# 内存分配机制 - 简书

# 内存分配机制

> 
 java程序运行在JVM(java Virtual Machine,java虚拟机）上，可以把JVM理解成java程序和操作系统之间的桥梁，JVM实现了java平台的无关性，由此可见JVM的重要性。所以在学习java内存分配原理的时候一定要牢记这一切都是在JVM中进行的，JVM是内存分配的基础和前提。一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。

#### JVM的体系结构包含几个主要的子系统和内存区：

> 
**垃圾回收器（Garbage Collection）**：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。

**类装载子系统（Classloader Sub-System）**：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。

**执行引擎（Execution Engine）**：负责执行那些包含在被装载类的方法中的指令。

**运行时数据区（Java Memory Allocation Area）**：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。


![](https://upload-images.jianshu.io/upload_images/3538963-750b22e7ad27896d.jpg)

#### java内存分区

> 
 运行数据区即是Java内存,而且数据区要存储的东西比较多，如果不对这块区域进行划分管理，会显得比较杂乱无章。因此根据存储数据的不同，java内存被划分为五个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Method Area）、栈（Stack）、堆（Heap）。

> 
**程序计数器（Program Count Register）**：又叫程序寄存器，JVM支持多个线程同时运行，当每一个线程被创建时	，它都将得到它自己的寄存器（程序计数器），如果线程正在执行时一个Java方法（非 native）,那么PC寄存器总是指向下一条将被执行的指令，如果方法是native,程序计数器的值不会被定义。JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。

> 
**栈（Stack）:又叫堆栈。**JVM为每个新创建的线程都分配一个栈。对一个JAVA程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道，某个线程正在执行方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当前线程激活一个Java方法，JVM就会在线程的堆栈里新压入一个帧，这个帧当然成为当前帧。在此方法执行期间，这个帧将用来保存参数，局部变量（包括：a.用来保存基本数据类型的值；b.保存类的实例，即堆区对象的引用（指针））；

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是 确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：

Java代码

int a = 3;

int b = 3;

编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。

这时，如果再令 a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响 到b的值。

要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。

对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。

形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。

成员变量存储在堆中的对象里面，由垃圾回收器负责回收。

如以下代码：

Java代码

1.class BirthDate {

2.    private int day;

3.    private int month;

4.    private int year;

5.    public BirthDate(int d, int m, int y) {

6.        day = d;

7.        month = m;

8.        year = y;

9.    }

10.    省略get,set方法………

11.}

12.

13.public class Test{

14.    public static void main(String args[]){

15.int date = 9;

16.        Test test = new Test();

17.           test.change(date);

18.        BirthDate d1= new BirthDate(7,7,1970);

19.    }

20.

21.    public void change1(int i){

22.        i = 1234;

23.    }

对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：

1. main方法开始执行：int date = 9;

date局部变量，基础类型，引用和值都存在栈中。

2. Test test = new Test();

test为对象引用，存在栈中，对象(new Test())存在堆中。

3. test.change(date);

i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。

4. BirthDate d1= new BirthDate(7,7,1970);

d1 为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。 day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。

5.main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(),new BirthDate()将等待垃圾回收。

-Xss --设置方法栈的最大

> 
**本地方法栈（Native Stack）**：存储本地方方法的调用状态。


![](https://upload-images.jianshu.io/upload_images/3538963-d8ed1f812cf98120.png)

> 
**方法区（Method Area）**：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。


![](https://upload-images.jianshu.io/upload_images/3538963-df1040a7105637ff.png)

> 
** 常量池 (constant pool)**

常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。

除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如：

◆类和接口的全限定名；

◆字段的名称和描述符；

◆方法和名称和描述符。

如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。

String是一个特殊的包装类数据。可以用：

Java代码

String str = new String("abc");

String str = "abc";

两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对 String类的对象引用变量str，然后通过符号引用去字符串常量池 里找有没有"abc",如果没有，则将"abc"存放进字符串常量池 ，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。

比较类里面的数值是否相等时，用equals()方法；当[测试](https://link.jianshu.com?t=http://lib.csdn.net/base/softwaretest)两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。

Java代码

String str1 = "abc";

String str2 = "abc";

System.out.println(str1==str2); //true

可以看出str1和str2是指向同一个对象的。

Java代码

String str1 =new String ("abc");

String str2 =new String ("abc");

System.out.println(str1==str2); // false

用new的方式是生成不同的对象。每一次生成一个。

因此用第二种方式创建多个”abc”字符串,在内存中 其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。

另 一方面, 要注意: 我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new()方法才能保证每次都创建一个新的对象。

String常量池问题的几个例子([http://blog.csdn.net/gaopeng0071/article/details/11741027](https://link.jianshu.com?t=http://blog.csdn.net/gaopeng0071/article/details/11741027))

> 
**堆（Heap）：**Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用确是在栈（stack）中分配。因此String s = new String("s")时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址,即指针）分配内存，如下图所示


![](https://upload-images.jianshu.io/upload_images/3538963-862837aee95e63ab.png)

> 
堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存 大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态 分配内存，存取速度较慢。

java虚拟机有一条在堆中分配新对象的指令，却没有释放内存的指令，正如你无法用java代码区明确释放一个对象一样。虚拟机自己负责决定如何以及何时释放不再被运行的程序引用的对象所占据的内存，通常，虚拟机把这个任务交给垃圾收集器（Garbage Collection）。其相关设置参数：

-Xms -- 设置堆内存初始大小

-Xmx -- 设置堆内存最大值


