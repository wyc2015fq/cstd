# C 和 C++ 的没落 - 文章 - 伯乐在线
本文由 [伯乐在线](http://blog.jobbole.com) - [Sheng Gordon](http://www.jobbole.com/members/shenggordon) 翻译，[黄利民](http://www.jobbole.com/members/huanglimin) 校稿。未经许可，禁止转载！
英文出处：[diego](http://blog.biicode.com/c-cpp-biggest-threats-modern-ecosystem/)。欢迎加入[翻译组](https://github.com/jobbole/translation-project)。
**C 和 C++ 的没落，不仅是因为 CPU 时钟周期的关系，而且因为关系到了开发者的时间**
全球大约有400万C和C++程序员，很可能是最大的社区了，约占20%的市场份额，不亚于Java，甚至还要更多一些（C和C++一起）。它们也是当前主流语言中最古老的语言之一，应用于重要行业。C和C++在工业与其他领域如物联网/嵌入式系统/机器人的协同方面非常重要，由于协同效应，它们的应用甚至还在增长。
（编注：英文原文写于今年 3 月 25 日。根据今年 7 月 JetBrains 的一个开发者调查，全球大约 440 万 C++ 程序员；大约 190 万 C 程序员。详情看伯乐在线的这篇文章《[全球有多少 C/C++ 程序员？Java 和 Python 又有多少？](http://blog.jobbole.com/93554/)》）。
C++ 是一门出色的语言，最近出现的C++11与14标准，以及即将到来的 C++17 标准，使其改进速度比以往都快的多。令人吃惊的是，其语法与其他“现代”语言越来越接近，例如Python。C语言是当前IT技术的坚实基础。C和C++的编译器、优化器、调试器以及IDE的工艺水平都是一流的。
![C-600x600-300x300](http://jbcdn2.b0.upaiyun.com/2015/03/b4346d1edadc055a7153a65782ba884c.png)
全球代码中，20%是C和C++
但是，如果有一天你想写一段简单且可重用的代码，并且希望能够通过一个串行端口发送一串“Hello World”的字符。
问一个python开发者。他会写$ pip install pyserial，并在几分钟内，他就能给出一个解决方案。
问一个C++开发者。首先在C++中没有类似pyserial的模块。C++号称对底层非常擅长。最接近的答案可能是Boost.Asio里面的串行端口了（这是StackOverflow上得票最高的答案）。然而仅仅下载Boost就可能花费比实现python方案更多的时间，并且它要求在一个异步框架中使用串行端口，对于这个任务来说，有杀鸡用牛刀之嫌。证据是在这个简单项目中要添加数百个文件。此外C++程序员通常必须手动添加IDE的包含路径，或者在项目中设置。
相反，python的pyserial库只有少数几个文件，并且有意思的是它大部分上是用C实现的。使用C++为这个串行端口的“Hello World”创建一个可复用的组件将要花费更多的努力，并且你需要在每台电脑上都需要安装一次Boost。
我绝不是在说Boost很差，实际上它非常出色。但是显然在C和C++开发过程中，低效率仍然存在。
在追求语言的潜力以及计算资源效率方面，「*不要为你不使用的东西付出（**don’t pay for what you don’t use**）」*的格言显然是正确的；但是在开发过程方面却是完全误导的。相比较其他开发语言，C和C++的开发过程是低效的。并且 [C++ 是付出代价最高的编程语言](http://tech.co/highest-paying-programming-languages-2015-03)。就是说，作为开发者，我们使用C和C++时不得不花费不少宝贵的时间，却不对我们的产品产生价值，相对于用其他语言开发的同事处于竞争劣势。
因此最大的问题不是语言本身，而是开发工具以及其生态系统。首先，对于不同的编译器和不同的选项以及库文件，**构建系统****(build system)**差异非常大。更糟糕的是，不同的构建系统不仅与操作系统相关，也与编译器相关。
幸运的是，这种情况下**CMake**就派上用场了。严格意义上来说，它不是一个构建系统，只是位于构建系统上层的一个工具，能够为各种不同的构建系统输出配置文件。CMake是跨操作系统项目的事实标准，而在单操作系统项目上的使用也越来越多。它很成熟并且强大，以很快的速度持续改进。新的项目如CLion IDE，直接使用CMake作为唯一支持的构建系统。这是一个很好的做法。虽然脚本的语法可以做的更好，但是平台一致性比任何其他因素重要的多。我认为C和C++社区普遍选择CMake，对每个人都将是巨大的胜利。向比特神祈求在每个项目中都能够找到CMakeLists.txt。
其次，但是更重要的是C和C++依赖管理器的缺失。Python中有pip，Java有Maven，Node有NPM，Ruby有bundler，Rust有cargo……不，apt或者类似的东西不是依赖管理器，否则这些语言不会提供自己的依赖管理器。在未来几年内C和C++最终将减少到一些非常核心的组件，就像今天的汇编一样。这将是C和C++语言走向没落的最终原因。
**真正的威胁：Rust与Go**
由于解释型语言和动态语言的不断进步，虚拟机与即时编译的进步在运行速度上创造了惊人的成绩，例如PyPy；支持C和C++生态系统的一些最好的技术如LLVM也促成了这些语言工具。但是，**真正的威胁来自于现代编译型语言，如****Rust****或者****Go**，它们学习了计算机语言几十年的优势，又没有需要维护的代码库。它们的语法有着非常便捷的特点（简单、并发、安全…），除此之外，依赖管理也很简单。简单的deps管理能够创造指数级别的循环增长。仅仅通过声明或者引入GUI、AI、graphics、server、serialization、ORM 等你需要集成到项目的库，你可以轻松地建立Rust或者Go应用程序、库或者系统。尽管C或C ++可以预期得到更好的性能，但是使用C或C++建立一个相同的项目需要花费更长的时间。
**不管语言如何改进，只要这个问题没有被解决，我心爱的****C****和****C++****语言的未来就是悲观的。**而开发出这样一个生态系统，那么它们不但不会下降，甚至会接管非传统领域，如Web应用和移动应用。
