# 二叉树的可视化 - 文章 - 伯乐在线
原文出处： [Bean_lee](http://blog.chinaunix.net/uid-24774106-id-3506024.html)
在我前面的一篇博文[数据结构之红黑树](http://blog.chinaunix.net/uid-24774106-id-3440620.html)中，提到了数据结构之可视化的重要性。 因为如果我们能将二叉树可视化，也能提高加快调试，减少bug。原文给出了print_tree函数，会打印二叉树，但是旋转了90度，不优美，不友好。最近学习了下Graphviz这个软件，学了下怎么用这个软件绘制图片，基本解决了二叉树的可视化问题。
我还是以我的红黑树代码为例子，写测试代码，看下如何将我们插入产生的红黑树可视化。
我们看下代码：

```
typedef unsigned long long ULL;
void __tree2dot(struct rbtree_node* node,FILE* stream)
{
    if(node->color == RB_BLACK)
    {
        fprintf(stream,"%llu [shape=box];n",*(ULL*)(node->key));
    }
    if(node->left)
    {
        
        fprintf(stream," %llu -> %llu;n",*(ULL*)(node->key),*(ULL*)(node->left->key));
        __tree2dot(node->left,stream);
    }
    if(node->right)
    {
        fprintf(stream," %llu -> %llu;n",*(ULL*)(node->key),*(ULL*)(node->right->key));
        __tree2dot(node->right,stream);
    }
}
int tree2dot(struct rbtree* tree,char* filename)
{
    assert(tree != NULL && filename != NULL);
    FILE* stream = fopen(filename,"w+");
    if(stream == NULL)
    {
        fprintf(stderr, "open failed n");
        return -1;
    }
    fprintf(stream,"digraph {n");
    __tree2dot(tree->root,stream);
    fprintf(stream,"}n");
    fclose(stream);
    return 0;
    
}
```
tree2dot接受一个二叉树和一个文件名作为入参。负责创建文件 关闭文件和填写dot文件有向图的格式头和尾。
__tree2dot是递归调用，添加父节点到子节点的有向连接。我们因为是红黑树，所以添加了这部分处理红黑结点的代码：


```
if(node->color == RB_BLACK)
    {
        fprintf(stream,"%llu [shape=box];n",*(ULL*)(node->key));
    }
```
这部分代码的作用对于黑节点，采用box类型表示节点，对于红节点，采用默认的椭圆图形。
比较才能看到进步，我们比较下新旧两种方法的输出：
![24774106_13622082049ngr](http://jbcdn2.b0.upaiyun.com/2016/11/a0099ce199a6124c476c59518976f3de.png)
在看下生成的dot文件（Ubuntu下用XDot打开）
![24774106_1362208373w5d8](http://jbcdn2.b0.upaiyun.com/2016/11/0acff8bb57161faafe6e5cf2596f214a.png)
下面这种的优越性，一目了然。这个方法目前有个缺点是没有将NULL节点处理，导致421看不出是386左孩子还是右孩子，我们改进下：


```
void process_null_node(struct rbtree_node* node, int nullcount, FILE* stream)
{
        fprintf(stream, " null%d [shape=hexagon];n", nullcount);
        fprintf(stream, " %llu -> null%d;n",*(ULL*)(node->key), nullcount);
}
void __tree2dot(struct rbtree_node* node,FILE* stream)
{
    static int null_node_cnt = 0;
    if(node->color == RB_BLACK)
    {
        fprintf(stream,"%llu [shape=box];n",*(ULL*)(node->key));
    }
    if(node->left)
    {
        
        fprintf(stream," %llu -> %llu;n",*(ULL*)(node->key),*(ULL*)(node->left->key));
        __tree2dot(node->left,stream);
    }
    else
    {
        process_null_node(node,null_node_cnt++,stream);
    }
    if(node->right)
    {
        fprintf(stream," %llu -> %llu;n",*(ULL*)(node->key),*(ULL*)(node->right->key));
        __tree2dot(node->right,stream);
    }
    else
    {
        process_null_node(node,null_node_cnt++,stream);
    }
}
```
我们将NULL节点处理成六边形，这样就能完整的看出红黑树的情况了，请看生成的dot文件：
![24774106_1362209439luon](http://jbcdn2.b0.upaiyun.com/2016/11/e5f7d952ad9d51130232fbb0e25e5938.png)
完整的代码在我的github上 ，可以去下面路径去取：
https://github.com/manuscola/rbtree
参考文献：
1 Drawing graphs with dot
