# C++最大的敌人是它的过去 - 文章 - 伯乐在线
原文出处： [codergears](http://www.codergears.com/Blog/?p=867)   译文出处：[慧都控件网](http://www.evget.com/article/2014/12/1/21882.html)
在过去的几年里，我们谈到了关于“C++的复兴”。我们不得不承认微软是这项运动中主要参与者，我记得在Craig Symonds和Mohsen Agsen在视频中提到了这件事。
在2011年，微软写了许多文章来宣布C++的回归，并且众多微软专家如Herb Sutter在很多会议上解释了为什么C++会重新崛起，主要原因是现代C++的推广使用。而同一时间。C++11标准的认可使我们重新把C++作为一门新的语言来讨论。
然而，截至到2011年，C++已经有超过30年的历史了。因此，让开发人员相信关于新的C++已经简化了过去许多令人失望的用法，而是使用了一种改进了C++代码的全新方法不是一件容易的事情。
让我们以内存管理为例，这也许是C++中最受争议的地方。多年来，对象的分配是通过new这个关键字来完成，开发者必须牢牢记住在代码中某些地方调用delete。“现代的C++”解决了这个问题并推进了共享指针的使用。
但是，关于现代C++的推广光靠活跃的C++社区和知名专家是不够的。有一句谚语是：“习惯成自然。”当你努力向某些人推介某个语言或者工具，他有可能觉得你有道理但是却不会照着你想的做。
这就是在C++上发生的事情，我们中的许多人仍然坚持使用new和delete，而这种影响还要持续很多年，而且许多非C++的开发者也会一直通过调用复杂的内存分配方式来使用这门语言。
C++的过去影响了很多东西甚至从项目的创建之初，许许多多的开发者仍然认为这门语言非常复杂。
**C++的过去是如何在影响着它？**
为了发现这点，我们来做一个测试，我们在网上搜索“C++对象分配”，查找第一个链接便是“*C++中是怎样分配堆对象的?唯一的方法就是用new…*”。这很令人吃惊，而搜索页前面谈论共享指针、智能指针的文章几乎没有。
另一个有趣的测试是到到任何大学的图书馆去找一本关于C++的书，去阅读关于对象分配的那一章节，你基本上不会找到关于“共享指针、智能指针”的介绍。
而C++开发者想要了解它们，一般查找的资源是来自于“C类”而不是现代C++。
**如何预防C++的过去所带来的影响？**
这里并没有特别有效的解决方案。我们可以希望C++编译器通过发出一些关于最新更新的启用和弃用警告，就象过去的字符串操作一样（strcpy、strcat*…*），但这个解决方案也不是根本的解决之道。现代C++新技术的推动需要学习和实践。
另外一个解决方案是将“C++”更名为“现代C++”，这个解决方案很简单也很有趣。在网络上搜索“现代C++”，那么在我们谈论的现代C++的对象分配问题上，第一个链接就谈论了“智能指针”。
因此，在未来的C++推广之路上，我们可以提醒新的C++开发者，在网络上查找关于C++的资料时，“现代C++”和“C++”会是两个非常不同的搜索结果，前者代表C++的最新用法，而后者只代表过去。
**本文翻译自[The first enemy of C++ is its past.](http://www.codergears.com/Blog/?p=867)**
