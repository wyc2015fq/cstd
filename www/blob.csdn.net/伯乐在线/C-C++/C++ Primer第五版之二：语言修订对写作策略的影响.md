# C++ Primer第五版之二：语言修订对写作策略的影响 - 文章 - 伯乐在线
[在上篇文章中，我提到了这样一个观点](http://blog.jobbole.com/25199/)：作者在采取修订的方式写书的时候，把新的内容自然地融入到全书当中，比直接把所有新内容砸到一个章节里显得更加合理。不过采取这样的做法，会给读者的学习造成一定的困难，尤其是在新加入的内容使得原有的知识更加抽象的前提下——根据我与C++打交道30年来的经验，C++的发展一直是让这门语言越来越抽象的。
下面举个例子说明这种现象。给C语言加上类的支持的最初目的，是为了让C++类能够向上兼容C的结构体。尤其是，在早期版本的拷贝构造函数里（大约是1984年左右的版本），如果没有显示定义拷贝构造函数，那么拷贝一个类的时候，仅仅是拷贝其内部的C结构体。那时的程序员管这种操作叫“按位拷贝”（bitwise copy）。这种拷贝行为在下面的例子中会产生问题：

C++
```
struct Person {
      String firstname, lastname;
};
```
当时还没有标准的string库，因此我使用String这个名字来强调这是一个用户自定义的类，用来实现多字符的串结构。
在早期的C++版本中，这个类将会成为一个灾难。因为String  类很可能包含了一个指针，这个指针会直接指向存放字符串内容的地址，指针在对Person对象进行拷贝时不会被简单地拷贝过去。这么做可能导致的结果就是，内存中的字符串和可能会面临两次free操作，一次是针对原来的Person对象，另一次是针对Person对象的拷贝。如此一来，使用这个版本C++的程序员就必须提供显示的拷贝构造函数来避免这个问题。

C++
```
struct Person {
      Person(const Person& p):
   firstname(p.firstname), lastname(p.lastname) { }
                         // and so on
      String firstname, lastname;
};
```
所有早期C++版本的教学材料都会教给你上面的技术，因为如果你不这么做的话，即使最简单的抽象过程也会导致严重的bug。显然，这些复杂的语言特性和随之带来的不便推动了对C++语言默认行为的改进：在进行默认对象拷贝时，不会再直接拷贝类的C结构体，C++编译器会遍历源类的结构，并递归地拷贝所有对象元素到目标对象。
![Barbara Moo——《C++ Primer 5th edition》的作者](http://jbcdn2.b0.upaiyun.com/2012/08/bmoo.jpg)
Barbara Moo——《C++ Primer 5th edition》的作者
设想如果你就是书的作者。通过你的书，你的程序练习例子，读者却感到使用显示拷贝构造函数是那么的困难，这多糟糕！还好，现在这门语言已经改进了，所有这些累赘的代码都不需要了。但是这时，还需要你作者干什么呢？
作为作者，你可以遍历全书，精于细节，找到每一个例子中曾经用到过那些累赘代码的片段，并进行简化或者彻底删掉重写，让各种细节都更加合理。或者，你可以增加一些章节，比如像“如何使用XXX新特性”这样的章节，用来向读者说明，之前的那些繁文缛节的代码已经不再需要了。
尽管第二个做法看上去比第一个做法要省力很多，但是修订版（第五版）的《C++ Primer》却采用了第一种策略。在C++11的语法中，很多代码的书写方式已经被简化了，不需要再像以前那么麻烦了。这个特性会在很大程度上影响到本书对于C++11关键知识点的介绍顺序。下周，我们会用具体的示例，来探讨一下C++语言究竟有哪些改变。
英文原文：[Andrew Koenig](http://www.drdobbs.com/cpp/c-primer-5th-edition-part-2-how-language/240004388)  编译：[伯乐](http://www.jobbole.com)在线 – [黄小非](http://blog.jobbole.com/25428/)
【如需转载，请标注并保留原文链接、译文链接和译者等信息，谢谢合作！】
