# C++11 新特性之容器相关特性 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [usher2007](http://www.jobbole.com/members/usher2007) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
前三篇在这里：
C++11新特性之新类型与初始化: [http://blog.jobbole.com/102728/](http://blog.jobbole.com/102728/)
C++11新特性之类型推断与类型获取: [http://blog.jobbole.com/104559/](http://blog.jobbole.com/104559/)
C++11新特性之lambda：[http://blog.jobbole.com/104548/](http://blog.jobbole.com/104548/)
这是C++11新特性介绍的第四部分，涉及到C++11这次更新中与容器有关的新特性。
不想看toy code的读者可以直接拉到文章最后看这部分的总结。
# cbegin和cend
原来的begin和end返回的iterator是否是常量取决于对应的容器类型，但是有时，即使容器不是常量类型，我们也希望获得一个const_iterator，以避免不必要的修改行为。C++11新标准中提供了cbegin和cend函数，无论容器类型，都固定返回const_iterator。


```
vector<int> c1 = {0, 1, 2, 3, 4};
auto it1_1 = c1.begin();
auto it1_2 = c1.cbegin();
*it1_1 = 4;
//*it1_2 = 5; // wrong, const iterator's value can't be changed via this iterator.
cout<<*it1_1<<'\t'<<*it1_2<<endl;
```
# 标准库的 begin 和 end
C++11新标准提供了begin和end函数，可以对普通数组使用，获得头指针和尾指针。


```
int c2[] = {0, 1, 2, 3, 4};
auto it2_1 = begin(c2);
auto it2_2 = end(c2);
while(it2_1 != it2_2)
{
	cout<<*it2_1<<'\t';
	it2_1++;
}
cout<<endl;
```
# 新的赋值方式
C++11允许使用一个{}包围的初始值列表来进行复制。如果等号左侧是个容器，那么怎么赋值由容器决定。


```
vector<int> c3;
c3 = {0, 1, 2, 3, 4};
for(auto it3_1 = c3.begin(); it3_1 != c3.end(); it3_1++)
	cout<<*it3_1<<'\t';
cout<<endl;
```
# initializer_list
C++11新标准中新增了initializer_list类型，其实在之前介绍初始化的那篇文章中，使用vector v = {0, 1, 2, 3, 4}这种初始化形式时，就隐式的使用了initializer_list：每当在程序中出现一段以{}包围的字面量时，就会自动构造一个initializer_list对象。
另外，initializer_list的另一个作用就在于作为函数的形参，这样的函数可以方便的传入以{}包围的不定长列表：


```
void print_list(initializer_list<int> il)
{
	for(auto it = il.begin(); it != il.end(); it++)
	{
		cout<<*it<<'\t';
		//*it = 100; // wrong. initializer_list element is read-only.
	}
	cout<<endl;
}
print_list({0, 1, 2, 3, 4});
print_list({0, 1, 2, 3, 4, 5});
```
但是，需要注意的是，initializer_list中的元素是只读的。
# array
C++11标准中提供了定长数组容器array，相比于普通数组更安全、更易使用。array是定长数组，所以不支持诸如插入、删除等改变容器大小的操作，但是可以对元素进行赋值改变其值。


```
array<int, 5> c4 = {0, 1, 2, 3, 4};
c4[3] = 100; // can't insert since the array size is fixed.
for(auto it4_1 = c4.begin(); it4_1 != c4.end(); it4_1++)
{
	cout<<*it4_1<<'\t';
}
cout<<endl;
```
# forward_list
C++11标准中增加了新的容器forward_list，提供了一个快速的、安全的单向链表实现。因为是单向链表，所以也就没有rbegin、rend一类的函数支持了。
同样是因为单向链表的缘故，无法访问到给定元素的前驱，所以没有提供insert函数，而对应提供了一个insert_after函数，用于在给定元素之后插入节点。erase_after、emplace_after同理。


```
forward_list<int> c5 = {3, 4};
c5.push_front(2);
c5.push_front(1);
auto it5_1 = c5.before_begin();
c5.insert_after(it5_1, 0);
for(auto it5_2 = c5.begin(); it5_2 != c5.end(); it5_2++)
{
	cout<<*it5_2<<'\t';
}
cout<<endl;
```
# swap
新标准中提供了非成员版本的swap操作，此操作对array容器，会交换元素的值；对其他容器，则只交换容器的内部结构，并不进行元素值的拷贝操作，所以在这种情况下是非常迅速的。
正因如此，当swap array后，原来array上的迭代器还依然指向原有元素，只是元素的值变了；
而swap非array容器之后，原来容器上的迭代器将指向对方容器上的元素，而指向的元素的值却保持不变。


```
vector<int> c6 = {0, 1, 2, 3, 4};
vector<int> c7 = {5, 6, 7, 8, 9};
auto it6_1 = c6.begin();
auto it7_1 = c7.begin();
swap(c6, c7);
for(auto it6_2 = c6.begin(); it6_2 != c6.end(); it6_2++)
	cout<<*it6_2<<'\t';
cout<<endl;
	
for(auto it7_2 = c7.begin(); it7_2 != c7.end(); it7_2++)
	cout<<*it7_2<<'\t';
cout<<endl;
cout<<(it6_1 == c7.begin())<<'\t'<<(it7_1 == c6.begin())<<endl;
array<int, 5> c8 = {0, 1, 2, 3, 4};
array<int, 5> c9 = {5, 6, 7, 8, 9};
auto it8_1 = c8.begin();
auto it9_1 = c9.begin();
swap(c8, c9);
cout<<(it8_1 == c8.begin())<<'\t'<<(it9_1 == c9.begin())<<endl;
```
# emplace
emplace操作将使用接受的参数构造一个对应容器中的元素，并插入容器中。这一点，使用普通的insert、push操作是做不到的。


```
class TestData
{
	public:
		TestData(string name, int age, double salary): name(name), age(age), salary(salary)
		{}
	private:
		string name;
		int age;
		double salary;
};
vector<TestData> c10;
c10.emplace_back("yubo", 26, 100000000000.0);
//c10.push_back("laowang", 56, 10.5); // wrong. no 3 params push_back
c10.push_back(TestData("laowang", 56, 10.5));
cout<<c10.size()<<endl;
```
# shrink_to_fit
一般可变长容器会预先多分配一部分内存出来，以备在后续增加元素时，不用每次都申请内存。所以有size和capacity之分。size是当前容器中存有元素的个数，而capacity则是在不重新申请内存的情况下，当前可存放元素的最大数目。而shrink_to_fit就表示将capacity中的多余部分退回，使其回到size大小。但是，这个函数的具体效果要依赖于编译器的实现……


```
vector<int> c11;
for(int i = 0; i < 24; i++)
	c11.push_back(i);
cout<<c11.size()<<'\t'<<c11.capacity()<<endl;
c11.shrink_to_fit();
cout<<c11.size()<<'\t'<<c11.capacity()<<endl;
```
# 无序关联容器
C++11新标准中引入了对map、set等关联容器的无序版本，叫做unorderer_map\/unordered_set。
无序关联容器不使用键值的比较操作来组织元素顺序，而是使用哈希。这样在某些元素顺序不重要的情况下，效率更高。


```
unordered_map<string, int> c12;
map<string, int> c13;
string string_keys[5] = {"aaa", "bbb", "ccc", "ddd", "eee"};
for(int i = 0; i < 5; i++)
{
	c12[string_keys[i]] = i;
	c13[string_keys[i]] = i;
}
cout<<"normal map:\n";
for(auto it13 = c13.begin(); it13 != c13.end(); it13++)
	cout<<it13->first<<':'<<it13->second<<'\t';
cout<<endl;
cout<<"unordered map:\n";
for(auto it12 = c12.begin(); it12 != c12.end(); it12++)
	cout<<it12->first<<':'<<it12->second<<'\t';
cout<<endl;
```
# tuple
熟悉python的程序员应该对tuple都不陌生，C++11中也引入了这一数据结构，用于方便的将不同类型的值组合起来。
可以通过如下方式，获取tuple中的元素、tuple的长度等：


```
//tuple<int, string, vector<int>> c14 = {1, "tuple", {0, 1, 2, 3, 4}}; // wrong. must explicit initialize
tuple<int, string, vector<int>> c14{1, "tuple", {0, 1, 2, 3, 4}};
get<0>(c14) = 2;
typedef decltype(c14) ctype;
size_t sz = tuple_size<ctype>::value;
cout<<get<0>(c14)<<'\t'<<get<1>(c14)<<'\t'<<get<2>(c14)[0]<<'\t'<<sz<<endl;
```
总结
- cbegin和cend提供了固定获取const_iterator的方式。
- begin和end用于普通数组获得首尾指针。
- 可以使用{}包围的初始值列表进行赋值。
- 增加initializer_list类型用于方便的使用{}包围的不定长列表。
- 增加新的定长数组容器array 单向链表容器forward_list。
- 增加非成员函数版本的swap操作。对array swap只交换元素值，而容器的结构不变；对其他容器则只改变容器数据结构，而元素值不变。
- 增加emplace操作用于将参数传递给构造函数构造元素并插入容器。
- 增加shrink_to_fit函数用于退回多余的空间。
- 增加无序关联容器。
- 增加tuple容器。
完整代码详见[container.cpp](https://github.com/yubo1911/saber/blob/master/learncpp11/container.cpp)
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
任选一种支付方式
![](http://jbcdn2.b0.upaiyun.com/2016/08/a41e08fcaca939c581c931c115da0a8d.png)![](http://jbcdn2.b0.upaiyun.com/2016/08/c07df7ab8dad3a49f6ce602eb7d62949.jpg)
