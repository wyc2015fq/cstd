# 面向指针编程 - 文章 - 伯乐在线
原文出处： [garfileo](https://segmentfault.com/a/1190000004200708)
面向对象编程，面向设计模式编程（亦即设计模式），面向接口编程，面向模板编程（亦即泛型编程），面向函数编程（亦即函数式编程），面向多核时代的并行编程，面向大数据的机器学习编程……这么多年，大家要面向的东西已经够多了，然而我看到的现象是，很多编程语言让大家面向 xxx 的同时在竭力回避指针。我可不想面向这么多东西，所以我只好加入指针的黑暗势力。我要不自量力的来写一篇《面向指针编程》作为投名状，借以表示我与软件世界的光明势力的彻底决裂。
这个世界上，提供指针的编程语言很少，这样的语言有汇编语言、C/C++ 以及 Pascal 等。Pascal 我没学过。汇编语言过于黑暗，我现在功力还不足以驾驭它。C++，我觉得它简直是黑暗势力中的败类——它试图挣脱指针，走向光明，结果却出了一堆幺蛾子。所以我还是俗套的选 C 语言来阐述指针的黑暗力量。
阅读本文之前，请读三遍无名师说的话：**当尊者 Ritchie 发明 C 时，他将程序员放到缓冲溢出、堆损坏和烂指针 bug 的地狱中惩罚**。然后自我安慰一下，如果地狱未能使我屈服，那么我会比地狱更黑暗更强大。
# 指针是什么？
内存是以字节为单位的一个很大但是又经常不够用的空间。指针是内存中 x 个连续的字节中存储的数据——在 32 位的机器上，x 的值为 4；在 64 位机器上，x 值为 8。为了叙述的简便，本文只在 64 位的机器上谈论指针。
指针是一种数据，这没什么稀奇的。从机器的角度来看，程序的一切是存放在数组中的数据。只有那些自作多情的程序猿才会像亚里士多德一样自作多情的认为程序是由对象 + 方法或者许多函数复合而成的。事实上，从最远离机器的 Lisp 语言的角度来看，程序的一切也都是数据，存放在表中的数据。如果忽视程序本身就是数据这个客观事实，程序猿们很容易就走上了形而上学的道路，然后他们会度过漫长的、罪恶的、痛苦的中世纪，膜拜着一个又一个神棍，当然期间也出现了几位圣·奥古斯丁。
那么，指针中存储着什么数据？内存地址。
内存是以字节为单位的空间，其中每个字节都伴随着一个地址，这个地址机器赋予的，并不是我们的程序编制的。你可以将整个内存空间想象成一栋大楼，将字节想象为大楼中每个房间，将每个字节的地址想象为房间的门牌号，于是指针中存储的数据就类似于门牌号。
如果你从未学过 C 语言，读到此处可能会问，我们为什么要在内存中存储内存地址？不知你是否住过宾馆。在正规的宾馆里，每个房间的门后都会贴着逃生路线图，图中『存储』了该宾馆与你的房间同一楼层内的全部房间的门牌号以及它们的布局。如果你住酒店时从来也不看逃生路线图，那么从现在开始，入住酒店后第一件事就是认真的看一下它，关键时刻它能救你一命。在内存中存储内存地址，虽然不是救你性命的，但是可以藉此构造与宾馆逃生路线图相似的抽象事物——内存数据的抽象与复合。
![](http://jbcdn2.b0.upaiyun.com/2016/03/1f0a6fef6c2d5b68bad02162be963e8e.png)
# 内存空间的有名与无名
现在来看两行 C 代码：

C
```
int foo = 10;
 int *bar = &foo;
```
`foo` 是什么？`foo` 表示一个内存地址。`foo` 前面的 `int` 是数据类型修饰，它表示 `foo` 是内存中 4 个连续字节的首字节地址（ 64 位机器上，`int` 类型的数据长度为 4 个字节）。C 编译器总是会根据某个内存地址相应的类型来确定以该内存地址起始的一段连续字节中所存储的数据的逻辑意义。因此，当我们用 `int` 类型来修饰 `foo`，编译器就会认为以 `foo` 开始的连续 4 个字节中存储的数据是一个整型数据。在上述代码中，这个整型数据是 `10`，我们通过赋值运算符 `=` 将这个整型数保存到内存中以 `foo` 地址开始的连续 4 个字节中。
从此刻开始，要记住一个事实，那就是 **C 语言中所有的变量名，本质上都是内存地址**。之所以不直接使用内存地址，而是使用一些有意义的名字，这就类似于没人愿意用你的身份证号来称呼你，大家更愿意用你的姓名来称呼你。
由于 C 语言认为数据的长度是由其类型确定的。例如，`int` 类型的数据长度是 4 个字节，`char` 类型的数据长度是是 1 个字节，用户自定义的 `struct` 类型的数据长度则是根据实际情况而待定。在这种情况下，所有表示内存地址的名字，它们实质上表示的是内存中各种类型数据存储空间的起始地址——专业一点，就是**基地址**。凡是用名字来表示基地址的内存空间，我们就将其称为**有名的内存空间**。
再来看 `bar` 是什么？`bar` 是内存地址的名字，由于 `bar` 前面有个 `*` 号，这表示我们打算在以 bar 为基地址的连续 8 个字节中存储一个内存地址（别忘了，我们是在 64 位机器上，指针数据的长度是 8 个字节）——`foo` 所表示的那个地址，亦即 `&foo`。在这里， `&` 是取值符，它会对 `foo` 说，你甭给我耍花样了，老实交代你的身份证号！在`*` 之前还有 `int`，这意味着在以 bar 为基地址的连续 8 个字节中存储的那个内存地址是某个用于存储整型数据的内存空间的基地址。
由于 `bar` 是某个内存空间的基地址，而这个内存空间中存储的是一个内存地址，所以 `bar` 就是所谓的指针。在这里，我们可以认为 `bar` 是对某块以 `foo` 为基地址的内存空间的『引用』，也就是在一个房间号为 `bar` 的房间里存储了房间号 `foo`。按照 C 语言教材里常用的说法，可将 `int *bar = &foo` 这件事描述为『指针 `bar` 指向了整型变量 `foo`』，然而事实上内存里哪有什么针，哪有什么指向？一切都是内存空间的引用。在上面的例子里，我们是用 `foo` 来直接引用某个内存空间，然后又使用 `bar` 来间接引用某个内存空间。
在上面的例子里，`bar` 引用的是一个有名的内存空间。那么有没有无名的内存空间呢？看下面的代码：

C
```
int *bar = malloc(sizeof(int));
```
`malloc(sizeof(int))` 就是一个无名的内存空间，因为它是一个表达式，而这个表达式描述的是一系列行为，行为需要借助动词来描述，而无法用名词来描述。比如『我在写文章』，这种行为无法只使用名词来描述，必须借助动词。任何会终止的行为都可表示为一系列的状态的变化，也就是说任何会终止的行为都会产生一个结果，而这个结果可以用名词来描述。例如 `malloc(sizeof(int))` 这个行为就是可终止的，它的结果是它在内存所开辟 4 个字节的空间的基地址，这个基地址是没有名字的，所以它就是个无名的基地址，因此它对应的内存空间就是**无名的内存空间**。在上例中，我们将这个无名的内存空间的基地址保存到了一个有名的内存空间——以 `bar` 为基地址的内存空间。
C 语言的创始人—— Dennis Ritchie 与 Brian Kernighan 将带名字的存储空间称为**对象**（Object）——并非『面向对象编程』中的对象，然后将指代这个对象的表达式称为**左值**（lvalue）。也就是说，在 C 语言中，上例中的 `foo` 与 `bar` 都是左值，因为它们总是能够出现在赋值符号的左侧。
看下面的代码：

C
```
int foo = 10;
int *bar = &foo;
printf("%d", *bar);
```
第三行的 `printf` 语句中的 `*bar` 也是一个左值，因为它指代了一个有名字的存储空间，这个存储空间的名字就叫做 `*bar`。这个存储空间其实就是以 `foo` 为基地址的存储空间。在表达式 `*bar` 中， `*` 号的作用是**解引用**，就是将以 `bar` 为基地址的内存空间中存储的内存地址取出来，然后去访问这个内存地址对应的内存空间。由于 `*bar` 的类型是 `int`，所以程序自身就可以知道要访问的是以 `*bar` 为基地址的 4 个字节，因此它可以准确无误的将整型数据 `10` 取出来并交给 `printf` 来显示。
指针最黑暗之处在于，当你拿到了一块内存空间的基地址之后，你可以借助这个基地址随意访问内存中的任何区域！也就是说，你可以从通过指针获得内存空间的入口，然后你可以让你的程序在内存中随便逛，随便破坏，然后你的程序可能就崩溃了。你的程序如果隐含缓冲区溢出漏洞，它甚至可被其他程序控制着去执行一些对你的系统非常不利的代码，这就是所谓的**缓冲区溢出攻击**。C 语言不提供任何缓冲区保护机制，能否有效保护缓冲区，主要取决于你的 C 编程技艺。
> 
现在我们写 C 程序时，基本上不需要担心自己的程序会遭遇缓冲区溢出攻击。因为只有那些被广泛使用的 C 程序才有这种风险；如果很不幸，你写的 C 程序真的被很多人使用了，那也不需要太担心。《深入理解计算机系统》在 3.12 节『存储器的越界引用和缓冲区溢出』中告诉我们，现代操作系统对程序运行时所需要的栈空间是随机生成的，导致攻击者很难获得栈空间中的某个确定地址，至少在 Linux 系统中是这样子。C 语言编译器提供了栈破坏检测——至少在 GCC 中是这样，其原理就是程序的栈空间放置了一只『金丝雀』，程序在运行中一旦发现有袭击『金丝雀』的可耻代码，它就会异常终止。处理器层面也对可执行代码所在的内存区域进行了限定，这样攻击者很难再向程序的栈空间插入攻击系统的可执行代码了。
# 栈与堆
如果我说 C 语言是一种部分支持垃圾内存回收的语言……你可能会认为我脑子坏掉了。事实上，C 语言中的所有的局部变量包括指针超出作用域时，它们所占据的存储空间都会被『回收』。这算不算内存垃圾回收？
从 C 程序的角度来看，内存并非一个以字节为单位的一个很大但是又经常不够用的空间，不是一个，而是两个。其中一个空间叫栈，另一个空间叫堆。可被 C 程序『回收』存储空间是栈空间。也就是说，在一个函数中，所有的局部变量所占据的存储空间属于栈空间。可能再说的学术一点，就是绝大多数左值都在栈空间（**有人在很遥远的地方指出，全局变量是左值，但它不在栈空间，它与程序同寿，与进程齐光**）。
当一个函数运行结束，它所占据的栈空间就不再属于它了，而是将会被一个新的待运行的函数占据。所以，从本质上说，C 程序对栈空间的回收都不屑一顾，因为它根本不回收，而是旧的数据会被新的数据覆盖。
堆空间，我们在程序里无法直接访问，只能借助指针。因为堆空间的内存地址可被指针引用。例如，当使用 `malloc` 分配空间时，所分配空间的基地址总是保存在一个位于栈空间的指针中的。
栈空间通常远远小于堆空间，即便如此也几乎不会出现某个函数会耗尽栈空间的现象。如果这种现象出现了，那只能证明造出这种现象的程序猿应该继续学习 C 语言了。栈空间被耗尽，往往是因为有些程序本来是写成递归，但可能是代码写错了，导致递而不归；还有一种可能是递归层次太深，这时可以想办法在堆空间中模拟一个栈来解决。还有一种情况就是在函数中定义了很大的数组，导致栈空间放不下……这种情况总是可以靠分配堆空间来解决。
# 数据的抽象
当你具备了一些 C 编程基础，并且能够理解上文中的内容，那么你就可以对各种类型的数据进行抽象了。
我们为什么要对数据进行抽象？《计算机程序的构造和解释》的第 2 章的导言部分给出了很好的答案，即：许多程序在设计时就是为了模拟复杂的现象，因为它们就常常需要构造出一些运算对象，为了能够模拟真实世界中的现象的各个方面，需要将运算对象表示为一些组件的复合结构。
下面来对自行车链的任意一个链节进行模拟：
![](http://jbcdn2.b0.upaiyun.com/2016/03/b06a425e8c2607d6f91137feae893822.jpeg)

C
```
struct chain_node {
        struct chain_node *prev;
        struct chain_node *next;
        void *shape;
};
```
然后我们可以造出 3 个链节，然后可以造出世界上最短的车链：

C
```
struct chain_node a, b, c;
a.next = &b;
b.prev = &a;
b.next = &c;
c.prev = &b;
c.next = &a;
a.prev = &c;
```
如果再多造一些链节，就可以得到周长大一些的车链，也能够制造出各种形状的多边形，但是最好是借助无名的内存空间。下面的代码可以创建一条具有 1000 个链节的链条：

C
```
struct chain_node *head = malloc(sizeof(struct chain_node));
struct chain_node *tail = head;
for (int i = 0; i next = new_tail;
        new_tail->prev = tail;
        tail = new_tail;
}
tail->next = head;
head->prev = tail;
```
如果我们将前面那个示例中的 `a`，`b`, `c` 视为三角形的三个顶点，那么我们所创造的三个链节构成的链条就变成了一个三角形。同理，上述所创建的 1000 个链节的链条就变成了一个 1000 条边首尾相接的多边形。如果学过拓扑学，那么自然可以发现任何与圆环同胚的结构都可以基于 `struct chai_node` 这种数据结构模拟出来，而我们所仰仗的东西仅仅是将三个指针封装到一个结构体中。
事实上，`struct chain_node` 中的第三个指针 `void *shape` 还没被用到。这是一个 `void *` 类型的指针，是喜欢用 C 代码玩各种抽象的程序猿的最爱，因为它能引用任何类型数据所在内存空间的基地址。这就意味着 `struct chain_node` 可以借助 `shape` 指针获得强大的扩展能力。
现在，我要制造一种很简陋的链节，它的形状仅仅是一个矩形的小铁片，上面打了两个小圆孔。我将它的数据结构设计为：

C
```
struct point {
        double x;
        double y;
};
struct rectangle {
        double width;
        double height;
};
struct circle {
        struct point *center;
        double radius;
};
struct chain_node_shape {
        struct rectangle *body;
        struct circle *holes[2] ;
};
```
基于这些数据结构，我就可以写出一个专门用来制造矩形小铁片的函数：

C
```
struct chain_node_shape *
create_chain_node_shape(struct circle *c1,
                        struct circle *c2,
                        struct rectangle *rect) 
{
        struct chain_node_shape *ret = malloc(sizeof(struct chain_node_shape));
        ret->body = rect;
        ret->holes[0] = c1;
        ret->holes[1] = c2;
        return ret;
}
```
然后再为 `create_chain_node_shape` 所接受的两种参数写出相应的构造函数：

C
```
struct circle *
create_circle(struct point *center, double radius)
{
        struct circle *ret = malloc(sizeof(struct circle));
        ret->center = center;
        ret->radius = radius;
        return ret;
}
struct rectangle *
create_rectangle(double w, double h)
{
        struct rectangle *ret = malloc(sizeof(struct rectangle));
        ret->width = w;
        ret->height = h;
        return ret;
}
```
为了让 `create_circle` 更方便使用，最好再创建一个 `struct point` 的构造函数：

C
```
struct point *
create_point(double x, double y)
{
        struct point *ret = malloc(sizeof(struct point));
        ret->x = x;
        ret->y = y;
        return ret;
}
```
一切所需要的构件都已准备完毕，现在可以开始生产某种特定型号的链节了，即：

C
```
struct chain_node *
create_chain_node(void)
{
        double radius = 0.5;
        double left_x = 1.0;
        double left_y = 1.0;
        struct point *left_center = create_point(left_x, left_y);
        struct circle *left_hole = create_circle(left_center, radius);
        double right_x = 9.0;
        double right_y = 1.0;
        struct point *right_center = create_point(right_x, right_y);
        struct circle *right_hole = create_circle(right_center, radius);
        struct rectangle *body = create_rectangle(10.0,  2.0);
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = create_chain_node_shape(left_hole, right_hole, body);
        return ret;
}
```
最后再将制造链条的代码略作修改：

C
```
struct chain_node *head = create_chain_node();
struct chain_node *tail = head;
for (int i = 0; i next = new_tail;
        new_tail->prev = tail;
        tail = new_tail;
}
tail->next = head;
head->prev = tail;
```
现在我们所模拟的车链与现实中的车链已经有些形似了。上述代码虽然有些冗长，下文会对其进行重构，现在先来总结一下上述代码中指针的用法。
仔细观察上述代码中我们所定义的结构体，它们的共同特征是：**所有非 C 内建的数据类型都是结构体类型，当它们作为某个结构体成员类型时均被声明为指针类型**。为什么要这样？如果你真的打算问这个问题，那么就请你观察一下上述的 5 个 `create_xxx` 函数，你会发现这些 `create` 函数的参数与返回值也都是结构体类型的指针。将这些现象综合起来，可以得出以下结论：
- 将结构体指针作为函数的参数与返回值，可以避免函数调用时发生过多的内存复制。
- 当一个结构体类型作为其他结构体的成员类型时，将前者声明为指针类型，可以在后者的 `create` 函数中避免繁琐的解引用。
- `void *` 指针可以引用任意类型的数据存储空间的基地址。例如在 `create_chain_node` 函数的定义中，我们将一个 `struct chain_node_shape` 类型的指针赋给了 `void *` 类型的指针 `shape`。
这三条结论是指针在数据抽象中的惯用手法，它不仅关系到数据结构的设计，也关系到数据结构的构造与销毁函数的设计。（上述代码为了省事，没有定义数据结构的销毁函数）
# 数据再抽象
上一节的代码有些冗长，我们可以尝试对其进行精简。首先看下面这三个结构体及其 `create` 函数：

C
```
struct point {
        double x;
        double y;
};
struct rectangle {
        double width;
        double height;
};
struct circle {
        struct point *center;
        double radius;
};
struct chain_node_shape {
        struct rectangle *body;
        struct circle *holes[2] ;
};
struct point *
create_point(double x, double y)
{
        struct point *ret = malloc(sizeof(struct point));
        ret->x = x;
        ret->y = y;
        return ret;
}
struct circle *
create_circle(struct point *center, double radius)
{
        struct circle *ret = malloc(sizeof(struct circle));
        ret->center = center;
        ret->radius = radius;
        return ret;
}
struct rectangle *
create_rectangle(double w, double h)
{
        struct rectangle *ret = malloc(sizeof(struct rectangle));
        ret->width = w;
        ret->height = h;
        return ret;
}
struct chain_node_shape *
create_chain_node_shape(struct circle *c1,
                        struct circle *c2,
                        struct rectangle *rect) 
{
        struct chain_node_shape *ret = malloc(sizeof(struct chain_node_shape));
        ret->body = rect;
        ret->holes[0] = c1;
        ret->holes[1] = c2;
        return ret;
}
```
显然，这些代码长的太像了！那四个结构体都是存储两个成员的结构体，而相应的 `create` 函数也无非是将函数所接受的参数保存到结构体成员中。有没有办法用很少的代码来表示它们？有！
既然每个结构体都保存 2 个成员，那么我们就先将上述代码删掉，然后定义一个 `pair` 类型的结构体：

C
```
struct pair {
        void *first;
        void *second;
};
```
在 `pair` 结构体中，我们用了两个 `void *` 指针，只有如此我们方能很自信的说 `pair` 可以存储任意类型的两个数据。接下来，只需修改 `create_chain_node` 函数的定义：

C
```
struct chain_node *
create_chain_node(void)
{
        double *left_x = malloc(sizeof(double));
        double *left_y = malloc(sizeof(double));
        *left_x = 1.0;
        *left_y = 1.0;
        struct pair *left_center = malloc(sizeof(struct pair));
        left_center->first = left_x;
        left_center->second = left_y;
        double *left_radius = malloc(sizeof(double));
        *left_radius = 0.5;
        struct pair *left_hole = malloc(sizeof(struct pair));
        left_hole->first = left_center;
        left_hole->second = left_radius;
        double *right_x = malloc(sizeof(double));
        double *right_y = malloc(sizeof(double));
        *right_x = 9.0;
        *right_y = 1.0;
        struct pair *right_center = malloc(sizeof(struct pair));
        right_center->first = right_x;
        right_center->second = right_y;
        double *right_radius = malloc(sizeof(double));
        *right_radius = 0.5;
        struct pair *right_hole = malloc(sizeof(struct pair));
        right_hole->first = right_center;
        right_hole->second = right_radius;
        struct pair *holes = malloc(sizeof(struct pair));
        holes->first = left_hole;
        holes->second = right_hole;
        struct pair *body = malloc(sizeof(struct pair));
        double *width = malloc(sizeof(double));
        *width = 10.0;
        double *height = malloc(sizeof(double));
        *height = 2.0;
        body->first = width;
        body->second = height;
        struct pair *shape = malloc(sizeof(struct pair));
        shape->first = body;
        shape->second = holes;
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
我勇敢的承认这个基于 `struct pair` 的 `create_chain_node` 函数太丑陋了，但是我们总算是消除了大量的结构体及其构造函数了，而且整体代码量减少了大约 1/6。
仔细观察上述代码，显然下面的三段代码存在着高度的重复：

C
```
double *left_x = malloc(sizeof(double));
        double *left_y = malloc(sizeof(double));
        *left_x = 1.0;
        *left_y = 1.0;
        struct pair *left_center = malloc(sizeof(struct pair));
        left_center->first = left_x;
        left_center->second = left_y;
        double *right_x = malloc(sizeof(double));
        double *right_y = malloc(sizeof(double));
        *right_x = 9.0;
        *right_y = 1.0;
        struct pair *right_center = malloc(sizeof(struct pair));
        right_center->first = right_x;
        right_center->second = right_y;
        struct pair *body = malloc(sizeof(struct pair));
        double *width = malloc(sizeof(double));
        *width = 10.0;
        double *height = malloc(sizeof(double));
        *height = 2.0;
        body->first = width;
        body->second = height;
```
这三段代码都在向 `pair` 结构体中存入两个 `double *` 类型的数据。既然如此，我们可以专门写一个函数，让它生成面向 `double *` 的 `pair` 结构体，即：

C
```
struct pair *
pair_for_double_type(double x, double y)
{
        struct pair *ret = malloc(sizeof(struct pair));
        double *first = malloc(sizeof(double));
        double *second = malloc(sizeof(double));
        *first = x;
        *second = y;
        ret->first = first;
        ret->second = first;
        return ret;
}
```
然后再次重构 `create_chain_node` 函数：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_center = pair_for_double_type(1.0, 1.0);
        double *left_radius = malloc(sizeof(double));
        *left_radius = 0.5;
        struct pair *left_hole = malloc(sizeof(struct pair));
        left_hole->first = left_center;
        left_hole->second = left_radius;
        struct pair *right_center = pair_for_double_type(9.0, 1.0);
        double *right_radius = malloc(sizeof(double));
        *right_radius = 0.5;
        struct pair *right_hole = malloc(sizeof(struct pair));
        right_hole->first = right_center;
        right_hole->second = right_radius;
        struct pair *holes = malloc(sizeof(struct pair));
        holes->first = left_hole;
        holes->second = right_hole;
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = malloc(sizeof(struct pair));
        shape->first = body;
        shape->second = holes;
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
# 山重水复疑无路
经过再次重构后的 `create_chain_node` 看上去要好了一些，但是依然有两段代码存在高度重复：

C
```
struct pair *left_center = pair_for_double_type(1.0, 1.0);
        double *left_radius = malloc(sizeof(double));
        *left_radius = 0.5;
        struct pair *left_hole = malloc(sizeof(struct pair));
        left_hole->first = left_center;
        left_hole->second = left_radius;
        struct pair *right_center = pair_for_double_type(9.0, 1.0);
        double *right_radius = malloc(sizeof(double));
        *right_radius = 0.5;
        struct pair *right_hole = malloc(sizeof(struct pair));
        right_hole->first = right_center;
        right_hole->second = right_radius;
```
但是仅从 `pair` 结果体层面已经无法对这两段代码进行简化了，而且我又非常不想写一个像下面这样的辅助函数：

C
```
struct pair *
create_hole(struct pair *center, double radius)
{
        struct pair *ret = malloc(sizeof(struct pair));
        double *r = malloc(sizeof(double));
        *r = radius;
        ret->first = center;
        ret->second = r;
        return ret;
}
```
虽然 `create_hole` 能够将上述两段重复的代码简化为：

C
```
struct pair *left_center = pair_for_double_type(1.0, 1.0);
        struct pair *left_hole = create_hole(left_center, 0.5);
        struct pair *right_center = pair_for_double_type(9.0, 1.0);
        struct pair *right_hole = create_hole(right_center, 0.5);
```
但是与 `pair_for_double_type` 函数相比，`create_hole` 这个函数的应用范围非常狭小。由于 `pair_for_double_type` 函数可以将两个 `double` 类型的数据存储到 `pair` 结构体中，在我们的例子中创建二维点与矩形可以用到它，在科学计算中创建极坐标、复数以及所有的二次曲线方程式也都都能用到它，但是 `create_hole` 却只能在创建车链这件事上有点用处。也就是说，正是因为 `pair_for_double_type` 函数所取得的成功，导致我们认为 `create_hole` 的品味太低。我们应该想一想还有没有其他途径可以消除上述代码的重复。
仔细分析 `left_hole` 与 `right_hole` 的构造过程，不难发现 `hole` 的 `center` 与 `radius` 这两种数据的类型不一致是造成我们难以对上述重复的代码进行有效简化的主要原因，`create_hole` 之所以能够对上述重复的代码进行大幅简化，是因为它根据我们的问题构造了一个特殊的 `pair` 结构体——姑且称之为 X，这个结构体的特殊之处在于其 `first` 指针存储的是一个面向 `double *` 的同构类型的 `pair` 结构体，其 `second` 指针则存储了一个 `double` 类型数据的基地址。正是因为 X 的结构太特殊了，所以导致 `create_hole` 这种抽象的应用范围过于狭隘，以至于现实中只有圆形比较符合这种结构体。
既然是异构的 `pair`，而我们已经实现了一个可以创建存储 `double` 类型数据的 `pair` 的函数 `pair_for_double_type`，这个函数的结果是可以直接存入异构 `pair` 中的。现在我们缺少只是一个可以将 `double` 值转化为可直接存入异构 `pair` 的函数，即：

C
```
double *
malloc_double(double x)
{
        double *ret = malloc(sizeof(double));
        *ret = x;
        return ret;
}
```
有了这个函数，就可以对 `create_chain_node` 继续进行简化了：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_hole = malloc(sizeof(struct pair));
        left_hole->first = pair_for_double_type(1.0, 1.0);;
        left_hole->second = malloc_double(0.5);
        struct pair *right_hole = malloc(sizeof(struct pair));
        right_hole->first = pair_for_double_type(9.0, 1.0);;
        right_hole->second = malloc_double(0.5);
        struct pair *holes = malloc(sizeof(struct pair));
        holes->first = left_hole;
        holes->second = right_hole;
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = malloc(sizeof(struct pair));
        shape->first = body;
        shape->second = holes;
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
而且，基于 `malloc_double` 函数，还能对 `pair_for_double_type` 函数进行简化：

C
```
struct pair *
pair_for_double_type(double x, double y)
{
        struct pair *ret = malloc(sizeof(struct pair));
        ret->first = malloc_double(x);
        ret->second = malloc_double(y);
        return ret;
}
```
事实上，如果我们再有一个这样的函数：

C
```
struct pair *
pair(void *x, void *y)
{
        struct pair *ret = malloc(sizeof(struct pair));
        ret->first = x;
        ret->second = y;
        return ret;
}
```
还能对 `reate_chain_node` 再做一步简化：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_hole = pair(pair_for_double_type(1.0, 1.0), malloc_double(0.5));
        struct pair *right_hole = pair(pair_for_double_type(9.0, 1.0), malloc_double(0.5));
        struct pair *holes = pair(left_hole, right_hole);
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = pair(body, holes);
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
看到了吧，只要略微换个角度，很多看似难以简化的代码都能得以简化。这个简化的过程一直是在指针的帮助下进行的，但事实上，当你的注意力一直集中在怎么对代码进行简化时，指针的使用简直就是本能一样的存在，以至于你觉得你并没有借助指针的任何力量，完全是你自己的逻辑在指导着你的行为。在这个过程中，无论是面向对象还是面向模板，都很难将你从冗长的代码中拯救出来……
# 面向什么，可能就会失去未面向的那些
在上文中模拟车链的程序中，我一开始是用面向对象的方式来写的，所以我造出了 5 个结构体，分别描述了二维点、矩形、圆形、链节形状以及链节等**对象**，结果却出现了一大堆繁琐的代码。虽然面向对象编程，在思维上是非常简单的，那就是现实中有什么，我们就模拟什么。但是你认真思考一下，现实中其实很多东西都有共性，如果你傻乎乎的去逐个模拟，而忽略它们的共性，那么你的代码绝对会非常臃肿。
当然，面向对象编程也提倡从所模拟的事物中提取共性，然后借助继承的方式来简化代码。但是一旦信仰了类与继承，你能做的最好的抽象就是对某一类事物进行抽象，比如你能够对『车』类的事物进行抽象，但是你却无法将对『飞机』和『车』这两类中的事物进行抽象。显然，飞机与车是有共性的，例如它们都能载客，都有仪表盘，都有窗户，都有座位，都有服务员……
当我发现基于面向对象创造的那些结构体存在着一个共性——它们都包含着两个成员，很自然的就会想到我应该制造一个包含着两个任意类型的结构体 `pair`，然后用 `pair` 来容纳我需要的数据。当面向对象编程范式在你的思想中根深蒂固，这种简单的现象往往会被忽略的，特别是你已经满足于你写的程序已经能够成功的运行之时。
接下来，当我试图用 `pair` 结构体取代二维点、矩形、圆形、链节形状等结构体的时候，我就开始走上了『泛型』的道路。C 语言里没有 C++ 模板这种工具可以用，所以我只能依赖 `void *`，而且为了简化 `double` 类型的数据向 `void *` 的转化，所以定义了：

C
```
double *
malloc_double(double x)
{
        double *ret = malloc(sizeof(double));
        *ret = x;
        return ret;
}
struct pair *
pair_for_double_type(double x, double y)
{
        struct pair *ret = malloc(sizeof(struct pair));
        ret->first = malloc_double(x);
        ret->second = malloc_double(y);
        return ret;
}
```
如果你对 C++ 的泛型编程有所了解，一定会觉得 `pair_for_double_type` 函数其实就是对 `pair` 进行**特化**。因为本来我是希望 `pair` 能存储任意类型的数据的，但是现在我需要频繁的用它来存储一对 `double` 类型的数据，那么我就应该去制造一个专用的 `pair` 结构。
当我发现我需要频繁的产生 `pair` 实例，并向它的 `first` 与 `second` 指针中存储某些类型的数据存储空间的基地址，所以我就将这种共性抽象为：

C
```
struct pair *
pair(void *x, void *y)
{
        struct pair *ret = malloc(sizeof(struct pair));
        ret->first = x;
        ret->second = y;
        return ret;
}
```
最终使得 `create_chain_node` 函数的定义即简洁又清晰：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_hole = pair(pair_for_double_type(1.0, 1.0), malloc_double(0.5));
        struct pair *right_hole = pair(pair_for_double_type(9.0, 1.0), malloc_double(0.5));
        struct pair *holes = pair(left_hole, right_hole);
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = pair(body, holes);
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
原来我用面向对象编程范式所写的代码是 104 行，换成泛型编程范式所写的代码是 75 行。那么我可以断定，是泛型编程拯救了面向对象吗？当然不能！因为我们的程序还没有写完，我们还需要面向对象。
# 对象的回归
先摆出 `create_chain_node` 函数：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_hole = pair(pair_for_double_type(1.0, 1.0), malloc_double(0.5));
        struct pair *right_hole = pair(pair_for_double_type(9.0, 1.0), malloc_double(0.5));
        struct pair *holes = pair(left_hole, right_hole);
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = pair(body, holes);
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
`create_chain_node` 函数可以创建链节，它是借助很抽象的 `pair` 结构体将很多种类型的数据层层封装到了 `chain+node` 结构体中，那么我们如何从 `chain_node` 结构体中提取这些数据，并使之重现它们所模拟的现实事物？
例如，我们怎样从 `chain_node` 结构体中获取一个 `left_hole` 的信息？显然，下面的代码

C
```
struct *t = create_chain_node();
struct pair *shape = t->shape;
struct pair *holes = shape->second;
struct pair *left_hole = holes->first;
```
并不能解决我们的问题，因为 `left_hole` 中只是两个 `void *` 指针，而我们需要知道的是 `left_hole` 的中心与半径。那么我们继续：

C
```
struct pair *center = left_hole->first;
double radius = *((double *)(left_hole->second));
```
依然没有解决我们的问题，因为我们想要的是 `left_hole` 的中心，而不是一个包含着两个 `void *` 指针的 `center`，所以需要继续：

C
```
double center_x = *((double *)(center->first));
double center_y = *((double *)(center->second));
```
最后我们得到了三个 `double` 类型的数据，即 `center_x`, `center_y`, `radius`，于是似乎我们的任务完成了，但是你如何将上述过程写成一个函数 `get_left_hole`？ C 语言中的函数只能有一个返回值。如果通过函数的参数来返回一些值，那么 `get_left_hole` 是能写出来的，例如：

C
```
void get_left_hole(struct chain_node *t, double *x, double *y, double *r)
{
        struct pair *shape = t->shape;
        struct pair *holes = shape->second;
        struct pair *left_hole = holes->first;
        struct pair *center = left_hole->first;
        *x = *((double *)(center->first));
        *y = *((double *)(center->second));
        *r = *((double *)(left_hole->second));
}
```
但是，如果你真的这么写了，那只能说明再好的编程语言也无法挽救你的品味。
我们应该继续挖掘指针的功能，像下面这样定义 `get_left_hole`会更好一些：

C
```
struct point {
        double *x;
        double *y;
};
struct hole {
        struct point *center;
        double *radius;
};
struct hole *
get_left_hole(struct chain_node *t)
{
        struct pair *shape = t->shape;
        struct pair *holes = shape->second;
        return holes->first;
}
```
好在哪？我们充分利用了 C 编译器对数据类型的隐式转换，这实际上就是 C 编译器的一种编译期计算。这样做可以避免在代码中出现 `*((double *)(...))` 这样的代码。`void *` 指针总是能通过赋值语句自动转换为左值，前提是你需要保证左值的类型就是 `void *` 的原有类型。这是 C 语言的一条清规戒律，不能遵守这条戒律的程序猿，也许再好的编程语言也无法挽救他。
C++ 这个叛徒，所以无论它有多么强大，也无法拯救那些无法保证左值的类型就是 `void *` 原有类型的程序猿。用 C++ 编译器迫使程序猿必须将

C
```
struct pair *shape = t->shape;
struct pair *holes = shape->second;
```
写成：

C
```
struct pair *shape = (struct pair *)(t->shape);
struct pair *holes = (struct pair *)(shape->second);
```
否则代码就无法通过编译。这样做，除了让代码更加混乱之外，依然无法挽救那些无法保证左值的类型就是 `void *` 原有类型的程序猿，只会让他们对裸指针以及类型转换这些事非常畏惧，逐渐就走上了惟类型安全的形而上学的道路。C++ 11 带来了新的智能指针以及右值引用，希望他们能得到这些新 C++ 式的拯救吧。
当我们用面向对象的思路实现了 `get_left_hole` 之后，就可以像下面这样使用它：

C
```
struct *t = create_chain_node();
struct hole *left_hole = get_left_hole(t);
printf("%lf, %lf, %lfn", *(left_hole->center->x), *(left_hole->center->y), *(left_hole->radius));
```
一切都建立在指针上了，只是在最后要输出数据的需用 `*` 对指针进行解引用。
上述代码中有个特点，`left_hole` 并不占用内存，它仅仅是对 `t` 所引用的内存空间的再度引用。可能有人会担心 `left_hole` 具有直接访问 `t` 所引用的内存空间的能力是非常危险的……有什么危险呢？你只需要清楚 `left_hole` 只是对其他空间的引用，而这种直觉很容易在使用一段时间的指针之后就能够建立。有了指针，你想修改 `left_hole` 所引用的内存空间中的数据，就可以 do it，不想修改就不去 do it，这有何难？如果自己并不打算去修改 `left_hole` 所引用的内存空间中的数据，但是又担心自己或他人会因为失误而修改了这些数据……你应该将这些担心写到有关 `get_left_hole` 函数的文档里。试图从语言自身的层面来确保内存空间的读写权限，结果必然会让代码充满了与所解决的问题毫无关系的杂碎代码，你变成了装在套子里的人，你的程序变成了装在套子里的程序。
对于只需要稍加注意就可以很大程度上避免掉的事，非要从编程语言的语法层面来避免，这真的是小题大作了。如果我们在编程中对于 `void *` 指针的隐式类型正确转换率高达 99%，为何要为 1% 的失误而修改编程语言，使之充满各种巧妙迂回的技巧并使得代码愈加晦涩难懂呢？
《C 陷阱与缺陷》的作者给出了一个很好的比喻，在烹饪时，你用菜刀的时候是否失手切伤过自己的手？怎样改进菜刀让它在使用中更安全？你是否愿意使用这样一把经过改良的菜刀？作者给出的答案是：我们很容易想到办法让一个工具更安全，代价是原来简单的工具现在要变得复杂一些。食品加工机一般有连锁装置，可以保护使用者的手指不会受伤。然而菜刀却不同，如果给菜刀这种简单、灵活的工具安装可以保护手指的装置，只能让它失去简单性与灵活性。实际上，这样做得到的结果也许是一台食品加工机，而不再是一把菜刀。
我成功的将本节的题目歪到了指针上。现在再歪回来，我们来谈谈对象。其实已经没什么好谈的了，`get_left_hole` 返回的是泛型指针的类型具化，借助这种类型具化的指针我们可以有效避免对 `pair` 中的 `void *` 指针进行类型转换的繁琐过程。
# 将函数变成数据
再来看一下经过大幅简化的 `create_chain_node` 函数：

C
```
struct chain_node *
create_chain_node(void)
{
        struct pair *left_hole = pair(pair_for_double_type(1.0, 1.0), malloc_double(0.5));
        struct pair *right_hole = pair(pair_for_double_type(9.0, 1.0), malloc_double(0.5));
        struct pair *holes = pair(left_hole, right_hole);
        struct pair *body = pair_for_double_type(10.0, 1.0);
        struct pair *shape = pair(body, holes);
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
}
```
这个函数对于我们的示例而言，没有什么问题，但是它只能产生特定形状的链节，这显然不够通用。如果我们想更换一下链节的形状，例如将原来的带两个小孔的矩形铁片换成带两个小孔的椭圆形铁片，那么我们将不得不重写一个 `create_elliptic_chain_node` 函数。当我们这样做的时候，很容易发现 `create_elliptic_chain_node` 函数中同样需要下面这段代码：

C
```
struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = shape;
        return ret;
```
如果我们要生产 100 种形状的链节，那么上述代码在不同的链节构造函数的实现中要重复出现 100 次，这样肯定不够好，因为会出现 500 行重复的代码。太多的重复的代码，这是对程序猿的最大的羞辱。
面向对象的程序猿可能会想到，我们可以为 `chain_node` 做一个基类，然后将上述共同的代码封装到基类的构造函数，然后在各个 `chain_node` 各个派生类的构造函数中制造不同形状的链节……在你要将事情搞复杂之前，建议先看一下这样的代码：

C
```
void *
rectangle_shape(void)
{
        struct pair *left_hole = pair(pair_for_double_type(1.0, 1.0), malloc_double(0.5));
        struct pair *right_hole = pair(pair_for_double_type(9.0, 1.0), malloc_double(0.5));
        struct pair *holes = pair(left_hole, right_hole);
        struct pair *body = pair_for_double_type(10.0, 1.0);
        return pair(body, holes);
}
struct chain_node *
create_chain_node(void *(*fp)(void))
{
        struct chain_node *ret = malloc(sizeof(struct chain_node));
        ret->prev = NULL;
        ret->next = NULL;
        ret->shape = fp();
        return ret;
}
```
看到了吧，我将 `create_chain_node` 函数原定义中负责创建链节形状的代码全部的抽离了出去，将它们封装到 `rectangle_shape` 函数中，然后再让 `create_chain_node` 函数接受一个函数指针形式的参数。这样，当我们需要创建带两个小孔的矩形形状的链节时，只需：

C
```
struct chain_node *rect_chain_node = create_chain_node(rectangle_shape);
```
如果我们像创建带两个小孔的椭圆形状的链节，可以先定义一个 `elliptic_shape` 函数，然后将其作为参数传给 `create_chain_node`，即：

C
```
struct chain_node *elliptic_chain_node = create_chain_node(elliptic_shape);
```
这样做，岂不是要比弄出一大堆类与继承的代码更简洁有效吗？
在 C 语言中，函数名也是一种指针，它引用了函数代码所在内存空间的基地址。所以，我们可以将 `rectangle_shape` 这样函数作为参数传递给 `create_chain_node` 函数，然后在后者中调用前者。
由于我们已经将 `chain_node` 结构体中的 `shape` 指针定义为 `void *` 指针了，因此对于 `create_chain_node` 函数所接受的函数，其返回值是 `void *` 没什么问题。不仅没问题，更重要的是 `void *(*fp)(void)` 对所有不接受参数且返回指针类型数据的函数的一种抽象。这意味着对于链节的形状，无论它的形状有多么特殊，我们总是能够定义一个不接受参数且返回指针的函数来产生这种形状，于是 `create_chain_node` 函数就因此具备了无限的扩展能力。
如果阿基米的德还活着，也许他会豪放的说，给我一个函数指针与一个 `void *`，我就能描述宇宙！
# 代码简化的基本原则
当你采用一切都是对象的世界观编写代码时，一旦发现一些类之间存在着共性的数据抽象，这往往意味着你需要创造一种**泛型**的数据容器，然后用这种容器与具体类型的数据的组合来消除那些类。
当你打算从泛型的数据容器中取数据，并希望所取的数据能够直观的模拟现实中的事物时，这往往意味着你要创造一些数据结构，然后让泛型的数据容器中存储的数据流入这些数据结构中，从而转化为有类型且具名的数据。这些数据结构就类似于各种各样的观察器或 Parser，我们通过它们解读或修改泛型容器中的数据。
当某个函数 `f` 中有一部分代码是与具体的问题息息相关，而另一部分代码则与具体的问题无关。为了让这个函数具备强大的扩展性，你需要将那些与具体问题息息相关的代码抽离到专用的函数中，然后再将这些专用函数传递给 `f`。
# 回避 C 指针是要付出代价的
在 C 语言中，在执行上述的代码简化基本原则时，指针是最简单明快的工具，像是著名厨师庖丁手里的刀。在静态类型语言中，任何企图回避指针的行为，必然会导致编程语言的语法复杂化或者削弱语言的表达能力。
在 C++ 中为了回避指针，发明了引用——本质上一种被弱化了的指针，结果导致 C++ 初学者经常要问『什么时候用指针，什么时候用引用』这样的问题。在智能指针未问世之前，STL 提供的泛型容器无法存储引用，为了避免在容器中存储对象时发生过多的内存复制，往往需要将指针存到容器中。当某个函数在内部创建了一个比较大的对象时，这个函数想将这个对象传递给其他对象时，这时如果不借助指针，那只能是将这个大对象作为返回值，然后引发了对象数据不止一次被复制的过程。如果在函数中 `new` 一个大对象，然后以指针的形式将其返回，这又与 C++ 一直想向用户掩盖指针的理想发生了矛盾……为了解决这个问题，终于在 C++ 11 里搞出来一个挺复杂挺扭曲的右值引用的办法，解决了在类的复制构造函数中偷偷的使用指针，但是类的用户却看不到指针这样的问题……
Java 回避指针的策略比 C++ 要高明一些。在 Java 中，即没有指针也没有引用。只要是类的实例（对象），无论是将其作为参数传递给函数，还是作为函数的返回值，还是将其复制给同类的其他对象，都是在传地址，而不是在传值。也就是说，Java 将所有的类实例都潜在的作为指针来用的，只有那些基本类型才是作为值来传递的。这种对数据类型进行了明确的区分的态度是值得点赞的，但是当 Java 想将一个函数（方法）传递给另一个函数（方法）时，代码就出现了扭曲，完全不能做到像 C 语言以指针的形式传递函数那样简洁直观。
C# 在指针的处理上似乎要比 Java 好得多，但是将那些使用指针的代码标定为 `unsafe`，这是一种歧视，类似于『嗟，来食！』。另外 C# 的指针只能用于操作值类型，也不能在泛型代码中使用。
在动态类型语言中，例如 Python，据说是一切皆引用，这样很好。也可以直接将一个函数作为参数传递给另一个函数，甚至还能在一个函数中返回一个函数，这样更好。动态类型语言在语法、抽象能力、类型安全以及资源管理方面很大程度上超越了 C、C++、Java 这些静态类型语言，但是用前者编写的程序的计算速度却往往比后者慢上一倍。
没有完美的指针，也不会有完美的编程语言，这一切皆因我们是在机器上编程，而不是在我们的大脑编程，更不是在教科书里编程。
# C 程序猿的指针信条
篡改《步枪兵信条》，自娱自乐。
这是我的指针。虽有很多相似的，但这个是我的。我的指针是我的挚友，如同我的生命。我将运用它如同运用我的生命。指针没了我便是废物，我没了指针便成为废人。我将准确无误的使用我的指针，我将比敌人用的更好，我将在他的程序速度超过我之前超过他，我会超过他的。
我与我的指针知道，编程中不论动用多么优雅的语言，动用多么强大的标准库，面向多么强大的编程范式，都是没意义的。只有解决问题才有意义。我们会解决的。
我的指针是人性的，就像我一样，因为它如同我的生命。因此我将像对兄弟一样地了解它。我将了解它的弱点，它的强项，它的构成，它所指的和指向它的。我将对指针持续建立完善的知识与技艺，使它们就如同我一般整装待发。我们会成为彼此的一部分。
在上帝面前我对这信条宣誓。我与我的指针是计算机的守卫者，我们是问题的克星，我们将拯救我的程序。但愿如此，直到不需要编程，没有问题，只有休息。
