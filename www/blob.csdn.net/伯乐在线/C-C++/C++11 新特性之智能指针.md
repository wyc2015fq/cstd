# C++11 新特性之智能指针 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [usher2007](http://www.jobbole.com/members/usher2007) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
前四篇在这里：
C++11新特性之新类型与初始化:  [http://blog.jobbole.com/102728/](http://blog.jobbole.com/102728/)
C++11新特性之类型推断与类型获取: [http://blog.jobbole.com/104559/](http://blog.jobbole.com/104559/)
C++11新特性之lambda：[http://blog.jobbole.com/104548/](http://blog.jobbole.com/104548/)
C++11新特性之容器相关特性：[http://blog.jobbole.com/104563/](http://blog.jobbole.com/104563/)
这是C++11新特性介绍的第五部分，涉及到智能指针的相关内容（shared_ptr, unique_ptr, weak_ptr)。
不想看toy code的读者可以直接拉到文章最后看这部分的总结。
# shared_ptr
## shared_ptr 基本用法
shared_ptr采用引用计数的方式管理所指向的对象。当有一个新的shared_ptr指向同一个对象时（复制shared_ptr等），引用计数加1。当shared_ptr离开作用域时，引用计数减1。当引用计数为0时，释放所管理的内存。
这样做的好处在于解放了程序员手动释放内存的压力。之前，为了处理程序中的异常情况，往往需要将指针手动封装到类中，通过析构函数来释放动态分配的内存；现在这一过程就可以交给shared_ptr去做了。
一般我们使用make_shared来获得shared_ptr。


```
cout<<"test shared_ptr base usage:"<<endl;
shared_ptr<string> p1 = make_shared<string>("");
if(p1 && p1->empty())
	*p1 = "hello";
auto p2 = make_shared<string>("world");
cout<<*p1<<' '<<*p2<<endl;
cout<<"test shared_ptr use_count:"<<endl;
cout<<"p1 cnt:"<<p1.use_count()<<"\tp2 cnt:"<<p2.use_count()<<endl;
auto p3 = p2;
cout<<"p1 cnt:"<<p1.use_count()<<"\tp2 cnt:"<<p2.use_count()<<"\tp3 cnt:"<<p3.use_count()<<endl;
p2 = p1;
cout<<"p1 cnt:"<<p1.use_count()<<"\tp2 cnt:"<<p2.use_count()<<"\tp3 cnt:"<<p3.use_count()<<endl;
```
## shared_ptr 和 new
shared_ptr可以使用一个new表达式返回的指针进行初始化。


```
cout<<"test shared_ptr and new:"<<endl;
shared_ptr<int> p4(new int(1024));
//shared_ptr<int> p5 = new int(1024); // wrong, no implicit constructor
cout<<*p4<<endl;
```
但是，不能将一个new表达式返回的指针赋值给shared_ptr。
另外，特别需要注意的是，不要混用new和shared_ptr!


```
void process(shared_ptr<int> ptr)
{
	cout<<"in process use_count:"<<ptr.use_count()<<endl;
}
cout<<"don't mix shared_ptr and normal pointer:"<<endl;
shared_ptr<int> p5(new int(1024));
process(p5);
int v5 = *p5;
cout<<"v5: "<<v5<<endl;
int *p6 = new int(1024);
process(shared_ptr<int>(p6));
int v6 = *p6;
cout<<"v6: "<<v6<<endl;
```
上面的程序片段会输出：


```
in process use_count:2
v5: 1024
in process use_count:1
v6: 0
```
可以看到，第二次process p6时，shared_ptr的引用计数为1，当离开process的作用域时，会释放对应的内存，此时p6成为了悬挂指针。
所以，一旦将一个new表达式返回的指针交由shared_ptr管理之后，就不要再通过普通指针访问这块内存！
## shared_ptr.reset
shared_ptr可以通过reset方法重置指向另一个对象，此时原对象的引用计数减一。


```
cout<<"test shared_ptr reset:"<<endl;
cout<<"p1 cnt:"<<p1.use_count()<<"\tp2 cnt:"<<p2.use_count()<<"\tp3 nt:"<<p3.use_count()<<endl;
p1.reset(new string("cpp11"));
cout<<"p1 cnt:"<<p1.use_count()<<"\tp2 cnt:"<<p2.use_count()<<"\tp3 cnt:"<<p3.use_count()<<endl;
```
## shared_ptr deleter
可以定制一个deleter函数，用于在shared_ptr释放对象时调用。


```
void print_at_delete(int *p)
{
	cout<<"deleting..."<<p<<'\t'<<*p<<endl;
	delete p;
}
cout<<"test shared_ptr deleter:"<<endl;
int *p7 = new int(1024);
shared_ptr<int> p8(p7, print_at_delete);
p8 = make_shared<int>(1025);
```
# unique_ptr
## unique_ptr基本用法
unique_ptr对于所指向的对象，正如其名字所示，是独占的。所以，不可以对unique_ptr进行拷贝、赋值等操作，但是可以通过release函数在unique_ptr之间转移控制权。


```
cout<<"test unique_ptr base usage:"<<endl;
unique_ptr<int> up1(new int(1024));
cout<<"up1: "<<*up1<<endl;
unique_ptr<int> up2(up1.release());
cout<<"up2: "<<*up2<<endl;
//unique_ptr<int> up3(up1); // wrong, unique_ptr can not copy
//up2 = up1; // wrong, unique_ptr can not copy
unique_ptr<int> up4(new int(1025));
up4.reset(up2.release());
cout<<"up4: "<<*up4<<endl;
```
## unique_ptr 作为参数和返回值
上述对于拷贝的限制，有两个特殊情况，即unique_ptr可以作为函数的返回值和参数使用，这时虽然也有隐含的拷贝存在，但是并非不可行的。


```
unique_ptr<int> clone(int p)
{
	return unique_ptr<int>(new int(p));
}
void process_unique_ptr(unique_ptr<int> up)
{
	cout<<"process unique ptr: "<<*up<<endl;
}
cout<<"test unique_ptr parameter and return value:"<<endl;
auto up5 = clone(1024);
cout<<"up5: "<<*up5<<endl;
process_unique_ptr(move(up5));
//cout<<"up5 after process: "<<*up5<<endl; // would cause segmentfault
```
这里的std::move函数，以后再单独具体细说^_^
## unique_ptr deleter
unique_ptr同样可以设置deleter，和shared_ptr不同的是，它需要在模板参数中指定deleter的类型。好在我们有decltype这个利器，不然写起来好麻烦。


```
cout<<"test unique_ptr deleter:"<<endl;
int *p9 = new int(1024);
unique_ptr<int, decltype(print_at_delete) *> up6(p9, print_at_delete);
unique_ptr<int> up7(new int(1025));
up6.reset(up7.release());
```
## weak_ptr
weak_ptr一般和shared_ptr配合使用。它可以指向shared_ptr所指向的对象，但是却不增加对象的引用计数。这样就有可能出现weak_ptr所指向的对象实际上已经被释放了的情况。因此，weak_ptr有一个lock函数，尝试取回一个指向对象的shared_ptr。


```
cout<<"test weak_ptr basic usage:"<<endl;
auto p10 = make_shared<int>(1024);
weak_ptr<int> wp1(p10);
cout<<"p10 use_count: "<<p10.use_count()<<endl;
//p10.reset(new int(1025)); // this will cause wp1.lock() return a false obj
shared_ptr<int> p11 = wp1.lock();
if(p11) cout<<"wp1: "<<*p11<<" use count: "<<p11.use_count()<<endl;
```
# 总结
- shared_ptr采用引用计数的方式管理所指向的对象。
- shared_ptr可以使用一个new表达式返回的指针进行初始化；但是，不能将一个new表达式返回的指针赋值给shared_ptr。
- 一旦将一个new表达式返回的指针交由shared_ptr管理之后，就不要再通过普通指针访问这块内存。
- shared_ptr可以通过reset方法重置指向另一个对象，此时原对象的引用计数减一。
- 可以定制一个deleter函数，用于在shared_ptr释放对象时调用。
- unique_ptr对于所指向的对象，是独占的。
- 不可以对unique_ptr进行拷贝、赋值等操作，但是可以通过release函数在unique_ptr之间转移控制权。
- unique_ptr可以作为函数的返回值和参数使用。
- unique_ptr同样可以设置deleter，需要在模板参数中指定deleter的类型。
- weak_ptr一般和shared_ptr配合使用。它可以指向shared_ptr所指向的对象，但是却不增加对象的引用计数。
- weak_ptr有一个lock函数，尝试取回一个指向对象的shared_ptr。
完整代码详见[smart_pointer.cpp](https://github.com/yubo1911/saber/blob/master/learncpp11/smart_pointer.cpp)
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
任选一种支付方式
![](http://jbcdn2.b0.upaiyun.com/2016/08/a41e08fcaca939c581c931c115da0a8d.png)![](http://jbcdn2.b0.upaiyun.com/2016/08/c07df7ab8dad3a49f6ce602eb7d62949.jpg)
