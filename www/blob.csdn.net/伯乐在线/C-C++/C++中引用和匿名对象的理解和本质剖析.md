# C++中引用和匿名对象的理解和本质剖析 - 文章 - 伯乐在线
原文出处： [开源中国-沙米笔记](http://my.oschina.net/u/1783725/blog/656271?fromerr=A05VHNwJ)
大家对C++的引用应该都不陌生吧，抱着既要知其然，也要知其所以然的态度。下面将按照是什么？怎么用？为什么需要？本质剖析的流程来向大家一一描述。
## 引用是什么？
引用其实就是给变量起的一个别名，使用这个别名跟使用变量名没有区别。
## 那什么又是变量名呢？
变量名实质上是一段连续存储空间的别名，是一个标号(门牌号)，编译器通过变量来申请并命名内存空间，程序员可以通过变量的名字可以使用存储空间。
也可以这样理解，变量名是逻辑概念，变量是物理层面，变量含数据类型和数据值，数据类型决定内存的分配，编译器将变量名和变量对应的内存联系起来，使程序员可以通过变量名来操作内存。
## 引用怎么用？
语法：Type& name = var;
规则：1、普通引用在声明时必须用其它的变量进行初始化
2、引用作为函数参数声明时不进行初始化（后面将通过引用本质来解释原因）
## 为什么需要引用？
1）引用作为其它变量的别名而存在，因此在一些场合可以代替指针
2）引用相对于指针来说具有更好的可读性和实用性
引用为java等高级的语言程序员提供了很大便利，其不需要了解C++中的指针，只需要按照以前的习惯来使用就可以。
**引用的本质剖析（很重要！！）**
1、**引用其实是个常量**，证明如下

C++
```
int main()
{
	int a = 1;
	//int& b;   C++编译器提示：错误“b”，必须初始化引用-->说明引用是个常量
	int& b = a;
}
```
说明： 必须初始化引用–>说明引用是个常量
2、**引用其实也是个指针**，证明如下

C++
```
struct teacher
{
	int age;		//4个字节
	teacher& m_techer;	
};
struct student
{
	int age;               //4个字节
	short& weight;
};
int main()
{
	cout说明m_techer的
	                                                    引用占4个字节*/
	cout说明weight的引
	                                                    用占4个字节*/
	system("pause");
	return 0;
}
```
说明：从上面teacher&和short&的两个引用中占用的4个字节（32位系统），可以推断出引用其实是个指针。
根据1、2的结论可以推断出引用其实是个指针常量或者是常量指针，下面进一步证明。
3、**引用其实是个指针常量 **，证明如下

C++
```
int main()
{
	int a =10;
	int m = 22;
	int& b = a;
	&b = &m;      /*疑问：  b是引用，引用是个指针，指针赋值为什么还要在取地址符&b
	                    （因为编译器在我们使用引用时，自动给引用披上了间接引用的外衣即：*b）
       		        编译错误 “=”: 左操作数必须为左值-->引用是个指针常量，不能修改
       		          其指针的指向。*/
	system("pause");
	return 0;
}
```
说明：引用是个指针常量。下面会说出C++编译器是怎么在C语言的基础上加入引用机制的。
4、**C++编译器在C语言的基础上加入引用机制![](http://jbcdn2.b0.upaiyun.com/2016/04/973e13397146ab504e04c3195961feaa.png)说明：**
1、声明引用时，C语言将引用声明的是指针常量。（为啥要初始化引用原因）
2、引用使用，C语言隐藏了对常指针自动间接引用，让我们完全不用了解指针
3、初始化引用时，C语言隐藏了对变量的取地址符&操作，让我们感觉是在直接给变量起别名
应用的剖析到此就结束了，下面我们来说说匿名对象吧。
**什么是匿名对象**
匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。
**匿名对象的生命周期（很重要！！！）**

C++
```
class Cat
{
public:
    Cat()
    {
        cout<<"Cat类 无参构造函数"<<endl;
    }
    Cat(Cat& obj)
    {
        cout<<"Cat类 拷贝构造函数"<<endl;
    }
    ~Cat()
    {
        cout<<"Cat类 析构函数 "<<endl;
    }
};
void playStage() //一个舞台，展示对象的生命周期
{
    Cat();             /*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；执行完此行代码，
                            因为外部没有接此匿名对象的变量，此匿名又被析构了*/
    Cat cc = Cat();    /*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；然后将此匿名变
                            成了cc这个实例对象，此匿名对象没有被析构。*/
    cout<<"cc 对象好没有被析构"<<endl;    
}
int main()
{
    playStage();
    system("pause");
    return 0;
}
```
输出：

C++
```
Cat类 无参构造函数
Cat类 析构函数
Cat类 无参构造函数
cc 对象好没有被析构
Cat类 析构函数
```
**说明：**
1、在执行playStage( )函数中的Cat( )时，生成了一个匿名对象，执行完Cat( )代码后，此匿名对象就此消失。这就是匿名对象的生命周期。
2、在执行playStage( )函数中Cat cc = Cat();时，首先生成了一个匿名对象，因为外部有cc对象在等待被实例化，然后将此匿名对象变为了cc对象，其生命周期就变成了cc对象的生命周期。
**总结：**
如果生成的匿名对象在外部有对象等待被其实例化，此匿名对象的生命周期就变成了外部对象的生命周期；如果生成的匿名对象在外面没有对象等待被其实例化，此匿名对象将会生成之后，立马被析构。
最后希望能对大家有帮助，沙米才疏学浅，有什么错误请留言指正，谢谢大家。
