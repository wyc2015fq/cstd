# C++ 中命名空间的 5 个常见用法 - 文章 - 伯乐在线
原文出处： [CppDepend Team](http://cppdepend.com/blog/?p=79)   译文出处：[王江平](http://www.iteye.com/news/32479)
译者注：可能很多程序员对C++已经非常熟悉，但是对命名空间经常使用到的地方还不是很明白，这篇文章就针对命名空间这一块做了一个叙述。
命名空间在1995年被引入到 c++ 标准中，通常是这样定义的:
> 
命名空间定义了新的作用域。它们提供了一种避免名称冲突的方法。
c++ 中的命名空间通常用于避免命名冲突。尽管命名空间在最近的 c++ 代码中广泛使用，但大多数较旧代码都不使用此工具。
基于对众多C++项目源码的探索与研究，总结出了在这些项目中使用命名空间的一些常见原因。
**1-避免名称冲突**
如前所述，这是在C++中使用命名空间最常见的原因，在这种情况下，它们的使用只是对编译器有效。无法为开发人员在代码可读性和维护性方面带来什么价值。
**2-模块化应用程序**
命名空间采取 “Namespace-by-feature ”的方法使代码模块化。”Namespace-by-feature” 通过命名空间来反映功能集。它将具有相互关联的项归类在同一个命名空间。这会形成具有高内聚低耦合（译者注：高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务。耦合是一个软件结构内不同模块之间互连程度的度量）、模块性很强的命名空间。
Boost是按功能分组的最佳示例， 它包含数以千计的命名空间， 每一个都用于对特定功能进行分组。
**3-匿名命名空间**
匿名的命名空间可避免产生全局静态变量。您创建的 “匿名” 命名空间只能在创建它的文件中访问。
**4-解决枚举类型成员重名问题**
如果在同一个作用域内定义了具有相同名称的枚举，C++中的“传统”枚举会在其作用域内导出枚举值，可能会导致名称冲突，
在一个大型项目中，不能保证两个不同的枚举都不会以同名命名。这个问题在C++ 11中已经得以解决，它使用枚举类，隐式地对枚举名称中的枚举值进行定义。
许多年前, 使用在命名空间内声明枚举的技巧解决这个问题, 而不是像这样声明枚举


```
enum status{  
   status_ok,  
    status_error  
};
```
它在命名空间中声明:


```
namespace status{  
   enum status{  
     ok,
      error  
 };  
}
```
许多 c++ 项目使用此技巧，例如Unreal Engine（译者注：UNREAL ENGINE中文名称为“虚幻引擎” ，是目前世界最知名授权最广的顶尖游戏引擎，占有全球商用游戏引擎80%的市场份额）源代码就广泛使用此技术。
**5-隐藏实现**
对于在头文件中实现的模板库，开发者在调用时不需要用到特殊的数据类型，因为他们只专注于功能的实现，所以对于找到一种适合开发者调用库的方法是很有趣的。在c#中， “internal” 关键字做了这项工作， 但是在c++中，没有办法将公有数据类型完全对开发者进行隐藏。
在模块中将定义和实现分离，是由Boost库开发者们创建的一个c++惯用语法，但这些定义必须按照规则放入到一个可供开发者调用sub-namespace（子命名空间）中。
例如在 boost::math文档中， 它指定:
引用
> 
不适用于应用程序的函数是在 boost::math::detail中。
