# 多线程中的使用共享变量的问题 - 文章 - 伯乐在线
原文出处： [雨天搁浅](http://blog.chinaunix.net/uid-26946560-id-3438795.html)
一组并发线程运行在一个进程的上下文中，每个线程都有它自己独立的线程上下文，例如：栈、程序计数器、线程ID、条件码等，每个线程和其它的线程一起共享除此之外的进程上下文的剩余部分，包括整个用户的虚拟地址空间，当然也共享同样的打开的文件的集合。，这里有一点要特别注意，就是寄存器是从不共享的，而虚拟存储器总是共享的。
有了共享就要防止在对共享变量进行操作的过程中得到一个不可知的值，在Linux内核中有个原子类型与原子操作这么个概念，因为用户态下没有这么一个原子操作存在，那么在我们用户态下就需要要对操作这个共享变量的线程进行同步。为什么要进行同步呢？
因为假设我们在一个程序中有一个全局变量cnt，初始值为0，接下去我们创建了两个线程，完成的功能都是在一个循环中对这个变量进行+1操作，想象一下在这两个线程操作完成后会出现什么状况。
假设我们这里的max为10000，那么我们想要得到的结果的结果当然是20000，可是在执行之后结果并不是我们所期望的20000，而是一个小于20000的值。为什么会出现这个现象呢？
这里就是我们为什么需要对线程进行同步了。
因为在C语言的层面来说，cnt++就是一条语句，实际上我们在心里默认把它当作了一个原子操作，事实上，就这么一条操作语句，在汇编代码中是分三步执行的：
1）、将这个值从内存中取出来，放入一个寄存器中；
2）、将寄存器中的值进行+1操作；
3）、将寄存器中的值放入内存中去。
![](http://jbcdn2.b0.upaiyun.com/2016/12/f3fdaf0b83a244e943c6653ad81cf10f.png)
因为对与多线程来说我们不知道何时会执行哪个线程，所以执行的顺序是不可知的。我们所想的是先让一边执行完，然后再开始执行另外一边。
现在我们不妨将这个问题极端化，也就是两线程交叉执行，假设左边的执行线程为A，右边为B，假设A先执行，A从内存中取出cnt的值，那么现在在R1里的值为0，接下去，A线程被B线程打断，A停止执行，B开始执行，B又从内存中取出cnt的值，现在在R2中的值也为0。然后又轮到A执行，进行加1操作，则R1为1，接下去轮到B执行，进行加1操作，则R2为1。然后A将值写回到内存中，B也将值写回到内存中。这次我们知道内存中的值为1而并非我们所期望的2。
那么怎么能让它进行正确的执行顺序呢？同步，可以用加锁来完成同步操作。


```
for(int i=0;i<max;i++)
{
    P(&mutex);
    cnt++;
    V(&mutex);
}
```
在对cnt加1的操作时，对这个操作加锁，这就意味着当下只有这一个线程执行这个操作，其它的线程都得等在外面，等这个线程解锁出来，其他的线程才可以有机会进去。
加锁之后我们再来看看上面的那张图的执行过程，也假设是在一个极端的情况：
A先加锁，然后完成那三个步骤（因为此时只有它一个线程有操作的权限），解锁；现在内存中的值为1，A加锁，然后一样完成三个步骤，解锁；现在内存中的值为2。与所期望的相同。当然了，对于加锁的问题还要防止出现死锁现象，这里就不讨论了。
