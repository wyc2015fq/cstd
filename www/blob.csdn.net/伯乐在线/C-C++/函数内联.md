# 函数内联 - 文章 - 伯乐在线
原文出处： [lwbeyond](http://blog.csdn.net/lwbeyond/article/details/6445370)
**1. 用内联取代宏代码**
C++ 语言支持函数内联，其目的是为了提高函数的执行效率（速度）。
在 C 程序中，可以用宏代码提高执行效率。宏代码本身不是函数，但使用起来象函数。 预处理器用复制宏代码的方式代替函数调用， 省去了参数压栈、 生成汇编语言的 CALL 调用、返回参数、执行 return 等过程，从而提高了速度。使用宏代码最大的缺点是容 易出错 ，预处理器在复制宏代码时常常产生意想不到的边际效应。
例如
#define MAX(a, b)         (a) > (b) ? (a) : (b)
语句
result = MAX(i, j) + 2 ;
将被预处理器解释为
result = (i) > (j) ? (i) : (j) + 2 ;
由于运算符‘ +’比运算符‘ :’的优先级高，所以上述语句并不等价于期望的
result = ( (i) > (j) ? (i) : (j) ) + 2 ;
如果把宏代码改写为
#define MAX(a, b) ( (a) > (b) ? (a) : (b) )
则可以解决由优先级引起的错误。但是即使使用修改后的宏代码也不是万无一失的，例如语句
result = MAX(i++, j);
将被预处理器解释为
result = (i++) > (j) ? (i++) : (j);
对于 C++ 而言，使用宏代码还有另一种缺点：无法操作类的私有数据成员 ,也就是说宏代码基本是针对公共或全局操作的。
让我们看看 C++ 的“函数内联”是如何工作的。对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型） 。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样） 。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查 ，或者进行自动类型转换。假如内联函数是成员函数，对象的地址（ this）会被放在合适的地方，这也是预处理器办不到的。
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。所以在 C++ 程序中，应该用内联函数取代所有宏代码， “断言 assert”恐怕是唯一的例外。 assert 是仅在 Debug 版本起作用的宏，它用于检查“不应该”发生的情况。为了不在程序的 Debug 版本和 Release 版本引起差别， assert 不应该产生任何副作用。 如果 assert 是函数， 由于函数调用会引起内存、 代码的变动， 那么将导致 Debug 版本与 Release 版本存在差异。 所以 assert 不是函数， 而是宏。 
**2. 内联函数的编程风格**
关键字 inline 必须与**函数定义** 体放在一起才能使函数成为内联 ，仅将 inline **放在****函数声明前面不起任何作用** 。如下风格的函数 Foo 不能成为内联函数：


```
inline void Foo(int x, int y);   // inline 仅与函数声明放在一起,不起任何作用  
void Foo(int x, int y)  
{  
 …  
}  
而如下风格的函数 Foo 则成为内联函数：  
void Foo(int x, int y);     
inline void Foo(int x, int y) // inline 与函数定义体放在一起  
{  
 …  
}
```
所以说， inline 是一种“用于实现的关键字” ，而不是一种“用于声明的关键字” 。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量 C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。
定义在类声明之中的成员函数将自动地成为内联函数，例如


```
class A  
{  
public:  
    void Foo(int x, int y) { … }   // 自动地成为内联函数  
}
```
将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：


```
// 头文件  
class A  
{  
public:  
    void Foo(int x, int y)；   
}  
// 定义文件  
inline void A::Foo(int x, int y)  
{  
…  
}
```
**3. 慎用内联**
内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？
如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？
内联是以代码膨胀 （复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，
消耗更多的内存空间。以下情况不宜使用内联：
（ 1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
（ 2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以**不要随便地将构造函数和析构函数的定义体放在类声明中** 。
一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中） 。
注：
参考《高质量C++编程指南》。
