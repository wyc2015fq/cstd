# C++11 的 10 个实用特性（上） - 文章 - 伯乐在线
本文由 [伯乐在线](http://blog.jobbole.com) - [黄小非](http://www.jobbole.com/members/huangxiaofei) 翻译，[至秦](http://www.jobbole.com/members/applevip) 校稿。未经许可，禁止转载！
英文出处：[Kernel Panic](https://kerpanic.wordpress.com/2015/11/16/5-useful-things-in-c11/)。欢迎加入[翻译组](https://github.com/jobbole/translation-project)。
Kernel Panic 在这篇文章中总结了  C++11 中的 5 个实用特性：自动类型推导、强类型枚举、Unique 指针、static_assert、Lambdas 表达式。
## 自动类型推导
auto 关键字让用户得以使用 C++ 内置的类型推导特性。

C++
```
std::string something = somethingthatreturnsastring.getString();
auto something = somethingthatreturnsastring.getString();
```
Auto 关键字会对上述自变量（something）进行自动推导，得出其应该是 string 类型的结论，并在 auto 出现的地方用正确的类型进行替换。这个特性对迭代器特别有用。

C++
```
for(std::vector<T>::iterator it = x.begin(); it != x.end(); i++)
{
   it->something();
}
```
上述代码可以写成：

C++
```
for(auto it = x.begin(); it != x.end(); i++)
{
   it->something();
}
```
赞！ 代码看上去简洁多了！
## 强类型枚举
这个特性可以有效避免枚举类型的命名冲突，从而消除很多潜在的 bug。在旧版本的 C++ 中，程序员必须为每一个枚举项设定一个全局唯一的名字。例如，如果你给一个枚举项取名叫 None，那么其他的枚举集合就不能再用这个名字了。但是现在，你可以这么做了！（译注：作者下面给的例子仿佛和上面的文字不是非常搭配//myEnum ::All 和 myEnum::All是不是存在差异？）

C++
```
enum class myEnum {None, One, All};
myEnum o = myEnum ::All;
auto p = myEnum::All; // 同样有效
```
## Lambdas 表达式
Lambda 表达式简单说就是个匿名函数（译注：原文为in-place function，意思是“用来镶嵌的函数”，但是匿名函数能更精确表达这个含义）。对于迭代器以及for 循环非常有用，这种函数你只需要在程序的某一处使用一次，所以没有必要专门在程序里明确定义它。Lambda 表达式并没有让 C++ 在逻辑表达上做到“及以往之不可及”的程度，它是一种受函数式编程思想影响而引入的语言特性，能够让程序更紧凑。Lambda 表达式的最简形式是下面这样的：
[]() { }
加上所有可能的操作符，会是这样：

C++
```
[]() mutable -> T { }
```
其中[]是捕获列表，()是参数列表，{}是函数体
**Capture List 捕获列表**
捕获列表定义了什么类型的东西可以从 Lambda 表达式之外匹配到函数体中来。可以包含以下这些：
- 一个值：[x]
- 一个引用 [&x]
- 当前范围内任意变量的引用 [&]
- 同3，但是通过变量的值
你可以对上面的各项进行任意混合，只要用逗号隔开即可 [x, &y]
**Argument List 参数列表**
参数列表和 C++ 函数的参数列表是一个概念。
**Function Body ****函数体**
函数体是指在 Lambda 表达式被调用时真正执行的代码。
**Return Type Deduction**
**返回值推断**
如果 Lambda 表达式只有一个返回声明，那么返回值类型就可以省略，其类型就是隐式类型：decltype(return_statement)
**可变 Labmda**
如果一个 Lambda 表达式被标记为 mutable（例如：[]() mutable{ }），那么对于按值捕获的数值来说，在函数体内就允许对这些值进行修改操作。
下面举个例子：

C++
```
int main()
{
   char s[]="Hello World!";
   int Uppercase = 0; //lambda会改变这个变量的值
   for_each(s, s+sizeof(s), [&Uppercase] (char c) {
    if (isupper(c))
     Uppercase++;
    });
 cout<< Uppercase<<" uppercase letters in: "<< s<<endl;
}
```
## Unique 指针
Unique 指针是 C++11 版本的智能指针类。
一旦你用 unique_ptr 关键字定义了一个对象，那么下列事件只要发生一个，对象就会被销毁并释放内存：
- unique_ptr 管理的对象被销毁。
- unique_ptr 管理的对象通过赋值操作符指向另一个指针，或调用了reset()方法。
对于不想了解太多细节的用户来说，这就意味着如果你使用了 unique 指针的语义，那么**在跳出作用域之前，你就不用手动回收对象的内存了**。
以前，我们需要这么写代码：

C++
```
YourObject * obj = new YourObject();
```
然后在程序的最后你一定要记得释放内存：

C++
```
delete(obj);
```
否则你可就造成内存泄露了。而现在，

C++
```
std::unique_ptr<YourObject> obj(new YourObject());
```
当 obj 跳出作用域范围之外的时候，内存将会被自动回收。
## static_assert
static_assert 简单说就是一个在编译期执行的断言。例如，你可以这么做：

C++
```
static_assert(sizeof(unsigned int) * CHAR_BIT == 32);
```
假设由于系统的原因造成了上述的逻辑判断的失败，那么 static_assert 就会断言失败。
它的另一种用途，是和 C++ 特征类型搭配使用。比如：

C++
```
static_assert(std::is_pod<yourstruct>::value, "Not a pod struct!");
```
POD 是指“简单数据”（Plain Old Data)结构，也就是说，它是一个的类（你可以用struct关键字定义，也可以用class关键字定义），但没有构造函数，析构函数和虚成员函数。所以，如果一个愚蠢的菜鸟程序员企图给这种类型增加构造函数的话，static_assert 就会在编译的时候阻止这种行为，并报错。这对代码维护来说可是非常有用的。
当然 C++ 还有很多有用的特性，我希望在以后的文章中能给大家介绍更多。谢谢大家的关注！
> 
**打赏支持我翻译更多好文章，谢谢！**
[打赏译者](#rewardbox)
#### 打赏支持我翻译更多好文章，谢谢！
![](http://www.jobbole.com/wp-content/uploads/2016/04/78805a221a988e79ef3f42d7c5bfd4187.jpeg)
