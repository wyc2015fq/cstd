# C++函数中那些不可以被声明为虚函数的函数 - 文章 - 伯乐在线
原文出处： [hackbuteer1](http://blog.csdn.net/hackbuteer1/article/details/6878255)
常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。
**1、为什么C++不支持普通函数为虚函数？**
普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时邦定函数。
**2、为什么C++不支持构造函数为虚函数？**
这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）
**3、为什么C++不支持内联成员函数为虚函数？**
其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的邦定函数）
**4、为什么C++不支持静态成员函数为虚函数？**
这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态邦定的必要性。
**5、为什么C++不支持友元函数为虚函数？**
因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。
*********************************************************************
1、**顶层函数**：多态的运行期行为体现在虚函数上，虚函数通过继承方式来体现出多态作用，顶层函数不属于成员函数，是不能被继承的。
2、**构造函数**：
（1）构造函数不能被继承，因而不能声明为virtual函数。
（2）构造函数一般是用来初始化对象，只有在一个对象生成之后，才能发挥多态的作用，如果将构造函数声明为virtual函数，则表现为在对象还没有生成的情况下就使用了多态机制，因而是行不通的，如下例：


```
#include <iostream>  
using namespace std;  
  
class B  
{  
public:  
    B() {}  
    virtual void show()  
    {  
        cout<<"***"<<endl;  
    }  
};  
class D:public B  
{  
public:  
    D() {}  
    void show()  
    {  
        cout<<"==="<<endl;  
    }  
};  
  
int main(void)  
{  
    B *pb;  
    D d;        //先生成对象  
    pb=&d;  
    pb->show(); //再体现多态  
  
    pb=new D(); //先调用构造函数  
    pb->show(); //再多态  
    delete pb;  
    return 0;  
}
```
3、static函数：不能被继承，只属于该类。
4、友元函数：友元函数不属于类的成员函数，不能被继承。
5、inline函数：inline函数和virtual函数有着本质的区别，inline函数是在程序被编译时就展开，在函数调用处用整个函数体去替换，而virtual函数是在运行期才能够确定如何去调用的，因而inline函数体现的是一种编译期机制，virtual函数体现的是一种运行期机制。此外，一切virtual函数都不可能是inline函数。
