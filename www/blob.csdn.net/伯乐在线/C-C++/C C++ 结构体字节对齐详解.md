# C/C++ 结构体字节对齐详解 - 文章 - 伯乐在线
原文出处： [Moondark，2012-03-07](http://www.cnblogs.com/moondark/archive/2012/03/08/2383491.html)
结构体的sizeof
先看一个结构体：

```
struct S1
{
    char c;
    int i;
};
```
sizeof(s1)在VC6中按默认设置得到的结果为8。
我们先看看sizeof的定义——sizeof的结果等于对象或者类型所占的内存字节数，好吧，那就让我们来看看S1的内存分配情况


```
S1 s1 = { 'a', 0xFFFFFFFF };
```
定义上面的变量后，加上断点，运行程序，观察s1所在的内存，你发现了什么
以我的VC6.0(sp6)为例，s1的地址为0x0012FF78，其数据内容如下：
0012FF78: 61 CC CC CC FF FF FF FF
发现了什么怎么中间夹杂了3个字节的CC看看MSDN上的说明：
When applied to a structure type or variable, sizeof returns the actual size, which may include padding bytes inserted for alignment.
原来如此，这就是传说中的字节对齐啊！一个重要的话题出现了。
为什么需要字节对齐计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，以此类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。
让我们交换一下S1中char与int的位置：

```
struct S2
{
    int i;
    char c;
};
```
看看sizeof(S2)的结果为多少，怎么还是8再看看内存，原来成员c后面仍然有3个填充字节，这又是为什么啊别着急，下面总结规律。
字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：
1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。
对于上面的准则，有几点需要说明：
1) 前面不是说结构体成员的地址是其大小的整数倍，怎么又说到偏移量了呢因为有了第1点存在，所以我们就可以只考虑成员的偏移量，这样思考起来简单。想想为什么。
结构体某个成员相对于结构体首地址的偏移量可以通过宏offsetof()来获得，这个宏也在stddef.h中定义，如下：

```
#define offsetof(s,m) (size_t)&(((s *)0)->m)
```
例如，想要获得S2中c的偏移量，方法为size_t pos = offsetof(S2, c);// pos等于4
2) 基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型，这里所说的“数据宽度”就是指其sizeof的大小。由于结构体的成员可以是复合类型，比如另外一个结构体，所以在寻找最宽基本类型成员时，应当包括复合类型成员的子成员，而不是把复合成员看成是一个整体。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。这里叙述起来有点拗口，思考起来也有点挠头，还是让我们看看例子吧（具体数值仍以VC6为例，以后不再说明）：

```
struct S3
{
    char c1;
    S1 s;
    char c2
};
```
S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整除，整个sizeof(S3)的值也应该被4整除。c1的偏移量为0，s的偏移量呢这时s是一个整体，它作为结构体变量也满足前面三个准则，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填充字节。最后得到sizeof(S3)的值为16。
通过上面的叙述，我们可以得到一个公式：
结构体的大小等于最后一个成员的偏移量加上其大小再加上末尾的填充字节数目，即：
sizeof( struct ) = offsetof( last item ) + sizeof( last item ) + sizeof( trailing padding )
到这里，朋友们应该对结构体的sizeof有了一个全新的认识，但不要高兴得太早，有一个影响sizeof的重要参量还未被提及，那便是编译器的pack指令。它是用来调整结构体对齐方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改/Zp编译开关。#pragma pack的基本用法为：#pragma pack( n )，n为字节对齐数，其取值为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，公式如下：
offsetof( item ) = min( n, sizeof( item ) )
再看示例：

```
#pragma pack(push) // 将当前pack设置压栈保存
#pragma pack(2)// 必须在结构体定义之前使用
struct S1
{
    char c;
    int i;
};
struct S3
{
    char c1;
    S1 s;
    char c2
};
#pragma pack(pop) // 恢复先前的pack设置
```
计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)等于6，能够被2整除，所以整个S1的大小为6。同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能被2整除，添加一个填充字节，所以sizeof(S3)等于10。
现在，朋友们可以轻松的出一口气了，:)
还有一点要注意，“空结构体”（不含数据成员）的大小不为0，而是1。试想一个“不占空间”的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。如下：

```
struct S5 { };
sizeof( S5 ); // 结果为1
```
含位域结构体的sizeof:
前面已经说过，位域成员不能单独被取sizeof值，我们这里要讨论的是含有位域的结构体的sizeof，只是考虑到其特殊性而将其专门列了出来。
C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型类型的存在。
使用位域的主要目的是压缩存储，其大致规则为：
1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；
2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；
3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；
4) 如果位域字段之间穿插着非位域字段，则不进行压缩；
5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。
还是让我们来看看例子。
示例1：

```
struct BF1
{
    char f1 : 3;
    char f2 : 4;
    char f3 : 5;
};
```
其内存布局为：
 |__f1___|____f2___ |__|____f3______|______|
|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|
位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能从下一个字节开始。因此sizeof(BF1)的结果为2。
示例2：

```
struct BF2
{
    char f1 : 3;
    short f2 : 4;
    char f3 : 5;
};
```
由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。
示例3：

```
struct BF3
{
    char f1 : 3;
    char f2;
    char f3 : 5;
};
```
非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。
