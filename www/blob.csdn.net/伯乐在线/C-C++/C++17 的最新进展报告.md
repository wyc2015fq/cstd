# C++17 的最新进展报告 - 文章 - 伯乐在线
原文出处： [reddit](https://www.reddit.com/r/cpp/comments/3q4agc/c17_progress_update_oct_2015/)   译文出处：[csdn](http://geek.csdn.net/news/detail/42726)
C++标准委员会最近在夏威夷的科纳召开了一次会议，大家可能关心最新的进展，但是按照以往的情况，某些文件需要很久才会公开。会议进行的时候， 大家都在忙着修订自己的文件，会议之后，大会会收集改好的文件，在几周之后发布。但是这一次，委员会修改了他们的系统，所以得到早些版本的文件非常简单， [这些邮件](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/#mailing2015-09)就是公开的。
我从官方收集与组织了这些信息，没有任何我个人的主观评论。如果你想知道这次会议的主要内容，请阅读下面的内容（我已经知道了绝大多数关于C++17 库的内容，但是要将其全部写出来还是需要一定的时间）
**C++17 核心库文件**
- P0001R1 弃用 register 关键字
- P0002R1 bool 类型不再支持++运算符
- P0012R1 异常成为类型系统的一部分，第五版
- P0061R1 支持__has_include
- P0134R0 引入非静态成员变量的拷贝构造函数//not sure
- P0136R1 重写继承构造器(core issue 1941 et al)
- P0160R0 删除一元运算符的预设值//Wording for removing defaults for unary folds
**C++17 库相关文件**
- P0004R1 弃用过时的 iostreams 的别名
- P0006R0 采用基于标准库规范的类型特征变量模板
- P0092R1 优化
- P0007R1 Constant View:一个::as_const 的辅助函数模板
- P0156R0 可变的 lock_guard (Rev. 3)
- P0074R0 使 std::owner_less 更加灵活
- P0013R1 逻辑运算符类型特征 (revision 1)
**库基本规范第二版文件**
- N4531 替换 std::rand，版本三
- P0013R1 逻辑运算符类型特征 (revision 1)[C++17 投票通过]
- 这些文件将会应用于 N4529 草案，然后进行拟议草案技术规范的投票。
**并发规范**
- P0159R0 将会作为并发技术规范发布，届时可能稍作改动。
**并行规范 v2**
- N4505 草案和 P0155R0 的”Task Block R5”负责这项工作。
**网络规范**
- P0112R1 草案负责这想工作。
**范围规范**
- P0021R0 草案负责这项工作。
**核心主题**
- 1274. 常见的非终结符表达式和内嵌初始化列表
- 1391. 非推导模板参数到参数类型的转化
- 1722. lambda 函数指针转换函数应该不例外吗？
- 1847. 部分排序时声明一致性
- 1863. 抛出对象的类型应该支持 std::current_exception ()
- 1949. ”sequenced after”代替”sequenced before”
- 1975. 允许声明异常类型
- 1981. 隐式和显式的上下文转换
- 1990. decl-specifier-seq 造成的歧义
- 2000. #include 之外的头文件名称
- 2004. 常亮表达式中有可变成员的变量
- 2006. Cv-qualified 的 void 类型
- 2015. 虚函数的 odr-use
- 2016. 类型转换函数的描述中可能存在的歧义
- 2019. 存储时间描述中成员引用的省略
- 2024. 依赖类型和未解包的参数包
- 2026. Zero-initialization 和 constexpr
- 2027. 指定多个 alignas 的需求不明
- 2031. &&的不兼容
- 2052. 模板参数推导 vs 重载操作符
- 2075. 传递短初始化列表给数组引用参数
- 2101. 对类型和值的依赖的错误说明
- 2120. 数组作为标准布局类的第一个非静态成员变量
**库主题**
- 1169. num_get 不能和 strto*完全兼容
- 2072. 缓冲区容量定义不明确
- 2101. 一些类型转换可能产生非预期的类型
- 2111. 处理异常时可能调用那些已经删除的句柄？
- 2119. 扩展 int 类型缺少哈希函数
- 2127. 带 raw_storage_iterator 的 Move-construction
- 2133. 重载逗号迭代器
- 2156. 无序容器的 reserve (n)保存的是n-1 个元素
- 2218. 容器如何使用 allocator_traits::construct ()不够明确
- 2219. INVOKE-ing 一个带有 reference_wrapper 的指针作为对象表达式
- 2224. 不活跃对象的状态问题
- 2234. assert ()应该允许在常亮表达式中使用
- 2244. 关于 basic_istream::seekg 的 issue
- 2250. Library Issue 2207 中的 Follow-up
- 2259. 17.6.5.5 规则中有关成员函数的问题
- 2273. regex_match 的歧义
- 2336. is_trivially_constructible/is_trivially_assignable 结果永远是 false
- 2353. std::next 限制过度
- 2367. pair 和 tuple 无参数时不兼容 is_constructible
- 2380. 应该提供 long ::abs (long) 和 long long ::abs (long long)吗?
- 2384. 分配器的解除函数需要更好的规范
- 2385. function::assign 分配器参数无意义
- 2435. reference_wrapper::operator ()的标记应该是被删除
- 2447. 分配器和 [Volatile](http://www.codeceo.com/article/java-volatile-var.html)-qualified 值类型
- 2462. std::ios_base::failure 被过度规范
- 2466. allocator_traits::max_size ()默认表现是错误的
- 2469. map 的[]操作符和 unordered_map 规则错误
- 2473. basic_filebuf 对C文件的兼容
- 2476. scoped_allocator_adaptor 是不可分配的
- 2477. std::vector::erase ()和 std::deque::erase ()的不一致
- 2483. throw_with_nested ()应该使用 is_final
- 2484. rethrow_if_nested ()是不可实现的
- 2485. 常量 tuple&&应该重载 get（）
- 2486. mem_fn ()应该提供向前兼容
- 2487. bind ()不应该是 cv-overloaded, 而应该是 const-overloaded
- 2489. mem_fn ()应该是 noexcept 的
- 2492. 明确 comp 的需求
- 2495. 没有类似异常安全元素的东西
**Library Fundamentals TS v2 Issues**
- 2494. [fund.ts.v2] ostream_joiner 应该是 noexcept 的
- 2500. [fund.ts.v2] fundts.memory.smartptr.shared.obs/6 应该适用于 cv-unqualified void
- 2515. [fund.ts.v2]observer_ptr 的确定操作符不能匹配任何简介
- 2517. [fund.ts.v2] 两个 propagate_const assignment 操作符返回不正确的类型
- 2526. [fund.ts]experimental::function::swap 条件不正确
**更多信息**
以上只是投票通过的部分记录。每次的会议都会涉及很多工作，不会全都反映在文件上，比如，有关 modules 的热烈讨论文件中就没有。虽然我几乎花了所有的时间在库工作组中，但是还是不能跟进所有的内容。最终版文件我会在 Reddit 分享各个模块的进展。
本文作者可以回答大多数有关库的问题，但是可能回复略有延迟。可以确定的是，库的可用性提高了。看起来一切都像小猫一样温顺可爱，但是如果你去 看一眼重载集合，就会发现这些模棱两可的东西简直是灾难。LWG2451 是作为标准库定义的一个极好的例子，optional opt_str = “meow”;现在还未实现。对于基本规范没有什么问题，但是 optional 的 ship-stopper 不符合国际标准。在这次会议上，LWG 意识到一些 issue 影响到了 variant，问题会牵扯到基本规范。当然了，会议会解决这些问题，你不必经历这些痛苦。
