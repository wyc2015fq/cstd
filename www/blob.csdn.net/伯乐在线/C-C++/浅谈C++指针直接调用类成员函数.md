# 浅谈C++指针直接调用类成员函数 - 文章 - 伯乐在线
原文出处： [佚名，2011-08-06](http://soft.chinabyte.com/database/187/12133187.shtml)
在编程工作中常会遇到在一个“类”中通过函数指针调用成员函数的要求，如，当在一个类中使用了C++标准库中的排序函数qsort时，因qsort参数需要一个“比较函数”指针，如果这个“类”使用某个成员函数作“比较函数”，就需要将这个成员函数的指针传给qsort供其调用。本文所讨论的用指针调用 “类”的成员函数包括以下三种情况：
(1).将 “类”的成员函数指针赋予同类型非成员函数指针，如：
例子1
![](http://jbcdn2.b0.upaiyun.com/2016/12/99cefa47258fd523e232f25300ab0951.jpg)
(2) 在一个“类”内，有标准库函数，如qsort， 或其他全局函数，用函数指针调用类的成员函数。如：
例子2：
![](http://jbcdn2.b0.upaiyun.com/2016/12/9b20a421517cbbc5bd1c2153d81a3337.jpg)
(3)同一个“类”内，一个成员函数调用另一个成员函数， 如：
例子3：
![](http://jbcdn2.b0.upaiyun.com/2016/12/a01acc06f7c82da4da27029af53a99e5.jpg)
以上三种情况的代码语法上没有显著的错误，在一些较早的编译环境中，如，[VC](http://www.chinabyte.com/keyword/VC/)++ 4.0， 通常可以编译通过，或至多给出问题提醒(Warning)。后来的编译工具，如，VC++6.0和其他一些常用的C++编译软件，不能通过以上代码的编译， 并指出错误如下(以第三种情况用VC++ 6.0编译为例)：
error C2664: ‘Memberfun1’ : cannot convert parameter 1 from ‘void (void)’ to ‘void (__cdecl *)(void)’
None of the functions with this name in scope match the target type
即：Memberfun1参数中所调用的函数类型不对。
按照以上提示，仅通过改变函数的类型无法消除错误，但是，如果单将这几个函数从类的定义中拿出来，不作任何改变就可以消除错误通过编译， 仍以第三种情况为例，以下代码可通过编译:
![](http://jbcdn2.b0.upaiyun.com/2016/12/a64693e71504a251bad1ca32034746d3.jpg)
第1、 2种情况和第3种情况完全相同。
由此可以的得出结论，以上三种情况编译不能通过的原因表面上并不在于函数类型调用不对，而是与 “类”有关。没通过编译的情况是用函数指针调用了 “类”的成员函数，通过编译的是用函数指针调用了非成员函数，而函数的类型完全相同。那么， “类”的成员函数指针和非成员函数指针有什么不同吗？
在下面的程序中，用sizeof()函数可以查看各种“类”的成员函数指针和非成员函数指针的长度(size)并输出到屏幕上。
![](http://jbcdn2.b0.upaiyun.com/2016/12/9c153c0c4cbff563b589f88bd4a9c40d.jpg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/394957831aa54b0ecced76b0f9e9d0a2.jpg)
输出结果为(VC++6.0编译，运行于Win98[操作系统](http://soft.chinabyte.com/os/)，其他操作系统可能有所不同)：
一般非成员函数指针长度= 4
-类的成员函数指针长度-
Test3类成员函数指针长度=4
Test5类成员函数指针长度=8
Test4类成员函数指针长度=12
Test类成员函数指针长度=16
以上结果表明，在32位Win98操作系统中，一般函数指针的长度为4个字节(32位)，而类的成员函数指针的长度随类的定义与否、类的继承种类和关系而变，从无继承关系类(Test3)的4字节(32位)到有虚继承关系类(Virtual Inheritance)(Test4)的12字节(96位)，仅有说明(declaration)没有定义的类(Test)因为与其有关的一些信息不明确成员函数指针最长为16字节(128位)。显然， 与一般函数指针不同，指向“类”的成员函数的指针不仅包含成员函数地址的信息，而且包含与类的属性有关的信息，因此，一般函数指针和类的成员函数指针是根本不同的两种类型，当然，也就不能用一般函数指针直接调用类的成员函数，这就是为什么本文开始提到的三种情况编译出错的原因。尽管使用较早版本的编译软件编译仍然可以通过，但这会给程序留下严重的隐患。
至于为什么同样是指向类的成员函数的指针，其长度竟然不同，从32位到128位，差别很大，由于没有看到[微软](http://com.chinabyte.com/microsoft/)官方的资料只能推测VC++6.0在编译时对类的成员函数指针进行了优化，以尽量缩短指针长度，毕竟使用128位或96位指针在32位操作系统上对程序性能会有影响。但是，无论如何优化，类的成员函数指针包含一定量的对象(Objects)信息是确定的。其他的操作系统和编译软件是否进行了类似的处理，读者可以用以上程序自己验证。
那么，当需要时，如何用指针调用类的成员函数？可以考虑以下方法：
(1) 将需要调用的成员函数设为static 类型，如：在前述例子2中，将class Test2 成员函数Compare 定义前加上static 如下(黑体为改变之处)：
![](http://jbcdn2.b0.upaiyun.com/2016/12/0cd96adec10b9e1a317366dad2f90845.jpg)
改变后的代码编译顺利通过。原因是，static 类型的成员函数与类是分开的，其函数指针也不包含对象信息，与一般函数指针一致。这种方法虽然简便，但有两个缺点：1、被调用的函数成员定义内不能出现任何类的成员(包括变量和函数);2、由于使用了static 成员，类在被继承时受到了限制。
(2) 使用一个函数参数含有对象信息的static 类型的成员函数为中转间接地调用其他成员函数，以例3为例，将类Test3作如下修改(黑体字为修改之处)，main()函数不变，则可顺利通过编译：
![](http://jbcdn2.b0.upaiyun.com/2016/12/7ea08bebfe8cb66ad86ba409e65f70b4.jpg)
这种间接方式对成员函数没有任何限制，克服了第一种方法成员函数不能使用任何类的成员的缺点，但由于有static 成员，类的继承仍受到制约。
(3)使用一个全程函数(global function)为中转间接调用类的成员函数，仍以例3为例，将代码作如下修改(VC++6.0编译通过)：
![](http://jbcdn2.b0.upaiyun.com/2016/12/92b2bbb94be0459426a70295ee5655ce.jpg)
这个方法对成员函数没有任何要求，但是需要较多的代码。
除上述三种方法外还有其他方法，如， 可以在汇编层面上修改代码解决上述问题等，不属于本文范围。
结论：函数指针不能直接调用类的成员函数，需采取间接的方法，原因是成员函数指针与一般函数指针有根本的不同，成员函数指针除包含地址信息外，同时携带其所属对象信息。本文提供三种办法用于间接调用成员函数。这三种办法各有优缺点，适用于不同的场合。
希望通过以上内容的介绍，能够给大家带来帮助。
