# 从开源项目学习 C 语言基本的编码规则 - 文章 - 伯乐在线
本文由 [伯乐在线](http://blog.jobbole.com) - [清蒸竹马](http://www.jobbole.com/members/qingzhengzhuma) 翻译。未经许可，禁止转载！
英文出处：[CoderGears Team](http://www.codergears.com/Blog/?p=163)。欢迎加入[翻译组](https://github.com/jobbole/translation-project)。
每个项目都有自己的风格指南：一组有关怎样为那个项目编码约定。一些经理选择基本的编码规则，另一些经理则更偏好非常高级的规则，对许多项目而言则没有特定的编码规则，项目中的每个开发者使用他自己的风格。
所有代码都保持一致风格的大型库，更容易让人理解。
有许多资源是关于能让人采取的更好的编码规则的，我们可以通过以下方式学到好的编码规则：
- 阅读书或杂志
- 浏览网站
- 与同事交流
- 参加培训
另一个更有趣的方法是通过研究一个成熟的知名开源项目来得知其开发者是怎样编写代码的。对于C语言来说，[Linux内核](https://github.com/torvalds/linux)是个不错的选择。
对初级甚至中级的C开发者而言，可能不太容易深入到Linux内核的代码中，但是我们的目标不一定得是对它的源码做出贡献，而是探索它是怎样实现的。
让我们以来自Linux源码中的一个函数实现为例：
![](http://ww2.sinaimg.cn/mw690/6941baebgw1em9bvnjr1rj20fa09kmy8.jpg)
这段代码看起来非常干净，实际上这个函数
- 仅有几行代码
- 签名定义得好
- 注释写得好
- 缩进安排得好
- 变量名非常清晰
同样的功能可以被另一个开发者以下面这种方式实现
![](http://ww1.sinaimg.cn/mw690/6941baebgw1em9bvn5lwuj20jr07lq3s.jpg)
编码风格对源码的可读性影响甚巨，投入一些时间培训开发者以及周期性评审代码总有利于轻松地维护和升级代码。
让我们使用CppDepend深入到Linux内核的源码中，发现一些它的开发者们采用的编码规则。
**模块化**
模块化是一种提升使用不同独立部分构建软件的程度的设计技巧，你可以轻松地管理维护模块化的代码。
对于像C这种没有名字空间（namespace）、组件（component）或者类（class）等逻辑构件的过程语言，我们可以使用目录和文件实现模块化。
下面是一些可能的情形：
- 把所有的代码放在一个目录中
-  分离出与一个模块或子模块有关的文件，再放入一个特定的目录
Linux内核使用目录和子目录来模块化核心源码：
![](http://ww2.sinaimg.cn/mw690/6941baebgw1em9bvmglakj209o08ygm0.jpg)
**封装**
封装是指隐藏一份实现内部的功能与数据。在C中，封装是通过使用关键字static实现的。这些实体称为文件域的函数和变量。
让我们通过执行下面的CQLinq查询语句查找一下所有的静态函数：
![](http://ww1.sinaimg.cn/mw690/6941baebgw1em9bvm1r9hj20an0120sm.jpg)
使用Metric视图，我们可以清楚地看到有多少个函数是静态的。在Metric视图中，代码库由树形图（Treemap）描述。树形图（Treemap）是一种使用嵌套矩形来展示树结构数据的方法。CppDepend中树形图使用的树结构就是通常的代码层次结构：
- 项目包含目录
- 目录包含文件
- 文件包含结构体，函数和变量
树形图视图为描述一条CQLinq请求的结果提供了一种有用的方式，所以我们能够可视化地看到与该请求有关的类型。
![](http://ww2.sinaimg.cn/mw690/6941baebgw1em9bvlh664j20lf0an41q.jpg)
正如我们所见，许多函数都声明为静态的
现在我们来查询静态域：
![](http://ww3.sinaimg.cn/mw690/6941baebgw1em9bvkdhg9j20aa0d5t9u.jpg)
和函数的标记一样，许多变量都声明为静态属性。
在Linux内核源码中，只要函数和变量对于文件域而言是私有的，就使用封装的手法。
**使用结构体存储你的数据模型**
在C编程中，函数使用变量达到不同的处理要求，这些变量可以是：
- 静态变量
-  全局变量
- 局部变量
- 结构体变量
每个项目都有一些可以被很多源文件使用的数据模型，可以使用全局变量，但这不是好的解决方案，更推荐使用结构体对数据分组。
让我们搜索一下属于基本类型的全局变量：
![](http://ww4.sinaimg.cn/mw690/6941baebgw1em9bvjrf9wj209x0d1q43.jpg)
仅有几个变量与该查询匹配，也许我们可以把这些变量中的一些分组到结构体中，例如（elfcorehdr_addr and elfcorehdr_size），或者是（pm_freezing and pm_nosig_freezing）这样。
**让函数短小而干练**
下面是来自linux编码风格网页的一份关于函数长度的建议：
函数应该短小而干练，并且一个函数只做一件事。它们应该恰好占据一屏到两屏（我们都知道ISO/ANSI标准屏幕的大小为80×24），只做一件事并且做得很好。
一个函数的最大长度与它的复杂程度和缩进层级成反比。所以，如果你有一个概念上简单的函数，这个函数包含着冗长的（但是简单）case语句，而每个case分支都对应着为不同情况而不得不进行简单处理，那么这个函数长点也没多大关系。
让我们找找多于30行的函数：
![](http://ww3.sinaimg.cn/mw690/6941baebgw1em9bvj4fl8j20an0cymz4.jpg)
多于30行的方法仅有几个。
**函数参数的个数**
拥有多于8个参数的函数调用起来可能很伤神，还可能降低函数的性能。一个替代方案是提供一个专职传参的结构体。
![](http://ww3.sinaimg.cn/mw690/6941baebgw1em9bvikakpj209w09sq46.jpg)
仅有2个方法的参数多于8个。
**局部变量的个数**
方法的局部变量超过8个，会让方法难以理解，也难以维护。超过15个就非常复杂，这时应该拆分成两个更小的方法（使用工具自动生成的除外）。
![](http://ww4.sinaimg.cn/mw690/6941baebgw1em9bvi32dij209s0bh75u.jpg)
仅仅5个函数的局部变量超过15个。
**避免定义复杂的函数**
有许多度量复杂函数的指标，上面提到的代码行数、参数个数和局部变量个数是基本的。
还有些其他有趣的指标：
- 环路复杂度在过程软件中是一个广为使用的指标，等于一个过程可以接纳的决议的个数。
- 嵌套深度是一个定义在方法上的指标，该指标与方法体中最深嵌套作用域成正比。
- 最大嵌套循环等于嵌套在一个函数中最深循环层级。
这些指标的可接受最大值更多依赖于团队的选择，并没有标准参考值。
让我们找找可能需要重构的函数：
![](http://ww3.sinaimg.cn/mw690/6941baebgw1em9bvhqhm0j209q0d0q4l.jpg)
只有很少几个可以被认为是复杂的函数。
**命名约定**
命名约定没有标准，每个项目经理都可以选择他们认为更好的规范，重要的是遵守选择的约定，让项目拥有一致的命名。
例如在Linux中，结构体必须以小写字母开头，我们可以验证一下这条规则在整个核心代码中是否成立，执行下面的查询：
![](http://ww4.sinaimg.cn/mw690/6941baebgw1em9bvharrbj209v0b1gmx.jpg)
仅有4个结构体以“_”代替小写字母开头。
**缩进**
缩进非常有利于让代码容易阅读，下面这段摘自[linux编码风格网页](https://www.kernel.org/doc/Documentation/CodingStyle)的文字，说明了隐藏在使用缩进背后的动机。
原理阐释：缩进背后整体思想是为了清楚地定义一个控制块的开始与结束。特别是当你已经持续对着屏幕长达20个小时的时候，你更容易发现缩进是怎样发挥功效的（如果你有大量的缩进）
当前，有的人会声称，八字符的缩进会让代码行右端伸太远，这会是代码在80字符宽度的终端屏幕上难以阅读。对此的答案是：如果你需要多于3级缩进的话，不管怎么说，你已经陷入囹圄，你应该修改你的程序。
**结论**
探究一些知名开源项目总是有利于提高你的编程技巧，没必要下载生成该项目，你从——比如说——GitHub上就可以发现这些代码。
