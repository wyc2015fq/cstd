# C# 7.0 新特性（2）： 本地方法 - 文章 - 伯乐在线
原文出处： [Hover Zuo](http://www.cnblogs.com/ylvict/p/5579350.html)
*本文参考Roslyn项目中的Issue:#[259](https://github.com/dotnet/roslyn/issues/259).*
*        1. [C# 7.0 新特性1： 基于Tuple的“多”返回值方法](http://blog.jobbole.com/102521/)*
*　　2. [C# 7.0 新特性2： 本地方法](http://blog.jobbole.com/102439/)*
*　　3. [C# 7.0 新特性3： 模式匹配](http://blog.jobbole.com/102522/)*
简而言之，【**本地方法**】就是在方法体内部定义一个**方法**。
其实咋眼一看，这个新特新并没有什么新意，因为目前大量C#的项目中，都可以使用delegate或基于delegate变形的各种方案（lambda, Fun, Action, Action …）。
但是请仔细推敲一下，方法体内部delegate，是否真的那么完美无缺……
**目前的C#**
我们看一下，通常方法内部设置子逻辑单元的做法。


C#
```
public void Bar()
{
    var arr= new int[] { 5,8 ,10, 20 };
    Func<int, string> handler = i => $"当前值是：{i}。"; 
    foreach (var i in arr)
    {
        Console.WriteLine(handler(i));
    }
}
```
看起来有什么问题吗？当然，很多。
1. 首先，handler是无法进行递归调用的，看下面的代码。


C#
```
public int Bar(int n)
{
    if (n < 0) throw new ArgumentException();
    Func<int, int> handler = n => {
        if (n == 0) return 1;
        return n * handler(n - 1);
    };
    return handler(n);
}
```
这时***handler(n-1)*** 的调用会报错（***Use of unassigned local variable ‘handler’***），原因是handler还未被赋值。通常，这种问题我们会尝试用一种非常难看的做法变通解决：


C#
```
Funcint, int> handler = null;
 handler = n =>{
     if (n == 0) return 1;
     return n * handler(n - 1);
 };
```
咳咳咳，不多说了，心里一万只羊驼狂奔而过。
2. 其次，Lambda表达式的使用，非常有局限，它不允许在参数中添加行为修饰 **out**, **ref**, **params**, 以及**可选参数**，均不能在Lambda表达式的参数表中出现。参数无法使用泛型。
3. 分配了一个委托对象来指向函数，为了能够在Lambda表达式中访问本地变量，会为其分配一个新的对象，间接的增加了GC的压力。
说到这里，可能有的童鞋会自然的想到更原始的解决方案，在外部声明一个私有函数，就不会存在以上一系列的问题。


C#
```
class Foo
{
    public void Bar(int[] arr)
    {
        foreach(var i in arr)
        {
            Console.WriteLine(Handler(i));
        }
    }
    
    private string Handler(int i) =>  $"当前值是：{i}";
}
```
这的确是一种**简单粗暴**的解决方案，但是依然存在一些小问题，一个仅在**Bar**方法中有引用的方法，逻辑上也没必要暴露给**this**的其他成员。这种做法其实是结构上的一种不合理。
**本地方法（Local Function）**
在C#7.0中，允许代码直接在一个方法体（方法，构造，属性的Getter和Setter）里声明并调用子方法。
废话不说，上代码：


C#
```
public void Bar(int[] arr)
{
    var length = arr.Length;
    string Length() {
        return $"length is {length}";
    }
    //或:
    //string Length() => $"length is {length}";
    Length();
}
```
上面例子中的Length()，在编译后会转化成当前类的**私有成员方法**(IL: *this.g__Length(): string()*)，但由于在C#语言层面做出了限制，只被允许在Bar方法中访问。
由于对this而言，是以类似匿名方法的形态存在，所以，在当前类中**仍然可以定义同名且同样声明的成员方法**，从所在的方法体中调用，会执行本地方法。
Okay，话说回来，由于它的**本质**是**成员方法**，所以它可以避免 [委托 / Lambda表达式] 的种种限制，可以**异步**，可用**泛型**，可用**out**, **ref**, **param**, 可以**yield**, **特性参数**， 等等。。
来个例子：


C#
```
class Foo
{
    public IEnumerable<T> Bar<T>(params T[] items)
    {
        if (items == null) throw new ArgumentException(nameof(items));
        IEnumerable<T2> Enumerate<T2> ([CallerMemberName] T2[] array) //使用泛型及特性参数
        {
            //本地方法逻辑
            foreach (var item in array)
            {
                yield return item; //使用迭代器
            }
        }
        return Enumerate<T>(items); //调用本地方法
        //return this.Enumerate<T>(items);  //调用成员方法
    }
    IEnumerable<T2> Enumerate<T2>([CallerMemberName] T2[] array)
    {
        //成员方法逻辑
    }
}
```
**总结**
这个feature可以看出，C#在朝着函数式语言谨慎的调整。回想起很多人在首次接触代码的懵懂期，经常犯一种比较低级的错误，傻傻的尝试在Main方法中写函数声明，现在看来，那才是**人**最直接的思维逻辑。
目前(2016年6月)C#7.0还未正式发布，大家如果想体验部分特性，可以去下载[VS15预览版](https://www.visualstudio.com/downloads/visual-studio-next-downloads-vs)，最终发布的语法可能和本文中提及的有所不同，最新动态请大家关注[Roslyn](https://github.com/dotnet/roslyn)项目。
