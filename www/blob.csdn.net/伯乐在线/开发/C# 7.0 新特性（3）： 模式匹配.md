# C# 7.0 新特性（3）： 模式匹配 - 文章 - 伯乐在线
原文出处： [Hover Zuo](http://www.cnblogs.com/ylvict/p/5588613.html)
*本文参考Roslyn项目Issue:#[206](https://github.com/dotnet/roslyn/issues/206)，及Docs:#[patterns](https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md)。*
*　　1. [C# 7.0 新特性1： 基于Tuple的“多”返回值方法](http://blog.jobbole.com/102521/)*
*　　2. [C# 7.0 新特性2： 本地方法](http://blog.jobbole.com/102439/)*
*　　3. [C# 7.0 新特性3： 模式匹配](http://blog.jobbole.com/102522/)*
**模式匹配**也许能算的上C#本次更新最重量级的升级，也是最受关注的特性（也许没有之一），通过模式匹配，我们可以简化大量的条件代码。
**Switch语句**
大家也许遇到过这样的情景，假设你的代码中，有一个**Nullable**的值，需要对其在**正整数**，**非正整数**，**Null**三种情况下分别作不同的逻辑处理。大多数童鞋直接想到是类似于下面的逻辑：


C#
```
void Foo(int? num)
{
    if (!num.HasValue)
     /* null logic */
    else if (num.Value > 0)
     /* positive int logic */
    else
     /* negative int & zero logic */
}
```
请大家思考一下，这个逻辑是否可以用switch-case语句来做，在VB及很多**非C系**的语言中，答案是肯定的，比如**VB.NET中**可以这样写：


C#
```
Sub Foo(Num As Integer?)
    Select Case Num
        Case Not Num.HasValue
        'null logic
        Case Num > 0
        'positive Int logic
        Case Num <= 0
            'negative Int() & zero logic
        Case Else
    End Select
End Sub
```
说到这里，在具体讨论**模式匹配**在switch-case中的应用之前，先淡淡的吐槽一下C#，本来理所应当的一个简单的小语法，到了C#7.0才加入。
看看C#7.0加入的类型模式（Type Pattern）：


C#
```
void Foo(int? num)
{
    switch (num)
    {
        case null:
            //null logic
            break;
        case int n when n > 0:
            //positive Int logic
            break;
        case int n when n <= 0:
            //negative Int() & zero logic
            break;
    }
}
```
这个不多说了，大家自己体会，单纯的在**Nullable**下，可能体现的不是很清晰，个人认为这个小变动其实意义并不是很大，同样场景下，或许**if-if else-else**会让代码更清晰易读些。
如果说模式匹配仅仅是完善了一下switch-case，那可真是太大才小用了，下面我们看一个好玩的。
**Match表达式**
虽然把match带到C#中看起来并不是什么大事，但是会引起的代码简化还是非常爽的。
就像很多人说三元表达式（**？ : ** ）将**if-else**简化一样。match表达式，是**将switch-case结构简化**到了一个新限度。
看match表达式代码前，我们先来看一行略坑的三元表达式。


C#
```
var reuslt = x == null ? default(int) : (x is Func<int> ? (x as Func<int>)() : (x is int ? Convert.ToInt32(x) : default(int)));
```
好吧，我承认我是故意让你们抓狂的。^_^， 为了能稳住大家看完上面这行代码后的情绪，来一副match表达式消消火。


C#
```
var result = x match(
    case Func<int> f: f(),
    case int i: i,
    case *: default(int)
);
```
这两种写法效果上是等效的，有没有非常干净清爽的感觉？写过match表达式的码农，应该再也不想回去嵌套 **<*>?<*>:<*>** 了。 （*注：目前这种写法还未确认，C#7.0发布后可能会有略微变动*）
**Is表达式**
如果说上面两个变化是“语法糖”，那么**is表达式**可是要玩真的了。
说点题外话，其实对**正则表达式**熟悉的童鞋可能知道，本质上**[模式匹配]**和正则表达式要解决的问题**逻辑**类似，**以一个确定的模式，来判断或查找一个确定的实例**。只不过在正则表达式中，这里说的”模式”是正则表达式，”实例”指字符串。而[模式匹配]下，所针对的”实例”是对象，那么”模式”，就可以理解成**is表达式**了。
举个例子，比如你要查找并列出 一组电子设备中，所有iPhone的IMEI串号，我们在C#6.0中，会这样做：


C#
```
class Device
{
    public ProductLineOption ProductLine { get; set; }
}
class MobiePhone : Device
{
    public string IMEICode { get; set; }
}
IEnumerable<Device> GetAllDevices() { /* 获取并返回所有设备 */ };
IEnumerable<string> GetAlliPhoneIMEI()
{
    var deviceList = this.GetAllDevices();
    foreach (Device device in deviceList)
    {
        MobiePhone phone = device as MobiePhone;
        if (phone == null) continue;
        if (phone.ProductLine == ProductLineOption.IPhone)
        {
            yield return phone.IMEICode;
        }
    }
}
```
一个非常典型的传统方法，没什么好说的。我们直接来看C#7.0 中** is表达式**怎么等效的实现这段逻辑：


C#
```
IEnumerable<string> GetAlliPhoneIMEI()
{
    List<Device> deviceList = this.GetAllDevices();
    foreach (Device device in deviceList)
    {
        if (device is MobiePhone { IMEICode is var imei, ProductLine is ProductLineOption.IPhone})
        {
            yield return imei;
        }
    }
}
```
如果你还是觉得这没什么，那么，其实这个例子中，仅仅体现出模式匹配中的**属性模式**。
根据Doc:#[patterns](https://github.com/dotnet/roslyn/blob/future/docs/features/patterns.md) C#7.0会提供一下几种匹配方式：
- 类型模式
- 常量模式
- 变量模式
- 通配符模式
- 位置模式
- 属性模式
我们可以想象，如果模式匹配组合起来使用，会给现有的C#代码打来多大的便利和清静。
Okay，说了这么多，下面给大家一个相对完整的案例，自行体会。
**案例**


C#
```
abstract class Animal
{
    public string Name { get; set; }
}
class Dog : Animal
{
    public string BarkLikeCrazy() => "WOOF WOOF WOOF";
}
class Cat : Animal { }
class Swan : Animal { }
class Program
{
    static void Main(string[] args)
    {
        var animals = new Animal[] {
            new Dog { Name = "hola" },
            new Cat { Name = "tom" },
            new Swan { Name = "hacienda" }
        };
        var organizedAnimals = from animal in animals
                               let sound = animal match( //Match语句
                                   case Dog d: "woof... " + d.BarkLikeCrazy(), //类型匹配
                                   case Cat c: "meow",
                                   case * : "I'm mute.." //通配符匹配
                               )
                               select new { Type = animal, Sound = sound };
        foreach (var animal in organizedAnimals)
        {
            Console.WriteLine($"{animal.Type.ToString()} - {animal.Sound}");
        }
        foreach (var a in animals)
        {
            if (a is Cat { Name is var name }) //类型及属性匹配，is表达式
            {
                Console.WriteLine($"Name of {nameof(Cat)} is {name}");
            }
            string sound = "";
            switch (a) //匹配switch语句
            {
                case Dog d when d.Name == "hola":
                    sound = "woof... hola" + d.BarkLikeCrazy();
                    break;
                case Dog d:
                    sound = "woof..." + d.BarkLikeCrazy();
                    break;
                case Cat c:
                    sound = "meow";
                    break;
                case IEnumerable<Animal> l when l.Any():
                    //TODO: any logic;
                    break;
                case null:
                    sound = "no animal";
                    break;
                default:
                    sound = "I'm mute..";
                    break;
            }
            Console.WriteLine($"{a.ToString()} - {sound}");
        }
    }
}
```
注1：模式匹配的**部分**高级feature，已经确认在C#7.0中移除，可能出现在后续C#版本中。(#[10888](https://github.com/dotnet/roslyn/pull/10888))。
注2：目前（*2016-06-15*）[VS15的最新Preview](https://www.visualstudio.com/en-us/downloads/visual-studio-next-downloads-vs.aspx)下，模式匹配的部分语法依然无法使用。
注3：由于目前仍然未在[Roslyn](https://github.com/dotnet/roslyn)中Release，后期有变动的可能，本文中涉及的样例代码以[Mads Torgersen](https://github.com/MadsTorgersen)在#[Build 2016](https://channel9.msdn.com/Events/Build/2016/B889)上的演示的语法为准，本文涉及的案例有可能无法在VS15 RTM后正常使用，仅供参考。
　　（当然，如果笔者乐意，会及时把后期得到确认的变更更新到本文中 ^_^!）
目前(2016年6月)C#7.0还未正式发布，大家如果想体验部分特性，可以去下载[VS15预览版](https://www.visualstudio.com/downloads/visual-studio-next-downloads-vs)，最终发布的语法可能和本文中提及的有所不同，最新动态请大家关注[Roslyn](https://github.com/dotnet/roslyn)项目。
