# 邪恶的编程咒语 - 文章 - 伯乐在线
本文由 [伯乐在线](http://blog.jobbole.com) - [精算狗](http://www.jobbole.com/members/chenyahui) 翻译。未经许可，禁止转载！
英文出处：[9tabs](http://9tabs.com/random/2017/12/23/evil-coding-incantations.html)。欢迎加入[翻译组](https://github.com/jobbole/translation-project)。
自从我看了 Gary Bernhardt 备受推崇的一个视频 [Wat](https://www.destroyallsoftware.com/talks/wat)，就惊异于特定编程语言的怪异行为。相较于其他编程语言来说，某些编程语言的行为更出乎意料。例如，有[一整本书](http://amzn.to/2zoCGSn)是针对 Java 的边缘案例和古怪情况。同样，差不多只要 200 美元你就可以阅读 [C++ 规范说明](https://www.iso.org/standard/68564.html)了。
![](http://wx3.sinaimg.cn/large/7cc829d3gy1fo80ho6bhuj20fu09twfy.jpg)
下面是我最喜欢的、惊奇的、滑稽的并仍然有效的咒语集合。一般来讲，利用这些古怪的行为被视为*坏事*，因为代码不应该出乎意料。值得庆幸的是，如果你尝试以下大多数蠢事，有很多代码校检工具（linters）已经准备好嘲笑你了。说了这么多，知识就是力量，那就开始吧。
### Python 2 中对 True 邪恶的重赋值


```
>>> True = False
>>> True
False
```
谢天谢地，这在 Python 3 中会导致 SyntaxError，因为[True、False 和 None 现在是保留字](https://docs.python.org/3.0/whatsnew/3.0.html)。它仍远没有 C++ 的那个恶作剧那么邪恶，把 #define true false 悄悄写进同事的开发机器的标准头文件中。
### Java 和 Python 中的诡异行为实例
对 Java 新手程序员来说，== 的语义往往使人困惑。甚至在微不足道的情境下，这个操作符的前后矛盾也会使情况变得复杂，即使性能效益是值得的。


```
Integer a = 100;
Integer b = 100;
System.out.print(a == b); // prints true
Integer c = 200;
Integer d = 200;
System.out.print(c == d); // prints false
```
JVM 会对区间 [-128, 127] 内的值使用相同的引用。更奇怪的是，Python 中也有同样的行为。


```
>>> x = 256
>>> y = 256
>>> x is y
True
>>> x = 257
>>> y = 257
>>> x is y
False
```
目前为止，还没有特别出乎意料的。


```
>>> x = -5
>>> y = -5
>>> x is y
True
>>> x = -6
>>> y = -6
>>> x is y
False
```
似乎 python 解释器使用相同例子的下限是……-5。区间 [-5, 256] 内的整数有同样的 ID。不知怎地，这变得更奇怪了。


```
>>> x = -10
>>> y = -10
>>> x is y
False
>>> x, y = [-10, -10]
>>> x is y
True
```
似乎使用解构赋值改变了这里的规则。我不确定为什么是这样。事实上，我在 [Stack Overflow 上提了一个问题](https://stackoverflow.com/questions/47958141/what-is-the-difference-between-destructured-assignment-and-normal-assignment)来试着理解它。我的猜测是，一个列表中的重复值指向同一个对象，用以节省内存。
### C 中颠倒的下标符号
颠倒的下标符号，会使所有开发者都头疼。


```
int x[1] = { 0xdeadbeef };
printf("%xn", 0[x]); // prints deadbeef
```
这行得通的原因是，array[index] 确实只是 *(array + index) 的语法糖。由于加法的交换性，我们可以交换数组和索引，并得到同样的结果。
### C 中的“倒数”操作符
–> 操作符第一次被看到时，似乎是句法错误。在你意识到它可编译时，它看起来像未被记载的语言特性。幸运的是，两者都不是。


```
for (x = 3; x --> 0;) {
    printf("%d ", x); // prints 2 1 0
}
```
–> “操作符”实际上是两个操作符，在这个背景下解析为 (x–) > 0。众所周知，大量使用会导致困惑，这完全是邪恶的。
### C 中的 sizeof 操作符
sizeof 操作符是一个编译时操作符，这给予了它有趣的属性。


```
int x = 0;
sizeof(x += 1);
if (x == 0) {
    printf("wtf?"); // this will be printed
}
```
由于 sizeof 操作符的例子是对编译时进行评估的，(x += 1) 不会运行。另一件趣事是，研究表明 printf(“wtf?”) 是最普遍的没有被 push 的代码。
### Lua、Smalltalk、MATLAB 及其他语言，索引由 1 开始
[/r/programminghumor](https://www.reddit.com/r/ProgrammerHumor/) 一直在用“[indexing](https://goo.gl/QreBLU)[starts](https://goo.gl/bm8Akz)[at](https://goo.gl/joQ9gt)[1](https://goo.gl/MM5BwP)”表情包取乐。令人震惊的是，有大量编程语言使用从 1 开始的数组索引。可以在[这里](https://goo.gl/kASpE7)找到更全面的清单。
### Ruby 中的 0 被判为 true
… and only Ruby. *
在 Ruby 中是这样。*


```
if 0 then print 'thanks, ruby' end # prints thanks, ruby
```
* edit: It was pointed out on [reddit](https://goo.gl/gnm654) that this is true for Lua, Lisp, and Erlang as well.
* 修订：Reddit 上有人指出，这在 Lua、Lisp 和 Erlang 中也成立。
Trigraph, Digraphs, and Tokens in C
### C 中的 Trigraph、Digraph 和 Token
由于历史原因，C 语言中的非字母符号有替代品。
![](http://wx2.sinaimg.cn/large/7cc829d3gy1fo80hoo0iij20cz0993zc.jpg)


```
if (true and true) { // same as if (true && true)
    printf("thanks, c");
}
```
有些外国设备，例如 IBM 3270，在 C/C++ 中不提供某些常用符号，所以提供了 digraph、trigraph 和 token 来避免排斥特定字符集。
