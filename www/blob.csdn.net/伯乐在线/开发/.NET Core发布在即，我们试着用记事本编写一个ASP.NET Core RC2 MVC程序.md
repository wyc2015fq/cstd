# .NET Core发布在即，我们试着用记事本编写一个ASP.NET Core RC2 MVC程序 - 文章 - 伯乐在线
原文出处： [蒋金楠](http://www.cnblogs.com/artech/p/5496211.html)
在.NET Core 1.0.0 RC2即将正式发布之际，我也应应景，针对RC2 Preview版本编写一个史上最简单的MVC应用。由于VS 2015目前尚不支持，VS Code的智能感知尚欠火候，所以我们直接采用最原始的记事本来编写这个MVC应用。[源代码从[这里](http://files.cnblogs.com/files/artech/HelloWorld.7z)下载]
# 步骤一、安装最新的.NET Core SDK
我们可以根据自身的操作系统环境从[https://github.com/dotnet/cli](https://github.com/dotnet/cli)上下载.NET Core最新的SDK，这个SDK包含.NET Core Runtime和一些有用工具（比如命令行）。如果你已经安装了老旧的版本，我个人建议你先将其卸载。
![rc2](http://jbcdn2.b0.upaiyun.com/2016/05/6d3b35760d4029703d0f07efcab4e6a5.png)
目前的版本为1.0.0-preview1-002702，我们可以执行dotnet –version命令确认是否是这个版本。
![image](http://jbcdn2.b0.upaiyun.com/2016/05/299d3b764f4fed44e08dc16da346d688.png)
# 步骤二、定义源代码和配置
我们创建一个目录（假设为C:HelloWorld）来存放MVC应用所有的源文件。下图展现了定义在这个目录下的所有文件。
![image](http://jbcdn2.b0.upaiyun.com/2016/05/5343782a68173bd2ecde00ddc5667b91.png)
## 定义NuGet.config
我们在NuGet.config文件中定义应用程序使用的NuGet包所在的站点地址（https://www.myget.org/F/aspnetrc2/api/v3/index.json

Visual Basic .NET
```
<?xml version="1.0" encoding="utf-8"?>
  <configuration>
   <packageSources>
      <add key="RC2" value="https://www.myget.org/F/aspnetrc2/api/v3/index.json" />
   </packageSources>
/configuration>
```
## 定义Project.json
定义在Project.json文件中的所有配置如下所示，我们会发现它与RC1中的Project.json不太一样。RC2中，我们可以向定义普通依赖一样来选择运行时（Microsoft.NETCore.App），或者说运行时本质已经成为了一个一般意义上的以来。除了这个针对运行时的依赖，我们还添加了两个依赖，它们分别是“Microsoft.AspNetCore.Mvc”和“Microsoft.AspNetCore.Server.Kestrel”，前者定义了ASP.NET Core MVC的核心框架，后者则提供了一个针对Kestrel的Server （ASP.NET Core管道中的Server专门负责请求的监听、接收和回复）。我们在“framework”节点添加了一个名为“netcoreapp1.0”的框架，之前的名称叫做“dnxcore50”。

Visual Basic .NET
```
{
      "version": "1.0.0-*",
      "buildOptions": {
        "emitEntryPoint": true
      },
      "dependencies": {
        "Microsoft.NETCore.App": {
          "type": "platform",
          "version": "1.0.0-rc2-3002702"
       },
       "Microsoft.AspNetCore.Mvc":"1.0.0-rc2-final",
       "Microsoft.AspNetCore.Server.Kestrel":"1.0.0-rc2-final"
     },
     "frameworks": {
       "netcoreapp1.0": {
         "imports": "dnxcore50"
       }
     }
   }
```
## 定义入口程序
启动应用的入口程序定义在Program.cs。如下面的代码片段所示，我们在这个文件中定义了一个Program类型，并在Main方法中编写了启动MVC应用的代码。具体来说，我们创建了一个WebHostBuilder对象通过调用扩展方法UseKestrel为构建的HTTP消息处理管道注册了一个Kestrel服务器。在调用UseStartup方法将Startup设置为启动类型之后，我们调用Build方法创建了一个WebHost对象。我们最终调用Run方法启动WebHost，进而启动了我们的MVC应用。

Visual Basic .NET
```
using Microsoft.AspNetCore.Hosting;
 using Microsoft.AspNetCore.Builder;
     
    public class Program
    {
        public static void Main(string[] args)
        {
            new WebHostBuilder()
            .UseKestrel()
           .UseStartup()
           .Build()
           .Run();
       }
   }
```
## 定义初始化类型
ASP.NET Core应用启动的时候会先执行一段初始化操作来构建一个完整的HTTP消息处理管道，这些初始化操作定义在Startup.cs。上面调用WebHostBuilder的UseStartup方法指定的类型Startup就定义在这个文件中。如下面的代码片段所示，我们在ConfigureServices方法中注册了与MVC相关的服务，并利用Configure方法将实现MVC框架的中间件注册到消息处理管道中。

Visual Basic .NET
```
using Microsoft.AspNetCore.Builder;
 using Microsoft.Extensions.DependencyInjection;
    
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
        }
    
       public void Configure(IApplicationBuilder app)
       {
           app.UseMvc();
       }
   }
```
## 定义Controller
我们在HomeController中定义了MVC应用中唯一的一个Controller，并按照如下的形式定义了一个唯一的Action方法。这个Action方法返回一个简单的字符串“Hello World”，并映射为应用的根地址（“/”）

Visual Basic .NET
```
using Microsoft.AspNetCore.Mvc;
    public class HomeController : Controller
    {
        [HttpGet("/")]
        public string Index() 
        {
            return "Hello World";          
        }
    }
```
# 步骤三、运行程序
RC2提供了一个非常强大的命令行（dotnet），包括恢复NuGet包以及编译执行.NET应用的相关操作都可以通过它来完成
## 恢复NuGet包
我们打开命令行工具并切换到应用所在的目录，执行dotnet restore命令恢复在project.json中使用的NuGet包。
![image](http://jbcdn2.b0.upaiyun.com/2016/05/15562e4ef7616162dc00e04db0a4b5d1.png)
## 编译执行程序
我们直接执行dotnet build命令对整个应用实施编译，然后执行dotnet run命令启动我们的MVC应用。
![image](http://jbcdn2.b0.upaiyun.com/2016/05/ecaf050d964ac2f89f9cdd0bf60dafdc.png)
## 向HomeController发起请求
当程序启动后，Kestrel服务器会利用5000端口对HTTP请求实施监听。由于定义在HomeController的Action方法Index被映射为应用根地址，所以我们利用浏览器向该地址发送请求会得到这个Action方法的响应结果。
![image](http://jbcdn2.b0.upaiyun.com/2016/05/9ad620d9fe95913bdc5ac0b17d390c5e.png)
