# C# 7.0 新特性（1）： 基于Tuple的“多”返回值方法 - 文章 - 伯乐在线
原文出处： [Hover Zuo](http://www.cnblogs.com/ylvict/p/5573094.html)
*本文基于Roslyn项目中的Issue:#[347](https://github.com/dotnet/roslyn/issues/347) 展开讨论.*
**1. *[C# 7.0 新特性1： 基于Tuple的“多”返回值方法](http://blog.jobbole.com/102521/)*
*　　2. [C# 7.0 新特性2： 本地方法](http://blog.jobbole.com/102439/)*
*　　3. [C# 7.0 新特性3： 模式匹配](http://blog.jobbole.com/102522/)*
**回顾**
首先，提出一个问题，C#中，如何使一个方法可返回”多个”返回值？
我们先来回顾一下C#6.0 及更早版本的做法。
在C#中，通常我们有以下4种方式使一个方法返回多条数据。
- 使用 KeyValue 组合


C#
```
static void Main(string[] args)
{
    int int1 = 15;
    int int2 = 25;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine(result.Key);
    Console.WriteLine(result.Value);
}
private static KeyValuePair<int, int> Add_Multiply(int int1, int int2)
{
    var KeyValuePair = new KeyValuePair<int, int>(int1 + int2, int1 * int2);
    return KeyValuePair;
}
```
- 使用 ref/out 参数
- Ref


C#
```
static void Main(string[] args)
{
    int int1 = 15;
    int int2 = 25;
    int add = 0;
    int multiply = 0;
    Add_Multiply(int1, int2, ref add, ref multiply);
    Console.WriteLine(add);
    Console.WriteLine(multiply);
}
private static void Add_Multiply(int int1, int int2, ref int add, ref int multiply)
{
    add = int1 + int2;
    multiply = int1 * int2;
}
```
- Out


C#
```
static void Main(string[] args)
{
    int int1 = 15;
    int int2 = 25;
    int add = 0;
    int multiply = 0;
    Add_Multiply(int1, int2, out add, out multiply);
    Console.WriteLine(add);
    Console.WriteLine(multiply);
}
private static void Add_Multiply(int int1, int int2, out int add, out int multiply)
{
    add = int1 + int2;
    multiply = int1 * int2;
}
```
- 使用 struct 或者 class
- struct


C#
```
struct Result
{
    public int add;
    public int multiply;
}
static void Main(string[] args)
{
    int int1 = 53;
    int int2 = 17;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine(result.add);
    Console.WriteLine(result.multiply);
}
private static Result Add_Multiply(int int1, int int2)
{
    var result = new Result
    {
        add = int1 + int2,
        multiply = int1 * int2
    };
    return result;
}
```
- class


C#
```
class Result
{
    public int add;
    public int multiply;
}
static void Main(string[] args)
{
    int int1 = 13;
    int int2 = 27;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine(result.add);
    Console.WriteLine(result.multiply);
}
private static Result Add_Multiply(int int1, int int2)
{
    var result = new Result
    {
        add = int1 + int2,
        multiply = int1 * int2
    };
    return result;
}
```
- dynamic


C#
```
static void Main(string[] args)
{
    int int1 = 13;
    int int2 = 27;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine(result.add);
    Console.WriteLine(result.multiply);
}
private static dynamic Add_Multiply(int int1, int int2)
{
    var result = new
    {
        add = int1 + int2,
        multiply = int1 * int2
    };
    return result;
}
```
- 使用 Tuple


C#
```
static void Main(string[] args)
{
    int int1 = 25;
    int int2 = 28;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine(result.Item1);
    Console.WriteLine(result.Item2);
}
private static Tuple<int, int> Add_Multiply(int int1, int int2)
{
    var tuple = new Tuple<int, int>(int1 + int2, int1 * int2);
    return tuple;
}
```
Okay, 回顾的废话有些多了。我们来看看C#7.0中的写法
**新特性（C#7.0）**
老规矩，先上代码


C#
```
static void Main(string[] args)
{
    int int1 = 25;
    int int2 = 28;
    var result = Add_Multiply(int1, int2);
    Console.WriteLine($"Add: {result.add}, Multiply: {result.multiply}");
    //(var add, var multiply) = Add_Multiply(int1, int2);
    //Console.WriteLine($"Add: {add}, Multiply: {multiply}");
}
public (int add, int multiply) Add_Multiply(int int1, int int2) 
    => (int1 + int2, int1 * int2);
```
怎么样？比起6.0及以前的C#，有没有一种非常清爽的感觉。
其实只是基于Tuple 做了语法简化的语法糖罢了，只是给人一种多个返回值的错觉。
**总结**
这个特性虽然不是多么振奋人心的变化，但是解决了之前很多码农的一些痒点。
1. 看看KeyValue对的方式，本来很简单的一个操作，写出来的代码会显得非常的笨拙，取值的时候又根据Key获取。而且，最重要的是，如果不在运行时，外面调用的代码是不知道有那些Key的。
2. 再说Ref/Out，这种方式应该是传统意义上最流行的写法了。甚至C#7.0的该特性，也无法取缔ref在一定情景下的性质。但至少在ref用于返回值这种情况下，代码体现出的风格明显是和实际逻辑不符合的，明明是返回值，却要以参数的形式进出，非常不合理。
3. struct和class的方式就不多说了，如果你针对的是**一个**实体，还能讲得通，但如果本身目的是返回多个相关性不大的数据，专门为方法间传递而加一个本没有用处的Model类或结构，只能说是当时解决方案下的无奈。dynamic虽然从**表现形式**上没有这种问题，但是存在更坑的问题是，除非在运行时，否则外部调用代码根本不知道方法里传出来什么。
4. 说到传统的Tuple，其实是和该特性最接近的了，但是看看调用时的*.Item1，*.Item2 。。天知道都是何物。即使在实现方法里，也让人面对这种只见类型不见实际意义的值表示一头雾水。
目前(2016年6月)C#7.0还未正式发布，大家如果想体验部分特性，可以去下载[VS15预览版](https://www.visualstudio.com/downloads/visual-studio-next-downloads-vs)，最终发布的语法可能和本文中提及的有所不同，最新动态请大家关注[Roslyn](https://github.com/dotnet/roslyn)项目。
