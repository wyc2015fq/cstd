# 计算机中的浮点运算 - 文章 - 伯乐在线
本文由 [伯乐在线](http://blog.jobbole.com) - [Sheng Gordon](http://www.jobbole.com/members/shenggordon) 翻译，[至秦](http://www.jobbole.com/members/applevip) 校稿。未经许可，禁止转载！
英文出处：[Erik Wiffin](http://0.30000000000000004.com/)。欢迎加入[翻译组](https://github.com/jobbole/translation-project)。
文章讨论了计算机中的浮点运算问题，给出了各种不同语言的浮点输出。
![](http://ww1.sinaimg.cn/large/7cc829d3gw1emoaetimcqj20c80h4my1.jpg)
### 浮点数运算
你使用的语言并不烂，它能够做浮点数运算。计算机天生只能存储整数，因此它需要某种方法来表示小数。这种表示方式会带来某种程度的误差。这就是为什么往往 0.1 + 0.2 不等于 0.3。
### 为什么会这样？
实际上很简单。对于十进制数值系统（就是我们现实中使用的），它只能表示以进制数的质因子为分母的分数。10 的质因子有 2 和 5。因此 1/2、1/4、1/5、1/8和 1/10 都可以精确表示，因为这些分母只使用了10的质因子。相反，1/3、1/6 和 1/7 都是循环小数，因为它们的分母使用了质因子 3 或者 7。二进制下（进制数为2），只有一个质因子，即2。因此你只能精确表示分母质因子是2的分数。二进制中，1/2、1/4 和 1/8 都可以被精确表示。但是，1/5 或者 1/10 就变成了循环小数。所以，在十进制中能够精确表示的 0.1 与 0.2（1/10 与 1/5），到了计算机所使用的二进制数值系统中，就变成了循环小数。当你对这些循环小数进行数学运算时，并将二进制数据转换成人类可读的十进制数据时，会对小数尾部进行截断处理。
### 下面是在不同的语言中，运行 0 .1 + 0.2 的输出结果：
|**语言**|**代码**|**结果**|
|----|----|----|
|C|#include<stdio.h>int main(int argc, char* argv) {printf(“%.17fn”, .1+.2);return 0;}|0.30000000000000004|
|C++|#include <iomanip>std::cout << setprecision(17) << 0.1 + 0.2 << std.endl;|0.30000000000000004|
|PHP|echo .1 + .2;|0.3|
|注1：PHP 将 0.30000000000000004 格式化成字符串时，会把它缩短成 “0.3”。为了得到需要的浮点数结果，在 ini文件中调整精度设置：iniset(“precision”, 17)。| | |
|MySQL|SELECT .1 + .2;|0.3|
|Postgres|SELECT select 0.1::float + 0.2::float;|0.3|
|Delphi XE5|writeln(0.1 + 0.2);|3.00000000000000E-0001|
|Erlang|io:format(“~w~n”, [0.1 + 0.2]).|0.30000000000000004|
|Elixir|IO.puts(0.1 + 0.2)|0.30000000000000004|
|Ruby|puts 0.1 + 0.2 And puts 1/10r + 2/10r|0.30000000000000004 And 3/10|
|注2：Ruby 2.1及以后版本在语法上支持有理数。对于老版本，请使用 [Rational](http://ruby-doc.org/core/classes/Rational.html)。Ruby还有一个专门处理小数的库： [BigDecimal](http://ruby-doc.org/stdlib/libdoc/bigdecimal/rdoc/index.html)。| | |
|Python 2|print(.1 + .2)float(decimal.Decimal(“.1”) + decimal.Decimal(“.2”))  .1 + .2|0.30.30.30000000000000004|
|注3：Python 2 中的 “print” 语句将 0.30000000000000004 转成一个字符串，并缩短成 “0.3”。为了达到需要的浮点数结果，使用 print(repr(.1 + .2))。在 Python 3中这是内置设定（见下面例子）。| | |
|Python 3|print(.1 + .2).1 + .2|0.300000000000000040.30000000000000004|
|Lua|print(.1 + .2) print(string.format(“%0.17f”, 0.1 + 0.2))|0.3 0.30000000000000004|
|JavaScript|document.writeln(.1 + .2);|0.30000000000000004|
|Java|System.out.println(.1 + .2);System.out.println(.1F + .2F);|0.300000000000000040.3|
|Julia|.1 + .2|0.30000000000000004|
|注4：Julia 内置 [支持有理数](http://docs.julialang.org/en/release-0.4/manual/complex-and-rational-numbers/#rational-numbers) ，并且还有一个内置的数据类型[BigFloat](http://docs.julialang.org/en/release-0.4/manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic)，它支持任意精度 。要得到正确的运算结果，使用 1//10 + 2//10 会返回3//10。| | |
|Clojure|(+ 0.1 0.2)|0.30000000000000004|
|注5：Clojure 支持任意精度的数据。 (+ 0.1M 0.2M) 返回 0.3M，而 (+ 1/10 2/10) 返回 3/10。| | |
|C#|Console.WriteLine(“{0:R}”, .1 + .2);|0.30000000000000004|
|GHC (Haskell)|0.1 + 0.2|0.30000000000000004|
|注6：Haskell 支持有理数。要得到正确的运算结果，使用 (1 % 10) + (2 % 10) 返回 3 % 10。| | |
|Hugs (Haskell)|0.1 + 0.2|0.3|
|bc|0.1 + 0.2|0.3|
|Nim|echo(0.1 + 0.2)|0.3|
|Gforth|0.1e 0.2e f+ f.|0.3|
|dc|0.1 0.2 + p|.3|
|Racket (PLT Scheme)|(+ .1 .2) And (+ 1/10 2/10)|0.30000000000000004 And 3/10|
|Rust|extern crate num; use num::rational::Ratio; fn main() { println!(.1+.2); println!(“1/10 + 2/10 = {}”, Ratio::new(1, 10) + Ratio::new(2, 10)); }|0.30000000000000004 3/10|
|注7：Rust 中，使用 [num crate](https://doc.rust-lang.org/num/num/index.html) 支持获得 [有理数支持](https://doc.rust-lang.org/num/num/rational/struct.Ratio.html) 。| | |
|Emacs Lisp|(+ .1 .2)|0.30000000000000004|
|Turbo Pascal 7.0|writeln(0.1 + 0.2);|3.0000000000E-01|
|Common Lisp|(+ .1 .2) And * (+ 1/10 2/10)|0.3 And 3/10|
|Go|package main import “fmt” func main() { fmt.Println(.1 + .2) var a float64 = .1 var b float64 = .2 fmt.Println(a + b) fmt.Printf(“%.54fn”, .1 + .2) }|0.3 0.30000000000000004 0.299999999999999988897769753748434595763683319091796875|
|注8：[Go语言的数字常数有任意精度](http://blog.golang.org/constants#TOC_8.)。| | |
|Objective-C|0.1 + 0.2;|0.300000012|
|OCaml|0.1 +. 0.2;;|float = 0.300000000000000044|
|Powershell|PS C:>0.1 + 0.2|0.3|
|Prolog (SWI-Prolog)|?- X is 0.1 + 0.2.|X = 0.30000000000000004.|
|Perl 5|perl -E ‘say 0.1+0.2’ perl -e ‘printf q{%.17f}, 0.1+0.2’|0.3 0.30000000000000004|
|Perl 6|perl6 -e ‘say 0.1+0.2’ perl6 -e ‘say sprintf(q{%.17f}, 0.1+0.2)’ perl6 -e ‘say 1/10+2/10’|0.3 0.30000000000000000 0.3|
|注9：Perl 6 与 Perl 5 不同，默认使用有理数。因此 .1 被存储成类似这样 { 分子 => 1, 分母 => 10 }.| | |
|R|print(.1+.2) print(.1+.2, digits=18)|0.3 0.300000000000000044|
|scala|scala -e ‘println(0.1 + 0.2)’ And scala -e ‘println(0.1F + 0.2F)’ And scala -e ‘println(BigDecimal(“0.1”) + BigDecimal(“0.2”))’|0.30000000000000004 And 0.3 And 0.3|
|Smalltalk|0.1 + 0.2.|0.30000000000000004|
|Swift|0.1 + 0.2|0.3|
|D|import std.stdio; void main(string[] args) { writefln(“%.17f”, .1+.2); writefln(“%.17f”, .1f+.2f); writefln(“%.17f”, .1L+.2L); }|0.29999999999999999 0.30000001192092896 0.30000000000000000|
更多参考资料：| [wikipedia](http://en.wikipedia.org/wiki/Floating_point) | [IEEE 754](http://grouper.ieee.org/groups/754/) | [Stack Overflow](http://stackoverflow.com/questions/588004/is-javascripts-math-broken/588014)
我是Erik Wiffin。联系方式： [erik.wiffin.com](http://erik.wiffin.com/) 或者 [erik.wiffin@gmail.com](mailto:erik.wiffin@gmail.com)。
这个项目已经放在 [github](https://github.com/erikwiffin/0.30000000000000004)。如果你觉得这个页面需要改进，发消息给我。
