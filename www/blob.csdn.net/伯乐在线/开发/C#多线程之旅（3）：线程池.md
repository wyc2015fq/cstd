# C#多线程之旅（3）：线程池 - 文章 - 伯乐在线
原文出处： [jackson0714](http://www.cnblogs.com/jackson0714/p/5118814.html)
> 
先交代下背景，写《C#多线程之旅》这个系列文章主要是因为以下几个原因：1.多线程在C/S和B/S架构中用得是非常多的;2.而且多线程的使用是非常复杂的，如果没有用好，容易造成很多问题。
![](http://jbcdn2.b0.upaiyun.com/2016/06/7fa7eff54ac8d3c7d0bef5fc872636df.png)
多线程，有利也有弊，使用需谨慎。
[C#多线程之旅(1)——介绍和基本概念](http://blog.jobbole.com/101923/)
[C#多线程之旅(2)——创建和开始线程](http://blog.jobbole.com/101924/)
[C#多线程之旅(3)——线程池](http://blog.jobbole.com/101926/)
***更多文章正在更新中，敬请期待……***
C#多线程之旅(3)——线程池
# 代码下载
Thread_博客园_cnblogs_jackson0714.zip
第一篇~第三篇的代码示例：
![](http://jbcdn2.b0.upaiyun.com/2016/06/d6690cdf61e89355f3a9478f680b1ec6.png)
源码地址：[https://github.com/Jackson0714/Threads](https://github.com/Jackson0714/Threads)
# 一、介绍
无论你什么时候开始一个线程，几百毫秒会花在整理一个新的local variable stack。每一个线程默认会消耗1MB的内存。线程池通过分享和回收线程来削减这些开销，允许多线程被应用在一个非常颗粒级的级别而没有性能损失。当充分利用多核系统去执行密集型计算的并行代码时这是非常有用的。
线程池也会在线程的总数量上保持一个限制，从而使线程能够更平稳地运行。太多的线程将会造成管理负担和使CPU缓存是小，从而造成操作系统不能运行。一旦一个限制到达，job排队等待直到另外一个完成才开始。这会使任意的并行应用程序成为可能，比如一个web server（同步方法是高级技巧，可以更高效地使用线程池中的线程）。
**下面是几种方式进入线程池：**
- 通过Task Parallel Library（.NET 4.0）
- 通过调用ThreadPool.QueueUserWorkItem
- 通过asynchronous delegates
- 通过BackgroundWorkder
**下面的结构直接使用线程池：**
- WCF,Remoting,ASP.NET,ASMX Web Services application servers
- System.Timers.Timer and System.Threading.Timer
- Framework methods 由Async结束，比如WebClient(the event-based asynchronous pattern)和大部分的BeginXXX方法(the asynchronous programming model pattern)
- PLINQ
**Task Parallel Library(TPL)**和PLINQ是充分有效的和高等级的，甚至当线程池是不重要的时候，你也会想使用它们去协助处理多线程。
现在我们简单的看一下我们怎样使用Task类来实现一个简单的运行在线程池上的委托。
**当使用线程池时需要注意下面的事情：**
- 你不能设置一个线程的名字，因为设置线程的名字将会使调试更困难（当你在VS线程窗口中调试时，即使你可以附加一个描述）。
- 线程池中的线程总是后台线程（这通常不是问题）。
- 在应用程序的开始期间，阻塞一个线程可能会触发一个延迟，除非你调用ThreadPool.SetMinThreads
你不能任意地改变池中的线程的优先级–因为当它释放会池中的时候，优先级会被还原为正常状态。
你可以通过属性Thread.CurrentThread.IsThreadPoolThread的属性查询线程是否是正在运行的一个池中的线程
# 二、通过TPL进入线程池
你可以使用在TaskParallel Library中的Task类来轻松的进入线程池。这个Task类在Framework 4.0中有介绍：如果你对老的结构比较熟悉，考虑用非泛型的Task类替换***ThreadPool.QueueUserWorkItem***，将**Asunchoronous** delgates替换为泛型***Task***。最新的结构速度更快，更方便，而且更复杂。
为了使用非泛型的任务类，调用**Task.Factory.StartNew**方法，将方法传进委托中。
**Task.Factory.StartNew**会返回一个Task对象，你可以使用它去监控这个task，比如，你可以调用它的wait方法等待它直到它完成。


C#
```
static void Main(string[] args)
{
	Task task =  Task.Factory.StartNew(Go);
	task.Wait();
	Console.ReadKey();
}
static void Go()
{
	Console.WriteLine("From the thread pool start...");
	Thread.Sleep(3000);
	Console.WriteLine("From the thread pool end");
}
```
当你调用task的**Wait**方法时，一个未处理的异常会很容易地重新抛出到宿主线程上。（如果你不调用Wait方法而是放弃这个task，一个未处理的异常将会关闭掉这个进程）
泛型**Task**类是非泛型Task的子类。它让你从这个已经完成执行的task中得到一个返回值。在下面的例子中，我们使用**Task**来下载一个web page


C#
```
static void Main(string[] args)
{
	Task task = Task.Factory.StartNew(
		() => DownloadString("http://www.baidu.com"));
	//调用其他方法
	//
	//可以用task的Result的属性来获得task返回值。
	//如果这个任务还在运行，当前的主线程将会被阻塞，直到这个任务完成。
	string result = task.Result;
}
static string DownloadString(string uri)
{ 
	using(var wc = new System.Net.WebClient())
	{
		return wc.DownloadString(uri);
	}
}
```
Task Parallel Library有许多的功能，特别是提升多核处理器的性能。我们会在并行编程中继续讨论TPL。
# 三、不用TPL进入到线程池
如果你的应用程序是.NET Framework的早期版本（4.0之前的版本），你将不能使用TPL。你必须使用老的结构进入线程池：
**ThreadPool.QueueUserWorkItem**和**asynchoronous** delegates.两者的不同点是**asynchronous** delegates让你从线程那里返回数据。**Asynchronous** delegates收集任何exception返回给调用者。
要使用**QueueUserWorkItem**，只需调用这个方法的运行在线程池上的委托。


C#
```
static void Main(string[] args)
{
	ThreadPool.QueueUserWorkItem(Go);
	ThreadPool.QueueUserWorkItem(Go, 123);
	Console.ReadKey();
}
static void Go(object data)
{
	Console.WriteLine("A from thread pool! " + data);
}
```
![](http://jbcdn2.b0.upaiyun.com/2016/06/75a43ca0a2f6634ec086b57124c4e927.png)
我们的目标方法Go，必须接收一个简单object类型的参数（为了满足waitCallBack委托）。这将提供一个简单的方式传递数据到方法中，就像是ParameterizedThreadStart。不像Task，QueueUserWorkItem不会返回一个对象去帮助你之后管理执行。还有，你必须显式在目标方法的代码中写处理异常的代码–因为未处理的异常将会终止程序。
**ThreadPool.QueueUserWorkItem**没有提供从一个已经完成的线程中得到它的返回值的机制。**Asynchronous** delegate invocations(asynchronous delegates for short)解决了这个问题，允许任何个数类型化的参数在两个方向传递。此外，在asynchronous delegates上未处理的异常很方便地在原始线程上重新抛出（更准确地说，这个线程叫做EndInvoke）,因此不需要显示处理。
> 
不要混淆asynchronous delegates和asynchronous method（方法以Begin和End开头的，比如File.BeginRead/File.EndRead）。Asynchronous methods表面上按照简单的协议，但是它们的存在是为了解决一个更困难的问题。
**下面是怎样通过一个asynchronous delegate开始一个worker task:**
- 实例化一个委托，该委托针对你想要并行运行的method（典型的是预定义Func delegates其中的一种）。
- 在delegate上调用BeginInvoke，保存它的IAsyncResult返回值。BeginInvoke立即返回给调用者。当其他池中的线程正在运行的时候，你可以执行其他动作。
- 当你需要这个结果，在delegate上调用EndInvoke，传递已保存的IAsyncResult对象。
在下面的例子中，我们使用一个asynchronous delegate invocation运行一个与主线程同时运行的简单方法，这个方法返回一个字符串的长度：


C#
```
static void Main(string[] args)
{
	Func t = Go;
	IAsyncResult result = t.BeginInvoke("test", null, null);
	//
	// ... 这里可以执行其他并行的任务
	//
	int length = t.EndInvoke(result);
	Console.WriteLine("String lenth is： " + length);
	Console.ReadKey();
}
static int Go(string messsage)
{
	return messsage.Length;
}
```
EndInvoke做三件事情。第一，如果asynchronous delegate没有完成执行，则一直等待它完成。第二，接收返回值（以及任何ref或者out参数）。第三，返回任何未处理的线程异常给调用它的线程。
> 
注意：如果你用asynchronous delegate调用的方法没有返回值，你在技术上需要调用EndInvoke。在实践中，这是开放的辩论；没有Endinvoke报警去管理处罚未编译者！如果你选择不去调用EndInvoke，然而，你需要考虑在线程的异常去避免静默失败。
当你调用BeginInvoke方法时，可以指定一个call back delegate-一个可以接收一个IAsyncResult 对象的方法，它会在委托方法完成后被自动调用这个允许正在发动的线程忘记asynchronous delegate，但它在call back结束时需要一点额外的工作。
