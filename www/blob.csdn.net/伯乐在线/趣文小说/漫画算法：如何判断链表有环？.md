# 漫画算法：如何判断链表有环？ - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [玻璃猫](http://www.jobbole.com/members/bjweimengshu) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
大四毕业前夕，计算机学院，
正在四处求职的小灰碰到了同系的学霸大黄……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%af%a2%e9%97%ae](http://jbcdn2.b0.upaiyun.com/2016/09/38ba636097eda2805cc450cb4725ca1c.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%8f%b9%e6%b0%94](http://jbcdn2.b0.upaiyun.com/2016/09/0b84f879a6aa90d7c63f411c971f67f2.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%af%a2%e9%97%ae2](http://jbcdn2.b0.upaiyun.com/2016/09/7710ef25443ca392ce304049221d9644.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e6%b2%89%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/adeda02b4fb08e2fd8f79696b0190f61.jpg)
小灰边说边回忆着上周去面试的情形……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%981](http://jbcdn2.b0.upaiyun.com/2016/09/7478a3bb991ee1934ef13be39a77c891.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%af%a2%e9%97%ae1](http://jbcdn2.b0.upaiyun.com/2016/09/da52b7bac8b36c1e4060c3d0caa4aaf6.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%982](http://jbcdn2.b0.upaiyun.com/2016/09/a0a584fd748d058585d0c6950485fa05.jpg)
有一个单向链表，链表当中有可能出现“环”，就像下图这样。如何用程序判断出这个链表是有环链表？
![%e9%93%be%e8%a1%a8%e5%9b%be1](http://jbcdn2.b0.upaiyun.com/2016/09/264a694e303e5c817dbc14956575fda9.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/f63b548032b1dc4529859419e4578bc7.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%942](http://jbcdn2.b0.upaiyun.com/2016/09/d547e61fde48e536be05faad364ade6c.jpg)
**方法一：**首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。
例如这样的链表：A->B->C->D->B->C->D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。
假设从链表头节点到入环点的距离是D，链表的环长是S。那么算法的时间复杂度是0+1+2+3+….+(D+S-1) = (D+S-1)*(D+S)/2 ， 可以简单地理解成 O(N*N)。而此算法没有创建额外存储空间，空间复杂度可以简单地理解成为O(1)。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%983](http://jbcdn2.b0.upaiyun.com/2016/09/2781b0e0e3e2178c44cafb4f257b2c99.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/f63b548032b1dc4529859419e4578bc7.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%943](http://jbcdn2.b0.upaiyun.com/2016/09/889a52f5465ed2d1ef4d479a2444193b.jpg)
**方法二：**首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。
这个方法在流程上和方法一类似，本质的区别是使用了HashSet作为额外的缓存。
假设从链表头节点到入环点的距离是D，链表的环长是S。而每一次HashSet查找元素的时间复杂度是O(1), 所以总体的时间复杂度是1*(D+S)=D+S，可以简单理解为O(N)。而算法的空间复杂度还是D+S-1，可以简单地理解成O(N)。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%984](http://jbcdn2.b0.upaiyun.com/2016/09/547d3308bb1df3c4a7d21e5fe3f40135.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/f63b548032b1dc4529859419e4578bc7.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d2](http://jbcdn2.b0.upaiyun.com/2016/09/8b1b01bd69856bccbfb9c0436fa2d61a.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%980](http://jbcdn2.b0.upaiyun.com/2016/09/37bb3500fb70d3b09c5f4718159e7671.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%a4%b1%e6%9c%9b](http://jbcdn2.b0.upaiyun.com/2016/09/07c4eda635dccfd102cdeaf2a5df4cdf.jpg)
等通知就是没通知，这是职场上公认的语言。
以上就是小灰悲剧的回忆……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a31](http://jbcdn2.b0.upaiyun.com/2016/09/0edc3462629a01ead2c74530303a8740.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e6%b2%89%e6%80%9d2](http://jbcdn2.b0.upaiyun.com/2016/09/7d9a12fa00dba9f1bd5c938eea29cd86.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a32](http://jbcdn2.b0.upaiyun.com/2016/09/032aad6634b2fd9de0b8e461c1ca0583.jpg)
**方法三：**首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。
例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。
此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。
![%e8%b7%91%e9%81%93](http://jbcdn2.b0.upaiyun.com/2016/09/9058c117421ce4cab72339271939bbf3-300x225.jpg)
假设从链表头节点到入环点的距离是D，链表的环长是S。那么循环会进行S*K次，K为正整数（为什么是S*K次，有心的同学可以自己揣摩下），可以简单理解为O（N）。除了两个指针以外，没有使用任何额外存储空间，所以空间复杂度是O（1）。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a30](http://jbcdn2.b0.upaiyun.com/2016/09/87c43688050c401cc9e6bbffb6b7f89d.jpg)
**问题一：**判断两个单向链表是否相交，如果相交，求出交点。
![%e9%93%be%e8%a1%a8%e5%9b%be3](http://jbcdn2.b0.upaiyun.com/2016/09/2bd5a3df0069630a01f43fa8b735822b.jpg)
**问题二：**在一个有环链表中，如何找出链表的入环点？
![%e9%93%be%e8%a1%a8%e5%9b%be2](http://jbcdn2.b0.upaiyun.com/2016/09/d708c5c492ab1cccd889ffa8ee295e70.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%be%97%e6%84%8f](http://jbcdn2.b0.upaiyun.com/2016/09/626f86b8a7b2aafc3e207e4b99d6e6c0.jpg)
本人微信号：**bjweimengshu**
欢迎朋友们一起交流讨论，加好友请注明**伯乐在线** ：）
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
![](http://jbcdn2.b0.upaiyun.com/2016/10/2df4a3ede6e684f78858dfde0e7b118f.jpeg)
