# 漫画算法：辗转相除法是什么鬼？ - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [玻璃猫](http://www.jobbole.com/members/bjweimengshu) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
大四毕业前夕，计算机学院的小灰又一次顶着炎炎烈日，
去某IT公司面试研发工程师岗位……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%b5%b6%e8%b7%af](http://jbcdn2.b0.upaiyun.com/2016/09/7292e14def54437a0fa29cb72cbd8064.jpg)
半小时后，公司会议室，面试开始……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%981](http://jbcdn2.b0.upaiyun.com/2016/09/7478a3bb991ee1934ef13be39a77c891.jpg)
![](http://ww4.sinaimg.cn/large/7cc829d3gw1f8be4bv37uj2071076t8v.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%987](http://jbcdn2.b0.upaiyun.com/2016/09/eeba245c4d023e683bd96587dedac915.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%944](http://jbcdn2.b0.upaiyun.com/2016/09/5112a010242cb674f8a5ee541811439f.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%985](http://jbcdn2.b0.upaiyun.com/2016/09/2cc6caaac16d5736ca6baab4af657f63.jpg)
![%e9%9d%a2%e8%af%95%e5%ae%98%e5%82%b2%e6%85%a22](http://jbcdn2.b0.upaiyun.com/2016/09/42d98571dddbcb1983cda5a438bb6cf4.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/f63b548032b1dc4529859419e4578bc7.jpg)
小灰奋笔疾书，五分钟后……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%945](http://jbcdn2.b0.upaiyun.com/2016/09/a7b68adccc280de17ac0e86d0a4acf3f.jpg)
![%e4%bb%a3%e7%a0%811](http://jbcdn2.b0.upaiyun.com/2016/09/860b2ccd45c885528c6dc24637f73411.jpg)
小灰的思路十分简单。他使用暴力枚举的方法，试图寻找到一个合适的整数 i，看看这个整数能否被两个整型参数numberA和numberB同时整除。
这个整数 i 从2开始循环累加，一直累加到 numberA 和 numberB 中较小参数的一半为止。循环结束后，上一次寻找到的能够被两数整除的最大 i 值，就是两数的最大公约数。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%988](http://jbcdn2.b0.upaiyun.com/2016/09/917ff1d87ca250109be579482d4a3f11.jpg)
![%e9%9d%a2%e8%af%95%e5%ae%98%e5%82%b2%e6%85%a2](http://jbcdn2.b0.upaiyun.com/2016/09/b8db3170e3901a81bdc4fca62ef70b14.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d](http://jbcdn2.b0.upaiyun.com/2016/09/f63b548032b1dc4529859419e4578bc7.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e6%97%a0%e5%a5%88](http://jbcdn2.b0.upaiyun.com/2016/09/888981064ffdbcf246ec838beba0d75b.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%95%e5%ae%980](http://jbcdn2.b0.upaiyun.com/2016/09/37bb3500fb70d3b09c5f4718159e7671.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%a4%b1%e6%9c%9b](http://jbcdn2.b0.upaiyun.com/2016/09/07c4eda635dccfd102cdeaf2a5df4cdf.jpg)
事后，垂头丧气的小灰去请教同系的学霸大黄……
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a33](http://jbcdn2.b0.upaiyun.com/2016/09/e316896a3e9aa8dff03c419abf2c35da.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e6%97%a0%e5%a5%882](http://jbcdn2.b0.upaiyun.com/2016/09/760fca806cfd7a29a4ac6f0112930c24.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a34](http://jbcdn2.b0.upaiyun.com/2016/09/3a048d0d4bb2b84b6a303922fbca6ff0.jpg)
辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。它是已知最古老的算法， 其可追溯至公元前300年前。
这条算法基于一个定理：**两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。**比如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最大公约数。
![%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97](http://jbcdn2.b0.upaiyun.com/2016/09/37ebee33ccc946f3ce460b53d4b33595.jpg)
有了这条定理，求出最大公约数就简单了。我们可以使用递归的方法来把问题逐步简化。
首先，我们先计算出a除以b的余数c，把问题转化成求出b和c的最大公约数；然后计算出b除以c的余数d，把问题转化成求出c和d的最大公约数；再然后计算出c除以d的余数e，把问题转化成求出d和e的最大公约数……
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a35b](http://jbcdn2.b0.upaiyun.com/2016/09/a3762e4b77bca8d1a76fbd6d74df841b.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%946](http://jbcdn2.b0.upaiyun.com/2016/09/075fd3727e968854ddbcc2f64956fdbc.jpg)
五分钟后，小灰改好了代码……
![%e4%bb%a3%e7%a0%812](http://jbcdn2.b0.upaiyun.com/2016/09/d5053e41101c8805e7d7e1936da7aaa1.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a37](http://jbcdn2.b0.upaiyun.com/2016/09/5900dde0e5e88efdd5d8dc68db04e080.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d3](http://jbcdn2.b0.upaiyun.com/2016/09/9bd9e4290b8b5a7526a8eddbc7a06685.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a38](http://jbcdn2.b0.upaiyun.com/2016/09/d99cef9604c3f6fef3c304e4493b2b97.jpg)
更相减损术， 出自于中国古代的《九章算术》，也是一种求最大公约数的算法。
他的原理更加简单：**两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数****。**比如10和25，25减去10的差是15,那么10和25的最大公约数，等同于10和15的最大公约数。
![%e4%b9%9d%e7%ab%a0%e7%ae%97%e6%9c%af](http://jbcdn2.b0.upaiyun.com/2016/09/f7cfb42351201abab774d49594da7880.jpg)
由此，我们同样可以通过递归来简化问题。首先，我们先计算出a和b的差值c（假设a>b），把问题转化成求出b和c的最大公约数；然后计算出c和b的差值d（假设c>b），把问题转化成求出b和d的最大公约数；再然后计算出b和d的差值e（假设b>d），把问题转化成求出d和e的最大公约数……
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的两个数。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a39](http://jbcdn2.b0.upaiyun.com/2016/09/81100f2ee82970ab5967e510d8b10bfe.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%946](http://jbcdn2.b0.upaiyun.com/2016/09/075fd3727e968854ddbcc2f64956fdbc.jpg)
五分钟后，小灰重写了代码……
![%e4%bb%a3%e7%a0%813](http://jbcdn2.b0.upaiyun.com/2016/09/75db2d356384d26bd5f4abf650ff04bb.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a310](http://jbcdn2.b0.upaiyun.com/2016/09/0df8f281083a0d2a985903484ce649c0.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%8b%a6%e6%80%9d4](http://jbcdn2.b0.upaiyun.com/2016/09/e34d0248fdcfc1fd6282f1126a69b7aa.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a311](http://jbcdn2.b0.upaiyun.com/2016/09/47a6d48feb50cb889946be55809b0986.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e6%b2%89%e6%80%9d4](http://jbcdn2.b0.upaiyun.com/2016/09/73ce190b080805565c1870b436ea5739.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a312](http://jbcdn2.b0.upaiyun.com/2016/09/8ff52299f7f32c8d0a92b767a6cac8ce.jpg)
众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论。其中gcb(a,b)的意思是a,b的最大公约数函数：
当a和b均为偶数，gcb(a,b) = 2*gcb(a/2, b/2) = 2*gcb(a>>1, b>>1)
当a为偶数，b为奇数，gcb(a,b) = gcb(a/2, b) = gcb(a>>1, b)
当a为奇数，b为偶数，gcb(a,b) = gcb(a, b/2) = gcb(a, b>>1)
当a和b均为奇数，利用更相减损术运算一次，gcb(a,b) = gcb(b, a-b)， 此时a-b必然是偶数，又可以继续进行移位运算。
比如计算10和25的最大公约数的步骤如下：
- 整数10通过移位，可以转换成求5和25的最大公约数
- 利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数
- 整数20通过移位，可以转换成求5和10的最大公约数
- 整数10通过移位，可以转换成求5和5的最大公约数
- 利用更相减损法，因为两数相等，所以最大公约数是5
在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a313](http://jbcdn2.b0.upaiyun.com/2016/09/c3ea6eba3f87ef31bd7d3bc442ba4d01.jpg)
![%e4%bb%a3%e7%a0%814](http://jbcdn2.b0.upaiyun.com/2016/09/be5b12780888a444537dae9879693ea1.jpg)
最后总结一下上述所有解法的时间复杂度：
1.**暴力枚举法**：时间复杂度是O(min(a, b)))
2.**辗转相除法**：时间复杂度不太好计算，可以近似为O(log(min(a, b)))，但是取模运算性能较差。
3.**更相减损术**：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为O(max(a, b)))
4.**更相减损术与移位结合**：不但避免了取模运算，而且算法性能稳定，时间复杂度为O(log(max(a, b)))
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%9b%9e%e7%ad%947](http://jbcdn2.b0.upaiyun.com/2016/09/27c8ceb6a669de4106702eb1ba8db173.jpg)
![%e5%b0%8f%e4%bb%93%e9%bc%a0%e8%ae%b2%e8%a7%a314](http://jbcdn2.b0.upaiyun.com/2016/09/6e75331340d3941caa0b572d99b7ce80.jpg)
本文原本只写到辗转相除法就终告结束，后来网友们指出还有更优化的解法，看来自己还是才疏学浅，很感谢大家指出问题。另外，方法的参数默认必定是正整数，所以在代码中省去了合法性检查。
文中描述的更相减损术是简化了的方式。在九章算术原文中多了一步验证：如果两数都是偶数，计算差值之前会首先让两个数都折半，使得计算次数更少。这种方法做到了部分优化，但古人似乎没想到一奇一偶的情况也是可以优化的。
由于篇幅所限，本文省略了关于辗转相除法原和更相减损术的原理及证明。其实证明过程并不复杂，细心的同学们也可以自己尝试研究一下。谢谢大家的捧场！
本人微信号：**bjweimengshu**
欢迎朋友们一起交流讨论，加好友请注明**伯乐在线** ：）
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
![](http://jbcdn2.b0.upaiyun.com/2016/10/2df4a3ede6e684f78858dfde0e7b118f.jpeg)
