# PHP多进程编程（一） - 文章 - 伯乐在线
原文出处： [暮夏](http://www.cnblogs.com/niniwzw/archive/2010/01/18/1651082.html)
虽然PHP 中，多进程用的比较的少。但是毕竟可能是会用到了。我最近就遇到这样一个问题，用户提交几百个url以后，要读出这个url 中的标题。
当然，你不希望用户等待的太久，10s 钟应该给出个答案。但是，本身，你要获取一个url 的标题，少的要 0.1s ，多的要好几秒。
显然，采用单个线程的方式是不行的。
**我的第一个设计方案是这样的：**
1. 用我前面提供的代码提供一个简单的服务器：  http://www.cnblogs.com/niniwzw/archive/2009/09/27/1575002.html
这个服务器的作用是：提供一个url，然后，就读取标题。这里，可以每次读128个字节，看看有没有读到title，如果读到title了就停止读了。
这样可以省带宽。
2. 在客户端，同时打开1百个 socket ，访问这个服务器。如果提供的url数目超过100，那么就多次运行。
这个方案，基本上能够满足要求，读比较快的网页如：google.com 100次，也只要1s 左右。但是，通过测试，发现，有一定
的概率在打开链接的时候被阻塞。（有时候会阻塞个1s左右，然后继续往下open）可能打开了太多的链接了，会出很大的问题。
当然，这是一个很差的解决方案：建立tcp 链接本身的消耗非常的大。因为可靠有序传输的要求，要维持一个数据结构，而且，系统还要开辟一定的缓存给客户端和服务器端，
用户缓存数据。如果建立上百个链接，就可能占用很大的内存。作为一个系统的服务，应该尽量的简单，就是，我叫你做什么事情，你做好以后，结果给我就可以了。
一般来说，PHP要进行多进程编程，比较常见的是：
1. 要进行大量的网络耗时的操作
2. 要做大量的运算，并且，系统有多个cpu，为了让用户有更快的体验，把一个任务，分成几个小任务，最后合并。
所以，应该尽量不要在调用的地方有太多复杂的逻辑，把逻辑内置在服务中。
**我的第二个设计方案是这样的：**
同样用上面的服务器，只是，这个服务器功能变了，接收不超过100个的url，然后打开100个子线程，下载title。最后合并，返回给客户端。
具体怎么编写这个服务器，在下一个部分讲。
这个一测试，发现效率高了很多。而且也十分的稳定。下载一百下google 大概 0.7s。基本上不会超过1s，而原来的那个方案，经常超过5s（20%的可能性）
当然，如果这样的设计方案只是一个很简单的解决方案。如果有很多人使用你的服务的情况下，肯定不能这样做。
PHP做企业级别的开发，一个比较复杂的问题，就是内存怎么处理。还有就是往往采用数组 会引起内存急剧膨胀。一般，数组处理10万条数据已经是极限，
在小网站开发很少会用到一次读取如此大的数据量，要是遇到了，最好通过C 扩展进行解决，否则，一次会损耗 几百M 的内存，10个人用就拖死你。
