# SQL注入攻击高级 - 文章 - 伯乐在线
原文出处： [i春秋学院](http://www.cnblogs.com/ichunqiu/p/5793686.html)
**前言**
前面我们学习了如何寻找，确认，利用SQL注入漏洞的技术，本篇文章我将介绍一些更高级的技术，避开过滤，绕开防御。有攻必有防，当然还要来探讨一下SQL注入防御技巧。
**目录**
![](http://jbcdn2.b0.upaiyun.com/2016/08/d43da9938008069ea20d145285c4abab.gif)
**第五节 避开过滤方法总结**
- **5.1、大小写变种**
- **5.2、URL编码**
- **5.3、SQL注释**
- **5.4、空字节**
- **5.5、二阶SQL注入**
** 第六节 探讨SQL注入防御技巧**
- **6.1、输入验证**
- **6.2、编码输出**
![](http://jbcdn2.b0.upaiyun.com/2016/08/c1cad5a58b0cc3e4374e87c928df38d2.gif)
**正文**
- **第五节 避开过滤方法总结**
Web应用为了防御包括SQL注入在内的攻击，常常使用输入过滤器，这些过滤器可以在应用的代码中，也可以通过外部实现，比如Web应用防火墙和入侵防御系统。避开过滤的方法是灵活的，本节我总结了一些常用的技巧。在我们不知道过滤规则的时候可以尝试一下。
**5.1、大小写变种**
这种技巧适用于关键字阻塞过滤器不聪明的时候，我们可以变换关键字字符串中字符的大小写来避开过滤，因为使用不区分大小写的方式处理SQL关键字。
例如：（下面的代码就是一个简单的关键字阻塞过滤器）


MySQL
```
function waf($id1){
    if(strstr($id1,'union')){
        echo 'error:lllegal input';
        return;
    }
    return $id1;
}
```
这段代码的缺陷就在strstr()函数是对大小写敏感的，所以我们可以通过大小写变种来绕过。
=   ![](http://jbcdn2.b0.upaiyun.com/2016/08/d7dfe78da175ec7a8e57417778607c2f.gif)
**5.2、URL编码**
URL编码用途广泛，可以通过它绕过多种类型的输入过滤器。

MySQL
```
function waf($id1){
    if(strstr($id1,' ') || strstr($id1,'/**/')){
        echo 'error:lllegal input';
        return;
    }
    return $id1;
}
```
双URL编码有时候会起作用，如果Web应用多次解码，在最后一次解码之前应用其输入过滤器。
![](http://jbcdn2.b0.upaiyun.com/2016/08/4aa01615dc1d58bc6ba72ef354d0469a.gif)
因为双URL编码，第一次解码%2f%2a进入输入过滤器，所以成功绕过了。当然这个使用前提是后面有一个URL解码。
**5.3、SQL注释**
很多开发人员认为，将输入限制为单个就可以限制SQL注入攻击，所以他们往往就只是阻止各种空白符。


MySQL
```
function waf($id1){
    if(strstr($id1,' ')){
        echo 'error:lllegal input';
        return;
    }
    return $id1;
}
```
但是内联注释不使用空格就可以构造任意复杂的SQL语句。
![](http://jbcdn2.b0.upaiyun.com/2016/08/0bd13801f3b0b3d671caa628292aef8e.gif)
**5.4、空字节**
通常的输入过滤器都是在应用程序之外的代码实现的。比如[入侵检测系统](http://www.ichunqiu.com/course/298?bbs)（IDS），这些系统一般是由原生编程语言开发而成，比如C++，为什么空字节能起作用呢，就是因为在原生变成语言中，根据字符串起始位置到第一个出现空字节的位置来确定字符串长度。所以说空字节就有效的终止了字符串。
只需要在过滤器阻止的字符串前面提供一个采用URL编码的空字节即可，例如：


MySQL
```
%00' union select username,password from users where username='admin' --
```
**5.5、二阶SQL注入**
> 
实际上到目前为止，你在网上大部分搜索SQL注入文章 基本都可以归类到”一阶(first-order)”SQL注入中，因为这些例子涉及的事件均发生在单个HTTP请求和响应中，如下所示：
(1) 攻击者在HTTP请求中提交某种经过构思的输入。
(2) 应用处理输入，导致攻击者注入的SQL查询被执行。
(3) 如果可行的话，会在应用对请求的响应中向攻击者返回查询结果。
另一种不同的SQL注入攻击是”二阶(second-order)”SQL注入，这种攻击的事件时序通常如下所示：
(1) 攻击者在HTTP请求中提交某种经过构思的输入。
(2) 应用存储该输入(通常保存在数据库中)以便后面使用并响应请求。
(3) 攻击者提交第二个(不同的)请求。
(4) 为处理第二个请求，应用会检索已经存储的输入并处理它，从而导致攻击者注入的SQL查询被执行。
(5) 如果可行的话，会在应用对第二个请求的响应中向攻击者返回查询结果。
从字面上来看二阶SQL注入对于新手很难理解，所以我来介绍一个经典的例子帮助大家理解。这是一个个人信息应用程序，我们可以更新我们的用户名，也可以查看我们的个人信息。
第二步查看我们个人信息时的SQL语句：


MySQL
```
select * from users where username = '$name'
```
 查询的语句所用到的变量name就是从数据库提取到的我们的用户名，所以我们可以先利用更新我们的用户名功能插入语句进数据库。这样查看我们个人信息的时候就成功执行了我们的SQL注入攻击。
例如：我们在用户名插入
[SQL] 纯文本查看 复制代码
那么后面我们就执行了语句

```
select * from users where username = 'zusheng' or '1'='1'
```
- **第六节 探讨SQL注入防御技巧**
**6.1、输入验证**
输入验证是指要验证所有应用程序接收到的输入是否合法。有两中不同类型的输入验证方法：白名单和黑名单验证
- 白名单验证：比如id值，那么我们判断它是否为数字。
- 黑名单验证：使用正则表达式禁止使用某些字符和字符串
应该尽量使用白名单，对于无法使用白名单的，使用黑名单提供局部限制。
**6.2、编码输出**
我们除了要验证应用程序收到的输入以外，还要对数据进行编码，这样不仅可以防御SQL注入攻击，还能防止出现其他问题，比如XSS。
**结束语**
因为本人技术有限，所以对防御技巧了解并不是深入，希望有更好防御技巧的小伙伴可以分享一下心得，我会将收到的技巧加入本文，提供给更多的小伙伴进行参考，谢谢了。
