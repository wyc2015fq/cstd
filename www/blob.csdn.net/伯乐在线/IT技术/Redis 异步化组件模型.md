# Redis 异步化组件模型 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [Float_Lu](http://www.jobbole.com/members/5334670325) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
# Redis 线程体系
Redis可以说是基于单线程模型的，因为对于客户端的所有读写请求的处理，都由一个主线程串行地处理，因此多个客户端同时对一个键进行写操作不会有并发问题，但是除了客户端读写请求之外还有一些比较耗时的操作，如持久化RDB文件，持久化AOF文件等等，这些操作不能放在主线程里面处理，因此Redis会在适当的时候fork子进程来异步的处理这种任务。除了这些，Redis还有一组异步任务处理线程，用于处理不需要主线程同步处理的工作，总体上Redis的线程体系结构大致如下图：![225154_hs7v_1759553](http://jbcdn2.b0.upaiyun.com/2016/06/d69b25d53e4c0b3333c64aca0e3ec690.jpg)
**Redis线程体系结构**
上图中间蓝色的部分代表主线程，最左边虚线代表通过fork得到的子进程，用来处理RDB持久化以及AOF持久化等任务，最右边橙色部分代表一组异步任务处理线程，下面会详细介绍这组异步任务处理线程，即Redis异步化组件——BIO组件。
# Redis 异步化组件模型
在Redis中，异步任务处理线程组被封装在BIO组件中，源文件为bio.h和bio.c。BIO组件目前包括三个线程，分别处理三种类型的任务：
- 文件句柄关闭任务
- AOF持久化任务
- 空间懒释放
BIO内部的结构示意图如下图所示：![230648_JjUG_1759553](http://jbcdn2.b0.upaiyun.com/2016/06/d081c5b4712379c36c60fdfdaacf4238.jpg)
**BIO异步任务处理组件结构**
## 任务类型
上面提到，Redis BIO组件提供的异步任务处理线程组目前只包含三个线程分别处理三类任务，这里稍微详细介绍着三类任务：
### 文件句柄关闭任务
文件句柄的释放（close）对于操作系统来说是一个比较重的操作，在Redis中，当需要重新创建新的文件句柄，废弃的文件句柄失效的时候，这个废弃的文件句柄将由异步任务处理线程来关闭。
### AOF 持久化任务
Redis对于AOF文件的持久化有三种策略：
- 关闭AOF功能
- aof_fsync_everysec策略，即每秒一次，实际上并不是一定一秒钟一次
- aof_fsync_always策略，即每次IO事件处理完毕，都将AOF持久化
这三种策略分别对应不同的业务场景和用户需求，默认的策略为aof_fsync_everysec，这个时候对于aof缓冲区内容持久化工作会交给异步任务处理线程来处理。
### 空间懒释放
内存的释放也是比较重的操作，这部分工作可以交给异步任务处理线程来处理，Redis中通过一部任务释放的空间主要包括三种：
- 对象空间的释放，当当前内存够用的时候，主线程不会同步释放废弃对象的内存，交给异步任务处理线程来释放，当然需要配合lazyfree_lazy_server_del参数使用。
- DB空间的异步释放，当需要删除DB的时候，Redis会申请一个新的哈希表作为新的DB，将DB内存的释放的工作交给异步任务处理线程来处理。
- slots-leys空间释放，在Redis Cluster模式下，slots-keys是由Redis实现的跳跃表数据结构支撑的，当Redis Cluster需要刷新slots-keys的时候，首先创建一个新的跳跃表结构作为新的slots-keys，然后将老的slots-keys结构释放的工作交给异步任务处理线程来处理。
## 异步任务处理模型
每个线程都有一个虚拟阻塞队列，之所以叫虚拟阻塞队列主要有两个原因，一个原因是这个队列并不是一个真实的队列结构，队列的底层数据结构由Redis实现的跳跃表支持，另一个原因是这个队列的阻塞唤醒机制主要由Redis基于pthread库提供的线程同步原语实现的，如pthread_cond_wait、pthread_cond_notify等。BIO外部通过BIO组件提供的接口将任务提交到阻塞队列，内部线程对任务进行处理，主线程、队列以及异步任务处理线程协作流程图如下如所示：![232132_zMGA_1759553](http://jbcdn2.b0.upaiyun.com/2016/06/81ce225815764881f8193d3e7aa56e42.jpg)
**异步任务处理流程**
## 阻塞等待处理模型
目前，Redis对于异步任务的提交都是异步的，主线程将任务提交到任务队列同时唤醒阻塞的异步任务处理线程来队列那任务进行处理，这个时候主线程不需要知道异步任务处理的情况，Redis BIO组件也提供了阻塞等待的接口，当外部线程将任务提交到任务队列之后可以调用该接口进行同步等待，但是值得注意的是，这里等待的只是正在执行的任务处理完毕的事件，而不一定是任务提交线程刚刚提交的任务处理完毕事件。目前Redis BIO提供了该接口，但是该接口并没有被用到，如果加上这个逻辑，则上图补充完毕如下：![233014_9A8v_1759553](http://jbcdn2.b0.upaiyun.com/2016/06/7b9b486c339c0b230f4d0e036613602f.jpg)
**加上同步等待的异步任务处理流程**
# 总结
Redis的单线程模型串行的处理客户端请求以及一些其他的事情，为了提高单线程的应用效率，Redis将一些可以异步处理的任务交给BIO组件提供的异步任务处理线程组来处理，这样的好处是降低了主线程的压力，分担了主线程的部分工作量，能够让主线程更快的响应客户端的请求，在一定程度上提高了Redis的吞吐量。这种异步化模型在其他应用场景也是非常有效的，我认为其核心思想是：**非核心逻辑异步化，提高主流程的处理效率。**
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
任选一种支付方式
![](http://jbcdn2.b0.upaiyun.com/2016/05/7cb05a1a5b9ef06cc9d40cc79a096f293.png)![](http://jbcdn2.b0.upaiyun.com/2016/05/12e72c4df391cc981614cc68aedd44085.jpg)
