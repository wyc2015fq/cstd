# 15位身份证补全为18位身份证算法 - 文章 - 伯乐在线
原文出处： [我心自在](http://www.cnblogs.com/10158wsj/p/7050736.html)
最近在参与一个银行项目-某银行安防系统-反洗钱需求的开发，银行项目的离不开身份证号码，身份证号码作为我国公民的唯一标识，有这非同寻常的意义，由于业务的要求15位的身份证号码无法命中，所以需要补全为18位，一开始自己想着加个年份的前两位，后面再加个X不就行了嘛，后来代码写不下去了，上网查了资料，才知道自己想的是多么天真，还是比较复杂的，折腾了一下午终于有了眉目。
## 一、15位身份证和18位身份证号码结构介绍
要进行身份证号码的验证，首先需要了解我国身份证号码的编码规则。我国身份证号码多由若干位数字或者数字与字母混合组成。早期身份证由15位数字构成，这主要是在1980年以前发放的身份证，后来考虑到千年虫问题，因为15位的身份证号码只能为1900年1月1日到1999年12月31日出生的人编号，所以又增加了18位身份证号码编号规则。
1     2     3     4     5     6     7     8     9     10   11   12   13   14   15
A     A     A     A     A     A     Y     Y     M    M    D     D     N    N    S
前六位AAAAAA是身份证编码对象的所在地（出生地）的编码，该号码可由国家统计局公布的相关标准中得到。YY表示出生年的后两位，MM和DD表示出生月和日，不足两位的高位补0，NNS为顺序号，无法确定。S为性别识别码，男性为奇数，女性为偶数。了解了这些，再来写代码就变得容易多了。
## 二、算法实现
了解了身份证号码的规则后，我们就可以推断出，身份证的15位转化位需要两步。首先把15位身份证号补全为17位，然后再补全最后一位。但是最后一位是数字还是字母X？这里又出现了问题。我们知道，身份证的最后一位为校验位，那么最后一位是怎么得到的呢？原来，最后一位是由数字1-9组成，超过9的比如11就用字母X表示，否则号码就变成了19位。了解了这些，经过整理得出身份证补全算法实现思想如下：
**step1**、将15位身份证号码加入出生年变为17位
**step2**、将step1得到的身份证17位数分别乘以不同的系数。从第1位到第17位的系数分别为：7-9-10-5-8-4-2-1-6-3-7-9-10-5-8-4-2.
**step3**、将这17位数字和系数相乘的结果相加
**step4**、将step3的结果除以11，得出余数
由于数字的特殊性，这些余数只可能是0-10这11个数字，身份证最后一位的对应数字为1-0-X-9-8-7-6-5-4-3-2.。例上面的余数结果为3那么对应身份证号码的最后一位就是9，如果是10，身份证最后一位便是2。
代码如下：


```
public static void main(String[] args) {
        System.out.println(transIDCard15to18("370986890623212"));
        System.out.println(transIDCard15to18("370725881105149"));
    }
    /* 18位标准身份证号
     * 方法用途：15位身份证转化为18位标准证件号
     */
    public static String transIDCard15to18(String IdCardNO){
        String cardNo=null;
        if(null!=IdCardNO&&IdCardNO.trim().length()==15){
            IdCardNO=IdCardNO.trim();
            StringBuffer sb=new StringBuffer(IdCardNO);
            sb.insert(6, "19");
            sb.append(transCardLastNo(sb.toString()));
            cardNo=sb.toString();
        }
        return cardNo;
    }
    /* 方法用途：15位补全‘19’位后的身份证号码
     */
    private static String transCardLastNo(String newCardId){
        char[] ch=newCardId.toCharArray();
        int m=0;
        int [] co={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
        char [] verCode=new char[]{'1','0','X','9','8','7','6','5','4','3','2'};
        for (int i = 0; i < newCardId.length(); i++) {
            m+=(ch[i]-'0')*co[i];
        }
        int residue=m%11;
        return String.valueOf(verCode[residue]);
         
    }
```
测试结果如下：
![1153367-20170619213856382-410871354](http://jbcdn2.b0.upaiyun.com/2017/06/4de63d1dfe6ae7d0e16eb62169a51728.png)
## 三、总结
身份证号码补全虽然简单，但是前提需要了解我国公民的身份证构成原理才能正确验证，今天将这个学习过程分享给大家，希望对大家有所帮助，学习是个永无止境的过程，只有不断学习才能有进步！
