# 漫画算法：无序数组排序后的最大相邻差值 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [玻璃猫](http://www.jobbole.com/members/bjweimengshu) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
![](http://jbcdn2.b0.upaiyun.com/2016/12/1f9677905d8072215ad9a9b67f8c6658.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/a59420a1fe26e7dc87e26e2cb4a0316a.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/7deda15257094b85d34796b2338abd99.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ec025f024712b179478be4e4464ef47c.jpeg)
小灰一边回忆一边讲述起当时面试的情景……
![](http://jbcdn2.b0.upaiyun.com/2016/12/42fff1f178af6d218ce19efbe9016b30.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/7623642da420870026f31375ec4291a0.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/6c35c7d443dd113343d4e4c7528fcd89.jpeg)
**题目**：有一个无序整型数组，如何求出这个数组排序后的任意两个相邻元素的最大差值？要求时间和空间复杂度尽可能低。（例如：无序数组 2,3,1,4,6，排序后是1,2,3,4,6，最大差值是6-4=2）
![](http://jbcdn2.b0.upaiyun.com/2016/12/2f5aeb4283abc3ee0e8def97b568dda9.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/699068993ce21d89232f7c64f1d6cf1a.jpeg)
**解法一：**
用一种较快的稳定排序算法（比如归并算法，时间复杂度N*logN）给原数组排序，然后遍历排好序的数组，每两个相邻元素求差，最终得到最大差值。
该解法的时间复杂度是O（N*logN），在不改变原数组的情况下，空间复杂度是O（N）。
![](http://jbcdn2.b0.upaiyun.com/2016/12/5cafda0cb5e7e89144cdad407f5c8fad.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/af2eb7a3b33bb5dc6acc75c3f4cd15be.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/e3541adcb6d14a30e03536303e316d01.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/067af94afb274b5d794df7b30b054817.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/e43ef488924fc24fe159ae625ca3cb15.jpeg)
**解法二：**
1.利用计数排序的思想，先求出原数组的最大值Max与最小值Min的区间长度k（k=Max-Min+1）。
2.创建一个长度为k的新数组Array。
3.遍历原数组，把原数组每一个元素插入到新数组Array对应的位置，比如元素的值为n，则插入到Array[n-min]当中。此时Array的部分位置为空，部分位置填充了数值。
4.遍历新数组Array，统计出Array中最大连续出现空值的次数+1，即为相邻元素最大差值。
例如给定无序数组 { 2, 6, 3, 4, 5, 10, 9 }，处理过程如下图：
![](http://jbcdn2.b0.upaiyun.com/2016/12/bfc04ca2f5ef3ba96f7f0d0ee5878e12.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/0798bfb792bfe47f2d601d0ccb819f2c.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/5f03ea2e78240cae369204aa4a3b320e.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ffdcce8ded2cb01fe2f9454577cce068.jpeg)
该解法的时间复杂度为O（n+k），空间复杂度同样是O（n+k）。
![](http://jbcdn2.b0.upaiyun.com/2016/12/702a0ed6e25f346e5d80936dc770e498.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ae2240060472026c91452d19d51f2e73.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ecbd1afc055638154b9b22d5702e4c1a.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/3c22a1712366906a035e6608f02f6013.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ef7da0166b0607bd58c7235d7c4e6632.jpeg)
**解法三：**
1.利用桶排序的思想，先求出原数组从最小值Min到最大值Max的单位区间长度d，d=(Max-Min)/n。算出d的作用是为了后续确定各个桶的区间范围划分。
2.创建一个长度是N+1的数组Array，数组的每一个元素都是一个List，代表一个桶。
3.遍历原数组，把原数组每一个元素插入到新数组Array对应的桶当中，进入各个桶的条件是根据不同的数值区间（数值区间如何划分，看后面的图就明白了）。由于桶的总数量是N+1，所以至少有一个桶是空的。
4.遍历新数组Array，计算每一个空桶**右端非空桶中的最小值**，与空桶**左端非空桶的最大值**的差，数值最大的差即为原数组排序后的相邻最大差值。
例如给定无序数组 { 0, 6, 3, 16, 7, 10, 9, 11, 20, 18 }，处理过程如下图：
![](http://jbcdn2.b0.upaiyun.com/2016/12/89b91bce7c338468e0cdd03d9321d04f.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/0eda8f08fe53ff047b4cacdc56483541.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/7b6145fd67ec2daac97deab606429d22.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/ca2d86260a0e59dd202a7d684370541c.jpeg)
该解法的时间复杂度为O（n），空间复杂度同样是O（n）。
![](http://jbcdn2.b0.upaiyun.com/2016/12/4fba2d3776e6ae3ee01bb056fb5fbbcc.jpeg)
十分钟后……
![](http://jbcdn2.b0.upaiyun.com/2016/12/0731d8d11c00a5aa70dfac6a27d31907.jpeg)
以上就是小灰面试的情况……
![](http://jbcdn2.b0.upaiyun.com/2016/12/d8db009ca730089c8622b3b1bb6f0027.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/9cb835483cb5b4621b62f132f2b4a9e1.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2016/12/0b2a4f158d0d07f5e75f7294ddbaba91.jpeg)
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
![](http://jbcdn2.b0.upaiyun.com/2016/10/2df4a3ede6e684f78858dfde0e7b118f.jpeg)
