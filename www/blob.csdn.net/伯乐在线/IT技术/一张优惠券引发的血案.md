# 一张优惠券引发的血案 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [玻璃猫](http://www.jobbole.com/members/bjweimengshu) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
![](http://jbcdn2.b0.upaiyun.com/2017/05/d24198d89a821452a421af6ae64b13c4.png)
![](http://jbcdn2.b0.upaiyun.com/2017/05/7def9437ba1d27381bc1d8d522825c3b.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/66bf1f49392cc2729a0d5cafaaf40cd8.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/5f0fa047a0e2b67a708e5e89909e012d.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/fc99049bd070406e907ca7a7b03fc2f8.jpeg)
一个月前——
![](http://jbcdn2.b0.upaiyun.com/2017/05/09bc3864a82cd1c8f16f1c7edae1ddba.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/0ae3146a3cb106598ef79fad3f2916dc.jpeg)
整个优惠券中心分为前端和后端，小灰所负责的是后端RPC接口的开发。接口中包含“查券”和“领券”两个方法，项目大体结构如下图：
![](http://jbcdn2.b0.upaiyun.com/2017/05/318ace3b189049e62f11dfba8913af6d.jpeg)
两周后——
![](http://jbcdn2.b0.upaiyun.com/2017/05/42ad521e5db9f2f628587bcbc4ab82f8.jpeg)
小灰：看，这是优惠券查询功能的效果！
![](http://jbcdn2.b0.upaiyun.com/2017/05/e1b844b2f74eef1823d3f723c5021e71.jpeg)
小灰：看，这是优惠券领取功能的效果！
![](http://jbcdn2.b0.upaiyun.com/2017/05/14e01e8b4326eca2c0177263eb083b61.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/748679d70e308d36cf5e5e442eebd30d.jpeg)
三天后——
![](http://jbcdn2.b0.upaiyun.com/2017/05/adceb1aa90f1b7893c88bde770ec0c31.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/b477138a9ffb55307507de5bd8b0ca6e.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/6bbd3f7bdedfeb0fa43a79e8355351dc.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/aad1cef68792f2615646d6ecf8e6fc1f.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/edfb4c04847b5a4005dff11f628e45f1.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/154b75b87bff4cc056d217702f37d0f2.jpeg)
小灰原本的优惠券查询接口是这样实现的：
![](http://jbcdn2.b0.upaiyun.com/2017/05/fc64391201fe85da923378e79a60335e.jpeg)
优惠券列表在Redis中以List的形式存储，查询时的逻辑很简单：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.把查询数据库的结果循环放入缓存
然而，当某个时间点缓存不存在，请求量又很大的时候，会出现**缓存并发**的问题。也就是多个线程会重复去查询DB，又重复去更新缓存。（注意，这并不是**缓存击穿**，很多人在这两个概念上混淆。）
这其中重复查询DB是次要问题，而重复更新缓存则是主要问题。假如有两个线程同时进入上述的第三个阶段，各自进行rpush操作，那么最终会在优惠券列表的缓存中插入两组同样的数据。
怎么解决呢？用Java的锁机制？显然不行，因为线上环境通常都是多个服务器组成的集群。于是小灰想到了利用**分布式锁**。
![](http://jbcdn2.b0.upaiyun.com/2017/05/095014b99c5dd133849989833bb76ef5.jpeg)
所谓分布式锁有很多种，可以利用ZooKeeper、MemCache、Redis来实现。其中Redis的方式比较简单，无非是利用一个服务器之间共享的Key，以及Setnx指令。
当第一个线程执行Setnx，会存储对应的键值，相当于成功获得锁。当后续再有线程对同于的Key执行Setnx指令，则会返回空，相当于抢锁失败。同时，为了防止一个线程因意外情况而长久把持着锁，程序对Key设置了1秒的过期时间。
归纳一下修改后的逻辑：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，把查询数据库的结果循环放入缓存
5.释放分布式锁
![](http://jbcdn2.b0.upaiyun.com/2017/05/1beea94a72fb2d15e1c08cc483ef3533.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/7de5ac624d06a082fba5cae7a3588aa5.jpeg)
三天后——
![](http://jbcdn2.b0.upaiyun.com/2017/05/79ba27f4cd5680b75005a725a1dcc537.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/0044500e143abcb925d4533225e64aad.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/183fd9b545ddc47c5a63b5f9276e280d.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/1073a937f6afe55bd10f8fd51637707b.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/72c0b99525b98fdd4667217b04fa3b1c.jpeg)
诡异的bug又重现了，因为小灰上次的改动仍然存在一个致命的漏洞。在这里我们假定缓存不存在，刚好有两个线程A和B一后一先进入到代码块。
第一阶段，线程A刚开始查询优惠券缓存，线程B正尝试获取分布式锁：
![](http://jbcdn2.b0.upaiyun.com/2017/05/4d7d298409701592f1b7a53adc6d8786.jpeg)
第二阶段，由于缓存不存在，线程A开始查询数据库，线程B成功获得锁，开始更新缓存：
![](http://jbcdn2.b0.upaiyun.com/2017/05/3adf9ed881fad675b2e79d8c49d93be3.jpeg)
第三阶段，线程A尝试获得分布式锁，而线程B已经释放分布式锁：
![](http://jbcdn2.b0.upaiyun.com/2017/05/ab7d96c7be4d6ee33be1876ba8831e2e.jpeg)
第四阶段，线程A获得了锁，**又一次**更新缓存，而线程B已经成功返回：
![](http://jbcdn2.b0.upaiyun.com/2017/05/2d17073f0ce0d166a6a02e3cda641604.jpeg)
就这样，缓存被重复更新了两次，所以再次出现数据重复的bug。
这种局面如何破解呢？其实不难，只需在线程成功得到锁以后，再次判断优惠券缓存的存在：
![](http://jbcdn2.b0.upaiyun.com/2017/05/71acc87a2e881836880ca644179f2a17.jpeg)
归纳一下修改后的逻辑：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，再次判断缓存的存在
5.如果缓存仍旧不存在，把查询数据库的结果循环放入缓存
6.释放分布式锁
这种二次判断存在性的机制有一个专门的名字，叫做**双重检测**。该方法在线程安全的单例模式中也常常被用到。
![](http://jbcdn2.b0.upaiyun.com/2017/05/f9ecbb65155916c904f27a8be9775fcf.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/dec0265a6c103b90338e8a18c7b5a6af.jpeg)
小灰的回忆告一段落——
![](http://jbcdn2.b0.upaiyun.com/2017/05/6e05443ad29333f6d6971f625ccb228d.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/2fdf07d2f2c5816f8eafcaca4c7a5302.jpeg)
![](http://jbcdn2.b0.upaiyun.com/2017/05/2097948c9c34eb94889851fa789aa37b.jpeg)
**几点补充：**
1.文中所使用的分布式锁，其实并不是“正宗”的分布式锁，当线程争夺锁失败的时候，会直接返回查询DB的结果，而不会依靠**自旋**机制来等锁。
2.为什么优惠券列表的信息要使用List类型来存入缓存，而不是把整个列表存为一个很长的Json字符串？这是由于业务需要，使用List在某些情况下更方便对单个优惠券信息进行修改（LSET指令）。
3.为什么优惠券列表的信息不使用Redis的Set或者Hash数据类型来存储，实现自动去重呢？对于Set类型，去重前需要对比整个字符串是否完全相同，而每一张优惠券是一个较长的Json字符串，对比的效率会比较低。使用Hash倒是可以实现高效的去重，但并未在根本上解决重复更新的问题。
> 
**打赏支持我写出更多好文章，谢谢！**
[打赏作者](#rewardbox)
#### 打赏支持我写出更多好文章，谢谢！
![](http://jbcdn2.b0.upaiyun.com/2016/10/2df4a3ede6e684f78858dfde0e7b118f.jpeg)
