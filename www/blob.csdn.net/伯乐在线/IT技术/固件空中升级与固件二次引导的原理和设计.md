# 固件空中升级与固件二次引导的原理和设计 - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [吴跃前](http://www.jobbole.com/members/yueqian_scut) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
蓝牙固件空中升级（OTA）涉及到蓝牙无线通信、固件外存分布、固件内存分布（定制链接脚本）、固件二次引导等技术，需要开发人员深入理解蓝牙单芯片的存储架构、启动引导流程、外存设备驱动和产品电路设计等领域知识。完整和完美地设计和实现OTA，是一名嵌入式物联网软件工程师最好的技术体现。
本文以Dialog公司研发的号称全球最低功耗蓝牙单芯片DA14580平台为基础进行分析和设计，但设计思想可以推广到其他蓝牙单芯片平台，甚至也适用于wifi固件空中升级。
### 一、OTA意义
固件空中升级是如此重要，在于：
1.修复产品缺陷。
2.丰富产品功能，增加用户粘性。
3.迭代的产品升级，也有助于快速切入市场，降低整体开发成本。
### 二、场景和问题分析
![](http://img.blog.csdn.net/20160310182652544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
我们以常见的通过手机蓝牙来升级蓝牙设备固件这种方式来分析OTA会遇到什么问题：
1.固件的形式。我们一般在调试时使用HEX格式来烧写，HEX带有地址信息，因此可以烧写到任意地方，也即是固件的代码和数据的分布是可以不连续的。但是在OTA里面，如果蓝牙的OTA profile在接收到数据后还要进行hex到bin的转换，那效率无疑是相当低的。因此一般的OTA都要求固件为bin格式，也意味着固件的代码和数据要连续存放。这里说的数据是指const data和.data的初始化值，它们和.bss的运行时地址并不要求跟代码的地址是连续的，程序运行起来，可以将初始化数据搬到对应的运行时地址所对应的地方。Hex是标准格式，因此也有标准的Hex2bin工具来支持完成转换。
2.固件的头。除了代码和数据，在无线传输中，如何让对方认为这是一份完整无错误的固件？这就需要在代码和数据之外定义一个固件头，它至少要包括校验（一般是CRC）字段和代码数据的长度字段。这样，对方可以对代码数据进行校验，并将结果和校验字段比较，以确定是否完整。另外，为了让引导程序快速判断是否是固件，宜在固件头部进入固件标识字段，如0x7050是DA14580的第一次引导辨别的固件标识，而0x7051是二次引导辨别的固件标识。
3.OTA后蓝牙设备是一份固件还是两份固件？我们可能会想，反正在OTA过程中，原来的代码数据已经运行在内存中，新固件可以直接烧到原固件所在的地方，因此设备永远都是只存一份。如果是这样，那我就没必要在这里巴拉巴拉那么多了。这种方法确实是可行的，但是万一在传输的过程中出现意外（掉电，干扰等等，这概率可不是万一了），那就相当于设备里面没有固件，直接变成垃圾。所以支持OTA的设备必须要在外存中开辟不同的区域来存储新、旧两份固件。
4.两份固件就够了吗？系统ROM中的一次引导程序是必读某个外存地址的，两份固件在不同的地方，一次引导怎么知道要Run哪份固件呢？ROM的一次引导之前可没有考虑OTA这档子事的。所以我们自然应该要加入二次引导程序，让二次引导程序放在ROM必读的起始地址上，由二次引导程序（开发人员可以定制开发的）来判断哪份固件是新的且是完整无误的，再选择性引导新固件。
5.二次引导加上两份固件够了吗？其实是够的，但是不够灵活。假如是这样，那么两份固件一定要放置在二次引导程序指定的两个地方，这显然是很笨的方法，假如两份代码间隔设置大了会浪费，设置小了，万一固件长度超了不就歇菜了。我们可以考虑在二次引导程序指定的一个地方烧写进一个简单的配置文件，由该配置文件来指定两份固件的起始点。
### 三、设备的外存固件分布
根据以上分析，我们可以得出蓝牙设备的外存固件分布图，假设flash：
![](http://img.blog.csdn.net/20160310182705402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
### 四、设备芯片的内存框架和运行时内存分布
1.一般无线单芯片SOC
一般无线（蓝牙和wifi）单芯片SOC都内置ROM和RAM，并支持多种外存引导，如nor flash、eerom，有些还可能有OTP等存储类型，也可能支持SPI、I2C等总线接口方式。
二次引导程序被ROM中的一次引导程序从flash中引导到RAM中运行，而二次引导程序运行过程中也要将最新固件引导到RAM。因此，二次引导程序和固件所运行的RAM中是不可以重复的，必须分布独立的内存空间。
二次引导程序在引导出固件后，它的使命就完成了，因此它所占有的内存空间应该被定义为固件的数据运行空间（如.bss段），否则就浪费了。
综上所述，一般的内存框架和运行时分布的图示如下：
![](http://img.blog.csdn.net/20160310182718107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
2.DA14580的内存框架和运行时内存分布
DA14580的内存框架应该说在低端电子产品SOC的设计领域是非常经典的，它不仅在设计时因考虑OTA而将内存分块为两个区域（当然，其中也有深度睡眠时保存数据的原因），也为了低成本设计了OTP。产品在发布可以不要任何外存，直接将固件烧进OTP即可，当然没有外存是不可以OTA的。
如果支持OTA，那一般的方式是将二次引导程序烧写到OTP。因为DA14580的一次引导程序支持多种方式引导，其尝试引导的顺序为OTP、SPI接口、I2C接口。所以放到OTP有利于加快启动时间。
运行时图示如下：
![](http://img.blog.csdn.net/20160310182735076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
### 五、引导过程
有了以上分析，相信对引导过程非常清晰了。
![](http://img.blog.csdn.net/20160310182749670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
### 六、蓝牙OTA profile设计和实现
待下一篇文章再做详细讲解。
