# 服务的扩展性 - 文章 - 伯乐在线
原文出处： [loveis715](http://www.cnblogs.com/loveis715/p/5097475.html)
在编写一个应用时，我们常常考虑的是该应用应该如何实现特定的业务逻辑。但是在逐渐发展出越来越多的用户后，这些应用常常会暴露出一系列问题，如不容易增大容量，容错性差等等。这常常会导致这些应用在市场的拓展过程中无法快速地响应用户的需求，并最终失去商业上的先机。
通常情况下，我们将应用所具有的用来避免这一系列问题的特征称为非功能性需求。相信您已经能够从字面意义上理解这个名词了：功能性需求用来提供对业务逻辑的支持，而非功能性需求则是一系列和业务逻辑无关，却可能影响到产品后续发展的一系列需求。这些需求常常包括：高可用性（High Avalibility），扩展性（Scalability），维护性（Maintainability），可测试性（Testability）等等。
而在这些非功能性需求中，扩展性可能是最有趣的一种了。因此在本文中，我们将对如何编写一个具有高可扩展性的应用进行讲解。
### 什么是扩展性
假设我们编写了一个Web应用，并将其置于共有云上以向用户提供服务。该应用的创意非常新颖，并在短时间内就吸引了大量的用户。但是由于我们在编写该应用时并没有期望它来处理这么多用户的请求，因此它的运行速度越来越慢，甚至可能出现服务没有响应的情况。频繁发生这种事情的结果就是，用户将无法忍受该应用经常性地宕机，并将寻找其它类似应用来获得类似的服务。
该应用所缺少的能够根据负载来对处理能力进行适当扩展的能力便是应用的扩展性，而其衡量的标准则是处理能力扩展的简单程度。如果您的应用在添加了更多内存后就能运行得更好，或者通过添加一个额外的服务实例就能解决服务实例过载的问题，那么我们就可以说该应用的扩展性非常好。如果为了处理更多的负载而不得不重写整个应用，那么应用的开发者就需要在多多注意应用的扩展性了。
较好的扩展性不仅可以省却您重写应用的麻烦，更重要的是，它会帮助您在市场的争夺中获得先机。试想一下，如果您的应用已经出现了处理能力不够的苗头，却没有适当的解决方案来提高整个系统的处理能力，那么您能做的事情只能是重新编写一个具有更高处理能力的具有同一个功能的应用。在该段时间内，您的应用的处理能力显得越来越捉襟见肘。而体现在客户层面上的，则是您的应用的响应速度越来越慢，甚至有时都无法正常工作。在新应用上线之前，您的应用将逐渐地流失客户。而这些流失的客户则很有可能变成类似软件的忠实客户，从而使得您的产品失去了市场竞争的先机。反过来，如果您的应用具有非常良好的扩展性，而您的竞争对手并没有跟上用户的增长速度，那么的应用就有了完全超越甚至压制竞争对手的可能。
当然，一个成功的应用不应该仅仅拥有高扩展性，而是应该在一系列非功能性需求上都做得很好。例如您的应用不应该有太多的Bug，也不应该有特别严重的Bug，以避免由于这些Bug导致您的用户无法正常使用应用。同时您的应用需要拥有较好的用户体验，这样才能让这些用户非常容易地熟悉您的应用，并产生用户粘性。
当然，这些非功能性需求并不仅仅局限在用户的角度。例如从开发团队的角度来讲，一个软件的可测试性常常决定了测试组的工作效率。如果一个应用需要在几十台机器上逐一安装部署，那么每次测试人员对新版本的验证都需要几个小时甚至成天的时间才能准备完毕。测试组也就很自然地成为了该软件开发组中效率最为低下的一部分。为此我们就需要招入大量的测试人员，大大地增加了应用的整体开销。
总的来说，一个应用所具有的非功能性需求非常多，如完整性（Completeness），正确性（Correctness），可用性（Availability），可靠性（Reliability），安全（Security），扩展性（Scalability），性能（Performance）等等。而这些需求都会对如何分析，设计以及编码提出一定的要求。不同的非功能性需求所提出的要求常常会发生冲突。而到底哪个非功能性需求更为重要则需要根据您所编写的应用类型来决定。例如在编写一个大规模Web应用的时候，扩展性，安全以及可用性较为重要，而对于一个实时应用来说，性能以及可靠性则占据上风。在这篇文章中，我们的讨论将主要集中在扩展性上。因此其所提出的一系列建议可能会对其它的非功能性需求产生较大的影响。而到底如何取舍则需要读者根据应用的实际情况自行决定。
### 应用的扩展方法
好的，让我们重新回到扩展性这个话题上来。导致一个软件需要扩展的最根本原因实际上还是其所需要面对的吞吐量。在用户的一个请求到达时，服务实例需要对它进行处理并将其转化为对数据的操作。在这个过程中，服务实例以及数据库都需要消耗一定的资源。如果用户的请求过多从而导致应用中的某个组成所无法应对，那么我们就需要想办法提高该组成的数据处理能力。
提高数据处理能力的方法主要分为两类，那就是纵向扩展及横向扩展。而这两种方法所对应的操作就是Scale Up以及Scale Out。
纵向扩展表示在需要处理更多负载时通过提高单个系统处理能力的方法来解决问题。最简单的情况就是为该系统提供更为强大的硬件。例如如果数据库所在的服务器实例只有2G内存，进而导致了数据库不能高效地运行，那么我们就可以通过将该服务器的内存扩展至8G来解决这个问题：
![](http://jbcdn2.b0.upaiyun.com/2016/01/64df87e182090bc4a2e2b572e65681fd.png)
上图所展示的就是通过添加内存进行纵向扩展，以解决数据库所在服务实例IO过高的情况：当运行数据库服务的服务器所包含的内存不能加载数据库中所存储的最为常见的数据时，其会不断地从硬盘中读取持久化到磁盘中的内存页面，从而导致数据库的性能大幅下降。而在将服务器的内存扩展到8G的情况下，那些常用数据就能够长时间地驻留在内存中，从而使得数据库所在服务实例的磁盘IO迅速回复正常。
除了通过硬件方法来提高单个服务实例的性能之外，我们还可以通过优化软件的执行效率来完成应用的纵向扩展。最简单的示例就是，如果原有的服务实现只能使用单线程来处理数据，而不能同时利用服务器实例中所包含的多个CPU核心，那么我们可以通过将算法更改为多线程来充分利用CPU的多核计算能力，成倍地提高服务的执行效率。
但是纵向扩展并非总是最正确的选择。影响我们选择的最常见因素就是硬件的成本。我们知道，硬件的价格通常与该硬件所处的定位有关。如果一个硬件是当前市场上的主流配置，那么由于它已经大量出货，因此平摊的研发成本在每件硬件中已经变得非常小。反过来，如果一个硬件是刚刚投入市场的高端产品，那么每件硬件所包含的研发成本将会非常多。因此纵向扩展的投入性能比曲线常常如下所示：
![](http://jbcdn2.b0.upaiyun.com/2016/01/518ff0aa050c57edb17fc25d137c70bb.png)
也就是说，在单个实例优化到一定程度以后，再花费大量的时间和金钱来对单个实例的性能进行提高已经没有太多的意义了。在这个时候，我们就需要考虑横向扩展，也就是使用多个服务实例来一起提供服务。
就以一个在线的图像处理服务为例。由于图像处理是一个非常消耗资源的计算过程，因此单个服务器常常无法满足大量用户所发送的请求：
![](http://jbcdn2.b0.upaiyun.com/2016/01/147ecb1bed809fb229f1fc4edd55b380.png)
就像上图中所展示的那样，虽然我们的服务器已经安装了4个CPU，但是在单个服务器实例提供服务的情况下，CPU使用率还是一直处于警戒线之上。如果我们再在应用中添加一个相同的服务器来共同处理用户的请求，那么每台服务器的负载将会降到原有负载的一半左右，从而使得CPU使用率保持在警戒线之下。
在这种情况下，该服务所提供的一系列其它功能也随之得到了扩充。例如对处理结果进行保存的功能的性能也将变成原来的两倍。只是由于我们暂时并不需要这种扩充，因此该部分性能的增强实际上是毫无用处的，甚至造成了服务资源的浪费：
![](http://jbcdn2.b0.upaiyun.com/2016/01/8953676e22a72240e765b4a6420107da.png)
从上图中可以看到，在没有横向扩展之前，橙色组成的负载已经达到了90%，接近单个服务实例的极限。为了解决这个问题，我们再引入一个服务器实例来分担工作。但是这样会导致其它几个本来资源利用率就已经不高的组成的利用率降得更低。而更为正确的扩展方式则是只扩展橙色组成：
![](http://jbcdn2.b0.upaiyun.com/2016/01/990cc5166f53ac855711a3c593cdd654.png)
从上面的讲解中可以看出，横向扩展实际上包含了很多种方式。相应地，《The Art of Scalability》一书则介绍了一个横向扩展所需要遵守的AKF扩展模型。根据AKF扩展模型，横向扩展实际上包含了三个维度，而横向扩展解决方案则是这三个维度上所做工作的结合：
![](http://jbcdn2.b0.upaiyun.com/2016/01/421e7326ae6843caffe5296e4d7152f6.png)
上图中展示了AKF扩展模型的最通用的表示形式。在该图中，原点O表示的是应用实例并没有能力执行任何横向扩展，而只能通过纵向扩展来提高它的服务能力。如果您的系统朝着某个坐标轴的方向前进，那么它就将得到一定程度的横向扩展能力。当然，这三个坐标轴并不互斥，因此您的应用可能同时拥有XYZ三个轴向的扩展能力：
![](http://jbcdn2.b0.upaiyun.com/2016/01/31cf9a5751e28f36b09699795fcab82e.png)
现在就让我们来看一下AKF扩展模型中各个坐标轴的意义。首先要讲解的就是X轴。在AKF扩展模型中，X轴表示的是应用可以通过部署更多的服务实例来解决扩展性的问题。在这种情况下，原本需要少量服务实例处理的大量负载就可以通过新添加的其它服务实例分担，从而扩大了系统容量，降低了单个服务实例的压力。
我们刚刚提到过，一个服务的扩展性可以同时由多个轴向的扩展性共同组成，因此在该服务中，这种X轴方向的扩展性不仅仅存在于服务这个层次上，更可以由子服务，甚至服务组成的扩展性来共同完成：
![](http://jbcdn2.b0.upaiyun.com/2016/01/9bc1aeb1bfea31a87c34722c7a2e9b7c.png)
请注意上图中的橙色方块。在该服务中，橙色方块作为一个子服务来向整个服务提供特定功能。在需要扩展时，我们可以通过添加一个新的橙色子服务实例来解决橙色服务负载过大的问题。因此就整个服务而言，其X轴的横向扩展能力并不是通过重新部署整套服务来完成的，而是对独立的子服务进行扩容。
相信您会问：既然只通过添加新的服务或子服务实例就能够完成对服务容量的扩充，那么我们还需要其它两个轴向的横向扩展能力么？
答案是肯定的。首先，最为现实的问题就是服务运行场景的约束。例如在对服务进行X轴横向扩展的时候，我们常常需要一个负载平衡服务。在《[企业级负载平衡简介](http://www.cnblogs.com/loveis715/p/4547968.html)》一文中我们已经说过，负载平衡服务器常常具有一定的性能限制。因此横向扩展并非全无止境。除此之外，我们也看到了横向扩展有时是使用在子服务上的，而将一个大的服务分割为多个子服务，本身也是沿着其它轴向的横向扩展。
Y轴横向扩展的意义则在于将所有的工作根据数据的类型或业务逻辑进行划分。而就一个Web服务而言，Y轴横向扩展所做的最主要工作就是将一个Monolith服务划分为一系列子服务，从而使不同的子服务独立工作并拥有独立地进行横向扩展的能力。这一方面可以将原本一个服务所处理的所有请求分担给一系列子服务实例来运行，更可以让您根据应用的实际运行情况来对某个成为系统瓶颈的子服务进行X轴横向扩展，避免由于对整个服务进行X轴横向扩展所造成的资源浪费：
![](http://jbcdn2.b0.upaiyun.com/2016/01/75599417e33ad91edf80b9bee55470c5.png)
这种组织各个子服务的方式被称为Microservice。使用Microservice组织子服务还可以帮助您实现一系列其它非功能性需求，如高可用性，可测试性等等。具体内容详见《[Microservice架构模式简介](/%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E8%AE%A1%E5%88%92/%E8%BF%9B%E8%A1%8C%E4%B8%AD/%EF%BC%9F%EF%BC%9F)》一文。
相较而言，执行Y轴扩展要比执行X轴扩展困难一些。但是其常常会使得其它一系列非功能性需求具有更高的质量。
而在Z轴上的横向扩展可能是大家所最不熟悉的情况。其表示需要根据用户的某些特性对用户的请求进行划分。例如使用基于DNS的负载平衡。
当然，到底您的服务需要实现什么程度的X，Y，Z轴扩展能力则需要根据服务的实际情况来决定。如果一个应用的最终规模并不大，那么只拥有X轴扩展能力，或者有部分Y轴扩展能力即可。如果一个应用的增长非常迅速，并最终演变为对吞吐量有极高要求的应用，那么我们就需要从一开始就考虑这个应用在X，Y，Z轴的扩展能力。
### 服务的扩展
好了，介绍了那么多理论知识，相信您已经迫不及待地想要了解如何令一个应用具有良好的扩展性了吧。那好，让我们首先从服务实例的扩展性说起。
我们已经在前面介绍过，对服务进行扩展主要有两种方法：横向扩展以及纵向扩展。对于服务实例而言，横向扩展非常简单：无非是将服务分割为众多的子服务并在负载平衡等技术的帮助下在应用中添加新的服务实例：
![](http://jbcdn2.b0.upaiyun.com/2016/01/7e0d5ab5563e1fd4bd0e59496bf19e6c.png)
上图展示了服务实例是如何按照AKF扩展模型进行横向扩展的。在该图的最顶层，我们使用了基于DNS的负载平衡。由于DNS拥有根据用户所在位置决定距离用户最近的服务这一功能，因此用户在DNS查找时所得到的IP将指向距离自己最近的服务。例如一个处于美国西部的用户在访问Google时所得到的IP可能就是64.233.167.99。这一功能便是AKF扩展模型中的Z轴：根据用户的某些特性对用户的请求进行划分。
接下来，负载平衡服务器就会根据用户所访问地址的URL来对用户的请求进行划分。例如用户在访问网页搜索服务时，服务集群需要使用左边的虚线方框中的服务实例来为用户服务。而在访问图片搜索服务时，服务集群则需要使用右边虚线方框中的服务实例。这则是AKF扩展模型中的Y轴：根据数据的类型或业务逻辑来划分请求。
最后，由于用户所最常使用的服务就是网页搜索，而单个服务实例的性能毕竟有限，因此服务集群中常常包含了多个用来提供网页搜索服务的服务实例。负载平衡服务器会根据各个服务实例的能力以及服务实例的状态来对用户的请求进行分发。而这则是沿着AKF扩展模型中的X轴进行扩展：通过部署具有相同功能的服务实例来分担整个负载。
可以看到，在负载平衡服务器的帮助下，对应用实例进行横向扩展是非常简单的事情。如果您对负载平衡功能比较感兴趣，请查看我的另一篇博文《[企业级负载平衡简介](http://blog.jobbole.com/96952/)》。
相较于服务的横向扩展，服务的纵向扩展则是一个常常被软件开发人员所忽视的问题。横向扩展诚然可以提供近乎无限的系统容量，但是如果一个服务实例本身的效能就十分低下，那么这种无限的横向扩展常常是在浪费金钱：
![](http://jbcdn2.b0.upaiyun.com/2016/01/8789d6357d90b73c10b5efb62b5b37b0.png)
就像上图中所展示的那样，一个应用当然可以通过部署4台具有同样功能的服务器来为用户提供服务。在这种情况下，搭建该服务的开销是5万美元。但是由于应用实现本身的质量不高，因此这四台服务器的资源使用率并不高。如果一个肯于动脑的软件开发人员能够仔细地分析服务实例中的系统瓶颈并加以改正，那么公司将可能只需要购买一台服务器，而员工的个人能力及薪水都会得到提升，并可能得到一笔额外的嘉奖。如果该员工为应用所添加的纵向扩展性足够高，那么该应用将可以在具有更高性能的服务器上运行良好。也就是说，单个服务实例的纵向扩展性不仅仅可以充分利用现有硬件所能提供的性能，以辅助降低搭建整个服务的花费，更可以兼容具有更强资源的服务器。这就使得我们可以通过简单地调整服务器设置来完成对整个服务的增强，如添加更多的内存，或者使用更高速的网络等方法。
现在就让我们来看看如何提高单个服务实例的扩展性。在一个应用中，服务实例常常处于核心位置：其接受用户的请求，并在处理用户请求的过程中从数据库中读取数据。接下来，服务实例会通过计算将这些数据库中得到的数据糅合在一起，并作为对用户请求的响应将其返回。在整个处理过程中，服务实例还可能通过服务端缓存取得之前计算过程中已经得到的结果：
![](http://jbcdn2.b0.upaiyun.com/2016/01/aef62f13682d27681005e613ebde44dd.png)
也就是说，服务实例在运行时常常通过向其它组成发送请求来得到运行时所需要的数据。由于这些请求常常是一个阻塞调用，服务实例的线程也会被阻塞，进而影响了单个线程在服务中执行的效率：
![](http://jbcdn2.b0.upaiyun.com/2016/01/a91bb92001267c6f6602fd87fbfd77a7.png)
从上图中可以看到，如果我们使用了阻塞调用，那么在调用另一个组成以获得数据的时候，调用方所在的线程将被阻塞。在这种情况下，整个执行过程需要3份时间来完成。而如果我们使用了非阻塞调用，那么调用方在等待其它组成的响应时可以执行其它任务，从而使得其在4份时间内可以处理两个任务，相当于提高了50%的吞吐量。
因此在编写一个高吞吐量的服务实现时，您首先需要考虑是否应该使用Java所提供的非阻塞IO功能。通常情况下，由非阻塞IO组织的服务会比由阻塞IO所编写的服务慢，但是其在高负载的情况下的吞吐量较非阻塞IO所编写的服务高很多。这其中最好的证明就是Tomcat对非阻塞IO的支持。
在较早的版本中，Tomcat会在一个请求到达时为该请求分配一个独立的线程，并由该线程来完成该请求的处理。一旦该请求的处理过程中出现了阻塞调用，那么该线程将挂起直至阻塞调用返回。而在该请求处理完毕后，负责处理该请求的线程将被送回到线程池中等待对下一个请求进行处理。在这种情况下，Tomcat所能并行处理的最大吞吐量实际上与其线程池中的线程数量相关。反过来，如果将线程数量设置得过大，那么操作系统将忙于处理线程的管理及切换等一系列工作，反而降低了效率。而在一些较新版本中，Tomcat则允许用户使用非阻塞IO。在这种情况下，Tomcat将拥有一系列用来接收请求的线程。一旦请求到达，这些线程就会接收该请求，并将请求转给真正处理请求的工作线程。因此在新版Tomcat的运行过程中将只包括几十个线程，却能够同时处理成千上万的请求。当然，由于非阻塞IO是异步的，而不是在调用返回时就立即执行后续处理，因此其处理单个请求的时间较使用阻塞IO所需要的时间长。
因此在服务少量的用户时，使用非阻塞IO的Tomcat对于单个请求的响应时间常常是Tomcat的2倍以上，但是在用户数量是成千上万个的时候，使用非阻塞IO的Tomcat的吞吐量则非常稳定：
![](http://jbcdn2.b0.upaiyun.com/2016/01/f3904edb354d3a2108c08de5a59e3cd7.png)
因此如果想要提高您的单个服务性能，首先您需要保证您在Tomcat等Web容器中正确地使用了非阻塞模式：
protocol=”org.apache.coyote.http11.Http11NioProtocol” redirectPort=”8443″/>
当然，使用非阻塞IO并不仅仅是通过配置Tomcat就完成了。试想在一个子服务实现中调用另一个子服务的情况：如果在调用子服务时调用方被阻塞，那么调用方的一个线程就被阻塞在那里，而不能处理其它待处理的请求。因此在您的应用中包含了较长时间的的阻塞调用时，您需要考虑使用非阻塞方式组织服务的实现。
在使用非阻塞方式组织服务之前，您最好详细地阅读《[Enterprise Integration Pattern](http://www.enterpriseintegrationpatterns.com/)》。Spring旗下的项目Spring Integration则是Enterprise Integration Pattern在Spring体系中的一种实现。因为它是在是一个非常大的话题，因此我会在其它博文中对它们进行简单地介绍。
在通过使用非阻塞模式提高了并发连接数之后，我们就需要考虑是否其它硬件会成为单个服务实例的瓶颈了。首先，更大的并发会导致更大的内存占用。因此如果您所开发的应用对内存大小较为敏感，那么您首先要做的就是为系统添加内存。而且在您的内存敏感应用的实现中，内存管理也会变成您需要考虑的一项任务。虽然说很多语言，如Java等，已经通过提供垃圾回收机制解决了野指针，内存泄露等一系列问题，但是在这些垃圾回收机制启动的时候，您的服务会暂时挂起。因此在服务实现的过程中，您需要考虑通过一些技术来尽量避免内存回收。
另外一个和硬件有关的话题可能就是CPU了。一个服务器常常包含多个CPU，而这些CPU可以包含多个核，因此在该台服务实例上常常可以同时运行十几个，甚至几十个线程。但是在实现服务时，我们常常忽略了这种信息，从而导致某些服务只能由少数几个线程并行执行。通常情况下，这都是因为服务过多地访问同一个资源，如过多地使用了锁，同步块，或者是数据库性能不够等一系列原因。
还有一个需要考虑的事情就是服务的动静分离。如果一个应用需要提供一系列静态资源，那么那些常用的Servlet容器可能并不是一个最优的选择。一些轻量级的Web服务器，如nginx在服务静态资源时的效率就将明显高于Apache等一系列动态内容服务器。
由于这篇文章的主旨并不是为了讲解如何编写一个具有较高性能的服务，因此对于上面所述的各种增强单个服务性能的技巧将不再进行深入讲解。
除了从服务自身下功夫来增强一个服务实例的纵向扩展性之外，我们还有一个重要的用来提高服务实例工作效率的武器，那就是服务端缓存。这些缓存通过将之前得到的计算结果记录在缓存系统中，从而尽可能地避免对该结果再次进行计算。通过这种方式，服务端缓存能大大地减轻数据库的压力：
![](http://jbcdn2.b0.upaiyun.com/2016/01/dcfa60a4981e5eee04c0688dd2e7cecd.png)
那它和服务的扩展性有什么关系呢？答案是，如果服务端缓存能够减轻系统中每个服务的负载，那么它实际上相当于提高了单个服务实例的工作效率，减少了其它组成对扩容的需求，变相地增加了各个相关组成的扩展性。
现在市面上较为主流的服务端缓存主要分为两种：运行于服务实例之上并与服务实例处于同一个进程之内的缓存，以及在服务实例之外独立运行的缓存。而后一种则是现在较为流行的解决方案：
![](http://jbcdn2.b0.upaiyun.com/2016/01/ebbf0c3f6e0c879ec5c490bd78d89b00.png)
从上图中可以看出，由于进程内缓存与特定的应用实例绑定，因此每个应用实例将只能访问特定的缓存。这种绑定一方面会导致单个服务实例所能够访问的缓存容量变得很小，另一方面也可能导致不同的缓存实例中存在着冗余的数据，降低了缓存系统的整体效率。相较而言，由于独立缓存实例是独立于各个应用服务器实例运行的，因此应用服务实例可以访问任意的缓存实例。这同时解决了服务实例能够使用的缓存容量过小以及冗余数据这两个问题。
如果您希望了解更多的有关如何搭建服务端缓存的知识，请查看我的另一篇博文《[Memcached简介](http://blog.jobbole.com/88554/)》。
除了服务端缓存之外，CDN也是一种预防服务过载的技术。当然，它的最主要功能还是提高距离服务较远的用户访问服务的速度。通常情况下，这些CDN服务会根据请求分布及实际负载等众多因素在不同的地理区域内搭建。在提供服务时，CDN会从服务端取得服务的静态数据，并缓存在CDN之内。而在一个距离该服务较远的用户尝试使用该服务时，其将会从这些CDN中取得这些静态资源，以提高加载这些静态数据的速度。这样服务器就不必再处理从世界各地所发来的对静态资源的请求，进而降低了服务器的负载。
### 数据库的扩展性
相较于服务实例，数据库的扩展则是一个更为复杂的话题。我们知道，不同的服务对数据的使用方式常常具有很大的差异。例如不同的服务常常具有非常不同的读写比，而另一些服务则更强调扩展性。因此如何对数据库进行扩展并没有一个统一的方法，而常常决定于应用自身对数据的要求。因此在本节中，我们将采取由下向上的方法讲解如何对数据库进行扩展。
通常情况下，对一个话题自上而下的讲解常常能够形成较好的知识系统。在使用该方式对问题进行讲解的时候，我们将首先提出问题，然后再以该问题为中心讲解组成该问题的各个子问题。在讲解中我们需要逐一地解决这些子问题，并将这些子问题的解决方案进行关联和比较。通过这种方式，读者常常能够更清晰地认识到各个解决方案的优点和缺点，进而能够根据问题的实际情况对解决方案进行取舍。这种方法较为适合问题较为简单并且清晰的情况。
而在问题较为复杂，包含情况较多的情况下，我们就需要将这些问题拆分为子问题，并在讲清楚各个子问题之后再去分析整个问题如何通过这些子问题解决方案合作解决。
那么如何将数据库的扩展性分割为子问题呢？在决定一个数据库应该拥有哪些特性时，常常用来作为评判标准的就是[CAP理论](https://en.wikipedia.org/wiki/CAP_theorem)。该理论指出我们很难保证数据库的一致性（Consistency），可用性（Availability）以及分区容错性（Partition tolerance）：
![](http://jbcdn2.b0.upaiyun.com/2016/01/0f2689e2b3fc3f9f861709c5e38babb2.png)
因此一系列数据库都选择了其中的两个特性来作为其实现的重点。例如常见的关系型数据库主要保证的是数据的一致性及数据的可用性，而并不强调对扩展性非常重要的分区容错性。这也便是数据库的横向扩展成为业界难题的一个原因。
当然，如果您的应用对一致性或可用性的要求并不是那么高，那么您就可以选择将分区容错性作为重点的数据库。这些类型的数据库有很多。例如现在非常流行的NoSQL数据库大多都将分区容错性作为一个实现重点。
因此在本节中，我们将会以关系型数据库作为重点进行讲解。又由于对关系型数据库进行横向扩展常常较纵向扩展更为困难，因此我们将首先讲解如何对关系型数据库进行横向扩展。
首先，最为常见也最为简单的纵向扩展方法就是增加关系型数据库所在服务实例的性能。我们知道，数据库在运行时会将其所包含的数据加载在内存之中，而且最常访问的数据是否存在于内存之中是数据库是否运行良好的关键。如果数据库所在的服务实例能够根据实际负载提供足够的内存，以承载所有最常被访问的数据，那么数据库的性能将得到充分地发挥。因此在执行纵向扩展的第一步就是要检查您的数据库所在的服务实例是否拥有足够的资源。
当然，仅仅从硬件入手是不够的。在前面的章节中已经介绍过，纵向扩展需要从两个方面入手：硬件的增强，以及软件的优化。就数据库本身而言，其最重要的保证运行性能的组成就是索引。在当代的各个数据库中，索引主要分为聚簇索引以及非聚簇索引两种。这两种索引能够加速对具有特定特征的数据的查找：
![](http://jbcdn2.b0.upaiyun.com/2016/01/206d93bedf678b07ae6b579ffdcaa395.png)
因此在数据库优化过程中，索引可以说是最为重要的一环。从上图中可以看出，如果一个查找能够通过索引来完成，而不是通过逐个查找数据库中所拥有的记录来进行，那么整个查找只需要分析组成索引的几个节点，而不是遍历数据库所拥有的成千上万条记录。这将会大大地提高数据库的运行性能。
但是如果索引没有存在于内存中，那么数据库就需要从硬盘中将它们读取到内存中再进行操作。这明显是一个非常慢的操作。因此为了您的索引能够正常工作，您首先要保证数据库运行所在的服务实例拥有足够的内存。
除了保证拥有足够的内存之外，我们还需要保证数据库的索引自身没有过多的浪费内存。一个最常见的索引浪费内存的情况就是Index Fragmentation。也就是说，在经过一系列添加，更新和删除之后，数据库中的数据在存储中的物理结构中将变得不再规律。这主要分为两种：Internal Fragmentation，即物理结构中可能存在着大量空白；External Fragmentation，即这些数据在物理结构中并不是有序排列的。Internal Fragmentation意味着索引所包含节点的增加。这一方面导致我们需要更大的空间来存储索引，从而占用更多的内存，另一方面也会让数据寻找所需要遍历的节点数量增加，从而导致系统性能的下降。而External Fragmentation则意味着从磁盘顺序读取这些数据时需要硬盘重新进行寻址等操作，也会显著降低系统的执行性能。还有一个需要考虑的有关External Fragmentation的问题则是是否我们的服务与其它服务使用了共享磁盘。如果是，那么其它服务对于磁盘的使用会导致External Fragmentation的问题无法从根本上解决，巡道操作将常常发生。
另外一个常用的对索引进行优化的方法就是在非聚簇索引中通过INCLUDE子句包含特定列，以加快某些请求语句的执行速度。我们知道，聚簇索引和非聚簇索引的差别主要就存在于是否包含数据。如果从聚簇索引中执行数据的查找，那么在找到对应的节点之后，我们就已经可以从该节点中得到需要查找的数据。而如果我们的查找是在非聚簇索引中进行的，那么我们得到的则是目标数据所在的位置。为了找到真正的数据，我们还需要进行一次寻址操作。而在通过INCLUDE子句包含了所需要数据的情况下，我们就可以避免这次寻址，进而提高了查找的性能。
但是需要注意的是，索引是数据库在其本身所拥有的数据之外额外创建的数据结构，因此其实际上也需要占用内存。在插入及删除数据的时候，数据库同样需要维护这些索引，以保证索引和实际数据的一致性，因此其会导致数据库插入及删除操作性能的下降。
还有一个需要考虑的则是通过正确地设置Fill Factor来尽量避免Page Split。在常见的数据库中，数据是记录在具有固定大小的页中。当我们需要插入一条数据的时候，目标页中的可用空间可能已经不足以再添加一条新的数据。此时数据库会添加一个新的页，并将数据从一个页分到这两个页中。在该过程中，数据库不仅仅要添加及修改数据页本身，更需要对IAM等页进行更改，因此是一个较为消耗资源的操作。FillFactor是一个用来控制在叶页创建时每页所填充的百分比的全局设置。在设置了FillFactor的基础之上，用户还可以设置PAD_INDEX选项，来控制非叶页也使用FillFactor来控制数据的填充。一个较高的FillFactor会使数据更加集中，由此拥有更高的读取性能。而一个较低的FillFactor则对写入较为友好，因为其防止了Page Split。
除了上面所述的各种方法之外，您还可以通过其它一系列数据库功能来提高性能。这其中最重要的当然是各个数据库所提供的执行计划（Execution Plan）。通过执行计划，您可以看到您正在执行的请求是如何被数据库执行的：
![](http://jbcdn2.b0.upaiyun.com/2016/01/0fb42ee5578b3bcdb262a6037e745999.png)
由于如何提高单个数据库的性能是一个庞大的话题，而我们的文章主要集中在如何提高扩展性，因此我们在这里不再对如何提高数据库的执行性能进行详细的介绍。
反过来，由于单个服务器的性能毕竟有限，因此我们并不能无限地对关系型数据库进行纵向扩展。因此在必要条件下，我们需要考虑对关系型数据库进行横向扩展。而将AKF横向扩展模型施行在关系型数据库之上后，其各个轴的意义则如下所示：
![](http://jbcdn2.b0.upaiyun.com/2016/01/168f5799af07b18a352ff5cbc22216e2.png)
现在就跟我来看看各个轴的含义。在AKF模型中，X轴表示的是应用可以通过部署更多的服务实例来解决扩展性的问题。而由于关系型数据库要管理数据的读写并保证数据的一致性，因此在X轴上的扩展将不能简单地通过部署额外的数据库实例来解决问题。在进行X轴扩展的时候，这些数据库实例常常拥有不同的职责并组成特定的拓扑结构。这就是数据库的Replication。
而相较于X轴，数据库AKF模型中的Y轴和Z轴则较为容易理解。AKF模型中的Y轴表示的是将所有的工作根据数据的类型或业务逻辑进行划分，而Z轴则表示根据用户的某些特性对用户的请求进行划分。这两种划分实际上都是要将数据库中的数据划分到多个数据库实例中，因此它们对应的则是数据库的Partition。
让我们先看看数据库的Replication。简单地说，数据库的Replication表示的就是将数据存储在多个数据库实例中。读请求可以在任意的数据库实例上执行，而一旦某个数据库实例上发生了数据的更新，那么这些更新将会自动复制到其它数据库实例上。在数据复制的过程中，数据源被称为Master，而目标实例则被称为Slave。这两个角色并不是互斥的：在一些较为复杂的拓扑结构中，一个数据库实例可能既是Master，又是Slave。
在关系型数据库的Replication中，最为常见的拓扑模型就是简单的Master-Slave模型。在该模型中，对数据的读取可以在任意的数据库实例上完成。而在需要对数据进行更新的时候，数据将只能写入特定的数据库实例。此时这些数据的更改将沿着单一的方向从Master向Slave进行传递：
![](http://jbcdn2.b0.upaiyun.com/2016/01/b03928b8e6da3c51bdd28ffea186aa99.png)
在该模型中，数据读取的工作是由Master和Slave共同处理的。因此在上图中，每个数据库的读负载将是原来的一半左右。但是在写入时，Master和Slave都需要执行一次写操作，因此各个数据库实例的写负载并没有降低。如果读负载逐渐增大，我们还可以加入更多的Slave节点以分担读负载：
![](http://jbcdn2.b0.upaiyun.com/2016/01/aff446ff8e39212ad753cdc45ec5281c.png)
相信您现在已经清楚了，关系型数据库的横向扩展主要是通过加入一系列数据库实例来分担读负载来完成的。但是有一点需要注意的是，这种写入传递关系是靠Master和Slave中的一个独立的线程来完成的。也就是说，一个Master拥有多少个Slave，它的内部就需要维持多少个线程来完成对属于它的Slave的更新。由于在一个大型应用中常常可能包含上百个Slave实例，因此将这些Slave都归于同一个Master将导致Master的性能急剧下降。
其中一个解决方法就是将其中的某些Slave转化为其它Slave的Master，并将它们组织成为一个树状结构：
![](http://jbcdn2.b0.upaiyun.com/2016/01/fac9ce761f1213be055cd85a0a61f6f5.png)
但是Master-Slave模型拥有一个缺点，那就是有单点失效的危险。一旦作为Master的数据库实例失效了，那么整个数据库系统，至少是以该Master节点为根的子系统将会失效。
而解决该问题的一种方法就是使用多Master的Replication模型。在该模型中，每个Master数据库实例除了可以将数据同步给各个Slave之外，还可以将数据同步给其它的Master：
![](http://jbcdn2.b0.upaiyun.com/2016/01/51ac752b34d4cab037e30b026f16f622.png)
在这种情况下，我们避免了单点失效的问题。但是如果两个数据库实例对同一份数据更新，那么它们将产生数据冲突。当然，我们可以通过将对数据的划分为毫不相干的多个子集并由每个Master节点负责某个特定子集的更新的方式来防止数据冲突。
![](http://jbcdn2.b0.upaiyun.com/2016/01/20de42eaec6949f34a74de495480171e.png)
从上图中可以看到，用户对数据的写入会根据特定条件来分配到不同的数据库实例上。接下来，这些写入会同步到其它实例上，从而保持数据的一致性。但是既然我们能将这些数据独立地切割为各个子集，那么我们为什么不去尝试一下数据库的Partition呢？
简单地说，数据库的Partition就是将数据库中需要记录的数据划分为一系列子集，并由不同的数据库实例来记录这些数据子集所包含的数据。通过这种方法，对数据的读取以及写入负载都会根据数据所在的数据库实例来进行划分。而这也就是数据库沿AKF扩展模型的Y轴进行横向扩展的方法。
在执行数据库的Partition时，数据库原有的数据将被切分到不同的数据库实例中。每个数据库实例将只包含原数据库中几个表的数据，从而将对整个数据库的访问切分到不同的数据库实例中：
![](http://jbcdn2.b0.upaiyun.com/2016/01/20dca8f89497aed853e97fe767f9bbda.png)
但是在某些情况下，对数据库中的数据按表切分并不能解决问题。切分完毕后的某个数据库实例仍然可能承担了过多的负载。那么此时我们就需要将该数据库再次切分。只是这次我们所切分的是数据库中的数据行：
![](http://jbcdn2.b0.upaiyun.com/2016/01/1e6c19398d43f169669eedd2747084d0.png)
在这种情况下，我们在对数据进行操作之前首先需要执行一次计算来决定数据所在的数据库实例。
然而数据库的Partition并不是没有缺点。最常见的问题就是我们不能通过同一条SQL语句操作不同数据库实例中记录的数据。因此在决定对数据库进行切分之前，您首先需要仔细地检查各个表之间的关系，并确认被分割到不同数据库中的各个表没有过多的关联操作。
好了。至此为止，我们已经讲解了如何创建具有可扩展性的服务实例，缓存以及数据库。相信您已经对如何创建一个具有高扩展性的应用有了一个较为清晰的认识。当然，在撰写本文的过程中，我也发现了一系列可以继续讲解的话题，如Spring Integration，以及对数据库Replication以及Partition（Sharding）的讲解。在有些方面（如数据库），我并不是专家。但是我会尽我所能把本文所写的知识点一一陈述清楚。
