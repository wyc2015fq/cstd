# 基于海量词库的单词拼写检查、推荐到底是咋做的？ - 文章 - 伯乐在线
原文出处： [haolujun](https://www.cnblogs.com/haolujun/p/9585509.html)
# 前言
在我们日常应用中，应该遇到不少类似的状况：
- 写文档时，单词拼写错误后，工具自动推荐一个相似且正确的拼写形式；
- 使用搜狗输入法时，敲错某个字的拼音照样能够打出我们想要的汉字；
- 利用搜索引擎进行搜索时，下拉框中自动列出与输入相近的词语。
- 等等，不一一列举。
这种功能是如何实现的呢？里面用到了哪些算法呢？本文就来介绍一个能够完成这个任务的算法。
## 问题描述
其实，这几个问题都能够转换成同一个问题：即对于给定的输入字符串T，在预先准备好的模式串集合Q中找到与输入串相似的模式串子集。
那么如何得到准备好的这些模式串集合呢？我们可以通过数据挖掘等一些机制来得到。
那么接下来的问题就是如何快速的从这个集合中找到与输入串相似的字符串？通常我们用最小编辑距离来表示两个字符串的相似程度。
例如，对于输入串T，我们限制错误数小于等于2，即在预先准备好的模式集合中找所有与输入串编辑距离小于等于2的字符串。
有什么算法能够快速完成这个任务呢？
## 暴力算法
遍历集合Q中的每个模式串P，分别计算其与输入串T的最小编辑距离，如果编辑距离小于指定的错误容忍度x，则输出这个模式串。
- 时间复杂度：O(|Q| * n * m)，当|Q|很大时，速度将会很慢。
那么这个算法可以优化么？可以！
比如，第一个字很少有人输入错，所以我们可以在模式串集合Q中只对第一个字与输入串第一个字相同的那些字符串进行相似度计算，这样就能够减少相当多的算量，是一个可行方法。
但是这也有问题，假若少部分人确实第一个字输入错了，那么这个算法找到的所有串也是错的，不能达到纠错的效果。
所以，针对首字符过滤的优化算法有一定的局限性。
## 步步优化
我们仔细思考这个问题，由于模式串Q是一个集合，那么其中必定有大量的模式串有共同的前缀。能否利用这个前缀进行优化呢？
#### 优化1： 利用两个词的相同前缀进行优化
比如：字符串 explore和explain，他们有公共的前缀，这就意味着他们与字符串explode的编辑矩阵的前几列值是相同的，不用重复计算，如下图红色部分所示。
![](http://jbcdn2.b0.upaiyun.com/2018/09/6b81c4bb8a7804c54bce2e8238499d4d.png)
explore与explain无论与任何字符串计算编辑距离，编辑矩阵的前4列肯定一模一样。所以，如果我们已经计算过explore与某个串的编辑距离后，那么当计算该串与explain的编辑距离时，前4列可以复用，直接从第五列开始计算。
到此，我们得到一个新的算法计算多模式的编辑距离：把模式串集合建立成一棵字典树，深度优先遍历这棵树，在遍历的过程中，不断更新编辑矩阵的某一个列，如果到达的节点是一个终结符，并且T与P（路径上的字符形成的字符串）的编辑距离小于指定的容忍度，则找到一个符合条件的串。
### 优化2：剪枝
虽然我们利用词前缀优化了算法，能够避免拥有相同前缀模式串的编辑矩阵的重复计算，但是必须要遍历所有节点。有没有什么办法能够在计算到某一深度后，根据一些限制条件能够剪去该子树其它剩余节点的计算呢？在搜索算法中，这种优化叫做剪枝。接下来我们讨论一下该如何设计一个剪枝函数。
重新审视我们的编辑距离定义，其实可以看成是把字符串P和T分别拆分成两段，然后计算对应的段的编辑距离之和，如下图所示。
![](http://jbcdn2.b0.upaiyun.com/2018/09/20d56bfac8d442debca343d977f2a9c7.png)
字符串P和T分别拆分成两段，红色和绿色。红色部分之间的编辑距离与绿色部分之间的编辑距离之和即为字符串P和T的编辑距离。
举个例子，更形象：
- 例子1
![](http://jbcdn2.b0.upaiyun.com/2018/09/9ca01e50bde33fdc2a171f2ce7326356.png)


```
ed("explore", "express") = ed("explo", "exp") + ed("re", "ress")
```
- 例子2
![](http://jbcdn2.b0.upaiyun.com/2018/09/5f9235b8943733fe2cf38090a84beb09.png)


```
ed("explore", "express") = ed("exp", "exp") + ed("lore", "ress")
```
- 例子3
但是，并不是每种划分都是正确的，比如下面图所示：
![](http://jbcdn2.b0.upaiyun.com/2018/09/bf3bef35858e60c200fae355b5b2ed2c.png)


```
ed("ex","exp") + ed("plore", "ress") = 1 + 4 = 5
```
**所以，最小编辑距离问题又相当于一个最优拆分，即对于字符串P中位置为i的字符，找到在T中的一个最优位置j，使得**


```
ed(P.prefix(i), T.prefix(j)) + ed(P.suffix(i+1), T.suffix(j+1))
```
**最小。**
回到我们这个问题中来，如果我们限制P和T的最小编辑距离小于等于x，
![](http://jbcdn2.b0.upaiyun.com/2018/09/e3bebd84db26517fba83de949eee80b9.png)
我们让 p[i]分别匹配t[i-x],t[i-x+1],……,t[i],t[i+1],……t[i+x]，并找到其中前半段匹配的最小的编辑距离ed1=ed(p[1~i],t[1~j])，如果ed1大于x，我们则能推断出ed(p,t)也终将大于x（ed=ed1+ed2>x）。
为什么p[i]不匹配t[i-x-1]以及之前的位置呢？那是因为ed(p.prefix(i), t.prefix(i-x-1)) > x，因为必须至少在t.prefix(i-x-1)中插入x+1个字符才能保证字符串长度相等；同理p[i]也不能匹配t[i+x+1]及其之后的位置。所以，根据分段原则，最优匹配肯定出现在t[i-x] ~ t[i+x]之间，如果这个区间的最小编辑距离都大于x，那么我们无需对p[i+1]及其之后的字符进行匹配计算。
![](http://jbcdn2.b0.upaiyun.com/2018/09/fcf1ee5a9fe3f9f583cd37264f33cb90.png)
例如：当遍历到蓝色节点l时，路径形成的字符串expl与T=exist满足剪枝条件，则后序节点不需要遍历，因为后面不可能有任何一个字符串满足与T的编辑距离小于2。
**至此，我们得到了剪枝优化：深度遍历到达字典树的某个节点，其路径上的字符组成字符串P，计算其与T.prefix(i-x), T.prefix(i-x+1),……T.prefix(i+x)的最小编辑距离，如果其中的最小值大于x，则停止遍历这棵子树上的后面的节点。**
其实，这个最终版本的优化算法出自论文：**《Error-tolerant finite-state recognition with applications to morphological analysis and spelling correction》.K Oflazer:1996 **
### 代码实现与效果对比
代码实现需需要很强的技巧性，因为无论是剪枝函数还是进行最终确认函数都可以复用同一个编辑矩阵，贴一个很丑陋的代码：[https://github.com/haolujun/Algorithm/tree/master/muti-edit-distance](https://github.com/haolujun/Algorithm/tree/master/muti-edit-distance)
这个算法在错误容忍度非常小的情况下效率非常高，我随机生成了10万个长度5~10的模式串，再随机生成100个输入串T（长度5 ~ 10），字符集大小为10，x最小编辑距离限制，计算多模式编辑距离，处理总时间如下，单位ms：
|算法|x = 1|x = 2|x = 3|x = 4|x = 5|x = 6|
|----|----|----|----|----|----|----|
|暴力算法|21990|21990|21990|21990|21990|21990|
|优化算法|97|922|4248|11361|20097|28000|
当容忍度很小时，优化算法完胜暴力算法，并且实际应用中x一般取值都非常小，正好适合优化算法。
当x值增大，优化算法效率逐渐下降，并且最后慢于暴力算法，这是因为优化算法实现复杂导致（递归+更复杂的判断）。
所以，最终应用时，我们根据x值选择不同的算法。
