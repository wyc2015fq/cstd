# 树形结构数据存储方案（二）： 物化路径 - 文章 - 伯乐在线
原文出处： [标点符](https://www.biaodianfu.com/path-enumeration.html)
前一篇文章介绍了比较简单的[邻接列表模式](http://blog.jobbole.com/112309/)，物化路径其实更加容易理解，其实就是在创建节点时，将节点的完整路径进行记录。以下图为例：
![tree](http://jbcdn2.b0.upaiyun.com/2017/08/91ae30cffcfe91c0ebd3e6091f970295.jpg)
按照Path Enumeration 进行存储后的结果如下：
![Path-Enumeration](http://jbcdn2.b0.upaiyun.com/2017/08/d1a1da59ee04bd6479425f929f1da5d0.png)
此种方案借助了unix文件目录的思想，主要时以空间换时间。
查询某一节点下的所有子节点:（以Fruit为例）


```
SET @path = (SELECT path FROM pathTree WHERE node_name = 'Fruit');
SELECT * FROM pathTree WHERE path like CONCAT(@path,'/%');
```
如何查询直属子节点？需要采用MySQL的正则表达式查询：


```
SET @path = (SELECT path FROM pathTree WHERE node_name = 'Fruit');
SELECT * FROM pathTree WHERE path REGEXP CONCAT(@path,'/','[0-9]$');
```
查询任意节点的所有上级：（以Yellow为例）：


```
SET @path = (SELECT path FROM pathTree WHERE node_name = 'Yellow');
SELECT * FROM pathTree WHERE @path LIKE CONCAT(path, '%') AND path <> @path;
```
插入新增数据：


```
SET @parent_path = ( SELECT path FROM pathTree WHERE node_name = 'Fruit');
INSERT INTO pathtree (path,node_name) VALUES (CONCAT(@parent_path,'/',LAST_INSERT_ID()+1),'White')
```
此方案的缺点是树的层级太深有可能会超过PATH字段的长度，所以其能支持的最大深度并非无限的。
如果层级数量是确定的，可以再将所有的列都展开，如下图，比较试用于类似行政区划、生物分类法（界、门、纲、目、科、属、种）这些层级确定的内容。
![Multiple-lineage-columns](http://jbcdn2.b0.upaiyun.com/2017/08/579dacd5167f484176573e5603f755c3.png)
参考文章：
- https://communities.bmc.com/docs/DOC-9902
