# 坐在马桶上看算法（13）：堆—神奇的优先队列（下） - 文章 - 伯乐在线
本文作者： [伯乐在线](http://blog.jobbole.com) - [啊哈磊](http://www.jobbole.com/members/ahalei) 。未经作者许可，禁止转载！
欢迎加入伯乐在线 [专栏作者](http://blog.jobbole.com/99322)。
[接着上一篇说。](http://blog.jobbole.com/101484/)就是如何建立这个堆呢。可以从空的堆开始，然后依次往堆中插入每一个元素，直到所有数都被插入（转移到堆中为止）。因为插入第i个元素的所用的时间是O(log i)，所以插入所有元素的整体时间复杂度是O(NlogN)，代码如下。


```
n=0;
for(i=1;i<=m;i++)
{
    n++;
    h[ n]=a[ i];  //或者写成scanf("%d",&h[ n]);
    siftup();
}
```
其实我们还有更快得方法来建立堆。它是这样的。
直接把99、5、36、7、22、17、46、12、2、19、25、28、1和92这14个数放入一个完全二叉树中（这里我们还是用一个一维数组来存储完全二叉树）。
![](http://www.ahalei.com/data/attachment/forum/201406/17/091806wwy7lo7lkwp66npb.png)
在这个棵完全二叉树中，我们从最后一个结点开始依次判断以这个结点为根的子树是否符合最小堆的特性。如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。如果这句话没有理解不要着急，继续往下看。
首先我们从叶结点开始。因为叶结点没有儿子，所以所有以叶结点为根结点的子树（其实这个子树只有一个结点）都符合最小堆的特性（即父结点的值比子结点的值小）。这些叶结点压根就没有子节点，当然符合这个特性。因此所有叶结点都不需要处理，直接跳过。从第n/2个结点（n为完全二叉树的结点总数，这里即7号结点）开始处理这棵完全二叉树。注意完全二叉树有一个性质：最后一个非叶结点是第n/2个结点。
以7号结点为根的子树不符合最小堆的特性，因此要向下调整。
![](http://www.ahalei.com/data/attachment/forum/201406/17/091759acwvyrag0gvag0ff.png)
同理以6号、5号和4结点为根的子树也不符合最小对的特性，都需要往下调整。
![](http://www.ahalei.com/data/attachment/forum/201406/17/091816u1459fgmfdyf8955.png)
下面是已经对7号、6号、5号和4结点为根结点的子树调整完毕之后的状态
![](http://www.ahalei.com/data/attachment/forum/201406/17/091822m1sefwsg2fgfl6z6.png)
当然目前这棵树仍然不符合最小堆的特性，我们需要继续调整以3号结点为根的子树，即将3号结点向下调整。
![](http://www.ahalei.com/data/attachment/forum/201406/17/091832bfunwuf2ee76eeiy.png)
同理继续调整以2号结点为根的子树，最后调整以1号结点为根的子树。调整完毕之后，整棵树就符合最小堆的特性啦。
![](http://www.ahalei.com/data/attachment/forum/201406/17/091839mo8b8uxga71o1bun.png)
小结一下这个创建堆的算法。把n个元素建立一个堆，首先我可以将这n个结点以自顶向下、从左到右的方式从1到n编码。这样就可以把这n个结点转换成为一棵完全二叉树。紧接着从最后一个非叶结点（结点编号为n/2）开始到根结点（结点编号为1），逐个扫描所有的结点，根据需要将当前结点向下调整，直到以当前结点为根结点的子树符合堆的特性。虽然讲起来起来很复杂，但是实现起来却很简单，只有两行代码如下：


```
for(i=n/2;i>=1;i--)
    siftdown(i);
```
用这种方法来建立一个堆的时间复杂度是O(N)，如果你感兴趣可以尝试自己证明一下，嘿嘿。
堆还有一个作用就是堆排序，与快速排序一样堆排序的时间复杂度也是O(NlogN)。堆排序的实现很简单，比如我们现在要进行从小到大排序，可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。最终输出的或者存放在新数组中数就已经是排序好的了。


```
//删除最大的元素
int deletemax()
{
    int t;
    t=h[ 1];//用一个临时变量记录堆顶点的值
    h[ 1]=h[ n];//将堆得最后一个点赋值到堆顶
    n--;//堆的元素减少1
    siftdown(1);//向下调整
    return t;//返回之前记录的堆得顶点的最大值
}
```
建堆以及堆排序的完整代码如下：


```
#include <stdio.h>
int h[ 101];//用来存放堆的数组
int n;//用来存储堆中元素的个数，也就是堆的大小
  
//交换函数，用来交换堆中的两个元素的值
void swap(int x,int y)
{
    int t;
    t=h[ x];
    h[ x]=h[ y];
    h[ y]=t;
}
  
//向下调整函数
void siftdown(int i) //传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整
{
    int t,flag=0;//flag用来标记是否需要继续向下调整
    //当i结点有儿子的时候（其实是至少有左儿子的情况下）并且有需要继续调整的时候循环窒执行
    while( i*2<=n && flag==0 )
    {        
        //首先判断他和他左儿子的关系，并用t记录值较小的结点编号
        if( h[ i] > h[ i*2] )
            t=i*2;
        else
            t=i;
        //如果他有右儿子的情况下，再对右儿子进行讨论
        if(i*2+1 <= n)
        {
            //如果右儿子的值更小，更新较小的结点编号  
            if(h[ t] > h[ i*2+1])
                t=i*2+1;
        }
        //如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的  
        if(t!=i)
        {
            swap(t,i);//交换它们，注意swap函数需要自己来写
            i=t;//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整
        }
        else
            flag=1;//则否说明当前的父结点已经比两个子结点都要小了，不需要在进行调整了
    }
}
  
//建立堆的函数
void creat()
{
    int i;
    //从最后一个非叶结点到第1个结点依次进行向上调整
    for(i=n/2;i>=1;i--)
    {
        siftdown(i);
    }  
}
  
//删除最大的元素
int deletemax()
{
    int t;
    t=h[ 1];//用一个临时变量记录堆顶点的值
    h[ 1]=h[ n];//将堆得最后一个点赋值到堆顶
    n--;//堆的元素减少1
    siftdown(1);//向下调整
    return t;//返回之前记录的堆得顶点的最大值
}
  
int main()
{
    int i,num;
    //读入数的个数
    scanf("%d",&num);
  
    for(i=1;i<=num;i++)
        scanf("%d",&h[ i]);
    n=num;   
  
    //建堆
    creat();
  
  
    //删除顶部元素，连续删除n次，其实夜就是从大到小把数输出来
    for(i=1;i<=num;i++)
        printf("%d ",deletemax());
  
    getchar();
    getchar();
    return 0;
}
```
可以输入以下数据进行验证


```
14
99 5 36 7 22 17 46 12 2 19 25 28 1 92
```
运行结果是


```
1 2 5 7 12 17 19 22 25 28 36 46 92 99
```
当然堆排序还有一种更好的方法。从小到大排序的时候不建立最小堆而建立最大堆。最大堆建立好后，最大的元素在h[ 1]。因为我们的需求是从小到大排序，希望最大的放在最后。因此我们将h[ 1]和h[ n]交换，此时h[ n]就是数组中的最大的元素。请注意，交换后还需将h[ 1]向下调整以保持堆的特性。OK现在最大的元素已经归位，需要将堆的大小减1即n–，然后再将h[ 1]和h[ n]交换，并将h[ 1]向下调整。如此反复，直到堆的大小变成1为止。此时数组h中的数就已经是排序好的了。代码如下：


```
//堆排序
void heapsort()
{
    while(n>1)
    {
        swap(1,n);
        n--;
        siftdown(1);
    }
}
```
完整的堆排序的代码如下，注意使用这种方法来进行从小到大排序需要建立最大堆。


```
#include <stdio.h>
int h[ 101];//用来存放堆的数组
int n;//用来存储堆中元素的个数，也就是堆的大小
 
//交换函数，用来交换堆中的两个元素的值
void swap(int x,int y)
{
    int t;
    t=h[ x];
    h[ x]=h[ y];
    h[ y]=t;
}
 
//向下调整函数
void siftdown(int i) //传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整
{
    int t,flag=0;//flag用来标记是否需要继续向下调整
    //当i结点有儿子的时候（其实是至少有左儿子的情况下）并且有需要继续调整的时候循环窒执行
    while( i*2<=n && flag==0 )
    {        
        //首先判断他和他左儿子的关系，并用t记录值较大的结点编号
        if( h[ i] < h[ i*2] )
            t=i*2;
        else
            t=i;
        //如果他有右儿子的情况下，再对右儿子进行讨论
        if(i*2+1 <= n)
        {
            //如果右儿子的值更大，更新较小的结点编号  
            if(h[ t] < h[ i*2+1])
                t=i*2+1;
        }
        //如果发现最大的结点编号不是自己，说明子结点中有比父结点更大的  
        if(t!=i)
        {
            swap(t,i);//交换它们，注意swap函数需要自己来写
            i=t;//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整
        }
        else
            flag=1;//则否说明当前的父结点已经比两个子结点都要大了，不需要在进行调整了
    }
}
 
//建立堆的函数
void creat()
{
    int i;
    //从最后一个非叶结点到第1个结点依次进行向上调整
    for(i=n/2;i>=1;i--)
    {
        siftdown(i);
    }  
}
 
//堆排序
void heapsort()
{
        while(n>1)
    {
                swap(1,n);
        n--;
        siftdown(1);
    }
}
 
int main()
{
    int i,num;
    //读入n个数
    scanf("%d",&num);
 
    for(i=1;i<=num;i++)
        scanf("%d",&h[ i]);
    n=num;   
 
    //建堆
    creat();
 
    //堆排序
    heapsort();
 
    //输出
    for(i=1;i<=num;i++)
        printf("%d ",h[ i]);
 
    getchar();
    getchar();
    return 0;
}
```
可以输入以下数据进行验证


```
14
99 5 36 7 22 17 46 12 2 19 25 28 1 92
```
运行结果是


```
1 2 5 7 12 17 19 22 25 28 36 46 92 99
```
OK，最后还是要总结一下。像这样支持插入元素和寻找最大（小）值元素的数据结构称之为优先队列。如果使用普通队列来实现这个两个功能，那么寻找最大元素需要枚举整个队列，这样的时间复杂度比较高。如果已排序好的数组，那么插入一个元素则需要移动很多元素，时间复杂度依旧很高。而堆就是一种优先队列的实现，可以很好的解决这两种操作。
另外Dijkstra算法中每次找离源点最近的一个顶点也可以用堆来优化，使算法的时间复杂度降到O((M+N)logN)。堆还经常被用来求一个数列中第K大的数。只需要建立一个大小为K的最小堆，堆顶就是第K大的数。如果求一个数列中第K小的数，只最需要建立一个大小为K的最大堆，堆顶就是第K小的数，这种方法的时间复杂度是O(NlogK)。当然你也可以用堆来求前K大的数和前K小的数。你还能想出更快的算法吗？有兴趣的同学可以去阅读《编程之美》第二章第五节。
堆排序算法是由J.W.J. Williams在1964年发明，他同时描述了如何使用堆来实现一个优先队列。同年，由Robert W．Floyd提出了建立堆的线性时间算法。
