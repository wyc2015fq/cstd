# 逆元 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





链接：[https://www.nowcoder.com/acm/contest/80/B](https://www.nowcoder.com/acm/contest/80/B)
来源：牛客网




Jxc将天空看做一个n*n的矩阵，此时天上有m朵云，这些云会随机分布在m个不同的位置，同时太阳会随机出现在一个位置，Jxc想知道他被太阳晒到的概率是多少，由于他仍在站军姿，所以这个有趣的问题就交给了你。考虑到精度问题，Jxc只需要知道这个概率在对998244353取模意义下的值。 

  Tips：一个分数p/q在模意义下的值即p*q-1在模意义下的值，Xp-1![](https://uploadfiles.nowcoder.com/files/20180404/301599_1522836190862_equation?tex=%5Cequiv)1 (mod p) 











## 输入描述:
输入只有一行，包含两个整数n、m。n和m的意义见题面.
## 输出描述:
第一行包含一个整数Ans，为答案



示例1



## 输入

2 2



## 输出

499122177




## 备注:
1 <= n, m <= 2000,m <=n^2
```
#include<bits/stdc++.h>
using namespace std;
typedef long long  ll;
const int maxn = 1000000;
const int moder = 998244353;
const double e = 2.718281828459;



ll quick_mod(ll x,ll n)
{
    ll res = 1;
    while(n){
        if(n&1) res = (res*x)%moder;
        n = n>>1;
        x = (x*x)%moder;
    }
    return res;
}


int main()
{
    ll n,m;
    scanf("%lld%lld",&n,&m);
    ll bn = quick_mod(n*n,moder-2);
    printf("%lld\n",(n*n-m)*bn%moder);
    return 0;
}
```

——

x的moder-2次方 = （x的2次方）的倒数 取模











