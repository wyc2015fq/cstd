# 莫比乌斯函数 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





和容斥有点相似，代码看懂了，原理还不是很理解。

```
ll mod_pow(ll x,ll n,ll mod)
{
    ll res = 1;
    while(n > 0)
    {
        if(n & 1) res = (res * x)%moder;
        x = (x*x)%moder;
        n >>= 1;
    }
    return res;
}



map<int,int> moebius(int n)
{
    map<int,int>res;
    vector<int>primes;

    for(int i=2;i*i < n;i++)
    {
        if(n%i == 0)
        {
            primes.push_back(i);
            while(n%i ==0) n = n/i;
        }
    }
    if(n != 1)primes.push_back(n);

    int m = primes.size();
    for(int i=0;i < (1 << m);i++)
    {
        int mu=1,d=1;
        for(int j=0;j < m;j++)
        {
            if(i << j & 1)
            {
                mu *= -1;
                d *= primes[j];
            }
        }
        res[d] = mu;
    }
    return res;
}

int n;
void solve()
{
    int res = 0;
    map<int,int> mu = moebius(n);
    for(map<int,int>::iterator it = mu.begin();it != mu.end();++it)
    {
        res += it->second * mod_pow(26,n/it->first,moder);
        res = (res%moder+moder)%moder;
    }
    printf("%d\n",res);
}
```

——











