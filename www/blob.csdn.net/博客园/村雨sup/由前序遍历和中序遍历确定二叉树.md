# 由前序遍历和中序遍历确定二叉树 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





## 问题 B: 二叉树的遍历
时间限制: 1 Sec  内存限制: 128 MB
提交: 582  解决: 331
[[提交](http://202.4.155.100/JudgeOnline/submitpage.php?cid=1296&pid=1&langmask=0)][[状态](http://202.4.155.100/JudgeOnline/problemstatus.php?id=1218)][[讨论版](http://202.4.155.100/JudgeOnline/bbs.php?pid=1218&cid=1296)]
## 题目描述

根据二叉树性质，由二叉树的前序遍历序和中序遍历序，可以唯一确定一棵二叉树（设二叉树中各结点不相同）。请编写程序，根据输入的二叉树的前序遍历序和中序遍历序，计算并输出其后序遍历序。

## 输入

输入第一行为二叉树的个数n，0＜n≤1000，其后n行每行中由两个字符串组成，第一个是二叉树的前序遍历序，第二个是二叉树的中序遍历序，字符串中每个字符表示一个结点，字符串长度不超过2000。

## 输出

对每个二叉树，输出一行后序遍历序。

## 样例输入
2
abc bac
ab ba

## 样例输出
bca
ba



```
#include "bits/stdc++.h"
using namespace std;
typedef struct tree1
{
    char data;
    tree1 *leftchild;
    tree1 *rightchild;
}*Tree1;
void creattree1(Tree1 &T,string s1,string s2)
{
    if(s1.length() == 0)
    {
        T = NULL;
        return;
    }
    char roots  = s1[0];
    int position = s2.find(roots);
    string leftstr2 = s2.substr(0,position);
    string rightstr2 = s2.substr(position+1);

    int lenleft = leftstr2.length();
    int lenright = rightstr2.length();

    string leftstr1 = s1.substr(1,lenleft);
    string rightstr1 = s1.substr(lenleft+1);

    T = (Tree1)malloc(sizeof(tree1));
    if(T != NULL)
    {
        T->data = roots;
        creattree1(T->leftchild,leftstr1,leftstr2);
        creattree1(T->rightchild,rightstr1,rightstr2);
    }
}

void houxubianli(Tree1 &T)
{
    if(T == NULL)
        return;
    houxubianli(T->leftchild);
    houxubianli(T->rightchild);
    cout << T->data;
}

int main()
{
    int n;
    cin >> n;
    while(n--)
    {
        Tree1 T;
        string s1,s2;
        cin >> s1 >> s2;
        creattree1(T,s1,s2);
        houxubianli(T);
        cout <<endl;
    }
    return 0;
}
```

思想是递归，蛮难想的，半抄半写。











