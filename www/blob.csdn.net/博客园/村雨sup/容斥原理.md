# 容斥原理 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





容斥原理是早有耳闻，但是看到模板代码实现时真是被震惊了一下，是谁想出来这么牛逼的写法！

主要想法：从1到2^m-1循环，利用其二进制形式，各位上为1或0，对应数组a[ ]的2^m-1种取法。

```
ll gcd(ll a,ll b)
{
    if(b == 0) return a;
    else return gcd(b,a%b);
}
int a[maxn];
int n,m;
void solve()
{
    ll res = 0;
    for(int i=1;i < (1 << m);i++)
    {
        int num = 0;
        for(int j=i;j != 0;j >>= 1)  //统计二进制形势下各位上 1 的个数
            num += j&1;
        ll lcm = 1;
        for(int j=0;j < m;j++)
        {
            if((i >> j)&1)          //二进制下第 j 位上是否为 1 ，是 1 的话就参与到共同计算最小公倍数中来
            {
                lcm = lcm/gcd(lcm,a[j])*a[j];  
                if(lcm > n) break;
            }
        }
        if(num%2 == 0) res -= n/lcm; //对应容斥加减
        else res += n/lcm;
    }
    cout << res << endl;
}
```

其实你只要把1—n的二进制写出来对照一下，就会惊奇的发现，代码完全符合逻辑！











