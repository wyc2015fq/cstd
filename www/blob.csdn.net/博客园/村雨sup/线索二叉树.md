# 线索二叉树 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





数据结构课好像略过了，现在补一下代码。

```
struct Treenode{
    int val;
    Treenode* left;
    Treenode* right;
    int leftsign;
    int rightsign;
};

class Solution {
public:
    void create(Treenode* p,Treenode* pre){  //线索二叉树建立
        if(p == NULL) return;
        create(p->left,pre);
        if(p->left == NULL){
            p->left = pre;
            p->leftsign = 1;
        }
        if(pre != NULL && pre->right == NULL){
            pre->right = p;
            pre->rightsign = 1;
        }
        pre = p;
        create(p->right,pre);
    }
    
    void createtree(Treenode* head){
        Treenode* pre = NULL;
        if(head != NULL){
            create(head,pre);
            pre->right = NULL; //中序的最后一个节点
            pre->rightsign = 1;
        }
    }

    Treenode* Firstnode(Treenode* p){
        while(p->leftsign == 0) p = p->left;
        return p;
    }
    Treenode* Nextnode(Treenode* p){
        if(p->rightsign == 0) return Firstnode(p->right);  //如果不是线索就找到右节点的最左节点
        else return p->right;   //如果是线索，就返回序列的后继节点
    }
    Treenode* INORDER(Treenode* head){
        for(Treenode* p=Firstnode(head);p!=NULL;p = Nextnode(p))
            cout << p->val << endl;
    }
};
```

——











