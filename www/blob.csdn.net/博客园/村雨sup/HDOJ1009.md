# HDOJ1009 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





```
#include "iostream"
#include "algorithm"
#include "cstdio"
using namespace std;

struct Point
{
    int x;
    int y;
    double z;
};

bool cmp(const Point &a,const Point &b)
{
    return a.z > b.z;
}
int main()
{
    while(1)
    {
        int M;
        int n;

        cin >> M >> n;

        if(M == -1 && n == -1)
            break;
        Point *point = new Point[n];
        for(int i=0;i<n;i++)                    //sort
        {
            cin >> point[i].x >> point[i].y ;
            point[i].z = double(point[i].x)/double(point[i].y);
        }
        sort(point,point+n,cmp);

        double food = 0;
        int i;
        for(i=0;i<n;i++)                   //caculate
        {
            if(M >= point[i].y)
            {
                M = M - point[i].y;
                food = food + point[i].x;
            }

            else
            {
                food = food + double(M) * point[i].x/point[i].y;     //当double与整数相乘(除)就会变成double，完美的解决了精度的问题。遇到精度问题时，一定要把高精度数放在前面。
                break;
            }

        }
        printf("%.3lf\n",food);

    }
    return 0;
}
```

第一：精度问题，要将高精度的放在表达式前面进行优先处理。

第二：反复记忆上述的指针排序法

1.用指针new空间

2.函数传入的指针写法

3.在结构体内部的东西可以用这种方法排序，比较灵活，可以随意的在结构体内部增加或删减元素











