# 特别需要注意！ - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





**1，当发现怎么测试输出总是0时，就要想想是不是同时定义了一个全局和局部变量！**

**2，博客园复制代码有bug啊！！！，有时候会漏掉一部分数字或者代码！！！，气死我了！**

**3，当很简单的题目t了，考虑一下输入是否有错误，比如scanf忘记加~（编译器不会报错！）**

**4，出现runtime error 了，看看memset，二维数组是不能memset的，还看看数组是否越界，还有输入错误也会RE**

**5，使用cin默认读取一个词，当你读取的字符串中有空格的话就要用getline(cin,str)**

**6，最大子段和中，我max定义了-1，没有考虑到max 为负数的情况！**

**7，codeblock中输入字符出错的情况下，clion不会报错而且AC了**

**8，汉诺塔问题的通解 : 次数 = 2 ^ 层数 - 1；**

**9，cmd下哪怕是修改path都不能用pip，是因为我的pycharm（或者python）是从别的电脑拷过来的，很多东西都改变了，所以下东西一定要用安装包！**

**10，pip在cmd下速度太慢？windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下**

```
** [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple**
```

**11，判断过拟合，训练数据的准确率远远高于测试数据的准确率**

**12，过拟合出现的原因：网络太复杂，数据量太小。**

**13，出现“OpenCV(3.4.1) Error: Assertion failed (scn == 3 || scn == 4) in cv::cvtColor, file D:\Build\OpenCV\opencv-3.4.1\modules\imgproc\src\color.cpp, line 11147**

**Traceback (most recent call last):”错误，主要是图片读入问题 or 摄像头链接问题**

**14,以后写题还是要在纸上先列好提纲，不然如果你直接上机，遇到n多个bug的时候，容易迷失自我，去拆东补西的修bug而忽视了整片代码的逻辑的正确性。**

**15,当码完发现输不出不要急，检查是否是各种类型的数组越界。**

**16,Linux 下cd~返回主界面，学会常用 ls 列出可以 cd 的文件夹**

**17,提示permisson 不足用sudo**

**18,sudo dpkg -i 文件路径    文件路径可以直接把刚才下载的软件包拖进终端**

** 19，python3 输入列表：**
**lst = map(int,input().split())**
**lst = list(lst)**
**print(lst)**



**20.windows查看显存占用cd C:\Program Files\NVIDIA Corporation\NVSMI**
**　　　　　　　　　　　　nvidia-smi21. -3/2 = -1 向中间靠拢22.string 转 数字很简单，-‘0’就行，数字转string 要用to_string(),是个比较好的函数，网上用的sprintf之类的都丑哭了。23 https://blog.csdn.net/msdnwolaile/article/details/52708144   vcetor用法24 vector res.insert(res.begin()+下标,num) 是在下标数前插入数。25 在用socket时2.7版本和3.5版本的python不同，3.5的需要encode和decode26 https://blog.csdn.net/weired_cat/article/details/80899102 用load加载模型出现问题27 tensor到numpy的互相转化很重要，以后就要靠这个对图片进行变化28 层序遍历，计算层数for中要用到que.size()29 字符串string几大坑人之处：1. 必须要用char = s[0]才能进行比较和变数字（char - '0'）或者 s[0] - '0' (不算很坑）  2.s == " " (双冒号） s[0] == ' ' (单冒号）****30. hash_map 解析https://blog.csdn.net/city_to_sky/article/details/80042586**
**31.在层次遍历中 坑：int i=0;i < que.size();i++  que.size()会不停改变32.set 用法：http://www.cnblogs.com/caiyishuai/p/8646345.html33.在c++中有两个关联容器，第一种是map，内部是按照key排序的，第二种是unordered_map，容器内部是无序的，使用hash组织内容的。34.lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。**

**   upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。**


** 35.map中元素本身就是从小到大的，内部是基于红黑树，查找nlogn**

**36.在map中，find操作用于查找，如果找不到该key，则返回xxx.end()，并在map中插入该key，默认value是0。**

**37.map排序，要塞到vector中排序：**

```
**　　 map<int,double>::iterator it;    vector<pair<int,double>> vec;    for(it=mp.begin();it!=mp.end();it++){        vec.push_back(make_pair(it->first, it->second));    }**
```

```
**int cmp(const pair<string, int>& x, const pair<string, int>& y)  {      return x.second > y.second;  }  **
```

```
**sort(vec.begin(),vec.end(),combyValue);**
```

** 38.对于map容器还有一点，如果想要反向遍历，可以使用。**

```
**for(auto it=m.rbegin();it!=m.rend();it++)**
```

** 39.stl实现全排列**

```
**#include <iostream>#include <algorithm>using namespace std;int main(){    int num[3]={1,2,3};    do    {        cout<<num[0]<<" "<<num[1]<<" "<<num[2]<<endl;    }while(next_permutation(num,num+3));    return 0;}**
```

**-**

**算法描述：**

**1、从尾部开始往前寻找两个相邻的元素**

**第1个元素i，第2个元素j（从前往后数的），且i<j**

**2、再从尾往前找第一个大于i的元素k。将i、k对调**

**3、[j,last)范围的元素置逆（颠倒排列）**

**40.当提交出现全错的情况说明输出格式错了，比如这题，没有memset char数组是不对的，以后所有数组记得要初始化。**

**41.****vector不能随便开空间，开了以后就会有默认值，然后你再push-back就加到默认的后面了。****vector 循环中出现erase要注意i的位置会向前，从而跳过了删除的后一个项**

****42.getline(cin,str);****











