# nyoj1015——二分图染色 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)






## 二部图

时间限制：1000 ms  |  内存限制：65535 KB

难度：1



- 描述

二部图又叫二分图，我们不是求它的二分图最大匹配，也不是完美匹配，也不是多重匹配，而是证明一个图是不是二部图。证明二部图可以用着色来解决，即我们可以用两种颜色去涂一个图，使的任意相连的两个顶点颜色不相同，切任意两个结点之间最多一条边。为了简化问题，我们每次都从0节点开始涂色


- 输入
输入：
多组数据
第一行一个整数 n(n<=200) 表示 n个节点
第二行一个整数m 表示 条边
随后 m行 两个整数 u , v 表示 一条边- 输出
如果是二部图输出 BICOLORABLE.否则输出 NOT BICOLORABLE.- 样例输入
3
3
0 1
1 2
2 0
3
2
0 1
0 2- 样例输出
NOT BICOLORABLE.
BICOLORABLE.
```
#include <bits/stdc++.h>
using namespace std;
typedef long long  ll;
const int INF = 0x3f3f3f3f;
const int maxn = 205;

int V;
int vis[maxn];
vector<int>v[maxn];

int flag;
void dfs(int x)
{
    for(int i=0;i < v[x].size();i++){
        if(vis[v[x][i]] == vis[x]) flag = 1;
        if(vis[v[x][i]] == -1){
            vis[v[x][i]] = (vis[x]?0:1);
            dfs(v[x][i]);
        }
    }
}




int main()
{
    int m;
    while(~scanf("%d%d",&V,&m)) {
        memset(v,0, sizeof(v));
        for(int i=0;i < V;i++){   //未访问过的标记为-1
            vis[i] = -1;
        }
        vis[0] = 0;
        flag = 0;
        for (int i = 0; i < m; i++) {
            int a, b;
            scanf("%d%d", &a, &b);
            v[a].push_back(b);
            v[b].push_back(a);
        }
        dfs(0);
        if(flag == 1)
            printf("NOT BICOLORABLE.\n");
        else
            printf("BICOLORABLE.\n");
    }

    return 0;
}
```

——一开始漏了~，疯狂T，好气啊.











