# dp练习（11）——石子并归 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)







### **1048 石子归并**







 时间限制: 1 s



 空间限制: 128000 KB



 题目等级 : 黄金 Gold




[题解](http://codevs.cn/wiki/solution/?problem_id=1048)












题目描述 Description


有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小。




输入描述 Input Description


第一行一个整数n（n<=100）

第二行n个整数w1,w2...wn  (wi <= 100)




输出描述 Output Description


一个整数表示最小合并代价




样例输入 Sample Input


4

4 1 1 4




样例输出 Sample Output


18




数据范围及提示 Data Size & Hint

 我已经接受了自己的菜了，反正我就是那种题海战术后才会理解一点的那种弱智。

```
#include<bits/stdc++.h>
using namespace std;

const int INF =0x3f3f3f3f;
int SUM[1005][1005];
int dp[1005][1005];

int main()
{
    int n;
    cin >> n;
    int a[n];
    for(int i=1;i <= n;i++)
    {
        cin >> a[i];
    }
    memset(SUM,0, sizeof(SUM));
    for(int i=1;i <= n;i++)
    {
        SUM[i][i] = a[i];
        for(int j=i+1;j <= n;j++)
        {
            SUM[i][j] = SUM[i][j-1] + a[j];
        }
    }

    for(int len=2;len <= n;len++)
    {
        for(int i=1;i <= n-len+1;i++)
        {
            int j = i+len-1;      //这里不懂
            dp[i][j] = INF;
            for(int k=i;k <= j;k++)
            {
                dp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] + SUM[i][j]);
            }
        }
    }
    cout << dp[1][n] << endl;



    return 0;
}
```

多写几遍就好了咯，脑子笨















