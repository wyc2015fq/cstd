# 相邻的数互质 - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)






## 最大的最小公倍数

时间限制：1000 ms  |  内存限制：32768 KB

难度：2



- 描述

　　高中时我们对最小公倍数就已经很熟悉了，相信你很快就可以把这个问题解决。这次的问题是：给你一个正整数n，任取三个不大于n的正整数，取法不限，每个数可取多次，使得取到的这三个数的最小公倍数在所有取法中是最大的。

　　例如当n = 5 时，不大于5的数为1、2、3、4、5。则应该选3、4、5三个数，它们的最小公倍数是60，在所有取法中是最大的。因此我们得到结果60。

　　是不是很简单？抓紧时间 AC 吧。


- 输入
　　输入包含多组测试数据。每组数据为一个正整数n（1≤n≤10^6）。- 输出
　　对每组测试数据，输出一个整数，代表所有可能取法中，选出的三个数的最小公倍数的最大值。- 样例输入
5
7- 样例输出
60
210- 来源
[蓝桥杯](http://acm.nyist.edu.cn/JudgeOnline/search_result.php?source=%E8%93%9D%E6%A1%A5%E6%9D%AF)
```
#include <bits/stdc++.h>
using namespace std;
typedef long long  ll;
const int INF = 0x3f3f3f3f;
const int moder = 10000;
const int maxn = 2000000;



int main()
{
    ll n;
    while(cin >> n)
    {
        if(n == 1)printf("1\n");
        else if(n == 2)printf("2\n");
        else if(n%2 != 0) printf("%lld\n",n*(n-1)*(n-2));
        else if(n%3 == 0) printf("%lld\n",(n-1)*(n-2)*(n-3));
        else printf("%lld\n",n*(n-1)*(n-3));
    }

    return 0;
}
```

首先：大于1的两个相邻的自然数必定互质。
       如果n是奇数，那么 n、n-1、n-2必定两两互质。n是奇数，那么n，n-1，n-2一定是两奇加一偶的情况。

       假设剩下的n,n-2中有一个数能被3整除，那么有公因子的数一定是n或n-2加减3才能得到的情况。
       如果n是偶数，分析n*(n-1)*(n-2)，这样的话n和n-2必定有公因子2，看看n*(n-1)*(n-3)。此时若偶数本身就能被3整除的话，那么式子n*(n-1)*(n-3)也不成立了，n和n-3就有公因子3，故如果n%3==0的话式子就变成了(n-1)*(n-2)*(n-3)，两奇夹一偶的情况。











