# 二叉树遍历（二） - 村雨sup - 博客园








[博客园](https://www.cnblogs.com/)[首页](https://www.cnblogs.com/cunyusup/)[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)[联系](https://msg.cnblogs.com/send/%E6%9D%91%E9%9B%A8sup)[管理](https://i.cnblogs.com/)[订阅](https://www.cnblogs.com/cunyusup/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





## 问题 A: 数据结构作业04 -- 二叉树的输入
时间限制: 1 Sec  内存限制: 128 MB
提交: 1904  解决: 593
[[提交](http://202.4.155.100/JudgeOnline/submitpage.php?cid=1296&pid=0&langmask=0)][[状态](http://202.4.155.100/JudgeOnline/problemstatus.php?id=1119)][[讨论版](http://202.4.155.100/JudgeOnline/bbs.php?pid=1119&cid=1296)]
## 题目描述


用二叉树的带虚结点表示的前序遍历序可以唯一的确定一棵二叉树。


## 输入


每行是一棵二叉树的带虚结点（#）表示的前序遍历序串，长度不超过2000。每个结点为一个小写字母或一个数字。


## 输出


对每行输入，输出对应二叉树的中序遍历序（不含虚结点）、后序遍历序（不含虚结点）和层次遍历序（不含虚结点）。 每棵二叉树的输出占一行，中序遍历序、后序遍历序和层次遍历序之间用一个空格隔开。


## 样例输入
ab##c##
#
ab###

## 样例输出
bac bca abc
  
ba ba ab
## 提示




Sample Input的第二行表示一棵空树，因此输出时输出两个空格。


```
#include "bits/stdc++.h"
using namespace std;
struct Binode
{
    char data;
    Binode *lchild,*rchild;
};

typedef Binode *Bitree;
Bitree T1;

int InitBiTree(Bitree &T)
{
    T = NULL;
    return 0;
}


// 用带虚结点的前序遍历串str（每个字符对应一个结点）构造二叉树T，并返回剩余字符串
char *CreateBiTree(Bitree &T, char *str)
{
// 约定#表示空结点
    if (*str == '#')
    {
        T = NULL;
        return str + 1;
    }

// 创建结点
    T = new Binode;
    T->data = *str;

// 继续输入并构造左子树和右子树
    str = CreateBiTree(T->lchild, str + 1);
    str = CreateBiTree(T->rchild, str);

// 返回剩余的字符串
    return str;
}
int InTraverse(Bitree T)
{
    if (T == NULL) return 0;
    InTraverse(T->lchild);
    cout << T->data ;
    InTraverse(T->rchild);
    return 0;
}

int SucTraverse(Bitree T)
{
    if (T == NULL) return 0;
    SucTraverse(T->lchild);
    SucTraverse(T->rchild);
    cout << T->data ;
    return 0;
}
queue<Bitree>a;
int cengci(Bitree T)
{
    if(T == NULL) return 0;
    a.push(T);
    while(!a.empty())
    {
        cout << a.front()->data;

        if(a.front()->lchild != NULL)
            a.push(a.front()->lchild);
        if(a.front()->rchild != NULL)
            a.push(a.front()->rchild);
        a.pop();

    }
    return 0;
}

int main()
{
    char s[3000];
    char *str1;
    while(cin >> s)
    {
        str1 = s;
        InitBiTree(T1);
        CreateBiTree(T1,str1);
        InTraverse(T1);
        cout << " ";
        SucTraverse(T1);
        cout << " ";
        cengci(T1);
        cout << endl;
    }

    return 0;
}
```

哈哈哈哈，层次遍历被我想出来啦啦啦阿拉啦啦啦啦啦啦啦啦











