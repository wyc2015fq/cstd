# 算法导论之贪心算法 - best_na20170322 - 博客园




- [博客园](https://www.cnblogs.com/)
- [首页](https://www.cnblogs.com/believe-in-me/)
- [新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
- [联系](https://msg.cnblogs.com/send/best_na20170322)
- [管理](https://i.cnblogs.com/)
- [订阅](https://www.cnblogs.com/believe-in-me/rss)![订阅](https://www.cnblogs.com/images/xml.gif)





# [算法导论之贪心算法](https://www.cnblogs.com/believe-in-me/p/6612776.html)





参考：http://www.cnblogs.com/Creator/archive/2011/06/07/2074227.html

 贪心算法在几个基本算法里面算是相对简单的算法了，思路也是非常简单的，每一步总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。基本思路就是从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。

贪心算法存在的问题是：

1. 不能保证求得的最后解是最佳的；
2. 不能用来求最大或最小解问题；
3. 只能求满足某些约束条件的可行解的范围

上述的这些问题可以在[动态规划](http://www.cnblogs.com/Creator/archive/2011/05/17/2048302.html) ，[回溯算法](http://www.cnblogs.com/Creator/archive/2011/05/20/2052341.html) ，[分支限界算法](http://www.cnblogs.com/Creator/archive/2011/05/21/2053033.html) 里面得到相应的解决，但是我们也不会因此放弃对贪心算法的使用。这正是敏捷开发所提倡的,永远没有最好的，只有最适合的.我们选用贪心算法的原因就是因为他能够满足当前的需要并且比其他算法更加简单。

下面请看示例题：

有N个商品,每个商品的重量为WI,价格为:PI,现有一个背包，最多能装Ｍ的重量．其中(0<=I<N,0<wi<M).

问：怎样装能使包中装入的商品价值最高（对于每个商品可以只装该商品的一部分）

伪代码：

参数分别为 n:物品数   M：背包最多能装的重量   v[]：价值数组   w[]重量数组

void Knapsack(int n,float M,float v[],float w[],float x[])

{

Sort(n,v,w);     //进行排序

int i;

for (i = 1 ; i <= n ; i++)

x[i] = 0;

     float c=M;    //C为背包剩余空间

    for (i=1;i<=n;i++) {

   if (w[i] > c) break;

       x[i]=1;   //选取第i个物品

      c-=w[i];    //剩余重量减少

   }

if (i <= n)  //当此时背包的容量不够存放整个物品的情况时，存放一部分

    x[i]=c / w[i];

}

具体代码如下：
`![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)View Code`
 算法knapsack的主要计算时间在于将各种物品依其单位重量的价值从大到小排序。若不计较排序的是时间，单单贪心策略的算法复杂度只有O(n),上面的这个例子使用了O(n*n)的排序算法，这里只是为了简单而已，实际上我们可以选择合适的排序算法将排序部分的复杂度降到O(nlgn)..如堆排序，快速排序等等

这里我没有记录完整的例子完全是因为这个算法太好理解了 ，贪心算法一般在开始策略选择前会进行排序，排好序后就进行最优化选择，这和我们生活中找钱的规律是一样的，如我需要找87块钱给顾客，我会怎么做，首先我们知道10〉5>1这个排序，然后更具我们的经验，我们出具8张10块（最大化贪心原则）然后出具 一张5块，最后出具两张一块.当然你也可以说，我全部给一块或者给不给10块只给5块和1块，但是，那不是最简便的方法，细心一下，生活中处处是算法














