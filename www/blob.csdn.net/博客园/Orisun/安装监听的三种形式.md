# 安装监听的三种形式 - Orisun - 博客园







# [安装监听的三种形式](https://www.cnblogs.com/zhangchaoyang/articles/1796820.html)





Button是事件源，当Click事件发生后Button把事件丢给监听器来处理。

**方法一**

下面的代码是最易懂，最直白的表示方法：



```
1 package zcy.app;
 2 
 3  import android.app.Activity;
 4  import android.os.Bundle;
 5  import android.view.View;
 6  import android.widget.Button;
 7 
 8  public class MyEvent extends Activity {
 9     private Button bt;
10     /** Called when the activity is first created. */
11     @Override
12     public void onCreate(Bundle savedInstanceState) {
13         super.onCreate(savedInstanceState);
14         bt=new Button(this);
15         setContentView(bt);
16         bt.setText("按我");
17         MyListener ml=new MyListener();
18         bt.setOnClickListener(ml);
19     }
20 }
21  class MyListener implements Button.OnClickListener{
22 
23     @Override
24     public void onClick(View v) {
25         // TODO Auto-generated method stub
26          Button b=(Button)v;
27         b.setText("事件已触发");
28     }
29     
30 }
```




我们自定义了一个类MyListener实现了Button.OnClickListener接口（因为重写了接口中的onClick方法），然后创建了一个MyListener实例ml，最后在按钮bt上安装ml监听器（也就是bt.setOnClickListener(ml)这句话）。



实际上从面向对象的角度上讲，接口和类没有什么本质的不同。

Interface A{//....}

Interface B extends A{//....}　　接口B继承了接口A

class C imlements A{//....}　　　类C继承了接口A（在C++和C#中就是这么叫，从面向对象的思想上去理解我觉得这样更准确些）

两个“继承”有什么区别呢？使用extends，B不用实现A中的抽象方法，相反B中可以添加更多的抽象方法。使用implements，C就必须把A中的抽象方法全部实现。那我们C理解成继承了A有什么好处呢？在第三种方法中你会看到。

此外可能你对26行感到有点新奇，让我们来看一下View.OnClickListener中的onClick方法是如何定义的：

#### public abstract void onClick([View](file:///D:/AndndroidSDK_2.2/docs/reference/android/view/View.html) v)



Called when a view has been clicked.



##### Parameters
vThe view that was clicked.




**方法二**



```
1 package zcy.app;
 2 
 3  import android.app.Activity;
 4  import android.os.Bundle;
 5  import android.view.View;
 6  import android.widget.Button;
 7 
 8  public class MyEvent extends Activity {
 9     private Button bt;
10     /** Called when the activity is first created. */
11     @Override
12     public void onCreate(Bundle savedInstanceState) {
13         super.onCreate(savedInstanceState);
14         bt=new Button(this);
15         bt.setText("按我");
16         bt.setOnClickListener(new Button.OnClickListener(){
17 
18             @Override
19             public void onClick(View v) {
20                 // TODO Auto-generated method stub
21                  bt.setText("事件已触发");
22             }
23             
24         });  
25         setContentView(bt);
26     }
27 }
```








在方法一中，我们可以说ml是MyListener类型的一个实例，也可以说ml是OnClickListener类型的一个实例（因为MyListener继承了OnClickListener嘛）。而在方法二中我们直接创建了一个匿名的OnClickListener实例。



方法二代码中的

Button.OnClickListener(){
　　@Override
publicvoid onClick(View v) {
　　// TODO Auto-generated method stub
bt.setText("事件已触发");
}

相当于方法一中的

class MyListener implements Button.OnClickListener{
　　@Override
publicvoid onClick(View v) {
　　　　// TODO Auto-generated method stub
　　　　Button b=(Button)v;
b.setText("事件已触发");

　　}
}

前面再加个new，就相当于方法一中ml。

**方法三**



```
1 package zcy.app;
 2 
 3 import android.app.Activity;
 4 import android.os.Bundle;
 5 import android.view.View;
 6 import android.view.View.OnClickListener;
 7 import android.widget.Button;
 8 
 9 public class MyEvent extends Activity implements OnClickListener {
10     private Button bt;
11     /** Called when the activity is first created. */
12     @Override
13     public void onCreate(Bundle savedInstanceState) {
14         super.onCreate(savedInstanceState);
15         bt=new Button(this);
16         setContentView(bt);
17         bt.setText("按我");
18         bt.setOnClickListener(this);
19     }
20     @Override
21     public void onClick(View v) {
22         // TODO Auto-generated method stub
23         bt.setText("事件已触发");
24     }
25 }
```




这个方法有点奇怪，我们已经知道setOnClickListener()中的参数应该是个OnClickListener的实例，那18行的“this"是OnClickListener的一个实例吗？是的！应为this是MyEvent的一个实例，而MyEvent又继承了OnClickListener，也就是说MyEvent是OnClickListener的一个子类，那this自然也是OnClickListener的一个实例。














