# 分治 - Orisun - 博客园







# [分治](https://www.cnblogs.com/zhangchaoyang/articles/2675375.html)





分（divide）：递归解决较小的问题

治（conquer）：从子问题的解构建原问题的解

一般认为正文中至少含有两个递归调用才叫分治，只包含一个递归的不叫分治。一般认为子问题是不相交的。

方程![](http://www.forkosh.com/mathtex.cgi?T(N)=aT(N/b)+\Theta(N^k))的解为：

![](https://pic002.cnblogs.com/images/2012/103496/2012090717424954.png)

### 整数相乘

求两个N位数X和Y的乘积，手算需要进行![](http://www.forkosh.com/mathtex.cgi?N^2)次乘法，即把两个个位数相乘看作基本操作的话，算法复杂度为![](http://www.forkosh.com/mathtex.cgi?O(N^2))。X=12345678，Y=87654321，求XY。XL=1234，XR=5678，YL=8765，YR=4321。X=XL104+XR，Y=YL104+YR

所以：

![](http://www.forkosh.com/mathtex.cgi?XY=X_LY_L10^8+(X_LY_R+X_RY_L)10^4+X_RY_R)

需要进行4次4位数的乘法![](http://www.forkosh.com/mathtex.cgi?4T(N/2))，乘以108只是一些补0操作，再加上几次加法构成了![](http://www.forkosh.com/mathtex.cgi?O(N))。

![](http://www.forkosh.com/mathtex.cgi?T(N)=4T(N/2)+O(N))

由（1）式得![](http://www.forkosh.com/mathtex.cgi?T(N)=O(N^2))，此时算法没有得到改进。

注意到![](http://www.forkosh.com/mathtex.cgi?X_LY_R+X_RY_L=(X_L-X_R)(Y_R-Y_L)+X_LY_L+X_RY_R)，所以在计算出![](http://www.forkosh.com/mathtex.cgi?X_LY_L\%20X_RY_R)后，只需要再进行一次乘法就能计算出![](http://www.forkosh.com/mathtex.cgi?X_LY_R+X_RY_L)。

![](http://www.forkosh.com/mathtex.cgi?T(N)=3T(N/2)+O(N))

![](http://www.forkosh.com/mathtex.cgi?T(N)=O(N^{log_2{3}})=O(N^{1.59}))

当两个数都是1位时可以通过查表进行乘法。

实际上上述方法在实际中很少用，对于小的N开销大，对于大的N还存在更好的一些算法，它们也广泛利用了分治算法。

### 矩阵乘法

![](https://pic002.cnblogs.com/images/2012/103496/2012090718495816.png)

![](http://www.forkosh.com/mathtex.cgi?\parstyle\begin{eqnarray*}C_{11}=A_{11}B_{11}+A_{12}B_{21}\\C_{12}=A_{11}B_{12}+A_{12}B_{22}\\C_{21}=A_{21}B_{11}+A_{22}B_{21}\\C_{22}=A_{21}B_{12}+A_{22}B_{22}\end{eqnarray*})

一个N×N的矩阵乘法变成了8个N/2×N/2的矩阵乘法和4个N/2×N/2的矩阵加法，加法的复杂度为![](http://www.forkosh.com/mathtex.cgi?O(N^2))。

![](http://www.forkosh.com/mathtex.cgi?T(N)=8T(N/2)+O(N^2))

由（1）式得![](http://www.forkosh.com/mathtex.cgi?T(N)=O(N^3))

看来矩阵分块后再进行乘积并没带来复杂度的降低。

Strassen使用了类似于整数乘法的分治策略。

　　计算7个N/2×N/2阶矩阵的乘法
![\mathbf{M}_{1} := (\mathbf{A}_{1,1} + \mathbf{A}_{2,2}) (\mathbf{B}_{1,1} + \mathbf{B}_{2,2})](http://upload.wikimedia.org/math/6/2/9/6291151f280c5389e1697feb0ac8daa4.png)![\mathbf{M}_{2} := (\mathbf{A}_{2,1} + \mathbf{A}_{2,2}) \mathbf{B}_{1,1}](http://upload.wikimedia.org/math/b/f/5/bf5998b9cf7b30b2fbf2b4314b778746.png)![\mathbf{M}_{3} := \mathbf{A}_{1,1} (\mathbf{B}_{1,2} - \mathbf{B}_{2,2})](http://upload.wikimedia.org/math/0/a/0/0a0c681167a2d5d4f1443f650f438dc1.png)![\mathbf{M}_{4} := \mathbf{A}_{2,2} (\mathbf{B}_{2,1} - \mathbf{B}_{1,1})](http://upload.wikimedia.org/math/3/c/2/3c2bfd7643b3ec7c957436b50ae90abf.png)![\mathbf{M}_{5} := (\mathbf{A}_{1,1} + \mathbf{A}_{1,2}) \mathbf{B}_{2,2}](http://upload.wikimedia.org/math/6/9/9/699239b6e4824f002a6d482c6e85e559.png)![\mathbf{M}_{6} := (\mathbf{A}_{2,1} - \mathbf{A}_{1,1}) (\mathbf{B}_{1,1} + \mathbf{B}_{1,2})](http://upload.wikimedia.org/math/e/d/d/eddd30cb38b3ca847d1064cdea4226a1.png)![\mathbf{M}_{7} := (\mathbf{A}_{1,2} - \mathbf{A}_{2,2}) (\mathbf{B}_{2,1} + \mathbf{B}_{2,2})](http://upload.wikimedia.org/math/d/5/7/d5743d03a7d9bb7433b178db2ef5f137.png)然后![\mathbf{C}_{1,1} = \mathbf{M}_{1} + \mathbf{M}_{4} - \mathbf{M}_{5} + \mathbf{M}_{7}](http://upload.wikimedia.org/math/0/3/5/035520f6f1c9f5508fcfe7842ec91d52.png)![\mathbf{C}_{1,2} = \mathbf{M}_{3} + \mathbf{M}_{5}](http://upload.wikimedia.org/math/b/6/b/b6b7763d4dc487154322b5591db09308.png)![\mathbf{C}_{2,1} = \mathbf{M}_{2} + \mathbf{M}_{4}](http://upload.wikimedia.org/math/c/4/2/c42027916e1580ba68b2609c08d0bf26.png)![\mathbf{C}_{2,2} = \mathbf{M}_{1} - \mathbf{M}_{2} + \mathbf{M}_{3} + \mathbf{M}_{6}](http://upload.wikimedia.org/math/7/2/2/72259f5604860cf044231c94371d7796.png)
**![](http://www.forkosh.com/mathtex.cgi?T(N)=7T(N/2)+O(N^2))**

由（1）式得![](http://www.forkosh.com/mathtex.cgi?T(N)=O(N^{log_2{7}})=O(N^{2.81}))

当然要考虑N不是2的整次幂的情况。在N不是很大时Strassen算法不如矩阵直接相乘，它也不能推广到稀疏矩阵，而且不易并行化。当用浮点项运算时，在数值上不如经典算法稳定。算法稳定性是指：舍入误差在算法计算过程中是可控的。














