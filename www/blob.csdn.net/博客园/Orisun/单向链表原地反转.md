# 单向链表原地反转 - Orisun - 博客园







# [单向链表原地反转](https://www.cnblogs.com/zhangchaoyang/articles/2543359.html)





如果不要求“原地”，正向遍历原链表，头插法建立一个新的单向链表，它就是原链表的逆序。

下面利用递归的方法将单向链表原地逆序。

```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct node{
    int data;
    struct node *next;
}NODE;

void insert(NODE **head,NODE *node){
    if((*head)==NULL){
        *head=node;
        (*head)->next=NULL;
    }else{
        //头插法
        node->next=(*head);
        (*head)=node;
    }
}

//利用递归反转链表
NODE* reverse(NODE *first,NODE *second){
    if(second==NULL)
        return first;
    NODE *third=second->next;
    second->next=first;
    return reverse(second,third);
}

int main(int argc,char *argv[]){
    fprintf(stdout,"Input elements by order.Input negative to exit.\n");
    int ele=0;
    NODE *head=NULL;
    //根据用户的输入头插法建立单向链表
    while(1){
        scanf("%d",&ele);
        if(ele<0)
            break;
        NODE *node=(NODE*)malloc(sizeof(NODE));
        memset(node,0x00,sizeof(NODE));
        node->data=ele;
        node->next=NULL;
        insert(&head,node);
    }
    printf("The original link is: ");
    NODE *curr=head;
    while(curr!=NULL){
        printf("%d  ",curr->data);
        curr=curr->next;
    }
    printf("\n");
    if(head!=NULL){
        NODE *second=head->next;
        head->next=NULL;
        NODE *newhead=reverse(head,second);
        printf("The inversed link is: ");
        curr=newhead;
        while(curr!=NULL){
            printf("%d  ",curr->data);
            curr=curr->next;
        }
        printf("\n");
    }
    return 0;
}
```

可以很容易地把递归改写成非递归的形式。

NODE* inverse(NODE *head){
	if(head==NULL)
		return;
	NODE *first=head;
	NODE *second=head->next;
	first->next=NULL;
	while(second!=NULL){
		NODE *third=second->next;
		second->next=first;
		first=second;
		second=third;
	}
	return first;
}















