# numpy数组运算 - Orisun - 博客园







# [numpy数组运算](https://www.cnblogs.com/zhangchaoyang/articles/7040161.html)





#### 加、减、乘、除、指数运算、求倒数、取相反数、位运算   等各种运算都是在各个元素上分别进行的

加法

>>> a=numpy.array([2,4,5])
>>> b=numpy.array([1,1,1])
>>> a+b
array([3, 5, 6])

乘法

>>> a*b
array([2, 4, 5])

倒数

>>> 1./a
array([ 0.5 ,  0.25,  0.2 ])

相反数

>>> -a
array([-2, -4, -5])

平方 

>>> a**2
array([ 4, 16, 25])

按位异或

>>> a^2
array([0, 6, 7])

指数运算

>>> numpy.exp(a)
array([   7.3890561 ,   54.59815003,  148.4131591 ])

#### 真正的矩阵乘法需要用numpy.dot(A,B) 

```
>>> a=numpy.array([2,4,5])
>>> b=numpy.array([[1],[1],[1]])
>>> c=numpy.dot(a,b)
>>> c 
array([11])
```

#### 两个数据维度不一致时，低维数据会自动进行维度的扩充

```
>>> x=numpy.array([1,1,1])
>>> w=numpy.array([[1,2,3],[4,5,6]])
>>> z=w*x 
>>> z 
array([[1, 2, 3],
       [4, 5, 6]])
```

我们说numpy中的*表示矩阵相应位置上的元素分别相乘，可上例中w中2维的，而x才是1维。x的维度低，此时x会在第2个维度上自动扩充（即拷贝第一行的元素到第二行）。这等价于：

```
>>> x=numpy.array([[1,1,1],[1,1,1]])
>>> w=numpy.array([[1,2,3],[4,5,6]])
>>> z=w*x
>>> z 
array([[1, 2, 3],
       [4, 5, 6]])
```

同样，加法运算低维的数据也会自动向高维以复制的方式进行扩充。

```
>>> a=numpy.array([2,3])
>>> b=1+a 
>>> b 
array([3, 4])
```

#### 智能选择维度进行扩充

```
>>> a=np.array([[1.,2.],[3.,4.],[5.,6.]])
>>> b=np.array([1.,2.])
>>> a/b 
array([[ 1.,  1.],
       [ 3.,  2.],
       [ 5.,  3.]])
>>> b=np.array([[1.,2.]])
>>> a/b 
array([[ 1.,  1.],
       [ 3.,  2.],
       [ 5.,  3.]])
>>> b=np.array([[1.],[2.],[3.]])
>>> a/b 
array([[ 1.        ,  2.        ],
       [ 1.5       ,  2.        ],
       [ 1.66666667,  2.        ]])
```

我们看到，a是3*2的矩阵，numpy.ndarray的“/”操作是对应位置上的元素分别进行除操作。当b是1*2的矩阵时，b为了跟a对齐它会自动在axis=1的方向上进行扩充；当b是3*1的矩阵时，b为了跟a对齐它会自动在axis=0的方向上进行扩充

#### 外积

```
>>> a=np.array([[1,2,3],[4,5,6]])
>>> b=np.array([1,2])
>>> np.outer(b,a)
array([[ 1,  2,  3,  4,  5,  6],
       [ 2,  4,  6,  8, 10, 12]])
>>> b=np.array([[1],[2]])
>>> np.outer(b,a)
array([[ 1,  2,  3,  4,  5,  6],
       [ 2,  4,  6,  8, 10, 12]])
```

外积运算与两个矩阵的shape无关，只与两个矩阵中元素的多少有关。

c=np.outer(b,a)

b中有m个元素，a中有n个元素，则c的shape为(m,n)，$c_{ij}=b中的第i个元素*a中的第j个元素$

#### 一维数组与二维数组

```
>>> a=np.array([1,2,3])
>>> b=np.array([[1,2,3]])
>>> list(a)
[1, 2, 3]
>>> list(b)
[array([1, 2, 3])]
>>> a.shape 
(3,)
>>> b.shape 
(1, 3)
>>> a.T 
array([1, 2, 3])
>>> b.T 
array([[1],
       [2],
       [3]])
```

a是一维数组，b是二维数组。a比较特殊：a的转置还是它本身，而且a.shape在第2维上没有值。

最后来一个综合练习，自己一步一步体会：

$$y=\frac{1}{1+e^{-W*X^T}}$$

```
>>> x=numpy.array([[1,2,3],[4,5,6],[7,8,9]])
>>> w=numpy.array([0.3,0.8,1.2])
>>> y=1.0/(1.0+numpy.exp(-w*x.T))
>>> y
***array([[ 0.57444252,  0.96083428,  0.99977518],******[ 0.64565631,  0.98201379,  0.99993228],******[ 0.7109495 ,  0.99183743,  0.9999796 ]])***
```

##  shape

注意一维数组和只有一行的二维数组的区别

>>> b=np.array([3,6])
>>> d=np.array([[3,6]])
>>> b.shape
(2,)
>>> d.shape
(1, 2)
>>> b[1]
6
>>> d[0,1]
6


一维数组转置后其shape不变

>>> b.T.shape
(2,)
>>> d.T.shape
(2, 1)


**通过切片取二维数组的第i行时，x[i]和x[i,:]是等价的，得到的都是一个一维数组，而x[i:i+1,:]得到的是只有一行的二维数组**

>>> a=np.array([[2,4],[5,7]])
>>> a[0]
array([2, 4])
>>> a[0,:]
array([2, 4])
>>> a[0:1,:]
array([[2, 4]])


np.sun(ndarray)函数不指定axis参数时是对数组中的所有元素求总和；指定axis参数时可以按行/按列求和，求和的结果相比于原数组降低了一个维度。

>>> np.sum(a)
18
>>> np.sum(a,axis=0)
array([ 7, 11])
>>> np.sum(a,axis=1)
array([ 6, 12])















