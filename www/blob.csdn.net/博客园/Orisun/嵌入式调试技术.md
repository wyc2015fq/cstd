# 嵌入式调试技术 - Orisun - 博客园







# [嵌入式调试技术](https://www.cnblogs.com/zhangchaoyang/articles/1935355.html)







嵌入式调试方法：

1.模拟器。比如Qtopia Core可以用奇趣提供的Frame Buffer模拟工具qvfb，ARM硬件模拟可以用SkyEye开源项目。

2.远程调试。调试器还在PC上，调试器与被调试的程序通过网络通信。

3.通过LOG和Core Dump等文件事后分析。



stdprm标准打印机LPT1端口

stdaux标准串行设备COM1端口

stdin并不一定来自键盘，stdout和stderr也并不一定显示在屏幕上，可以将它们重定向到其他设备或磁盘文件上。

使用fprintf()时，第一参数推荐使用stderr而不要使用stdout，因为stderr的运行级要高一些，程序在异常退出时stderr可以输出，而stdout就不行。

![](https://pic002.cnblogs.com/images/2011/103496/2011011411473341.png)



cmd >file把stdout重定向到file中

cmd >>file把stdout追加到file中

cmd 2>>file 1>&2把stderr追加到file中，再把stdout追加到stderr中





在C程序中通过freopen（）进行重定向

FILE *freopen(const char *filename,const char mode,FILE *stream)

比如freopen("err.log","w",stderr)就把stderr重定向到err.log文件了



**控制log的级别**



比如QT中提供qDebug(),qWarning()，GTK中也有相应的g_debug(),g_error(),内核调试的printk()也提供很多级别。

在编译时利用QT提供的宏QT_NO_DEBUG_output就可以将qDebug("var=%d\n",var)去掉了，下次需要时还可以通过重新编译找回来。



#include<stdio.h>

#ifndef LOGLEVEL_H
#define LOGLEVEL_H

#ifndef LOG_LEVEL_CRITICAL
#define LOG_LEVEL_CRITICAL 0
#endif

#ifndef LOG_LEVEL_ERROR
#define LOG_LEVEL_ERROR 1
#endif

#ifndef LOG_LEVEL_DEBUG
#define LOG_LEVEL_DEBUG 2
#endif

#define DEFAULT_LOG_LEVEL LOG_LEVEL_CRITICAL

#ifndef LOG_LEVEL
#define LOG_LEVEL LOG_LEVEL_DEFAULT
#endif

#define _print_log(fmt,arg...)	\
	do{	\
		fprintf(stderr,"%s:%d\t"fmt"\n",__FILE__,__LINE__,##arg);	\
	}while(0)	\
	
#if(LOG_LEVEL_CRITICAL<=LOG_LEVEL)
	#define log_critical(fmt,arg...)	_print_log(fmt,##arg)
#else
	#define log_critical(fmt,arg...)	do{}while(0)
#endif

#if(LOG_LEVEL_ERROR<=LOG_LEVEL)
	#define log_error(fmt,arg...)	_print_log(fmt,##arg)
#else
	#define log_error(fmt,arg...)	do{}while(0)
#endif

#if(LOG_LEVEL_DEGUB<=LOG_LEVEL)
	#define log_debug(fmt,arg...)	_print_log(fmt,##arg)
#else
	#define log_debug(fmt,arg...)	do{}while(0)
#endif

#endif






注意上面代码中用到了一个gcc提供的可变参数的方法。

#define _print_log(fmt,arg...)	\
	do{	\
		fprintf(stderr,"%s:%d\t"fmt"\n",__FILE__,__LINE__,##arg);	\
	}while(0)	\C99支持的可变参数宏如下：#define _print_log(fmt, ...)　　do{
　　　　　fprintf(stderr, "%s:%d\t"fmt"\n", __FILE__,__LINE__,__VA__ARGS__);
　　}while(0)
之所以用do{}while(0)的格式来定义函数宏，这是考虑到宏的嵌套使用等一些情况。





#include "loglvl.h"

int main()
{
	log_debug("This is a debug log.");
	log_error("This is a error log.");
	log_critical("This is a critical log.");
	return 0;
}


orisun@zcypc:~/Docs$ gcc testlvl.c -o testlvl

orisun@zcypc:~/Docs$ ./testlvl

testlvl.c:7This is a critical log.




orisun@zcypc:~/Docs$ gcc testlvl.c -o testlvl -DLOG_LEVEL=2

orisun@zcypc:~/Docs$ ./testlvl

testlvl.c:5This is a debug log.

testlvl.c:6This is a error log.

testlvl.c:7This is a critical log.


















