# 0-1背包 - xcw0754 - 博客园
# [0-1背包](https://www.cnblogs.com/xcw0754/p/4229084.html)
01背包（ZeroOnePack）: 有N件物品和一个容量为V的背包， 每种物品均**只有一件。**第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 
完全背包(CompletePack): 有N种物品和一个容量为V的背包，每种物品都有**无限件**可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 
多重背包(MultiplePack): 有N种物品和一个容量为V的背包，第i种物品**最多有n[i]件**可用。每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 
比较三个题目，会发现不同点在于每种背包的数量，01背包是每种只有一件，完全背包是每种无限件，而多重背包是每种有限件。 
先来分析**01****背包**： 
01背包（ZeroOnePack）: 有N件物品和一个容量为V的背包，每种物品均只有一件。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 
用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： 
> f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}   
把这个过程理解下：
在前i件物品放进容量v的背包时，它有两种情况：
> 
情况一: 第i件不放进去，这时所得价值为:f[i-1][v]　　（即同样的背包空间，不放第i件）
情况二: 第i件放进去，这时所得价值为：f[i-1][v-c[i]]+w[i]   （即背包先放下第i件，看剩多少空间，再来看看还可以放第1~i-1中的哪几件东西）
（第二种是什么意思？就是如果第i件放进去，那么在容量v-c[i]里就要放进前i-1件物品） 
最后比较第一种与第二种所得价值的大小，哪种相对大，f[i][v]的值就是哪种。  （这里是重点，理解！） 
 例子：
|物品号i|1|2|3|4|5|6|
|----|----|----|----|----|----|----|
|体积C|2|3|1|4|6|5|
|价值W|5|6|5|1|19|7|
假如背包能装的体积上限为10，求包中能装入的最大价值？
解：
||1|2|3|4|5|6|7|8|9|10|
|----|----|----|----|----|----|----|----|----|----|----|
|1|0|5|5|5|5|5|5|5|5|5|
|2|0|5|6|6|11|11|11|11|11|11|
|3|5|5|10|11|11|16|16|16|16|16|
|4|5|5|10|11|11|16|16|16|16|17|
|5|5|5|10|11|11|19|24|24|29|30|
|6|5|5|10|11|11|19|24|24|29|30|

第一行表示：当前可挑选的是前 i 件
第一列表示：当前背包的空间为V
步骤：这个表的得出顺序是，第一行从左到右，第二行从左到右....。（因为用的是二维数组，所以这里从右到左也行；若用一维数组，则要从左到右了，且依次下一行覆盖上一行）
举例：以f[5][10]为例
　　　它是这样得到的， f[5][10] = max{f[4][10],f[4][10-c[i]]+w[i]}  = max{f[4][10],f[4][10-6]+19} = max{f[4][10],f[4][4]+19} = max{17,11+19}=30。  上表第5行红色格子是由第4行两个红色格子得出的。
这里是用二维数组存储的，可以把空间优化，用一维数组存储。 
用f[0..v]表示，f[v]表示把前i件物品放入容量为v的背包里得到的价值。把i从1~n(n件)循环后，最后f[v]表示所求最大值。
这里f[v]就相当于二维数组的f[i][v]。那么，如何得到f[i-1][v]和f[i-1][v-c[i]]+w[i]？（重点！思考）
首先要知道，我们是通过i从1到n的循环来依次表示前i件物品存入的状态。
即：for i=1..N
现在思考如何能在是f[v]表示当前状态是容量为v的背包所得价值，而又使f[v]和f[v-c[i]]+w[i]标签前一状态的价值？ 
逆序
这就是关键！ 
```
1 for i=1..N 
2       for v=V..0 
3  　　　　　　f[v]=max{f[v],f[v-c[i]]+w[i]};
```
**为什么要逆序？**
举例：f[3][5]是怎样得来的？
①按矩阵来保存的话，其靠的是f[2][5]和f[2][4]，这一行在当i为2时已经得到，可以直接用。
②但是按一维数组来保存的话，当i为3时，从v=1~10计算出总价值后覆盖i=2时算出的一维数组，所以在算f[3][5]时，一维数组中v=1~4就已经更新了，5~10还未更新。再看回①，需要用到的f[2][5]还在一维数组中未被更新，而f[2][4]=6就被更新为11了，虽然f[3][5]最后的结果是一样的。但是如果你挑其他的就不一定会一样了，比如f[5][10]。

