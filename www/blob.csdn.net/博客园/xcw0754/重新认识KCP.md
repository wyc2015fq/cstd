# 重新认识KCP - xcw0754 - 博客园
# [重新认识KCP](https://www.cnblogs.com/xcw0754/p/10203405.html)
### 什么是KCP
[KCP](https://github.com/skywind3000/kcp)是一种网络传输协议(ARQ，自动重传请求)，可以视它为TCP的代替品，但是它运行于用户空间，它不管底层的发送与接收，只是个纯算法实现可靠传输，它的特点是牺牲带宽来降低延迟。因为TCP协议的大公无私，经常牺牲自己速度来减少网络拥塞，它是从大局上考虑的。而KCP是自私的，它只顾自己的传输效率，从不管整个网络的拥塞情况。举个例子，TCP检测到丢包的时候，首先想到的是网络拥塞了，要放慢自己的速度别让网络更糟，而KCP想到的赶紧重传别耽误事。
TCP的特点是可靠传输(累积确认、超时重传、选择确认)、流量控制(滑动窗口)、拥塞控制(慢开始、拥塞避免、快重传、快恢复)、面向连接。KCP对这些参数基本都可配，也没用建立/关闭连接的过程。
### 怎么使用
KCP只有两个文件，分别是`ikcp.c`和`ikcp.h`，代码行数1300左右。使用KCP和使用TCP有些不同，所以上手之前需要先了解下KCP如何使用，需要时间成本。
第一步，就是创建一个kcp实例，相当于一个句柄。
`ikcpcb* ikcp_create(IUINT32 conv, void *user)`
第二步，设置发送数据的接口，底层用哪种socket都没问题，只要能把数据发送出去，建议使用UDP，比较简单。
`int output(const char *buf, int len, ikcpcb *kcp, void *user)`
第三步，更新KCP状态。KCP运行于用户空间，所以需要手动去更新每个实例的状态，其实主要就是检测哪些数据包该重传了。
`void ikcp_update(ikcpcb *kcp, IUINT32 current)`
第四步，发送数据。调用ikcp_send之后，KCP最后会使用上面设置的output函数来将发送数据(KCP自己并不关心如何发送数据)。
`int ikcp_send(ikcpcb *kcp, const char *buffer, int len)`
第五步，预接收数据。先手动预接收数据，然后再调用ikcp_input将裸数据交给KCP，这些数据有可能是KCP控制报文，并不是我们要的数据。
`int ikcp_input(ikcpcb *kcp, const char *data, long size)`
第六步，接收数据。此时收到的数据才是真正的数据，重组操作在调用ikcp_recv之前就完成了。
`int ikcp_recv(ikcpcb *kcp, char *buffer, int len)`
总体上还是容易理解的，以前我们是直接使用各种socket和对端通信，各种功能由自己控制。现在是在socket之上使用了一个中间件KCP，帮忙实现快速可靠传输功能。注意一下KCP有模式的区分，不同模式下的速度表现不一样，建议把参数配好之后再使用，否则使用的都是默认的参数。
### 快在哪里
- 没用使用任何系统调用接口
- 无需建立/关闭连接(就KCP本身来说)
- 很多影响速度的参数都可配
### 使用场景
丢包率高的网络环境下KCP的优点才会显示出来。如果不丢包，那么TCP和KCP的效率不会差别很大，可能就是少了连接建立/关闭而已。一般来讲，在公网上传输的都可以使用，特别是对实时性要求较高的程序，如LOL。
### 有何缺点
- 学习成本
- 据说有些运营商对UDP有限制?

