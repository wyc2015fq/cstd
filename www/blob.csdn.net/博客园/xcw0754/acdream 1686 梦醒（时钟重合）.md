# acdream 1686  梦醒（时钟重合） - xcw0754 - 博客园
# [acdream 1686  梦醒（时钟重合）](https://www.cnblogs.com/xcw0754/p/4572546.html)
#### Problem Description
娜娜离开了这个王国，走向远方，在旷野上，娜娜看到了一个大时钟，上面的时针分针秒针都在缓缓转动，那只挥着翅膀的天使又出现了，天使说：“外面天已经亮了，娜娜你别睡过头哟~”，娜娜问：“我怎样才能醒过来呢？”，天使说：“只要这个钟的时针和分针重合，你就可以进入时光隧道，离开这个地方。”
那你能告诉娜娜还有多久时针和分针才会重合吗？
#### Input
多组数据，第一行是一个正整数t(t<=100,000)，表示数据的组数
对于每组数据，为一个时刻，格式为hh:mm:ss分别表示当时的时、分、秒（采用24小时计时法，范围从00:00:00~23:59:59）
#### Output
对于每组数据，输出一个浮点数，表示距离下一次时针和分针重合的秒数，误差在1e-4以内将会视为正确。
#### Sample Input
2
23:59:59
00:00:00
#### Sample Output
1.000000
3927.272727
#### Hint
本题采用special judge
题意：给出一个时间（24小时制），问多久后时针和分针会重合，如果刚好给出的时间是重合的，比如0点，那么0点不能算。
思路：两针每次重合都是隔一定的时间的。直接12小时除以11此重合得到他们每次重合相隔的时间长。将给的时间转成12小时制的秒（不需要24），检测11次就得到结果了。
```
1 #include <bits/stdc++.h>
 2 #define LL long long
 3 using namespace std;
 4 const int N=11;
 5 char s1[N];
 6 
 7 int main()
 8 {
 9    // freopen("e://input.txt", "r", stdin);
10     //init();
11     int t;
12     cin>>t;
13     while(t--)
14     {
15         //gets(s1);
16         scanf("%s",s1);
17         int hour=((s1[0]-'0')*10+(s1[1]-'0'))%12;
18         int minu=(s1[3]-'0')*10+(s1[4]-'0');
19         int seco=(s1[6]-'0')*10+(s1[7]-'0');
20  
21         //全部转成秒来计
22         double cnt=hour*3600+minu*60+seco;
23         //cout<<cnt<<endl;
24         double aa=0.0;
25         while(aa<=cnt)
26             aa+=3927.272727;
27         printf("%.6f\n",aa-cnt);
28     }
29  
30  
31     return 0;
32 }
AC代码
```

