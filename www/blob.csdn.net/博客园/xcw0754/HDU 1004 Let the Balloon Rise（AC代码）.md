# HDU 1004 Let the Balloon Rise（AC代码） - xcw0754 - 博客园
# [HDU 1004 Let the Balloon Rise（AC代码）](https://www.cnblogs.com/xcw0754/p/4051937.html)
```
1 #include <stdio.h>
 2 #include <string.h>
 3 char a[1000][16];
 4 int b[1000]={0};
 5 int main()
 6 {
 7     int n,i,j,k,max,loc;
 8     while(scanf("%d",&n)!=EOF&&n!=0){
 9         max=-1;
10         k=0;
11         loc=0;
12         for(i=0;i<n;i++){
13             scanf("%s",a[k]);
14             for(j=0;j<k;j++){  
15                 if(strcmp(a[j],a[k])==0){
16                     b[j]++;
17                     k--;
18                     break;
19                 }
20             }
21             k++;
22         }
23         for(i=0;i<k;i++){
24             if(b[i]>max){
25                 max=b[i];
26                 loc=i;
27             }
28             b[i]=0;
29         }
30         puts(a[loc]);
31     }
32     return 0;
33 }
```
gets遇到回车才结束，并把回车符改为'\0'再存到字符串。注：如果输入的数字过长，这个函数会出问题，因为他不判断输入的长度的。
puts只要遇到第一个'\0'就会输出，并自动输出一个换行符。
格式：这个格式没很大问题，遇到0就结束，而不用输出换行再结束。
思路：
1、题中明确说答案只会有一个，也就是不会出现比如：2 red green的情况。
2、一个二维的字符数组，保存输入的颜色。
3、一个int型数组记录每个颜色出现的次数。（我把他初始化为0，是因为次数不重要，重要的是谁是最多的，实际上应该是该数字+1）
技巧：
1、每输入一个颜色，就对比前面输入的颜色中有没有出现过，若有，在该颜色位置对应的int数组上+1。
2、若输入的已经在之前的颜色中存在，在1中已经记录过出现的次数，那么颜色数组中刚输入的位置就可以重复利用了。
3、若输入的没有在之前的颜色中存在（即新颜色），该位置就不能被覆盖了。
4、输完之后，只需要对比一下int数组中的前k个就行啦（看代码），不用扫整个int数组了，这对于“大部分都是重复出现的颜色”情况就好多了，要是只有两个颜色，一次对比就搞定。

