# 《MORE EFFECTIVE C++》条款20 条款21 - xcw0754 - 博客园
# [《MORE EFFECTIVE C++》条款20 条款21](https://www.cnblogs.com/xcw0754/p/4969724.html)
**条款20 协助编译器实现返回值优化**
　　当重载运算符的时候，比如+ - * / 这类运算符，该函数返回的值一定是个右值（即不能是引用），那么执行一次运算的开销可能会在临时对象上调用多次构造函数和析构函数，这笔开销还是很大的。现在的新编译器已经可以对这种情况进行优化了，甚至优化到连开销都没有，只是有一定的适用范围。如果可以返回一个匿名的临时对象，并且利用构造函数来得到结果对象，那么就有可能被优化到零开销。注意，**有名字的对象意味着返回值优化不可用。**
　　假设有如下的代码：
```
1     node a(2);
2     node b(3);
3     node c=a+b;
```
　　函数的原型大概是这样的：
```
1 const node add(const node& a,const node& b)
2 {
3     return node(a,b);
4 }
```
　　这里返回了一个匿名的临时对象，但是编译器可能会进行优化，甚至零开销（但是c的构造函数开销还是要的）。即使没有优化，我们尽量这么用也没有什么坏处。
**条款22 考虑使用op=来取代单独的op运算符**
　　一般情况下，operator + 只需要定义operator +=就可以一块实现了， 主要的目的是还可以使用条款20中的优化作用，即利用构造函数来达到返回值优化的作用。例如：
```
1 struct node
 2 {
 3 public:
 4     const node& operator += (const node& rhs) const
 5     {
 6         ...
 7         return this;
 8     }
 9 };
10 
11 const node operator +(const node& a,const node& b)
12 {
13     return node(a)+=b;
14 }
```
　　对于返回值优化，如果加上inline内联的话，可能更好。
　　这两篇其实看得不是很明白，只是知道如果这样子用估计会更高效，但是肯定不会花费更多的开销。书中也没有肯定地讲这样一定就优化得了。

