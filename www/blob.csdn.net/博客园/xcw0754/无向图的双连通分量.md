# 无向图的双连通分量 - xcw0754 - 博客园
# [无向图的双连通分量](https://www.cnblogs.com/xcw0754/p/4616700.html)
先看如下的两个定义：
- **点-双连通图**：一个连通的无向图内部没有割点，那么该图是点-双连通图。
注意：孤立点，以及两点一边这两种图都是点-双连通的，因为它们都是内部无割点。
- **边-双连通图**：一个连通的无向图内部没有桥，那么该图就是边-双连通图。
注意：孤立点是边-双连通的，但是两点一边不是边-双连通的。
由上面定义可以知道：**点-双连通图不一定是边-双连通的**。
对于一张无向图，点-双连通的极大子图称为双连通分量。不难发现,每条边恰好属于一个双连通分量(所以两点一边是一个点-双连通分量)。但不同双连通分量可能会有公共点，可以证明不同双连通分量最多只有一个公共点，且它一定是割顶。另一方面任意割顶都是至少两个不同的点-双连通分量的公共点。
边-双连通的极大子图称为边-双连通分量。除了桥不属于任何边-双连通分量外，其他每条边恰好属于一个边-双连通分量，而且把所有桥删除之后,每个连通分量对应原图中的一个边-双连通分量。
**总之:**
判断一个图是不是点-双连通的只要看图中是否有割点。（比寻找割点多了个栈而已）
判断一个图是不是边-双连通的只要看图中是否有桥。
如果看到这里还有很多困惑，先画图思考矛盾的地方，然后看代码可以更清楚，前提是能看懂求割点的算法。
```
1 #include<cstdio>
  2 #include<cstring>
  3 #include<algorithm>
  4 #include<queue>
  5 #include<vector>
  6 #include<stack>
  7 using namespace std;
  8 const int maxn=1000+10;
  9 
 10 int n,m;
 11 int bcc_cnt;
 12 int dfs_clock;      //bcc_cnt计数一共有多少个点-双连通分量
 13 int pre[maxn];      //vis标记，同时也标记了是树中的第几个点
 14 bool iscut[maxn];
 15 int bccno[maxn];    //bccno[i]=x表示第i个顶点属于x号点双连通分量
 16 vector<int> G[maxn],bcc[maxn];  //bcc[i]中包含了i号点-双连通分量的所有节点
 17 
 18 struct Edge //边的结构体
 19 {
 20     int u,v;
 21     Edge(int u,int v):u(u),v(v){}
 22 };
 23 stack<Edge> S;
 24 
 25 int dfs(int u,int fa)
 26 {
 27     int lowu=pre[u]=++dfs_clock;
 28     int child=0;
 29     for(int i=0;i<G[u].size();i++)
 30     {
 31         int v=G[u][i];      //取出点
 32         Edge e = Edge(u,v); //创建这条边
 33 
 34         if(!pre[v]) //v没有被访问过
 35         {
 36             S.push(e);      //将边入栈
 37             child++;
 38             int lowv=dfs(v,u);  //求low先
 39             lowu=min(lowu,lowv);
 40             if(lowv >= pre[u])  //本节点是割点
 41             {
 42                 iscut[u]=true;
 43                 bcc_cnt++;              //注意bcc_cnt从1开始编号
 44                 bcc[bcc_cnt].clear();   //清除之前留下的
 45                 while(true)             //产生一个双连通分量，
 46                 {
 47                     Edge x=S.top();     //逐次取出边
 48                     S.pop();
 49                     //1个点可能属于多个连通分量，且它一定是割点。
 50                     if(bccno[x.u]!=bcc_cnt)     //这个点还没有统计到这个连通分量。
 51                     {
 52                         bcc[bcc_cnt].push_back(x.u);
 53                         bccno[x.u]=bcc_cnt;     //预防重复统计
 54                     }
 55                     if(bccno[x.v]!=bcc_cnt)
 56                     {
 57                         bcc[bcc_cnt].push_back(x.v);
 58                         bccno[x.v]=bcc_cnt;
 59                     }
 60                     if(x.u==u && x.v==v)      //扫到u-v，栈中又没有与u相连的边了。继续试试其他孩子
 61                         break;
 62                 }
 63             }
 64         }
 65         else if(pre[v]<pre[u]&&v!=fa)     //点v在u上面就被访问过，才可以更新，在下面访问过的，不可以！
 66         {
 67             S.push(e);      //这个是和u在一起的双连通分量
 68             lowu=min(lowu,pre[v]);
 69         }
 70     }
 71 
 72     /*
 73     根的孩子必须大于1才会是割点，有割点才会有双连通分量。
 74     （1）那么如果根不是割点呢？
 75     假设根不是割点，那么根最多只有1个孩子，也就是说根的度为1，那么根不可能处于任何1个双连通分量中。
 76     假设根是割点，那么每个孩子各自是一个连通分量。那么就会在上面的代码中被处理为一个双联通分量。
 77     （2）如果有桥呢？比如u-v是桥，那么会怎样？
 78     假设u-v是桥，且u在数中的时间戳比较小。可知v也就是一个割点啦，u-v断开后，与v相连的都成为一个双连通分量了。
 79     回溯到u时，栈中（或顶）没有包含u的边，直到另一个连通分量的产生。
 80     如果u的孩子中没有连通分量了，那么与u相连的孩子肯定有边连到u的上边，他们又形成了一个环了，双连通分量又产生了，由其他割点去解决。
 81     */
 82     if(fa<0 && child==1) iscut[u]=false;
 83     return lowu;
 84 }
 85 
 86 void find_bcc(int n)
 87 {
 88     memset(pre,0,sizeof(pre));
 89     memset(iscut,0,sizeof(iscut));
 90     memset(bccno,0,sizeof(bccno));
 91     dfs_clock = bcc_cnt = 0;
 92     for(int i=0;i<n;i++)            //为了防止有多个连通图，全部都得搜
 93         if(!pre[i]) dfs(i,-1);
 94 }
 95 int main()
 96 {
 97     while(scanf("%d%d",&n,&m)==2&&n)
 98     {
 99         for(int i=0;i<n;i++) G[i].clear();  //点集
100         for(int i=0;i<m;i++)        //输入边
101         {
102             int u,v;
103             scanf("%d%d",&u,&v);
104             G[u].push_back(v);
105             G[v].push_back(u);
106         }
107         find_bcc(n);    //计算双连通分量的个数
108         printf("点-双连通分量一共%d个\n",bcc_cnt);
109 
110 
111 
112         for(int i=1;i<=bcc_cnt;i++)     //输出每个双连通分量。可能点A在第一个双连通分量中输出，又出现在第2个双连通分量中，因为它是割点。
113         {
114             printf("第%d个点-双连通分量包含以下点:\n",i);
115             sort(&bcc[i][0],&bcc[i][0]+bcc[i].size()); //对vector排序,使输出的点从小到大
116             for(int j=0;j<bcc[i].size();j++)
117             {
118                 printf("%d ",bcc[i][j]);
119             }
120             printf("\n");
121         }
122     }
123     return 0;
124 }
125 
126 带注释的源码
带注释的源码
```
**需要注意的是：**
- 单个点不算是一个双连通分量，比如仅有1个点的图。
- 两个点一条边的子图算是一个双连通分量。比如:a-b-c 这个图中有两个双连通分量：a-b和b-c。
- 算法中已经考虑到根和叶子和非叶子节点，所以不用例外去添加代码。
- 根据需要可删减。比如可以不用vector来存储所有连通分量等等。

