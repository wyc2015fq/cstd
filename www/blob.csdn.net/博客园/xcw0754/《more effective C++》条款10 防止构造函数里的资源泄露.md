# 《more effective C++》条款10 防止构造函数里的资源泄露 - xcw0754 - 博客园
# [《more effective C++》条款10 防止构造函数里的资源泄露](https://www.cnblogs.com/xcw0754/p/4967853.html)
　　构造函数也可能发生内存泄露，考虑如下程序：
```
1 class A
 2 {
 3 public:
 4     A(int *p)
 5     {
 6         if(p!=NULL) num=p;
 7         else    p=new int(0);
 8         //do something    
 9     }
10 private:
11     int *num;
12 };
```
　　假设在do something 处抛出异常了，那么即使有析构函数，也是不会执行的。在构造函数没有执行完全的对象是不会自动调用析构函数的，因为析构函数并不知道构造函数执行到哪了，会不会做的事多余了。而当异常没有被及时捕获的话，就会产生泄露了，且会抛异常到调用构造函数的地方。
　　一个有用的方法是，将需要执行的部分先执行完，再抛出异常，并且及时捕获，再释放指针。大概类似如下模式：
```
1 class A
 2 {
 3 public:
 4     A()
 5     {
 6         try{
 7             //do something1
 8             //do something2            
 9         }
10         catch(...){
11             delete x1;
12             delete x2;
13             throw;
14         }
15     }
16 };
```
　　如果类中定义了const成员呢？那就必须在构造函数的初始化表中直接初始化，而在此时出现异常了怎么办？有点难搞了，其实可以使用类似auto_ptr的对象来搞定，局部对象是肯定会被完好释放的。还有一种方法，初始化时是这样的A:X(X),Y(Y){}; 那么可以写一个成员函数，来代替X和Y，异常自然就可以在函数里处理了，但是这样的麻烦程度也增大了，为了初始化而已就开了两个函数来处理这些可能的异常。具体看P39.

