# UVA 10900 So you want to be a 2n-aire?  2元富翁 （数学期望，贪心） - xcw0754 - 博客园
# [UVA 10900 So you want to be a 2n-aire?  2元富翁 （数学期望，贪心）](https://www.cnblogs.com/xcw0754/p/4755010.html)
题意：你一开始有1元钱，接下来又n<=30个问题，只需答对1个问题手上的钱就翻倍，最多答对n个，得到的钱是2n。而每个问题答对的概率是[t,1]之间平均分布，那么问最优情况下得到奖金的期望值是多大？
思路：这题还有最优的情况！而且概率还是均匀连续分布的。
　　分析一下：
　　（1）如果不回答问题，直接拿1元，百分百能带走。
　　（2）最优在可以有两种选择：可以在第i+1个问题面前选择不回答，可拿到2i元期望值，而选择回答也能拿到一定的期望值。而必须根据答对这个问题的概率来决定到底是如何选择。这个可以在坐标轴上表示出来。
　　（3）假设只有1个问题，那么最多可以带走21元，而回答这个问题的期望是多少？是max(20, p*21)，这个max并不是表示单纯的二选一，而是表示在概率t~1上面的二选一。假设概率是t=0.2，那么如果回答这个问题的概率p=[0.2,0.5]，我会选择不回答，即寄望是前者的1元；概率在p=[0.5,1]，我会选择回答，那么期望就是2*p>=1啦，比前者要好。这个画坐标轴的话，前者是直线段，后者是向右上方向的直线段。
　　（4）在第3中，我们是假设了只有1个问题，如果有2，3，4个呢？看只有2个的，我们先算算回答第一个问题，max(20,p*x)，x是表示后面那个问题所能拿到的最大期望值，还没有算呢。所以，必须算出最后一个问题，知道了第n个问题的最大期望值后，才能算第n-1个问题的最大期望值。
　　（5）如何求答案？设d[i]为在回答第i个问题时的最大期望，我们要逆推d数组，最后的d[0]就会是答案，因为d[0]就是回答第一个问题所能拿到的最大期望值（相当于将所有问题绑定，看成只有1个问题，要么不回答，要么回答，而回不回答是看概率的）。假设回答的概率在[t,p0]，不回答的概率在[p0,1]，那么不回答这个问题的概率是(p0-t)/(1-t)。第i个问题的最大期望=不回答时的期望+回答时的期望=2i*p1 + (1+p0)/2*d[i+1]*(1-p1)。
![](https://images0.cnblogs.com/blog2015/641737/201508/241552023436673.jpg)
　　上图中就是处于一个问题时的情况，直线y1表示不回答能得到的期望，直线y2表示回答时能得到的期望。观察发现，如果p在[p0,1]这一段区间内还是选择y2比较好，而p在[t, p0]这一段区间内还是选择y1比较好（即不回答）。他们各自的面积之和就是遇到这个问题时的期望了。所以现在的问题是求p0，po=max(t,2i/d[i+1])，这里需要取max是因为y1和y2的交点可能在[0,t]之间。
```
1 #include <bits/stdc++.h>
 2 #define pii pair<int,int>
 3 #define INF 0x3f3f3f3f
 4 #define LL long long
 5 using namespace std;
 6 const int N=33;
 7 double d[N];
 8 
 9 int main()
10 {
11     //freopen("input.txt", "r", stdin);
12     int n;
13     double t;
14     while(scanf("%d%lf", &n, &t), n)
15     {
16         d[n]=(1<<n);
17         for(int i=n-1; i>=0; i--)
18         {
19             double p0=max(t, (double)(1<<i)/d[i+1] );   //两条直线的交点的x坐标。
20             double p1=(p0-t)/(1-t);     //不回答的概率
21             d[i]=(1<<i)*p1   +  (1+p0)/2*d[i+1]*(1-p1);  //前部分是不回答，后部分是回答。
22         }
23         printf("%.3f\n", d[0]);
24     }
25     return 0;
26 }
AC代码
```

