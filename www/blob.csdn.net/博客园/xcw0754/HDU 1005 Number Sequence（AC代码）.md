# HDU 1005 Number Sequence（AC代码） - xcw0754 - 博客园
# [HDU 1005 Number Sequence（AC代码）](https://www.cnblogs.com/xcw0754/p/4058237.html)
```
1 #include <stdio.h>
 2 #include <string.h>
 3 int main()
 4 {
 5     int a,b,n;
 6     int i;
 7     int f[52]={0};
 8     f[0]=1;
 9     f[1]=1;
10     while(scanf("%d %d %d",&a,&b,&n)!=EOF){
11         if(a==0){
12             break;
13         }
14         for(i=2;i<52;i++){
15             f[i]=(a*f[i-1]+b*f[i-2])%7;
16         }
17         if(n<=52){
18             printf("%d\n",f[n-1]);
19         }
20         else{
21             printf("%d\n",f[(n-52)%48+3]);
22         }
23     }
24     return 0;
25 }
```
因为n可能比较大，它决定了递归的层数，所以不能够用递归了，因为栈可能容不下这么大。
否则用递归是一件很轻松的事。
那么得寻找规律：
每个f(n)的结果与f(n-1)和f(n-2)有关
而f(n-1)只可能是0~6其中的一个，所以共7种（除了f(1)和f(2)）
而f(n-2)也是0~6其中的一个，也共7种（除了f(1)和f(2)）
那么f(n)的结果也只会是0~6之间的一个数
**按照a和b的大小，每个f(n)的结果都是[(a倍0~6)+(b倍0~6)]%7**
设x=f(n-1)和y=f(n-2)，那么可能出现的组合有：
(0,0)	(0,1)	(0,2)	(0,3)	(0,4)	(0,5)	(0,6)
(1,0)	(1,1)	(1,2)	(1,3)	(1,4)	(1,5)	(1,6)
(2,0)	(2,1)	(2,2)	(2,3)	(2,4)	(2,5)	(2,6)
(3,0)	(3,1)	(3,2)	(3,3)	(3,4)	(3,5)	(3,6)
(4,0)	(4,1)	(4,2)	(4,3)	(4,4)	(4,5)	(4,6)
(5,0)	(5,1)	(5,2)	(5,3)	(5,4)	(5,5)	(5,6)
(6,0)	(6,1)	(6,2)	(6,3)	(6,4)	(6,5)	(6,6)
以数组a[100]来测试，a[0]=1,a[1]=1,以下是100个数的后48*2个，即a[4]~a[99]，其中a[4]~a[51]为一个周期，a[52]~a[99]可以看出又是另一个周期。（自己测试前100个即可）
![](https://images0.cnblogs.com/blog/641737/201410/282159277697433.jpg)
![](https://images0.cnblogs.com/blog/641737/201410/282200263627332.jpg)
总结：
以代码中的f[100]这个数组来讲，f[0]~f[3]是没规律的，如果给这几个数，直接输出即可。
f[4]~f[51]是第一个周期内的所有数据，共48个。f[52]~[99]、f[100]~f[147].....类推下去
如果n<=52那么直接输出就行了，如果大于52，那么就要对应到f[4]~f[51]中的一个数了。

