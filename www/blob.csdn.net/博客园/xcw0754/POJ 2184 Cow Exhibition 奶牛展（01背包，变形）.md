# POJ 2184 Cow Exhibition 奶牛展（01背包，变形） - xcw0754 - 博客园
# [POJ 2184 Cow Exhibition 奶牛展（01背包，变形）](https://www.cnblogs.com/xcw0754/p/4477759.html)
题意：有只奶牛要证明奶牛不笨，所以要带一些奶牛伙伴去证明自己。牛有智商和幽默感，两者可为负的（难在这），要求所有牛的智商和之 / 幽默感之和都不为负。求两者之和的最大值。
思路：每只牛可以带或不带上，是01背包问题。但是问题是没有明显的背包容量限制，却有了不为负的一些限制，相同的是要求最大和。必须找个背包容量出来。
1）背包容量：可以使用幽默感之和或智商之和作为背包容量。两者是提供的有明确范围的。
2）负号的问题：牛最多100只，而智商与幽默感最多为正负1千，那么 -1000*100<=x<=1000*100，可以将范围提升100000,那么变成0<=x<=200000。这样就满足作为背包容量的限制了。
3）单个和不能为负：这个限制可以先过滤掉一些弱智牛（两项属性均负）。
4）总和：总和=TF+TS。而TS已经记录在dp·[ ]中，只要不为负就行了。而TF是dp数组的下标，dp[100000]表示TF为0时TS所能获得的总和。dp[>100000]表示TF为正，dp[<100000]表示TF为负，负的不考虑。正解从dp[>100000]中产生。就是TF+TS=j-100000+dp[j]。
**注意**：如何初始化dp数组？这里要有点技巧。为了要让dp的下标就是TF总和，那么绝不能将dp全部置0（否则dp[100010]=0，我们还没进行dp就已经TF+TS=100010-100000-0=10了，是不符合前提的）。但是可以将dp[100000]置零，TS+TF=0 很合理！而其他的全部置为负无穷。理由是，我们在计算TS+TF已经会滤掉单项和为负的，所以在没有开始dp时，所有的dp[x]<0均被滤掉，仅剩dp[0]=0。**而且**，dp[j]要准确表示TF为j的情况，还得满足一个条件，“对于特定TF（即j），dp[j]上必须有意义才可以进行背包求max”。什么意思呢？比如我们的dp用的是一维数组，那么一般都从后往前扫，ans=max(ans, dp[j-智商]+幽默感)，可是当dp[j-智商]=负无穷时，它是无意义的，即dp[j-智商]中并没有已经记录的牛的TS信息，不能用来求max。所以需要加个判断是否为负无穷来判断是否是有意义的，若非负无穷，才是有意义的（有记录某些牛的TS信息），可以求max。这样dp[TF]=TS才能表达TF和TS的组合。若按照dp全部置0处理，无法判断TS是否真的为0，刚开始时幽默感为负的都装不进背包，即使智商1千的牛。dp[j]也不能表示j就是TF，当第一只牛背包时，dp[100500]=dp[100499]=....=1000，1千表示其幽默感，这样100500+1000表达出此牛的TF+TS了吗？没有。
```
1 #include <iostream>
 2 #include <cstdio>
 3 using namespace std;
 4 const int N=200005;
 5 int s[105],f[105];
 6 int dp[N];
 7 int t;
 8 
 9 int cal(int cnt1, int cnt2)
10 {
11     int up=100000+cnt1;        //容量上限，避免每回扫都20w次，若两只牛何必扫4W次？
12     int down=100000+cnt2;    //容量下限
13 
14     for(int i=down; i<=up; i++)    dp[i]=-N;
15     dp[100000]=0;    //背包容量为0时，幽默感当然为0。其他必须初始化为负。
16     
17     //思路：用智力作为背包容量，将100000当成0,那么容量的范围就在100000左右浮动。
18     for(int i=0; i<t; i++)
19     {
20         if(s[i]<=0&&f[i]<=0)    continue;    //若有s[i]+f[i]<0，也可能需要带上，比如有(-5,2)和(1000,-4)两牛，当过滤掉第一只时，第二只也带不了，两只配合却能达到最大。WA贡献在这了。
21         
22         if(s[i]>0)
23         {
24             for(int j=up; j>=down+s[i]; j--)        //从右往左
25                 if(dp[j-s[i]]>-N)        //注意：必须带这牛才能加上它的幽默感，不然i-100000就不是它们的智力和了，而只是智力上限（无用值）。
26                     dp[j] = max( dp[j-s[i]]+f[i], dp[j]);
27         }
28         else
29         {
30             for(int j=down; j<=up+s[i]; j++)
31                 if(dp[j-s[i]]>-N)
32                     dp[j] = max( dp[j-s[i]]+f[i], dp[j]);
33         }
34     }
35     int big=-N;
36     for(int i=100000; i<=up; i++)
37         if(dp[i]>0)
38             big=max(big, i-100000+dp[i]);
39 
40     if(big>0)    return big;
41     else        return 0;
42 }
43 
44 int main()
45 {
46     //freopen("input.txt","r",stdin);
47     while(~scanf("%d",&t))
48     {
49         int cnt1=0,cnt2=0;    
50         for(int i=0; i<t; i++)
51         {
52             scanf("%d%d",&s[i],&f[i]);
53             if(s[i]>0)
54                 cnt1+=s[i];
55             else
56                 cnt2+=s[i];        
57         }
58         printf("%d\n",cal(cnt1,cnt2));
59     }
60         return 0;
61 }
AC代码
```

