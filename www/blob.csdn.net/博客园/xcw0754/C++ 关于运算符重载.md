# C++ 关于运算符重载 - xcw0754 - 博客园
# [C++ 关于运算符重载](https://www.cnblogs.com/xcw0754/p/4214143.html)
转载来源：http://c.biancheng.net/cpp/biancheng/view/216.html
重载运算符的函数一般格式如下：
    函数类型 operator 运算符名称 (形参表列)
    {
        // 对运算符的重载处理
    }
例如，想将”+”用于Complex类(复数)的加法运算，函数的原型可以是这样的：
    Complex operator+ (Complex& c1, Complex& c2);
在上面的一般格式中，operator是关键字，是专门用于定义重载运算符的函数的，运算符名称就是C++提供给用户的预定义运算符。注意，函数名是由operator和运算符组成，上面的operator+就是函数名，意思是“对运算符+重载”。只要掌握这点，就可以发现，这 类函数和其他函数在形式上没有什么区别。两个形参是Complex类对象的引用，要求实参为Complex类对象。
在定义了重载运算符的函数后，可以说，函数operator +重载了运算符+。在执行复数相加的表达式c1 + c2时（假设c1和c2都已被定义为Complex类对象），系统就会调用operator+函数，把c1和c2作为实参，与形参进行虚实结合。
为了说明在运算符重载后，执行表达式就是调用函数的过程，可以把两个整数相加也想像为调用下面的函数：
int operator + (int a, int b)
{
    return (a+b);
}
如果有表达式5+8，就调用此函数，将5和8作为调用函数时的实参，函数的返回值为13。这就是用函数的方法理解运算符。可以在例10.1程序的基础上重载运算符“+”，使之用于复数相加。
[例10.2] 改写例10.1，重载运算符“+”，使之能用于两个复数相加。
- #include <iostream>
- using namespace std;
- classComplex
- {
- public:
- Complex( ){real=0;imag=0;}
- Complex(double r,double i){real=r;imag=i;}
- Complexoperator+(Complex&c2);//声明重载运算符的函数
- void display( );
- private:
- double real;
- double imag;
- };
- Complex Complex::operator+(Complex&c2) //定义重载运算符的函数
- {
- Complex c;
-    c.real=real+c2.real;
-    c.imag=imag+c2.imag;
- return c;
- }
- 
- void Complex::display( )
- {
-    cout<<"("<<real<<","<<imag<<"i)"<<endl;
- }
- 
- int main( )
- {
- Complexc1(3,4),c2(5,-10),c3;
-    c3=c1+c2; //运算符+用于复数运算
-    cout<<"c1=";c1.display( );
-    cout<<"c2=";c2.display( );
-    cout<<"c1+c2=";c3.display( );
- return 0;
- }
运行结果与例10.1相同：
c1=(3+4i)
c2=(5-10i)
c1+c2=(8,-6i)
请比较例10.1和例10.2，只有两处不同：
1) 在例10.2中以operator+函数取代了例10.1中的complex_add函数，而且只是函数名不同，函数体和函数返回值的类型都是相同的。
2) 在main函数中，以“c3=c1+c2;”取代了例10.1中的“c3=c1.complex_add(c2);”。在将运算符+重载为类的成员函数后，C++编译系统将程序中的表达式c1+c2解释为
    c1.operator+(c2)  //其中c1和c2是Complex类的对象
即以c2为实参调用c1的运算符重载函数operator+(Complex &c2)，进行求值，得到两个复数之和。
可以看到，两个程序的结构和执行过程基本上是相同的，作用相同，运行结果也相同。重载运算符是由相应的函数实现的。有人可能说，既然这样，何必对运算符重载呢？我们要从用户的角度来看问題，虽然重载运算符所实现的功能完全可以用函数实现，但是使用运算符重载能使用户程序易于编写、阅读和维护。在实际工作中，类的声明和类的使用往往是分离的。假如在声明Complex类时，对运算符+, -, *, /都进行了重载，那么使用这个类的用户在编程时可以完全不考虑函数是怎么实现的，放心大胆地直接使用+, -, *, /进行复数的运算即可，十分方便。
对上面的运算符重载函数operator+还可以改写得更简练一些：
    Complex Complex::operator + (Complex &c2)
    {return Complex(real+c2.real, imag+c2.imag);}
return语句中的Complex( real+c2.real, imag+c2.imag)是建立一个临时对象，它没有对名，是一个无名对象。在建立临时对象过程中调用构造函数。return语句将此临时对象作为函数返回值。
请思考，在例10.2中能否将一个常量和一个复数对象相加？如
    c3=3+c2;  //错误，与形参类型不匹配
应写成对象形式，如
    c3 = Complex (3,0) +c2;  //正确，类型均为对象
需要说明的是，运算符被重载后，其原有的功能仍然保留，没有丧失或改变。通过运算符重载，扩大了C++已有运算符的作用范围，使之能用于类对象。
运算符重载对C++有重要的意义，把运算符重载和类结合起来，可以在C++程序中定义出很有实用意义而使用方便的新的数据类型。运算符重载使C++具有更强大的功能､更好的可扩充性和适应性，这是C++最吸引人的特点之一。
C++对运算符重载定义了如下几条规则。
1) C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。 例如，有人觉得BASIC中用“**“作为幂运算符很方便，也想在C++中将”**“定义为幂运算符，用”3**5“表示35，这样是不行的。
2) 重载不能改变运算符运算对象(即搡作数)的个数。如关系运算符“>”和“ <” 等是双目运算符，重载后仍为双目运算符，需要两个参数。运算符“ +”，“-”，“*”，“&”等既可以作为单目运算符，也可以作为双目运算符，可以分别将它们重载为单目运算符或双目运算符。
3) 重载不能改变运算符的优先级别。例如“*”和“/”优先于“ +”和“-”，不论怎样进行重载，各运算符之间的优先级别不会改变。有时在程序中希望改变某运算符的优先级，也只能使用加圆括号的办法强制改变重载运算符的运算顺序。
4) 重载不能改变运算符的结合性。如赋值运算符是右结合性（自右至左），重载后仍为右结合性。
5) 重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数，与前面第(2)点矛盾。
6) 重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象(或类对象的引用）。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质，如下面这样是不对的：
    int operator + (int a,int b)
    {
        retum(a-b);
    }
原来运算符+的作用是对两个数相加，现在企图通过重载使它的作用改为两个数相减。 如果允许这样重载的话，如果有表达式4+3，它的结果是7呢还是1？显然，这是绝对禁止的。
如果有两个参数，这两个参数可以都是类对象，也可以一个是类对象，一个是C ++标准类型的数据，如
    Complex operator + (int a,Complex&c)
    {
        return Complex(a +c.real, c.imag);
    }
它的作用是使一个整数和一个复数相加。
7) 用于类对象的运算符一般必须重载，但有两个例外，运算符“=”和“&”不必重载。
①赋值运算符( = )可以用于每一个类对象，可以利用它在同类对象之间相互赋值。 我们知道，可以用赋值运算符对类的对象賦值，这是因为系统已为每一个新声明的类重载了一个赋值运算符，它的作用是逐个复制类的数据成员。用户可以认为它是系统提供的默认的对象赋值运算符，可以直接用于对象间的赋值，不必自己进行重载。但是有时系统提供的默认的对象赋值运算符不能满足程序的要求，例如，数据成员中包含指向动态分配内存的指针成员时，在复制此成员时就可能出现危险。在这种情况下， 就需要自己重载赋值运算符。
②地址运算符&也不必重载，它能返回类对象在内存中的起始地址。
8) 从理论上说，可以将一个运算符重载为执行任意的操作，如可以将加法运算符重载为输出对象中的信息，将“>”运算符重载为“小于”运算。但这样违背了运算符重载的初衷，非但没有提髙可读性，反而使人莫名其妙，无法理解程序。应当使重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能（如用“+”实现加法，用“>”实现“大于”的关系运算）。
9) 运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非类的成员函数也不是友元函敝的普通函数。

