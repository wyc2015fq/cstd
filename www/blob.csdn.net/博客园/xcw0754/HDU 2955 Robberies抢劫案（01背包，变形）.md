# HDU 2955 Robberies抢劫案（01背包，变形） - xcw0754 - 博客园
# [HDU 2955 Robberies抢劫案（01背包，变形）](https://www.cnblogs.com/xcw0754/p/4242828.html)
题意：要抢劫，但是抢每个银行都有被抓的概率，问在低于规定的被抓概率情况下最多能抢到多少钱。
输入：第一行为T，表示共T个测试例子。每个例子的第一行给出一个浮点数P，是规定被抓的概率上限。第一行还有一个整数N，是准备抢的N个银行。接下来有N行代表N个银行，每行是一个整数M和一个浮点数P。M表示此银行钱的数量，P劫此银行会被抓的概率。
输出：低于规定的被抓概率，能抢多少钱？
思路：
　　注意到，这里的背包容量是概率！也就是浮点型，不适合作为容量。要找其他的背包容量才行。
　　将被抓的概率转为安全的概率，安全概率=1-被抓概率，dp保存的是安全概率。将银行作为第1重for循环，也就是表示前 i 个银行可抢的情况下，怎么抢会更多而不被抓。将钱的数量作为第2重for循环，上限是每个银行的钱之和，下限是第i个银行里的钱。每次一更新dp[j]就代表着能抢得 j 钱的最大安全概率。这么说吧，背包的容量是所有银行的钱之和，价值是安全的概率。那dp数组应该开多少合适？还好HDU留个条生路，开dp[10000]就够了。最后怎么获取答案？答案并不在dp[]中了，dp[]中保存的是抢到j钱的安全概率。在理想情况下，此数组是按逆序有序的，抢得越多，安全概率越小，即越危险。实际上却要考虑最糟糕的情况。分析如下：
（1）假设每个银行里的钱最少为y，当y>1时，dp[1]到dp[y]的值在计算的前后都为0，这几个元素都不会被更新到，可在第13行找答案。
（2）假设钱多的银行，其安全概率更大。这不符合常理，但是还是得防一下。举例，第1个银行钱为1，安全概率0.7，第2个银行钱为2，安全概率为0.9，那么dp[0]=1,dp[1]=0.7,dp[2]=0.9,dp[3]=0.7*0.9。　　dp里的值从1→0.7→0.9→0.63，也就是从大→小→大→小。如何找那个规定的安全概率？
（3）假设某个银行的钱为所有银行中最多，为x。那么dp[]数组中，下标大于x的在第1重for的每次循环都可能被更新一次，那么这段dp[]的值就不会出现0啦。可是会是逆序有序的吗？应该会吧！我还没证明！囧！理想会逆序有序，可是成功了。
```
1 #include <iostream>
 2 #define limit 110
 3 using namespace std;
 4 int n;
 5 int money[limit];    //银行的钱
 6 double safe[limit];    //被抓的概率
 7 double dp[10000], p,big;;
 8 void cal(int temp,int n)//所有银行的钱，n家银行
 9 {
10     int i,j;
11     for(i=0;i<n;i++)
12         for(j=temp;j>=money[i];j--)    //j是当前银行的钱
13         {
14             big=dp[j-money[i]]*safe[i];
15             if( dp[j]<big )    dp[j]=big;
16         }
17 }
18 int main()
19 {
20     int t,i,temp;
21     scanf("%d",&t);
22     while(t--)
23     {
24         scanf("%lf %d",&p,&n);
25         temp=0;
26         p=1-p;
27         memset(dp,0,sizeof(dp));
28         dp[0]=1.0;  //没抢到钱，安全概率为1
29         for(i=0;i<n;i++)
30         {
31             scanf("%d %lf",&money[i],&safe[i]);
32             safe[i]=1-safe[i];        //转安全概率
33             temp+=money[i];
34         }
35         cal(temp, n);
36         for(i=temp; i>=0; i--)
37             if(dp[i]-p>0.0)//安全概率比要求的大
38             {
39                 printf("%d\n",i);
40                 break;
41             }
42 
43     }
44     return 0;
45 }
AC代码
```

