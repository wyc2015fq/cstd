# 《MORE EFFECTIVE C++》条款27 要求或者禁止对象分配在堆上 - xcw0754 - 博客园
# [《MORE EFFECTIVE C++》条款27 要求或者禁止对象分配在堆上](https://www.cnblogs.com/xcw0754/p/4966471.html)
**1. 要求对象分配在堆上　　**
　　临时对象一般是存在于栈中的，或者是静态对象存在于常量存储区的。那么当创建一个这样的对象的时候，一般是需要隐式或显式地调用构造函数，在销毁的时候调用析构函数的。可以从这方面入手，去限制构造或析构一个对象，从而达到禁止的效果。很明显，我们可以将构造/析构函数设为private，但是构造函数就没有必要设为private了，一般还得靠它来做一些初始化工作，而析构函数只能有1个，那么将析构函数设为private是最好不过了。如果还是需要用到析构函数呢？只需要设一个public的伪析构函数来调用真的析构函数就可以了（注意析构的时候别用delete了）。
　　通过设private的析构函数已经可以要求该类必须在堆上创建对象了。但是该类也不能被作为基类继承了，这可能不是我们要的效果。这也不难解决，把析构函数设为protected不就可以解决了。其他的问题并不大，总是可以解决。
**2. 判断对象是否在堆上**
　　这个难以实现，即使实现出了，也是不可移植。
**3. 禁止对象分配在堆上**
　　这个问题好解决，只需要重载operator new操作符，并将其设为private即可。当有人想要用new创建一个对象的时候，就会报错。
　　如果想要令继承此类的派生类也不能在堆上分配对象呢？很幸运，只要派生类中没有声明一个public的operator new 成员函数，那么就会继承到基类的private的，从而也会被禁止。如果不巧，派生类中也声明了一个这样的函数呢？抱歉，可能是无解了！

