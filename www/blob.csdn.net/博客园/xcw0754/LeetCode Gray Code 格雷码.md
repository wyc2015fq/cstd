# LeetCode Gray Code 格雷码 - xcw0754 - 博客园
# [LeetCode Gray Code 格雷码](https://www.cnblogs.com/xcw0754/p/4379560.html)
题意：提供一个数字n，代表二进制的个数，那么就有2的n次方个可能性了，从0到2^n-1。将其转成格雷码，再直接将二进制的格雷码按二进制的读法变成整数，装在vector容器中返回，要有序（否则你直接将0～2^n-1返回算了）。
思路：咋一看！什么是格雷码？假设有1个整数，是二进制形式的，将其最高位的1提出来，其他的每一位等于该位上的数字与该数字的前一位之异或。
　　好像很复杂的样子？举例： 整数 21 = 0001 0101 二进制 ，格雷码前4位是这样的0001，这就是将二进制的最高位的1提出来啦，那么格雷码的后4位呢？从左数，格雷码的第5位 = 二进制的第5位0 异或^ 二进制的第4位1 = 1,此时格雷码第5位出现了，格雷码变成0001 1了。第6位呢？从左数，格雷码的第6位 = 二进制的第6位1 异或^ 二进制的第5位0 = 1，格雷码为0001 11了，后几位相信你都会算了。结果格雷码就是0001 1111。
　　上面的方法在计算机中怎么实现？按规律，反正二进制的每个位上的数字都要和前一位异或，即使最高位，因为最高位肯定是1（出位整数0），而该1之前全是0，那么1和0的异或仍是1啦。这样的话，直接将我们的整数右移一位，再与原来整数异或的结果，就是我们要的格雷码，虽然它读出来不再是原来的整数，但是它的二进制形式就是该整数对应的格雷码了。 假如有一个整数a=7，二进制是0000 0111，改成格雷码是0000 0100，这个格雷码按整数的二进制读法将其翻译成整数是4，这就是vector[7]=4。简单吧？
```
1 class Solution {
 2 public:
 3     vector<int> grayCode(int n) {
 4         vector<int> ans;
 5         int m = (1<<n) ;    //一共有m个数要返回
 6         ans.resize(m);    //先把m个数字置为0，还帮你一次性设好内存，多方便！
 7         int count = 0;    
 8         for(int i=1; i<m ;i++ )    //对第i个数字的处理
 9         {
10             count++;    
11             ans[i] = ( count >> 1 ) ^ count;
12         }
13         return ans;
14     }
15 };
grayCode
```

