# 威佐夫博弈（证明） - xcw0754 - 博客园
# [威佐夫博弈（证明）](https://www.cnblogs.com/xcw0754/p/4504039.html)
版权声明：转载时请以超链接形式标明文章原始出处和作者信息及本声明
http://yjq24.blogbus.com/logs/42826226.html
大致上是这样的：有两堆石子，不妨先认为一堆有10，另一堆有15个，双方轮流取走一些石子，合法的取法有如下两种：
1)在一堆石子中取走任意多颗；
2)在两堆石子中取走相同多的任意颗；
约定取走最后一颗石子的人为赢家，求必败态(必胜策略)。
  这个可以说是MR.Wythoff(Wythoff于1907年提出此游戏)一生全部的贡献吧，我在一篇日志里就说完有点残酷。这个问题好像被用作编程竞赛的题目，网上有很多把它Label为POJ1067，不过如果学编程的人不知道*[Beatty定理和Beatty序列](http://www.java3z.com/cwbwebhome/article/article19/res046.html)*，他们所做的只能是找规律而已。
简单分析一下，容易知道两堆石头地位是一样的，我们用余下的石子数(a,b)来表示状态，并画在平面直角坐标系上。
用之前的定理：[*有限个结点的无回路有向图有唯一的核*](http://www.java3z.com/cwbwebhome/article/article19/rew048.html) 中 所述的方法寻找必败态。先标出(0,0)，然后划去所有(0,k),(k,0),(k,k)的格点；然后找y=x上方未被划去的格点，标出(1,2)，然 后划去(1,k),(k,2),(1+k,2+k)，同时标出对称点(2,1)，划去(2,k),(1,k),(2+k,1+k)；然后在未被划去的点中 在y=x上方再找出(3,5)。。。按照这样的方法做下去，如果只列出a<=b的必败态的话，前面的一些是(0,0),(1,2),(3,5), (4,7),(6,10),…
![](http://www.java3z.com/cwbwebhome/article/article19/img1/wythoff.gif)
接下来就是找规律的过程了，可能很辛苦，但是我写得也不容易，而且我暂时没有看到其他地方有这样的证明过程。
忽略(0,0)，记第n组必败态为(a[n],b[n])
**命题一：a[n+1]=前n组必败态中未出现过的最小正整数**
[分析]：如果a[n+1]不是未出现的数中最小的，那么可以从a[n+1]的状态走到一个使a[n+1]更小的状态，和我们的寻找方法矛盾。
**命题二：b[n]=a[n]+n**
[分析]：归纳法：若前k个必败态分别为![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif.gif) ，下证：第k+1个必败态为![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%281%29.gif)
从该第k+1个必败态出发，一共可能走向三类状态，从左边堆拿走一些，从右边堆拿走一些，或者从两堆中拿走一些．下面证明这三类都是胜态．
情况一：由命题一，任意一个比a[k+1]小的数都在之前的必败态中出现过，一旦把左边堆拿少了，我们只要再拿成那个数相应的必败态即可。
情况二（从右边堆拿走不太多）：这使得两堆之间的差变小了，比如拿成了![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%282%29.gif) ，则可再拿成![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%283%29.gif)；
情况二（从右边堆拿走很多）：使得右边一堆比左边一堆更少，这时类似于情况一，比如拿成了![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%284%29.gif) (其中a[m]<a[k+1])  ，则可再拿成![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%285%29.gif) ；
情况三：比如拿成![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%286%29.gif) ，则可再拿成![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%283%29.gif)．
综上所述，任何从![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%281%29.gif)出发走向的状态都可以走回核中．故原命题成立．
以上两个命题对于确定(a[n],b[n])是完备的了，给定(0,0)然后按照这两个命题，就可以写出(1,2),(3,5),(4,7),…
这样我们得到了这个数列的递推式，以下我们把这两个命题当成是(a[n],b[n])的定义。
先证明两个性质：
性质一：核中的a[n],b[n]遍历所有正整数。
[分析]：由命题一，二可得a[n],b[n]是递增的，且由a[n]的定义显然。
性质二：A={a[n]:n=1,2,3,…},B={b[n]:n=1,2,3,…}，则集合A,B不交。
[分析]：由核是内固集，显然。
看到这里大家有没有想到Beatty序列呢，实际上a[n]和b[n]就是一个Beatty序列。
![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%287%29.gif) ，有 ![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%288%29.gif) ，解方程 ![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%289%29.gif)
得 ![](http://www.java3z.com/cwbwebhome/article/article19/img1/gif%2810%29.gif) ，到此，我们找到了该必败态的通项公式。
实际上这组Beatty序列还有一些别的性质，比如当一个数是Fibonacci数的时候，另一个数也是Fibonacci数；而且两者的比值也越来越接近黄金比，这些性质在得到通项公式之后不难证明。
总的来说，这个问题给我们了哪些启示呢？首先用定理所说的方法找核，然后给出核的规律（递推，或是通项）并且证明。最后附上一张对应的必败态图.
![wythoff](http://www.java3z.com/cwbwebhome/article/article19/img1/20090724032234.jpg)

