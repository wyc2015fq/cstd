# 3分钟了解红黑树 - xcw0754 - 博客园
# [3分钟了解红黑树](https://www.cnblogs.com/xcw0754/p/4971392.html)
**1. 简介**
　　红黑树也是一种自平衡二叉查找树，具有二叉树的特点，又与平衡二叉树有区别，主要区别在于红黑树的“平衡”不再是"左右子树高度之差不大于1"，全部体现在其定义中。它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。在C++ STL中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。
　　本文介绍了红黑树的基本性质和基本操作。读者应对平衡二叉树事先有所了解，再来了解红黑树可以更方便些？若有疑问，建议带着疑问全篇看一遍先。
**2. 红黑树的性质**
　　红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡。它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。
　　红黑树的定义也是它的性质，有以下五条：
　　　　性质1. 节点是红色或黑色
　　　　性质2. 根是黑色
　　　　性质3. 所有叶子都是黑色（叶子是NIL节点）
　　　　性质4. 如果一个节点是红的，则它的两个儿子都是黑的
　　　　性质5. 从任一节点向下到任一叶子的所有简单路径都包含**相同数目的黑色节点**。
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree.jpg)
　　这五个性质规定了红黑树的一个关键特性: **任一棵子树的根到叶子的最长路径不多于最短路径的两倍长**。
　　为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，**最短的可能路径全是黑色节点，最长路径可能有交替的红色和黑色节点**。结合性质5可知：从子树根到叶子的简单路径都有相同数目的黑色节点，而红色节点个数总是不多于黑色节点数。这就表明了没有一条简单路径长度能大于其他路径长度的两倍。
**在最坏情况下，每次插入或删除节点，最多只需要3步的旋转就可以调整红黑树为合法状态。**这是其他平衡树可能所不具备的。
**3. 红黑树的基本操作**
　　因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量节点的颜色变更和树旋转，但也是复杂度为 O(log n)，只是从统计上性能好一点而已。
**3.1 插入操作**
　　插入操作可以概括为以下几个步骤：
　　(1) 查找要插入的位置，时间复杂度为：O(logN)
　　(2) 将新节点的color赋为红色
　　(3) 自下而上重新调整该树为红黑树
　　其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了。下面讨论步骤(3)的一些细节：
　　设要插入的节点为N，其父节点为P，P的兄弟节点为U（即P和U是同一个节点的孩子）。
　　[1] 如果P是黑色的，则整棵树不必调整便是红黑树。
　　[2] 如果P是红色的（可知，其父节点G一定是黑色的），则插入N后，违背了性质4，需要进行调整。调整时分以下3种情况：
　　（a）N的叔叔U是红色的
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-s1.jpg)
　　如上图所示，我们将P和U重绘为黑色并重绘节点G为红色(用来保持性质5)。现在新节点N有了一个黑色的父节点P，因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归调整颜色。
　　（b）N的叔叔U是黑色的，且N是右孩子
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-s2.jpg)
　　如上图所示，我们对P进行一次左旋转调换新节点和其父节点的角色; 接着，按情形(c)处理就行了，此时是P节点需要调整。
　　（c）N的叔叔U是黑色的，且N是左孩子
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-s3.jpg)
　　如上图所示，对祖父节点G 的一次右旋转; N和G在同一层且变成红色，P成为该子树新根且为黑色，这样已经满足红黑树性质，无需考虑向上会不会冲突。
**3.2 删除操作**
　　删除操作可以概括为以下几个步骤：
　　(1) 查找要删除位置，时间复杂度为：O(logN)
　　(2) 用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）
　　(3) 如果删除节点的替换节点为黑色，则需重新调整该树为红黑树
　　其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的。如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。（没看懂？？？可参考：http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91 ）在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整。如果删除节点是黑节点，分四种情况：
　　设要删除的节点为N，其父节点为P，其兄弟节点为S。
　　由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的　　
　　（1）S是红色的
　　此时P肯定是红色的。我们对N的父节点进行左旋转，然后把红色兄弟转换成N的祖父。我们接着对调 N 的父亲和祖父的颜色。尽管所有的路径仍然有相同数目的黑色节点，现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按 (2)、(3)或(4)情况来处理。
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-deletion-s1.jpg)
　　（2）S和S的孩子全是黑色的
　　在这种情况下，P可能是黑色的或者红色的，我们简单的重绘S 为红色。结果是通过S的所有路径，它们就是以前不通过 N 的那些路径，都少了一个黑色节点。因为删除 N 的初始的父亲使通过 N 的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点。接下来，要调整以P作为N递归调整树。
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-deletion-s21.jpg)![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-deletion-s22.jpg)
　　（3）S是黑色的，S的左孩子是红色，右孩子是黑色
　　这种情况下我们在 S 上做右旋转，这样 S 的左儿子成为 S 的父亲和 N 的新兄弟。我们接着交换 S 和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在 N 有了一个右儿子是红色的黑色兄弟，所以我们进入了情况（4）。N 和它的父亲都不受这个变换的影响。
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-deletion-s3.jpg)
　　（4）S是黑色的，S的右孩子是红色
　　在这种情况下我们在 N 的父亲上做左旋转，这样 S 成为 N 的父亲和 S 的右儿子的父亲。我们接着交换 N 的父亲和 S 的颜色，并使 S 的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以属性 3 没有被违反。但是，N 现在增加了一个黑色祖先: 要么 N 的父亲变成黑色，要么它是黑色而 S 被增加为一个黑色祖父。所以，通过 N 的路径都增加了一个黑色节点。
![](http://dongxicheng.org/wp-content/uploads/2011/08/red-black-tree-deletion-s4.jpg)

