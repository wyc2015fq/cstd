# C/C++ 关于l-value跟r-value - TaigaComplex求职中 - 博客园







# [C/C++ 关于l-value跟r-value](https://www.cnblogs.com/TaigaCon/archive/2012/12/19/2824354.html)





一般来说，以 “=” 作为分界，左边的叫左值（l-value），右边的叫右值（r-value）。



虽然通俗，不过这种说法，我是认为是不妥的。



今天有人问了条面试题，

a=++b++;

这式子编译无法通过，error: non-lvalue in increment　　　　

错误信息翻译过来就是：自增无左值



下面来分析错误，

首先，我从没见过这种用法，究竟这两个++，先运算的哪个？

为了明白运算顺序，我给他们加了个括号：

a=(++b)++;　　　　//编译通过

a=++(b++);　　　　//编译无法通过，出现跟a=++b++;一样的错误

也就是说，先执行的b++,后执行++b

至于为什么是这种顺序，我在网上找了很久都没找到令人信服的解释，就当作是编译器规定的吧。



然后，为什么b++后不能再++呢，突然想起听说过gcc是c++实现的（虽然我没去查过），如果通过c++来实现b++或者++b会是个什么样？



++b:　　　　

　　　　A& A::operator++(){

　　　　　　　　　　　　　　 ++x;

　　　　　　　　　　　　 　　return *this ; 

　　　　　　　　　　　　　　}

先对b进行自增，然后返回b的引用。





b++:

A A::operator++(int ){

　　　　　　　　 　　　　　　return A(this->x++);

　　　　　　　　　　　　　　}

上面返回的是对象的镜像，然后对x进行自增，

如果是b的话，则会返回一个常数，然后对b自增。



现在我们知道了，b++后返回的是个常数，试问对一个常数，如何进行自增运算呢（++常数）？

而++b返回的是b的引用，即变量，变量是可以自增的。












