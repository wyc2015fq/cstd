# [flex & bison]编译器杂谈 - TaigaComplex求职中 - 博客园







# [[flex & bison]编译器杂谈](https://www.cnblogs.com/TaigaCon/p/3455586.html)





　　flex与bison是编译器设计工具。这里的编译器为广义，其中包括一般的编译器、脚本解析器等，需要进行语言结构解析来得出意义的程序。

　　当我们需要用一个语言来设计一款编译器时，需要考虑太多设计重心外的东西，如内存管理、模块设计、字符识别等，flex与bison就很好地为我们处理了这些事情，将设计重心放在词法与语法分析上。

　　flex提供词法分析，采用的是正则表达式匹配字符。

　　bison提供语法分析，采用A : B | C ;的方式进行语法设计。

　　具体的规则《flex 与 bison》有很详细的描述。



**首先，对于语言的解析，是以流（stream）的方式进行的。**

　　假定我们词法与语法都已经设定好

　　if A > B then C = 0;

　　对于以上句子大概会进行如此解析：

1. if 词法分析判定为 IF，返回标记

2. 语法分析接到标记，存放到栈内，发现找不到适合的语法来进行归约，返回进行词法分析

3. A 词法分析判定为NAME，返回标记

4. 语法分析接到标记，存放到栈内发现NAME能被归约成exp，NAME出栈，exp入栈

　　5. 现在栈内有IF exp，语法分析发现找不到适合的语法来进行归约，返回进行词法分析

6. > 词法分析判定为CMP，返回标记

7. 语法分析接到标记，存放到栈内，发现找不到适合的语法来进行归约，返回进行词法分析

8. B 词法分析判定为NAME，返回标记

9. 语法分析接到标记，存放到栈内发现NAME能被归约成exp，NAME出栈，exp入栈

　　10.语法分析接到标记，存放到栈内，发现栈内有exp CMP exp，可以规约为exp，于是进行归约，exp放回栈内，然后发现有IF exp，无法归约，返回词法分析

　　...

　　*分析方法采用的是lrlr(1)，这也是bison的一般做法，上面分析为了方便省去向前查看的步骤。

　　上述例子可以看出只要过一遍字符流，通过词法分析与语法分析的交替进行，就可以最终归约句子。



**为了方便维护，语法分析时都会进行语法树构建**，如上述例子：

　　当NAME被归约成exp时，创建节点，节点需要保存NAME所在符号表的位置，

　　当exp CMP exp被归约成exp时，创建节点，节点需要保存作exp节点的指针为左子树，保持右exp节点的指针为右子树，保存CMP类型



　　一般的编译器都能够自定义变量，如上述例子的A、B、C，这些符号会在词法分析时被判别为自定义变量。

**自定义变量需要进行维护，可以用哈希表保存自定义变量。**

　　自定义变量的名称在词法分析时，就可以加到哈希表内。

另外自定义变量包含比较多的信息，如类型、变量值等，如果是函数，那么还会包含函数体指针，这些在词法分析时是无法得到的。而在词法分析时，只是构建语法树，并不适于进行信息填充。但是在计算时就会用到哈希表内的变量。

　　假设句子是一行一行执行的，那么在碰到'\n'符合时就会执行计算，

　　如上例：C = 0;

　　计算时会把C在哈希表内的变量值填充为0；














