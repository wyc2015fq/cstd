# static 用法 - h13 - 博客园
### 面向过程设计中的static
　　1、静态全局变量
　　在全局变量前，加上[关键字](http://www.cnblogs.cc2/view/390935.htm)static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：
　　//Example 1
　　#include <iostream.h>
　　void fn();
　　static int n; //定义静态全局变量
　　void main()
　　{ n=20;
　　cout<<n<<endl;
　　fn();
　　}
　　void fn()
　　{ n++;
　　cout<<n<<endl;
　　}
　　静态全局变量有以下特点：
　　该变量在全局数据区分配内存；
　　未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
　　静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
[静态变量](http://www.cnblogs.cc2/view/675642.htm)都在全局数据区分配内存，包括后面将要提到的静态[局部变量](http://www.cnblogs.cc2/view/552847.htm)。对于一个完整的程序，在内存中的分布情况如下图：
　　代码区 //low address
　　全局数据区
　　堆区
　　栈区 //high address
　　一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静 态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，Example 1中的代码中将
　　static int n; //定义静态全局变量
　　改为
　　int n; //定义全局变量
　　程序照样正常运行。
　　的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：
　　静态全局变量不能被其它文件所用；
　　其它文件中可以定义相同名字的变量，不会发生冲突；
　　您可以将上述示例代码改为如下：
　　//Example 2//File1
　　#include <iostream.h>
　　void fn();
　　static int n; //定义静态全局变量
　　void main()
　　{ n=20;
　　cout<<n<<endl;
　　fn();
　　}
　　//File2
　　#include <iostream.h>
　　extern int n;
　　void fn()
　　{ n++;
　　cout<<n<<endl;
　　}
　　编译并运行Example 2，您就会发现上述代码可以分别通过编译，但运行时出现错误。 试着将
　　static int n; //定义静态全局变量
　　改为
　　int n; //定义全局变量
　　再次编译运行程序，细心体会全局变量和静态全局变量的区别。
**注意：**全局变量和全局静态变量的区别
　　1）全局变量是不显式用static修饰的全局变量，但全局变量默认是静态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。
　　2）全局静态变量是显式用static修饰的全局变量，作用域是所在的文件，其他的文件即使用extern声明也不能使用。
　　2、静态局部变量
　　在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
　　我们先举一个静态局部变量的例子，如下：
　　//Example 3
　　#include <iostream.h>
　　void fn();
　　void main()
　　{ fn();
　　fn();
　　fn();
　　}
　　void fn()
　　{ static int n=10;
　　cout<<n<<endl;
　　n++;
　　}
　　通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。
　　但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
　　静态局部变量有以下特点：
　　该变量在全局数据区分配内存；
　　静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
　　静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
　　它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
　　3、[静态函数](http://www.cnblogs.cc2/view/1836316.htm)
　　在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
　　静态函数的例子：
　　//Example 4
　　#include <iostream.h>
　　static void fn();//声明静态函数
　　void main()
　　{
　　fn();
　　}
　　void fn()//定义静态函数
　　{ int n=10;
　　cout<<n<<endl;
　　}
　　定义静态函数的好处：
　　静态函数不能被其它文件所用；
　　其它文件中可以定义相同名字的函数，不会发生冲突；
### 面向对象的static关键字
　　（类中的static关键字）
　　1、静态数据成员
　　在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。先举一个静态数据成员的例子。
　　//Example 5
　　#include <iostream.h>
　　class Myclass
　　{
　　public:
　　Myclass(int a,int b,int c);
　　void GetSum();
　　private:
　　int a,b,c;
　　static int Sum;//声明静态数据成员
　　};
　　int Myclass::Sum=0;//定义并初始化静态数据成员
　　Myclass::Myclass(int a,int b,int c)
　　{ this->a=a;
　　this->b=b;
　　this->c=c;
　　Sum+=a+b+c;}
　　void Myclass::GetSum()
　　{ cout<<"Sum="<<Sum<<endl;
　　}
　　void main()
　　{ Myclass M(1,2,3);
　　M.GetSum();
　　Myclass N(4,5,6);
　　N.GetSum();
　　M.GetSum();}
　　可以看出，静态数据成员有以下特点：
　　对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷 贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共 用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
　　静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员；
　　静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
　　因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
　　静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
　　＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
　　类的静态数据成员有两种访问形式：
　　＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
　　如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
　　静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这 有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次， 则所有存款类对象的利息全改变过来了；
　　同全局变量相比，使用静态数据成员有两个优势：
　　静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
　　可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；
　　2、[静态成员](http://www.cnblogs.cc2/view/534160.htm)函数
　　与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部 实现，属于类定义的一部分。 普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this 是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指 针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。 下面举个静态成员函数的例子。
　　//Example 6
　　#include <iostream.h>
　　class Myclass
　　{public:
　　Myclass(int a,int b,int c);
　　static void GetSum();/声明静态成员函数
　　private:
　　int a,b,c;
　　static int Sum;//声明静态数据成员
　　};
　　int Myclass::Sum=0;//定义并初始化静态数据成员
　　Myclass::Myclass(int a,int b,int c)
　　{ this->a=a;
　　this->b=b;
　　this->c=c;
　　Sum+=a+b+c; //非静态成员函数可以访问静态数据成员
　　}
　　void Myclass::GetSum() //静态成员函数的实现
　　{// cout<<a<<endl; //错误代码，a是非静态数据成员
　　cout<<"Sum="<<Sum<<endl;
　　}
　　void main()
　　{ Myclass M(1,2,3);
　　M.GetSum();
　　Myclass N(4,5,6);
　　N.GetSum();
　　Myclass::GetSum();
　　}
　　关于静态成员函数，可以总结为以下几点：
　　出现在类体外的函数定义不能指定关键字static；
　　静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
　　非静态成员函数可以任意地访问静态成员函数和静态数据成员；
　　静态成员函数不能访问非静态成员函数和非静态数据成员；
　　由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
　　调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
　　＜类名＞::＜静态成员函数名＞（＜参数表＞）
　　调用类的静态成员函数。
### 作用
　　static静态变量声明符。 在声明它的程序块，子程序块或函数内部有效，值保持，在整个程序期间分配存储器空间，[编译器](http://www.cnblogs.cc2/view/487018.htm)默认值0。
　　是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。
### 为什么要引入static
　　函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。
### 什么时候用static
　　需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。
### static的内部机制
　　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
　　这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有[类的成员函数](http://www.cnblogs.cc2/view/2345889.htm)定义；三是[应用程序](http://www.cnblogs.cc2/view/330120.htm)的main（）函数前的全局数据声明和定义处。
　　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
　　static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态
　　数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。
### static的优势
　　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
### 应用格式
　　引用静态数据成员时，采用如下格式：
　　<类名>::<静态成员名>
　　如果静态数据成员的访问权限允许的话(即public的成员)，可在程序中，按上述格式来引用静态数据成员。
### 注意事项
　　(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。
　　(2)不能将静态成员函数定义为虚函数。
　　(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember[函数指针](http://www.cnblogs.cc2/view/1604730.htm)”。
　　(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X Window系统结合，同时也成功的应用于[线程](http://www.cnblogs.cc2/view/1053.htm)函数身上。
　　(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。
　　(6)静态数据成员在<定义或说明>时前面加关键字static。
　　(7)静态数据成员是静态存储的，所以必须对它进行初始化。
　　(8)静态成员初始化与一般数据成员初始化不同:
　　初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
　　初始化时不加该成员的访问权限控制符private，public等；
　　初始化时使用作用域运算符来标明它所属类；
　　所以我们得出静态数据成员初始化的格式：
　　<数据类型><类名>::<静态数据成员名>=<值>
　　(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。在各通信公司的笔试面试中经常出现的考题就是static的作用及功能。
## [编辑本段](http://baike.baidu.com/view/536145.htm#)C++中的static函数
### 分类
　　static 函数内部函数和外部函数
　　当一个源程序由多个源文件组成时，Ｃ语言根据函数能否被其它源文件中的函数调用，将函数分为内部函数和外部函数。
### 内部函数
　　（又称静态函数）
　　如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为内部函数。
　　定义一个内部函数，只需在函数类型前再加一个“static”关键字即可，如下所示：
　　static 函数类型 函数名(函数参数表)
　　{……}
　　关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。
　　使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。
### 外部函数
　　外部函数的定义：在定义函数时，如果没有加关键字“static”，或冠以关键字“extern”，表示此函数是外部函数：
　　[extern] 函数类型 函数名(函数参数表)
　　{……}
　　调用外部函数时，需要对其进行说明：
　　[extern] 函数类型 函数名(参数类型表)[，函数名2(参数类型表2)……]；
　　[案例]外部函数应用。
　　（1）文件mainf.c
　　main()
　　{ extern void input(…),process(…),output(…);
　　input(…); process(…); output(…);
　　}
　　（2）文件subf1.c
　　……
　　extern void input(……) /*定义外部函数*/
　　{……}
　　（3）文件subf2.c
　　……
　　extern void process(……) /*定义外部 函数*/
　　{……}
　　（4）文件subf3.c
　　……
　　extern void output(……) /*定义外部函数*/
　　{……}
