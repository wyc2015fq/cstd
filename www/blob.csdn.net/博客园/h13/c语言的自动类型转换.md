# c语言的自动类型转换 - h13 - 博客园
自动转换遵循以下规则：
1)        若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
2)        转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。
     a.若两种类型的字节数不同，转换成字节数高的类型
b.若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
3)        所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
4)        char型和short型参与运算时，必须先转换成int型。
5)        在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。
隐式转换 
隐式类型转换分三种，即算术转换、赋值转换和输出转换。
**1．算术转换**
进行算术运算（加、减、乘、除、取余以及符号运算）时，不同类型数招必须转换成同一类型的数据才能运算，算术转换原则为：
在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如：
(1)若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。
(2)若运算数中最长的类型为long型．则其他类型数均转换成long型数。
(3)若运算数中最长类型为int型，则char型也转换成int型进行运算。算术转换是在运算过程中自动完成的。
**2．赋值转换**
进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。
下面用一实例说明：
      char ch;
      int i,result;
      float f;
      double d;
      result=ch/i+(f*d-i);
(1)首先计算 ch/i,ch → int型，ch/i → int型。
(2)接着计算 f*d-i，由于最长型为double型，故f→double型，i→double型，f*d-i→double型。
(3)(ch/i) 和(f*d-i)进行加运算，由于f*d-i为double型，故ch/i→double型，ch/i+(f*d-i)→double型。
(4)由于result为int型，故ch/i+(f*d-i)→double→int，即进行截断与舍入，最后取值为整型。
**3．输出转换**
在程序中将数据用printf函数以指定格式输出时，当要输出的盐据类型与输出格式不符时，便自动进行类型转换，如一个long型数据用整型格式(%d)输出时，则相当于将long型转换成整型(int)数据输出；一个字符(char）型数据用整型格式输出时，相当于将char型转换成int型输出。
注意：较长型数据转换成短型数据输出时，其值不能超出短型数据允许的值范围，否则转换时将出错。如：
      long a=80000;
      printf("%d",a);
运行结果为14464，因为int型允许的最大值为32767，80000超出此值，故结果取以32768为模的余数，即进行如下取余运算：
      (80000-32768)-32768=14464;
输出的数据类型与输出格式不符时常常发生错误，如：
      int d=9;
      printf("%f",d);
或
      float c=3.2;
      printf("%d",c);
将产生错误的结果。
同一句语句或表达式如果使用了多种类型的变量和常量（类型混用），C 会自动把它们转换成同一种类型。以下是自动类型转换的基本规则：
      1. 在表达式中，char 和 short 类型的值，无论有符号还是无符号，都会自动转换成 int 或者 unsigned int（如果 short 的大小和 int 一样，unsigned short 的表示范围就大于 int，在这种情况下，unsigned short 被转换成 unsigned int）。因为它们被转换成表示范围更大的类型，故而把这种转换称为“升级（promotion）”。
      2. 按照从高到低的顺序给各种数据类型分等级，依次为：long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int 和 int。这里有一个小小的例外，如果 long 和 int 大小相同，则 unsigned int 的等级应位于 long 之上。char 和 short 并没有出现于这个等级列表，是因为它们应该已经被升级成了 int 或者 unsigned int。
      3. 在任何涉及两种数据类型的操作中，它们之间等级较低的类型会被转换成等级较高的类型。
      4. 在赋值语句中，= 右边的值在赋予 = 左边的变量之前，首先要将右边的值的数据类型转换成左边变量的类型。也就是说，左边变量是什么数据类型，右边的值就要转换成什么数据类型的值。这个过程可能导致右边的值的类型升级，也可能导致其类型降级（demotion）。所谓“降级”，是指等级较高的类型被转换成等级较低的类型。
      5. 作为参数传递给函数时，char 和 short 会被转换成 int，float 会被转换成 double。使用函数原型可以避免这种自动升级。
