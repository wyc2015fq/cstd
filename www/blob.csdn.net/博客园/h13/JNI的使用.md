# JNI的使用 - h13 - 博客园
```
public class testdll 
　　{ 
　　static 
　　{ 
　　System.loadLibrary("goodluck"); 
　　} 
　　public native static int get(); 
　　public native static void set(int i); 
　　public static void main(String[] args) 
　　{ 
　　testdll test = new testdll(); 
　　test.set(10); 
　　System.out.println(test.get()); 
　　} 
　　}
```
      首先引用一篇文章，介绍一个简单的JNI的调用的过程。 
　　JAVA以其跨平台的特性深受人们喜爱，而又正由于它的跨平台的目的，使得它和本地机器的各种内部联系变得很少，约束了它的功能。解决JAVA对本地操作的一种方法就是JNI。 
　　JAVA通过JNI调用本地方法，而本地方法是以库文件的形式存放的（在WINDOWS平台上是DLL文件形式，在UNIX机器上是SO文件形式）。通过调用本地的库文件的内部方法，使JAVA可以实现和本地机器的紧密联系，调用系统级的各接口方法。 
　　简单介绍及应用如下： 
　　一、JAVA中所需要做的工作 
　　在JAVA程序中，首先需要在类中声明所调用的库名称，如下： 
```
static { 
　　System.loadLibrary(“goodluck”); 
　　}
```
　　在这里，库的扩展名字可以不用写出来，究竟是DLL还是SO，由系统自己判断。 
　　还需要对将要调用的方法做本地声明，关键字为native。并且只需要声明，而不需要具 体实现。如下： 
　　public native static void set(int i); 
　　public native static int get(); 
　　然后编译该JAVA程序文件，生成CLASS，再用JAVAH命令，JNI就会生成C/[C++](http://www.jcwcn.com/html/C++)的头文件。 
　　例如程序testdll.java，内容为： 
　　用javac testdll.java编译它，会生成testdll.class。 
　　再用javah testdll，则会在当前目录下生成testdll.h文件，这个文件需要被C/[C++](http://www.jcwcn.com/html/C++)程序调用来生成所需的库文件。 
　　二、C/[C++](http://www.jcwcn.com/html/C++)中所需要做的工作 
　　对于已生成的.h头文件，C/[C++](http://www.jcwcn.com/html/C++)所需要做的，就是把它的各个方法具体的实现。然后编译连接成库文件即可。再把库文件拷贝到JAVA程序的路径下面，就可以用JAVA调用C/[C++](http://www.jcwcn.com/html/C++)所实现的功能了。 
　　接上例子。我们先看一下testdll.h文件的内容： 
```
/* DO NOT EDIT THIS FILE - it is machine generated */ 
　　#include 
　　/* Header for class testdll */ 
　　#ifndef _Included_testdll 
　　#define _Included_testdll 
　　#ifdef __cplusplus 
　　extern "C" { 
　　#endif 
　　/* 
　　* Class: testdll 
　　* Method: get 
　　* Signature: ()I 
　　*/ 
　　JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 
　　/* 
　　* Class: testdll 
　　* Method: set 
　　* Signature: (I)V 
　　*/ 
　　JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint); 
　　#ifdef __cplusplus 
　　} 
　　#endif 
　　#endif
```
　　在具体实现的时候，我们只关心两个函数原型 
　　JNIEXPORT jint JNICALL [Java](http://www.jcwcn.com/html/Java)_testdll_get (JNIEnv *, jclass); 和 
　　JNIEXPORT void JNICALL [Java](http://www.jcwcn.com/html/Java)_testdll_set (JNIEnv *, jclass, jint); 
　　这里JNIEXPORT和JNICALL都是JNI的关键字，表示此函数是要被JNI调用的。而jint是以JNI为中介使JAVA的int类型与本地的int沟通的一种类型，我们可以视而不见，就当做int使用。函数的名称是JAVA_再加上java程序的package路径再加函数名组成的。参数中，我们也只需要关心在JAVA程序中存在的参数，至于JNIEnv*和jclass我们一般没有必要去碰它。 
　　好，下面我们用testdll.cpp文件具体实现这两个函数： 
```
#include "testdll.h" 
　　int i = 0; 
　　JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass) 
　　{ 
　　return i; 
　　} 
　　JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint j) 
　　{ 
　　i = j; 
　　}
```
　　编译连接成库文件，本例是在WINDOWS下做的，生成的是DLL文件。并且名称要与JAVA中需要调用的一致，这里就是goodluck.dll 。把goodluck.dll拷贝到testdll.class的目录下，java testdll运行它，就可以观察到结果了。 
　　我的项目比较复杂，需要调用动态链接库，这样在JNI传送参数到C程序时，需要对参数进行处理转换。才可以被C程序识别。 
　　大体程序如下： 
```
public class SendSMS { 
　　static 
　　{ 
　　System.out.println(System.getProperty("java.library.path")); 
　　System.loadLibrary("sms"); 
　　} 
　　public native static int SmsInit(); 
　　public native static int SmsSend(byte[] mobileNo, byte[] smContent); 
　　}
```
　　在这里要注意的是，path里一定要包含类库的路径，否则在程序运行时会抛出异常： 
　　java.lang.UnsatisfiedLinkError: no sms in java.library.path 
　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1491) 
　　at java.lang.Runtime.loadLibrary0(Runtime.java:788) 
　　at java.lang.System.loadLibrary(System.java:834) 
　　at com.mobilesoft.sms.mobilesoftinfo.SendSMS.(SendSMS.java:14) 
　　at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18) 
　　Exception in thread "main" 
　　指引的路径应该到.dll文件的上一级，如果指到.dll，则会报： 
　　java.lang.UnsatisfiedLinkError: C:\sms.dll: Can't find dependent libraries 
　　at java.lang.ClassLoader$NativeLibrary.load(Native Method) 
　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1560) 
　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1485) 
　　at java.lang.Runtime.loadLibrary0(Runtime.java:788) 
　　at java.lang.System.loadLibrary(System.java:834) 
　　at com.mobilesoft.sms.mobilesoftinfo.SendSMS.(SendSMS.java:14) 
　　at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18) 
　　Exception in thread "main" 
　　通过编译，生成com_mobilesoft_sms_mobilesoftinfo_SendSMS.h头文件。（建议使用Jbuilder进行编译，操作比较简单！）这个头文件就是[Java](http://www.jcwcn.com/html/Java)和C之间的纽带。要特别注意的是方法中传递的参数jbyteArray，这在接下来的过程中会重点介绍。 
　　/* DO NOT EDIT THIS FILE - it is machine generated */ 
　　#include 
　　/* Header for class com_mobilesoft_sms_mobilesoftinfo_SendSMS */ 
　　#ifndef _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS 
　　#define _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS 
　　#ifdef __cplusplus 
　　extern "C" { 
　　#endif 
　　/* 
　　* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS 
　　* Method: SmsInit 
　　* Signature: ()I 
　　*/ 
　　JNIEXPORT jint JNICALL [Java](http://www.jcwcn.com/html/Java)_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsInit 
　　(JNIEnv *, jclass); 
　　/* 
　　* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS 
　　* Method: SmsSend 
　　* Signature: ([B[B)I 
　　*/ 
　　JNIEXPORT jint JNICALL [Java](http://www.jcwcn.com/html/Java)_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsSend 
　　(JNIEnv *, jclass, jbyteArray, jbyteArray); 
　　#ifdef __cplusplus 
　　} 
　　#endif 
　　#endif 
　　对于我要调用的C程序的动态链接库，C程序也要提供一个头文件，sms.h。这个文件将要调用的方法罗列了出来。 
　　/* 
　　* SMS API 
　　* Author: yippit 
　　* Date: 2004.6.8 
　　*/ 
　　#ifndef MCS_SMS_H 
　　#define MCS_SMS_H 
　　#define DLLEXPORT __declspec(dllexport) 
　　/*sms storage*/ 
　　#define SMS_SIM 0 
　　#define SMS_MT 1 
　　/*sms states*/ 
　　#define SMS_UNREAD 0 
　　#define SMS_READ 1 
　　/*sms type*/ 
　　#define SMS_NOPARSE -1 
　　#define SMS_NORMAL 0 
　　#define SMS_FLASH 1 
　　#define SMS_MMSNOTI 2 
　　typedef struct tagSmsEntry { 
　　int index; /*index, start from 1*/ 
　　int status; /*read, unread*/ 
　　int type; /*-1-can't parser 0-normal, 1-flash, 2-mms*/ 
　　int storage; /*SMS_SIM, SMS_MT*/ 
　　char date[24]; 
　　char number[32]; 
　　char text[144]; 
　　} SmsEntry; 
　　DLLEXPORT int SmsInit(void); 
　　DLLEXPORT int SmsSend(char *phonenum, char *content); 
　　DLLEXPORT int SmsSetSCA(char *sca); 
　　DLLEXPORT int SmsGetSCA(char *sca); 
　　DLLEXPORT int SmsSetInd(int ind); 
　　DLLEXPORT int SmsGetInd(void); 
　　DLLEXPORT int SmsGetInfo(int storage, int *max, int *used); 
　　DLLEXPORT int SmsSave[Flash](http://www.jcwcn.com/html/Flash)(int flag); 
　　DLLEXPORT int SmsRead(SmsEntry *entry, int storage, int index); 
　　DLLEXPORT int SmsDelete(int storage, int index); 
　　DLLEXPORT int SmsModifyStatus(int storage, int index); /*unread -> read*/ 
　　#endif 
　　在有了这两个头文件之后，就可以进行C程序的编写了。也就是实现对JNI调用的两个方法。在网上的资料中，由于调用的方法实现的都比较简单，（大多是打印字符串等）所以避开了JNI中最麻烦的部分，也是最关键的部分，参数的传递。由于[Java](http://www.jcwcn.com/html/Java)和C的编码是不同的，所以传递的参数是要进行再处理，否则C程序是会对参数在编译过程中提出警告，例如；warning C4024: 'SmsSend' : different types for formal and actual parameter 2等。 
　　Sms.c的程序如下： 
　　#include "sms.h" 
　　#include "com_mobilesoft_sms_mobilesoftinfo_SendSMS.h" 
　　JNIEXPORT jint JNICALL [Java](http://www.jcwcn.com/html/Java)_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsInit(JNIEnv * env, jclass jobject) 
　　{ 
　　return SmsInit(); 
　　} 
　　JNIEXPORT jint JNICALL [Java](http://www.jcwcn.com/html/Java)_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsSend(JNIEnv * env, jclass jobject, jbyteArray mobileno, jbyteArray smscontent) 
　　{ 
　　char * pSmscontent ; 
　　//jsize theArrayLengthJ = (*env)->GetArrayLength(env,mobileno); 
　　jbyte * arrayBody = (*env)->GetByteArrayElements(env,mobileno,0); 
　　char * pMobileNo = (char *)arrayBody; 
　　printf("[%s]\n ", pMobileNo); 
　　//jsize size = (*env)->GetArrayLength(env,smscontent); 
　　arrayBody = (*env)->GetByteArrayElements(env,smscontent,0); 
　　pSmscontent = (char *)arrayBody; 
　　printf("

