# Linux内存管理(上) - h13 - 博客园
**摘要**：本章首先以应用程序开发者的角度审视Linux的进程内存管理，在此基础上逐步深入到内核中讨论系统物理内存管理和内核内存地使用方法。力求从外自内、水到渠成地引导网友分析Linux地内存管理与使用。在本章最后我们给出一个内存映射地实例，帮助网友们理解内核内存管理与用户内存管理之间地关系，希望大家最终能驾驭Linux内存管理。
## 前言
内存管理一向是所有操作系统书籍不惜笔墨重点讨论的内容，无论市面上或是网上都充斥着大量涉及内存管理的教材和资料。因此我们这里所要写的Linux内存管理采取必重就轻的策略，从理论层面就不去板门弄斧，贻笑大方了。我们最想做的和可能做到的是以开发者的角度谈谈对内存管理的理解，最终目的是把我们在内核开发中使用内存的经验和对Linux内存管理的认识与大家共享。
当然这其中我们也会设计一些诸如段页等内存管理的基本理论，但我们目的不是为了强调理论，而是为了指导理解开发中的实践，所以仅仅点到为止，不做深究。
遵循“理论来源于实践”的“教条”，我们先不必一下子就钻入内核里去看系统内存到底是如何管理，那样往往会让你陷入似懂非懂的窘境（我当年就犯了这个错误！）。所以最好的方式是先从外部（用户编程范畴）来观察进程如何使用内存，等到对大家内存使用有了较直观的认识后，再深入到内核中去学习内存如何被管理等理论知识。最后再通过一个实例编程将所讲内容融会贯通。
## 进程与内存
### 进程如何使用内存？
毫无疑问所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。
对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都该能想到这几个数据段种包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。
***代码段***：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
***数据段***：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[[1]](http://writeblog.csdn.net/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&Toolbar=Default#_ftn1)的变量和全局变量。
***BSS******段[**[2]**](http://writeblog.csdn.net/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&Toolbar=Default#_ftn2)***：BSS段包含了程序中未初始化全局变量，在内存中 bss段全部置零。
***堆（heap******）***：堆是用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
***栈***：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味这在数据段中存放变量）。除此以外在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把堆栈看成一个临时数据寄存、交换的内存区。
### 进程如何组织这些区域？
上述几种内存区域中数据段、BSS和堆通常是被连续存储的——内存位置上是连续的，而代码段和栈往往会被独立存放。有趣的是堆和栈两个区域关系很“暧昧”，他们一个向下“长”（i386体系结构中栈向下、堆向上），一个向上“长”，相对而生。但你不必担心他们会碰头，因为他们之间间隔很大（到底大到多少，你可以从下面的例子程序计算一下），绝少有机会能碰到一起。
下图简要描述了进程内存区域的分布：
![](http://p.blog.csdn.net/images/p_blog_csdn_net/kanghua/stack1.bmp)
数据段
BSS
代码段
堆
栈
“事实胜于雄辩”，我们用一个小例子（原形取自《User-Level Memory Management》）来展示上面所讲的各种内存区的差别与位置。
*#include<stdio.h>*
*#include<malloc.h>*
*#include<unistd.h>*
*int bss_var;*
*int data_var0=1;*
*int main(int argc,char **argv)*
*{*
*printf("below are addresses of types of process's mem/n");*
*printf("Text location:/n");*
*printf("/tAddress of main(Code Segment):%p/n",main);*
*printf("____________________________/n");*
*int stack_var0=2;*
*printf("Stack Location:/n");*
*printf("/tInitial end of stack:%p/n",&stack_var0);*
*int stack_var1=3;*
*printf("/tnew end of stack:%p/n",&stack_var1);*
*printf("____________________________/n");*
*printf("Data Location:/n");*
*printf("/tAddress of data_var(Data Segment):%p/n",&data_var0);*
*static int data_var1=4;*
*printf("/tNew end of data_var(Data Segment):%p/n",&data_var1);*
*printf("____________________________/n");*
*printf("BSS Location:/n");*
printf("/tAddress of bss_var:%p/n",&bss_var);
printf("____________________________/n");
char *b = sbrk((ptrdiff_t)0);
printf("Heap Location:/n");
printf("/tInitial end of heap:%p/n",b);
brk(b+4);
b=sbrk((ptrdiff_t)0);
printf("/tNew end of heap:%p/n",b);
return 0;
}
它的结果如下
below are addresses of types of process's mem
Text location:
Address of main(Code Segment):0x8048388
____________________________
Stack Location:
Initial end of stack:0xbffffab4
new end of stack:0xbffffab0
____________________________
Data Location:
Address of data_var(Data Segment):0x8049758
New end of data_var(Data Segment):0x804975c
____________________________
BSS Location:
Address of bss_var:0x8049864
____________________________
Heap Location:
Initial end of heap:0x8049868
New end of heap:0x804986c
利用size命令也可以看到程序的各段大小，比如执行size example会得到
text data bss dec hex filename
1654 2808 1942 796 example
但这些数据是程序编译的静态统计，而上面显示的是进程运行时动态值，但两者是对应的。
从前面的例子，我们对进程使用的逻辑内存分布已经先睹为快。这部分我们就继续进入操作系统内核看看进程对内存具体是如何进行分配和管理的。
从用户向内核看，所使用的内存表象形式会依次经历“逻辑地址”——“线形地址”——“物理地址”几种形式（关于几种地址的解释在前面已经讲述了）。逻辑地址经段机制转化成线性地址；线性地址又经过页机制转化为物理地址。（但是我们要知道Linux系统虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在Linux中逻辑地址就等于线性地址，它们的值是一样的）。沿着这条线索，我们所研究的主要问题也就集中在下面几个问题。
1.进程空间地址如何管理？
2.进程地址如何映射到物理内存？
3.物理内存如何被管理？
以及由上述问题引发的一些子问题。如系统虚拟地址分布;内存分配接口;连续内存分配与非连续内存分配等。
## 进程内存空间
Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是用户程序可使用比实际物理内存更大的地址空间（具体的原因请看硬件基础部分）。
在讨论进程空间细节前，请大家这里先要澄清下面几个问题。
l第一、4G的进程地址空间被人为的分为两个部分——用户空间与内核空间。用户空间从0到3G（0xC0000000），内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。例外情况只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。
l第二、用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表（init_mm.pgd），用户进程各自有不同的页表（。
l第三、每个进程的用户空间都是完全独立、互不相干的。不信的话，你可以把上面的程序同时运行10次（当然为了同时运行，让它们在返回前一同睡眠100秒吧），你会看到10个进程占用的线性地址一模一样。
### 进程内存管理
进程内存管理的对象是进程线性地址空间上的内存镜像,这些内存镜像其实就是进程使用的虚拟内存区域（memory region）。进程虚拟空间是个32或64位的“平坦”（独立的连续区间）地址空间（空间的具体大小取决于体系结构）。要统一管理这么大的平坦空间可绝非易事，为了方便管理，虚拟空间被化分为许多大小可变的(但必须是4096的倍数)内存区域，这些区域在进程线性地址中像停车位一样有序排列。这些区域的划分原则是“将访问属性一致的地址空间存放在一起”，所谓访问属性在这里无非指的是“可读、可写、可执行等”。
如果你要查看某个进程占用的内存区域，可以使用命令cat /proc/<pid>/maps获得（pid是进程号，你可以运行上面我们给出的例子——./example &;pid便会打印到屏幕），你可以发现很多类似于下面的数字信息。
由于程序example使用了动态库，所以除了example本身使用的的内存区域外，还会包含那些动态库使用的内存区域（区域顺序是：代码段、数据段、bss段）。
我们下面只抽出和example有关的信息，除了前两行代表的代码段和数据段外，最后一行是进程使用的栈空间。
-------------------------------------------------------------------------------
08048000 - 08049000 r-xp 00000000 03:03 439029/home/mm/src/example
08049000 - 0804a000 rw-p 00000000 03:03 439029/home/mm/src/example
……………
bfffe000 - c0000000 rwxp ffff000 00:00 0
----------------------------------------------------------------------------------------------------------------------
每行数据格式如下：
（内存区域）开始－结束访问权限偏移主设备号：次设备号 i节点文件。
注意，你一定会发现进程空间只包含三个内存区域，似乎没有上面所提到的堆、bss等，其实并非如此，程序内存段和进程地址空间中的内存区域是种模糊对应，也就是说，堆、bss、数据段（初始化过的）都在进程空间种由数据段内存区域表示。
在Linux内核中对应进程内存区域的数据结构是: vm_area_struct, 内核将每个内存区域作为一个单独的内存对象管理，相应的操作也都一致。采用面向对象方法使VMA结构体可以代表多种类型的内存区域－－比如内存映射文件或进程的用户空间栈等，对这些区域的操作也都不尽相同。
vm_area_strcut结构比较复杂，关于它的详细结构请参阅相关资料。我们这里只对它的组织方法做一点补充说明。vm_area_struct是描述进程地址空间的基本管理单元，对于一个进程来说往往需要多个内存区域来描述它的虚拟空间，如何关联这些不同的内存区域呢？大家可能都会想到使用链表，的确vm_area_struct结构确实是已链表形式链接，不过位了方便查找，内核又以红黑树（以前的内核使用平衡树）的形式组织内存区域，以便降低搜索耗时。并存两种组织形式，并非冗余：链表用于需要遍历全部节点的时候用，而红黑树适用于在地址空间中定位特定内存区域的时候。内核为了内存区域上的各种不同操作都能获得高性能，所以同时使用了这两种数据结构。
下图反映了进程地址空间的管理模型：
![](http://p.blog.csdn.net/images/p_blog_csdn_net/kanghua/vm_area_struct.bmp)
mmap
进程内存描述符
Vm_area_struct
进程虚拟地址
进程的地址空间对应的描述结构是“内存描述符结构”,它表示进程的全部地址空间，——包含了和进程地址空间有关的全部信息，其中当然包含进程的内存区域。
### 进程内存的分配与回收
创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()/brk()等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终多会归结到do_mmap（）函数上来（brk调用被单独以系统调用实现，不用do_mmap()），
内核使用do_mmap()函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的VMA了。但无论哪种情况， do_mmap()函数都会将一个地址区间加入到进程的地址空间中－－无论是扩展已存在的内存区域还是创建一个新的区域。
同样释放一个内存区域使用函数do_ummap(),它会销毁对应的内存区域。
### 如何由虚变实！
从上面已经看到进程所能直接操作的地址都为虚拟地址。当进程需要内存时，从内核获得的仅仅时虚拟的内存区域，而不是实际的物理地址，进程并没有获得物理内存（物理页框——页的概念请大家参与硬件基础一章），获得的仅仅是对一个新的线性地址区间的使用权。实际的物理内存只有当进程真的去访问新获取的虚拟地址时，才会由“请页机制”产生“缺页”异常，从而进入分配实际页框的例程。
该异常是虚拟内存机制赖以存在的基本保证——它会告诉内核去真正为进程分配物理页，并建立对应的页表，这之后虚拟地址才实实在在映射到了系统物理内存上。（当然如果页被换出到磁盘，也会产生缺页异常，不过这时不用再建立页表了）
这种请页机制把页框的分配推迟到不能再推迟为止，并不急于把所有的事情都一次做完（这中思想由点想涉及模式中的代理模式（proxy））。之所以能这么做是利用了内存访问的“局部性原理”，请页带来的好处是节约了空闲内存，提高了系统吞吐。要想更清楚的了解请页，可以看看《深入理解linux内核》一书。
这里我们需要说明在内存区域结构上的nopage操作，该操作是当发生访问的进程虚拟内存而发现并未真正分配页框时，该方法变被调用来分配实际的物理页，并为该页建立页表项。在最后的例子中我们会演示如何使用该方法。
## 系统物理内存管理
虽然应用程序操作的对象是映射到物理内存之上的虚拟内存，但是处理器直接操作的却是物理内存。所以当用程序访问一个虚拟地址时，首先必须将虚拟地址转化成物理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成，概括的讲，地址转换需要将虚拟地址分段，使每段虚地址都作为一个索引指向页表，而页表项则指向下一级别的页表或者指向最终的物理页面。
每个进程都有自己的页表。进程描述符号的pgd域指向的就是进程的页全局目录。席面我们借用《linux设备驱动程序》中的一幅图大致看看进程地址空间到物理页之间的转换关系。
上面的过程说起简单，做起难呀。因为在虚拟地址映射到页之前必须先分配物理页——也就是说必须先从内核获取空闲页，并建立页表。下面我们介绍一下内核管理物理内存的机制。
[[1]](http://writeblog.csdn.net/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&Toolbar=Default#_ftnref1)静态分配内存就是编译器在编译程序的时候根据源程序来分配内存. 动态分配内存就是在程序编译之后, 运行时调用运行时刻库函数来分配内存的. 静态分配由于是在程序运行之前,所以速度快, 效率高, 但是局限性大. 动态分配在程序运行时执行, 所以速度慢, 但灵活性高.
[[2]](http://writeblog.csdn.net/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&Toolbar=Default#_ftnref2)术语"BSS"已经有些年头了，它是*block started by symbol*的缩写。因为未初始化的变量没有对应的值,所以并不需要存储在可执行对象中。但是因为C标准强制规定未初始化的全局变量要被赋予特殊的默认值(基本上是0值)，所以内核要从可执行代码装入变量(未赋值的)到内存中，然后将零页映射到该片内存上，于是这些未初始化变量就被赋予了0值。这样做避免了在目标文件中进行显式地初始化，减少空间浪费
