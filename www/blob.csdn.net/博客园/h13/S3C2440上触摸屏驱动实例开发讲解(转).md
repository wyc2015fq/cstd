# S3C2440上触摸屏驱动实例开发讲解(转) - h13 - 博客园
- 共享资源，欢迎转载：[http://hbhuanggang.cublog.cn](http://hbhuanggang.cublog.cn/)
**一、开发环境**
- 主  机：VMWare--Fedora 9
- 开发板：Mini2440--64MB Nand, Kernel:2.6.30.4
- 编译器：arm-linux-gcc-4.3.2
**二、前提知识**
1、Linux输入子系统(Input Subsystem)：
   在Linux中，输入子系统是由输入子系统设备驱动层、输入子系统核心层(Input Core)和输入子系统事件处理层(Event Handler)组成。其中设备驱动层提供对硬件各寄存器的读写访问和将底层硬件对用户输入访问的响应转换为标准的输入事件，再通过核心层提交给事件处理层；而核心层对下提供了设备驱动层的编程接口，对上又提供了事件处理层的编程接口；而事件处理层就为我们用户空间的应用程序提供了统一访问设备的接口和驱动层提交来的事件处理。所以这使得我们输入设备的驱动部分不在用关心对设备文件的操作，而是要关心对各硬件寄存器的操作和提交的输入事件。下面用图形来描述一下这三者的关系吧！
![](http://blog.chinaunix.net/photo/101649_100129104623.png)
另外，又找了另一幅图来说明Linux输入子系统的结构，可能更加形象容易理解。如下：
![](http://blog.chinaunix.net/photo/101649_100225110636.png)
2、输入子系统设备驱动层实现原理：
在Linux中，Input设备用input_dev结构体描述，定义在input.h中。设备的驱动只需按照如下步骤就可实现了。
①、在驱动模块加载函数中设置Input设备支持input子系统的哪些事件；
②、将Input设备注册到input子系统中；
③、在Input设备发生输入操作时(如：键盘被按下/抬起、触摸屏被触摸/抬起/移动、鼠标被移动/单击/抬起时等)，提交所发生的事件及对应的键值/坐标等状态。
Linux中输入设备的事件类型有(这里只列出了常用的一些，更多请看linux/input.h中)：
`EV_SYN     0x00     同步事件`
```
EV_KEY     0x01     按键事件
EV_REL     0x02     相对坐标(如：鼠标移动，报告的是相对最后一次位置的偏移)
EV_ABS     0x03     绝对坐标(如：触摸屏和操作杆，报告的是绝对的坐标位置)
EV_MSC     0x04     其它
EV_LED     0x11     LED
EV_SND     0x12     声音
EV_REP     0x14     Repeat
EV_FF      0x15     力反馈
```
用于提交较常用的事件类型给输入子系统的函数有： 
```
void input_report_key(struct input_dev *dev, unsigned int code, int value); //提交按键事件的函数
void input_report_rel(struct input_dev *dev, unsigned int code, int value); //提交相对坐标事件的函数
void input_report_abs(struct input_dev *dev, unsigned int code, int value); //提交绝对坐标事件的函数
```
注意，在提交输入设备的事件后必须用下列方法使事件同步，让它告知input系统，设备驱动已经发出了一个完整的报告： 
`void input_sync(struct input_dev *dev)`
**三、触摸屏驱动的实现步骤**
1、硬件原理图分析：
   S3c2440芯片内部触摸屏接口与ADC接口是集成在一起的，硬件结构原理图请看：[S3C2440上ADC驱动实例开发讲解](http://blog.chinaunix.net/u3/101649/showart_2155714.html)中的图，其中通道7(XP或AIN7)作为触摸屏接口的X坐标输入，通道5(YP或AIN5)作为触摸屏接口的Y坐标输入。在"S3C2440上ADC驱动实例开发讲解"中，AD转换的模拟信号是由开发板上的一个电位器产生并通过通道1(AIN0)输入的，而这里的模拟信号则是由点触触摸屏所产生的X坐标和Y坐标两个模拟信号，并分别通过通道7和通道5输入。S3c2440提供的触摸屏接口有4种处理模式，分别是：正常转换模式、单独的X/Y位置转换模式、自动X/Y位置转换模式和等待中断模式，对于在每种模式下工作的要求，请详细查看数据手册的描述。本驱动实例将采用自动X/Y位置转换模式和等待中断模式。
注意：在每步中，为了让代码逻辑更加有条理和容易理解，就没有考虑代码的顺序，比如函数要先定义后调用。如果要编译此代码，请严格按照C语言的规范来调整代码的顺序。
2、建立触摸屏驱动程序my2440_ts.c，首先实现加载和卸载部分，在驱动加载部分，我们主要做的事情是：启用ADC所需要的时钟、映射IO口、初始化寄存器、申请中断、初始化输入设备、将输入设备注册到输入子系统。代码如下： 
```
```
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/clk.h>
#include <linux/init.h>
#include <linux/input.h>
#include <linux/serio.h>
#include <plat/regs-adc.h>
#include <asm/irq.h>
#include <asm/io.h>
```
` `
```
```
/*用于保存从平台时钟列表中获取的ADC时钟*/
static struct clk *adc_clk;
/*定义了一个用来保存经过虚拟映射后的内存地址*/
static void __iomem *adc_base;
/*定义一个输入设备来表示我们的触摸屏设备*/
static struct input_dev *ts_dev;
/*设备名称*/
#define DEVICE_NAME    "my2440_TouchScreen"
/*定义一个WAIT4INT宏，该宏将对ADC触摸屏控制寄存器进行操作
S3C2410_ADCTSC_YM_SEN这些宏都定义在regs-adc.h中*/
#define WAIT4INT(x)    (((x)<<8) | S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | \
                    S3C2410_ADCTSC_XP_SEN | S3C2410_ADCTSC_XY_PST(3))
static int __init ts_init(void)
{
    int ret;
    /*从平台时钟队列中获取ADC的时钟，这里为什么要取得这个时钟，因为ADC的转换频率跟时钟有关。
    系统的一些时钟定义在arch/arm/plat-s3c24xx/s3c2410-clock.c中*/
    adc_clk = clk_get(NULL, "adc");
    if(!adc_clk)
    {
        /*错误处理*/
        printk(KERN_ERR "falied to find adc clock source\n");
        return -ENOENT;
    }
    /*时钟获取后要使能后才可以使用，clk_enable定义在arch/arm/plat-s3c/clock.c中*/
    clk_enable(adc_clk);
    /*将ADC的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中。
     注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作,
     S3C2410_PA_ADC是ADC控制器的基地址，定义在mach-s3c2410/include/mach/map.h中，0x20是虚拟地址长度大小*/
    adc_base = ioremap(S3C2410_PA_ADC, 0x20);
    if(adc_base == NULL)
    {
        /*错误处理*/
        printk(KERN_ERR "failed to remap register block\n");
        ret = -EINVAL;
        goto err_noclk;
    }
    /*初始化ADC控制寄存器和ADC触摸屏控制寄存器*/
    adc_initialize();
    /*申请ADC中断，AD转换完成后触发。这里使用共享中断IRQF_SHARED是因为该中断号在ADC驱动中也使用了，
    最后一个参数1是随便给的一个值，因为如果不给值设为NULL的话，中断就申请不成功*/
    ret = request_irq(IRQ_ADC, adc_irq, IRQF_SHARED | IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);
    if(ret)
    {
        printk(KERN_ERR "IRQ%d error %d\n", IRQ_ADC, ret);
        ret = -EINVAL;
        goto err_nomap;
    }
    /*申请触摸屏中断，对触摸屏按下或提笔时触发*/
    ret = request_irq(IRQ_TC, tc_irq, IRQF_SAMPLE_RANDOM, DEVICE_NAME, 1);
    if(ret)
    {
        printk(KERN_ERR "IRQ%d error %d\n", IRQ_TC, ret);
        ret = -EINVAL;
        goto err_noirq;
    }
    /*给输入设备申请空间，input_allocate_device定义在input.h中*/
    ts_dev = input_allocate_device();
    /*下面初始化输入设备，即给输入设备结构体input_dev的成员设置值。
    evbit字段用于描述支持的事件，这里支持同步事件、按键事件、绝对坐标事件，
    BIT宏实际就是对1进行位操作，定义在linux/bitops.h中*/
    ts_dev->evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS); 
    
    /*keybit字段用于描述按键的类型，在input.h中定义了很多，这里用BTN_TOUCH类型来表示触摸屏的点击*/
    ts_dev->keybit[BITS_TO_LONGS(BTN_TOUCH)] = BIT(BTN_TOUCH);
    /*对于触摸屏来说，使用的是绝对坐标系统。这里设置该坐标系统中X和Y坐标的最小值和最大值(0-1023范围)
    ABS_X和ABS_Y就表示X坐标和Y坐标，ABS_PRESSURE就表示触摸屏是按下还是抬起状态*/
    input_set_abs_params(ts_dev, ABS_X, 0, 0x3FF, 0, 0);
    input_set_abs_params(ts_dev, ABS_Y, 0, 0x3FF, 0, 0);
    input_set_abs_params(ts_dev, ABS_PRESSURE, 0, 1, 0, 0);
    /*以下是设置触摸屏输入设备的身份信息，直接在这里写死。
    这些信息可以在驱动挂载后在/proc/bus/input/devices中查看到*/
    ts_dev->name          = DEVICE_NAME;   /*设备名称*/
    ts_dev->id.bustype    = BUS_RS232;     /*总线类型*/    
    ts_dev->id.vendor     = 0xDEAD;        /*经销商ID号*/
    ts_dev->id.product    = 0xBEEF;        /*产品ID号*/
    ts_dev->id.version    = 0x0101;        /*版本ID号*/
    /*好了，一些都准备就绪，现在就把ts_dev触摸屏设备注册到输入子系统中*/
    input_register_device(ts_dev);
    return 0;
/*下面是错误跳转处理*/
err_noclk:
    clk_disable(adc_clk);
    clk_put(adc_clk);
err_nomap:
    iounmap(adc_base);
err_noirq:
    free_irq(IRQ_ADC, 1);
    return ret;
}
/*初始化ADC控制寄存器和ADC触摸屏控制寄存器*/
static void adc_initialize(void)
{
    /*计算结果为(二进制)：111111111000000，再根据数据手册得知
    此处是将AD转换预定标器值设为255、AD转换预定标器使能有效*/
    writel(S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(0xFF), adc_base + S3C2410_ADCCON);
    /*对ADC开始延时寄存器进行设置，延时值为0xffff*/
    writel(0xffff, adc_base + S3C2410_ADCDLY);
    /*WAIT4INT宏计算结果为(二进制)：11010011，再根据数据手册得知
    此处是将ADC触摸屏控制寄存器设置成等待中断模式*/
    writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);
}
static void __exit ts_exit(void)
{
    /*屏蔽和释放中断*/
    disable_irq(IRQ_ADC);
    disable_irq(IRQ_TC);
    free_irq(IRQ_ADC, 1);
    free_irq(IRQ_TC, 1);
    /*释放虚拟地址映射空间*/
    iounmap(adc_base);
    /*屏蔽和销毁时钟*/
    if(adc_clk)
    {
        clk_disable(adc_clk);
        clk_put(adc_clk);
        adc_clk = NULL;
    }
    /*将触摸屏设备从输入子系统中注销*/
    input_unregister_device(ts_dev);
}
module_init(ts_init);
module_exit(ts_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Huang Gang");
MODULE_DESCRIPTION("My2440 Touch Screen Driver");
```
3、接下来要做的是，在两个中断服务程序中实现触摸屏状态和坐标的转换。先看代码，如下： 
```
/*定义一个外部的信号量ADC_LOCK，因为ADC_LOCK在ADC驱动程序中已申明
这样就能保证ADC资源在ADC驱动和触摸屏驱动中进行互斥访问*/
extern struct semaphore ADC_LOCK;
/*做为一个标签，只有对触摸屏操作后才对X和Y坐标进行转换*/
static int OwnADC = 0;
/*用于记录转换后的X坐标值和Y坐标值*/
static long xp;
static long yp;
/*用于计数对触摸屏压下或抬起时模拟输入转换的次数*/
static int count;
/*定义一个AUTOPST宏，将ADC触摸屏控制寄存器设置成自动转换模式*/
#define AUTOPST    (S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | \
                S3C2410_ADCTSC_AUTO_PST | S3C2410_ADCTSC_XY_PST(0))
/*触摸屏中断服务程序，对触摸屏按下或提笔时触发执行*/
static irqreturn_t tc_irq(int irq, void *dev_id)
{
    /*用于记录这一次AD转换后的值*/
    unsigned long data0;
    unsigned long data1;
    /*用于记录触摸屏操作状态是按下还是抬起*/
    int updown;
    /*ADC资源可以获取，即上锁*/
    if (down_trylock(&ADC_LOCK) == 0)
    {
        /*标识对触摸屏进行了操作*/
        OwnADC = 1;
        /*读取这一次AD转换后的值，注意这次主要读的是状态*/
        data0 = readl(adc_base + S3C2410_ADCDAT0);
        data1 = readl(adc_base + S3C2410_ADCDAT1);
        /*记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN*/
        updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));
        /*判断触摸屏的操作状态*/
        if (updown) 
        {
            /*如果是按下状态，则调用touch_timer_fire函数来启动ADC转换，该函数定义后面再讲*/
            touch_timer_fire(0);
        } 
        else 
        {
            /*如果是抬起状态，就结束了这一次的操作，所以就释放ADC资源的占有*/
            OwnADC = 0;
            up(&ADC_LOCK);
        }
    }
    return IRQ_HANDLED;
}
static void touch_timer_fire(unsigned long data)
{
    /*用于记录这一次AD转换后的值*/
      unsigned long data0;
      unsigned long data1;
    /*用于记录触摸屏操作状态是按下还是抬起*/
    int updown;
    /*读取这一次AD转换后的值，注意这次主要读的是状态*/
      data0 = readl(adc_base + S3C2410_ADCDAT0);
    data1 = readl(adc_base + S3C2410_ADCDAT1);
    /*记录这一次对触摸屏是压下还是抬起，该状态保存在数据寄存器的第15位，所以与上S3C2410_ADCDAT0_UPDOWN*/
     updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));
    /*判断触摸屏的操作状态*/
     if (updown) 
    {
        /*如果状态是按下，并且ADC已经转换了就报告事件和数据*/
         if (count != 0) 
        {
            long tmp;
                                                                                                 
            tmp = xp;
            xp = yp;
            yp = tmp;
                                                                                                 
            xp >>= 2;
            yp >>= 2;
#ifdef CONFIG_TOUCHSCREEN_MY2440_DEBUG
            /*触摸屏调试信息，编译内核时选上此项后，点击触摸屏会在终端上打印出坐标信息*/
            struct timeval tv;
            do_gettimeofday(&tv);
            printk(KERN_DEBUG "T: %06d, X: %03ld, Y: %03ld\n", (int)tv.tv_usec, xp, yp);
#endif
            /*报告X、Y的绝对坐标值*/
             input_report_abs(ts_dev, ABS_X, xp);
             input_report_abs(ts_dev, ABS_Y, yp);
            /*报告触摸屏的状态，1表明触摸屏被按下*/
            input_report_abs(ts_dev, ABS_PRESSURE, 1);
            /*报告按键事件，键值为1(代表触摸屏对应的按键被按下)*/
             input_report_key(ts_dev, BTN_TOUCH, 1);
            /*等待接收方受到数据后回复确认，用于同步*/
             input_sync(ts_dev); 
         }
        /*如果状态是按下，并且ADC还没有开始转换就启动ADC进行转换*/
         xp = 0;
         yp = 0;
         count = 0;
        /*设置触摸屏的模式为自动转换模式*/
         writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);
        /*启动ADC转换*/
         writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);
     } 
    else 
    {
        /*否则是抬起状态*/
         count = 0;
        /*报告按键事件，键值为0(代表触摸屏对应的按键被释放)*/
         input_report_key(ts_dev, BTN_TOUCH, 0);
        /*报告触摸屏的状态，0表明触摸屏没被按下*/
         input_report_abs(ts_dev, ABS_PRESSURE, 0);
        /*等待接收方受到数据后回复确认，用于同步*/
         input_sync(ts_dev);
        /*将触摸屏重新设置为等待中断状态*/
         writel(WAIT4INT(0), adc_base + S3C2410_ADCTSC);
        /*如果触摸屏抬起，就意味着这一次的操作结束，所以就释放ADC资源的占有*/
        if (OwnADC) 
        {
            OwnADC = 0;
            up(&ADC_LOCK);
        }
     }
}
/*定义并初始化了一个定时器touch_timer，定时器服务程序为touch_timer_fire*/
static struct timer_list touch_timer = TIMER_INITIALIZER(touch_timer_fire, 0, 0);
/*ADC中断服务程序，AD转换完成后触发执行*/
static irqreturn_t adc_irq(int irq, void *dev_id)
{
    /*用于记录这一次AD转换后的值*/
    unsigned long data0;
    unsigned long data1;
    if(OwnADC)
    {
        /*读取这一次AD转换后的值，注意这次主要读的是坐标*/
        data0 = readl(adc_base + S3C2410_ADCDAT0);
        data1 = readl(adc_base + S3C2410_ADCDAT1);
        /*记录这一次通过AD转换后的X坐标值和Y坐标值，根据数据手册可知，X和Y坐标转换数值
        分别保存在数据寄存器0和1的第0-9位，所以这里与上S3C2410_ADCDAT0_XPDATA_MASK就是取0-9位的值*/
        xp += data0 & S3C2410_ADCDAT0_XPDATA_MASK;
        yp += data1 & S3C2410_ADCDAT1_YPDATA_MASK;
        /*计数这一次AD转换的次数*/
        count++;
        if (count < (1<<2)) 
        {
            /*如果转换的次数小于4，则重新启动ADC转换*/
            writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, adc_base + S3C2410_ADCTSC);
            writel(readl(adc_base + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, adc_base + S3C2410_ADCCON);
        } 
        else 
        {
            /*否则，启动1个时间滴答的定时器，这是就会去执行定时器服务程序上报事件和数据*/
            mod_timer(&touch_timer, jiffies + 1);
            writel(WAIT4INT(1), adc_base + S3C2410_ADCTSC);
        }
    }
    return IRQ_HANDLED;
}
```
我们从整体上描述转换这个的过程：
(1)如果触摸屏感觉到触摸，则触发触摸屏中断即进入tc_irq，获取ADC_LOCK后判断触摸屏状态为按下，则调用touch_timer_fire启动ADC转换；
(2)当ADC转换启动后，触发ADC中断即进入adc_irq，如果这一次转换的次数小于4，则重新启动ADC进行转换，如果4次完毕后，启动1个时间滴答的定时器，停止ADC转换，也就是说在这个时间滴答内，ADC转换是停止的；
(3)这里为什么要在1个时间滴答到来之前停止ADC的转换呢？这是为了防止屏幕抖动。
(4)如果1个时间滴答到来则进入定时器服务程序touch_timer_fire，判断触摸屏仍然处于按下状态则上报事件和转换的数据，并重启ADC转换，重复第(2)步；
(5)如果触摸抬起了，则上报释放事件，并将触摸屏重新设置为等待中断状态。
**四、移植和测试触摸屏驱动程序**
移植和测试请看[Linux-2.6.30.4在2440上的移植之触摸屏驱动](http://blog.chinaunix.net/u3/101649/showart_2085414.html)
