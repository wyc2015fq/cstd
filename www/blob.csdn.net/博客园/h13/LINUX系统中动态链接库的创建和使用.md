# LINUX系统中动态链接库的创建和使用 - h13 - 博客园
    大家都知道，在windows系统中有非常多的动态链接库(以.dll为后缀的文件，dll即dynamic link library)。这种动态链接库，和静态函数库不同，他里面的函数并不是执行程式本身的一部分，而是根据执行程式需要按需装入，同时其执行代码可在多个执行程式间共享，节省了空间，提高了效率，具有非常高的灵活性，得到越来越多程式员和用户的青睐。那么，在linux系统中有无这样的函数库呢？ 
    答案是肯定的，linux的动态链接库不仅有，而且为数不少。在/lib目录下，就有许多以.so作后缀的文件，这就是linux系统应用的动态链接库，只不过和windows叫法不同，他叫so，即shared object，共享对象。(在linux下，静态函数库是以.a作后缀的) x-window作为linux下的标准图像窗口界面，他本身就采用了非常多的动态链接库(在/usr/x11r6/lib目录下)，以方便程式间的共享，节省占用空间。著名的apache网页服务器，也采用了动态链接库，以便扩充程式功能。你只需将php动态链接库拷到其共享目录，修改一下设置，apache就能支持php网页了。如果你愿意，能自己编写动态链接库，让apache支持你自己定义的网页格式。这就是动态链接的好处。 
1、linux下动态链接库的创建 
在linux系统下，创建动态链接库是件再简单不过的事情。只要在编译函数库源程式时加上-shared选项即可，这样所生成的执行程式即为动态链接库。从某种意义上来说，动态链接库也是一种执行程式。按一般规则，程式名应带.so后缀。下面举个例子说说。 
我准备编写两个函数，一个用于查询当前日期getdate，一个用于查询当前时间gettime，并将这两个函数存于动态链接库my.so中。为此，需要做以下几项工作。 
1.1 编写用户接口文件datetime.h，内容如下(每行前面的数字为行号)： 
---------------------------------------------------------------------- 
```
/* datetime.h : 纵横软件制作中心雨亦奇编写, 2001-06-28. */ 
 
 #ifndef __datetime_h 
 
 #define __datetime_h 
 
 /* 日期结构 */ 
 typedef struct 
 { 
 int year; 
 int mon; 
 int day; 
 }datetype; 
 
 /* 时间结构 */ 
 typedef struct 
 { 
 char hour; 
 char min; 
 char sec; 
 }timetype; 
 
 /* 函数原型说明 */ 
 
 #ifdef shared 
 int (*getdate)(datetype *d); 
 #else 
 int getdate(datetype *d); 
 #endif 
 
 #ifdef shared 
 int (*gettime)(timetype *t); 
 #else 
 int gettime(timetype *t); 
 #endif 
 
 #endif 
 
/*---------------------------------------------------------------------- 
这个用户接口文件中，先定义了日期和时间结构，接着定义一下函数的原型。动态函数和静态函数的原型说明不
同的是，动态函数应使用(*函数名)的形式，以便引用其指针。若要引用文件中的动态函数说明，用户应该定义
一下shared宏，这样才能使用。 
1.2 编写getdate.c，源程式如下： 
---------------------------------------------------------------------- */
 /* getdate.c : 纵横软件制作中心雨亦奇编写, 2001-06-28. */ 
 
 #include "time.h" 
 #include "datetime.h" 
 
 int getdate(datetype *d) 
 { 
   long ti; 
   struct tm *tm; 
 
   time(&ti); 
   tm=localtime(&ti); 
   d->year=tm->tm_year+1900; 
   d->mon=tm->tm_mon+1; 
   d->day=tm->tm_mday; 
 }
```
---------------------------------------------------------------------- 
在getdate函数中，先调用time取得以秒计的系统时间，再用localtime函数转换一下时间结构，最后调整得到正确的日期。 
1.3 编写gettime.c，源程式如下： 
---------------------------------------------------------------------- 
```
/* gettime.c : 纵横软件制作中心雨亦奇编写, 2001-06-28. */ 
 
 #include "time.h" 
 #include "datetime.h" 
 
 int gettime(timetype *t) 
 { 
 long ti; 
 struct tm *tm; 
 
 time(&ti); 
 tm=localtime(&ti); 
 t->hour=tm->tm_hour; 
 t->min=tm->tm_min; 
 t->sec=tm->tm_sec; 
 }
```
---------------------------------------------------------------------- 
gettime函数和getdate函数相仿，先用time函数取得以秒计的系统时间，再用localtime函数转换一下时间结构，最后返回当前的时间(不需调整)。 
1.4 编写维护文件makefile-lib，内容如下： 
---------------------------------------------------------------------- 
```
# makefile-lib : 纵横软件制作中心雨亦奇编写, 2001-06-28. 
 
 all : my.so 
 
 src = getdate.c gettime.c 
 
 tgt = $(src:.c=.o) 
 
 $(src) : datetime.h 
 @touch $@ 
 
 %.o : %.c 
 cc -c $? 
 
 # 动态函数库(my.so)生成 
 my.so : $(tgt) 
 cc -shared -o $@ $(tgt)
```
---------------------------------------------------------------------- 
编写维护文件的目的，在于方便程式员维护程式，尤其是维护比较大的工程项目。一个素质良好的程式员应该学会熟练地编写维护文件makefile。定义了文件间的依赖关系后，一旦源文件发生变化，仅需make一下，其目标文件维护代码会自动执行，从而自动更新目标文件，减少了许多工作量。注意: 每行维护代码必须以tab(跳格键)开始，不是的话make时将出错。 
本维护文件第1行是注释行，以#号开头；文件第3行定义所有需要维护的函数库；第5行定义相关源程式文件；第7行定义目标文件；第9-10行说明所有源程式依赖于datetime.h头文件，并有相应维护代码，即touch一下，更新一下源文件的时间；第12-13行定义.o文件依赖于相应的.c文件，并指定了维护代码，即用cc编译一下；第16-17行定义共享库my.so依赖的目标文件，维护代码中用-shared编译选项，以生成动态链接库my.so。 
1.5 运行make -f makefile-lib 命令 
make运行后，动态链接库my.so就产生了，我们就能在程式中调用了。如果想让系统所有用户都能使用，则应以root用户登录系统，将这个库拷贝到/lib目录下(命令：cp my.so /lib)，或在/lib目录下建个符号连接即可(命令：ln -s `pwd`/my.so /lib)。 
2、linux下动态链接库的使用 
2.1 重要的dlfcn.h头文件 
linux下使用动态链接库，源程式需要包含dlfcn.h头文件，此文件定义了调用动态链接库的函数的原型。下面周详说明一下这些函数。 
2.1.1 dlerror 
原型为: const char *dlerror(void); 
当动态链接库操作函数执行失败时，dlerror能返回出错信息，返回值为null时表示操作函数执行成功。 
2.1.2 dlopen 
原型为: void *dlopen (const char *filename, int flag); 
dlopen用于打开指定名字(filename)的动态链接库，并返回操作句柄。 
filename: 如果名字不以/开头，则非绝对路径名，将按下列先后顺序查找该文件。 
(1) 用户环境变量中的ld_library值； 
(2) 动态链接缓冲文件/etc/ld.so.cache 
(3) 目录/lib，/usr/lib 
flag表示在什么时候解决未定义的符号(调用)。取值有两个: 
1) rtld_lazy : 表明在动态链接库的函数代码执行时解决。 
2) rtld_now : 表明在dlopen返回前就解决所有未定义的符号，一旦未解决，dlopen将返回错误。 
dlopen调用失败时，将返回null值，否则返回的是操作句柄。 
2.1.3 dlsym : 取函数执行地址 
原型为: void *dlsym(void *handle, char *symbol); 
dlsym根据动态链接库操作句柄(handle)和符号(symbol)，返回符号对应的函数的执行代码地址。由此地址，能带参数执行相应的函数。 
如程式代码: void (*add)(int x,int y); /* 说明一下要调用的动态函数add */ 
add=dlsym("xxx.so","add"); /* 打开xxx.so共享库,取add函数地址 */ 
add(89,369); /* 带两个参数89和369调用add函数 */ 
2.1.4 dlclose : 关闭动态链接库 
原型为: int dlclose (void *handle); 
dlclose用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。 
2.2 在程式中使用动态链接库函数 
2.2.1 程式范例 
下面的程式装载了动态链接库my.so，并用getdate,gettime取得当前日期和时间后输出。 
---------------------------------------------------------------------- 
```
1 /************************************/ 
2 /* 文件名称: dy.c */ 
3 /* 功能描述: 动态链接库应用示范程式 */ 
4 /* 程式编写: 纵横软件制作中心雨亦奇 */ 
5 /* 编写时间: 2001-06-28 */ 
6 /************************************/ 
7 
8 #include "stdio.h" /* 包含标准输入输出文件 */ 
9 
10 #include "dlfcn.h" /* 包含动态链接功能接口文件 */ 
11 #define sofile "./my.so" /* 指定动态链接库名称 */ 
12 
13 #define shared /* 定义宏,确认共享,以便引用动态函数 */ 
14 #include "datetime.h" /* 包含用户接口文件 */ 
15 
16 main() 
17 { 
18 datetype d; 
19 timetype t; 
20 void *dp; 
21 char *error; 
22 
23 puts("动态链接库应用示范"); 
24 
25 dp=dlopen(sofile,rtld_lazy); /* 打开动态链接库 */ 
26 
27 if (dp==null) /* 若打开失败则退出 */ 
28 { 
29 fputs(dlerror(),stderr); 
30 exit(1); 
31 } 
32 
33 getdate=dlsym(dp,"getdate"); /* 定位取日期函数 */ 
34 
35 error=dlerror(); /* 检测错误 */ 
36 if (error) /* 若出错则退出 */ 
37 { 
38 fputs(error,stderr); 
39 exit(1); 
40 } 
41 
42 getdate(&d); /* 调用此共享函数 */ 
43 printf("当前日期: %04d-%02d-%02d＼n",d.year,d.mon,d.day); 
44 
45 gettime=dlsym(dp,"gettime"); /* 定位取时间函数 */ 
46 
47 error=dlerror(); /* 检测错误 */ 
48 if (error) /* 若出错则退出 */ 
49 { 
50 fputs(error,stderr); 
51 exit(1); 
52 } 
53 
54 gettime(&t); /* 调用此共享函数 */ 
55 printf("当前时间: %02d:%02d:%02d＼n",t.hour,t.min,t.sec); 
56 
57 dlclose(dp); /* 关闭共享库 */ 
58 
59 exit(0); /* 成功返回 */ 
60 
61 }
```
---------------------------------------------------------------------- 
程式说明: 
第8行: 包含标准输入输出头文件,因为程式中使用了printf,puts,fputs等标准输入输出函数,需要让编译器根据头文件中函数的原型,检查一下语法; 
第10-11行: 包含动态链接库功能头文件,并定义动态链接库名称; 
第13-14行: 定义宏shared以便引用14行的头文件datetime.h中的动态函数说明; 
第25行: 用dlopen打开sofile共享库,返回句柄dp; 
第27-31行: 检测dp是否为空,为空则显示错误后退出; 
第33行: 用dlsym取得getdate函数动态地址; 
第35-40行: 如果dlerror返回值不为空,则dlsym执行出错,程式显示错误后退出; 
第42-43行: 执行getdate调用,输出当前日期; 
第45行: 用dlsym取得gettime函数动态地址; 
第47-52行: 如果dlerror返回值不为空,则dlsym执行出错,程式显示错误后退出; 
第54-55行: 执行gettime调用,输出当前时间; 
第57行: 用dlclose关闭dp所指示的动态链接库; 
第59行: 程式退出,返回0值。 
2.2.2 编写维护文件 
维护文件makefile内容如下: 
---------------------------------------------------------------------- 
```
1 # makefile : 纵横软件制作中心雨亦奇编写, 2001-06-28. 
2 
3 all : dy 
4 
5 dysrc = dy.c 
6 
7 dytgt = $(dysrc:.c=.o) 
8 
9 %.o : %.c 
10 cc -c $? 
11 
12 # 动态库应用示范程式 
13 dy : $(dytgt) 
14 cc -rdynamic -s -o $@ $(dytgt) -ldl 
15
```
---------------------------------------------------------------------- 
维护文件说明: 
第3行: 定义所有需要维护的模块; 
第5行: 定义源程式; 
第7行: 定义目标文件; 
第9-10行: 定义.o文件依赖于.c文件,维护代码为“cc -c 变动的源文件名”; 
第13-14行: 定义dy依赖于变量dytgt指示的值,维护代码中采用-rdynamic选项以指定输出文件为动态链接的方式，选项-s指定删除目标文件中的符号表,最后的选项-ldl则指示装配程式ld需要装载dl函数库。 
2.2.3 运行make命令 
运行make后将产生执行文件dy，运行后将产生如下类似信息： 
动态链接库应用示范 
当前日期: 2001-06-28 
当前时间: 10:06:21 
当删除my.so文件时,将出现以下信息: 
动态链接库应用示范 
my.so: cannot open shared object file: 文件或目录不存在 
3、小结 
linux创建和使用动态链接库并不是一件难事。 
编译函数源程式时选用-shared选项即可创建动态链接库，注意应以.so后缀命名，最佳放到公用库目录(如/lib,/usr/lib等)下面，并要写好用户接口文件，以便其他用户共享。 
使用动态链接库，源程式中要包含dlfcn.h头文件，写程式时注意dlopen等函数的正确调用，编译时要采用-rdynamic选项和-ldl选项，以产生可调用动态链接库的执行代码。 
