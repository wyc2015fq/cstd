# S3C2440上ADC驱动实例开发讲解 - h13 - 博客园
**一、开发环境**
- 主  机：VMWare--Fedora 9
- 开发板：Mini2440--64MB Nand, Kernel:2.6.30.4
- 编译器：arm-linux-gcc-4.3.2
**二、硬件原理分析**
                               S3C2440内部ADC结构图
![S3C2440上ADC驱动实例开发讲解 - Noah - Noah](http://blog.chinaunix.net/photo/101649_100121103629.png)
我们从上面的结构图和数据手册可以知道，该ADC模块总共有8个通道可以进行模拟信号的输入，分别是AIN0、AIN1、AIN2、AIN3、YM、YP、XM、XP。那么ADC是怎么实现模拟信号到数字信号的转换呢？首先模拟信号从任一通道输入，然后设定寄存器中预分频器的值来确定AD转换器频率，最后ADC将模拟信号转换为数字信号保存到ADC数据寄存器0中(ADCDAT0)，然后ADCDAT0中的数据可以通过中断或查询的方式来访问。对于ADC的各寄存器的操作和注意事项请参阅数据手册。
![S3C2440上ADC驱动实例开发讲解 - Noah - Noah](http://blog.chinaunix.net/photo/101649_100121105900.png)
上图是mini2440上的ADC应用实例，开发板通过一个10K的电位器(可变电阻)来产生电压模拟信号，然后通过第一个通道(即：AIN0)将模拟信号输入ADC。
**三、实现步骤**
ADC设备在Linux中可以看做是简单的字符设备，也可以当做是一混杂设备(misc设备)，这里我们就看做是misc设备来实现ADC的驱动。注意：这里我们获取AD转换后的数据将采用中断的方式，即当AD转换完成后产生AD中断，在中断服务程序中来读取ADCDAT0的第0-9位的值(即AD转换后的值)。
1、建立驱动程序文件my2440_adc.c，实现驱动的初始化和退出，代码如下： 
#include<linux/errno.h>
#include<linux/kernel.h>
#include<linux/module.h>
#include<linux/init.h>
#include<linux/input.h>
#include<linux/serio.h>
#include<linux/clk.h>
#include<linux/miscdevice.h>
#include<asm/io.h>
#include<asm/irq.h>
#include<asm/uaccess.h>
/*定义了一个用来保存经过虚拟映射后的内存地址*/
staticvoid __iomem *adc_base;
/*保存从平台时钟队列中获取ADC的时钟*/
staticstruct clk *adc_clk;
/*申明并初始化一个信号量ADC_LOCK，对ADC资源进行互斥访问*/
DECLARE_MUTEX(ADC_LOCK);
staticint __init adc_init(void)
{
int ret;
/*从平台时钟队列中获取ADC的时钟，这里为什么要取得这个时钟，因为ADC的转换频率跟时钟有关。
    系统的一些时钟定义在arch/arm/plat-s3c24xx/s3c2410-clock.c中*/
    adc_clk = clk_get(NULL,"adc");
if(!adc_clk)
{
/*错误处理*/
        printk(KERN_ERR "failed to find adc clock source\n");
return-ENOENT;
}
/*时钟获取后要使能后才可以使用，clk_enable定义在arch/arm/plat-s3c/clock.c中*/
    clk_enable(adc_clk);
/*将ADC的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中。
     注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作,
     S3C2410_PA_ADC是ADC控制器的基地址，定义在mach-s3c2410/include/mach/map.h中，0x20是虚拟地址长度大小*/
    adc_base = ioremap(S3C2410_PA_ADC, 0x20);
if(adc_base ==NULL)
{
/*错误处理*/
        printk(KERN_ERR "Failed to remap register block\n");
        ret =-EINVAL;
goto err_noclk;
}
/*把看ADC注册成为misc设备，misc_register定义在miscdevice.h中
     adc_miscdev结构体定义及内部接口函数在第②步中讲,MISC_DYNAMIC_MINOR是次设备号，定义在miscdevice.h中*/
    ret = misc_register(&adc_miscdev);
if(ret)
{
/*错误处理*/
        printk(KERN_ERR "cannot register miscdev on minor=%d (%d)\n", MISC_DYNAMIC_MINOR, ret);
goto err_nomap;
}
    printk(DEVICE_NAME " initialized!\n");
return 0;
//以下是上面错误处理的跳转点
err_noclk:
    clk_disable(adc_clk);
    clk_put(adc_clk);
err_nomap:
    iounmap(adc_base);
return ret;
}
staticvoid __exit adc_exit(void)
{
    free_irq(IRQ_ADC, 1);/*释放中断*/
    iounmap(adc_base);/*释放虚拟地址映射空间*/
if(adc_clk)/*屏蔽和销毁时钟*/
{
        clk_disable(adc_clk);
        clk_put(adc_clk);
        adc_clk =NULL;
}
    misc_deregister(&adc_miscdev);/*注销misc设备*/
}
/*导出信号量ADC_LOCK在触摸屏驱动中使用，因为触摸屏驱动和ADC驱动公用
  相关的寄存器，为了不产生资源竞态，就用信号量来保证资源的互斥访问*/
EXPORT_SYMBOL(ADC_LOCK);
module_init(adc_init);
module_exit(adc_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Huang Gang");
MODULE_DESCRIPTION("My2440 ADC Driver");DE>
2、adc_miscdev结构体定义及内部各接口函数的实现，代码如下： 
#include<plat/regs-adc.h>
/*设备名称*/
#define DEVICE_NAME    "my2440_adc"
/*定义并初始化一个等待队列adc_waitq，对ADC资源进行阻塞访问*/
static DECLARE_WAIT_QUEUE_HEAD(adc_waitq);
/*用于标识AD转换后的数据是否可以读取，0表示不可读取*/
staticvolatileint ev_adc = 0;
/*用于保存读取的AD转换后的值，该值在ADC中断中读取*/
staticint adc_data;
/*misc设备结构体实现*/
staticstruct miscdevice adc_miscdev =
{
.minor   = MISC_DYNAMIC_MINOR,/*次设备号，定义在miscdevice.h中，为255*/
.name    = DEVICE_NAME,/*设备名称*/
.fops    =&adc_fops,/*对ADC设备文件操作*/
};
/*字符设备的相关操作实现*/
staticstruct file_operations adc_fops =
{
.owner    = THIS_MODULE,
.open= adc_open,
.read= adc_read,
.release  = adc_release,
};
/*ADC设备驱动的打开接口函数*/
staticint adc_open(struct inode *inode,structfile*file)
{
int ret;
/*申请ADC中断服务，这里使用的是共享中断:IRQF_SHARED,为什么要使用共享中断，因为在触摸屏驱动中
     也使用了这个中断号。中断服务程序为:adc_irq在下面实现，IRQ_ADC是ADC的中断号，这里注意：
     申请中断函数的最后一个参数一定不能为NULL，否则中断申请会失败，如果中断服务程序中用不到这个
     参数，就随便给个值就好了，我这里就给个1*/
    ret = request_irq(IRQ_ADC, adc_irq, IRQF_SHARED, DEVICE_NAME, 1);
if(ret)
{
/*错误处理*/
        printk(KERN_ERR "IRQ%d error %d\n", IRQ_ADC, ret);
return-EINVAL;
}
return 0;
}
/*ADC中断服务程序，该服务程序主要是从ADC数据寄存器中读取AD转换后的值*/
static irqreturn_t adc_irq(int irq,void*dev_id)
{
/*保证了应用程序读取一次这里就读取AD转换的值一次，
     避免应用程序读取一次后发生多次中断多次读取AD转换值*/
if(!ev_adc)
{
/*读取AD转换后的值保存到全局变量adc_data中，S3C2410_ADCDAT0定义在regs-adc.h中，
         这里为什么要与上一个0x3ff，很简单，因为AD转换后的数据是保存在ADCDAT0的第0-9位，
         所以与上0x3ff(即：1111111111)后就得到第0-9位的数据，多余的位就都为0*/
        adc_data = readl(adc_base + S3C2410_ADCDAT0)& 0x3ff;
/*将可读标识为1，并唤醒等待队列*/
        ev_adc = 1;
        wake_up_interruptible(&adc_waitq);
}
return IRQ_HANDLED;
}
/*ADC设备驱动的读接口函数*/
static ssize_t adc_read(structfile*filp,char*buffer,size_tcount, loff_t *ppos)
{
/*试着获取信号量(即：加锁)*/
if(down_trylock(&ADC_LOCK))
{
return-EBUSY;
}
if(!ev_adc)/*表示还没有AD转换后的数据，不可读取*/
{
if(filp->f_flags & O_NONBLOCK)
{
/*应用程序若采用非阻塞方式读取则返回错误*/
return-EAGAIN;
}
else/*以阻塞方式进行读取*/
{
/*设置ADC控制寄存器，开启AD转换*/
            start_adc();
/*使等待队列进入睡眠*/
            wait_event_interruptible(adc_waitq, ev_adc);
}
}
/*能到这里就表示已有AD转换后的数据，则标识清0，给下一次读做判断用*/
    ev_adc = 0;
/*将读取到的AD转换后的值发往到上层应用程序*/
    copy_to_user(buffer,(char*)&adc_data,sizeof(adc_data));
/*释放获取的信号量(即：解锁)*/
    up(&ADC_LOCK);
returnsizeof(adc_data);
}
/*设置ADC控制寄存器，开启AD转换*/
staticvoid start_adc(void)
{
unsignedint tmp;
    tmp =(1 << 14)|(255 << 6)|(0 << 3);/* 0 1 00000011 000 0 0 0 */
    writel(tmp, adc_base + S3C2410_ADCCON);/*AD预分频器使能、模拟输入通道设为AIN0*/
    tmp = readl(adc_base + S3C2410_ADCCON);
    tmp = tmp |(1 << 0);/* 0 1 00000011 000 0 0 1 */
    writel(tmp, adc_base + S3C2410_ADCCON);/*AD转换开始*/
}
/*ADC设备驱动的关闭接口函数*/
staticint adc_release(struct inode *inode,structfile*filp)
{
return 0;
}
注意：在上面实现的每步中，为了让代码逻辑更加有条理和容易理解，就没有考虑代码的顺序，比如函数要先定义后调用。如果要编译此代码，请严格按照C语言的规范来调整代码的顺序。
3、编写用户应用程序测试my2440_adc驱动。建立应用程序adc_test.c，代码如下： 
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(int argc,char**argv)
{
int fd;
//以阻塞方式打开设备文件，非阻塞时flags=O_NONBLOCK
    fd =open("/dev/my2440_adc", 0);
if(fd < 0)
{
printf("Open ADC Device Faild!\n");
exit(1);
}
while(1)
{
int ret;
int data;
//读设备
        ret =read(fd,&data,sizeof(data));
if(ret !=sizeof(data))
{
if(errno!= EAGAIN)
{
printf("Read ADC Device Faild!\n");
}
continue;
}
else
{
printf("Read ADC value is: %d\n", data);
}
}
close(fd);
return 0;
}
4、将驱动程序下载挂载到内核，下载应用程序到开发板上后，运行应用程序，扭动mini2440开发板上的定位器，可以观察到ADC转换值的变化，证明驱动程序工作正常。效果图如下：
![S3C2440上ADC驱动实例开发讲解 - Noah - Noah](http://blog.chinaunix.net/photo/101649_100127165746.png)
