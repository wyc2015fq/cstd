# Perl语言入门--4--列表 - 默槑 - 博客园







# [Perl语言入门--4--列表](https://www.cnblogs.com/modaidai/p/7368081.html)





1、列表也是数组的形式：(1,'a',2,3,4)

　　元素可以是任意类型，变量，表达式

2、空列表：()

　　单元素列表:(2)  。与值2不同

　　qw(1 $a str)  　　#qw是用空格作为分隔符，元素中不能有空格，否则视为两个元素，()可变为<>

3、范围运算符：..

![](https://images2017.cnblogs.com/blog/1038110/201708/1038110-20170815150307443-1285485668.png)

4、数组：列表的存储

形式：@a=(1,2,3)

　　与$a是不同的变量

　　@a的初始值是空 ：()

元素形式:   $a[0]   #注意是$  美元符号

　　负索引：倒数第一是-1  $a[-1]

5、数组的赋值：

　　@a=(1,2,3,4)

　　@a=(1,2,3,4),@a=@b

　　@b=(2,3),@a=(1,@b,4)

　　@b='a' x 4; @b=('a','a','a','a') 

　　@b = <>; 从标准输入(键盘)读出一行赋予元素，最后用 ctrl+d结束输入

　　元素操作：

　　　　改变元素的值：$a[1] = 3 ;  @a=(1,3,3,4)

　　　　对超出数组大小的元素赋值： $a[5]=6 ; @a=(1,2,3,4,"",6)  数组自动增长，原来没有的元素值为NULL

　　　　读不存在的元素为空: $x = $a[7] ;

6、数组的读取

　　单个元素的读取： $a=$a[1]

　　多个元素的读取： 

　　　　　　每个元素对应到变量： @a=(1,2,3) ;($x,$y,$z)=@a; - ->$x=1 $y=2 $z=3

　　　　　　多余的变量为空：($x,$y,$z,$zz)=@a; - ->$x=1 $y=2 $z=3 $zz=""

　　一些用法：

　　　　$a =@a;       #这样$a的值是@a的长度  

　　　　($a) =@a;    #这样$a的值是@a的第一个元素

　　　　$a=(1,2,3)    #把一个列表直接赋值给变量 则$a =最右面的元素 也就是3

　　　　$#a :它的值是元素的最后一个元素的索引。加1即为长度。但对其赋值就改变了数组的长度

　　数组的输出：

　　　　print @a   　　中间没空格

　　　　print "@a"       中间有空格

7、数组片段：访问数组的部分元素，而不是全部元素

　　用法：

　　　　@a =(1,2,3,4,5)

　　　　读出：@sub = @a [0,1,3]   @sub=(1,2,4)

　　　　赋值：@a[1,3]=('a','b') ;  @a =(1,'a',3,'b',5)

　　范围：

　　　　@sub = @a[1..3]  　　　　　　　   则 @sub=(2,3,4)

　　　　$x = 1,$y=3;@sub=@a[$x..$y]; 　　则 @sub=(2,3,4)    #这样指代也可以

　　列表：

　　　　@b=(1,2,3); @sub = @a[@b];　　   则@sub=(2,3,4)

　　　　@b=(2,3); @sub=@a[1,@b];　　     则 @sub=(2,3,4)

　　　　($a,@b,$c)=(1,2,3,4,5); 　　　　      则@b=(2,3,4,5) ,$c=""

　　数组元素的重叠：

　　　　交换：@a[1,2]=@[2,1]   @a=(2,1,3,4,5)

　　　　重叠：@a[1,2,3]=@a[3,2,4]   @a=(1,4,3,5,5)

8、数组操作函数

　　@a = (1,12,4,8,20)

　　1、sort {代码块}(数组):

　　　　不要代码块时：print sort(@a);    #(1,12,20,,4,8)

　　　　怎么实现大小的排序呢：print sort {$a<=>$b}(@a);    #这是默认方式，记住就好 (1,4,8,12,20)

　　2、reverse @a: 数组的反序

　　3、chop  @a ：数组的每一个元素都截取最后一个字符

　　4、shift (@a) ：删除数组第一个元素，返回删除的元素。如直接输出shift()，则对@ARGV数组使用 

　　5、unshift(@a,$a)：在数组开头增加元素，返回新数组长度

　　6、push(@a,$a)：在数组末尾增加元素

　　7、pop(@a) : 在数组末尾删除元素

　　8、join('连接符',@a)把数组连接成一个字符串

　　　　　　@a=('a','b');  join('_',@a);      - ->  'a_b'

　　　　　　　　　　　　join('_','a','b');    - -> 'a_b'

　　9、split(/模式/,分割串,长度)

　　　　　　模式：缺省为空格，可省略

　　　　　　分割串：缺省为$_，可省略

　　　　　　长度：分割成几个元素，可省略，则全部分割

　　　　　　$s='a,b,c'; @a=split(/,/,$s); @a=('a','b','c')     　　#以逗号为分割符进行切割

　　　　　　　　　　   @a=split(/,/,$s,2);  @a= (     'a'   ,     'b,c'    )       #指定数组的长度为2，只有@a[0]  和@a[1]

　　10、wantarray():当期望返回数组时为真，返回简单变量时为假

　　　　　　先定义一个子函数：sub mysub() {print wantarray() ? "数组\t" : "变量\n" ;}

　　　　　　然后在用：@a=mysub;

　　　　　　　　　　　$a=mysub;             #第一个输出数组  第二个输出变量  

　　11、splice：

　　　　@a=splice(@a,skip,length,@newlist)

　　　　　对@a操作，跳过skip个元素，然后开始用@newlist替换length个元素。@newlist和length可以不等长，无论@newlist多长，它只占用（或者说替换）length长的元素位置

　　　　   #当length=0时为插入。splice(@a,-1,0,@n)    #在末尾追加

　　　　   #当@newlist为空则为删除

　　　　　#当@newlist和length都省略时，其后的全部删除。split(@a,3);  

　　12、正则表达式在数组中的用法

　　　　　　@found=grep(/patten/,@search) 对 @search的每一个元素进行搜索，匹配的元素返回到@found数组中

　　13、map　　

　　　　　　map(expr,@list );   对每一个元素进行expr(你指定让他干啥他干啥) ，返回运算后的数组。元素用$_代表。

　　　　　　举个栗子：

　　　　　　　　map($_+1,(1,2))  - ->(2,3)

　　14、二维数组

　　　　　　$aoa=[[1,2,3,]],['a','b','c']   #至于为什么美元符  记住就好

　　　　　　　　内含两个子数组         (1,2,3)   ('a','b','c')

　　　　　　子数组访问：@{$aoa -> 0}                                                 #至于为什么这样访问  记住就好  @开头 紧接着用大括号{}圈起来

　　　　　　子数组元素访问：@{$aoa -> 0}[0,1]

　　　　　　元素访问   ： $aoa ->[0][0]



　　　　　　有一维数组构成二维数组：

　　　　　　　　@a=(1,2,3)

　　　　　　　　@b=('a','b','c')

　　　　　　　　$aoa=[[@a],[@b]];
















