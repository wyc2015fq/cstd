# Google揭开Mesa的神秘面纱——一个具备跨地域复制和近实时特性的可伸缩数据仓库 - =朝晖= - 博客园
# [Google揭开Mesa的神秘面纱——一个具备跨地域复制和近实时特性的可伸缩数据仓库](https://www.cnblogs.com/dhcn/p/7412473.html)
http://www.infoq.com/cn/news/2014/08/google-data-warehouse-mesa
[Google](http://www.google.com/)发表了一篇新的论文，该论文描述了他们内部所使用的一个被称为[Mesa](http://research.google.com/pubs/pub42851.html)的新型数据仓库系统。Mesa是一个规模横跨多个数据中心，并可以处理PB级数据的系统。该系统可以对查询作出亚秒级（sub-second）的响应，同时维持了[ACID](http://en.wikipedia.org/wiki/ACID)属性。
Mesa主要是围绕Google的广告业务使用场景而设计的。据Google描述，随着他们的广告平台的不断发展，客户对各自的广告活动的可视化提出了更高的要求。对于更具体和更细粒度的信息需求，直接导致了数据规模的急速增长。Google构建了Mesa从而能处理持续增长的数据量，同时它还提供了一致性和近实时查询数据的能力。我们可以从Google的白皮书中了解到Mesa的需求：
> 
原子更新。某一单个的用户行为可能会引起多个关系数据级别的更新，从而影响定义在某个指标集上（例如：点击和成本）跨某个维度集（例如：广告客户和国家）的数千张一致性视图。所以系统状态不会在查询时处于一个只有部分更新生效的状态。
一致性和正确性。出于业务和法律的原因，该系统必须返回一致和正确的数据。即使某个查询牵涉到多个数据中心，我们仍然需要提供强一致性和可重复的查询结果。
可用性。系统不允许出现单点故障。不会出现由于计划中或非计划中的维护或故障所造成的停机，即使出现影响整个数据中心或地域性的断电也不能造成停机。
近实时的更新吞吐率。系统必须支持大约每秒几百万行规模的持续更新，包括添加新数据行和对现有数据行的增量更新。这些更新必须在几分钟内对跨不同视图和数据中心的查询可见。
查询性能。系统必须对那些对时间延迟敏感的用户提供支持，按照超低延迟的要求为他们提供实时的客户报表，而分批提取用户需要非常高的吞吐率。总的来说，系统必须支持将99%的点查询的延迟控制在数百毫秒之内，并且整体查询控制在每天获取万亿行的吞吐量。
可伸缩性。系统规模必须可以随着数据规模和查询总量的增长而伸展。举个例子，它必须支持万亿行规模和PB级的数据。但是即使上述参数再出现显著增长，更新和查询的性能必须仍然得以保持。
在线的数据和元数据转换。为了支持新功能的启用或对现有数据粒度的变更，客户端经常需要对数据模式进行转换或对现有数据的值进行修改。这些变更必须对正常的查询和更新操作没有干扰。
根据Google的描述，所有Google现有的大数据技术都无一能满足所有以上的需求。[BigTable](http://en.wikipedia.org/wiki/BigTable)无法提供原子性和强一致性。而[Megastore](http://research.google.com/pubs/pub36971.html)、[Spanner](http://en.wikipedia.org/wiki/Spanner_(database))和[F1](http://research.google.com/pubs/pub38125.html)虽然为跨地域复制的数据提供了强一致性的访问，但是他们无法支持Mesa客户端所有需要的峰值更新吞吐率。
不管怎样，Mesa在其不同的基础设施中充分利用了现有的Google技术组件。它使用了BigTable来存储所有持久化的元数据，使用了[Colossus](http://static.googleusercontent.com/media/research.google.com/en/us/university/relations/facultysummit2010/storage_architecture_and_challenges.pdf) (Google的分布式文件系统)来存储数据文件。此外，Mesa还利用了[MapReduce](http://en.wikipedia.org/wiki/MapReduce)来处理连续的数据。
Mesa概念上的数据模型与传统的关系型数据库极为相似。所有的数据都存储在表中。一个表同样也可以是另一个表的[物化视图](http://en.wikipedia.org/wiki/Materialized_view)。每个表拥有一个指定了其结构的模式。因为“到底有多少”是广告业务中如此普遍的一个问题，所以一个例如像“SUM”这样的聚合函数可以作为表定义的一部分来指定。在模式中同样也可以指定一个或多个该表的索引。
在Mesa中，最有意思的一个方面是处理更新的方式。Mesa中存储的数据是多版本的，这使得当新的更新正在处理时，Mesa可以向用户提供前置状态的一致性数据。通常，每隔几分钟，上游系统就会执行一次数据更新的批处理。独立的各个无状态的数据提交者实例，负责对跨（Mesa运行所在的）全部数据中心的更新操作进行协调。提交者为每个更新批处理分配一个新的版本号，并基于[Paxos一致算法](http://en.wikipedia.org/wiki/Paxos_(computer_science))向版本数据库发布全部与该更新关联的元数据。当一个更新满足提交的条件时，意味着一个给定的更新已经被全球范围内的大量Mesa实例进行了合并，提交者会将该次更新的版本号声明为新的提交版本号，并将该值存储在版本数据库里。查询通常都是根据提交版本号来分发的。
因为查询通常都是根据提交版本号来分发的，所以Mesa不需要在更新和查询之间进行任何的锁操作。更新都是由Mesa实例在批处理中进行异步实施的。这些属性使得Mesa获得了非常高的查询和更新吞吐率，同时也对数据一致性提供了保障。
Google提供了数个关于Mesa的更新和查询性能的基准测试数据。一个简单的数据源，平均每秒可以读取30到60MB的压缩数据、更新3到6百万个不同的行和新增30万个新行。在单独的一天里，Mesa执行了大约5亿次查询，返回了1.7到3.2万亿行，并且平均延迟是10毫秒，而且99%的延迟低于100毫秒。
据Google描述，Mesa中所存储的数据总量在过去的两年内扩增到了原来的五倍。这暗示了Mesa在Google内部的生产环境中已经使用了至少两年之久。
如果你是一个技术极客，并且想对Mesa进行更多的了解，那么你可以参考Google的[Mesa白皮书](http://research.google.com/pubs/pub42851.html)。

