# nyoj  破门锁(水题) - Vmetrio - 博客园







# [nyoj  破门锁(水题)](https://www.cnblogs.com/wangmengmeng/p/5479429.html)






Time Limit: 1000ms

Memory Limit: 128000KB

64-bit integer IO format:      Java class name:


[Submit](http://115.159.40.116/contest_show.php?cid=29)[Status](http://115.159.40.116/contest_show.php?cid=29#status/A)



几年前，在孙老大担任GDUTACM集训队教练之前，集训队的日子过得非常惨淡，实验室的桌子非常老旧，动不动就塌，集训队员们也是苦不堪言。幸运的是，在孙老大的领导下，集训队的日子走向了小康，所有东西都渐渐的有了，打印机（当然是激光的）什么的，高速上网（10+M每秒的下载）什么的。更加重要的是，集训队出去比赛的经费翻了几番，并且看起来肯定还会继续增长，总之，集训队正在大踏步向前飞奔。

    沐浴在改革开放的春风里，月亮在白棉花般的云朵里穿行，晚风吹来一阵阵快乐的歌声，队员们坐在高高的谷堆旁边，听孙老大讲过去的故事。

    那时候，集训队没有门锁，大家只能用一个不知道用了多久的密码锁来锁门(就是锁单车那一种)，这个密码锁有3位，每位有1～N共计N个数字，其中1和N相邻(因为是个圈)，密码锁有一个用户密码(A1,B1,C1)，也有一个工厂密码(A2,B2,C2)(因为是冒牌厂商做的，所以比较坑爹= =)。更坑爹的是，由于年久失修，当开门的人使用的密码和正确密码的每一位相差都不超过2的时候，门锁就会打开。(摔～！)

    比如用户密码是(1,2,3)，工厂密码是(4,5,6)，N为9，这个时候，如果使用密码(1,9,5)门锁就会被打开，因为它和用户密码分别相差了(0,2,2)。同理，密码(2,4,8)也可以开门，因为它和工厂密码的差距分别为(2,1,2)。但是(1,5,6)就不可以了，因为它和用户密码的差距为(0,3,3),和工厂密码的差距为(3,0,0)。

    现在，孙老大问你，一共有多少个密码可以打开这个破门锁。




### Input

输入数据的第一行只有一个数字，表示测试数据的数量。

接下来每组数据占3行。

第一行只有一个数字N（1<=N<=100）。。

接下来一行有三个数字，表示用户密码。。

第三行有三个数字，表示工厂密码。。




### Output

每组数据输出一行，表示一共有多少个密码可以开锁。




### Sample Input
1
50
1 2 3
5 6 7

### Sample Output
249


对临界点特殊处理...



代码:

```
1 #include <iostream>
 2 #include <cstring>
 3 #include <string>
 4 using namespace std;
 5 int map[105][105][105],ans;
 6 int n;
 7 void cmp(int x,int y,int z)
 8 {
 9     int i,j,k,p,q,m;
10     for(i=-2;i<=2;i++)
11     {
12         for(j=-2;j<=2;j++)
13         {
14             for(k=-2;k<=2;k++)
15             {
16                 p=x+i;q=y+j;m=z+k;
17                 while(p<=0||p>n||q<=0||q>n||m<=0||m>n)
18                 {
19                     if(p<=0) p=n+p;
20                     if(p>n) p=p%n;
21                     if(q<=0) q=n+q;
22                     if(q>n) q=q%n;
23                     if(m<=0)m=n+m;
24                     if(m>n) m=m%n;
25                 }
26                 if(!map[p][q][m])
27                 {
28                     ans++;
29                     map[p][q][m]=1;    
30                 } 
31             }
32         }
33     }
34 }
35 int main()
36 {
37     int k,x,y,z,x1,y1,z1;
38     cin>>k;
39     while(k--)
40     {   
41         ans=0;
42         cin>>n;
43         memset(map,0,sizeof(map));
44         cin>>x>>y>>z;
45         cin>>x1>>y1>>z1;
46         cmp(x,y,z);
47         cmp(x1,y1,z1);
48         cout<<ans<<endl;
49     }
50     return 0;
51 }
```














