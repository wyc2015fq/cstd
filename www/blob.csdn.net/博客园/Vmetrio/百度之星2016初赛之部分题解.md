# 百度之星2016初赛之部分题解 - Vmetrio - 博客园







# [百度之星2016初赛之部分题解](https://www.cnblogs.com/wangmengmeng/p/5517530.html)






# All X

 Accepts: 1281

 Submissions: 7580


 Time Limit: 2000/1000 MS (Java/Others)

 Memory Limit: 65536/65536 K (Java/Others)





Problem Description


F(x, m)

F(x,m)\ mod\ k\ \equiv \ c




Input


第一行一个整数T

1\leq x\leq 9

1\leq m\leq 10^{10}

0\leq c< k\leq 10,000




Output


对于每组数据，输出两行： 第一行输出："Case #i:"。i




Sample Input

3
1 3 5 2
1 3 5 1
3 5 99 69




Sample Output

Case #1:
No
Case #2:
Yes
Case #3:
Yes

Hint

对于第一组测试数据：111 mod 5 = 1，公式不成立，所以答案是”No”，而第二组测试数据中满足如上公式，所以答案是 “Yes”。



代码:


```
1 #include <stdio.h>
 2 #include <string.h>
 3 #include <algorithm>
 4 #include <iostream>
 5 #include <iomanip>
 6 #include <stdlib.h>
 7 using namespace std;
 8 int s[10000009];
 9 int main()
10 {
11     long long n;
12     cin>>n;
13     long long  x,m,k,c;
14     long long num=1;
15     while(n--)
16     {
17         cin>>x>>m>>k>>c;
18 
19         s[1]=x%k;
20         int i;
21         for(i=2;i<=10000005;i++)
22         {
23             s[i]=(s[i-1]*10+x)%k;
24             if(s[1]==s[i]) break;
25         }
26         m=m%i;
27         cout<<"Case #"<<num++<<":"<<endl;
28         if(c==s[m]) cout<<"Yes"<<endl;
29         else cout<<"No"<<endl;
30     }
31     return 0;
32 }
```




# 瞬间移动

 Accepts: 1018

 Submissions: 3620


 Time Limit: 4000/2000 MS (Java/Others)

 Memory Limit: 65536/65536 K (Java/Others)





Problem Description


有一个无限大的矩形，初始时你在左上角（即第一行第一列），每次你都可以选择一个右下方格子，并瞬移过去（如从下图中的红色格子能直接瞬移到蓝色格子），求到第n

![http://acm.hdu.edu.cn/data/images/C702-1003-1.jpg](http://acm.hdu.edu.cn/data/images/C702-1003-1.jpg)




Input


多组测试数据。

两个整数n,m(2\leq n,m\leq 100000)




Output


一个整数表示答案




Sample Input

4 5



Sample Output

Copy10


杨辉三角...找规律...  逆元求组合数  C(m+n-4,m-2)



代码:

```
1 #include <cstdio>
 2 #include <cmath>
 3 #include <cstring>
 4 #include <string>
 5 #include <algorithm>
 6 #include <queue>
 7 #include <map>
 8 #include <set>
 9 #include <vector>
10 #include <iostream>
11 using namespace std;
12 #define ll long long
13 #define MOD 1000000007
14 int n,m;
15 long long t1[100010],t2[100010];
16 
17 long long  qpow(long long x,long long k)
18 {
19     long long res = 1;
20     while(k){
21         if(k & 1)
22             res=res*x%MOD;
23         x=x*x%MOD;
24         k>>=1;
25     }
26     return res;
27 }
28 long long inv(long long a,long long x)
29 {
30     return qpow(a,x-2);
31 }
32 
33 void init()
34 {
35     t1[0]=t1[1]=1;
36     t2[0]=t2[1]=1;
37     for(int i=2; i<100010; i++){
38         t1[i]= (t1[i-1] * i)%MOD;
39         t2[i]= inv(t1[i],MOD);
40     }
41 }
42 
43 long long pro(int n,int m)
44 {
45     if(n < m|| m < 0)
46         return 1;
47     return ((t1[n]*t2[m]) % MOD *t2[n-m]) %MOD;
48 }
49 
50 int main()
51 {
52     init();
53     while(scanf("%d%d",&n,&m)!=EOF){
54         long long ans=0;
55         for(int i=0; i<= min(n,m)-2; i++){
56             ans=(ans+ ( pro(n-2,i) * pro(m-2,i)) %MOD) %MOD;
57         }
58         printf("%I64d\n",ans);
59         
60     }
61      return 0;
62 }
```










# 中位数计数

 Accepts: 592

 Submissions: 3341


 Time Limit: 12000/6000 MS (Java/Others)

 Memory Limit: 65536/65536 K (Java/Others)





Problem Description


中位数定义为所有值从小到大排序后排在正中间的那个数，如果值有偶数个，通常取最中间的两个数值的平均数作为中位数。

现在有n




Input


多组测试数据

第一行一个数n(n\leq 8000)

第二行n




Output


N




Sample Input

5
1 2 3 4 5




Sample Output

1 2 3 2 1





代码:

```
![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)


 1 #include <cstdio>
 2 #include <cmath>
 3 #include <cstring>
 4 #include <string>
 5 #include <algorithm>
 6 #include <queue>
 7 #include <map>
 8 #include <set>
 9 #include <vector>
10 #include <iostream>
11 using namespace std;
12 
13 const double pi=acos(-1.0);
14 double eps=0.000001;
15 
16 int aa[8008];
17 int les[8008];
18 int big[8008];
19 int has[8008+8000];
20 int main()
21 {
22 
23 
24     int n;
25     while(scanf("%d",&n)!=EOF)
26     {
27         int i,j;
28         for (i=1; i<=n; i++)
29         {
30             scanf("%d",&aa[i]);
31         }
32         for (i=1; i<=n; i++)
33         {
34             long long ans=0;
35             memset(has,0,sizeof has);
36             les[i]=0;
37             big[i]=0;
38             for (j=i-1; j>=1; j--)
39             {
40                 if (aa[j]<aa[i]) les[j]=les[j+1]+1;
41                 else les[j]=les[j+1];
42                 if (aa[j]>aa[i]) big[j]=big[j+1]+1;
43                 else big[j]=big[j+1];
44             }
45             for (j=i+1; j<=n; j++)
46             {
47                 if (aa[j]<aa[i]) les[j]=les[j-1]+1;
48                 else les[j]=les[j-1];
49                 if (aa[j]>aa[i]) big[j]=big[j-1]+1;
50                 else big[j]=big[j-1];
51             }
52             for (j=i+1; j<=n; j++)
53             {
54                  int need_big=les[j]-big[j];
55                  has[need_big+8000]++;
56             }
57             has[0+8000]++;
58             for (j=1; j<i; j++)
59             {
60                 ans+=has[big[j]-les[j]+8000];
61             }
62             ans+=has[0+8000];
63             if (i>1)printf(" ");
64             printf("%I64d",ans);
65         }
66 
67         printf("\n");
68 
69 
70     }
71 
72         return 0;
73 
74     }


View Code
```














