# 【网络流24题】魔术球 - 胡小兔 - 博客园







# [【网络流24题】魔术球](https://www.cnblogs.com/RabbitHu/p/LOJ6003.html)





# [LOJ 6003](https://loj.ac/problem/6003) 【网络流24题】魔术球

## 题面

> 
【题目描述】

假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1,2,3,4,⋯ 的球。
- 每次只能在某根柱子的最上面放球。
- 在同一根柱子中，任何 2个相邻球的编号之和为完全平方数。

试设计一个算法，计算出在 n 根柱子上最多能放多少个球。

【输入格式】

文件第 1 行有 1 个正整数 n(n <= 50) ，表示柱子数。


> 
【输出格式】

第一行是球数。接下来的 n 行，每行是一根柱子上的球的编号。


## 题解

能放的球数非常少，所以我们可以暴力放入每一个球，放球的时候，在已经放进去的、能和它相邻的球和它之间连一条有向边，然后新图的最小路径覆盖就是需要的柱子数，每条路径对应一个柱子。如果需要的柱子数大于n则显然不合法了，并且之后加入的球也不会让图从不合法变成合法。

最小路径覆盖 = 点数 - 每个点拆成入点和出点后的二分图匹配数。

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
#define space putchar(' ')
#define enter putchar('\n')
template <class T>
bool read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
        else if(c == EOF) return 0;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op) x = -x;
    return 1;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 4005, M = 2000005, INF = 0x3f3f3f3f;
int ncnt, n, m, s, t, ans, cnt;
int ecnt = 1, adj[N], nxt[M], go[M], cap[M], cur[N];
int que[N], qr, lev[N], stk[N], top;

void ADD(int u, int v, int w){
    go[++ecnt] = v;
    nxt[ecnt] = adj[u];
    adj[u] = ecnt;
    cap[ecnt] = w;
}
void add(int u, int v, int w){
    ADD(u, v, w), ADD(v, u, 0);
}
bool bfs(){
    for(int i = 1; i <= ncnt; i++)
        lev[i] = -1, cur[i] = adj[i];
    lev[s] = 0, que[qr = 1] = s;
    for(int ql = 1; ql <= qr; ql++){
        int u = que[ql];
        for(int e = adj[u], v; e; e = nxt[e])
            if(cap[e] && lev[v = go[e]] == -1){
                lev[v] = lev[u] + 1, que[++qr] = v;
                if(v == t) return 1;
            }
    }
    return 0;
}
int dinic(int u, int flow){
    if(u == t) return flow;
    int delta, ret = 0;
    for(int &e = cur[u], v; e; e = nxt[e])
        if(cap[e] && lev[v = go[e]] > lev[u]){
            delta = dinic(v, min(cap[e], flow - ret));
            if(delta){
                cap[e] -= delta;
                cap[e ^ 1] += delta;
                ret += delta;
                if(ret == flow) return flow;
            }
        }
    lev[u] = -1;
    return ret;
}
int main(){
    read(n);
    s = 1, t = 2;
    while(1){
        cnt++, ncnt = 2 * cnt + 2;
        add(s, 2 * cnt + 1, 1), add(2 * cnt + 2, t, 1);
        for(int i = 1; i < cnt; i++)
            if((int)sqrt(i + cnt) * (int)sqrt(i + cnt) == i + cnt)
                add(2 * i + 1, 2 * cnt + 2, 1);
        while(bfs()) ans += dinic(s, INF);
        if(cnt - ans > n){
            write(cnt - 1), enter;;
            for(int e1 = adj[t]; e1; e1 = nxt[e1]){
                if((e1 & 1) && !cap[e1] && go[e1] < ncnt){
                    int u = go[e1] - 1;
                    while(u){
                        write(u / 2), space;
                        int v = 0;
                        for(int e2 = adj[u]; e2; e2 = nxt[e2])
                            if(!(e2 & 1) && !cap[e2]){
                                v = go[e2] - 1;
                                break;
                            }
                        u = v;
                    }
                    enter;
                }
            }
            break;
        }
    }
    return 0;
}
```












