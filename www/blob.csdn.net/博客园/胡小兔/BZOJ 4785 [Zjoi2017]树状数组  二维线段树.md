# BZOJ 4785 [Zjoi2017]树状数组 | 二维线段树 - 胡小兔 - 博客园







# [BZOJ 4785 [Zjoi2017]树状数组 | 二维线段树](https://www.cnblogs.com/RabbitHu/p/BZOJ4785.html)





## 题目链接

[BZOJ 4785](http://www.lydsy.com/JudgeOnline/problem.php?id=4785)

## 题解

这道题真是令人头秃 = =

可以看出题面中的九条可怜把求前缀和写成了求后缀和，然后他求的区间和却仍然是sum[r] ^ sum[l - 1]，实际上求的是闭区间[l - 1, r - 1]的区间和。什么时候[l - 1, r - 1]的区间和与[l, r]的想等呢？就是位置l - 1与r对应的值相等的时候。于是问题就转换成了：修改操作每次随机修改区间中的一个位置，询问操作每次查询两个位置的值相同的概率。

可以想到一种做法：用线段树维护每个位置上的值为1的概率，然后区间修改+单点查询……可惜这个做法是错误的。为什么？题目中的修改操作规定了：这个区间内有且只有一个值被修改，而一棵线段树体现不了这个限制。

正确的做法是用二维线段树，二维位置(x, y)表示位置x与位置y相同的概率。

查询很简单咯，考虑修改操作。设修改区间是[l, r]，len = r - l + 1, 对于位置(x, y):
- x, y 都在修改区间外：没有影响
- x 在修改区间内，y在修改区间外：有\(\frac{1}{len}\)的可能性修改到x，所以答案有\(\frac{1}{len}\)的可能取反。
- x, y 都在修改区间内，有\(\frac{2}{len}\)的可能性修改到x或y（根据限制，不可能同时修改他们两个）。

原先某两点相同概率是\(p\)，有\(q\)的概率取反，那么新的相同概率是什么呢？

是原来相同且没取反的概率 + 原来不相同且取反了的概率，即\(p * (1 - q) + q * (1 - p)\)。

可以标记永久化。

还需要注意一个大问题：在题面伪代码中，当询问位置是0的时候，查询操作返回的不是后缀和，而是0。那么对于l = 1的查询操作，我们要输出的概率是位置r的前缀和等于后缀和的概率。这个需要特判。

```
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 100005, M = 3e7, P = 998244353;
int n, m, tot, root[4*N], ls[M], rs[M], data[M], ans;

ll inv(ll a){
    ll ret = 1, x = P - 2;
    while(x){
    if(x & 1) ret = ret * a % P;
    a = a * a % P;
    x >>= 1;
    }
    return ret;
}
ll merge(ll x, ll y){
    return ((x * y % P + ((1 - x) % P) * ((1 - y) % P) % P) % P + P) % P;
}
void change2(int &k, int l, int r, int ql, int qr, int x){
    if(!k) k = ++tot, data[k] = 1;
    if(ql <= l && qr >= r) return (void)(data[k] = merge(data[k], x));
    int mid = (l + r) >> 1;
    if(ql <= mid) change2(ls[k], l, mid, ql, qr, x);
    if(qr > mid) change2(rs[k], mid + 1, r, ql, qr, x);
}
void change1(int k, int l, int r, int xl, int xr, int yl, int yr, int x){
    if(xl <= l && xr >= r) return change2(root[k], 0, n + 1, yl, yr, x);
    int mid = (l + r) >> 1;
    if(xl <= mid) change1(k << 1, l, mid, xl, xr, yl, yr, x);
    if(xr > mid) change1(k << 1 | 1, mid + 1, r, xl, xr, yl, yr, x);
}
void query2(int k, int l, int r, int p){
    if(k == 0) return;
    ans = merge(ans, data[k]);
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(p <= mid) query2(ls[k], l, mid, p);
    else query2(rs[k], mid + 1, r, p);
}
void query1(int k, int l, int r, int x, int y){
    query2(root[k], 0, n + 1, y);
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(x <= mid) query1(k << 1, l, mid, x, y);
    else query1(k << 1 | 1, mid + 1, r, x, y);
}

int main(){

    read(n), read(m);
    int op, l, r;
    while(m--){
    read(op), read(l), read(r);
    if(op == 1){
        ll x = (1 - inv(r - l + 1) + P) % P;
        if(l > 1) change1(1, 0, n + 1, 1, l - 1, l, r, x);
        if(r < n) change1(1, 0, n + 1, l, r, r + 1, n, x);
        x = (1 - 2 * inv(r - l + 1) % P + P) % P;
        change1(1, 0, n + 1, l, r, l, r, x);

        change1(1, 0, n + 1, 0, 0, l, r, inv(r - l + 1));
        change1(1, 0, n + 1, 0, 0, 0, l - 1, 0);
        change1(1, 0, n + 1, 0, 0, r + 1, n + 1, 0);
    }
    else{
        ans = 1;
        query1(1, 0, n + 1, l - 1, r);
        write(ans), enter;
    }
    }

    return 0;
}
```












