# BZOJ 2440 [中山市选2011]完全平方数 | 莫比乌斯函数 - 胡小兔 - 博客园







# [BZOJ 2440 [中山市选2011]完全平方数 | 莫比乌斯函数](https://www.cnblogs.com/RabbitHu/p/BZOJ2440.html)





# [BZOJ 2440](http://www.lydsy.com/JudgeOnline/problem.php?id=2440) [中山市选2011]完全平方数 | 莫比乌斯函数

## 题面

找出第k个不是平方数的倍数的数（1不是平方数, \(k \le 10^9\)）。

## 题解

首先二分答案，问题就转化成了求\([1, x]\)中有多少数不是平方数的倍数，设这个答案为\(Q(x)\)。

根据容斥原理，\(Q(x)\)等于：

[1, x] 0个质数的平方的倍数的数量（1的倍数的数量)
- [1, x] 1个质数的平方的倍数的数量 （如\(3^2=9\)的倍数的数量）
- [1, x] 2个质数的平方的倍数的数量 （如\((2 * 3)^2 = 36\)的倍数的数量）
- [1, x] 3个质数的平方的倍数的数量
- ......

发现某个数的贡献就是它的平方根莫比乌斯函数，如36的贡献是1, 4的贡献是-1。

所以

\[Q(x) = \sum_{i = 1}^{\lfloor \sqrt x \rfloor} \mu (i) * \lfloor \frac{x}{i^2} \rfloor\]

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
#define space putchar(' ')
#define enter putchar('\n')
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}
const int N = 100000;
int T, n, mu[N + 5], prime[N + 5], tot;
bool notprime[N + 5];
void getmu(){
    mu[1] = 1;
    for(int i = 2; i <= N; i++){
    if(!notprime[i]) prime[++tot] = i, mu[i] = -1;
    for(int j = 1; j <= tot && i * prime[j] <= N; j++){
        notprime[i * prime[j]] = 1;
        if(i % prime[j] == 0){
        mu[i * prime[j]] = 0;
        break;
        }
        else mu[i * prime[j]] = -mu[i];
    }
    }
}
ll check(ll x){
    ll ret = 0;
    for(ll i = 1; i * i <= x; i++)
    ret += x / (i * i) * mu[i];
    return ret;
}
int main(){
    getmu();
    read(T);
    while(T--){
    read(n);
    ll l = 1, r = 1644934081, mid;
    while(l < r){
        mid = (l + r) >> 1;
        if(check(mid) >= n) r = mid;
        else l = mid + 1;
    }
    write(l), enter;
    }
    return 0;
}
```












