# UOJ #314. 【NOI2017】整数 | 线段树 压位 - 胡小兔 - 博客园







# [UOJ #314. 【NOI2017】整数 | 线段树 压位](https://www.cnblogs.com/RabbitHu/p/UOJ314.html)





## 题目链接

[UOJ 134](http://uoj.ac/problem/314)

## 题解

可爱的电音之王松松松出的题……好妙啊。

首先想一个朴素的做法！

把当前的整数的二进制当作01序列用线段树维护一下（序列的第i位就是整数中位权为\(2^k\)的那一位）。

如何做加法？一下子加一个整数比较麻烦，可以把整数拆成一个个二进制位，一位位地加1。如果当前要加一的位置就是0，直接加就好了；否则显然要进位，松松松出的题肯定肯定不能暴力进位骗分(=v=)……所以线段树维护区间是否全是1，每次加的时候找右边（即更高位）第一个为0的位置，然后把那个位置修改为1，b和那个位置中间所有的位置都改成0就好了。

像这样（为了看着不反人类，最低位在右边，最高位在左边）：

```
001111111
       10
---------
010000001
```

减法怎么做呢？如果这一位就是1则直接减，否则找右边第一个为1的位置，然后单点修改为0，区间修改为1即可。

```
110000001
       10
---------
101111111
```

但是这样做还是会T的！

于是要压位！

把30（或60？）个位用一个数存起来，然后类似上面的这样做。注意这时候**不要还把a一位位拆开加了**，最多只用拆成两部分（为了契合线段树中压位后每一“位”的大小）然后分别加就好了……

代码：

```
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}

const int N = 500005, S = 60;
const ll INF = (1LL << S) - 1;
int n, m, t, pos[4*N];
ll data[N], tag[4*N];
bool all[4*N][2];

void single_change(int k, ll x){
    if(pos[k] != -1) data[pos[k]] = x;
    if(x == 0) all[k][0] = 1, all[k][1] = 0, tag[k] = 0;
    else if(x == INF) all[k][0] = 0, all[k][1] = 1, tag[k] = INF;
    else all[k][0] = all[k][1] = 0, tag[k] = -1;
}
void pushdown(int k){
    if(tag[k] == -1) return;
    single_change(k << 1, tag[k]);
    single_change(k << 1 | 1, tag[k]);
    tag[k] = -1;
}
void pushup(int k){
    all[k][0] = all[k << 1][0] & all[k << 1 | 1][0];
    all[k][1] = all[k << 1][1] & all[k << 1 | 1][1];
}
void build(int k, int l, int r){
    all[k][0] = 1, tag[k] = pos[k] = -1;
    if(l == r) return (void)(pos[k] = l);
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
}
void range_change(int k, int l, int r, int ql, int qr, ll x){
    if(ql <= l && qr >= r) return single_change(k, x);
    pushdown(k);
    int mid = (l + r) >> 1;
    if(ql <= mid) range_change(k << 1, l, mid, ql, qr, x);
    if(qr > mid) range_change(k << 1 | 1, mid + 1, r, ql, qr, x);
    pushup(k);
}
int find_nxt(int k, int l, int r, int p, int o){
    if(all[k][!o]) return -1;
    if(l == r) return l;
    pushdown(k);
    int mid = (l + r) >> 1, tmp;
    if(p <= mid && (tmp = find_nxt(k << 1, l, mid, p, o)) != -1) return tmp;
    return find_nxt(k << 1 | 1, mid + 1, r, p, o);
}
ll query(int k, int l, int r, int p){
    if(l == r) return data[l];
    pushdown(k);
    int mid = (l + r) >> 1;
    if(p <= mid) return query(k << 1, l, mid, p);
    else return query(k << 1 | 1, mid + 1, r, p);
}
void add(int p, ll x){
    ll tmp = query(1, 0, n, p);
    range_change(1, 0, n, p, p, (tmp + x) & INF);
    if(tmp + x > INF){
        int tar = find_nxt(1, 0, n, p + 1, 0);
        range_change(1, 0, n, tar, tar, data[tar] + 1);
        if(p + 1 <= tar - 1) range_change(1, 0, n, p + 1, tar - 1, 0);
    }
}
void sub(int p, ll x){
    ll tmp = query(1, 0, n, p);
    range_change(1, 0, n, p, p, (tmp - x) & INF);
    if(tmp - x < 0){
        int tar = find_nxt(1, 0, n, p + 1, 1);
        range_change(1, 0, n, tar, tar, data[tar] - 1);
        if(p + 1 <= tar - 1) range_change(1, 0, n, p + 1, tar - 1, INF);
    }
}

int main(){

    read(n), m = n, n = n / 2 + 2;
    read(t), read(t), read(t);
    build(1, 0, n);
    ll op, a, b;
    while(m--){
        read(op), read(a);
        if(op == 1){
            read(b);
            if(a > 0){
                int p = b / S, rst = b % S;
        ll x = a << rst & INF;
        if(x) add(p, x);
        p++, a >>= (S - rst);
        if(b) add(p, a);
            }
            else{
                a = -a;
                int p = b / S, rst = b % S;
        ll x = a << rst & INF;
        if(x) sub(p, x);
        p++, a >>= (S - rst);
        if(b) sub(p, a);
            }
        }
        else write(query(1, 0, n, a / S) >> (a % S) & 1), enter;
    }

    return 0;
}
```












