# 51nod 1421 最大MOD值 | 暴力 - 胡小兔 - 博客园







# [51nod 1421 最大MOD值 | 暴力](https://www.cnblogs.com/RabbitHu/p/51nod1421.html)





## 题面

有一个a数组，里面有n个整数。现在要从中找到两个数字(可以是同一个) ai,aj ，使得 ai mod aj 最大并且 ai ≥ aj。

### Input

单组测试数据。

第一行包含一个整数n，表示数组a的大小。(1 ≤ n ≤ 2*10^5)

第二行有n个用空格分开的整数ai (1 ≤ ai ≤ 10^6)。

### Output

输出一个整数代表最大的mod值。

### Input示例

3

3 4 5

### Output示例

2

对每个数，枚举它的所有倍数，找到比这个倍数小并且最接近这个倍数的数，更新ans。

是的！就这样暴力就好了！

——为什么？因为复杂度上限是 1/1 + 1/2 + 1/3 + 1/4 + ... + 1/1e6，松爷教导我们，这个式子是log的！

```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
#define space putchar(' ')
#define enter putchar('\n')

template <class T>
bool read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
        else if(c == EOF) return 0;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op) x = -x;
    return 1;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 200005;
int n, a[N], ans, mx;

int main(){
    read(n);
    for(int i = 1; i <= n; i++)
        read(a[i]), mx = max(mx, a[i]);
    sort(a + 1, a + n + 1);
    a[n + 1] = INF;
    for(int i = 1; i <= n; i++)
        if(a[i] != a[i - 1])
            for(int j = a[i] * 2; j <= mx + a[i]; j += a[i]){
                int p = lower_bound(a + i, a + n + 2, j) - a - 1;
                ans = max(ans, a[p] % a[i]);
            }
    write(ans), enter;
    return 0;
}
```












