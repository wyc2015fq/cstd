# 51nod 1293 球与切换器 | DP - 胡小兔 - 博客园







# [51nod 1293 球与切换器 | DP](https://www.cnblogs.com/RabbitHu/p/51nod1293.html)





# [51nod 1293](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1293) 球与切换器 | DP

## 题面

有N行M列的正方形盒子。每个盒子有三种状态0, -1, +1。球从盒子上边或左边进入盒子，从下边或右边离开盒子。规则：

如果盒子的模式是-1，则进入它的球从下面出去。（方向变为向下）

如果盒子的模式是+1，则进入它的球从右面出去。 （反向变为向右）

如果盒子的模式是0， 则进入它的球方向不变。从上面进入的，从下面出去，从左面进入的，从右面出去。

![](http://img.51nod.com/upfile/000fbd56/08d1bbe35098d8d1000000000000000b.gif)

球离开一个盒子，这个盒子的模式切换为相反数。已知，每个盒子的状态，扔k个球，它们都从左上角那个盒子的上面进入（方向向下），问最终有几个球从右下角的盒子的下边出去。

（可以理解维球一个一个放，等待的时间足够长，不会有两个球同时进入一个盒子的情形）本题由Javaman翻译。

Input

第1行：包括3个数M, N, K中间用空格分隔，M,N 为盒子的宽度和高度，K为球的数量(1 <= M, N <= 1000, 1 <= K <= 10^18)。

第2 - N + 1行：每行M个数(-1, 0 或 1)，表示对应的模式。

Output

输出1个数，对应最终有有多少个球从右下角的盒子的下边出去。

Input示例

3 2 4

-1 0 -1

1 0 0

Output示例

1

## 题解

思路是对所有球“批量处理”。

dp[i][j][0]表示箱子(i, j)下面出去的球的数量，dp[i][j][1]表示箱子(i, j)右面出去的球的数量。

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#define INF 0x3f3f3f3f
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;
typedef long long ll;
template <class T>
bool read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
        else if(c == EOF) return 0;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op) x = -x;
    return 1;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 1003;
int n, m, op;
ll k, dp[N][N][2];

int main(){
    read(m), read(n), read(k);
    dp[0][1][0] = k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            read(op);
            if(op == 0) dp[i][j][0] = dp[i - 1][j][0], dp[i][j][1] = dp[i][j - 1][1];
            else{
                ll sum = dp[i - 1][j][0] + dp[i][j - 1][1];
                if(op == 1) dp[i][j][0] = sum / 2, dp[i][j][1] = (sum + 1) / 2;
                else dp[i][j][0] = (sum + 1) / 2, dp[i][j][1] = sum / 2;
            }
        }
    write(dp[n][m][0]), enter;
    return 0;
}
```












