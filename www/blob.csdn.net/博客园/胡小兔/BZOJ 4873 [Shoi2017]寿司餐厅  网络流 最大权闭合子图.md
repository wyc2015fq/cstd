# BZOJ 4873 [Shoi2017]寿司餐厅 | 网络流 最大权闭合子图 - 胡小兔 - 博客园







# [BZOJ 4873 [Shoi2017]寿司餐厅 | 网络流 最大权闭合子图](https://www.cnblogs.com/RabbitHu/p/BZOJ4873.html)





## 链接

[BZOJ 4873](http://www.lydsy.com/JudgeOnline/problem.php?id=4873)

## 题解

~~当年的~~省选题……还记得蒟蒻的我Day1 20分滚粗……

这道题是个最大权闭合子图的套路题。严重怀疑出题人就是先画好了图然后照着图编了个3000字的题面。~~和我喜欢的妹子当年给别人写的情书一样长……~~

> 
### 最大权闭合子图

最大权闭合子图问题：一个有向图中，每个点带有一个权值（有正有负），有向边\(u \to v\)表示选\(u\)必须选\(v\)，选出一些点使权值和最大，问权值和最大是多少。

最大权闭合子图的解法：网络流建图，对于每个点\(u\)，设权值为\(w_u\)，如果\(w_u\)为正，则连边\((S, u, w_u)\)；若为负，连边\((u, T, |w_u|)\)。对于原图中每条有向边\(u \to v\)，连边\((u, v, +\infty)\)。

答案即为所有正点权之和减去网络流的最小割。


这道题的依赖关系很明确：
- 选择了一个区间\([i, j](i < j)\)，则必须选择它的两个子区间\([i, j - 1], [i + 1, j]\)。
- 选择了一个区间\([i, i]\)，则必须选择里面的唯一寿司\(i\)。
- 选择了一个寿司\(i\)，则必须选择它的代号\(a_i\)。

点的权值也很明确：
- “代号”\(i\)的权值为\(- m * i ^ 2\)。
- “代号”为\(i\)的寿司的权值为\(- i\)。
- 区间\([i, j]\)的权值就是输入数据中的“美味度”。

有了权值和依赖关系，按照上面的最大权闭合子图的建图套路无脑建图即可。

```
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
#define enter putchar('\n')
#define space putchar(' ')
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c > '9' || c < '0')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}
const int N = 10005, M = 1000005, INF = 0x3f3f3f3f;
int n, m, src, des, sum;
int ecnt = 1, adj[N], cur[N], dis[N], nxt[M], go[M], cap[M];
int a[105], w[105][105], lst[1005], idx, type_num[1005], sushi_num[105], range_num[105][105];
void ADD(int u, int v, int _cap){
    go[++ecnt] = v;
    nxt[ecnt] = adj[u];
    adj[u] = ecnt;
    cap[ecnt] = _cap;
}
void add(int u, int v, int _cap){
    ADD(u, v, _cap);
    ADD(v, u, 0);
}
bool bfs(){
    static int que[N], qr;
    for(int i = 1; i <= des; i++)
    cur[i] = adj[i], dis[i] = -1;
    que[qr = 1] = src, dis[src] = 1;
    for(int ql = 1; ql <= qr; ql++){
    int u = que[ql];
    for(int e = adj[u], v; e; e = nxt[e])
        if(cap[e] && dis[v = go[e]] == -1){
        dis[v] = dis[u] + 1, que[++qr] = v;
        if(v == des) return 1;
        }
    }
    return 0;
}
int dfs(int u, int flow){
    if(u == des) return flow;
    int ret = 0, delta;
    for(int &e = cur[u], v; e; e = nxt[e])
    if(cap[e] && dis[v = go[e]] == dis[u] + 1){
        delta = dfs(v, min(cap[e], flow - ret));
        if(delta){
        cap[e] -= delta;
        cap[e ^ 1] += delta;
        ret += delta;
        if(ret == flow) return ret;
        }
    }
    dis[u] = -1;
    return ret;
}
int maxflow(){
    int ret = 0;
    while(bfs()) ret += dfs(src, INF);
    return ret;
}
int main(){
    read(n), read(m);
    for(int i = 1; i <= n; i++)
    read(a[i]), lst[++idx] = a[i];
    sort(lst + 1, lst + idx + 1);
    int tmp = idx = unique(lst + 1, lst + idx + 1) - lst - 1;
    for(int i = 1; i <= lst[idx]; i++)
    type_num[i] = lower_bound(lst + 1, lst + idx + 1, i) - lst;
    for(int i = 1; i <= n; i++)
    sushi_num[i] = ++idx;
    for(int i = 1; i <= n; i++)
    for(int j = i; j <= n; j++){
        range_num[i][j] = ++idx;
        read(w[i][j]);
    }
    src = ++idx, des = ++idx;
    for(int i = 1; i <= n; i++){
        add(sushi_num[i], des, a[i]);
    add(sushi_num[i], type_num[a[i]], INF);
    add(range_num[i][i], sushi_num[i], INF);
    }
    for(int i = 1; i <= n; i++)
    for(int j = i; j <= n; j++){
        if(j > i){
                add(range_num[i][j], range_num[i][j - 1], INF);
                add(range_num[i][j], range_num[i + 1][j], INF);
            }
            if(w[i][j] > 0) add(src, range_num[i][j], w[i][j]), sum += w[i][j];
            else add(range_num[i][j], des, -w[i][j]);
    }
    for(int i = 1; i <= tmp; i++)
        add(i, des, lst[i] * lst[i] * m);
    write(sum - maxflow()), enter;
    return 0;
}
```












