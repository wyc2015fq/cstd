# UDP socket 设置为的非阻塞模式 - DoubleLi - 博客园






UDP socket 设置为的非阻塞模式 
Len = recvfrom(SocketFD, szRecvBuf, sizeof(szRecvBuf), MSG_DONTWAIT, (struct sockaddr *)&SockAddr,&ScokAddrLen);


UDP socket 设置为的阻塞模式 
Len = recvfrom(SocketFD, szRecvBuf, sizeof(szRecvBuf), 0, (struct sockaddr *)&SockAddr,&ScokAddrLen);




Linux socket编程之阻塞套接字和非阻塞套接字

每一个TCP套接口有一个发送缓冲区，可以用SO_SNDBUF套接口选项来改变这个缓冲区的大小。当应用进程调用 write时，内核从应用进程的缓冲区中拷贝所有数据到套接口的发送缓冲区。如果套接口的发送缓冲区容不下应用程序的所有数据(或是应用进程的缓冲区大于套接口发送缓冲区，或是套接口发送缓冲区还有其他数据)，应用进程将被挂起(睡眠)。这里假设套接口是阻塞的，这是通常的缺省设置。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都拷贝到套接口发送缓冲区。因此从写一个TCP套接口的write调用成功返回仅仅表示我们可以重新使用应用进程的缓冲区。它并不告诉我们对端的 TCP或应用进程已经接收了数据。 
    TCP取套接口发送缓冲区的数据并把它发送给对端TCP，其过程基于TCP数据传输的所有规则。对端TCP必须确认收到的数据，只有收到对端的ACK，本端TCP才能删除套接口发送缓冲区中已经确认的数据。TCP必须保留数据拷贝直到对端确认为止。
1 输入操作: read、readv、recv、recvfrom、recvmsg
    如果某个进程对一个阻塞的TCP套接口调用这些输入函数之一，而且该套接口的接收缓冲区中没有数据可读，该进程将被投入睡眠，直到到达一些数据。既然 TCP是字节流协议，该进程的唤醒就是只要到达一些数据：这些数据既可能是单个字节，也可以是一个完整的TCP分节中的数据。如果想等到某个固定数目的数据可读为止，可以调用readn函数，或者指定MSG_WAITALL标志。
    既然UDP是数据报协议，如果一个阻塞的UDP套接口的接收缓冲区为空，对它调用输入函数的进程将被投入睡眠，直到到达一个UDP数据报。
    对于非阻塞的套接口，如果输入操作不能被满足（对于TCP套接口即至少有一个字节的数据可读，对于UDP套接口即有一个完整的数据报可读），相应调用将立即返回一个EWOULDBLOCK错误。
2 输出操作：write、writev、send、sendto、sendmsg
    对于一个TCP套接口，内核将从应用进程的缓冲区到该套接口的发送缓冲区拷贝数据。对于阻塞的套接口，如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。
    对于一个非阻塞的TCP套接口，如果其发送缓冲区中根本没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是内核能够拷贝到该缓冲区中的字节数。这个字节数也称为不足计数(short count)
    UDP套接口不才能在真正的发送缓冲区。内核只是拷贝应用进程数据并把它沿协议栈向下传送，渐次冠以UDP头部和IP头部。因此对一个阻塞的UDP套接口，输出函数调用将不会因为与TCP套接口一样的原因而阻塞，不过有可能会因其他的原因而阻塞。









