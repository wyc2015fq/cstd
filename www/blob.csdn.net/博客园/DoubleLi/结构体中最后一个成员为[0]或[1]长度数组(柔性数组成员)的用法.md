# 结构体中最后一个成员为[0]或[1]长度数组(柔性数组成员)的用法 - DoubleLi - 博客园






结构体中最后一个成员为[0]长度数组的用法：这是个广泛使用的常见技巧，常用来构成缓冲区。比起指针，用空数组有这样的优势：(1)、不需要初始化，数组名直接就是所在的偏移；(2)、不占任何空间，指针需要占用int长度空间，空数组不占任何空间。“这个数组不占用任何内存”，意味着这样的结构节省空间；“该数组的内存地址就和它后面的元素地址相同”，意味着无需初始化，数组名就是后面元素的地址，直接就能当指针使用。

这样的写法最适合制作动态buffer，因为可以这样分配空间malloc(sizeof(structXXX) + buff_len); 直接就把buffer的结构体和缓冲区一块分配了。用起来也非常方便，因为现在空数组其实变成了buff_len长度的数组了。这样的好处是：(1)、一次分配解决问题，省了不少麻烦。为了防止内存泄露，如果是分两次分配(结构体和缓冲区)，那么要是第二次malloc失败了，必须回滚释放第一个分配的结构体。这样带来了编码麻烦。其次，分配了第二个缓冲区以后，如果结构里面用的是指针，还要为这个指针赋值。同样，在free这个buffer的时候，用指针也要两次free。如果用空数组，所有问题一次解决。(2)、小内存的管理是非常困难的，如果用指针，这个buffer的struct部分就是小内存了，在系统内存在多了势必严重影响内存管理的性能。要是用空数组把struct和实际数据缓冲区一次分配大块问题，就没有这个问题。如此看来，用空数组既简化编码，又解决了小内存碎片问题提高了性能。

结构体最后使用0或1长度数组的原因：主要是为了方便的管理内存缓冲区(其实就是分配一段连续的内存，减少内存的碎片化)，如果直接使用指针而不使用数组，那么，在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，(而此时分配的内存已经与结构体的内存不连续了，所有要分别管理即申请和释放)而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放。使用指针，得先释放结构体内的指针，再释放结构体，还不能颠倒顺序。

结构体中最后一个成员为[1]长度数组的用法：与长度为[0]数组的用法相同，改写为[1]是出于可移植性的考虑。有些编译器不支持[0]数组，可将其改成[]或[1].

         不完整类型(incomplete type)：它缺乏足够的信息例如长度去描述一个完整的对象。(1)、前向声明就是一种常用的不完整类型， class base; struct test; base和test只给出了声明，没有给出定义。不完整类型必须通过某种方式补充完整，才能使用它们进行实例化，否则只能用于定义指针或引用，否则只能用于指针或引用，因为此时实例化的是指针或引用本身，不是base或test对象。(2)、一个未知长度的数组也属于不完整类型：extern int a[]; extern不能去掉，因为数组的长度未知，不能作为定义出现。不完整类型的数组可以通过几种方式补充完整才能使用，大括号形式的初始化就是其中一种方式：int a[] = {10, 20};

         柔性数组成员(flexible array member)：也叫收缩性数组成员，这种代码结构产生于对动态结构体的需求。C99使用不完整类型实现柔性数组成员，在C99中，结构中的最后一个元素允许是未知大小的数组，这就叫柔性数组成员。但结构中的柔性数组成员前面必须至少一个其它成员。柔性数组成员允许结构中包含一个大小可变的数组。柔性数组成员只作为一个符号地址存在，而且必须是结构体的最后一个成员，sizefo返回的这种结构大小不包括柔性数组的内存。柔性数组成员不仅可以用于字符数组，还可以是元素为其它类型的数组。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

         C/C++标准规定不能定义长度为0的数组，因此，有些编译器就把0长度的数组成员作为自己的非标准扩展。

示例代码：





**[cpp]**[view plain](http://blog.csdn.net/fengbingchun/article/details/24185217)[copy](http://blog.csdn.net/fengbingchun/article/details/24185217)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)



- #include <iostream>  
- using namespace std;  
- 
- typedef struct _FlexibleArray  
- {  
- char ch;  
- int arr[0];//int arr[];//int arr[1];  
- }FlexibleArray;  
- 
- int main()  
- {  
-     cout<<sizeof(FlexibleArray)<<endl;  
- 
- const int LENGTH = 10;  
-     FlexibleArray* flexibleArray = (FlexibleArray*)new char[sizeof(FlexibleArray) + LENGTH * sizeof(int)];  
- 
- for (int i = 0; i < LENGTH; i ++) {  
-         flexibleArray->arr[i] = i * i;  
-     }  
- 
- for (int i = 0; i < LENGTH; i ++) {  
-         cout<<flexibleArray->arr[i]<<endl;  
-     }  
- 
- delete [] flexibleArray;  
- 
- return 0;  
- }  



参考文献：





1、  [http://blog.chinaunix.net/uid-26750459-id-3191136.html](http://blog.chinaunix.net/uid-26750459-id-3191136.html)

2、  [http://blog.csdn.net/ce123_zhouwei/article/details/8973073](http://blog.csdn.net/ce123_zhouwei/article/details/8973073)

3、 [http://blog.csdn.net/code_crash/article/details/4854939](http://blog.csdn.net/code_crash/article/details/4854939)









