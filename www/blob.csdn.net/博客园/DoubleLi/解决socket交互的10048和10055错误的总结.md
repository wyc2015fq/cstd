# 解决socket交互的10048和10055错误的总结 - DoubleLi - 博客园






问题：60多路轮训的情况下，5分钟之后，现场报链接不上子进程的错误。绝大部分为海康设备



分析：

子进程的日志中 存在输入海康的解码库的错误，在子进程的对外dll中加日志发现，socket链接的时候存在10048（通常每个套接字地址(协议/网络地址/端口)只允许使用一次）的错误。公司重现的情况还存在10055（由于系统缓冲区空间不足或列队已满，不能执行套接字上的操作 ）的错误。10055的错误发现是由于硬件支持的所限以及输入解码库的时候，当解码速度达不到的情况没有相应的抛弃帧的机制。出现10048的错误的原因的为60路轮训，dll和海康子进程的1秒一次的保活，导致socket资源耗尽。



解决方案：

现场：添加当解码速度达不到的情况相应的抛弃帧的机制，以及修改注册表中的[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters]

"MaxUserPort"=dword:0000fffe
"TcpTimedWaitDelay"=dword:0000001E[/code]



TcpTimedWaitDelay 为30秒，默认为2MSL 大概为2~4分钟



最终方案：


（1）添加当解码速度达不到的情况相应的抛弃帧的机制

（2）客户端针对保活的socket交互添加关闭的时候的抛弃经历time_wait的过程：

参考代码：


BOOL bReuseaddr=TRUE;

setsockopt(ServerSocket,SOL_SOCKET ,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof(BOOL));



BOOL bDontLinger = FALSE;

setsockopt(ServerSocket,SOL_SOCKET,SO_DONTLINGER,(const char*)&bDontLinger,sizeof(BOOL));



linger m_sLinger;



m_sLinger.l_onoff = 1; // (在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)



m_sLinger.l_linger = 0; // (容许逗留的时间为0秒)



setsockopt(ServerSocket,



SOL_SOCKET,



SO_LINGER,



(const char*)&m_sLinger,



sizeof(linger)); // 可选代码




注释掉原有的代码：//shutdown(ServerSocket,2);









