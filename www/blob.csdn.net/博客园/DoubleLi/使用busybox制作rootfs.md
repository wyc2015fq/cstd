# 使用busybox制作rootfs - DoubleLi - 博客园






Build Busybox as a static binary（no shared libs），如果选择上，则busybox将以静态形式进行编译，否则将以动态方式编译。此外，还需要对交叉编译环境进行配置，选择其中的Cross Compiler Perfix，输入交叉编译器的前缀，我们的嵌入式平台上使用的是arm-uclinux-linu


**TAG: **[busybox](http://www.rosoo.net/tags.php?/busybox/)[rootfs](http://www.rosoo.net/tags.php?/rootfs/)
|**1  获取源码解压**从busybox的官方主页[http://www.busybox.net](http://www.busybox.net/) ,下载busybox的源码，目前最新的版本为busybox-1.13.3.tar.bz2#tar –jvxf busybox-1.13.3.tar.bz2进入解压后的busybox源码目录#cd busybox-1.13.3**2  配置busybox**步骤跟编译linux内核时很像#make menuconfig出现一个图形界面，选择Busybox Settings，这里可以对编译、安装以及调试等模式进行配置。然后选择Build Options，对交叉编译器以及编译方式进行配置。其中的第一项是Build Busybox as a static binary（no shared libs），如果选择上，则busybox将以静态形式进行编译，否则将以动态方式编译。此外，还需要对交叉编译环境进行配置，选择其中的Cross Compiler Perfix，输入交叉编译器的前缀，我们的[嵌入式](http://www.rosoo.net/a/index_em.html)平台上使用的是arm-uclinux-linux的交叉编译工具。这里我们先选择静态编译，动态方式的稍后再讲，注意Build with Large File Support (for accessing files > 2 GB)不要选（默认是选上的），否则编译后会出现如下错误：miscutils/lib.a（readahead.）:In function ‘readahead_main’readahead.(.text.readahead_main+0×70):undefined reference to ‘readahead’collect2:ld returned 1 exit statusmake :***[busybox_unstripped ]Error 1**3         编译busybox**#make**4         安装busybox**#make install可以采用perfix参数安装到指定目录下，格式为：make install prefix=xxx目录，如果不特别指定，将默认在busybox源码目录下生成一个_install目录。到此，busybox基本上可以功成身退 了。我们需要的就是busybox编译出来的这个_install目录。进入_install目录，可以看到一共有3个目录和一个文件，分别是：bin、sbin和usr目录以及linuxrc文件。在对这几个目录进行说明之前，先简单介绍一下编译生成的busybox可执行文件，它存在于bin目录下。Busybox使用了带参的main 函数：int main(int argc，char *argv[])，在这个定义中，argc是传递进来的参数的个数（参数数量），而argv是一个字符串数组，代表从命令行传递进来的参数。argv的索 引0是命令行调用的程序名。可以在bin目录下进行如下操作：#busybox pwd(注意，busybox这个可执行文件不需要加./)当为一个可执行程序创建符号链接后，在执行这个符号链接时，就可以获取到这个符号链接的名字。而busybox正是使用符号链接的方式使一个可 执行程序看起来像很多程序一样。对于busybox中包含的每个工具来讲，都会创建一个符号链接，这样就可以使用这些符号链接来调用busybox了。然 后busybox接着根据argv[0]的值来调用内部工具。下面分别对install目录下的几个文件进行一些说明。Ø        bin包含用户工具，其中，busybox可执行文件就在这个目录 下，该目录下其他所有文件都是指向busybox的符号链接Ø        sbin目录包含操作系统工具，同样也指向busybox。Ø        linuxrc是一个链接文件，指向busybox。**5         添加etc目录及基本配置文件**参考一个正常的linux系统将会发现，此时busybox建立的文件系统还缺少很多文件。如果用这个作为文件系统，将是无法运行的。生成这些 配置可以选择的方法有2种，一种是直接从一个正常运行的系统中拷贝，另一种是借助于busybox的examples。显然，选择第二种会容易的多，我们 直接拷贝examples/bootfloopy/etc到install目录下。#cp –a ../examples/bootfloppy/etc/ .然后可以看看etc目录下的文件,一共有3个目录和文件，下面逐一对以上几个文件进行分析和说明。Ø        inittab文件：系统启动后访问的第一个脚本文件，后续启动的文 件都由它指定。下面看一下busybox中原始的inittab文件内容：::sysint:/etc/init.d/rcS::respawn:-/bin/shtty2：：askfirst：-/bin/sh::ctrlaltdel:/bin/umount –a -r其中第一行指定系统的启动脚本为/etc/init.d/rcS第二行指定打开一个登录会话第三行指定在第三个虚拟终端打开一个无须登录验证的shell第四行指定了当按下ctrl+alt+del组合键时的执行命令Ø        fstab文件：定义了文件系统的各个“挂载点”，需要与实际的系统 相配合。默认的fstab文件内容为：proc   /proc proc defaults 0 0其他的根据需要再进行添加，比如devpts  /dev/pts devpts defaults 0 0就是为UNIX PTYs准备的，后面讲telnetd时要用到。Ø        profile文件：终端登陆之后首先运行的脚本。**6         添加dev目录及基本设备文件**调试时要通过串口发送消息到终端显示。因此串口控制台和终端2个设备文件是必不可少的。#mkdir dev#mknod dev/console c 5 1#mknod dev/ttyAMA0 c 204 64在启动参数中，设置console=ttyAMA0**7         添加其他常用目录**可以选择home、root、proc、mnt、lib、var、opt、tmp。此时，一个基本的文件系统的功能就已经完成了。可以采用NFS进行调试。但是，此时你可能会遇到如下问题，系统登录后终端上会不断打印:cannot open /dev/ttyS2:No such file or directory.原因出在/etc目录下的inittab文件，我们看一下其内容：::sysint:/etc/init.d/rcS::respawn:-/bin/shtty2：：askfirst：-/bin/sh::ctrlaltdel:/bin/umount –a -r这条语句表示在第3个虚拟终端打开一个无须登录验证的shell。而我们之前没有建立这个tty2设备，因此会出错。解决的办法有2个：一是屏 蔽该语句，二是建立该设备节点。我们选择将其屏蔽。**8         相关问题****8.1      使用动态方式编译 busybox**进入Build Options时，不要选择Build Busybox as a static binary,其他所有操作步骤跟静态编译一样，你会发现这样建立的文件系统无法启动，终端上打印出如下消息：Kernel panic-not synving:No init found. Try passing init=option to kernel.为什么会出现这种问题呢？这就得回到两种编译方式的特点上来。静态编译时是将所用到的库文件一起编译了进去，而动态编译时是在需要时才调用相应 的库。我们选择动态编译后，没有添加任何库文件就运行，显然是会出错的。那么如何查看busybox可执行文件里使用的库呢。Readelf这个工具提供 了解决办法。使用如下命令，参数d表示将文件中所有的动态部分予以显示。# arm-uclibc-linux-readelf -d busybox Dynamic section at offset 0xca014 contains 18 entries:  标记        类型                         名称/值 0×00000001 (NEEDED)                     共享库: [libm.so.0] 0×00000001 (NEEDED)                     共享库: [libc.so.0] 0×0000000c (INIT)                       0xbe24 0×0000000d (FINI)                       0xb2054 0×00000004 (HASH)                       0×80e8 0×00000005 (STRTAB)                     0xa500 0×00000006 (SYMTAB)                     0×8b70 0×0000000a (STRSZ)                      3259 (bytes) 0×0000000b (SYMENT)                     16 (bytes) 0×00000015 (DEBUG)                      0×0 0×00000003 (PLTGOT)                     0xda0cc 0×00000002 (PLTRELSZ)                   3040 (bytes) 0×00000014 (PLTREL)                     REL 0×00000017 (JMPREL)                     0xb244 0×00000011 (REL)                        0xb1bc 0×00000012 (RELSZ)                      136 (bytes) 0×00000013 (RELENT)                     8 (bytes) 0×00000000 (NULL)                       0×0从上面的结果中，我们可以看到，busybox这个程序使用到了libm.so.0和libc.so.0两个库文件，实际上这是2个符号链接， 分别指向libc-0.9.28.so和libuClibc-0.9.28.so。将以上四个文件分别拷贝到lib目录下。按理说，这样应该就可以了，但 是仍然无法正常运行。显示的错误信息和刚刚没加库之前一样。可能的原因有2种：一是库文件没有添加全，二是库文件没有正确被加载。根据readelf显示 的结果应该不是第一种原因。那么到底为什么没被正确加载呢？原来库文件的加载，还需要一个共享库加载器。找到对应的文件ld-uClibc- 0.9.28.so和ld-uClibc.so.0添加到lib目录下后。运行正常。**8.2      终端登录用户验证功 能添加**需要在etc目录下增加passwd、group和shadow(在编译busybox时如果不选择shadow功能将不需要这个文件)3个文 件。生成这3个文件的方法有：Ø        手动生成，按照格式规范自己编写内容；Ø        通过busybox提供的工具adderuser自动生成**8.2.1        手动方式**首先我们介绍一下如何手动添加。以增加root用户为例，增加passwd文件，其内容为：#cat passwdroot:x:0:0:root:/root:/bin/sh同时，此时要确定root目录已经存在。passwd一共由7个字段组成，6个冒号将其隔开。它们的含义分别为：1     用户名2     是否有加密口令，x表示有，不填表示无，采用MD5、DES加密。3     用户ID4     组ID5     注释字段6     登录目录7     所使用的shell程序增加group文件，其内容为：#cat grouproot:x:0:Group一共由4个字段组成，3个冒号将其隔开，它们的含义分别为：1     组名2     是否有加密口令，同passwd3     组ID4     指向各用户名指针的数组由于busybox默认启动了shadow模式，因此需要增加shadow文件，其内容为：#cat shadowroot:$1$3jZ93Mwq$oaeef6lWIuThavs8wD0Wh1:0:0:99999:7:::shadow一共由9个字段组成，8个冒号将其隔开，它们的含义分别为：1     用户名2     加密后的口令，若为空，表示该用户不需要口令即可登陆，若为*号，表示该账号被禁用。 上面的表示的是123456加密后的口令。3     从1970年1月1日至口令最近一次被修改的天数4     口令在多少天内不能被用户修改5     口令在多少天后必须被修改（0为没有修改过）6     口令过期多少天后用户账号被禁止7     口令在到期多少天内给用户发出警告8     口令自1970年1月1日被禁止的天数9     保留域这里强调一下shadow文件的由来。/etc/passwd文件对系统的所有用户都是可读的，这样的好处是每个用户都知道系统上有哪些用户， 但缺点是其他用户的口令容易受到攻击，尤其是当口令较简单时。所以一些linux系统中使用到了影子口令文件shadow，将用户的口令存储在另一个文件 /etc/shadow中，该文件只有根用户root可读，大大提高了安全性。不过，采用这种手动添加文件的方法有一个缺陷，就是如果要为用户设置登陆口令的话，shadow文件中必须填写加密后的口令，而这个加密算法我 们又不知道，即使知道，要经过转换后再添加，比较麻烦。此时，不妨试一下第二种方法。**8.2.2        自动方式**自动生成是使用了busybox提供的adduser工具和passwd工具。在文件系统正常运行起来后，使用adduser命令，使用方法为：#adduser root然后就会在etc目录下自动生成passwd 、group和shadow3个文件。但是运行该命令后会打印出如下消息：passwd：unknown uid 0这表示不能为该用户设置密码，此时你会发现要passwd命令也无法使用。解决的办法是，打开passwd文件，其内容为：root:x:1000:1000:[Linux](http://www.rosoo.net/a/list_49_1.html) User…:/home/root:/bin/sh将用户ID和组ID均更改为0打开group文件，其内容为：root:x:1000:同样将组ID改为0然后，passwd命令就可以正常使用了。这时为root用户设置口令：#passwd root根据提示输入密码。其中，root用户登陆后的目录可以手动进行更改。**8.3      telnetd功能 添加**busybox默认已经添加了对telnetd和telnet功能的支持，只需要完成一些相关的设置工作就可以启动这2个功能了。Ø          创建/dev/pts目录Ø        在/etc/fstab中添加如下信息，挂载devpts文件系统devpts /dev/pts devpts defaults 0 0Ø        在/dev目录下增加ptmx设备文件：#mknod ptmx c 5 2Ø        在rcS文件中添加如下脚本，启动telnetdif [ -x /usr/sbin/telnetd ] ;then        telnetd&fiØ        在/dev目录下增加null设备文件，否则上述脚本运行时会出错： 提示找不到null文件。#mknod null c 1 3此时，telnetd功能开机就可以启动了。|
|----|










