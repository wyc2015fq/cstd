# 基于无锁队列和c++11的高性能线程池 - DoubleLi - 博客园







基于无锁队列和c++11的高性能线程池
线程使用c++11库
和线程池之间的消息通讯使用一个简单的无锁消息队列
适用于linux平台，gcc 4.6以上




**标签：** <无>






## 代码片段(6)[[全屏查看所有代码]](https://www.oschina.net/code/piece_full?code=32565)


### 1. [代码]lckfree.h     [](https://www.oschina.net/code/piece_full?code=32565&piece=46845#46845)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
// lckfree.h
```



```cpp
// Implementation of lock free queue using CAS operations
```



```cpp
// for simple multi-threading use cases like:
```



```cpp
// 1. multiple worker to process incoming messages
```



```cpp
// 2. async processing using a thread pool
```



```cpp
// 3. simple tcp server deal with async requests
```



```cpp
// Author: typhoon_1986@163.com
```



```cpp
// Refrence: http://coolshell.cn/articles/8239.html
```





```cpp
#ifndef __LCKFREE_H__
```



```cpp
#define __LCKFREE_H__
```





```cpp
#include <string>
```



```cpp
using
```

```cpp
namespace
```

```cpp
std;
```





```cpp
namespace
```

```cpp
bfd {
```





```cpp
struct
```

```cpp
LinkNode {
```



```cpp

```

```cpp
string data;
```



```cpp

```

```cpp
LinkNode* next;
```



```cpp
};
```



```cpp
typedef
```

```cpp
struct
```

```cpp
LinkNode LinkNode;
```





```cpp
class
```

```cpp
LckFreeQueue {
```



```cpp

```

```cpp
public
```

```cpp
:
```



```cpp

```

```cpp
LckFreeQueue();
```



```cpp

```

```cpp
~LckFreeQueue();
```





```cpp

```

```cpp
int
```

```cpp
push(
```

```cpp
const
```

```cpp
string &msg);
```



```cpp

```

```cpp
string pop();
```

```cpp
// non-block pop method
```



```cpp
//  string bpop(); // block pop method
```



```cpp

```

```cpp
bool
```

```cpp
empty();
```



```cpp

```

```cpp
private
```

```cpp
:
```



```cpp

```

```cpp
LinkNode * head_;
```



```cpp

```

```cpp
LinkNode * tail_;
```



```cpp

```

```cpp
bool
```

```cpp
empty_;
```



```cpp

```

```cpp
unsigned
```

```cpp
int
```

```cpp
length_;
```



```cpp
};
```





```cpp
}
```

```cpp
// namespace bfd
```



```cpp
#endif
```
```





### 2. [代码]lckfree.cpp     [](https://www.oschina.net/code/piece_full?code=32565&piece=46846#46846)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
#include <lckfree.h>
```





```cpp
namespace
```

```cpp
bfd {
```





```cpp
LckFreeQueue::LckFreeQueue(): head_(NULL), tail_(NULL), empty_(
```

```cpp
true
```

```cpp
), length_(0) {
```



```cpp

```

```cpp
head_ =
```

```cpp
new
```

```cpp
LinkNode;
```



```cpp

```

```cpp
head_->next = NULL;
```



```cpp

```

```cpp
tail_ = head_;
```



```cpp
}
```





```cpp
LckFreeQueue::~LckFreeQueue() {
```



```cpp

```

```cpp
LinkNode *p = head_;
```



```cpp

```

```cpp
if
```

```cpp
(p) {
```



```cpp

```

```cpp
LinkNode *q = p->next;
```



```cpp

```

```cpp
delete
```

```cpp
p;
```



```cpp

```

```cpp
p = q;
```



```cpp

```

```cpp
}
```



```cpp
}
```





```cpp
int
```

```cpp
LckFreeQueue::push(
```

```cpp
const
```

```cpp
string &msg) {
```



```cpp

```

```cpp
LinkNode * q =
```

```cpp
new
```

```cpp
LinkNode;
```



```cpp

```

```cpp
q->data = msg;
```



```cpp

```

```cpp
q->next = NULL;
```





```cpp

```

```cpp
LinkNode * p = tail_;
```



```cpp

```

```cpp
LinkNode * oldp = p;
```



```cpp

```

```cpp
do
```

```cpp
{
```



```cpp

```

```cpp
while
```

```cpp
(p->next != NULL)
```



```cpp

```

```cpp
p = p->next;
```



```cpp

```

```cpp
}
```

```cpp
while
```

```cpp
( __sync_bool_compare_and_swap(&(p->next), NULL, q) !=
```

```cpp
true
```

```cpp
);
```

```cpp
//如果没有把结点链在尾上，再试
```





```cpp

```

```cpp
__sync_bool_compare_and_swap(&tail_, oldp, q);
```

```cpp
//置尾结点
```



```cpp

```

```cpp
return
```

```cpp
0;
```



```cpp
}
```





```cpp
string LckFreeQueue::pop() {
```



```cpp

```

```cpp
LinkNode * p;
```



```cpp

```

```cpp
do
```

```cpp
{
```



```cpp

```

```cpp
p = head_;
```



```cpp

```

```cpp
if
```

```cpp
(p->next == NULL){
```



```cpp

```

```cpp
return
```

```cpp
""
```

```cpp
;
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
}
```

```cpp
while
```

```cpp
( __sync_bool_compare_and_swap(&head_, p, p->next) !=
```

```cpp
true
```

```cpp
);
```



```cpp

```

```cpp
return
```

```cpp
p->next->data;
```



```cpp
}
```





```cpp
bool
```

```cpp
LckFreeQueue::empty() {
```



```cpp

```

```cpp
return
```

```cpp
empty_;
```



```cpp
}
```





```cpp
}
```
```





### 3. [代码]workthreadpool.h     [](https://www.oschina.net/code/piece_full?code=32565&piece=46847#46847)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
// workthreadpool.h
```



```cpp
// 一个用于将消息分发给多个进程，并使用多个进程处理的库，工作进程并不返回数据
```



```cpp
#ifndef __WORK_THREAD_POOL__
```



```cpp
#define __WORK_THREAD_POOL__
```





```cpp
#include <stdio.h>
```



```cpp
#include <thread>
```



```cpp
#include <queue>
```



```cpp
#include <string>
```



```cpp
#include <vector>
```



```cpp
#include "lckfree.h"
```





```cpp
using
```

```cpp
namespace
```

```cpp
std;
```



```cpp
namespace
```

```cpp
bfd {
```





```cpp
class
```

```cpp
WorkThreadPool {
```



```cpp

```

```cpp
public
```

```cpp
:
```



```cpp

```

```cpp
WorkThreadPool(
```

```cpp
int
```

```cpp
size);
```



```cpp

```

```cpp
virtual
```

```cpp
~WorkThreadPool();
```





```cpp

```

```cpp
// 需要子类继承并实现的函数，每个线程实际执行的内容
```



```cpp

```

```cpp
virtual
```

```cpp
void
```

```cpp
Init() {};
```



```cpp

```

```cpp
virtual
```

```cpp
void
```

```cpp
Finish() {};
```



```cpp

```

```cpp
virtual
```

```cpp
void
```

```cpp
Handle(
```

```cpp
const
```

```cpp
string &msg)=0;
```





```cpp

```

```cpp
// 将消息放入处理队列, 消息只支持string类型
```



```cpp

```

```cpp
int
```

```cpp
SendMessage(
```

```cpp
const
```

```cpp
string &msg);
```





```cpp

```

```cpp
int
```

```cpp
Start();
```



```cpp

```

```cpp
int
```

```cpp
Stop();
```





```cpp

```

```cpp
private
```

```cpp
:
```



```cpp

```

```cpp
void
```

```cpp
Worker();
```





```cpp

```

```cpp
int
```

```cpp
size_;
```



```cpp

```

```cpp
LckFreeQueue msg_queue_;
```

```cpp
// 线程池的协作基于这个无锁队列
```



```cpp

```

```cpp
vector<
```

```cpp
thread
```

```cpp
> thread_pool_;
```



```cpp
};
```



```cpp
}
```

```cpp
// namespace
```



```cpp
#endif
```
```





### 4. [代码]workthreadpool.cpp     [](https://www.oschina.net/code/piece_full?code=32565&piece=46848#46848)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
#include "workthreadpool.h"
```



```cpp
#include <sstream>
```



```cpp
#include <unistd.h>
```





```cpp
namespace
```

```cpp
bfd {
```



```cpp
WorkThreadPool::WorkThreadPool(
```

```cpp
int
```

```cpp
size) {
```



```cpp

```

```cpp
if
```

```cpp
(size <= 0) {
```

```cpp
// 最小也需要有1个线程
```



```cpp

```

```cpp
size_ = 1;
```



```cpp

```

```cpp
}
```

```cpp
else
```

```cpp
{
```



```cpp

```

```cpp
size_ = size;
```



```cpp

```

```cpp
}
```



```cpp
}
```





```cpp
WorkThreadPool::~WorkThreadPool() {
```





```cpp
}
```





```cpp
int
```

```cpp
WorkThreadPool::SendMessage(
```

```cpp
const
```

```cpp
string &msg) {
```



```cpp

```

```cpp
msg_queue_.push(msg);
```



```cpp

```

```cpp
return
```

```cpp
0;
```



```cpp
}
```





```cpp
void
```

```cpp
WorkThreadPool::Worker() {
```



```cpp

```

```cpp
unsigned
```

```cpp
int
```

```cpp
msg_count = 0;
```



```cpp

```

```cpp
while
```

```cpp
(1) {
```



```cpp

```

```cpp
string msg = msg_queue_.pop();
```



```cpp

```

```cpp
if
```

```cpp
(msg.empty()) {
```



```cpp

```

```cpp
printf
```

```cpp
(
```

```cpp
"no msg got, sleep for 0.1 sec\n"
```

```cpp
);
```



```cpp

```

```cpp
usleep(100000);
```

```cpp
// 0.1 sec
```



```cpp

```

```cpp
continue
```

```cpp
;
```



```cpp

```

```cpp
}
```





```cpp

```

```cpp
if
```

```cpp
(msg ==
```

```cpp
"__exit__"
```

```cpp
) {
```



```cpp

```

```cpp
stringstream ss;
```



```cpp

```

```cpp
ss <<
```

```cpp
"exit worker: "
```

```cpp
<< std::this_thread::get_id() <<
```

```cpp
", processed: "
```

```cpp
<< msg_count <<
```

```cpp
".."
```

```cpp
;
```



```cpp

```

```cpp
printf
```

```cpp
(
```

```cpp
"%s\n"
```

```cpp
, ss.str().c_str());
```



```cpp

```

```cpp
return
```

```cpp
;
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
Handle(msg);
```



```cpp

```

```cpp
msg_count++;
```



```cpp

```

```cpp
if
```

```cpp
(msg_count % 1000 == 0) {
```



```cpp

```

```cpp
printf
```

```cpp
(
```

```cpp
"every 1000 msg count\n"
```

```cpp
);
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
}
```



```cpp
}
```





```cpp
int
```

```cpp
WorkThreadPool::Start() {
```



```cpp

```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
i=0; i < size_; i++) {
```



```cpp

```

```cpp
thread_pool_.push_back(
```

```cpp
thread
```

```cpp
(&WorkThreadPool::Worker,
```

```cpp
this
```

```cpp
) );
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
return
```

```cpp
0;
```



```cpp
}
```





```cpp
int
```

```cpp
WorkThreadPool::Stop() {
```



```cpp

```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
i=0; i < size_; i++) {
```



```cpp

```

```cpp
SendMessage(
```

```cpp
"__exit__"
```

```cpp
);
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
i=0; i < size_; i++) {
```



```cpp

```

```cpp
thread_pool_[i].join();
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
return
```

```cpp
0;
```



```cpp
}
```





```cpp
}
```
```





### 5. [代码]main.cpp     [](https://www.oschina.net/code/piece_full?code=32565&piece=46849#46849)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
#include "workthreadpool.h"
```



```cpp
#include <sstream>
```



```cpp
#include <math.h>
```





```cpp
class
```

```cpp
MyThreadPool :
```

```cpp
public
```

```cpp
bfd::WorkThreadPool {
```



```cpp

```

```cpp
public
```

```cpp
:
```



```cpp

```

```cpp
MyThreadPool(
```

```cpp
int
```

```cpp
size) : bfd::WorkThreadPool(size) {
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
void
```

```cpp
Handle(
```

```cpp
const
```

```cpp
string &msg) {
```



```cpp

```

```cpp
stringstream ss;
```



```cpp

```

```cpp
ss <<
```

```cpp
"worker ("
```

```cpp
<< std::this_thread::get_id() <<
```

```cpp
") got msg: "
```

```cpp
<< msg;
```



```cpp

```

```cpp
printf
```

```cpp
(
```

```cpp
"%s\n"
```

```cpp
, ss.str().c_str());
```



```cpp

```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
i=0; i<=999999; i++) {
```



```cpp

```

```cpp
double
```

```cpp
result =
```

```cpp
sqrt
```

```cpp
(
```

```cpp
sqrt
```

```cpp
(i) / 93.234);
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
}
```



```cpp
};
```





```cpp
int
```

```cpp
main() {
```



```cpp

```

```cpp
printf
```

```cpp
(
```

```cpp
"start running ....\n"
```

```cpp
);
```



```cpp

```

```cpp
MyThreadPool pool(5);
```



```cpp

```

```cpp
pool.Start();
```



```cpp

```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
i=0; i<100; i++) {
```



```cpp

```

```cpp
pool.SendMessage(
```

```cpp
"msg info ----------"
```

```cpp
);
```



```cpp

```

```cpp
}
```



```cpp

```

```cpp
pool.Stop();
```





```cpp

```

```cpp
return
```

```cpp
0;
```



```cpp
}
```
```





### 6. [代码]Makefile     [](https://www.oschina.net/code/piece_full?code=32565&piece=46850#46850)



[?](https://www.oschina.net/code/snippet_197384_32565#)

```
```cpp
LIB_SRC_FILES = src/workthreadpool.cpp src/lckfree.cpp
```



```cpp
TEST_SRC_FILES = src/main.cpp
```



```cpp
INCLUDE_DIR = src
```



```cpp
STD_FLAG = -std=c++0x
```





```cpp
all: main.o libs
```



```cpp

```

```cpp
g++ $(STD_FLAG) -o test_workthreadpool main.o libworkthreadpool.so -lpthread
```



```cpp

```



```cpp
main.o: $(TEST_SRC_FILES)
```



```cpp

```

```cpp
g++ $(STD_FLAG) -c $(TEST_SRC_FILES) -I$(INCLUDE_DIR)
```





```cpp
libs: $(LIB_SRC_FILES)
```



```cpp

```

```cpp
g++ $(STD_FLAG) -o libworkthreadpool.so -fPIC -O2 -shared -Wl,--no-as-needed -Isrc $(LIB_SRC_FILES) -lpthread
```





```cpp
.PHONY : clean
```



```cpp
clean :
```



```cpp

```

```cpp
rm -f test_workthreadpool main.o libworkthreadpool.so
```
```






举报











