# 简单字符设备驱动程序 - DoubleLi - 博客园






**linux驱动程序开发步骤**

1）查看原理图、数据手册，了解设备的操作方法。

2）在内核中找到相近的驱动程序，以它为模板进行开发，有时候需要从零开始。

3）实现驱动程序的初始化：比如向内核注册驱动程序，这样应用程序传入文件名时，内核才能找到相应的驱动程序。

4）设计所要实现的操作，比如open,read,write,close。

5）实现中断服务（不是必需的）

6）编译该驱动程序到中，或者用insmod命令加载。

7）测试驱动程序。



** 驱动框架**

应用程序API接口read,open,write 是对应驱动程序上的led_read,led_open,led_write的

1)写出驱动函数led_read,led_open,led_write

**每个系统调用，驱动程序怎样和它对应起来？？**

2)定义一个file_operations结构，和应用层API对接，

**Linux系统怎么知道去调用哪个驱动程序的file_operations??**

3)根据设备类型和主设备号

例如应用层程序open("dev/led");根据打开的文件属性中的根据设备类型和主设备号，找到内核中注册了的file_operations结构来判断是哪个驱动程序。

所以，要将注册函数将主设备号和file_operations一起注册到内核

4)最后把驱动程序加载到内核

如module_init(memdev_init);

加载时，就调用驱动初始化函数，向内核注册



|--------------------------------------------------------------------|

|           APP：open("dev/xxx");write();read()                 |

|              文件属性：设备类型   c  主设备号  11           |

|--------------------------------------------------------------------|

|                                       C库                                             |

|--------------------------------------------------------------------| 

|                  VFS                                  内核                       |

|                   chrdev数组 0,1,2...11...                              |

|                   找到对应的 file_operations                      |

|--------------------------------------------------------------------|

|                    1)led_read();led_write();led_open();      |

|驱动程序：2)定义了file_operations  关联APP函数  |

|                    3)chardev_region()注册到内核                |

|--------------------------------------------------------------------|          



**注意：  chardev_region()是2.4的接口， struct cdev是2.6的接口**



**一、重要知识点**

**1. 主次设备号**

dev_t

         dev_t是内核中用来表示设备编号的数据类型;

int MAJOR(dev_t dev)

int MINOR(dev_t dev)

         这两个宏抽取主次设备号。

dev­_t MKDEV(unsigned int major, unsigned int minor)

         这个宏由主/次设备号构造一个dev_t结构。



**2. 分配和释放设备号**

   静态申请设备号

int register_chardev_region(dev_t first,unsigned int count, char *name)  //分配成功时，返回0，错误时，返回一个负的错误码

参数：

first 要注册的第一个设备号

count 要注册的设备号个数

name 设备名

      Int alloc_chardev_region(dev_t *dev,unsigned int firstminor, unsigned int count, char *name)

//分配成功时，返回0，错误时，返回一个负的错误码

//alloc_chardev_region函数调用成功后，会把得到的设备号放入dev中

参数：

dev 分配到的设备号

firstminor 起始次设备号

count、name和静态一样

         动态申请设备号，注意第一个参数是传地址，而静态则是传值。



**     3. 几种重要的数据结构**

struct file

         file结构代表一个打开的文件，它由内核在open时创建，并传递给该文件上进行操作的所有函数，直到最后的close函数。

         file结构private_data是跨系统调用时保存状态信息非常有用的资源。

         file结构的f_ops 保存了文件的当前读写位置。

struct inode

         内核用inode代表一个磁盘上的文件，它和file结构不同，后者表示打开的文件描述符。对于单个文件，可能会有许多个表示打开文件的文件描述符file结构，但他们都指单个inode结构。inode的dev_t i_rdev成员包含了真正的设备编号，struct cdev *i_cdev包含了指向struct cdev结构的指针。

struct file_operations

         file_operations结构保存了字符设备驱动程序的方法。它是一个在 <linux/fs.h> 中定义的 struct file_operations 结构，这是一个内核结构，不会出现在用户空间的程序中，它定义了常见文件 I/O 函数的入口。系统调用函数通过内核，最终调用对应的 struct file_operations 结构的接口函数（例如，open() 文件操作是通过调用对应文件的file_operations 结构的 open 函数接口而被实现）。当然，每个设备的驱动程序不一定要实现其中所有的函数操作，若不需要定义实现时，则只需将其设为 NULL 即可。

**   4. 字符设备的注册和注销**

struct cdev *cdev_alloc(void);//分配

void cdev_init(struct cdev *dev, structfile_operations *fops);//初始化

int cdev_add(struct cdev *dev, dev_t num,unsigned int count);//添加

void cdev_del(struct cdev *dev);//移除

         用来管理cdev结构的函数，内核中使用该结构表示字符设备。注意cdev_add函数的count参数为次设备的个数，要想拥有多个次设备，就必须将该参数设为次设备的个数。

**     5. 并发处理**

         信号量和自旋锁的区别，使用信号量时当调用进程试图获得一个锁定了的锁时会导致进程睡眠，而自旋锁则是一直循法的等待一直到该锁解锁了为止。

         1)信号量

DECLARE_MUTEX(name);

DECLARE_MUTEX_LOCKED(name);

         声明和初始化用在互斥模式中的信号量的两个宏

void init_MUTEX(struct semaphore *sem)

void init_MUTEX_LOCKER(struct semaphore*sem);

         这两个函数可以在运行时初始化信号量

void down(struct semaphore *sem);

int down_interruptible(struct semaphore*sem);

int down_trylock(struct semahpore *sem);

void up(struct semaphore *sem);

         锁定和解锁信号量。如果必要,down会将调用进程置于不可中断的休眠状态；相反，down_interruptible可被信号中断。down_trylock不会休眠，并且会在信号量不可用时立即返回。锁定信号量的代码最后必须使用up解锁该信号量。

         2)自旋锁

spionlock_t lock = SPIN_LOCK_UNLOCKED;

spin_lock_init(spinlock_t *lock);

初始化自旋锁的两种方式。

         voidspin_lock(spinlock_t *lock);

锁定自旋锁

         voidspin_unlock(spinlock_t *lock);

         解锁自旋锁

**6. 驱动程序的加载和卸载 **

在2.6的内核中，模块的扩展名为.ko

使用insmod命令加载，当使用时，模块的初始化函数被调用，它用来向内核注册驱动程序

rmmod卸载

lsmod查看内核中已经加载了哪些模块



**module_init(memdev_init);**

**module_exit(memdev_exit);**

注意：模块有多种，例如文件系统也可以编译为模块，不一定只是驱动程序。



- 二、驱动代码  
- 
- #include <linux/module.h>  
- #include <linux/types.h>  
- #include <linux/fs.h>  
- #include <linux/errno.h>  
- #include <linux/mm.h>  
- #include <linux/sched.h>  
- #include <linux/init.h>  
- #include <linux/cdev.h>  
- #include <asm/io.h>  
- #include <asm/system.h>  
- #include <asm/uaccess.h>  
- 
- 
- #define MEMDEV_MAJOR 251   /*预设的mem的主设备号*/  
- #define MEMDEV_NUM 2  /*设备数*/  
- #define MEMDEV_SIZE 1024  //分配的内存大小  
- 
- struct mem_dev  
- {  
-          unsignedint size;  
- char*data;  
-          structsemaphore sem;  
- };  
- 
- static int mem_major = MEMDEV_MAJOR;  /*预设的mem的主设备号*/  
- struct cdev mem_cdev;  
- struct mem_dev *mem_devp; /*设备结构体指针*/  
- /*文件打开函数*/   
- static int mem_open(struct inode *inode,struct file *filp)  
- {  
- struct mem_dev *dev;  
-          unsignedint num;  
- 
-          printk("mem_open.\n");  
- 
-          num= MINOR(inode->i_rdev);//获得次设备号  
- if(num> (MEMDEV_NUM -1))          //检查次设备号有效性  
- return-ENODEV;  
- 
-          dev= &mem_devp[num];  
-          filp->private_data= dev; //将设备结构保存为私有数据  
- 
-          return0;  
- }  
- 
- static int mem_release(struct inode *inode,struct file *filp)  
- {  
-          printk("mem_release.\n");  
-          return0;  
- }  
- 
- static ssize_t mem_read(struct file *filp,char __user *buf, size_t size, loff_t *ppos)  
- {  
-          intret = 0;  
-          structmem_dev *dev;  
-          unsignedlong p;  
-          unsignedlong count;  
- 
-          printk("mem_read.\n");  
- 
-          dev= filp->private_data;//获得设备结构  
-          count= size;  
-          p= *ppos;  
- 
- //检查偏移量和数据大小的有效性  
- if(p> MEMDEV_SIZE)  
-                    return0;  
- if(count> (MEMDEV_SIZE-p))  
-                    count= MEMDEV_SIZE - p;  
- 
- if(down_interruptible(&dev->sem))//锁定互斥信号量  
- return -ERESTARTSYS;  
- 
- //读取数据到用户空间  
- if(copy_to_user(buf,dev->data+p, count)){  
-                    ret= -EFAULT;  
-                    printk("copyfrom user failed\n");  
-          }  
- else{  
-                    *ppos+= count;  
-                    ret= count;  
-                    printk("read%d bytes from dev\n", count);  
-          }  
- 
-          up(&dev->sem);//解锁互斥信号量  
- 
-          returnret;  
- }  
- 
- static ssize_t mem_write(struct file *filp,const char __user *buf, size_t size, loff_t *ppos)//注意：第二个参数和read方法不同  
- {  
-          intret = 0;  
-          structmem_dev *dev;  
-          unsignedlong p;  
-          unsignedlong count;  
- 
-          printk("mem_write.\n");  
- 
-          dev= filp->private_data;  
-          count= size;  
-          p= *ppos;  
- 
- if(p> MEMDEV_SIZE)  
-                    return0;  
- if(count> (MEMDEV_SIZE-p))  
-                    count= MEMDEV_SIZE - p;  
- 
- if(down_interruptible(&dev->sem))//锁定互斥信号量  
- return-ERESTARTSYS;  
- 
- if(copy_from_user(dev->data+p,buf, count)){  
-                    ret= -EFAULT;  
-                    printk("copyfrom user failed\n");  
-          }  
- else{  
-                    *ppos+= count;  
-                    ret= count;  
-                    printk("write%d bytes to dev\n", count);  
-          }  
- 
-          up(&dev->sem);//解锁互斥信号量  
- 
-          returnret;  
- }  
- 
- static loff_t mem_llseek(struct file *filp,loff_t offset, int whence)  
- {  
-          intnewpos;  
- 
-          printk("mem_llseek.\n");  
- 
- switch(whence)  
-          {  
-                    case0:  
-                             newpos= offset;  
- break;  
- 
-                    case1:  
-                             newpos= filp->f_pos + offset;  
- break;  
- 
-                    case2:  
-                             newpos= MEMDEV_SIZE - 1 + offset;  
- break;  
- 
- default:  
- return-EINVAL;  
-          }  
- 
- if((newpos<0)|| (newpos>(MEMDEV_SIZE - 1)))  
- return-EINVAL;  
- 
-          filp->f_pos= newpos;  
-          returnnewpos;  
- }  
- 
- /*文件操作结构体*/  
- static const struct file_operations mem_fops = {  
-          .owner= THIS_MODULE,  
-          .open= mem_open,  
-          .write= mem_write,  
-          .read= mem_read,  
-          .release= mem_release,  
-          .llseek= mem_llseek,  
- };  
- /*设备驱动模块加载函数*/  
- static int __init memdev_init(void)  
- {  
- int result;  
- int err;  
- int i;  
- 
- //申请设备号  
-          dev_t devno = MKDEV(mem_major, 0);  
- 
- if(mem_major)  
-                    result= register_chrdev_region(devno, MEMDEV_NUM, "memdev");//注意静态申请的dev_t参数和动态dev_t参数的区别  
- else{        //静态直接传变量，动态传变量指针  
-                    result= alloc_chrdev_region(&devno, 0, MEMDEV_NUM, "memdev");  
-                    mem_major= MAJOR(devno);  
-          }  
- 
- if(result< 0){  
-                    printk("can'tget major devno:%d\n", mem_major);  
-                    returnresult;  
-          }  
- 
- //注册设备驱动  
-          cdev_init(&mem_cdev,&mem_fops);  /*初始化cdev结构*/  
-          mem_cdev.owner= THIS_MODULE;  
- 
- /* 注册字符设备 */  
- 
-          err= cdev_add(&mem_cdev, MKDEV(mem_major, 0), MEMDEV_NUM);//如果有N个设备就要添加N个设备号  
- if(err)  
-                    printk("addcdev faild,err is %d\n", err);  
- 
- //分配设备内存  
-          mem_devp= kmalloc(MEMDEV_NUM*(sizeof(struct mem_dev)), GFP_KERNEL);  
- if(!mem_devp){  
-                     result = - ENOMEM;  
- goto fail_malloc;  
-          }  
-          memset(mem_devp,0, MEMDEV_NUM*(sizeof(struct mem_dev)));  
- 
- 
- for(i=0;i<MEMDEV_NUM; i++){  
-                    mem_devp[i].size= MEMDEV_SIZE;  
-                    mem_devp[i].data= kmalloc(MEMDEV_SIZE, GFP_KERNEL);  
-                    memset(mem_devp[i].data,0, MEMDEV_SIZE);  
-                    init_MUTEX(&mem_devp[i].sem);//初始化互斥锁  
-          }  
- 
-          returnresult;  
- 
- fail_malloc:  
-          unregister_chrdev_region(MKDEV(mem_major,0), MEMDEV_NUM);  
-          returnresult;  
- }  
- 
- static void memdev_exit(void)  
- {  
-          cdev_del(&mem_cdev);  
-          unregister_chrdev_region(MKDEV(mem_major,0), MEMDEV_NUM);//注意释放的设备号个数一定要和申请的设备号个数保存一致  
- //否则会导致设备号资源流失  
-          printk("memdev_exit\n");  
- }  
- 
- module_init(memdev_init);  
- module_exit(memdev_exit);  
- 
- MODULE_AUTHOR("Y-Kee");  
- MODULE_LICENSE("GPL");  










**三、疑点难点**



1.

__init

__initdata

__exit

__exitdata

         仅用于模块初始化或清除阶段的函数(__init和__exit)和数据(__initdata和__exitdata)标记。标记为初始化项目会在初始化结束后丢弃；而退出在内核未被配置为可卸载模块的情况下被简单的丢弃。被标记为__exit的函数只能在模块卸载或者系统关闭时被调用，其他任何用法都是错误的。内核通过对应的目标对象放置在可执行文件的特殊ELF段中而让这些标记起作用。



2.static

         初始化函数应该被声明为static，因为这种函数在特定文件之外没有其他意义。因为一个模块函数要对内核其他部分课件，则必须显示导出，因此这并不是什么强制性规则。



3. struct module *owner

         内核使用这个字段以避免在模块操作正在使用时卸载该模块。几乎在所有的情况下，该成员都会被初始化为THIS_MODULE。它是定义在<linux/module.h>中的一个宏。



4 __user

         我们会注意到许多参数包括含有__user字串，它其实是一种形式的文档而已，表面指针是一个用户指针，因此不能被直接用。对通常的编译来讲，__user没有任何效果，但是可由外部检查软件使用，用来寻找对用户空间地址错误使用。









from:http://blog.csdn.net/jianchi88/article/details/6797057









