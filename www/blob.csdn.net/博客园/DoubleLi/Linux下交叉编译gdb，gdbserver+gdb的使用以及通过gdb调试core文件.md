# Linux下交叉编译gdb，gdbserver+gdb的使用以及通过gdb调试core文件 - DoubleLi - 博客园






**交叉编译gdb和gdbserver**

1、下载gdb：
下载地址为：[http://ftp.gnu.org/gnu/gdb/](http://ftp.gnu.org/gnu/gdb/)
按照一般的想法，最新版本越好，因此下载7.2这个版本。当然，凡事无绝对。
我们以gdb-7.2.tar.bz2 这个文件为例。
2、解压缩：

> $ tar jxvf gdb-7.2.tar.bz2

注：小技巧：Linux下一般压缩文件后缀为.tar.bz2和.tar.gz，它们解压命令有两三个选项是一致的：

xf（v），前者再加上j选项，后者再加上z选项。

3、进入该目录

> $ cd gdb-7.2/

4、配置

> $./configure --target=arm-linux --program-prefix=arm-linux- --prefix=/usr/local/arm-gdb

注**：--target=arm-linux**意思是说目标平台是运行于ARM体系结构的linux内核**；--program-prefix=arm-linux-**是指生成的可执行文件的前缀，比如arm-linux-gdb**，--prefix**是指生成的可执行文件安装在哪个目录，这个目录需要根据实际情况作选择。如果该目录不存在，会自动创建，当然，权限足够的话。

5、编译、安装

> 
$  make

$ make install


幸运的话，会在--prefix指定的目录下生成三个子目录：bin、lib、share，我们需要的arm-linux-gdb就在其中的bin目录下。
如果你不小心查看它的大小的话，会发觉它有14MB那么大！天呐！怎么会占这么多空间？没关系，我们可以为它瘦身。没错！就是使用strip命令！

> $ strip arm-linux-gdb -o arm-linux-gdb-stripped
$ ls -lh 
总计 33M

-rwxr-xr-x 1 latelee root 14M 12-14 16:16 arm-linux-gdb

-rwxr-xr-x 1 latelee root 3.1M 12-14 16:25 arm-linux-gdb-stripped



可以看到，strip后的文件大小只有3.1MB，瘦身效果明显！如果做广告的话，绝对有说服力。
这个文件就是我们以后远程调试时在主机上运行的交叉调试器了：在主机上执行，调试的却是另一种体系结构的代码。但是，光有主机的调试器还不够。还需要在目标板上运行一个叫gdbserver的东东。这个东东是怎么来的呢？

1、在刚才那个gdb解压后的目录：gdb-7.2，进入./gdb/gdbserver子目录

> 
> **gdbserver**

> **1、cd gdb/gdbserver/**

> **2、配置： ./configure --target=arm-hismall-linux --host=arm-hismall-linux ****--prefix=/mnt/hgfs/vmshare/gdbserver7.41/**

> **(同样，target 和 host 为你的交叉编译器， prefix为安装的目录)**

> 

> **3、编译： make CC=****make CC=arm-hismall-linux-gcc**

> **出现错误：**

> **linux-arm-low.c: In function `arm_stopped_by_watchpoint':**

> **linux-arm-low.c:642: error: `PTRACE_GETSIGINFO' undeclared (first use in this function)**

> **linux-arm-low.c:642: error: (Each undeclared identifier is reported only once**

> **linux-arm-low.c:642: error: for each function it appears in.)**

> 

> **解决方法：这里提示没有PTRACE_GETSIGINFO这个东西，这里搜索PTRACE_GETSIGINFO的路径为-I指定的头文件以及交叉 编译工**

> 

> **具链，我们不妨到交叉编译工具链里面去查找一下：**

> **cd /usr/local/arm/3.4.5/**

> **grep "PTRACE_GETSIGINFO" * -nR**

> **找到如下信息：**

> **arm-linux/sys-include/linux/ptrace.h:27:#define PTRACE_GETSIGINFO       0x4202**

> **arm-linux/include/linux/ptrace.h:27:#define PTRACE_GETSIGINFO   0x4202**

> **distributed/arm-linux/sys-include/linux/ptrace.h:27:#define PTRACE_GETSIGINFO  0x4202**

> **distributed/arm-linux/include/linux/ptrace.h:27:#define PTRACE_GETSIGINFO       0x4202**

> **说明PTRACE_GETSIGINFO是在交叉编译工具链：linux/ptrace.h文件里定义的，那么可能是头文件没有包含好吧！**

> **我们到gdbserver下的linux-arm-low.c里面一看，可不是嘛，只有：#include <sys/ptrace.h>而没有：#include **

> 

> **<linux/ptrace.h>，于是在****linux-arm-low.c文件中****加上：#include <linux/ptrace.h>，再次编译：make CC=/usr/local/arm/3.4.5/bin/arm-linux-gcc**

> **成功！**


32位，ARM平台，动态链接，未strip。
同样，我们也减小它的体积：



**     # arm-hismall-linux-strip gdbserver**



**[root@localhost gdbserver]# ls gdbserver -l**

-rwxrwxrwx 1 root root 498279 2012-12-30 06:21 gdbserver



[root@localhost gdbserver]# ls gdbserver -l

-rwxrwxrwx 1 root root 209048 2012-12-30 06:53 gdbserver

瘦身效果同样那么明显！
注意，这里必须使用strip的交叉版本，也就是你交叉编译器带的strip工具，我的是**arm-hismall-linux-strip**。



> 
> **[root@localhost gdbserver]# file gdbserver**


> 
> **gdbserver: ELF 32-bit LSB executable, ARM, version 1, dynamically linked (uses shared libs), stripped**


到此，我们生成了两个重量级别的文件：**arm-linux-gdb**和**gdbserver**。它们的版本是一致的，这一点非常重要。我们需要将gdbserver下载到开发板中，——可以通过各种各样的手段，包括但不限于NFS。调试时需要在开发板中运行这个程序。同时在主机中执行arm-linux-gdb调试器。





**GDB+GDBServer****的使用**

在目标系统上启动gdbserver,其实就是在超级终端下或者minicom下启动gdbserver。这里将gdbserver放在宿主机的NFS设置的共享目录下/home/zzl，该目录挂载在目标板/work下。宿主机的ip为192.168.1.1,目标板的ip为192.168.1.33

超级终端或者minicom下

[root@localhost]cd /work

[root@localhost]./gdbserver 192.168.1.1:1234 hello

出现提示：
Process /work/hello created: pid=69
Listening on port 1234

这时切换到宿主机的控制台，运行

[root@localhost] arm-softfloat-linux-gnu-gdb hello

(gdb) target remote 192.168.2.33:1234

出现提示：
Remote debugging using 192.168.1.33:1234
[New thread 80]
[Switching to thread 80]
0x40002a90 in ??()
同时在minicom下提示：
Remote debugging from host 192.168.2.100
(gdb)
连接成功，这时候就可以输入各种gdb命令如list、continue、next、step、break等进行程序调试了。



**使用GDB调试core文件**

$ gdb --core=core.9128 
GNU gdb Asianux (6.0post-0.20040223.17.1AX) 
Copyright 2004 Free Software Foundation, Inc. 
GDB is free software, covered by the GNU General Public License, and you are 
welcome to change it and/or distribute copies of it under certain conditions. 
Type "show copying" to see the conditions. 
There is absolutely no warranty for GDB. Type "show warranty" for details. 
This GDB was configured as "i386-asianux-linux-gnu". 
Core was generated by `./a.out'. 
Program terminated with signal 11, Segmentation fault. 
#0 0x08048373 in ?? () 
(gdb) bt 
#0 0x08048373 in ?? () 
#1 0xbfffd8f8 in ?? () 
#2 0x0804839e in ?? () 
#3 0xb74cc6b3 in ?? () 
#4 0x00000000 in ?? () 

此时用bt看不到backtrace，也就是调用堆栈，原来GDB还不知道符号信息在哪里。我们告诉它一下： 

(gdb) file ./a.out 
Reading symbols from ./a.out...done. 
Using host libthread_db library "/lib/tls/libthread_db.so.1". 
(gdb) bt 
#0 0x08048373 in sub () at foo.c:17 
#1 0x08048359 in main () at foo.c:8 

此时backtrace出来了。 

(gdb) l 
8        sub(); 
9        return 0; 
10    } 
11 
12    static void sub(void) 
13    { 
14        int *p = NULL; 
15 
16         
17        printf("%d", *p); 
(gdb) 





**对于GDBServer****出现的问题**

1．GDBServer调试时出现packet error 问题。

主要是虚拟机与目标机的网络连接要经过windows，数据包容易丢失。换到Linux系统下则恢复正常。









