# 嵌入式/X86下linux系统死机及内存优化 - DoubleLi - 博客园






**一.  CPU 过高或死锁导致系统卡死**



**1. CPU占用过高**

**（1）开线程太多导致CPU占用过高，系统卡死**

 解决：优化应用层业务逻辑，有些业务不必开线程就不开

**（2）频繁清缓存导致读spi-flash频繁，引起CPU过高**

解决：在内核中文件系统部分进行处理，不去清缓存，然后在应用层用后台服务进程清缓存。这样可能导致系统内存不够用，这样就需要再对系统内存进行优化



**2. CPU死锁**

（1）Spinlock+死等导致死锁

（2）应用层pthread_mutex_lock死锁



**3.  CPU过热导致系统启动失败**

（1）CPU超过BIOS的设定阈值导致内核启动失败

（2）CPU确实太热，加风扇、扇热片，或者对结构进行优化



**4. 灰尘太多、环境恶劣等因素导致电源异常**



**二． 内存问题导致系统死机**

**1. 虚拟内存耗尽**

（1）线程开太多，导致虚拟内存到达3G，出现主程序挂死，但系统不会死机

确认方法：假如系统进程号为pid，那么查看/proc/pid/status可以看到开的线程数及虚拟、物理内存。另外用top也可以看到虚拟内存或物理内存，有的Busybox编译问题，看不到物理内存占用情况，这样就要根据/proc/pid/status，或者查看如下字段：

cat /proc/pid/stat | awk -F" " '{print "virt:"$23}'

cat /proc/pid/stat | awk -F" " '{print "rss:"$24}'

解决方法：调整应用层策略，可不开的线程就不开



**2. 物理内存耗尽（OOM）**

（1）这种一般都是内存泄露问题

确认方法：

A. 通过top确认物理内存增长情况

B. 通过/proc/pid/status统计物理内存增长情况，或者/proc/pid/stat



解决方法：

（1）通过review malloc/free来解决

（2）通过工具检查valgrind、oprofile、perf等工具

（3）静态检查工具：flint、pclint



**（2）确实物理内存不够用**

解决方法：内存优化

**3. 内存碎片过多，伙伴系统大块内存耗尽**

这是系统会出现内存OOM，通过OOM或者/proc/sysrq-tigger可以看到伙伴系统、slab缓存的内存分布情况，根据使用地方进行优化。

我们出现过一个问题，CPU过高时产生大量内存碎片，而CPU过高是因为清缓存后CPU读flash导致，CPU读flash到内存会产生内存碎片，这样可以通过CPU清缓存的时机来解决，或者就不去清缓存。

其他内存碎片处理方法：



**三． 硬件问题**

（1）外接串口一端悬空产生天线效应导致串口中断过多

（2）SIO信号干扰导致大量中断产生，系统卡住



**四． 开机速度优化方法**

（1）精简内核业务，没有用到的模块可以不编译进去，这种模块还是很多的

（2）将可以开机后加载的驱动编译成ko单独加载

（3）通过编译器编译选项优化

（4）增加flash的读取速度，调整flash时钟

（5）使用非压缩内核

（6）关闭串口打印输出

（7）XIP技术（eXecute In Place）

内核XIP：直接在flash/ROM中运行内核，或者使用非压缩内核vmlinux肯定比zImage、uImage快

文件系统XIP：比如cramfs文件系统，只把用到的部分读取到RAM中，要比jiffs2节省时间

（8）图形界面系统采用直接写framebuff，而不用C++/QT的GUI



**五． 内存优化方法**

（1）物理内存实在不够，即使没有内存泄露也不够，考虑交换内存

（2）优化数据结构，合理申请内存

（3）在适当的时间进行内存回收

（4）堆内存最小单位为16字节所以应尽量减少小块内存的申请，避免内存浪费

（5）调整M_MMAP_THRESHOLD,降低mmap的门槛，会降低内存空洞的风险，但也会增加系统调用，降低性能。

（6）调整M_TRIM_THRESHOLD,减少堆顶连续内存门槛，释放更多的堆顶内存。

（7）使用ptmalloc工具、oprofile、valgrind、perf等工具优化









