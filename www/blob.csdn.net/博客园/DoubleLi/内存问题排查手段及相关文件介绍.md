# 内存问题排查手段及相关文件介绍 - DoubleLi - 博客园







[[-]](http://blog.csdn.net/xiangpingli/article/details/39623979)
- [内存问题排查手段及相关文件介绍重点](http://blog.csdn.net/xiangpingli/article/details/39623979#t0)
- [1 procsysvmmin_free_kbytes](http://blog.csdn.net/xiangpingli/article/details/39623979#t1)
- [2 procsysvmdrop_caches](http://blog.csdn.net/xiangpingli/article/details/39623979#t2)
- [3 procsysrq-trigger](http://blog.csdn.net/xiangpingli/article/details/39623979#t3)
- [31对echo m procsysrq-trigger输出的解析](http://blog.csdn.net/xiangpingli/article/details/39623979#t4)
- [4 cat procslabinfo](http://blog.csdn.net/xiangpingli/article/details/39623979#t5)
- [5 cat procmeminfo](http://blog.csdn.net/xiangpingli/article/details/39623979#t6)
- [51 重要信息](http://blog.csdn.net/xiangpingli/article/details/39623979#t7)
- [6 top信息](http://blog.csdn.net/xiangpingli/article/details/39623979#t8)
- [7 free命令](http://blog.csdn.net/xiangpingli/article/details/39623979#t9)
- [8 procsysvm目录下的其他文件](http://blog.csdn.net/xiangpingli/article/details/39623979#t10)





# 5. 内存问题排查手段及相关文件介绍【重点】

对于内存问题排查，或者OOM问题排查，一般会涉及到如下文件，下面将如下文件的分析和设置介绍一下，这也是本文档的重点，后面排查内存信息还是要根据这些文件信息来排查。其实未必是有内存泄露，也可能是一些策略有问题，比如线程数目的增加，buffer的申请、释放时间交集等。

## 5.1 /proc/sys/vm/min_free_kbytes

min_free_kbytes用来确定系统开始回收内存的阀值，控制系统的空闲内存。值越高，内核越早开始回收内存，空闲内存越高。

可以使用如下方式：echo 65535 >　/proc/sys/vm/min_free_kbytes将系统保留内存设置为6M。

## 5.2 /proc/sys/vm/drop_caches

清系统缓存：

#echo 1 > /proc/sys/vm/drop_caches 清理页缓存

#echo 2 > /proc/sys/vm/drop_caches 清理文件缓存

#echo 3 > /proc/sys/vm/drop_caches 清理也缓存和文件缓存

## 5.3 /proc/sysrq-trigger

当一个sysrq命令被触发，内核将会打印信息到内核的环形缓冲并输出到系统控制台。此信息一般也会通过syslog输出到/var/log/messages.

有时候，可能系统已经无法响应，syslogd可能无法记录此信息。在这种情况下，建议您配置一个串口终端来收集这个信息。

#echo m > /proc/sysrq-trigger 导出内存分配信息

#echo t > /proc/sysrq-trigger 导出线程状态信息

#echo 　p >　/proc/sysrq-trigger　导出当前CPU寄存器信息和标志位的信息

#echo w > /proc/sysrq-trigger将进入uninterrupted状态的任务的信息dump出来

### 5.3.1对echo m > /proc/sysrq-trigger输出的解析



root@ubuntu:/home/linux# echo m >/proc/sysrq-trigger

root@ubuntu:/home/linux# dmesg -c

SysRq : Show Memory

Mem-Info:

DMA per-cpu:

CPU   0: hi:    0, btch:   1 usd:  0

CPU   1: hi:    0, btch:   1 usd:  0

Normal per-cpu:

CPU   0: hi:  186, btch:  31 usd: 93

CPU   1: hi:  186, btch:  31 usd: 140

HighMem per-cpu:

CPU   0: hi:  186, btch:  31 usd: 185

CPU   1: hi:  186, btch:  31 usd: 13

active_anon:22129 inactive_anon:645isolated_anon:0

active_file:52387 inactive_file:81072isolated_file:0

unevictable:0 dirty:6 writeback:0unstable:0

free:336695 slab_reclaimable:12052slab_unreclaimable:2825

mapped:11208 shmem:892 pagetables:795bounce:0

free_cma:0

DMA free:15900kB min:788kB low:984kBhigh:1180kB active_anon:0kB inactive_anon:0kB active_file:0kB inactive_file:0kBunevictable:0kB isolated(anon):0kB isolated(file):0kB present:15992kBmanaged:15916kB mlocked:0kB dirty:0kB writeback:0kB mapped:0kB shmem:0kBslab_reclaimable:0kB slab_unreclaimable:16kB kernel_stack:0kB pagetables:0kBunstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:0all_unreclaimable? no

lowmem_reserve[]: 0 843 1999 1999

Normal free:635940kB min:42908kBlow:53632kB high:64360kB active_anon:0kB inactive_anon:0kB active_file:75608kBinactive_file:85104kB unevictable:0kB isolated(anon):0kB isolated(file):0kBpresent:897016kB managed:864652kB mlocked:0kB dirty:24kB writeback:0kBmapped:4kB shmem:0kB slab_reclaimable:48208kB slab_unreclaimable:11284kBkernel_stack:1696kB pagetables:0kB unstable:0kB bounce:0kB free_cma:0kBwriteback_tmp:0kB pages_scanned:0 all_unreclaimable? no

lowmem_reserve[]: 0 0 9247 9247

HighMem free:694940kB min:512kBlow:15208kB high:29908kB active_anon:88516kB inactive_anon:2580kBactive_file:133940kB inactive_file:239184kB unevictable:0kB isolated(anon):0kBisolated(file):0kB present:1183624kB managed:1183624kB mlocked:0kB dirty:0kBwriteback:0kB mapped:44828kB shmem:3568kB slab_reclaimable:0kBslab_unreclaimable:0kB kernel_stack:0kB pagetables:3180kB unstable:0kBbounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? no

lowmem_reserve[]: 0 0 0 0

DMA: 1*4kB (U) 1*8kB (U) 1*16kB (U)0*32kB 2*64kB (U) 1*128kB (U) 1*256kB (U) 0*512kB 1*1024kB (U) 1*2048kB (R)3*4096kB (M) = 15900kB

Normal: 1*4kB (M) 6*8kB (UEM)3*16kB (UM) 2*32kB (EM) 2*64kB (UE) 2*128kB (UE) 2*256kB (UM) 2*512kB (UE)1*1024kB (M) 1*2048kB (U) 154*4096kB (MR) = 635940kB

HighMem: 59*4kB (UM) 10*8kB (UM) 2*16kB(M) 58*32kB (UM) 48*64kB (UM) 4*128kB (UM) 2*256kB (UM) 1*512kB (M) 0*1024kB0*2048kB 168*4096kB (UMR) = 694940kB

Node 0 hugepages_total=0hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB

134350 total pagecache pages

0 pages in swap cache

Swap cache stats: add 0, delete 0, find0/0

Free swap  = 1045500kB

Total swap = 1045500kB

524287 pages RAM

295938 pages HighMem

8303 pages reserved

647658 pages shared

93503 pages non-shared

root@ubuntu:/home/linux#

**主要关注如下几个参数：**

active_anon：匿名映射的页，这些映射是与文件无关的

active_file：文件映射的页，这些映射和文件有关

mapped：设备和文件映射的大小

slab_reclaimable：内核数据结构缓存的大小，可减少申请和释放内存带来的消耗

active_anon + active_file + mapped = 应用所使用的大小

active_anon + active_file + mapped +slab_reclaimable = 目前所使用的所有内存大小

**另外我们一般还会关注：**

Normal: 1*4kB (M) 6*8kB (UEM)3*16kB (UM) 2*32kB (EM) 2*64kB (UE) 2*128kB (UE) 2*256kB (UM) 2*512kB (UE)1*1024kB (M) 1*2048kB (U) 154*4096kB (MR) = 635940kB

这里是buddy system（伙伴系统）的内存信息，如果这里比较大块的内存不多，也很容易出现内存申请失败，或者触发OOM问题

## 5.4 cat /proc/slabinfo

一般来说内核程序中对小于一页的小块内存的请求才通过Slab分配器提供的接口Kmalloc来完成。因为slab分配的缓存都是比较小块的缓存，所以一般情况下我们分析内存性能时，对这里不会太关注，因为其对系统整体内存性能影响不会太大，并且内核中的kmalloc相对问题较少，应用层的问题较多。

不过可以通过如下信息获取slab缓存的使用情况：

root@ubuntu:/home/linux# cat/proc/slabinfo

查看slab信息，除了看slabinfo文件外，还可以执行/usr/bin/slabtop命令：

以上是一个/proc/slabinfo文件的信息

root@ubuntu:/home/linux#/usr/bin/slabtop

 Active / Total Objects (% used)    : 311009 / 312759 (99.4%)

 Active / Total Slabs (% used)      : 7308 / 7308 (100.0%)

 Active / Total Caches (% used)     : 66 / 100 (66.0%)

 Active / Total Size (% used)       : 58479.13K / 58915.22K (99.3%)

 Minimum / Average / Maximum Object : 0.01K /0.19K / 8.00K



 OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME                  

 73949 73949 100%    0.05K   1013      73      4052K buffer_head

 66976 66686  99%    0.12K  2093       32      8372K dentry

 47100 47100 100%    0.63K   1884      25     30144K ext4_inode_cache

该命令的输出字段的意义：

OBJS — The total number of objects(memory blocks), including those in use (allocated), and some spares not inuse.

ACTIVE — The number of objects (memoryblocks) that are in use (allocated).

USE — Percentage of total objects thatare active. ((ACTIVE/OBJS)(100))

OBJ SIZE — The size of the objects.

SLABS — The total number of slabs.

OBJ/SLAB — The number of objects thatfit into a slab.

CACHE SIZE — The cache size of theslab.

NAME — The name of the slab.

## 5.5 cat /proc/meminfo

### 5.5.1 重要信息

对于该文件，比较重要的是Active、Active(anon)、Active(file)、Mapped、Slab，类似于sysrq-trigger中所说，存在如下计算关系：

Active = Active(anon) + Active(file)

Active(anon)+Ac tive(file)+Mapped = 应用

Active(anon)+Ac tive(file)+Mapped +Slab= 系统总共使用内存

5.5.2 meminfo文件各字段说明

$cat /proc/meminfo

MemTotal:        2052440 kB //总内存

MemFree:           50004 kB //空闲内存

Buffers:           19976 kB //给文件的缓冲大小

Cached:           436412 kB //高速缓冲存储器(http://baike.baidu.com/view/496990.htm)使用的大小

SwapCached:        19864 kB //被高速缓冲存储用的交换空间大小

Active:          1144512 kB //活跃使用中的高速缓冲存储器页面文件大小

Inactive:         732788 kB //不经常使用的高速缓冲存储器页面文件大小

Active(anon):     987640 kB //anon：不久

Inactive(anon):   572512 kB

Active(file):     156872 kB

Inactive(file):   160276 kB

Unevictable:           8 kB

Mlocked:               8 kB

HighTotal:       1177160 kB //The total and free amountof memory, in kilobytes, that is not directly mapped into kernel space.

HighFree:           7396 kB // The HighTotal value canvary based on the type of kernel used.

LowTotal:         875280 kB // The total and free amountof memory, in kilobytes, that is directly mapped into kernel space.  used.

LowFree:           42608 kB //The LowTotal value canvary based on the type of kernel

SwapTotal:        489940 kB //交换空间总大小

SwapFree:         450328 kB //空闲交换空间

Dirty:               104 kB //等待被写回到磁盘的大小

Writeback:             0 kB //正在被写回的大小

AnonPages:       1408256 kB //未映射的页的大小

Mapped:           131964 kB //设备和文件映射的大小

Slab:              37368 kB //内核数据结构缓存的大小，可减少申请和释放内存带来的消耗

SReclaimable:      14164 kB //可收回slab的大小

SUnreclaim:        23204 kB //不可收回的slab的大小23204+14164=37368

PageTables:        13308 kB //管理内存分页的索引表的大小

NFS_Unstable:          0 kB //不稳定页表的大小

Bounce:                0 kB //bounce:退回

WritebackTmp:          0 kB //

CommitLimit:     1516160 kB

Committed_AS:    2511900 kB

VmallocTotal:     122880 kB //虚拟内存大小

VmallocUsed:       28688 kB //已经被使用的虚拟内存大小

VmallocChunk:      92204 kB

HugePages_Total:       0//大页面的分配

HugePages_Free:        0

HugePages_Rsvd:        0

HugePages_Surp:        0

Hugepagesize:       2048 kB

DirectMap4k:       10232 kB

DirectMap2M:      899072 kB

## 5.6 top信息

**VIRT：virtual memory usage 虚拟内存**
1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等
2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量

**RES：resident memory usage常驻内存（物理内存）**
1、进程当前使用的内存大小，但不包括swap out
2、包含其他进程的共享
3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反
4、关于库占用内存的情况，它只统计加载的库文件所占内存大小

**SHR：shared memory 共享内存**
1、除了自身进程的共享内存，也包括其他进程的共享内存
2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
3、计算某个进程所占的物理内存大小公式：RES – SHR
4、swap out后，它将会降下来

**DATA**
1、数据占用的内存。如果top没有显示，按f键可以显示出来。
2、真正的该程序要求的数据空间，是真正在运行中要使用的。

**top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：**
s – 改变画面更新频率
l – 关闭或开启第一部分第一行 top 信息的表示
t – 关闭或开启第一部分第二行 Tasks 和第三行Cpus 信息的表示
m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap信息的表示
N – 以 PID 的大小的顺序排列表示进程列表
P – 以 CPU 占用率大小的顺序排列进程列表
M – 以内存占用率大小的顺序排列进程列表
h – 显示帮助
n – 设置在进程列表所显示进程的数量
q – 退出 top
s – 改变画面更新周期

序号 列名 含义
a PID 进程id
b PPID 父进程id
c RUSER Real user name
d UID 进程所有者的用户id
e USER 进程所有者的用户名
f GROUP 进程所有者的组名
g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?
h PR 优先级
i NI nice值。负值表示高优先级，正值表示低优先级
j P 最后使用的CPU，仅在多CPU环境下有意义
k %CPU 上次更新到现在的CPU时间占用百分比
l TIME 进程使用的CPU时间总计，单位秒
m TIME+ 进程使用的CPU时间总计，单位1/100秒
n %MEM 进程使用的物理内存百分比
o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。
q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
r CODE 可执行代码占用的物理内存大小，单位kb
s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
t SHR 共享内存大小，单位kb
u nFLT 页面错误次数
v nDRT 最后一次写入到现在，被修改过的页面数。
w S 进程状态。（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）
x COMMAND 命令名/命令行
y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名
z Flags 任务标志，参考 sched.h

默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。

通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。
按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。
按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。

## 5.7 free命令





free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free）

free输出地第二行和第三行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。

第2行的输出时从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:

24677460KB（缺省时free的单位为KB）物理内存；

在这些物理内存中有23276064KB被使用了；

还用1401396KB是可用的；

第3行：

-buffers/cache，表示一个应用程序认为系统被用掉多少内存；

+buffers/cache，表示一个应用程序认为系统还有多少内存；

## 5.8 /proc/sys/vm/目录下的其他文件

**1. /proc/sys/vm/block_dump**
该文件表示是否打开Block Debug模式，用于记录所有的读写及DirtyBlock写回动作。
缺省设置：0，禁用BlockDebug模式


**2. /proc/sys/vm/dirty_background_ratio**
该文件表示脏数据到达系统整体内存的百分比，此时触发pdflush进程把脏数据写回磁盘。
缺省设置：10

**3. /proc/sys/vm/dirty_expire_centisecs**
该文件表示如果脏数据在内存中驻留时间超过该值，pdflush进程在下一次将把这些数据写回磁盘。
缺省设置：3000（1/100秒）


**4. /proc/sys/vm/dirty_ratio**
该文件表示如果进程产生的脏数据到达系统整体内存的百分比，此时进程自行把脏数据写回磁盘。
缺省设置：40


**5./proc/sys/vm/dirty_writeback_centisecs**
该文件表示pdflush进程周期性间隔多久把脏数据写回磁盘。
缺省设置：500（1/100秒）


**6. /proc/sys/vm/vfs_cache_pressure**
该文件表示内核回收用于directory和inode cache内存的倾向；缺省值100表示内核将根据pagecache和swapcache，把directory和inode cache保持在一个合理的百分比；降低该值低于100，将导致内核倾向于保留directory和inode cache；增加该值超过100，将导致内核倾向于回收directory和inode cache
缺省设置：100


**7. /proc/sys/vm/min_free_kbytes**
该文件表示强制Linux VM最低保留多少空闲内存（Kbytes）。
缺省设置：724（512M物理内存）


**8. /proc/sys/vm/nr_pdflush_threads**
该文件表示当前正在运行的pdflush进程数量，在I/O负载高的情况下，内核会自动增加更多的pdflush进程。
缺省设置：2（只读）


**9. /proc/sys/vm/overcommit_memory**
该文件指定了内核针对内存分配的策略，其值可以是0、1、2。
0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。
1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。
2， 表示内核允许分配超过所有物理内存和交换空间总和的内存（参照overcommit_ratio）。
缺省设置：0


**10. /proc/sys/vm/overcommit_ratio**
该文件表示，如果overcommit_memory=2，可以过载内存的百分比，通过以下公式来计算系统整体可用内存。
系统可分配内存=交换空间+物理内存*overcommit_ratio/100
缺省设置：50（%）


**11. /proc/sys/vm/page-cluster**
该文件表示在写一次到swap区的时候写入的页面数量，0表示1页，1表示2页，2表示4页。
缺省设置：3（2的3次方，8页）


**12. /proc/sys/vm/swapiness**
该文件表示系统进行交换行为的程度，数值（0-100）越高，越可能发生磁盘交换。










