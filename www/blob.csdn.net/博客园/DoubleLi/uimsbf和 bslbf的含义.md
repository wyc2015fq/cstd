# uimsbf和 bslbf的含义 - DoubleLi - 博客园






bslbf代表位串，即“Bit string, left bit first ”，

uimsbf代表无符号整数，即”unsinged integer, most significant bit first”，数字表示该数据项所占的比特数



又一解释：



bslbf  （bit string, left bit first）  比特串，左位在先

uimsbf  （unsigned integer，most significant bit first）  无符号整数，高位在先



我也写一点经验吧，可能以后还有人查这个资料。
这两个单位的本身都是一样的都是bit的意思，就是2进制， 如何转换16进制，就用数手指吧……比如说4位的2进制那就是1111，然后数手指就数出来了~==！==
所谓用bslbf是因为这个串没到一个字节，或是不是字节的整数倍数，才用这种所谓“从左边数起多少位的比特流”
在数字电视领域，SI的规范里面，基本上所有的描述信息都是由一串有序的这种规则构成。比如5楼的：
Vision ：4 bslbf  这是4位 ，半个字节，可以表达的区间是1111= 0xF
head_length:4 bslbf 同上,一个tag表示位必须对应一个length位，但是length位不一定要对应tag位，可以是在某个tag里面，私有约定哪几位是表示后面具体负载的长度。比如说后面有4个字节，这里的length就是0x4了
service_id:16 uimsbf 这是两个字节的表示位，11111111 11111111 = 0xFFFF
msg_id:16 uimsbf
在传输流里面传输的东西是一个：
tag  协议栈约定当收到的时候监听，当约定tag位长为1个字节时，例如是0x16
length： 前端发送的，表示这个tag包含的内容的具体长度，按照上面的例子，就是一共有5个字节的位长，一个字节是2的长度“0xFF”，所以在这里的例子是0xA的长度，约定length位的位长是2个字节的话，就是0x000A。
在C里面，解析这些东西是通过位计算（操作），因为传输流里面下来的数据大概是如下：
FDAIFNIWOQNIZNIUC!#@$%^#$@!%@16000AF4FFFFFFFF%%&……*……%%在整个传输流中，只有收到某一个程序里面写的tag后，才开始工作。
关于用C如何表示，其实必须有一个接口能把数据传近来，然后监听约定的值，如果没有，就是无用的数据，直接抛弃。如果有，就用C按照规范，把tag后面的负载拆开。每一位该怎么解析，用枚举搞定，最后封装个判断的函数， 哪些位的哪些组合返回什么， 哪些位的哪些组合又返回什么。然后以后别人用你的东西继续开发，或是自己继续开发，都方便了，公司里面也是这样处理的，就是专门做协议解析的人，和专门做规范的人，和应用实现的人（其中应用实现最简单，返回值就那么几个， 哪个返回值就操作封装好的那些函数即可）









