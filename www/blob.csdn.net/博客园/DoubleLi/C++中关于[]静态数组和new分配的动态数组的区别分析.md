# C++中关于[]静态数组和new分配的动态数组的区别分析 - DoubleLi - 博客园






> 
C++中关于[]静态数组和new分配的动态数组的区别分析





一、静态数据及动态数组的创建

    静态数据：  

            int a[10]；

            int a[]={1,2,3};

            数组的长度必须为常量。

    动态数组：

            int len;

            int *a=new int [len];

            delete a;

           数组的大小可以为变量。

注意不能这样做：  
  int   p[len];   
  C++编译器会报错说len的大小不能确定，因为用这种形式声明数组，数组的大小需要在编译时确定。

而且这样也不行：   
  int   p[]=new   int[len];   
  编译器会说不能把int*型转化为int[]型，因为用new开辟了一段内存空间后会返回这段内存的首地址，所以   要把这个地址赋给一个指针，所以要用int   *p=new   int[len];



二、new还需要你delete，是在堆分配空间，效率较低；而[]直接在栈上分配，会自动释放，效率高，但是栈空间有限。



三、对静态数组名进行sizeof运算时，结果是整个数组占用空间的大小；

    因此可以用sizeof(数组名)/sizeof(*数组名)来获取数组的长度。
    int a[5]; 则sizeof(a)=20,sizeof(*a)=4.因为整个数组共占20字节，首个元素（int型）占4字节。
     int *a=new int[4];则sizeof(a)=sizeof(*a)=4,因为地址位数为4字节，int型也占4字节。



四、静态数组作为函数参数时，在函数内对数组名进行sizeof运算，结果为4，因为此时数组名代表的指针即一个地址，占用4个字节的内存(因为在传递数组名的参数时，编译器对数组的长度不做检查)。对动态数组的函数名，无论何时进行sizeof运算，得到的结果都是4.



五、通过函数返回一个数组的问题
   函数声明的静态数组不可能通过函数返回，因为生存期的问题，函数调用完其内部变量占用的内存就被释放了。如果想通过函数返回一个数组，可以在函数中用new动态创建该数组，然后返回其首地址。
其原因可以这样理解，因为[]静态数组是在栈中申请的，而函数中的局部变量也是在栈中的，而new动态数组是在堆中的分配的，所以函数返回后，栈中的东西被自动释放，而堆中的东西如果没有delete不会自动释放。

例子如下：

int *test(int *b) //b可以是静态数组的数组名，也可以是动态数组的首地址

{ 


> 
> 
for(int i=0;i<5;i++) //输出传入的数组各元素 


> 
cout<<*(b+i)<<" "; 


> 
cout<<endl; 


> 
int *c=new int[5]; //动态创建一个数组  


> 
//如果将绿色部分换为int c[5];则主函数中调用test无法得到c数组  


> 
for(i=0;i<5;i++)  //新数组的各项值等于传入的数组各项值加5  


> 
 *(c+i)=*(b+i)+5;  


> 
return c;     //返回新创建的动态数组的首地址



> 
}



int main(){


> 
> 
int *b=new int[5]; 


> 
//创建动态数组b 


> 
for(int i=0;i<5;i++)//赋值 


> 
 *(b+i)=i;  //绿色部分也可以换为int b[5]={0,1,2,3,4};即也可以是静态数组


> 
int *c=test(b);   //将b作为参数，调用test函数，返回值赋给c 


> 
for(i=0;i<5;i++)  //输出test返回的数组的各项  


> 
 cout<<*(c+i)<<" "; 


> 
cout<<endl; return 0;



> 
}










