# 实例解说双缓冲 - DoubleLi - 博客园






昨天在论坛上，有人问起双缓冲的实现问题，想起网上这方面资料比较凌乱，而且多是DirectX相关的，今天特地在这里给大家简要的介绍一下双缓冲技术及其在VC++的GDI绘图环境下的实现。

**1. Windows绘图原理**

    我们在Windows环境下看到各种元素，如菜单、按钮、窗口、图像，从根本上说，都是“画”出来的。这时的屏幕，就相当于一块黑板，而Windows下的各种GDI要素，如画笔、画刷等，就相当于彩色粉笔了。我们在黑板上手工画图时，是一笔一划的，电脑亦然。只不过电脑的速度比手工快的太多，所以在我们看起来好像所有的图形文字都是同时出现的。

** 2.普通绘图方式的局限**

    上述绘图方式我们暂且称之为普通绘图方式吧。虽然这种方式能满足相当一部分的绘图需要，但是当要绘制的对象太复杂，尤其是含有位图时，电脑便力不从心了。这时的画面会显示的很慢，对于运动的画面，会给人“卡”住了的感觉，总之一个字：不爽。

** 3.解决之道：双缓冲**
    双缓冲的原理可以这样形象的理解：把电脑屏幕看作一块黑板。首先我们在内存环境中建立一个“虚拟“的黑板，然后在这块黑板上绘制复杂的图形，等图形全部绘制完毕的时候，再一次性的把内存中绘制好的图形“拷贝”到另一块黑板（屏幕）上。采取这种方法可以提高绘图速度，极大的改善绘图效果。下面是原理图：

![](http://p.blog.csdn.net/images/p_blog_csdn_net/forsiny/EntryImages/20091116/1633939680583463750.jpg)

         图一 双缓冲原理示意图

**4. 相关的函数介绍**
    1).  为屏幕DC创建兼容的内存DC：CreateCompatibleDC()

         if(!m_dcMemory.CreateCompatibleDC(NULL))        //  CDC m_dcMemory;
         {              
              ::PostQuitMessage(0);
         } 

    2).  创建位图：CreateCompatibleBitmap()

         m_Bmp.CreateCompatibleBitmap(&m_dcMemory, rt.Width(), rt.Height());        // CBitmap m_Bmp;

    3). 把位图选入设备环境：SelectObject()，可以理解为选择画布

         ::SelectObject(m_dcMemory.GetSafeHdc(), m_Bmp);   

    4). 把绘制好的图形“拷贝“到屏幕上:BitBlt()

         pdcView->BitBlt(0, 0, rt.Width(), rt.Height(), &m_dcMemory, 0, 0, SRCCOPY);

    函数的具体用法详见MSDN。有一句话我重复了多遍，再说一遍也无妨：MSDN是最好的老师。


**5. 下面给出一个例子，用效果对比的方法说明普通绘图方式的局限和双缓冲技术的好处。**    这个例子在一个View上画出很多半径渐变的圆，大家可以发现，普通绘图方式下动画的效果较差，绘制过程中明显存在着闪烁。

![](http://p.blog.csdn.net/images/p_blog_csdn_net/forsiny/EntryImages/20091116/2633939680584088750.jpg)


     Dem及源码下载：
[http://blog.vckbase.com/Files/HateMath/DBBTest.rar](http://blog.vckbase.com/Files/HateMath/DBBTest.rar)









zz from [http://blog.vckbase.com/hatemath/archive/2006/02/18/17822.html](http://blog.vckbase.com/hatemath/archive/2006/02/18/17822.html)









