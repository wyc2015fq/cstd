# 你不需要花哨的命令提示符 - 知乎
# 



以前很喜欢折腾命令提示符，bash/zsh 下面很多提示符都试过，一开始挺有意思，但用久了都有些别扭，他们不当影响观感，而且奇慢无比，比如下面这款集成 git branch 信息的：
![](https://pic1.zhimg.com/v2-ff2171c1c7f73a45dbfd308975c95404_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='502' height='80'></svg>)
典型的性能杀手，低配电脑/cygwin/msys 环境提示符计算分支很慢，按一次回车卡一秒。就连好点的机器也能感到明显的延迟，我想问一下：这个代价值得么？branch 真的是那么重要的信息需要每行命令都看？即便不在 git 仓库中，每按一下回车也要空跑一下计算程序？还用了奇怪的非标准字符，导致换个终端，你可能显示不正常。

很多 zsh 的新用户常常抱怨“zsh 太慢了”，我跟他们说，为啥我的 zsh 很流畅呢？把你的 prompt 给禁止掉，看看还慢不慢？顺便把 oh-my-zsh 删了，最慢的就是这个。这还算好的提示符了，还有更花哨的：
![](https://pic2.zhimg.com/v2-95c73971a1bce4659b63a41f73636e35_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='512' height='129'></svg>)
连时间，分支，还有 ruby 的 virtualenv（好像）全都给我塞进去了，我想问一下，既然 ruby 的 virtualenv 都显示了，为何不给我显示 python 的 virtualenv 呢？我还想看 CPU 占用呢，要不要每行给我输出一个？你们知道这玩意儿在我的 nas 下面多慢？按一次回车卡 1.2秒。

我发现 oh-my-zsh 的用户特别喜欢折腾 PROMPT，花哨程度只有更高，没有最高：
![](https://pic2.zhimg.com/v2-e19b7eecf30968ce50661b7afaa99319_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='633' height='346'></svg>)
我已经开启了命令行语法高亮，PROMPT 还在那里花里胡哨的话，容易让我眼花缭乱，人家服装设计一般都要控制衣服颜色不超过3种，命令提示符花里胡哨的干嘛呢？

试过了很多命令提示符以后，我开始思考，怎样才是我想要的 PROMPT？
- 他真的需要集成那么多信息么？重要的信息太多，一直往 prompt 里塞是个办法么？
- 色彩高亮到底是为了让人醒目？还是让人觉得混乱？
- 我到底是要好看还是要效率？

想完这三个问题以后，我把这些乱七八糟的 prompt themes 全部删除了， 然后开始思考如果我自己设计命令提示符，我需要设计成什么样呢？于是整理了一个清单：
- 速度：绝对不能卡，哪怕在我的路由器上，按回车一定要流畅，否则再怎么强大都免谈，所以必须尽量避免每次显示 PROMPT 的时候都要启动新进程。
- 精简：不能占用太多空间，同屏/同行看到的信息越多我工作效率越高，prompt 就不该占用太多，应该尽量把空间留出来，git branch 这些完全可以 alias 一下，要看时 gb 就够了。
- 素雅：避免让我眼花缭乱。
- 兼容：我是混用 bash/zsh 的，一个提示符不能让我 zsh 可以用，换台机器就没法用了。

总之就是一句话：prompt 应该是为我提高效率的，不是来拖我后腿的东西。

本着上面四条原则，我重新设计的两个主题，然后感觉整个世界都清净了，再也没有折腾过 prompt 了，一直安心的用了到现在，这里推荐给大家：




**默认主题**

其实就是 debian/ubuntu 的默认主题，显示：用户名，主机名和路径，有时候真的就够了，末尾如果是普通用户的话，显示一个“$”，如果是 root 则显示一个 "#"。

避免去到 centos 或者路由器上不一致，我们新建一个 prompt_default.sh 文件，内容如下：


```bash
if [ -n "$BASH_VERSION" ]; then
    export PS1='\u@\h:\w\$ '
else
    if [ "$UID" -eq 0 ]; then
        export PROMPT='%f%n@%m:%~%# '
    else
        export PROMPT='%f%n@%m:%~\$ '
    fi
fi
```


然后，再你的 bash 配置文件里面 source 一下该文件，当然，你也可以全部塞在你的 bashrc 或者 [init.sh](https://link.zhihu.com/?target=http%3A//init.sh/) 里面，只是分离文件的话，换主题方便些，改下 source 后面的文件名就行。

Bash 下面如果是 root 会自动将 $ 替换成 #，zsh 需要具体指明一下，效果如下：
![](https://pic1.zhimg.com/v2-138e2a3a7fa886df4f75545927c6ca88_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='365' height='73'></svg>)
什么？太素了？没颜色？好吧，我们新建 prompt_color.sh，支持 8 色终端：


```bash
if [ -n "$BASH_VERSION" ]; then
    export PS1='\[\e[01;32m\]\u@\h\[\e[00m\]:\[\e[01;34m\]\w\[\e[00m\]\$ '
else
    if [ "$UID" -eq 0 ]; then
        export PROMPT='%F{10}%n@%m%f:%F{12}%~%f%# '
    else
        export PROMPT='%F{10}%n@%m%f:%F{12}%~%f\$ '
    fi
fi
```


现在看起来好了那么一点：
![](https://pic4.zhimg.com/v2-86ad06ec94515d1b8ce33b2fc4176deb_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='414' height='76'></svg>)
你也可以在 bash 那段加个判断，uid 是 0 的话（root），将用户名显示未红色：


```bash
export PS1='\[\e[01;31m\]\u@\h\[\e[00m\]:\[\e[01;34m\]\w\[\e[00m\]\$ '
```


这样更醒目些，提醒你现在是 root 了，凡事要小心：
![](https://pic1.zhimg.com/v2-67ba3ba7655838ae3c2eb5701da760a8_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='473' height='93'></svg>)
搞了半天还和默认不配置效果一样，这不是浪费时间么？别急，上面只是些基本配置和配置的组织方式，上面这些太土没关系，至少支持各种终端，接下来我们弄个稍微洋气点的，支持 256 色，新建文件 prompt_256.sh：


```bash
if [ -n "$BASH_VERSION" ]; then
    export PS1='\[\e[38;5;135m\]\u\[\e[0m\]@\[\e[38;5;166m\]\h\[\e[0m \[\e[38;5;118m\]\w\[\e[0m\] \$ '
else
    if [ "$UID" -eq 0 ]; then
        export PROMPT="%F{135}%n%f@%F{166}%m%f %F{118}%~%f %# "
    else
        export PROMPT="%F{135}%n%f@%F{166}%m%f %F{118}%~%f \$ "
    fi
fi
```


效果如下：
![](https://pic3.zhimg.com/v2-efab6627ab09d697de33c36b695bb6ea_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='473' height='92'></svg>)
这个配色参考的 prezto 里一个比较素雅的主题 skwp，很清爽吧？但是速度比它快多了，以上这些都是类似 debian/ubuntu 的默认提示符，只是配色稍加修改，这是我的第一个主题。




**后期处理**

设置完 $PS1 或者 $PROMPT 环境变后就结束了么？我们还需要在他们前面加一些终端控制符，好让每次切换路径的时候更改下终端标题，比如：


```bash
export PS1="\[\e]0;\u@\h: \w\a\]$PS1"
```


通过终端控制命令，在每次显示命令提示符，都会把终端软件的标题设置成包含：用户，主机名以及当前路径的一串字符串。这和以前一模一样，和我一样嫌弃它太长的话，可以修剪下，只显示：用户名+主机名，标题不会随着当前路径改变而改变：


```bash
export PS1="\[\e]0;\u@\h\a\]$PS1"
```


这是我最常用的方式，zsh 的 $PROMPT 变量里不能这么设置改变标题，解析不了，一般是写到 precmd_function 这个 hook 里，各大框架都有做，可以继续沿用。唯一要做的是设置一下 $RPROMPT：


```bash
export RPROMPT="%F{red}%(?..%?)%f"
```


这样就能在右边用红色显示上一个程序的返回码了，如果是0的话（程序正常）就不显示，非零代表错误返回值。

到这里我们就完成了后期处理，这些代码可以放到 bashrc/init.sh 里面，但是要保证是在 source 上面那些主题之后再设置，避免被覆盖。




**Fish 路径折叠**

除了上面的默认主题外，我常用的还有一款类似 fish shell 的主题：
![](https://pic1.zhimg.com/v2-5ac58981bf820a432a23e38027e35f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='536' height='119'></svg>)
fish 默认命令提示符最明显的特点就是“路径折叠”，即提示符只保留最后一级目录的完整名称，其他父目录全部折叠成一个字母的前缀。

有时候路径太长的话，默认 prompt 基本上要占到我半个屏幕的宽度，如果采用 tmux 左右分屏，或者 vim/emacs 的一个分屏内嵌终端，那么我敲命令的空间，还没有路径名占用的那么多。比如你用 MacOS 到 xcode 文件夹下面找个文件，路径提示符都快顶到最右边了。

所以我当年才见到 fish 的这个“路径折叠”就十分喜欢，它解决了痛点，保留了必要的信息，又不至于占用太多空间，我可以再 xcode 里最深的一个文件夹里漫游，也不会担心 prompt 太过碍眼。

还有一个好处是用色很少，fish/zsh 下面本身就有语法高亮，如果 prompt 这里再花哨一些的话，真的会乱不清楚两行命令的交界在哪里。

所以 fish 确实是一个经过深思熟虑设计出来的 shell，那么我们把它移植到 bash/zsh 下面，注意 oh-my-zsh 下面有一个 fishy 的主题可以做上面的事情，大家千万别用，因为里面是调用 perl 来计算路径折叠，每次你按回车都要执行一次 perl 什么概念？

明明纯 shell 就可以了，我们新建 prompt_fish.sh 文件，先定义个函数：


```bash
function _fish_collapsed_pwd() {
    local pwd="$1"
    local home="$HOME"
    local size=${#home}
    [[ $# == 0 ]] && pwd="$PWD"
    [[ -z "$pwd" ]] && return
    if [[ "$pwd" == "/" ]]; then
        echo "/"
        return
    elif [[ "$pwd" == "$home" ]]; then
        echo "~"
        return
    fi
    [[ "$pwd" == "$home/"* ]] && pwd="~${pwd:$size}"
    if [[ -n "$BASH_VERSION" ]]; then
        local IFS="/"
        local elements=($pwd)
        local length=${#elements[@]}
        for ((i=0;i<length-1;i++)); do
            local elem=${elements[$i]}
            if [[ ${#elem} -gt 1 ]]; then
                elements[$i]=${elem:0:1}
            fi
        done
    else
        local elements=("${(s:/:)pwd}")
        local length=${#elements}
        for i in {1..$((length-1))}; do
            local elem=${elements[$i]}
            if [[ ${#elem} > 1 ]]; then
                elements[$i]=${elem[1]}
            fi
        done
    fi
    local IFS="/"
    echo "${elements[*]}"
}
```


该函数用于计算路径，并且同时兼容 bash/zsh，速度比调用 perl 快二十多倍，接着设置：


```bash
if [ -n "$BASH_VERSION" ]; then
    if [ "$UID" -eq 0 ]; then
        export PS1='\u@\h \[\e[31m\]$(_fish_collapsed_pwd)\[\e[0m\]# '
    else
        export PS1='\u@\h \[\e[32m\]$(_fish_collapsed_pwd)\[\e[0m\]> '
    fi
else
    if [ $UID -eq 0 ]; then
        export PROMPT='%f%n@%m %F{1}$(_fish_collapsed_pwd)%f# '
    else
        export PROMPT='%f%n@%m %F{2}$(_fish_collapsed_pwd)%f> '
    fi
fi
```


恩，保存文件，source 一下看看效果：
![](https://pic4.zhimg.com/v2-f707722ad3f60823e74849beff333777_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='656' height='114'></svg>)
成了！bash 下路径效果和 fish 一样了，包括 root 下的状态：
![](https://pic1.zhimg.com/v2-9dee605d7c4bd6d0a70610570a48761c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='656' height='116'></svg>)
可以看出，root 下也和 fish 一样采用了红色显示当前路径，并且把 ">" 换成了 "#" 符号。关键是速度非常快，比 oh-my-zsh 下面那个模拟 fish 的 fishy 主题快上几十倍，和默认主题一样的速度。主要是执行 shell 内建函数代替了 oh-my-zsh 里面的调用 perl 来计算路径折叠。

这是我常用的第二个主题。




**Shell 混用与语法高亮问题**

我的两个主题一般是 bash 用前面那个 256 色的，好看醒目，而 zsh 用这个 fish 路径折叠的，以示区别。而且 zsh 和 fish 一样启用了命令语法高亮，适合选择各色少的主题：
![](https://pic2.zhimg.com/v2-81565e814ca801a2c5b6bb6107d0d965_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='720' height='258'></svg>)
这是我 zsh 使用 fish 路径折叠主题搭配语法高亮，还有 $RPROMPT 的效果。可以想象，本身高亮就已经够抢眼了，如果 prompt 还是很花哨的话，容易让眼睛抓不住重点。

Bash 下面没有语法高亮，本身就比较素，所以我用 256 那个比较好看又醒目。

所以如果和我一样混用  bash/zsh 的同学们也可以参考做一些取舍，如果 bash/zsh 都用 fish 主题的话，注意稍微调整一下，以示区别，比如 bash 下面都用 ">" 符号，zsh 下面都用 "#" 符号之类的，以示区别，root 用户以颜色区分就好。




**话题总结**

今天先说了各种花哨主题存在的问题，思考了主题存在的价值和意义，最后和大家分享了我正在使用的两款比较干净素雅的主题，并且通过上面的设置过程，让大家了解了 bash/zsh 下面该如何制作自己的主题，如何设置颜色？如何调用函数？怎么区别 root 和非 root ？及相应的后期处理。

相信大家可以轻松的设计出让自己满意的 prompt 了。




---

补充1：觉得自己的 oh-my-zsh 主题很快的同学们，可以做个试验，系统设置里将键盘重复设置成最快，然后到你的 oh-my-zsh 下面按下回车不放，两秒钟后放手，看看 PROMPT 生成的相应如何，再对比下什么都没有的 bash 有何不同？

补充2：实在觉得 git 信息离不开的人，可把 git status/branch 绑定到 F5 快捷键啊，既让你方便看到  branch，又避免了每按一次回车就启动一堆新进程的开销。






