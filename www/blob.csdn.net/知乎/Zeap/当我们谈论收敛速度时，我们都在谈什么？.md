# 当我们谈论收敛速度时，我们都在谈什么？ - 知乎
# 

今天我们聊一聊**收敛速度**，看别人论文的时候，他们总会说我们的算法是sublinear convergence， 我们的算法是linear convergence的, 我们的算法是 quadratic convergence。。。看的我云里雾里，所以你们的算法，到底是什么样的convergence呢？
至少我查维基百科的时候没有看懂 （[Rate of convergence](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Rate_of_convergence)），因为我以前没有弄明白过，所以觉得可能有一些人和我一样不是特别天资聪颖所以可能也没弄明白，我愿意稍微写一些我不太正确又不够严谨的看法，希望对人有启发吧。

咱外行看个热闹，如果有啥没说对的地方，欢迎批评指证。能力有限，也就拼拼凑凑一些简单的东西了，大牛见笑了。

**本文有三部分：**

**Part I:** Introduction of Convergence Rate (informal)

**Part II:** Sublinear Convergence & Linear Convergence & Quadratic Convergence

**Part III: **Example Convergence Rate of GD under Convex, Strong Convex, Non-Convex

%-------------------------------------------正文开始--------------------------------------------------------------

## Part I: Definition (informal)

对于一个 Optimization 的问题，只考虑一阶的话，我们希望得到 Convergence Analysis 无外乎三种
- 最差的情况下，我们需要迭代多少次，才能保证当前得到的点![x_{T}](https://www.zhihu.com/equation?tex=x_%7BT%7D)与最小值点![x^{\star}](https://www.zhihu.com/equation?tex=x%5E%7B%5Cstar%7D)的距离**一定**小于![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)![](https://pic3.zhimg.com/v2-f2234e2daded4e6745d9d18fa7304f66_b.png)
- 最差的情况下，需要迭代多少次，才能保证当前得到的函数值![f(x_T)](https://www.zhihu.com/equation?tex=f%28x_T%29)与函数的最小值的差**一定**小于![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)![](https://pic4.zhimg.com/v2-770bf65f0fc15f9353aff4f8a44e0aa7_b.png)

- 最差的情况下，需要迭代多少次，才能保证当前得到的导数![f^{\prime}(x_T)](https://www.zhihu.com/equation?tex=f%5E%7B%5Cprime%7D%28x_T%29)**一定**小于![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon) （![f^{\prime}(x_T)](https://www.zhihu.com/equation?tex=f%5E%7B%5Cprime%7D%28x_T%29) 接近零，在凸函数里就是接近最小值点 ）![](https://pic2.zhimg.com/v2-036d16efd737e10a93ce8e4f7de2a051_b.png)

**![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)其实就是你对这个算法的精度要求，![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)越小，就是希望算法输出的解的精度越高，反之亦然。**

**但这个世界是很奇怪的，这三种不是都能数学推导分析出来的，不同的算法，不同的条件，有时候你只能分析出来其中一到二种，有时候你一个也分析不出来，都是正常的，看缘分了。**

下面我们就拿我们希望![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon)举例子，假设需要迭代![T](https://www.zhihu.com/equation?tex=T)次，才能保证一定达到我们的要求，那么一般求出来的T都是一个和![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)有关的函数，如果求出来![T \geqslant \frac{1}{\epsilon}](https://www.zhihu.com/equation?tex=T+%5Cgeqslant+%5Cfrac%7B1%7D%7B%5Cepsilon%7D),我们就知道，我们的迭代次数，至少是![O(\frac{1}{\epsilon})](https://www.zhihu.com/equation?tex=O%28%5Cfrac%7B1%7D%7B%5Cepsilon%7D%29) Order (数量级)的， 我们才一定能达到![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon)。于是我们就说我们的算法最差需要![O(\frac{1}{\epsilon})](https://www.zhihu.com/equation?tex=O%28%5Cfrac%7B1%7D%7B%5Cepsilon%7D%29) 的 Order (数量级) 才能达到![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon)的精度了，这个貌似就叫做Upper Complexity Bound (具体是不是这个叫法，我找不到了，但是算是某个东西的 Upper Bound)。不过有的论文里有时候可不这么说，他就说我们的算法是sublinear convegence的。。。所以什么是 sublinear convegence 呢？

另外 Order 越小，说明达到相同的精度，算法所需要的迭代次数越少，迭代的次数少，自然这个算法就快**。**

**结论就是：**

**Order 越小，一般来说算法越快。**

比如哈，一般来说![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)表示精度，我们一般比较都是比较![\epsilon \leqslant 1](https://www.zhihu.com/equation?tex=%5Cepsilon+%5Cleqslant+1)的时候所以，很明显可以得到**![\frac{1}{\epsilon} \leqslant \frac{1}{\epsilon^2} ](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Cepsilon%7D+%5Cleqslant+%5Cfrac%7B1%7D%7B%5Cepsilon%5E2%7D+)，**所以 Order 是 ![\frac{1}{\epsilon}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Cepsilon%7D) 的算法可能会比 Order ![\frac{1}{\epsilon^2}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Cepsilon%5E2%7D)的算法快，但是这只是一个upper bound的比较，算是最差情况下的比较，不同情况下，算法的表现是会有差异的。

这关于![\epsilon](https://www.zhihu.com/equation?tex=%5Cepsilon)的 Order 就是大家你死我活的不停向前拱，想 improve 的东西了，也是大家论文相互比较的重点。

## Part II:  Different Type of Convergence

**先上结论，只要背了这张表，其实本文的重点已经结束了，后文的一切不过是为了加深记忆和理解而已~（请注意：表格上，只是我自己的总结, 推导公式其实有好多别的形式，我举的只是我见过的，不涵盖全部哈）**
![](https://pic3.zhimg.com/v2-5d47ad7211080e94ac4f6575699a47d6_b.png)它们的快慢关系是 **Sublinear < Linear < Quadratic**, Quadratic最快了。 稍微画的图，感受一下Sublinear有多慢好了。。。x轴是要求的精度![\epsilon
](https://www.zhihu.com/equation?tex=%5Cepsilon%0A)，y轴是所需要的迭代次数。![](https://pic4.zhimg.com/v2-adf9d7cc7209e91a0e042872e3ae1b97_b.png)
其实，自然而然的问题是，给定要求![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon)，如何找到，最差情况下，我们需要的迭代次数![T](https://www.zhihu.com/equation?tex=T)的Order呢？

一般你推公式，推啊推啊推的，都能得到一些迭代的式子，下面就分Sublinear Convergence & Linear Convergence & Quadratic Convergence 三种情况分别举例。

（1） Sublinear Convergence 

这种情况下，你一般会得到这样的递推公式

![](https://pic3.zhimg.com/v2-ad0465a8092d439d3c79d55e03f8732a_b.png)
为了让![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon),我们只需要让![\frac{1}{T^\frac{1}{k}}\|x_0- x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7BT%5E%5Cfrac%7B1%7D%7Bk%7D%7D%5C%7Cx_0-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon) 加上![\|x_0- x^\star\|  ](https://www.zhihu.com/equation?tex=%5C%7Cx_0-+x%5E%5Cstar%5C%7C++)是一个常数，因为![x_0](https://www.zhihu.com/equation?tex=x_0)是我们的初始点，![x^\star](https://www.zhihu.com/equation?tex=x%5E%5Cstar)是极小值点，他们都是不变的。 所以我们能得到![T \geqslant \frac{C}{\epsilon^k}](https://www.zhihu.com/equation?tex=T+%5Cgeqslant+%5Cfrac%7BC%7D%7B%5Cepsilon%5Ek%7D), 也就是Order ![O(\frac{1}{\epsilon^k})](https://www.zhihu.com/equation?tex=O%28%5Cfrac%7B1%7D%7B%5Cepsilon%5Ek%7D%29)。

**所以Sublinear Convergence 的Order 是**![O\bigg(\frac{1}{\epsilon^k}\bigg)](https://www.zhihu.com/equation?tex=O%5Cbigg%28%5Cfrac%7B1%7D%7B%5Cepsilon%5Ek%7D%5Cbigg%29)，

**对应推导公式是 **![\|x_{t+1} - x^\star\| \leqslant \frac{1}{T^{\frac{1}{k}}} \|x_{0} - x^\star\|](https://www.zhihu.com/equation?tex=%5C%7Cx_%7Bt%2B1%7D+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cfrac%7B1%7D%7BT%5E%7B%5Cfrac%7B1%7D%7Bk%7D%7D%7D+%5C%7Cx_%7B0%7D+-+x%5E%5Cstar%5C%7C)。

**（2） Linear Convergence**

          这种情况下，你一般会得到这样的递推公式

![](https://pic2.zhimg.com/v2-6d1406a96d19b39c546f12710636f4a1_b.png)注意这里![q < 1](https://www.zhihu.com/equation?tex=q+%3C+1)，一直递推下去，就能得到
![](https://pic3.zhimg.com/v2-db56020737e4e0cccf51fa568023b502_b.png)
为了让![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon),我们只需要让![q^T\|x_0- x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=q%5ET%5C%7Cx_0-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon) 加上![\|x_0- x^\star\|  ](https://www.zhihu.com/equation?tex=%5C%7Cx_0-+x%5E%5Cstar%5C%7C++)是一个常数 ，两边取对数可得

![](https://pic3.zhimg.com/v2-8e56177fe19f4c8ab66e5a2ba8461b22_b.png)
然后两边都除以![\log q](https://www.zhihu.com/equation?tex=%5Clog+q)， 注意![q < 1](https://www.zhihu.com/equation?tex=q+%3C+1)，所以![\log q < 0](https://www.zhihu.com/equation?tex=%5Clog+q+%3C+0), 不等号要改变方向

![](https://pic1.zhimg.com/v2-94a530ca02c6df3c9c926eac97a59cec_b.png)公式（ii）因为![\log q < 0](https://www.zhihu.com/equation?tex=%5Clog+q+%3C+0)，而且![q](https://www.zhihu.com/equation?tex=q)是常数，所以直接写个![C](https://www.zhihu.com/equation?tex=C)替代了。

**所以Linear Convergence 的Order 是**![O\bigg(\log(\frac{1}{\epsilon})\bigg)](https://www.zhihu.com/equation?tex=O%5Cbigg%28%5Clog%28%5Cfrac%7B1%7D%7B%5Cepsilon%7D%29%5Cbigg%29)，

**对应推导公式是**![\|x_{t+1} - x^\star\| \leqslant q \|x_{t} - x^\star\|](https://www.zhihu.com/equation?tex=%5C%7Cx_%7Bt%2B1%7D+-+x%5E%5Cstar%5C%7C+%5Cleqslant+q+%5C%7Cx_%7Bt%7D+-+x%5E%5Cstar%5C%7C)。

**( 3 )  Quadratic Convergence**

         这种情况下，你一般会得到这样的递推公式

![](https://pic3.zhimg.com/v2-92d21675aa9596d7b900dac98245caee_b.png)然后我们一路迭代下去

![](https://pic1.zhimg.com/v2-e0499acf194faaa1b296a828fd85bc94_b.png)公式（i）用等比数列去和公式，公式（ii）因为![q](https://www.zhihu.com/equation?tex=q)是常数，说以用一个![C](https://www.zhihu.com/equation?tex=C)来替代一个![q](https://www.zhihu.com/equation?tex=q)。下来我们令![q^\prime = q \|x_0 - x^\star\| ](https://www.zhihu.com/equation?tex=q%5E%5Cprime+%3D+q+%5C%7Cx_0+-+x%5E%5Cstar%5C%7C+)，并假设![q^\prime < 1](https://www.zhihu.com/equation?tex=q%5E%5Cprime+%3C+1)，那么为了得到![\|x_T - x^\star\| \leqslant \epsilon](https://www.zhihu.com/equation?tex=%5C%7Cx_T+-+x%5E%5Cstar%5C%7C+%5Cleqslant+%5Cepsilon)，只需要![C\big(q^\prime \big)^{2^T} \leqslant \epsilon](https://www.zhihu.com/equation?tex=C%5Cbig%28q%5E%5Cprime+%5Cbig%29%5E%7B2%5ET%7D+%5Cleqslant+%5Cepsilon)，两边取对数可得![](https://pic1.zhimg.com/v2-2db6df134309d2ea7d66ec1404ba16c8_b.png)

公式（i）要注意到![q^\prime < 1](https://www.zhihu.com/equation?tex=q%5E%5Cprime+%3C+1)，所以![\log (q^\prime) < 0](https://www.zhihu.com/equation?tex=%5Clog+%28q%5E%5Cprime%29+%3C+0)，不等式两边要变号，而且变成常数后要加负号，所以![\log(\epsilon)](https://www.zhihu.com/equation?tex=%5Clog%28%5Cepsilon%29)变成了![\log(\frac{1}{\epsilon})](https://www.zhihu.com/equation?tex=%5Clog%28%5Cfrac%7B1%7D%7B%5Cepsilon%7D%29)。公式（ii）是两边同时又取了一次对数。

**所以，Quadratic Convergence的Order 是**![\log\log(\frac{1}{\epsilon})](https://www.zhihu.com/equation?tex=%5Clog%5Clog%28%5Cfrac%7B1%7D%7B%5Cepsilon%7D%29)

**推导公式是 **![\|x_{t+1} - x^\star\| \leqslant q \|x_{t} - x^\star\|^2](https://www.zhihu.com/equation?tex=%5C%7Cx_%7Bt%2B1%7D+-+x%5E%5Cstar%5C%7C+%5Cleqslant+q+%5C%7Cx_%7Bt%7D+-+x%5E%5Cstar%5C%7C%5E2)

Remark: Quadratic 比linear 多了一个平方， 这个收敛速度我目前就只在 Netwon Method 里见到过。

**再回头看看 Table 1, 是不是顺眼多了。数学嘛和你喜欢的姑娘一样，都是越看越顺眼的，哈哈！**

## **Part III: Convergence Rate of Gradient Descent**

这是总结的一个 Gradient Descent 在不同情况下的收敛，大家稍微背一背，以后就可以和别人吹牛了 ~~~我觉得还蛮实用的。你也能看出 GD 在 non-convex 下是 ![\frac{1}{\epsilon^2}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Cepsilon%5E2%7D) 这不知道比 linear 的慢了多少倍。 
![](https://pic2.zhimg.com/v2-0824941e0f4c2c7d5b742853bc88eb11_b.png)
%-----------------------------------------------------------------------------------------------------------------

话说有多少人想看， Gradient Descent 在 Convex, Strongly Convex, Non-Convex下的数学推导？一步一步推导出 Table 2 里的 Convergence Rate, **想看的话在下面留言**，想看的人多的话，我可以专门写一篇专栏讲一讲这三种情况下的推导，推导不难，但是还蛮有趣的。

%---------------------------------------------------------------------------------------------------------------------

谢谢你看到最后，但愿这些对你有帮助，有启发的话，**点个赞呗**，只收藏不点赞鼓励一下，人家都没有写下去的热情了。

以后想一起学习凸优化，非凸优化的可以关注我和专栏啦，我会写一些我看到的有意思的观点和思路的，哈哈！

参考文献：

【1】 Nesterov  <Introductory Lectures on Convex Programming>

