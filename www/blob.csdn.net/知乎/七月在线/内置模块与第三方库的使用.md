# 内置模块与第三方库的使用 - 知乎
# 



**写在最前:**

Python的厉害之处就不多说了，在机器学习的技能图谱中，Python属于地基层面。为此，多花些时间，把Python基础打牢固，是为将来的职业路径中走得更远更稳。

该Python基础笔记是七月学员clownfish对机器学习集训营一期中Python部分的整理，共分为四篇，1. Python环境配置及基础数据类型，2. 控制循环,与函数，3.面向对象，4.内置模块(os,文件，正则等)与第三方库(requests等)的应用




## Built-in Function内置函数(bif)




**IO相关操作**

**一、 open函数**

**(一) 读文件**
![](https://pic1.zhimg.com/v2-c583a34a3f2ed08e419239867874736c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='587' height='249'></svg>)
**打开文件的模式:**

r以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。

w打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。

wb以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。




**读取文件的属性**

print "", fo.name#文件名:

print " : ", fo.closed#是否已关闭

print " : ", fo.mode#访问模式




**read()与readline(),readlines()方法**

read()方法从一个打开的文件中读取一个字符

readline()读取一行

readlines()读取所有行




**(二) 写文件**

**write()方法**



![](https://pic1.zhimg.com/v2-c583a34a3f2ed08e419239867874736c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='587' height='249'></svg>)



write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。像图片也可以进行保存。




**(三) 关闭**

file 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入

**二、csv模块**






![](https://pic1.zhimg.com/v2-675547ed6e3e05a3d0af69f08693b140_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='501' height='273'></svg>)
**三、json模块**

Json是种数据格式，具体内容大家自己百度下，它其实可以看成是和python中的字典模式很接近的。



![](https://pic1.zhimg.com/v2-a29bb4233021e898057247b337a11eb0_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='57'></svg>)![](https://pic2.zhimg.com/v2-905ca59daeca307ef6958c0c179f3fd5_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='224'></svg>)
## os模块

使用python，不仅会对文件内容进行各类操作，也会经常跟文件名，路径，目录打交道，因此python提供了内置的os模块(操作系统模块)来帮助我们完成这些操作。 

os模块包含普遍的操作系统功能，与具体的平台无关。 

*import os *

以下列举出个别常用的命令，更多命令大家自己可以使用dir或help来查看




返回当前当前Python运行路径：*os.getcwd()* 返回指定目录下的所有文件和目录名：*os.listdir()*

删除一个文件：*os.remove()* 检验给出的路径是否是一个文件：*os.path.isfile()* 检验给出的路径是否是一个目录：*os.path.isdir()* 判断是否是绝对路径：*os.path.isabs()*







## 时间日期模块

Python也内置提供了有关日期与时间的函数，封装在了time模块中供使用。




> *import time;  #**引入time模块*

*ticks = time.time()*
*print ("当前时间戳为:", ticks)*

*time.localtime(time.time())#返回一个当前本地时间的元组*
*time.asctime()*
*time.ctime()*




> *print**(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())) #格式化输出*




> *import calendar#日历模块*

*cal = calendar.month(2018, 1)*
*print ("以下输出2018年1月份的日历:")*
*print (cal)*




## 正则模块

正则的功用及其强大，大家自行百度下。这里只简单介绍下三种搜索方式，其中最常用的是findall。




使用前要先导入：

*import re*




**正则匹配的语法及参数说明**

**正则匹配的语法：**

*re.command(pattern, string, flags=0)*

**说明：**

pattern匹配的正则表达式

string要匹配的字符串。

flags 标志位用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

**compile**

compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。

**re.match**

re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

**例子：**

*import re*

*print(re.match('www', 'www.163.com').span()) #**在起始位置匹配*

*print(re.match('com', 'www. 163.com')) #在起始位置匹配不到符合pattern的字符，返回None*




#span() 返回一个tuple表示(m.start(), m.end()) 

#start() 返回起始位置,m.end()返回结束位置(不包含该位置的字符). 




**re.search**

re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。

**注意：如果string中存在多个符合pattern子串，只返回第一个。**

**例子：**

*import re*

*url='[http://www.baidu.com/logo.jpg#url=www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com/logo.jpg%23url%3Dwww.baidu.com)'*

*re.search('www',url,re.S)[0]*




**re.findall**

返回string中所有与pattern相匹配的全部字串，返回形式为数组。此方法最为常用，大家多多例子掌握。




**例子：**

> *info = '<a href="[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)">baidu</a>\n<a href="[http://www.163.com](https://link.zhihu.com/?target=http%3A//www.163.com)">163</a>'*
*re.findall('<a',info) #找出所有的<a标签*




> *re.findall(r'\b\w{3}\b','Cat is smart than Dog',re.I)*




> *re.findall(r'\b\d{2,4}\b','543abc 543 defg54321')#找出左右为空格，长度在2或4的数字*




**使用compile对象**

> *p = re.compile(r'\d+')*
*p.findall('one1two2three3four4')*

['1', '2', '3', '4']




> *p = re.compile(r'[a-z]+')*
*p.findall('one1two2three3four4')*

['one', 'two', 'three', 'four']




> *p = re.compile(r'[^one]')*
*p.findall('one1two2three3four4')*

['1', 't', 'w', '2', 't', 'h', 'r', '3', 'f', 'u', 'r', '4']




> *p = re.compile(r'[^one]+')*
*p.findall('one1two2three3four4')*

['1tw', '2thr', '3f', 'ur4']




> *import re**p = re.compile(r'\d+')**print**(p.findall('one1two2three3four4'))*

['1', '2', '3', '4']




## Request模块



![](https://pic3.zhimg.com/v2-0f4d648e6759defc7038d37a56f7e922_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='176' height='225'></svg>)
不多介绍了，这是一个第三方库，在写抓虫时非常好用，使用前记得要先安装


*pip install requests*

然后正常导入即可:

*import requests*




**get方式获取网页**

get(params)与r.url

> *get_data = {'name': 'mogan', 'country_code': 'CN'}*
*r = requests.get("[http://www.163.com](https://link.zhihu.com/?target=http%3A//www.163.com)", params= get_data)*
*r.url#实际get请求的URL*
*r.text#请求网页得到的文本*




**text与content**

r.text返回的是Unicode型的数据。 
使用r.content返回的是bytes型的数据。 
也就是说，如果你想取文本，可以通过r.text。如果想取图片，文件，则可以通过r.content




**decode与encode**

decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串转换成unicode编码。

encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode('gb2312')，表示将unicode编码的字符串转换成gb2312编码。




**cookies**

如果一个响应中包含了cookie，那么我们可以利用 cookies 变量来拿到

> *import requests*
*url = 'http://example.com'*
*r = requests.get(url)*
*print r.cookies*
*print r.cookies['example_cookie_name']*

*import requests*
*url = 'http://example.com'*
*r = requests.get(url)*
*print r.cookies*
*print r.cookies['example_cookie_name']*

以上程序仅是样例，可以用 cookies 变量来得到站点的 cookies 

另外可以利用 cookies 变量来向服务器发送 cookies 信息

import requests

url = '[http://httpbin.org/cookies](https://link.zhihu.com/?target=http%3A//httpbin.org/cookies)'

cookies = dict(cookies_are='working')

r = requests.get(url, cookies=cookies)

print r.text




import requests

url = '[http://httpbin.org/cookies](https://link.zhihu.com/?target=http%3A//httpbin.org/cookies)'

cookies = dict(cookies_are='working')

r = requests.get(url, cookies=cookies)

print r.text

运行结果




'{"cookies": {"cookies_are": "working"}}'

1

'{"cookies": {"cookies_are": "working"}}'

可以已经成功向服务器发送了 cookies




**会话对象session**

在以上样例中，对网址每次请求都相当于发起了一个新的请求。也就是相当于我们每次请求之间没有关系，它并不是在一个会话中完成，即使请求的是同一个网址。

那当我们需要保持一个持久的会话时，该那么如何保持呢？就像用一个浏览器浏览电子邮件时，即使是在不同邮件之间跳转，也使用是处于登陆后的状态中。




> *import requests*
*s = requests.Session()#创建会话对象*
*s.get('[http://httpbin.org/cookies/set/sessioncookie/123456789](https://link.zhihu.com/?target=http%3A//httpbin.org/cookies/set/sessioncookie/123456789)')*
*r = s.get("[http://httpbin.org/cookies](https://link.zhihu.com/?target=http%3A//httpbin.org/cookies)")*
*print(r.text)*




> *# '{"cookies": {"sessioncookie": "123456789"}}'*




**写在最后：**

机器学习之Python基础笔记的最后一篇完成了。这四篇笔记都比较精简，属于对老师讲授内容的总结性笔记，对于零起步学习AI的同学来说，还需要再多要跟着老师的在线课程进行复习，练习以巩固Python基础的部分。

多练习，多动手是学好Python，以及后面课程的不二法门，希望同学们都能打好编程的基础。


