# 干货！神经网络入门指导！ - 知乎
# 



> 作者：Ben Gorman
链接：[http://blog.kaggle.com/2017/11/27/introduction-to-neural-networks/](https://link.zhihu.com/?target=http%3A//blog.kaggle.com/2017/11/27/introduction-to-neural-networks/)

注：本文中所涉及的示例都是用R语言写的代码。

让我们从一个动机问题开始思考。这里是一个灰度图片的集合，每个2×2的像素网格的像素取值都是在0(白)到255(黑)之间。我们的目标是构建一个模型，用“阶梯”的模式来识别图片。
![](https://pic3.zhimg.com/v2-54a867665e6ceb75521c99199db12656_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='274'></svg>)
在这里，我们来探讨如何找到一个能够合理拟合数据的模型感兴趣。

**方法一：预处理**

对每张图片，我们标记像素X1,X2,X3,X4 ,  并生成一个输入向量X=[X1 X2 X3 X4]，作为我们模型的输入值。我们希望我们的模型能够预测“True”(图像具有阶梯模式)或为“False”(图像不具有阶梯模式)。
![](https://pic3.zhimg.com/v2-417de03cd64906c65ec73e9a8f4db89a_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='300' height='263'></svg>)![](https://pic2.zhimg.com/v2-ba231167857e02120571ffbe8dd58fdd_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='264'></svg>)
**方法二：单层感知器(模型迭代0次)**

单层感知器是我们可以构建的一个简单模型。当一个感知器使用线性权重组合的输入时，可以得到一个预测值。如果预测的数值超过所选用的阈值，感知器则会判定为“True”，否则判定为“False”。更具体的说，
![](https://pic3.zhimg.com/v2-26d768db14a9b33fcd291fa3adedc096_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='81'></svg>)
我们可以将它重新表示为如下形式：
![](https://pic1.zhimg.com/v2-58f1238e535ec225d78e611ba6f33934_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='168' height='94'></svg>)



这里
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
表示预测值。

图形上，我们可以将感知器表示为一个由输入到输出的节点。
![](https://pic4.zhimg.com/v2-fd82468c8c8e48ce7f3314b157676f93_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='399'></svg>)
例如，我们假定构建如下的感知器：
![](https://pic2.zhimg.com/v2-79932101cbeacb8c6dbae93dd8dfc561_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='443' height='29'></svg>)
这里可以看到感知器是如何在我们的训练图像上执行的。
![](https://pic3.zhimg.com/v2-dc5bdef7373b9029e6e06c2de7c6bd76_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='142'></svg>)
这是合理的结果，肯定优于随机猜测的效果。所有的阶梯模式在其底部都有带有深色阴影的像素，能支持X3和X4采用更大的正系数。尽管如此，这个模型还是存在一些明显的问题。
- 该模型输出一个实数，它的值与自然的概念相关(值越大隐含着有更大的可能性说明图像表现为阶梯模式)，但是将这些值解释为概率值是没有依据的，特别当它们的取值范围在[0,1]之外。
- 该模型无法捕捉到变量之间非线性的关系。

为了解这个问题，可以考虑以下的假设情况：

**情况A：**从一张图像开始，x = [100, 0, 0, 125]，从0增至60.
![](https://pic1.zhimg.com/v2-edac302e7118592f3de01daed3a6515c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='350' height='204'></svg>)
**情况B：**从最后一张图像开始，x = [100, 0, 60, 125]，从60增至120.
![](https://pic4.zhimg.com/v2-cd24d405ea7715bfd395c52e8080356b_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='350' height='204'></svg>)
直观上，相对于情况B来说，情况A的
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
应该会有更大的增幅。然而，由于我们感知器模型只是一个线性等式，对于这两种情况，X3增加了60，而
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
只增加了0.12。

同时，我们的线性感知器还会有更多的问题，但是我们先来解决这两个问题。

**问题一：以Sigmoid为激活函数的单层感知器(模型迭代1次)：**

我们可以通过将我们的感知器包在Sigmoid函数里面(随后选择不同的权重值)来解决上述的问题1和2。回顾下Sigmoid函数是一条垂直方向上界定在0到1之间的S型曲线，因此经常被用来模拟二元事件发生的概率。
![](https://pic4.zhimg.com/v2-86c927e840cf85de75768568bd86483f_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='380' height='61'></svg>)![](https://pic4.zhimg.com/v2-71c768071b055500318b31d9d738d003_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='500' height='300'></svg>)
顺着这个思路，我们用下面的图片和方程式来更新我们的模型。
![](https://pic4.zhimg.com/v2-52c765ed877e55e811187690daf1609b_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='435'></svg>)![](https://pic3.zhimg.com/v2-6d149ca8ba7d4c9c22398118d2a783f2_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='354' height='71'></svg>)
这就是Logistic回归。然而，将这个模型解释为以Sigmoid为激活函数的线性感知器也是很好的，因为这给了我们更多的空间去泛化。此外，由于我们将
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
解释为概率值，所以我们必须相应地更新我们的决策规则。
![](https://pic1.zhimg.com/v2-e57b3c324a98499dc501847d15d6565c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='179' height='62'></svg>)
**问题二：假定我们提出以下的拟合模型：**
![](https://pic3.zhimg.com/v2-440a60d835b0ddb9e1c82838961f0fa2_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='395' height='132'></svg>)
对比先前的部分，可以看出这个模型在相同的图像上是如何起作用的。
![](https://pic4.zhimg.com/v2-1b81ee14bfa626f5f850ff4d28b69f8b_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='143'></svg>)
解决方法：

**情况A：**从一张图像开始，x = [100, 0, 0, 125]，从0增至60.
![](https://pic1.zhimg.com/v2-edac302e7118592f3de01daed3a6515c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='350' height='204'></svg>)
**情况B：**从最后一张图像开始，x = [100, 0, 60, 125]，从60增至120.
![](https://pic4.zhimg.com/v2-cd24d405ea7715bfd395c52e8080356b_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='350' height='204'></svg>)
请注意，随着
![](https://pic3.zhimg.com/v2-41b1c6a2356a78ebfb46d267dd32cd8e_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='88' height='11'></svg>)
的增加，Sigmoid函数是如何引起情况A的“触发”现象(快速增加)，但随着z的持续增加，速度会减慢。这与我们的直觉是相一致的，即对于出现阶梯的可能性，情况A应该反映出比情况B更大的增长。
![](https://pic4.zhimg.com/v2-7e59ae63b6e8e27477c54e8d76b4981f_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='274'></svg>)
不幸的是，这个模型仍然存在问题：
**![](https://pic1.zhimg.com/v2-735144c3a8bf4c7c5474b3654dfc6f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='20'></svg>)**
与每个变量都有单调的关系。如果我们想识别轻微的阴影阶梯，那该怎么办？
- 该模型不考虑变量的交互问题。假设图像的底部是黑色的，如果左上角的像素是白色，则右上角的像素变暗会增加阶梯出现的可能性。如果左上角的像素是黑色的，则右上角的像素变暗会降低阶梯出现的可能性。换句话说，就是根据其他变量的值，增加X3应该可能增加或减少
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
的值。目前我们的模型还无法实现这一点。

**问题三：以Sigmoid为激活函数的单层感知器(模型迭代2次)：**

我们可以通过在我们感知器模型上额外增加一个层来解决上述的两个问题。我们将以上面的模型为基础构建一系列基本模型，然后将每个基本模型的输出作为输入提供给另一个感知器。这个模型实际上就是一个 “香草型”的神经网络。让我们通过一些例子看看它是如何工作。

**例子1：识别阶梯模式**
- 构建一个模型，当左阶梯模式被识别时触发，
![](https://pic3.zhimg.com/v2-233a3d8b0f5479c47aa97e8b0e3984aa_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='34' height='21'></svg>)- 构建一个模型，当右阶梯模式被识别时触发，
![](https://pic2.zhimg.com/v2-c8ea17ad92b3aa599770a0d641052f71_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='42' height='21'></svg>)- 增大每个基础模型的得分，以便最后的S型函数只有在
![](https://pic3.zhimg.com/v2-233a3d8b0f5479c47aa97e8b0e3984aa_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='34' height='21'></svg>)
和
![](https://pic2.zhimg.com/v2-c8ea17ad92b3aa599770a0d641052f71_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='42' height='21'></svg>)
都很大时才会被触发。
![](https://pic1.zhimg.com/v2-039a8b152ac0a27917a90ff35cb629e4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='632' height='379'></svg>)![](https://pic1.zhimg.com/v2-242882600d5ba15001e85542bce3463c_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='128'></svg>)
或者
- 构建一个模型，当底部为暗色时才触发，
![](https://pic1.zhimg.com/v2-735144c3a8bf4c7c5474b3654dfc6f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='20'></svg>)- 构建一个模型，当左上角像素为暗色且右上角像素为亮色时才触发，
![](https://pic1.zhimg.com/v2-56e16e35bf3141e0af19e2543e7b45a4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)- 构建一个模型，当左上角像素为亮色且右上角像素为暗色时才触发，
![](https://pic3.zhimg.com/v2-6361f90c6fc7a5160374b05c5699ee62_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)- 增大基础模型以便最后的sigmoid函数只有在
![](https://pic1.zhimg.com/v2-735144c3a8bf4c7c5474b3654dfc6f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='20'></svg>)
和
![](https://pic1.zhimg.com/v2-56e16e35bf3141e0af19e2543e7b45a4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
都很大，或者
![](https://pic1.zhimg.com/v2-735144c3a8bf4c7c5474b3654dfc6f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='20'></svg>)
和
![](https://pic3.zhimg.com/v2-6361f90c6fc7a5160374b05c5699ee62_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
都很大时才触发(请注意
![](https://pic1.zhimg.com/v2-56e16e35bf3141e0af19e2543e7b45a4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
和
![](https://pic3.zhimg.com/v2-6361f90c6fc7a5160374b05c5699ee62_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
无法同时有很大的值)。
![](https://pic2.zhimg.com/v2-d95e60a5b60da86b9b294ce20faef99d_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='410'></svg>)![](https://pic1.zhimg.com/v2-8d64a2d7f6d6be40cd221a562ed201e4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='131'></svg>)
**例子2：识别带轻微阴影的阶梯**
- 构建一个模型，当底部为阴影，阴影x1和白色x2，阴影x2和白色x1时才被触发，
![](https://pic1.zhimg.com/v2-735144c3a8bf4c7c5474b3654dfc6f28_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='20'></svg>)
，
![](https://pic1.zhimg.com/v2-56e16e35bf3141e0af19e2543e7b45a4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
和
![](https://pic3.zhimg.com/v2-6361f90c6fc7a5160374b05c5699ee62_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)- 构建一个模型，当底部为暗色，暗色x1和白色x2，暗色x2和白色x1时才被触发， 
![](https://pic4.zhimg.com/v2-e05149ce89e9bee4e9d4ac53f45f0ce3_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
，
![](https://pic2.zhimg.com/v2-c0809eda9790d6b24ab33a1f855d4731_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)
和
![](https://pic4.zhimg.com/v2-c3e6d4aaeda146391aa9921336a84d47_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='17' height='20'></svg>)- 将模型组合起来以便在使用sigmoid函数压缩之前， “暗色”的标识符能够基本上从 “阴影”标识符中除去。
![](https://pic2.zhimg.com/v2-7abb924a1b773e9459d43b60d4b684c5_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='362'></svg>)![](https://pic1.zhimg.com/v2-b6cd9bd6a30cea002402fb5dadbd0fa4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='131'></svg>)
**专业术语注释**

单层感知器具有单个的输出层。因此，我们刚刚构建的模型将被称为双层感知器，因为模型的一个输出层，是另一个输出层的输入。然而，我们可以将这些模型称为神经网络，就这方面而言，网络有三层--输入层，隐藏层和输出层。
![](https://pic3.zhimg.com/v2-2d4f9f653323263e71f52b01e7602726_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='397'></svg>)
**可替代的激活函数**

在我们的例子中，我们使用了一个sigmoid作为激活函数。但是，我们可以使用其他的激活函数。双曲正切函数、 修正线性单元都是常用的选择。激活函数必须是非线性的，否则神经网络将等价于单层的感知器。

**多目标分类**

通过在最终输出层中使用多个节点，我们可以轻松地将我们的模型扩展成多分类模型。这里用到的想法是，每个输出对应于我们想要预测的类别之一C，我们可以使用Softmax函数将
![](https://pic2.zhimg.com/v2-824217aa9daa22a12f84a09f1a8ea0bd_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='25' height='16'></svg>)
空间中的一个向量映射到
![](https://pic2.zhimg.com/v2-824217aa9daa22a12f84a09f1a8ea0bd_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='25' height='16'></svg>)
中的另一个向量，如此使得向量的元素之和为1，而不是通过sigmoid函数映射
![](https://pic1.zhimg.com/v2-d7276dba4e426925bd23f4c2abe535ac_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'></svg>)
空间的一个输出元素并将其压缩在[0,1]之间输出。换句话说，我们可以设计一个网络使得它的输出向量是如此的形式：
![](https://pic1.zhimg.com/v2-d4de329bbf0b7b95b8a7669de9e3ffd0_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='97' height='19'></svg>)
。
![](https://pic3.zhimg.com/v2-94812fe1e5b0a449ba1d38132e430842_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='387'></svg>)
**使用不止两层的神经网络，即深度学习**

你可能想知道，我们是否可以扩展我们的香草式神经网络，使得其输出层被输入到第四层(进而第五层，第六层等等)？

是这样的，这就是通常所说的“深度学习”。实践中，它非常高效。但是值得注意的是，任何一个隐藏层都可以通过一个单隐藏层的网络来模拟。实际上，根据通用逼近定理，可以使用具有单个隐藏层的神经网络来逼近任何连续的函数。

深层神经网络架构经常选择偏向于单个隐层结构的原因就在于，他们更倾向于在拟合过程中更快速地收敛并得到最终的结果。
![](https://pic1.zhimg.com/v2-9eb31e9d2ca934f0d95b1859f990d3c0_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='331'></svg>)
**用模型去拟合带标签的训练样本 (反向传播法)**

在拟合阶段，到目前为止，我们已经讨论了神经网络如何能够有效地工作，但是我们还没有讨论如何用神经网络去拟合带标签的训练样本。

一个等价的问题就是：给定一些带标签的训练样本，我们该如何选择网络的最佳权重值？

对此，梯度下降法是常见的答案(尽管用最大似然估量法也可以做到)。




下面继续我们的示例问题，梯度下降的过程会像这样：
- 以一些带标签的训练数据开始
- 选择一个可微的损失函数并最小化，
![](https://pic4.zhimg.com/v2-e68fc0127584580ed9c2d5ff91a2aaff_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='44' height='16'></svg>)- 选择一个网络结构。具体地说就是确定网络的层数以及每层的节点数
- 随机地初始化网络权重
- 用网络运行训练数据来生成每个样本的预测值。根据损失函数
![](https://pic4.zhimg.com/v2-e68fc0127584580ed9c2d5ff91a2aaff_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='44' height='16'></svg>)
来度量总体的误差值(这就是所谓的前向传播过程)。
- 当每个权重发生小的变化，确定当前的损失值将改变多少。换句话说，计算L对于网络中每个权重的梯度值(这就是所谓的后向传播过程)。
- 沿负梯度的方向走一小步。例如，
![](https://pic4.zhimg.com/v2-a7db2fbbed62d3879277c547ddb2f7eb_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='66' height='14'></svg>)
，
![](https://pic4.zhimg.com/v2-e06197049d53557019d32f618d2432af_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='70' height='22'></svg>)
，那么小幅度的减少
![](https://pic2.zhimg.com/v2-d02ebf43f77e2a688ad26059c8f34e5d_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='12'></svg>)
会导致当前损失小幅度的降低。因此我们更新
![](https://pic1.zhimg.com/v2-d88729167bcc159cb00621b7c85a1cc4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='192' height='17'></svg>)
(这里0.001就是我们所预定义的步长)。
- 以固定的次数重复进行这个过程(从步骤5开始)，直至损失函数收敛为止。

这些是最基本的想法。实际中，这面临了一系列的困难：

**挑战一： 计算复杂度**

在拟合的过程中，我们需要计算的一个东西是L对于每个权重的梯度值。这是个棘手的问题，因为L依赖于输出层中的每个节点，并且每个节点依赖于之前的层中的每个节点，以此类推。这就意味着计算
![](https://pic4.zhimg.com/v2-cd51afe63824c6989244c3d8c42a7697_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='27'></svg>)
是一个链式规则的噩梦(请记住，实际上许多神经网络都有数十层数千个节点)。




我归纳了解决这个噩梦的四个技巧。

处理这个问题的关键是要认识到，在应用链式规则的时候，
![](https://pic4.zhimg.com/v2-cd51afe63824c6989244c3d8c42a7697_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='27'></svg>)
将重用相同中间层的导数值。

如果你仔细追踪这个的话，你就可以避免重新计算相同的东西几千次。

另一个技巧就是使用特殊的激活函数，其衍生物可以写成他们值的函数。例如，
![](https://pic1.zhimg.com/v2-32a92c242b771f8cda0b1d639a1676c4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='78' height='17'></svg>)
=
![](https://pic4.zhimg.com/v2-6d369ff102ec8ddaf27b9b32971c60a7_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='216' height='19'></svg>)
的导数。这是很方便的，因为在正向传播过程中，当我们计算每个训练样本
![](https://pic3.zhimg.com/v2-56046316a18689394cd230fe082870e6_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='19'></svg>)
时，我们必须为某个向量x逐元素地计算
![](https://pic1.zhimg.com/v2-32a92c242b771f8cda0b1d639a1676c4_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='78' height='17'></svg>)
。

在反向传播过程中，我们可以在计算L相对于权重的梯度时重用这些值，从而节省时间和内存的占用。

第三个技巧就是将训练数据分成“小批量”，并逐一更新每个批次的权重。例如，如果将训练数据划分为{batch1，batch2，batch3}，则训练数据首先将
- 使用batch1更新权重值
- 使用batch2更新权重值
- 使用batch3更新权重值

这里，L的梯度将在每次更新后重复地计算。

最后的一个值得注意的技巧就是使用GPU而不是CPU，因为GPU更适合并行地执行大量的计算。

**挑战二：梯度下降法可能会无法找到绝对最小值点**

这不仅仅是一个神经网络的问题，因为它也是一个梯度下降问题。在梯度下降的过程中，权重可能会陷入局部最小值。权重也可能超过最小值。

处理这个问题的一个技巧就是调整不同的步长。

另一个技巧就是增加网络中的节点数或网络层数(注意过拟合现象)。

此外，一些像使用动量的启发式技巧也可能有效。

**挑战三： 如何泛化？**

我们如何编写一个通用的程序来拟合任何数量的节点和网络层的神经网络呢？

答案是， 你不用这样做，你是用Tensorflow。但是，如果你真的想这么做的话，最困难的部分就是计算损失函数的梯度。

这么做的技巧就是意识到你可以把梯度表示为一个递归函数。5层的神经网络只是一个4层带一些感知器的神经网络，而4层的神经网络只是一个3层带一些感知器的神经网络。诸如此类。更正式的说，这称为自动分化。

七月在线【深度学习项目班】100%实战，一站式掌握场景、数据、建模与优化！

通过本门课程，学员能够掌握深度学习原理及其在计算机视觉、自然语言处理、广告点击率预估以及推荐系统方向的应用；

且课程设置毕业考试及1v1批改，辅助简历优化；

全程提供GPU云实验平台、CPU云实验平台，助力跳槽涨薪！

                                                      微信扫码，了解详情
![](https://pic2.zhimg.com/v2-b1046dbfa6e7b5b288af05efc47032e1_b.jpg)![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='750' height='1334'></svg>)

