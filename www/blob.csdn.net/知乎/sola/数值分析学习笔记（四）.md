# 数值分析学习笔记（四） - 知乎
# 

（期中季过去了一半多终于又有时间把自己挖过的坑填上了2333）

在这一章我们将会见到一些求**数值微分与数值积分**的方法。

事实上，我们可以将数值微分与数值积分看作是上一章插值的应用。最基本的想法便是：**将函数利用Lagrange插值多项式进行插值后转化为求多项式的微分与积分**（这是很容易进行的）。

所以我们的本章将会一直以这个想法为基础，拓展出一套数值微分和积分方法，看到数值微分与数值积分各自具有的一些有趣的方法以及特性。

同样地，我们**假设 函数![f](https://www.zhihu.com/equation?tex=f) 具有足够好的性质，且插值结点 ![x_0,...,x_n](https://www.zhihu.com/equation?tex=x_0%2C...%2Cx_n) 为等距间隔的，步长为 ![h](https://www.zhihu.com/equation?tex=h) 。**



**数值微分：**

我们先来考虑函数在某一点处的导数定义： ![f^{'}(x_0)=\lim_{h\rightarrow 0}\frac{f(x_0+h)-f(x_0)}{h}](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Clim_%7Bh%5Crightarrow+0%7D%5Cfrac%7Bf%28x_0%2Bh%29-f%28x_0%29%7D%7Bh%7D)

我们模仿导数的定义尝试着给出最简单的情况下的数值微分估计。

我们假设在某个区间中仅仅取**两个插值结点**（即两个区间端点 ![x_0,\ x_1=x_0+h](https://www.zhihu.com/equation?tex=x_0%2C%5C+x_1%3Dx_0%2Bh) ），我们容易知道此时的Lagrange插值多项式为 ![P(x)=f(x_0)\frac{x-x_1}{x_0-x_1}+f(x_1)\frac{x-x_0}{x_1-x_0}](https://www.zhihu.com/equation?tex=P%28x%29%3Df%28x_0%29%5Cfrac%7Bx-x_1%7D%7Bx_0-x_1%7D%2Bf%28x_1%29%5Cfrac%7Bx-x_0%7D%7Bx_1-x_0%7D)

则我们有： ![f(x)=P(x)+\frac{f^{''}(\xi)}{2!}(x-x_0)(x-x_1)](https://www.zhihu.com/equation?tex=f%28x%29%3DP%28x%29%2B%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%21%7D%28x-x_0%29%28x-x_1%29)

![f(x)=f(x_0)\frac{x-x_0-h}{-h}+f(x_0+h)\frac{x-x_0}{h}+\frac{f^{''}(\xi)}{2!}(x-x_0)(x-x_0-h)](https://www.zhihu.com/equation?tex=f%28x%29%3Df%28x_0%29%5Cfrac%7Bx-x_0-h%7D%7B-h%7D%2Bf%28x_0%2Bh%29%5Cfrac%7Bx-x_0%7D%7Bh%7D%2B%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%21%7D%28x-x_0%29%28x-x_0-h%29)

**注意此处Lagrange插值多项式的余项中的 ![\xi](https://www.zhihu.com/equation?tex=%5Cxi) 实质上是 ![\xi(x)](https://www.zhihu.com/equation?tex=%5Cxi%28x%29) ，是 ![x](https://www.zhihu.com/equation?tex=x) 的函数。**

那么我们对上式两边分别对 ![x](https://www.zhihu.com/equation?tex=x) 求导，得到如下等式。

![f^{'}(x)=\frac{f(x_0+h)-f(x_0)}{h}+\frac{2(x-x_0)-h}{2}f^{''}(\xi(x))+\frac{(x-x_0)(x-x_0-h)}{2}\frac{df^{''}(\xi(x))}{dx}](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x%29%3D%5Cfrac%7Bf%28x_0%2Bh%29-f%28x_0%29%7D%7Bh%7D%2B%5Cfrac%7B2%28x-x_0%29-h%7D%7B2%7Df%5E%7B%27%27%7D%28%5Cxi%28x%29%29%2B%5Cfrac%7B%28x-x_0%29%28x-x_0-h%29%7D%7B2%7D%5Cfrac%7Bdf%5E%7B%27%27%7D%28%5Cxi%28x%29%29%7D%7Bdx%7D)

我们发现 ![\frac{df^{''}(\xi(x))}{dx}](https://www.zhihu.com/equation?tex=%5Cfrac%7Bdf%5E%7B%27%27%7D%28%5Cxi%28x%29%29%7D%7Bdx%7D) 这一项确实十分麻烦，难以处理。但是好在这一项有系数 ![\frac{(x-x_0)(x-x_1)}{2}](https://www.zhihu.com/equation?tex=%5Cfrac%7B%28x-x_0%29%28x-x_1%29%7D%7B2%7D) 。

那么我们很自然地想到：我们只需要去考虑 ![f^{'}(x_0),f^{'}(x_1)](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%2Cf%5E%7B%27%7D%28x_1%29) 即可。（即**令 ![x](https://www.zhihu.com/equation?tex=x) 在插值结点处取值**就可以消去这难以处理的一项）

所以我们令 ![x=x_0](https://www.zhihu.com/equation?tex=x%3Dx_0) 得到下式：

**数值微分的两点公式：**![f^{'}(x_0)=\frac{f(x_0+h)-f(x_0)}{h}-\frac{f^{''}(\xi)}{2}h](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0%2Bh%29-f%28x_0%29%7D%7Bh%7D-%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%7Dh)**，其中 ![\xi](https://www.zhihu.com/equation?tex=%5Cxi) 在 ![x_0,x_1](https://www.zhihu.com/equation?tex=x_0%2Cx_1) 之间，且为 ![x](https://www.zhihu.com/equation?tex=x) 的函数。**（后文不再重复）

事实上，数值微分就是如此地简单：用Lagrange插值多项式对函数进行插值然后就能够估计在每个插值结点的微分。

而且，我们很容易对这个方法进行推广：我们可以**取三个插值结点**进行插值。

计算过程请读者模仿上面的步骤自行给出。

在这里我们直接给出取三个插值结点得到的结果：

![f^{'}(x_j)=f(x_0)\frac{2x_j-x_1-x_2}{(x_0-x_1)(x_0-x_2)} +  f(x_1)\frac{2x_j-x_0-x_2}{(x_1-x_0)(x_1-x_2)}  +  f(x_2)\frac{2x_j-x_0-x_1}{(x_2-x_0)(x_2-x_1)}+\frac{1}{6}f^{(3)}(\xi)\prod_{k=0\ k\neq j}^2(x_j-x_k)](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_j%29%3Df%28x_0%29%5Cfrac%7B2x_j-x_1-x_2%7D%7B%28x_0-x_1%29%28x_0-x_2%29%7D+%2B++f%28x_1%29%5Cfrac%7B2x_j-x_0-x_2%7D%7B%28x_1-x_0%29%28x_1-x_2%29%7D++%2B++f%28x_2%29%5Cfrac%7B2x_j-x_0-x_1%7D%7B%28x_2-x_0%29%28x_2-x_1%29%7D%2B%5Cfrac%7B1%7D%7B6%7Df%5E%7B%283%29%7D%28%5Cxi%29%5Cprod_%7Bk%3D0%5C+k%5Cneq+j%7D%5E2%28x_j-x_k%29)

然而，此处与两个插值结点时略有区别：令 ![x=x_0](https://www.zhihu.com/equation?tex=x%3Dx_0) 与令 ![x=x_1](https://www.zhihu.com/equation?tex=x%3Dx_1) 我们可以得到三点公式的不同形式。

若我们令 ![x=x_0](https://www.zhihu.com/equation?tex=x%3Dx_0) ，我们得到：

**数值微分的三点公式的端点形式：**

![f^{'}(x_0)=\frac{-3f(x_0)+4f(x_0+h)-f(x_0+2h)}{2h}+\frac{f^{(3)}(\xi)}{3}h^2](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7B-3f%28x_0%29%2B4f%28x_0%2Bh%29-f%28x_0%2B2h%29%7D%7B2h%7D%2B%5Cfrac%7Bf%5E%7B%283%29%7D%28%5Cxi%29%7D%7B3%7Dh%5E2)

若我们令 ![x=x_1](https://www.zhihu.com/equation?tex=x%3Dx_1) ，再将其中变量换为 ![x_0](https://www.zhihu.com/equation?tex=x_0) ，得到：

**数值微分的三点公式的中点形式：**

![f^{'}(x_0)=\frac{f(x_0+h)-f(x_0-h)}{2h}-\frac{f^{(3)}(\xi)}{6}h^2](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0%2Bh%29-f%28x_0-h%29%7D%7B2h%7D-%5Cfrac%7Bf%5E%7B%283%29%7D%28%5Cxi%29%7D%7B6%7Dh%5E2)

我们容易看到中点形式的误差比端点形式更小。事实上，在实际使用中，当我们估计插值区间端点处导数值时我们更多使用端点形式，否则我们更多使用中点形式。


接下来的一个问题是：对于**高阶导数**我们要如何数值地进行估计呢？

此时再利用插值多项式进行求导未免太过于繁琐。我们改用**该点处展开的Taylor公式**来进行估计。

下举数值地估计二阶导数为例：

根据Taylor公式，我们有：

![f(x_0+h)=f(x_0)+f^{'}(x_0)h+\frac{f^{''}(x_0)}{2}h^2+\frac{f^{(3)}(x_0)}{6}h^3+\frac{f^{(4)}(\xi_1)}{24}h^4](https://www.zhihu.com/equation?tex=f%28x_0%2Bh%29%3Df%28x_0%29%2Bf%5E%7B%27%7D%28x_0%29h%2B%5Cfrac%7Bf%5E%7B%27%27%7D%28x_0%29%7D%7B2%7Dh%5E2%2B%5Cfrac%7Bf%5E%7B%283%29%7D%28x_0%29%7D%7B6%7Dh%5E3%2B%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_1%29%7D%7B24%7Dh%5E4)

![f(x_0-h)=f(x_0)-f^{'}(x_0)h+\frac{f^{''}(x_0)}{2}h^2-\frac{f^{(3)}(x_0)}{6}h^3+\frac{f^{(4)}(\xi_2)}{24}h^4](https://www.zhihu.com/equation?tex=f%28x_0-h%29%3Df%28x_0%29-f%5E%7B%27%7D%28x_0%29h%2B%5Cfrac%7Bf%5E%7B%27%27%7D%28x_0%29%7D%7B2%7Dh%5E2-%5Cfrac%7Bf%5E%7B%283%29%7D%28x_0%29%7D%7B6%7Dh%5E3%2B%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_2%29%7D%7B24%7Dh%5E4)

注意此处 ![\xi_1,\xi_2](https://www.zhihu.com/equation?tex=%5Cxi_1%2C%5Cxi_2) 为两个不同的变量。

相加得到 ![f(x_0+h)+f(x_0-h)=2f(x_0)+f^{''}(x_0)h^2+\frac{f^{(4)}(\xi_1)+f^{(4)}(\xi_2)}{24}h^4](https://www.zhihu.com/equation?tex=f%28x_0%2Bh%29%2Bf%28x_0-h%29%3D2f%28x_0%29%2Bf%5E%7B%27%27%7D%28x_0%29h%5E2%2B%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_1%29%2Bf%5E%7B%284%29%7D%28%5Cxi_2%29%7D%7B24%7Dh%5E4)

由连续函数的介值性， ![\exists\ \xi,\ f^{(4)}(\xi)=\frac{ f^{(4)}(\xi_1)+f^{(4)}(\xi_2)}{2}](https://www.zhihu.com/equation?tex=%5Cexists%5C+%5Cxi%2C%5C+f%5E%7B%284%29%7D%28%5Cxi%29%3D%5Cfrac%7B+f%5E%7B%284%29%7D%28%5Cxi_1%29%2Bf%5E%7B%284%29%7D%28%5Cxi_2%29%7D%7B2%7D)

由此我们得到了：

**二阶导数的数值微分估计：**

![f^{''}(x_0)=\frac{f(x_0-h)+f(x_0+h)-2f(x_0)}{h^2}-\frac{f^{(4)}(\xi)}{12}h^2](https://www.zhihu.com/equation?tex=f%5E%7B%27%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0-h%29%2Bf%28x_0%2Bh%29-2f%28x_0%29%7D%7Bh%5E2%7D-%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi%29%7D%7B12%7Dh%5E2)

事实上，更加高阶的导数均可以通过上述方法进行求解。（例如：考虑 ![x_0-2h,x_0-h,x_0+h,x_0+2h](https://www.zhihu.com/equation?tex=x_0-2h%2Cx_0-h%2Cx_0%2Bh%2Cx_0%2B2h) 的Taylor公式就可以数值地估计出 ![f^{'''}(x_0)](https://www.zhihu.com/equation?tex=f%5E%7B%27%27%27%7D%28x_0%29) ，读者可自行进行尝试）



最后，作为数值微分部分的结束，我们介绍一种**通过低阶估计之间的相互运算达到更高阶截断误差的方法：Richardson外推**。

其思想非常简单：**虽然我不知道截断误差的高阶项究竟是什么，但是我可以通过取不同步长进行估计来相对地消除低阶截断误差项。**

我们只需要看一个例子便能明白Richardson外推方法的实际含义：

考虑用 ![h](https://www.zhihu.com/equation?tex=h) 的函数估计真实值 ![M](https://www.zhihu.com/equation?tex=M) 。

现在已知 ![N_1(h)](https://www.zhihu.com/equation?tex=N_1%28h%29) 是一个截断误差 ![O(h)](https://www.zhihu.com/equation?tex=O%28h%29) 的估计。

即 ![M=N_1(h)+K_1h+K_2h^2+...](https://www.zhihu.com/equation?tex=M%3DN_1%28h%29%2BK_1h%2BK_2h%5E2%2B...)

我们令 ![h=\frac{h}{2}](https://www.zhihu.com/equation?tex=h%3D%5Cfrac%7Bh%7D%7B2%7D) ，得到 ![M=N_1(\frac{h}{2})+\frac{K_1}{2}h+\frac{K_2}{4}h^2+...](https://www.zhihu.com/equation?tex=M%3DN_1%28%5Cfrac%7Bh%7D%7B2%7D%29%2B%5Cfrac%7BK_1%7D%7B2%7Dh%2B%5Cfrac%7BK_2%7D%7B4%7Dh%5E2%2B...)

那么我们现在就能够消去 ![h](https://www.zhihu.com/equation?tex=h) 项了。

考虑 ![2N_1(\frac{h}{2})-N_1(h)=N_2(h)](https://www.zhihu.com/equation?tex=2N_1%28%5Cfrac%7Bh%7D%7B2%7D%29-N_1%28h%29%3DN_2%28h%29) 为我们新的对于 ![M](https://www.zhihu.com/equation?tex=M) 的估计。

则有 ![M-N_2(h)=-\frac{K_2}{2}h^2+...](https://www.zhihu.com/equation?tex=M-N_2%28h%29%3D-%5Cfrac%7BK_2%7D%7B2%7Dh%5E2%2B...)

我们发现 ![N_2(h)](https://www.zhihu.com/equation?tex=N_2%28h%29) 的截断误差变为了 ![O(h^2)](https://www.zhihu.com/equation?tex=O%28h%5E2%29) ，比原先更优了。


特别地，我们容易发现当截断误差具有形式 ![K_2h^2+K_4h^4+...](https://www.zhihu.com/equation?tex=K_2h%5E2%2BK_4h%5E4%2B...) （**即只包含 ![h](https://www.zhihu.com/equation?tex=h) 的偶数次方**）时，进行一次Richarson外推，我们就能将估计的截断误差从 ![O(h^2)](https://www.zhihu.com/equation?tex=O%28h%5E2%29) 一下子提升到 ![O(h^4)](https://www.zhihu.com/equation?tex=O%28h%5E4%29) 。这样的做法是非常有效率的。

在这样的情形下，我们容易证明**具有 ![O(h^{2j})](https://www.zhihu.com/equation?tex=O%28h%5E%7B2j%7D%29) 截断误差的估计**

![N_j(h)=N_{j-1}(\frac{h}{2})+\frac{N_{j-1}(\frac{h}{2})-N_{j-1}(h)}{4^{j-1}-1}](https://www.zhihu.com/equation?tex=N_j%28h%29%3DN_%7Bj-1%7D%28%5Cfrac%7Bh%7D%7B2%7D%29%2B%5Cfrac%7BN_%7Bj-1%7D%28%5Cfrac%7Bh%7D%7B2%7D%29-N_%7Bj-1%7D%28h%29%7D%7B4%5E%7Bj-1%7D-1%7D) 。


作为应用，我们举一个例子由**数值微分的三点公式的中点形式推导出数值微分的五点公式**（即取5个插值结点的情况）

由Taylor公式，我们将数值微分的三点公式的中点形式进行改写，得到：

![f^{'}(x_0)=\frac{f(x_0+h)-f(x_0-h)}{2h}-\frac{f^{(3)}(x_0)}{6}h^2-\frac{f^{(5)}(x_0)}{120}h^4-...](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0%2Bh%29-f%28x_0-h%29%7D%7B2h%7D-%5Cfrac%7Bf%5E%7B%283%29%7D%28x_0%29%7D%7B6%7Dh%5E2-%5Cfrac%7Bf%5E%7B%285%29%7D%28x_0%29%7D%7B120%7Dh%5E4-...)

我们发现这样的形式**截断误差中只有 ![h](https://www.zhihu.com/equation?tex=h) 的偶数次项**，满足我们的上述条件。

我们在这里令 ![h=2h](https://www.zhihu.com/equation?tex=h%3D2h) （事实上和令 ![h=\frac{h}{2}](https://www.zhihu.com/equation?tex=h%3D%5Cfrac%7Bh%7D%7B2%7D) 效果相同），得到：

![f^{'}(x_0)=\frac{f(x_0+2h)-f(x_0-2h)}{4h}-\frac{4f^{(3)}(x_0)}{6}h^2-\frac{16f^{(5)}(x_0)}{120}h^4-...](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0%2B2h%29-f%28x_0-2h%29%7D%7B4h%7D-%5Cfrac%7B4f%5E%7B%283%29%7D%28x_0%29%7D%7B6%7Dh%5E2-%5Cfrac%7B16f%5E%7B%285%29%7D%28x_0%29%7D%7B120%7Dh%5E4-...)

上式的 ![4](https://www.zhihu.com/equation?tex=4) 倍与下式作差，化简，得到：

**数值微分的五点公式的中点形式：**

![f^{'}(x_0)=\frac{f(x_0-2h)-8f(x_0-h)+8f(x_0+h)-f(x_0+2h)}{12h}+\frac{f^{(5)}(\xi)}{30}h^4](https://www.zhihu.com/equation?tex=f%5E%7B%27%7D%28x_0%29%3D%5Cfrac%7Bf%28x_0-2h%29-8f%28x_0-h%29%2B8f%28x_0%2Bh%29-f%28x_0%2B2h%29%7D%7B12h%7D%2B%5Cfrac%7Bf%5E%7B%285%29%7D%28%5Cxi%29%7D%7B30%7Dh%5E4)

而读者可以尝试着利用过五点的Lagrange多项式求导得到，那样的计算过程会异常繁琐。

Richardson外推在**减小截断误差的同时大大减少了计算量**。但是天下并没有免费的午餐，这样的计算量减免是**以舍入误差的增大为代价**的。




**数值积分：**

数值积分的基本思想与数值微分相同，仍然是**利用Lagrange插值公式转化为对多项式的积分。**

我们与数值微分类似的，也先从**两个插值结点**的情况开始研究（ ![x_0=a,x_1=b](https://www.zhihu.com/equation?tex=x_0%3Da%2Cx_1%3Db) ）。

由数值微分处的推导过程，我们有：

![f(x)=f(x_0)\frac{x-x_0-h}{-h}+f(x_0+h)\frac{x-x_0}{h}+\frac{f^{''}(\xi)}{2!}(x-x_0)(x-x_0-h)](https://www.zhihu.com/equation?tex=f%28x%29%3Df%28x_0%29%5Cfrac%7Bx-x_0-h%7D%7B-h%7D%2Bf%28x_0%2Bh%29%5Cfrac%7Bx-x_0%7D%7Bh%7D%2B%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%21%7D%28x-x_0%29%28x-x_0-h%29)

那么 ![\int_a^bf(x)dx=\int_a^b[f(x_0)\frac{x-x_1}{-h}+f(x_1)\frac{x-x_0}{h}]dx+\int_a^b\frac{f^{''}(\xi)}{2!}(x-x_0)(x-x_0-h)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cint_a%5Eb%5Bf%28x_0%29%5Cfrac%7Bx-x_1%7D%7B-h%7D%2Bf%28x_1%29%5Cfrac%7Bx-x_0%7D%7Bh%7D%5Ddx%2B%5Cint_a%5Eb%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%21%7D%28x-x_0%29%28x-x_0-h%29dx)

经过计算得到：
![\int_a^bf(x)dx=\frac{x_1-x_0}{2}(f(x_0)+f(x_1))+\int_a^b\frac{f^{''}(\xi)}{2!}(x-x_0)(x-x_0-h)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cfrac%7Bx_1-x_0%7D%7B2%7D%28f%28x_0%29%2Bf%28x_1%29%29%2B%5Cint_a%5Eb%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%21%7D%28x-x_0%29%28x-x_0-h%29dx)

最后，我们着手化简余项。

注意此处 ![\xi=\xi(x)](https://www.zhihu.com/equation?tex=%5Cxi%3D%5Cxi%28x%29) 。

利用定积分第一中值定理，我们得到： ![\int_a^b\frac{f^{''}(\xi(x))}{2!}(x-x_0)(x-x_1)dx=\frac{f^{''}(\xi)}{2}\int_a^b(x-x_0)(x-x_1)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Eb%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%28x%29%29%7D%7B2%21%7D%28x-x_0%29%28x-x_1%29dx%3D%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%7D%5Cint_a%5Eb%28x-x_0%29%28x-x_1%29dx)

![=\frac{f^{''}(\xi)}{2}(-\frac{h^3}{6})=-\frac{f^{''}(\xi)}{12}h^3](https://www.zhihu.com/equation?tex=%3D%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B2%7D%28-%5Cfrac%7Bh%5E3%7D%7B6%7D%29%3D-%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B12%7Dh%5E3)

故我们得到了：

**数值积分梯形公式：**

![\int_a^bf(x)dx=\frac{h}{2}(f(x_0)+f(x_1))-\frac{f^{''}(\xi)}{12}h^3](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cfrac%7Bh%7D%7B2%7D%28f%28x_0%29%2Bf%28x_1%29%29-%5Cfrac%7Bf%5E%7B%27%27%7D%28%5Cxi%29%7D%7B12%7Dh%5E3)

从几何角度我们也很容易理解：梯形公式将两个端点之间的直线与坐标轴围成的梯形面积作为定积分的估计值。

如出一辙地，我们进行推广：利用**三个插值结点**进行Lagrange插值以及定积分。

我们得到：（计算过程略）

**数值积分的Simpson公式：**

![\int_a^bf(x)dx=\frac{h}{3}(f(x_0)+4f(x_1)+f(x_2))-\frac{f^{(4)}(\xi)}{90}h^5](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cfrac%7Bh%7D%7B3%7D%28f%28x_0%29%2B4f%28x_1%29%2Bf%28x_2%29%29-%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi%29%7D%7B90%7Dh%5E5)

从几何上理解：一定存在唯一的一条抛物线（可能退化）经过三个不同点，Simpson方法将抛物线与坐标轴围成的曲边梯形的面积作为了定积分的估计值。

再进一步地，增加结点数量，我们可以得到一族Newton-Cotes公式，在此处就不再赘述了。


这里介绍一下如何衡量一个数值积分方法的精度。

**定义：**

**一个数值积分方法的代数精度为 ![k](https://www.zhihu.com/equation?tex=k) 当且仅当对于任意次数小于等于 ![k](https://www.zhihu.com/equation?tex=k) 的多项式，数值积分方法的误差均为 ![0](https://www.zhihu.com/equation?tex=0) 。**

我们不难发现：**梯形公式的代数精度为 ![1](https://www.zhihu.com/equation?tex=1) ，而Simpson公式的代数精度为 ![3](https://www.zhihu.com/equation?tex=3) 。**



然而，对于数值积分方法的讨论并没止步于此。

微分和积分的最大**区别**在于：**微分具有局部性而积分具有整体性。**

**在计算微分时，我们仅仅关注函数在这个点处局部的取值。然而计算积分时，我们关注函数在整个区间上的整体变化趋势。**这意味着：当区间比较大时，若我们要较精确地估计积分值，我们需要很高阶的Lagrange插值多项式，会使得计算异常地繁琐；若我们用Simpson公式，我们仅仅关注了三个点处的取值，必然导致精度不够。

那么，我们能否利用现有的方法稍作改进克服这一缺点呢？

答案是肯定的。


一个简单的想法是：**将比较大的区间细分成若干个小区间，并且在每个区间上都分别应用梯形公式/Simpson公式。**

而这就是**复化梯形公式/复化Simpson公式**的由来。

我们此处给出复化Simpson公式的推导，复化梯形公式的推导可类似进行。

我们知道：在一个区间上应用Simpson公式需要三个结点。由于我们假定了结点之间的等距选取，故我们选取的三个结点一定是区间的两个端点以及区间中点。

在此，我们取等距结点 ![a=x_0<x_1<...<x_n=b](https://www.zhihu.com/equation?tex=a%3Dx_0%3Cx_1%3C...%3Cx_n%3Db) ，并且保证 ![n](https://www.zhihu.com/equation?tex=n) 是偶数，从而保证整个区间 ![[x_0,x_n]](https://www.zhihu.com/equation?tex=%5Bx_0%2Cx_n%5D) 可以被划分成 ![\frac{n}{2}](https://www.zhihu.com/equation?tex=%5Cfrac%7Bn%7D%7B2%7D) 个小区间，其中每个小区间包含三个结点。

接下来，我们在每个小区间上应用Simpson公式，得到：

![\int_a^bf(x)dx=\int_{x_0}^{x_2}f(x)dx+...+\int_{x_{n-2}}^{x_n}f(x)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cint_%7Bx_0%7D%5E%7Bx_2%7Df%28x%29dx%2B...%2B%5Cint_%7Bx_%7Bn-2%7D%7D%5E%7Bx_n%7Df%28x%29dx)

![=\sum_{j=1}^{\frac{n}{2}}\frac{h}{3}[f(x_{2j-2})+4f(x_{2j-1})+f(x_{2j})]-\frac{f^{(4)}(\xi_j)}{90}h^5](https://www.zhihu.com/equation?tex=%3D%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Cfrac%7Bh%7D%7B3%7D%5Bf%28x_%7B2j-2%7D%29%2B4f%28x_%7B2j-1%7D%29%2Bf%28x_%7B2j%7D%29%5D-%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_j%29%7D%7B90%7Dh%5E5)

![=\frac{h}{3}[f(x_0)+2\sum_{j=1}^{\frac{n}{2}-1}f(x_{2j})+4\sum_{j=1}^{\frac{n}{2}}f(x_{2j-1})+f(x_n)]-\frac{h^5}{90}\sum_{j=1}^{\frac{n}{2}}f^{(4)}(\xi_j)](https://www.zhihu.com/equation?tex=%3D%5Cfrac%7Bh%7D%7B3%7D%5Bf%28x_0%29%2B2%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D-1%7Df%28x_%7B2j%7D%29%2B4%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7Df%28x_%7B2j-1%7D%29%2Bf%28x_n%29%5D-%5Cfrac%7Bh%5E5%7D%7B90%7D%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7Df%5E%7B%284%29%7D%28%5Cxi_j%29)

接下来，我们来着手处理余项的化简。

由连续函数的介值定理，我们有 ![\exists \xi,\ \frac{2}{n}\sum_{j=1}^{\frac{n}{2}}f^{(4)}(\xi_j)=f^{(4)}(\xi)](https://www.zhihu.com/equation?tex=%5Cexists+%5Cxi%2C%5C+%5Cfrac%7B2%7D%7Bn%7D%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7Df%5E%7B%284%29%7D%28%5Cxi_j%29%3Df%5E%7B%284%29%7D%28%5Cxi%29)

故我们得到 ![-\frac{h^5}{90}\sum_{j=1}^{\frac{n}{2}}f^{(4)}(\xi_j)=-\frac{nh^5}{180}f^{(4)}(\xi)](https://www.zhihu.com/equation?tex=-%5Cfrac%7Bh%5E5%7D%7B90%7D%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7Df%5E%7B%284%29%7D%28%5Cxi_j%29%3D-%5Cfrac%7Bnh%5E5%7D%7B180%7Df%5E%7B%284%29%7D%28%5Cxi%29)

注意到 ![nh=b-a](https://www.zhihu.com/equation?tex=nh%3Db-a)

故我们得到：

**复化Simpson公式：**

![\int_a^bf(x)dx=\frac{h}{3}[f(a)+2\sum_{j=1}^{\frac{n}{2}-1}f(x_{2j})+4\sum_{j=1}^{\frac{n}{2}}f(x_{2j-1})+f(b)]-\frac{b-a}{180}h^4f^{(4)}(\xi)](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cfrac%7Bh%7D%7B3%7D%5Bf%28a%29%2B2%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D-1%7Df%28x_%7B2j%7D%29%2B4%5Csum_%7Bj%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7Df%28x_%7B2j-1%7D%29%2Bf%28b%29%5D-%5Cfrac%7Bb-a%7D%7B180%7Dh%5E4f%5E%7B%284%29%7D%28%5Cxi%29)

如出一辙地，我们得到：（读者自行模仿上述过程推导）

**复化梯形公式：**

![\int_a^bf(x)dx=\frac{h}{2}[f(a)+2\sum_{j=1}^{n-1}f(x_j)+f(b)]-\frac{b-a}{12}h^2f^{''}(\xi)](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3D%5Cfrac%7Bh%7D%7B2%7D%5Bf%28a%29%2B2%5Csum_%7Bj%3D1%7D%5E%7Bn-1%7Df%28x_j%29%2Bf%28b%29%5D-%5Cfrac%7Bb-a%7D%7B12%7Dh%5E2f%5E%7B%27%27%7D%28%5Cxi%29)

复化Simpson方法是数值计算中最常用的方法之一，再不带来过重的计算负担的同时，仍能保持较高的精度。

下面举一例：

例：数值求解 ![\int_0^{\pi}sinxdx](https://www.zhihu.com/equation?tex=%5Cint_0%5E%7B%5Cpi%7Dsinxdx)

解：
![](https://pic3.zhimg.com/v2-b95cb454bb3890ed24aea05727d5d6ee_b.jpg)
我们先用复化梯形公式。

如我们之前所说的，计算的过程是将区间分割后分别累积每个梯形的面积。
![](https://pic2.zhimg.com/v2-7b961c6a1fd26a5c3bd381a1c38ddb35_b.jpg)
再利用复化Simpson公式。

发现相同区间分割数下明显相对误差小得多。

事实上，当区间分割数越少时，两种方法的精度差异便越明显。
![](https://pic4.zhimg.com/v2-547ffd7c45386aae8ac86880caac5f7f_b.jpg)
这幅图的对比中我们更容易发现精度上的差别。




回忆我们在上文中介绍过的Richardson外推方法。

它为我们提供了一种减小截断误差阶数同时节省了大量计算量的方法。

事实上，**复化积分公式也能够与Richardson方法结合**，产生更高阶的截断误差。

这种方法就是**Romberg积分法**。

在Romberg积分法中，我们只需要构造一张Romberg表即可递归地生成所有高阶截断误差的估计值。下面我们用 ![R_{i,j}](https://www.zhihu.com/equation?tex=R_%7Bi%2Cj%7D) 表示Romberg表中的第 ![i](https://www.zhihu.com/equation?tex=i) 行 ![j](https://www.zhihu.com/equation?tex=j) 列的元素。

我们**先利用复化积分公式（此处以复化梯形公式为例）生成表的第一列，即所有 ![R_{i,1}](https://www.zhihu.com/equation?tex=R_%7Bi%2C1%7D) 。**

**![R_{i,1}](https://www.zhihu.com/equation?tex=R_%7Bi%2C1%7D) 代表 ![n=2^{i-1}](https://www.zhihu.com/equation?tex=n%3D2%5E%7Bi-1%7D) 时利用复化梯形公式所得到的积分估计值。**

则容易知道第一列的估计值截断误差均为 ![O(h^2)](https://www.zhihu.com/equation?tex=O%28h%5E2%29) ，且截断误差项中仅含 ![h](https://www.zhihu.com/equation?tex=h) 的偶数次方。

那么接下来我们**利用Richardson外推：**

**![R_{i,j}=R_{i,j-1}+\frac{1}{4^{j-1}-1}(R_{i,j-1}-R_{i-1,j-1})](https://www.zhihu.com/equation?tex=R_%7Bi%2Cj%7D%3DR_%7Bi%2Cj-1%7D%2B%5Cfrac%7B1%7D%7B4%5E%7Bj-1%7D-1%7D%28R_%7Bi%2Cj-1%7D-R_%7Bi-1%2Cj-1%7D%29)**

**利用此式将Romberg表一列列地全部生成。**

则 ![R_{i,i}](https://www.zhihu.com/equation?tex=R_%7Bi%2Ci%7D) 作为估计值的截断误差必为 ![O(h^{2i})](https://www.zhihu.com/equation?tex=O%28h%5E%7B2i%7D%29) 阶。

Romberg积分法的**优点之一便是利用并不大的计算量可以得到很精确的结果**。其次，每当我们想再一次提升精度时，我们只需要加入一个新的复化积分公式的估计值 ![R_{i+1,1}](https://www.zhihu.com/equation?tex=R_%7Bi%2B1%2C1%7D) ，我们就能够利用过去的计算结果生成出第 ![i+1](https://www.zhihu.com/equation?tex=i%2B1) 行，这个方法具有**良好的可扩展性**。

下面我们举一例：

例： ![\int_0^{\pi}sinxdx](https://www.zhihu.com/equation?tex=%5Cint_0%5E%7B%5Cpi%7Dsinxdx)

解：
![](https://pic3.zhimg.com/v2-fd29b77f90cb75da0bdb114fb8f38b6a_b.jpg)
可以看到到Romberg表第五行时我们就已经得到了非常精确的估计值。





至此为止，我们已经得到了复化积分公式这一有力的工具，但是我们的研究仍旧没有画上句号。我们注意到：我们至此为止谈及的数值积分方法都需要一个**前提条件：所取结点是等距分布的**。这样的取法本身就隐含着问题：我们**无法有效地应对在积分区间中一会儿变化剧烈一会儿变化非常微小的具有不同平稳性来回变化的函数**。所以，我们接下来要介绍的方法都具有一个共同特点：**我们开始关心结点的选取方法，我们要抛弃等距结点假设。**
![](https://pic2.zhimg.com/v2-b4b7fb095a92a675763f4e03181b8559_b.jpg)
上图所示函数 ![f(x)=e^{-3x}sin4x](https://www.zhihu.com/equation?tex=f%28x%29%3De%5E%7B-3x%7Dsin4x) 便是一个很好的例子。



其中一个很精妙的想法是：我们给定一阈值来**判定我们在某个小区间上的积分估计是否出现了很大的波动（前后估计值的差是否足够大）**，如果前后估计值相差很小，我们就认为在这个区间上我们的积分估计没有出现问题。反之，我们**进一步地细分这个区间（在估计不够好的区间中加入更多结点）**，再反复地进行上述步骤，直到相邻估计值相差得足够小时才停止。

这样的**根据积分估计值让积分结点选取自动地调整到合意位置**的方法就是：**自适应性积分法**。

我们下面侧重介绍自适应性积分方法的理论推导以及其成立所需要的前提条件。

为了简便起见，我们不妨将 ![[a,b]](https://www.zhihu.com/equation?tex=%5Ba%2Cb%5D) 区间上运用Simpson公式得到的定积分估计值记为 ![S(a,b)](https://www.zhihu.com/equation?tex=S%28a%2Cb%29) 。

那么我们有 ![S(a,b)=\frac{h}{3}[f(a)+4f(\frac{a+b}{2})+f(b)]](https://www.zhihu.com/equation?tex=S%28a%2Cb%29%3D%5Cfrac%7Bh%7D%7B3%7D%5Bf%28a%29%2B4f%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%29%2Bf%28b%29%5D)

那么我们容易知道 ![\int_a^bf(x)dx=S(a,b)-\frac{f^{(4)}(\xi_1)}{90}h^5](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3DS%28a%2Cb%29-%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_1%29%7D%7B90%7Dh%5E5)

那么同样地，我们可以利用复化积分公式的思想：将整个区间分成两个子区间后分别利用Simpson公式，我们有：

![\int_a^bf(x)dx=S(a,\frac{a+b}{2})+S(\frac{a+b}{2},b)-\frac{1}{16}\frac{f^{(4)}(\xi_2)}{90}h^5](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx%3DS%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29%2BS%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29-%5Cfrac%7B1%7D%7B16%7D%5Cfrac%7Bf%5E%7B%284%29%7D%28%5Cxi_2%29%7D%7B90%7Dh%5E5)

**注意：上两式中的 ![\xi_1,\xi_2](https://www.zhihu.com/equation?tex=%5Cxi_1%2C%5Cxi_2) 为不同的变量！**

**自适应性积分法成立的一个重要前提假设就是： ![\xi_1=\xi_2](https://www.zhihu.com/equation?tex=%5Cxi_1%3D%5Cxi_2) 。**

有了这个假设后我们很容易地能够将两个式子联立，得到：

![|\int_a^bf(x)dx-S(a,\frac{a+b}{2})-S(\frac{a+b}{2},b)|=\frac{1}{15}|S(a,b)-S(a,\frac{a+b}{2})-S(\frac{a+b}{2},b)|](https://www.zhihu.com/equation?tex=%7C%5Cint_a%5Ebf%28x%29dx-S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29-S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29%7C%3D%5Cfrac%7B1%7D%7B15%7D%7CS%28a%2Cb%29-S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29-S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29%7C)

这个式子意味着：如果我们要求估计值与真实值之间的绝对误差不超过 ![tolerance](https://www.zhihu.com/equation?tex=tolerance) ，则在估计的过程中我们只需要满足 ![|S(a,b)-S(a,\frac{a+b}{2})-S(\frac{a+b}{2},b)|<15*tolerance](https://www.zhihu.com/equation?tex=%7CS%28a%2Cb%29-S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29-S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29%7C%3C15%2Atolerance) 就已经满足了要求，对于 ![\int_a^bf(x)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx) 积分的估计就已经得以终止。

关于 ![\xi_1=\xi_2](https://www.zhihu.com/equation?tex=%5Cxi_1%3D%5Cxi_2) 的假设，可能很多读者会感到疑惑。当我第一次阅读时，我也感觉非常疑惑。对此，我能给出的解释是，由于我们假设了 ![f](https://www.zhihu.com/equation?tex=f) 是一个足够好的函数，故理所当然的我们假设了 ![f\in C^4[a,b]](https://www.zhihu.com/equation?tex=f%5Cin+C%5E4%5Ba%2Cb%5D) ，那么**当区间 ![[a,b]](https://www.zhihu.com/equation?tex=%5Ba%2Cb%5D) 足够小时，我们可以认为这样的假设是合理的**。当然，在实际应用中，我们常常将 ![\frac{1}{15}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B15%7D) 这个值调节得更为宽松，如 ![\frac{1}{10}](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B10%7D) 来确保自适应性方法有更大的概率会收敛。

最后我们简要地描述自适应性方法的思路并且给出实例证明其优越性。

**自适应性方法：**

**要估计 ![\int_a^bf(x)dx](https://www.zhihu.com/equation?tex=%5Cint_a%5Ebf%28x%29dx) ，且给定了可以接受的最大误差为 ![e](https://www.zhihu.com/equation?tex=e) 。**

**那么我们计算这个区间以及二分后的两个子区间上的积分估计值 ![S(a,b),S(a,\frac{a+b}{2}),S(\frac{a+b}{2},b)](https://www.zhihu.com/equation?tex=S%28a%2Cb%29%2CS%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29%2CS%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29) 。**

**如果我们发现 ![|S(a,b)-S(a,\frac{a+b}{2})-S(\frac{a+b}{2},b)|<15*e](https://www.zhihu.com/equation?tex=%7CS%28a%2Cb%29-S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29-S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29%7C%3C15%2Ae) ，我们直接结束方法并得到估计值为 ![S(a,\frac{a+b}{2})+S(\frac{a+b}{2},b)](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29%2BS%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29) 。**

**否则，我们需要进一步探究 ![S(a,\frac{a+b}{2})](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29) 与 ![S(\frac{a+b}{2},b)](https://www.zhihu.com/equation?tex=S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29) 中究竟是哪一个估计值出现了较大偏差。**

**对于 ![S(a,\frac{a+b}{2})](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29) ，我们再如上进行二分操作，计算出 ![S(a,\frac{3a+b}{4}),S(\frac{3a+b}{4},\frac{a+b}{2})](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7B3a%2Bb%7D%7B4%7D%29%2CS%28%5Cfrac%7B3a%2Bb%7D%7B4%7D%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29) 。由于我们将 ![S(a,b)](https://www.zhihu.com/equation?tex=S%28a%2Cb%29) 分成了两部分分别估计，我们对于![S(a,\frac{a+b}{2})](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29) 与 ![S(\frac{a+b}{2},b)](https://www.zhihu.com/equation?tex=S%28%5Cfrac%7Ba%2Bb%7D%7B2%7D%2Cb%29)的可容许误差上限都设定为 ![\frac{e}{2}](https://www.zhihu.com/equation?tex=%5Cfrac%7Be%7D%7B2%7D) 即可。**

**故若 ![|S(a,\frac{a+b}{2})-S(a,\frac{3a+b}{4})-S(\frac{3a+b}{4},\frac{a+b}{2})|<\frac{15e}{2}](https://www.zhihu.com/equation?tex=%7CS%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29-S%28a%2C%5Cfrac%7B3a%2Bb%7D%7B4%7D%29-S%28%5Cfrac%7B3a%2Bb%7D%7B4%7D%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29%7C%3C%5Cfrac%7B15e%7D%7B2%7D) ，则对于 ![S(a,\frac{a+b}{2})](https://www.zhihu.com/equation?tex=S%28a%2C%5Cfrac%7Ba%2Bb%7D%7B2%7D%29) 的估计结束，否则再一次进行区间的二分，如此往复。**

我们容易发现，整个过程可以画成一颗二叉树，过程类似于深度优先搜索。事实上，这个算法的实现就是依靠递归的。将一个结点的估计分成两颗子树的估计分别进行，等待进行完成后再求和。

我们下看一例：

例：估计 ![\int_0^3\frac{100sin(\frac{10}{x})}{x^2}dx](https://www.zhihu.com/equation?tex=%5Cint_0%5E3%5Cfrac%7B100sin%28%5Cfrac%7B10%7D%7Bx%7D%29%7D%7Bx%5E2%7Ddx)

解：

我们先向读者展示使用复化Simpson公式得到的结果。
![](https://pic4.zhimg.com/v2-c6a4163a9e7ab9b39200db0e95c7397f_b.jpg)
我们发现：为了达成这个相对误差我们需要进行 ![181](https://www.zhihu.com/equation?tex=181) 次函数估值。

接下来，我们再来看一下自适应性方法的结果：
![](https://pic1.zhimg.com/v2-1d17b8c73e49414c4f0b54a5e04c5bb4_b.jpg)
我们发现达成同样的相对误差仅仅用了 ![93](https://www.zhihu.com/equation?tex=93) 次函数估值。

注意表格中的每一行有助于我们理解自适应性方法的工作原理。 ![fail](https://www.zhihu.com/equation?tex=fail) 意味着在这个区间中的估计值误差仍旧较大，需要加入新的结点对区间进行细分。最右边一列代表栈中的状态（栈被用来模拟函数递归的操作，每当我们进入新的子树就将那个结点压入栈中，返回时弹出栈）
![](https://pic4.zhimg.com/v2-483c893ff70b8acbefd191ce2b67a42b_b.jpg)
观察上图，我们发现在函数值剧烈变化处结点数明显比平滑处多得多。

虽然复化Simpson公式也能够逐渐收敛到精确值，但是自适应性方法达成相同的相对误差节约了一半的计算量。本质是因为**自适应性方法对于那些估计本就很好的区间不再耗费结点进行细分估计，结点的加入是有选择性的**。





最后，我们再介绍一种非等距结点选取的积分估计方法：**Gauss方法**。

相比于自适应性方法这样的仍旧带有复化积分公式思想的方法，Gauss方法可谓另辟蹊径。

由线性代数的知识，我们都知道 ![1,x,x^2,...,x^n](https://www.zhihu.com/equation?tex=1%2Cx%2Cx%5E2%2C...%2Cx%5En) 可以作为线性空间的**一组基**，唯一地线性表出所有的次数不超过 ![n](https://www.zhihu.com/equation?tex=n) 的多项式。

Gauss方法在这一点上提出了疑问：这样的一组基真的足够好吗？

我们知道在线性代数中我们对于向量有Schimidt正交化的手段构造等价的标准正交基。那么要是我们是否能找到**![n+1](https://www.zhihu.com/equation?tex=n%2B1) 个相互正交的多项式作为基**唯一地线性表出所有次数不超过 ![n](https://www.zhihu.com/equation?tex=n) 的多项式呢？

答案是存在的。这便就是**Legendre多项式**。我们在这里先不提及要如何简便而系统地将多项式正交化，而是关注Legendre多项式在数值积分中到底能够给我们带来些什么。

**定义：**

**![n](https://www.zhihu.com/equation?tex=n) 次Legendre多项式 ![P_n(x)](https://www.zhihu.com/equation?tex=P_n%28x%29) 满足：首项系数为 ![1](https://www.zhihu.com/equation?tex=1) ，且对于任意次数小于 ![n](https://www.zhihu.com/equation?tex=n) 的多项式 ![P(x)](https://www.zhihu.com/equation?tex=P%28x%29) ， ![\int_{-1}^1P(x)P_n(x)dx=0](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1P%28x%29P_n%28x%29dx%3D0) 。**

容易发现**定积分运算满足内积所需要的正定性、对称性、双线性性**，确实可以作为线性空间的内积定义。但是注意到此处要求 ![x\in[-1,1]](https://www.zhihu.com/equation?tex=x%5Cin%5B-1%2C1%5D) 。故我们先讨论在 ![[-1,1]](https://www.zhihu.com/equation?tex=%5B-1%2C1%5D) 上的定积分如何处理，再将其推广到任意区间上。

读者可以试着求一下低阶的Legendre多项式。可以求得 ![P_0(x)=1,P_1(x)=x,P_2(x)=x^2-\frac{1}{3},P_3(x)=x^3-\frac{3}{5}x](https://www.zhihu.com/equation?tex=P_0%28x%29%3D1%2CP_1%28x%29%3Dx%2CP_2%28x%29%3Dx%5E2-%5Cfrac%7B1%7D%7B3%7D%2CP_3%28x%29%3Dx%5E3-%5Cfrac%7B3%7D%7B5%7Dx)


我们现在得到了一组Legendre多项式作为线性空间的基来表出多项式（注意相互正交的向量必定线性无关）。即任意 ![n](https://www.zhihu.com/equation?tex=n) 次多项式 ![P(x)=\sum_{j=1}^nk_jP_j(x)](https://www.zhihu.com/equation?tex=P%28x%29%3D%5Csum_%7Bj%3D1%7D%5Enk_jP_j%28x%29) ，且表出形式唯一。

现在我们的问题是：这如何与我们的数值积分理论挂上钩呢？

**Gauss方法：若要取 ![n](https://www.zhihu.com/equation?tex=n) 个结点对 ![\int_{-1}^1f(x)dx](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1f%28x%29dx) 进行估计，则取 ![P_n(x)](https://www.zhihu.com/equation?tex=P_n%28x%29) 的 ![n](https://www.zhihu.com/equation?tex=n) 个零点 ![x_1,...,x_n](https://www.zhihu.com/equation?tex=x_1%2C...%2Cx_n) 作为结点。我们有估计值 ![\int_{-1}^1f(x)dx=\sum_{j=1}^nc_jf(x_j)](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1f%28x%29dx%3D%5Csum_%7Bj%3D1%7D%5Enc_jf%28x_j%29) ，其中 ![c_j=\int_{-1}^1L_i(x)dx](https://www.zhihu.com/equation?tex=c_j%3D%5Cint_%7B-1%7D%5E1L_i%28x%29dx) 。（回忆 ![L_i](https://www.zhihu.com/equation?tex=L_i) 为关于 ![x_i](https://www.zhihu.com/equation?tex=x_i) 结点的Lagrange基函数）**


关于Gauss方法，其优势在于**能够用 ![n](https://www.zhihu.com/equation?tex=n) 个结点产生出代数精度高达 ![2n-1](https://www.zhihu.com/equation?tex=2n-1) 的估计值**。

**定理： ![n](https://www.zhihu.com/equation?tex=n) 个结点Gauss方法的代数精度为 ![2n-1](https://www.zhihu.com/equation?tex=2n-1)**

证明：

即证明当 ![f(x)](https://www.zhihu.com/equation?tex=f%28x%29) 为任意次数不超过 ![2n-1](https://www.zhihu.com/equation?tex=2n-1) 的多项式时，误差均为 ![0](https://www.zhihu.com/equation?tex=0)

先考虑当 ![f(x)](https://www.zhihu.com/equation?tex=f%28x%29) 为任意次数不超过 ![n-1](https://www.zhihu.com/equation?tex=n-1) 的多项式，我们容易知道此时 ![f(x)=\sum_{j=1}^nL_j(x)f(x_j)](https://www.zhihu.com/equation?tex=f%28x%29%3D%5Csum_%7Bj%3D1%7D%5EnL_j%28x%29f%28x_j%29) ，Lagrange插值不会产生任何误差。

那么自然地， ![\int_{-1}^1f(x)dx=\sum_{j=1}^nc_jf(x_j)](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1f%28x%29dx%3D%5Csum_%7Bj%3D1%7D%5Enc_jf%28x_j%29) 成立。

当 ![n\leq deg\ f\leq 2n-1](https://www.zhihu.com/equation?tex=n%5Cleq+deg%5C+f%5Cleq+2n-1) ，我们利用多项式的带余除法性质，将Legendre多项式写入表达式中。

即 ![\exists Q(x),R(x),f(x)=Q(x)P_n(x)+R(x)(degR\leq n-1)](https://www.zhihu.com/equation?tex=%5Cexists+Q%28x%29%2CR%28x%29%2Cf%28x%29%3DQ%28x%29P_n%28x%29%2BR%28x%29%28degR%5Cleq+n-1%29)

则我们容易看到正交性和插值结点选取为Legendre多项式的零点在此时都发挥了关键作用。

![\int_{-1}^1f(x)dx=\int_{-1}^1P_n(x)Q(x)dx+\int_{-1}^1R(x)dx](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1f%28x%29dx%3D%5Cint_%7B-1%7D%5E1P_n%28x%29Q%28x%29dx%2B%5Cint_%7B-1%7D%5E1R%28x%29dx)

由于其正交性，上式 ![=\int_{-1}^1R(x)dx](https://www.zhihu.com/equation?tex=%3D%5Cint_%7B-1%7D%5E1R%28x%29dx)

而又有 ![deg R\leq n-1](https://www.zhihu.com/equation?tex=deg+R%5Cleq+n-1) ，根据上面已经证明的结论，我们有

![\int_{-1}^1R(x)dx=\sum_{j=1}^nc_jR(x_j)](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1R%28x%29dx%3D%5Csum_%7Bj%3D1%7D%5Enc_jR%28x_j%29)

最后利用 ![x_1,...,x_n](https://www.zhihu.com/equation?tex=x_1%2C...%2Cx_n) 均为 ![P_n(x)](https://www.zhihu.com/equation?tex=P_n%28x%29) 零点，我们得到 ![R(x_j)=f(x_j)](https://www.zhihu.com/equation?tex=R%28x_j%29%3Df%28x_j%29) ，故得证。

Gauss方法的另一个优点在于：**可以将所有 ![x_j,c_j](https://www.zhihu.com/equation?tex=x_j%2Cc_j) 的数值提前计算好存储在计算机中反复利用**。如此一来，对于 ![n](https://www.zhihu.com/equation?tex=n) 个结点的积分值估计仅仅需要对函数值进行 ![n](https://www.zhihu.com/equation?tex=n) 次计算即可。


事实上，我们还能够通过另一个侧面来理解Gauss方法。

我们考虑估计形式 ![\int_{-1}^1f(x)dx=c_1f(x_1)+c_2f(x_2)](https://www.zhihu.com/equation?tex=%5Cint_%7B-1%7D%5E1f%28x%29dx%3Dc_1f%28x_1%29%2Bc_2f%28x_2%29) （取两个结点进行估计）。

我们想要使得数值积分的**代数精度尽可能高，以此反推出 ![c_1,c_2,x_1,x_2](https://www.zhihu.com/equation?tex=c_1%2Cc_2%2Cx_1%2Cx_2) 的选取**。

分别将 ![f(x)=1,f=x,f=x^2,f=x^3](https://www.zhihu.com/equation?tex=f%28x%29%3D1%2Cf%3Dx%2Cf%3Dx%5E2%2Cf%3Dx%5E3) 代入，得到四个未知数四个方程。

![\begin{cases} c_1+c_2=2\\ c_1x_1+c_2x_2=0\\ c_1x_1^2+c_2x_2^2=\frac{2}{3}\\ c_1x_1^3+c_2x_2^3=0  \end{cases}](https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+c_1%2Bc_2%3D2%5C%5C+c_1x_1%2Bc_2x_2%3D0%5C%5C+c_1x_1%5E2%2Bc_2x_2%5E2%3D%5Cfrac%7B2%7D%7B3%7D%5C%5C+c_1x_1%5E3%2Bc_2x_2%5E3%3D0++%5Cend%7Bcases%7D)

解得 ![c_1=c_2=1,x_1=-\frac{\sqrt{3}}{3},x_2=\frac{\sqrt{3}}{3}](https://www.zhihu.com/equation?tex=c_1%3Dc_2%3D1%2Cx_1%3D-%5Cfrac%7B%5Csqrt%7B3%7D%7D%7B3%7D%2Cx_2%3D%5Cfrac%7B%5Csqrt%7B3%7D%7D%7B3%7D)

我们惊奇地发现 ![x_1,x_2](https://www.zhihu.com/equation?tex=x_1%2Cx_2) 为 ![P_2(x)=x^2-\frac{1}{3}](https://www.zhihu.com/equation?tex=P_2%28x%29%3Dx%5E2-%5Cfrac%7B1%7D%7B3%7D) 的两个根。

这告诉我们：**Gauss方法在积分估计值为函数值的线性组合的情形下在代数精度上是最优的。**

另外值得说明的一点是：**Gauss方法事实上可以在任意区间中应用。我们只需要构造 ![[a,b]\rightarrow[-1,1]](https://www.zhihu.com/equation?tex=%5Ba%2Cb%5D%5Crightarrow%5B-1%2C1%5D) 的线性变换即可将Gauss方法推广至任意有限区间中**，请读者自行推广。

我们下举一例说明：

例：估计 ![\int_1^3x^6-x^2sin2x\ dx](https://www.zhihu.com/equation?tex=%5Cint_1%5E3x%5E6-x%5E2sin2x%5C+dx)

解：
![](https://pic4.zhimg.com/v2-680bcb2b10402c4886bde451f07bea63_b.jpg)
我们可以看到：仅仅利用了 ![7](https://www.zhihu.com/equation?tex=7) 次函数值计算，就能够达到如此高的精度。这再一次证明了Gauss方法在各种方面独特的优越性。



事实上，关于数值微分与数值积分，有趣的方法仍旧有很多。我们也能够进行很多推广，比如将复化Simpson公式和Gauss方法推广到多维情形来估计多重积分。我们也能够将自适应性方法推广到二维情形（这时二叉树将会变成四叉树）。

对于无穷积分与瑕积分，我们倾向于将所有积分化为瑕积分形式，在瑕点处进行Taylor展开。对于展开式，我们分成多项式部分（能精确地积出的部分）与余项部分（不能精确地积出，需要进一步利用复化Simpson公式估计）。

关于更多的巧妙方法，限于作者水平，在此不做过多介绍了。若读者有兴趣，可以查阅相关资料更深入了解。

谢谢各位的阅读！

