# 教程: 打造你自己的数学函数 - 知乎
# 

这节我们来将研究下怎么定义一个像内置函数一样的数学函数.

最终效果大概和卡塔兰数 ![\texttt{CatalanNumber[]}](https://www.zhihu.com/equation?tex=%5Ctexttt%7BCatalanNumber%5B%5D%7D) 差不多

定义一个函数: ![^{\infty}z=\frac{W(-\ln (z))}{-\ln (z)}](https://www.zhihu.com/equation?tex=%5E%7B%5Cinfty%7Dz%3D%5Cfrac%7BW%28-%5Cln+%28z%29%29%7D%7B-%5Cln+%28z%29%7D)

定义出来的函数要有自己的书写形式, 要能进行数值计算, 要能正确的输出TeX格式.

先写出来这个函数:

`TetraTower[z_]:=ProductLog[-Log[z]]/-Log[z];`

但是根本没法保持这个形式啊, 直接就被替换掉了.
![](https://pic2.zhimg.com/v2-2f6e2c997a1a8f3ff99edf21d670c2b5_b.jpg)
用模式判定阻断替换就行了 ![\texttt{ TetraTower[z_?NumericQ] }](https://www.zhihu.com/equation?tex=%5Ctexttt%7B+TetraTower%5Bz_%3FNumericQ%5D+%7D)

接下来我们想给出他的书写形式: ![^\infty\! x](https://www.zhihu.com/equation?tex=%5E%5Cinfty%5C%21+x)

但是...没有这种标记法啊

TeX 里也是没有左标的, 一般来说实现方式是插个空白

![\texttt{{}_b^a \! X_d^c}](https://www.zhihu.com/equation?tex=%5Ctexttt%7B%7B%7D_b%5Ea+%5C%21+X_d%5Ec%7D) , 渲染一下![{}_b^a \! X_d^c](https://www.zhihu.com/equation?tex=%7B%7D_b%5Ea+%5C%21+X_d%5Ec)

等价的表达式就是:

```
TetraTower[z_?NumericQ]:=ProductLog[-Log[z]]/-Log[z];
Format[TetraTower[z_],TraditionalForm]:=DisplayForm@RowBox[
    {SuperscriptBox[" ","\[Infinity]"],"(",z,")"}]
```

感觉就像在写 plainTeX.....

来试试效果
![](https://pic2.zhimg.com/v2-6f743a5b07ee45a47976cd25b3afb2b5_b.jpg)
效果很糟糕, TeX式还是错的,事实上如果右键复制会发现成了: \text{Null}^{\infty }(a)

而且如果你细心的话会发现内置函数光标移上去会显示函数名:
![](https://pic1.zhimg.com/v2-d6337ca6fce3a984e9c415fae37b26c8_b.jpg)
这是什么黑科技??

其实就是提示条 Tooltip,绘图示例里有介绍

当然扔其他地方是一样的.

括号问题可以通过原子判定解决掉

空格问题么...空格是空格, 真正的空白是 ![\texttt{\[Null]}](https://www.zhihu.com/equation?tex=%5Ctexttt%7B%5C%5BNull%5D%7D)

另外![\TeX](https://www.zhihu.com/equation?tex=%5CTeX) 里的 ![\texttt{\!}](https://www.zhihu.com/equation?tex=%5Ctexttt%7B%5C%21%7D) 对应的应该是 ![\texttt{\[NegativeThinSpace]}](https://www.zhihu.com/equation?tex=%5Ctexttt%7B%5C%5BNegativeThinSpace%5D%7D) .

```
TetraTower[z_?NumericQ]:=ProductLog[-Log[z]]/-Log[z];
Format[TetraTower[z_?AtomQ],TraditionalForm]:=DisplayForm@Tooltip[
    RowBox[{SuperscriptBox["\[Null]","\[Infinity]"],"\[NegativeThinSpace]",z}],
    "TetraTower"]
Format[TetraTower[z_],TraditionalForm]:=DisplayForm@Tooltip[
    RowBox[{SuperscriptBox["\[Null]","\[Infinity]"],"(",z,")"}],
    "TetraTower"]
```

![](https://pic1.zhimg.com/v2-0a4e7da13f764ce3e014b4d26eda6f18_b.jpg)
完美, 无论是提示条, 书写效果还是TeX格式都很标准! 

其实还是有小瑕疵, 这么定义的书写式和TeX式不能反向转化成标准式(单射).

当然其实还有更完美的解决方案...

但是要用到样式表, 超纲了, 我就不展开讲了...
[How can I type left (sub)superscript?​mathematica.stackexchange.com![图标](https://pic1.zhimg.com/v2-2397250edc98043237b0b8c11495a700_ipico.jpg)](https://link.zhihu.com/?target=https%3A//mathematica.stackexchange.com/questions/15058/how-can-i-type-left-subsuperscript/15131%2315131)
还有一个问题, 怎么给他加上运算法则?

一个暴力的方法是重载求导算符...

那岂不是相当于要手推微积分性质了???

Emmm, 我们可以抓个样板, 比如看看那些组合函数的定义.
![](https://pic3.zhimg.com/v2-f3552b642eb1dff8d74e837a6a7dda5e_b.jpg)
看到倒数第三段, 原来是用 ![\texttt{/:}](https://www.zhihu.com/equation?tex=%5Ctexttt%7B%2F%3A%7D) 定义了 **函数上值 **啊

我又看了下其他函数, 发现只有 **级数 **和**导数 **是定义在上值里的.

函数展开, 积分, 生成函数, 反函数之类的都是定义在规则里的....
![](https://pic1.zhimg.com/v2-fd68aa22adb0b59433a1a6622dd30388_b.jpg)想不到吧, 打表大法...
这个函数没有(符号)积分, 就不定义了

我们定义下反函数好了...因为它有两叶, 反函数要选取合适的分割

还要添加一些代数运算法则...不知道有没有别的解法, 但是暴力重载掉  ![\texttt{FunctionExpand}](https://www.zhihu.com/equation?tex=%5Ctexttt%7BFunctionExpand%7D) 是肯定可以的...

```
TetraSSR[z_?NumericQ]:=z^(1/z);
Unprotect[InverseFunction,FunctionExpand]
FunctionExpand@TetraTower[z_]:=ProductLog[-Log[z]]/-Log[z];
FunctionExpand@TetraSSR[z_]:=z^(1/z);
InverseFunction[TetraTower]=TetraSSR;
InverseFunction[TetraSSR]=TetraTower;
```

