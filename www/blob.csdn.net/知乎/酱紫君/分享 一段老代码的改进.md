# 分享: 一段老代码的改进 - 知乎
# 

最近在写一个项目整理一些代码

这是一段算24点的代码.[https://www.douban.com/group/topic/15763875/](https://link.zhihu.com/?target=https%3A//www.douban.com/group/topic/15763875/)

```
filter[{op1_,op2_,op3_},{a_,b_,c_,d_},t_:]:=Module[
  {ans={}},
    If[Quiet@op1[op2[op3[a,b],c],d]==,ans=Union[ans,{HoldForm@op1[op2[op3[a,b],c],d]}];];
    If[Quiet@op1[op2[a,b],op3[c,d]]==,ans=Union[ans,{HoldForm@op1[op2[a,b],op3[c,d]]}];];
    If[Quiet@op1[op2[a,op3[b,c]],d]==,ans=Union[ans,{HoldForm@op1[op2[a,op3[b,c]],d]}];];
    If[Quiet@op1[a,op2[op3[b,c],d]]==,ans=Union[ans,{HoldForm@op1[a,op2[op3[b,c],d]]}];];
    If[Quiet@op1[a,op2[b,op3[c,d]]]==,ans=Union[ans,{HoldForm@op1[a,op2[b,op3[c,d]]]}];];
  ans];

cal24[nums_List]:=Module[
  {ops,num=nums,rule,same},
  ops={Plus,Subtract,Times,Divide};
  rule=Thread[num->{n1,n2,n3,n4}];
  same[a_,b_]:=Module[{p,q},p=a/.rule;
    q=b/.rule;ReleaseHold[p]===ReleaseHold[q]];
    DeleteDuplicates[Union@@filter@@@Tuples[{Tuples[ops,],Permutations[num]}],
  same]
]
```

这段代码比其他我找得到的最快的代码还要快5倍(1秒20个模式,一分多钟检验完24点所有的可能性), 且**不重不漏**.

(不得不说算24点的代码很多都不做去重...最难的部分就是去重)

简单点评下这段代码,  主要就是最后一行

`DeleteDuplicates[Union@@filter@@@Tuples[{Tuples[ops,],Permutations[num]}]`

直接生成所有模式, 用filter判定, 因为算式都是HoldForm, 于是直接取并集(Union)去重即可.

那么问题来了...这个filter怎么写出来的...五个If 哪来的?

我问了下吧主...吧主表示...

> **7年前的代码谁还记得...**

大概是手写归纳的,因为原文中还漏掉了一个模式...

然后大佬 [@曹洪洋](https://www.zhihu.com/people/c8b23177ec096bda89bf5a53d4e7f8fc) 出手大大化简了这段代码.

```
calc24[nList_]:=DeleteDuplicatesBy[Cases[
  Outer[filter,Tuples[{Plus,Subtract,Times,Divide},3],Permutations[nList],1],e_/;Quiet@ReleaseHold@e==24,{3}],
  ReleaseHold[#/.Thread[nList->{x,y,z,w}]]&];
```

把 Quiet@ReleaseHold@e==24 给移出来了.

这下难度就不大了...

但是问题还在于filter到底是什么

我们画出树状图
![](https://pic4.zhimg.com/v2-485d7df6bcdf44cd85580e5ed2441c7b_b.jpg)
哇,n个节点的有序有根二叉树...或者叫卡特兰树...

因为树的数目是卡特兰数.

于是我们就能用元编程解决这个问题了

```
treeR[1]=n;
treeR[n_]:=treeR[n]=Table[o[treeR[a],treeR[n-a]],{a,1,n-1}]
treeC[n_]:=Flatten[treeR[n]//.{o[a_List,b_]:>(o[#,b]&/@a),o[a_,b_List]:>(o[a,#]&/@b)}]
treeC[4]//TableForm

nn=Array[ToExpression["n"<>ToString@#]&,4]
oo=Array[ToExpression["o"<>ToString@#]&,4-1]
ff=ReplacePart[#,Thread[Position[#,n]->nn]~Join~Thread[Position[#,o]->oo]]&
filter=Function[Evaluate@Join[oo,nn],Evaluate[HoldForm/@Evaluate[ff/@treeC[4]]]]

calc24[nList_]:=DeleteDuplicatesBy[Cases[Outer[filter@@Join[#1,#2]&,Tuples[{Plus,Subtract,Times,Divide},3],Permutations[nList],1],e_/;Quiet@ReleaseHold@e==24,{3}],ReleaseHold[#/.Thread[nList->nn]]&];

calc24[{2,3,5,7}]
```

算法规模是 ![f_o(n)=n! C_{n-1} o^{n-1}](https://www.zhihu.com/equation?tex=f_o%28n%29%3Dn%21+C_%7Bn-1%7D+o%5E%7Bn-1%7D)

C是卡特兰数,o是操作符数,这里是加减乘除4个

![f_4(n)=O\Biggl(\left(\frac{16}{e}\right)^n \left(n-\frac{3}{2}\right)^{n-1}\Biggl)](https://www.zhihu.com/equation?tex=f_4%28n%29%3DO%5CBiggl%28%5Cleft%28%5Cfrac%7B16%7D%7Be%7D%5Cright%29%5En+%5Cleft%28n-%5Cfrac%7B3%7D%7B2%7D%5Cright%29%5E%7Bn-1%7D%5CBiggl%29)

