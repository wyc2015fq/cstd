# 代码: 多项式穿越实空间时的截面 - 知乎
# 

本来今天应该更新怎么使用上文的包管理写程序包了...

然而我还在和作者就架构问题扯皮...

最严重的是他写这个架构时压根没考虑非英文...

修bug还来不及还多语言, 有的扯皮不如交PR...

算了, 我还有自己的项目,到时候手动魔改吧...

那讲个最近写的代码凑数吧...

[酱紫君：为什么一次函数、二次函数、三次函数的图像都是对称的，而四次函数则不一定？](https://www.zhihu.com/question/35003465/answer/274940638)

绘制多项式函数穿过 ![\Im=0](https://www.zhihu.com/equation?tex=%5CIm%3D0) 空间时的截面,

```
Options[PolynomialPlot]={Im->,FontSize->,Min->,Max->};
PolynomialPlot[poly_?PolynomialQ,ops:OptionsPattern[{PolynomialPlot,Plot3D}]]:=
Block[{sol,curves,pts,plane},
    (*sol[a_,b_]:=Solve[poly==a+b I,x,Quartics->False];*)
    sol[a_,b_]:=List@ToRules@Reduce[poly==a+b I,x];
    curves=Append[ReIm[x],y]/.sol[y,OptionValue[Im]];
    plane=Graphics3D[{Opacity[0.5],InfinitePlane[{{,,},{,,},{,,}}]}];
    pts=Point/@(Join[#,{}]&/@ReIm[x/.NSolve[poly==I OptionValue[Im]]]);
    Evaluate@Show[
        ParametricPlot3D[curves,{y,OptionValue[Min],OptionValue[Max]},
            Evaluate@FilterRules[{ops}, Options[Plot3D]],
            ColorFunction->Function[{x, y, z}, Hue[y + 0.5]],
            (*AxesLabel->{"Re","Im","y"},*)
            ViewPoint->#,SphericalRegion->True,
            Epilog->Inset[Style[TraditionalForm[\[GothicCapitalR]+OptionValue[Im]" I"==poly],OptionValue[FontSize]],{0.5,0.1}]],
        Graphics3D@Join[{PointSize[Large],Red},pts],plane,
        BoxRatios->{,,},AxesOrigin->{,,},Boxed->False,Axes->True
    ]&
]
```

![](https://pic3.zhimg.com/v2-b9446e2ee7fbe626e68b34213e45a9ae_b.gif)
好的我们来一行一行讲解

第一行

`Options[PolynomialPlot]={Im->0,FontSize->20,Min->-10,Max->10};`

是对这个函数的独特参数的声明,紧接着第二行

`ops:OptionsPattern[{PolynomialPlot,Plot3D}]`

表示 继承Plot3D函数的默认参数, 若冲突则使用PolynomialPlot函数的参数, 所有参数记为ops.

函数第一行sol写出n次多项式的n个反函数...我为什么把Solve注释掉了呢...

因为有可能异常展开导致惨案:
![](https://pic2.zhimg.com/v2-4834f5d4113ef321ea187ae4b2a4c795_b.jpg)分支点附近的异常连接
我当时想破脑袋都想不通这个bug哪来的...手写Root对象之后就好了...

接下来三行curves,plane,pts没啥好说的,就是图中的n条曲线,平面和n个解.

`接下来为什么要用Evaluate@Show[#]&形式呢?`

因为这样可以减小计算量.

上面的计算完成后Show函数传出一个带Options的图元对象(GraphicsComplex)

然后Graphics3D函数接受这个图元对象开始渲染.

也就是传入的多项式之后整个图形已经确定了,之后旋转不需要再计算一遍直接渲染即可.

于是直接Evaluate生成一个只缺旋转视角的偏函数.

这样可以减少85%的重复计算.

然后 ParametricPlot3D 接受继承来的 Plot3D 的参数.

`ParametricPlot3D[...,Evaluate@FilterRules[{ops}, Options[Plot3D]]]`

最后值得一提的是SphericalRegion->True参数,锁定旋转中心.不开的话...
![](https://pic3.zhimg.com/v2-54d49e5e5514b2279e0ea9e5c3006c1a_b.gif)
我也是醉了(字面意)...

于是最终函数接受一个多项式, 输出一个缺旋转视角的偏函数, 补上旋转视角即可.

`PolynomialPlot[x^6 - 3 x^4 - 4 x - 2][{Sin[0], Cos[0], 0.8}]`
![](https://pic1.zhimg.com/v2-ec171216134ef0b55ec5cc8db3c4faa8_b.jpg)
旋转视角就是在框体外面指向中心的一个向量的起始点.
![](https://pic2.zhimg.com/v2-45e44de0ac168900f7fc3ba83a4fcb65_b.gif)
比较复杂的路径我不会...绕圆我还是会的...

不就是 ![(\cos t, \sin t,z)](https://www.zhihu.com/equation?tex=%28%5Ccos+t%2C+%5Csin+t%2Cz%29) 嘛...

然后可以用ListAnimation预览一下效果

```
poly3d = PolynomialPlot[x^6 - 3 x^4 - 4 x - 2, Min -> -15, 
   ImageSize -> 512, MaxRecursion -> 12];
ListAnimate@Table[poly3d[{Sin[t], Cos[t], 0.8}], {t, 0, 2 Pi}]
```

参数调的差不多了就可以渲染了

```
(Clear[gifs];
  gifs = Table[poly3d[{Sin[t], Cos[t], 0.8}], {t, 0, 2 Pi, 0.1}];
  Export["poly2_1.gif", gifs, "AnimationRepetitions" -> Infinity]
) // TT
```

![](https://pic3.zhimg.com/v2-15a72c111bd0529cd806c9495a2f4cda_b.jpg)
这个IO时间真是分外感人...长达12秒...

有时候比较长的gif建议导出为png图片,用别的软件合成

因为导出png可以多线程,你这个gif爆了你的代码和图就没了...

题图黎曼, 附赠该函数的黎曼面
![](https://pic2.zhimg.com/v2-7f107e3ca1e839c4b99866eac72bf379_b.jpg)

