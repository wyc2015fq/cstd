# 用程序模拟进化过程：文字进化 - 知乎
# 

       图文应该有关吧，一个幽灵特工（ghost）在异虫主宰（Overmind）的设计下进化成刀锋女王（The Queen of Blades）——其实我就是想放Kerrigan而已【手动滑稽】。

进化可以说是生命的本质之一，进化思想也是生命科学的一大基石，但一直以来，进化论都只是通过对大量事实观察归纳和合理外推得到的理论。笔者认为**唯有由物理化学原理和数学推理建立的模型才有可能精确刻画进化的本质**——然而那太过遥遥无期。不过现在我们可以通过一个小程序从感性的层面体验进化的威力。该程序由visual c++编写，源文件和可直接运行的程序（advanced edition文件夹下的text.exe，不用安装VC++）可通过下面的链接下载：

[百度云：进化模拟小程序](https://link.zhihu.com/?target=http%3A//pan.baidu.com/s/1o8c1qaA)

       程序的内容是**由一段任意长度任意排序的字母进化成你想要的字母序列**。比如说我脸滚键盘打了个“dkfjskjfskn”，通过充分的进化，就可以得到一条真理序列“iamhandsome”（啪）。**这个过程其实是在模拟生物的进化，每代生物会发生随机变异，然后被自然自然淘汰只剩下最优秀的一部分，再由这部分生出下一代（我设定的字母组有1000个，相当于一个有1000个个体的种群）**。下面由我介绍程序正确的打开姿势：

       打开程序，首先需要**输入的是序列长度**。比如说想进化的单词是evolution，那就输入9回车；如果是life，就是4，回车。

        然后需要**输入的是初始变异序列**，长度须与序列长度一致，多余的字母会被舍去。这里需要麻烦各位读者老爷的是，由于笔者水平有限，不会将字母转化为自然数序列（如果哪位大神愿意指教，请在评论区留言，感谢），因此各位需要先将字母转化为数字：a=0，b=1，c=2，......，y=24，z=25。以abcd为例，就是0（空格或回车）、1（空格或回车）、2（空格或回车）、3（回车）。之后程序会帮助确认序列（不过各位应该也是脸滚键盘选的序列）。

         同样的道理，**输入目标序列**。以life为例，就是11（空格或回车）、8（空格或回车）、5（空格或回车）、4（空格或回车）。

         最后需要输入的是两个重要参数：突变率和选择率，单位都是万分之一，输入数据是正整数（当然你输0也是可以的，看代码跳也很有意思的#（滑稽））。之后程序会告诉你初始差异的大小。调节突变率和现实率是成功的关键。

          所有参数输入完成后界面类似下方

![](https://pic4.zhimg.com/v2-3044678fbc6cc2d9470ef6df4f529adb_b.jpg)         由于程序模拟了突变的随机性，因此即使是完全相同的参数，两次运行的结果也会有差异，进化的代数和过程都很可能不相同。**注意：需要仔细调节突变率和选择率**。突变率太高选择率太低，优秀的变异结果很难保留；突变率太低选择率太高，进化的速度又十分缓慢——二者都会导致难以进化到想要的序列。下面是三次运行上图参数的结果，可以看出差异还是很明显的。

![](https://pic2.zhimg.com/v2-ded6284eb5ad8a01e5a4a1196466bff5_b.jpg)![](https://pic2.zhimg.com/v2-c1fe3484f482763bafff73d6313d67c9_b.jpg)![](https://pic3.zhimg.com/v2-c3197be7f905d306155cd7cc880fce4e_b.jpg)**      接下来就看各位读者的探索了。**

![](https://pic2.zhimg.com/v2-c83b29622de1489edbfb603d2b8e1575_b.jpg)     为了便于交流，在末尾附上源代码，欢迎大家讨论，指出笔者的不足。笔者是编程新手，**求轻喷**。

```cpp
#include<iostream>
#include<cmath>
#include<ctime>
using namespace std;
int main()
{double a,b;
int var,var0,i,j,h,h0,min,minrep,min0,k,n,ge,x,s0;  //var0代表突变个数 var辅助循环
ge=;
min=;
min0=;
minrep=;
int o[][];
int o0[];
int oo[];
int s[];
int m[];
int site[];
int value[];

cout<<"STEP1 请输入序列长度（个字母）";
cin>>x;

cout<<endl<<"STEP2 请输入变异的初始字母序列（数字输入，a=0,b=1,c=2,...z=25）"<<endl;
for (i=;i<x;i++) cin>>o0[i];

cout<<"请确认初始序列";
for(i=;i<x;i++)
{
switch(o0[i])
	{case :cout<<"a";break;
case :cout<<"b";break;
case :cout<<"c";break;
case :cout<<"d";break;
case :cout<<"e";break;

case :cout<<"f";break;
case :cout<<"g";break;
case :cout<<"h";break;
case :cout<<"i";break;
case :cout<<"j";break;

case :cout<<"k";break;
case :cout<<"l";break;
case :cout<<"m";break;
case :cout<<"n";break;
case :cout<<"o";break;

case :cout<<"p";break;
case :cout<<"q";break;
case :cout<<"r";break;
case :cout<<"s";break;
case :cout<<"t";break;

case :cout<<"u";break;
case :cout<<"v";break;
case :cout<<"w";break;
case :cout<<"x";break;
case :cout<<"y";break;

case :cout<<"z";break;
default: cout<<endl<<endl<<"         input error,please reopen the program"<<endl;goto end;	}
}

cout<<endl;
cout<<endl<<"STEP3 请输入目标初始字母序列（同上，要求长度相同）"<<endl;
for(i=;i<x;i++)  cin>>oo[i];

cout<<"请确认目标序列";
for(i=;i<x;i++)
{
switch(oo[i])
	{case :cout<<"a";break;
case :cout<<"b";break;
case :cout<<"c";break;
case :cout<<"d";break;
case :cout<<"e";break;

case :cout<<"f";break;
case :cout<<"g";break;
case :cout<<"h";break;
case :cout<<"i";break;
case :cout<<"j";break;

case :cout<<"k";break;
case :cout<<"l";break;
case :cout<<"m";break;
case :cout<<"n";break;
case :cout<<"o";break;

case :cout<<"p";break;
case :cout<<"q";break;
case :cout<<"r";break;
case :cout<<"s";break;
case :cout<<"t";break;

case :cout<<"u";break;
case :cout<<"v";break;
case :cout<<"w";break;
case :cout<<"x";break;
case :cout<<"y";break;

case :cout<<"z";break;
default: cout<<endl<<endl<<"          input error,please reopen the program"<<endl;goto end;	}
}

cout<<endl;
s0=;
for(i=;i<x;i++) s0+=(o0[i]-oo[i])*(o0[i]-oo[i]);
               //caculate the distance
cout<<endl<<"初始差距s为"<<endl<<s0;
cout<<endl;
cout<<endl<<"STEP4 请输入突变率（正整数）var0(‰)"<<endl;
cin>>var0;
cout<<endl;
cout<<"STEP5 请输入选择率（整数,不建议超过100）n(‰)" <<endl;
cin>>n;
system  ("pause");
cout<<endl<<"please wait a few seconds"<<endl;

srand(time());       //引入时间函数模拟随机过程

for(j=;j<;j++) 
{for(i=;i<x;i++) o[j][i]=o0[i];}
j=;

for(h0=;h0<;h0++,j++)
{ 

for(var=;var<var0;var++)
{                               //s
b=rand()%x;
site[var]=b;
     //给数组中的随机序数（x以内非负整数）数字进行变异
}                              //e

for(var=;var<var0;var++)
{                             //s

	a=+rand()%;  
value[var]=a;
if(value[var]>)
value[var]=;    
}                               //给数组加一个26内的随机整数  e

for(var=;var<var0;var++)
{o[j][site[var]]=o[j][site[var]]+value[var];   //完成变异 s
if(o[j][site[var]]>)
{o[j][site[var]]=o[j][site[var]]-;}
}                                //e
}                                //e
  //for h0 结束的地方

while(min0>)  //在差异缩小到零之前循环
{                             //s
ge=ge+;
for(j=;j<;j++)
{
	s[j]=;
for(i=;i<x;i++) s[j]+=(o[j][i]-oo[i])*(o[j][i]-oo[i]);
}               //caculate the distance

for(min=s[],j=;j<;j++)
{if(s[j]<=min) min=s[j],minrep=j;}

min0=min;

for(i=;i<x;i++)
{
switch(o[minrep][i])
{case :cout<<"a";break;
case :cout<<"b";break;
case :cout<<"c";break;
case :cout<<"d";break;
case :cout<<"e";break;

case :cout<<"f";break;
case :cout<<"g";break;
case :cout<<"h";break;
case :cout<<"i";break;
case :cout<<"j";break;

case :cout<<"k";break;
case :cout<<"l";break;
case :cout<<"m";break;
case :cout<<"n";break;
case :cout<<"o";break;

case :cout<<"p";break;
case :cout<<"q";break;
case :cout<<"r";break;
case :cout<<"s";break;
case :cout<<"t";break;

case :cout<<"u";break;
case :cout<<"v";break;
case :cout<<"w";break;
case :cout<<"x";break;
case :cout<<"y";break;

case :cout<<"z";break;
	}

}
cout<<"  s="<<min<<"   (第"<<ge<<"代)"<<endl;

while(min<)
{
for(j=,k=;j<;j++)
{if(s[j]=min) continue;
m[k]=j;
k=k+;}
min=min+;
if(k>n) break;
}

for(h=;h<n;h++)
{

for(i=,i<x;i++;)
o[h*/n][i]=o[m[h]][i];
j=h*/n;

for(h0=;h0</n;h0++,j++)
{
for(var=;var<var0;var++)
{

b=rand()%x;
site[var]=b;
}   //给数组中的随机序数（x以内非负整数）数字进行变异

for(var=;var<var0;var++)
{
	
	a=+rand()%;  
value[var]=a;
if(value[var]>)
value[var]=;    
}                               //给数组加一个26内的随机整数

for(var=;var<var0;var++)
{o[j][site[var]]=o[j][site[var]]+value[var];   //完成变异
if(o[j][site[var]]>)
{o[j][site[var]]=o[j][site[var]]-;}
}
}
 //for h0 结束的地方

} //for h=0 end
}//while end
end:
cout<<endl<<"制作：镜子文明（知乎ID:然兮）"<<endl;
cout<<"欢迎关注我们的微信公众号：南京大学科幻爱好者协会（账号：njusfa）"<<endl<<"究想象之灵飞，切现实之深沉。"<<endl<<endl;
system ("pause");
return ;
}
```

