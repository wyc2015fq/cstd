# 【学界】快速扩展随机树路径规划算法 - 知乎
# 

> **文章作者：**冬木远景
**责任编辑：**张帆
文章发表于**微信公众号【运筹OR帷幄】：**[【学界】快速扩展随机树路径规划算法](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/1dOFsRCuTbm6UI1Pd5MNjw)
*欢迎原链接转发，转载请私信*[@留德华叫兽](https://www.zhihu.com/people/961e8cc4f7512fda1ea6626ce9a05e8e)*获取信息，盗版必究。*
敬请关注和扩散本专栏及同名公众号，会邀请**全球知名学者**发布运筹学、人工智能中优化理论等相关干货、[知乎Live](https://www.zhihu.com/lives/users/961e8cc4f7512fda1ea6626ce9a05e8e)及行业动态：[『运筹OR帷幄』大数据人工智能时代的运筹学](https://zhuanlan.zhihu.com/operations-research)

## **0、前言**

传统的路径规划算法有人工势场法、模糊规则法、遗传算法、神经网络、模拟退火算法、蚁群优化算法等。但这些方法都需要在一个确定的空间内对障碍物进行建模，计算复杂度与机器人自由度呈指数关系，不适合解决多自由度机器人在复杂环境中的规划。基于快速扩展随机树（RRT / rapidly exploring random tree）的路径规划算法，通过对状态空间中的采样点进行碰撞检测，避免了对空间的建模，能够有效地解决高维空间和复杂约束的路径规划问题。该方法的特点是能够快速有效地搜索高维空间，通过状态空间的随机采样点，把搜索导向空白区域，从而寻找到一条从起始点到目标点的规划路径，适合解决多自由度机器人在复杂环境下和动态环境中的路径规划。与PRM类似，该方法是概率完备且不最优的。
![](https://pic2.zhimg.com/v2-32a0d5960dfdf315add2f79269180dc5_b.gif)

## **1、RRT路径规划算法**

RRT是一种多维空间中有效率的规划方法。它以一个初始点作为根节点，通过随机采样增加叶子节点的方式，生成一个随机扩展树，当随机树中的叶子节点包含了目标点或进入了目标区域，便可以在随机树中找到一条由从初始点到目标点的路径。基本RRT算法如下面伪代码所示：

```
function BuildRRT(qinit, K, Δq)
    T.init(qinit)
    for k = 1 to K
        qrand = Sample()  -- chooses a random configuration
        qnearest = Nearest(T, qrand) -- selects the node in the RRT tree that is closest to qrand
        if  Distance(qnearest, qgoal) < Threshold then
            return true
        qnew = Extend(qnearest, qrand, Δq)  -- moving from qnearest an incremental distance in the direction of qrand
        if qnew ≠ NULL then
            T.AddNode(qnew)
    return false

function Sample() -- Alternatively,one could replace Sample with SampleFree(by using a collision detection algorithm to reject samples in C_obstacle
    p = Random(0, 1.0)
    if 0 < p < Prob then
        return qgoal
    elseif Prob < p < 1.0 then
        return RandomNode()
```

初始化时随机树T只包含一个节点：根节点qinit。首先Sample函数从状态空间中随机选择一个采样点qrand（4行）；然后Nearest函数从随机树中选择一个距离qrand最近的节点qnearest（5行）；最后Extend函数通过从qnearest向qrand扩展一段距离，得到一个新的节点qnew（8行）。如果qnew与障碍物发生碰撞，则Extend函数返回空，放弃这次生长，否则将qnew加入到随机树中。重复上述步骤直到qnearest和目标点qgaol距离小于一个阈值，则代表随机树到达了目标点，算法返回成功（6~7行）。为了使算法可控，可以设定运行时间上限或搜索次数上限（3行）。如果在限制次数内无法到达目标点，则算法返回失败。

为了加快随机树到达目标点的速度，简单的改进方法是：在随机树每次的生长过程中，根据随机概率来决定qrand是目标点还是随机点。在Sample函数中设定参数Prob，每次得到一个0到1.0的随机值p，当0<p<Prob的时候，随机树朝目标点生长行；当Prob<p<1.0时，随机树朝一个随机方向生长。

上述算法的效果是随机采样点会“拉着”树向外生长，这样能更快、更有效地探索空间（The effect is that the nearly uniformly distributed samples “pull” the tree toward them, causing the tree to rapidly explore C-Space）。随机探索也讲究策略，如果我们从树中随机取一个点，然后向着随机的方向生长，那么结果是什么样的呢？见下图（Left: A tree generated by applying a uniformly-distributed random motion from a randomly chosen tree node does not explore very far. Right: A tree generated by the RRT algorithm using samples drawn randomly from a uniform distribution. Both trees have 2000 nodes ）。可以看到，同样是随机树，但是这棵树并没很好地探索空间。
![](https://pic2.zhimg.com/v2-e3e088ae9cdf7c667885034b7e132fd9_b.jpg)

## **2、Matalb实现RRT路径规划**

根据上面的伪代码，可以用MATLAB实现一个简单的RRT路径规划。输入一幅像素尺寸为500×500的地图，使用RRT算法搜索出一条无碰撞路径：

```matlab
%% RRT parameters
map=im2bw(imread('map1.bmp')); % input map read from a bmp file. for new maps write the file name here
source=[ ]; % source position in Y, X format
goal=[ ]; % goal position in Y, X format
stepsize = ;  % size of each step of the RRT
threshold = ; % nodes closer than this threshold are taken as almost the same
maxFailedAttempts = ;
display = true; % display of RRT

if ~feasiblePoint(source,map), error('source lies on an obstacle or outside map'); end
if ~feasiblePoint(goal,map), error('goal lies on an obstacle or outside map'); end
if display,imshow(map);rectangle('position',[  size(map)-],'edgecolor','k'); end

tic;  % tic-toc: Functions for Elapsed Time

RRTree = double([source -]); % RRT rooted at the source, representation node and parent index
failedAttempts = ;
counter = ;
pathFound = false;

while failedAttempts <= maxFailedAttempts  % loop to grow RRTs
　　%% chooses a random configuration
    if rand < 0.5
        sample = rand(,) .* size(map);   % random sample
    else
        sample = goal; % sample taken as goal to bias tree generation to goal
    end
	
　　%% selects the node in the RRT tree that is closest to qrand
    [A, I] = min( distanceCost(RRTree(:,:),sample) ,[],); % find the minimum value of each column
    closestNode = RRTree(I(),:);
	
　　%% moving from qnearest an incremental distance in the direction of qrand
    theta = atan2(sample()-closestNode(),sample()-closestNode());  % direction to extend sample to produce new node
    newPoint = double(int32(closestNode(:) + stepsize * [sin(theta)  cos(theta)]));
    if ~checkPath(closestNode(:), newPoint, map) % if extension of closest node in tree to the new point is feasible
        failedAttempts = failedAttempts + ;
        continue;
    end
	
    if distanceCost(newPoint,goal) < threshold, pathFound = true; break; end % goal reached
	
    [A, I2] = min( distanceCost(RRTree(:,:),newPoint) ,[],); % check if new node is not already pre-existing in the tree
    if distanceCost(newPoint,RRTree(I2(),:)) < threshold, failedAttempts = failedAttempts + ; continue; end 
	
    RRTree = [RRTree; newPoint I()]; % add node
    failedAttempts = ;
    if display, line([closestNode();newPoint()],[closestNode();newPoint()]);counter = counter + ; M(counter) = getframe; end % Capture movie frame 
end

% getframe returns a movie frame, which is a structure having two fields
if display && pathFound, line([closestNode();goal()],[closestNode();goal()]); counter = counter+;M(counter) = getframe; end

if display, disp('click/press any key'); waitforbuttonpress; end
if ~pathFound, error('no path found. maximum attempts reached'); end

%% retrieve path from parent information
path = [goal];
prev = I();
while prev > 
    path = [RRTree(prev,:); path];
    prev = RRTree(prev,);
end

pathLength = ;
for i=:length(path)-, pathLength = pathLength + distanceCost(path(i,:),path(i+,:)); end % calculate path length
fprintf('processing time=%d \nPath Length=%d \n\n', toc, pathLength); 
imshow(map);rectangle('position',[  size(map)-],'edgecolor','k');
line(path(:,),path(:,));
```

 其它M文件：

```
%% distanceCost.m
function h=distanceCost(a,b)
	h = sqrt(sum((a-b).^2, 2));
	
	
%% checkPath.m	
function feasible=checkPath(n,newPos,map)
feasible=true;
dir=atan2(newPos(1)-n(1),newPos(2)-n(2));
for r=0:0.5:sqrt(sum((n-newPos).^2))
    posCheck=n+r.*[sin(dir) cos(dir)];
    if ~(feasiblePoint(ceil(posCheck),map) && feasiblePoint(floor(posCheck),map) && ... 
            feasiblePoint([ceil(posCheck(1)) floor(posCheck(2))],map) && feasiblePoint([floor(posCheck(1)) ceil(posCheck(2))],map))
        feasible=false;break;
    end
    if ~feasiblePoint(newPos,map), feasible=false; end
end

%% feasiblePoint.m
function feasible=feasiblePoint(point,map)
feasible=true;
% check if collission-free spot and inside maps
if ~(point(1)>=1 && point(1)<=size(map,1) && point(2)>=1 && point(2)<=size(map,2) && map(point(1),point(2))==1)
    feasible=false;
end
```

![](https://pic3.zhimg.com/v2-817e71d84f0794fe39a029033d449882_b.gif)

## **3、RTT路径规划的缺陷以及改进方法**

RRT算法也有一些缺点，它是一种纯粹的随机搜索算法对环境类型不敏感，当C-空间中包含大量障碍物或狭窄通道约束时，算法的收敛速度慢，效率会大幅下降：
![](https://pic4.zhimg.com/v2-a9fb5e66753536da29886306ee9171f7_b.gif)
RRT 的一个弱点是难以在有狭窄通道的环境找到路径。因为狭窄通道面积小，被碰到的概率低。下图展示的例子是 RRT 应对一个人为制作的很短的狭窄通道，有时RRT很快就找到了出路，有时则一直被困在障碍物里面：
![](https://pic4.zhimg.com/v2-723a629bc73e99f5bc6ad3afe2bc7d43_b.gif)![](https://pic1.zhimg.com/v2-1cf0a37dd640c50494dd20686e42b828_b.gif)
上述基础RRT算法中有几处可以改进的地方：

1.how to sample from C-Space (line 4). 如何进行随机采样

2.how to define the “nearest” node in T (line 5). 如何定义“最近”点

3.how to plan the motion to make progress

toward sample (line 8). 如何进行树的扩展

Even a small change to the sampling method, for example, can yield a dramatic change in the running time of the planner. A wide variety of planners have been proposed in the literature based on these choices and other variations. 根据以上几个方向，多种RRT改进算法被提出。

**1.The Sampler **

The reason that the tree ends up covering the entire search space (in most cases) is because of the combination of the sampling strategy, and always looking to connect from the nearest point in the tree. The choice of where to place the next vertex that you will attempt to connect to is the sampling problem. In simple cases, where search is low dimensional, uniform random placement (or uniform random placement biased toward the goal) works adequately. In high dimensional problems, or when motions are very complex (when joints have positions, velocities and accelerations), or configuration is difficult to control, sampling strategies for RRTs are still an open research area.

**2.Defining the Nearest Node**

查找最近点的基础是计算C-Space中两点间的距离。计算距离最直观的方法是使用欧氏距离，但对很多C-Space来说这样做的直观意义并不明显。Finding the “nearest” node depends on a definition of distance. A natural choice for the distance between two points is simply the Euclidean distance. For other spaces, the choice is less obvious. 举个例子，如下图所示，对于一个car-like robot来说其C-space为R2×S1.  虚线框分别代表三种不同的机器人构型：第一个构型绕其旋转了20°，第二个在它后方2米处，最后一个在侧方位1米处。那么哪一种距离灰色的目标“最近”呢？汽车型机器人的运动约束导致其不能直接进行横向运动和原地转动。因此，对于这种机器人来说从第二种构型移动到目标位置“最近”。
![](https://pic3.zhimg.com/v2-2df1858ca2ab8394aeee7c15c194629a_b.jpg)
从上面的例子可以看出来，定义一个距离需要考虑以下两点：

•**combining components of different units** (e.g., degrees, meters, degrees/s,meters/s) **into a single distance measure;**

•**taking into account the motion constraints of the robot**

结合不同单位的一个简单办法是使用加权平均计算距离，不同分量的重要程度用权值大小表示（The weights express the relative importance of the different components）。寻找最近点在计算机科学和机器人学等领域中是一个非常普遍的问题，已经有各种用于加速计算的方法，比如K-d树、hash算法等。

**3.The Local Planner**

The job of the local planner is to find a motion from qnearest to some point qnew which is closer to qrand. The planner should be simple and it should run quickly. 

•A straight-line planner. The plan is a straight line to qnew, which may be chosen at qrand or at a fixed distance d from qnearest on the straight line to qrand. This is suitable for kinematic systems with no motion constraints. 

## **4、Bidirectional RRT / RRT Connect的提出**

基本的RRT每次搜索都只有从初始状态点生长的快速扩展随机树来搜索整个状态空间，如果从初始状态点和目标状态点同时生长两棵快速扩展随机树来搜索状态空间，效率会更高。为此，基于双向扩展平衡的连结型双树RRT算法，即RRT_Connect算法被提出。
![](https://pic3.zhimg.com/v2-0e0a6340dba2251512be34ae909a89fe_b.jpg)
该算法与原始RRT相比，在目标点区域建立第二棵树进行扩展。每一次迭代中，开始步骤与原始的RRT算法一样，都是采样随机点然后进行扩展。然后扩展完第一棵树的新节点𝑞𝑛𝑒𝑤后，以这个新的目标点作为第二棵树扩展的方向。同时第二棵树扩展的方式略有不同（15~22行），首先它会扩展第一步得到𝑞′𝑛𝑒𝑤，如果没有碰撞，继续往相同的方向扩展第二步，直到扩展失败或者𝑞′𝑛𝑒𝑤=𝑞𝑛𝑒𝑤表示与第一棵树相连了，即connect了，整个算法结束。当然每次迭代中必须考虑两棵树的平衡性，即两棵树的节点数的多少（也可以考虑两棵树总共花费的路径长度），交换次序选择“小”的那棵树进行扩展。这种双向的RRT技术具有良好的搜索特性，比原始RRT算法的搜索速度、搜索效率有了显著提高，被广泛应用。首先，Connect算法较之前的算法在扩展的步长上更长，使得树的生长更快；其次，两棵树不断朝向对方交替扩展，而不是采用随机扩展的方式，特别当起始位姿和目标位姿处于约束区域时，两棵树可以通过朝向对方快速扩展而逃离各自的约束区域。这种带有启发性的扩展使得树的扩展更加贪婪和明确，使得双树RRT算法较之单树RRT算法更加有效。
![](https://pic1.zhimg.com/v2-3bdd0d2853e32e31ab04f6352d9957a4_b.jpg)
RRT_Connect的matlab实现代码后台回复关键词“RTT_Connect”即可获得。
![](https://pic3.zhimg.com/v2-817e71d84f0794fe39a029033d449882_b.gif)
参考文献：

Rapidly-exploring Random Trees (RRTs)

Code for Robot Path Planning using Rapidly-exploring Random Trees

Sampling-based Algorithms for Optimal Motion Planning

基于RRT的运动规划算法综述

路径规划算法初步认识

PRM路径规划算法

V-rep学习笔记：机器人路径规划

基于Mathematica的机器人仿真环境（机械臂篇）

冯林，贾菁辉. 基于对比优化的RRT路径规划改进算法.计算机工程与应用

The open online robotics education resource

Rapidly Exploring Random Tree (RRT) Path Planning

Implementing Rapidly exploring Random Tree (RRT) OpenRave Plugin on A 7-DOF PR2 Robot Arm

Robotics Toolbox

> **文章来源申明：**原文出处：[https://www.cnblogs.com/21207-iHome/p/7210543.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/21207-iHome/p/7210543.html)
如需转载请在公众号后台获取转载须知

可以在 **本公众号后台 **回复关键词：“**RRT**”获取大量由我平台编辑精心整理的学习资料，如果觉得有用， 请勿吝啬你的留言和赞哦！~

扫二维码关注『运筹OR帷幄』公众号：
![](https://pic1.zhimg.com/v2-872dc2d2c5eaf08b38d693490549136c_b.jpg)
[点击查看『运筹OR帷幄』志愿者招募介绍及加入方式](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzUxMTYwMzI0OQ%3D%3D%26mid%3D2247486166%26idx%3D1%26sn%3Da598e1475ae4f91afb7c33114ee61a85%26chksm%3Df9706d88ce07e49ec590fc2589d251bbf2b7d605cd127b1a0bdff61b8bad985eddf42365d823%26scene%3D21%23wechat_redirect) ：
![](https://pic1.zhimg.com/v2-d1fbc7022dc62969dcf8a6afdacdfcb4_b.jpg)
[点击查看【骥寻伯乐】板块说明及投稿方式](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzUxMTYwMzI0OQ%3D%3D%26mid%3D2247486137%26idx%3D2%26sn%3D24e9487d15a8c590645a4d83950c8f20%26chksm%3Df9706de7ce07e4f1507edd01511920bd8f0a3a80384aef8ee8768b68931f872bc6cff5d3485f%26scene%3D21%23wechat_redirect) ：
![](https://pic3.zhimg.com/v2-88ba2272456e93bb2f6b9bf2d55ef1d2_b.jpg)





