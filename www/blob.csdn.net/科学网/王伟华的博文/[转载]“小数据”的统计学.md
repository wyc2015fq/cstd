# 科学网—[转载]“小数据”的统计学 - 王伟华的博文




# [转载]“小数据”的统计学                           

已有 2236 次阅读2015-10-22 23:52|个人分类:[计算机&大数据](http://blog.sciencenet.cn/home.php?mod=space&uid=81613&do=blog&classid=11842&view=me)|系统分类:[科普集锦](http://blog.sciencenet.cn/home.php?mod=space&do=blog&view=all&uid=81613&catid=7)|文章来源:转载



“小数据”的统计学

**一、小数据来自哪里？**

科技公司的数据科学、关联性分析以及机器学习等方面的活动大多围绕着”大数据”，这些大型数据集包含文档、用户、文件、查询、歌曲、图片等信息，规模数以千计，数十万、数百万、甚至数十亿。过去十年里，处理这类型数据集的基础设施、工具和算法发展得非常迅速，并且得到了不断改善。大多数数据科学家和机器学习从业人员就是在这样的情况下积累了经验，逐渐习惯于那些用着顺手的算法，而且在那些常见的需要权衡的问题上面拥有良好的直觉（经常需要权衡的问题包括：偏差和方差，灵活性和稳定性，手工特性提取和特征学习等等)。但小的数据集仍然时不时的出现，而且伴随的问题往往难以处理，需要一组不同的算法和不同的技能。小数据集出现在以下几种情况:

·**企业解决方案****:**当您尝试为一个人员数量相对有限的企业提供解决方案，而不是为成千上万的用户提供单一的解决方案。

·**时间序列****:**时间供不应求!尤其是和用户、查询指令、会话、文件等相比较。这显然取决于时间单位或采样率，但是想每次都能有效地增加采样率没那么容易，比如你得到的标定数据是日期的话，那么你每天只有一个数据点。

·**关于以下样本的聚类模型**：州市、国家、运动队或任何总体本身是有限的情况(或者采样真的很贵)。【备注：比如对美国50个州做聚类】

·**多变量****A/B ****测试****:**实验方法或者它们的组合会成为数据点。如果你正在考虑3个维度，每个维度设置4个配置项，那么将拥有12个点。【备注：比如在网页测试中，选择字体颜色、字体大小、字体类型三个维度，然后有四种颜色、四个字号、四个字型】

·**任何罕见现象的模型**，例如地震、洪水。



**二、小数据问题**

小数据问题很多，但主要围绕高方差:

·很难避免过度拟合

·你不只过度拟合训练数据，有时还过度拟合验证数据。

·离群值（异常点）变得更危险。

·通常，噪声是个现实问题，存在于目标变量中或在一些特征中。

**三、如何处理以下情况**

**1-****雇一个统计学家**

我不是在开玩笑！统计学家是原始的数据科学家。当数据更难获取时统计学诞生了，因而统计学家非常清楚如何处理小样本问题。统计检验、参数模型、自举法（Bootstrapping，一种重复抽样技术），和其他有用的数学工具属于经典统计的范畴，而不是现代机器学习。如果没有好的专业统计员，您可以雇一个海洋生物学家、动物学家、心理学家或任何一个接受过小样本处理训练的人。当然，他们的专业履历越接近您的领域越好。如果您不想雇一个全职统计员，那么可以请临时顾问。但雇一个科班出身的统计学家可能是非常好的投资。

**2-****坚持简单模型**

更确切地说: 坚持一组有限的假设。预测建模可以看成一个搜索问题。从初始的一批可能模型中，选出那个最适合我们数据的模型。在某种程度上，每一个我们用来拟合的点会投票，给不倾向于产生这个点的模型投反对票，给倾向于产生这个点的模型投赞成票。当你有一大堆数据时，你能有效地在一大堆模型/假设中搜寻，最终找到适合的那个。当你一开始没有那么多的数据点时，你需要从一套相当小的可能的假设开始 (例如，含有 3个非零权重的线性模型，深度小于4的决策树模型，含有十个等间隔容器的直方图)。这意味着你排除复杂的设想，比如说那些非线性或特征之间相互作用的问题。这也意味着，你不能用太多自由度 (太多的权重或参数)拟合模型。适当时，请使用强假设 (例如，非负权重，没有交互作用的特征，特定分布等等) 来缩小可能的假设的范围。

![](http://image.sciencenet.cn/album/201510/22/234903sbo51js5zr237ii1.jpg)

任何疯狂的模型都能拟合单点。

![](http://image.sciencenet.cn/album/201510/22/234904mxx51quttsinztjh.jpg)

当我们有更多的数据点时，越来越少的模型可以拟合这些点。

![](http://image.sciencenet.cn/album/201510/22/2349043o5o2rsj7uk5omrs.jpg)

图像来自Chris Bishop的书《模式识别和机器学习》



**3-****尽可能使用更多的数据**

您想构建一个个性化的垃圾邮件过滤器吗?尝试构建在一个通用模型，并为所有用户训练这个模型。你正在为某一个国家的GDP建模吗?尝试用你的模型去拟合所有能得到数据的国家，或许可以用重要性抽样来强调你感兴趣的国家。你试图预测特定的火山爆发吗?……你应该知道如何做了。

**4-****做试验要克制**

不要过分使用验证集。如果你尝试过许多不同的技术，并使用一个保留数据集来对比它们，那么你应该清楚这些结果的统计效力如何，而且要意识到对于样本以外的数据它可能不是一个好的模型。

**5-****清洗您的数据**

处理小数据集时，噪声和异常点都特别烦人。为了得到更好的模型，清洗您的数据可能是至关重要的。或者您可以使用鲁棒性更好的模型，尤其针对异常点。(例如分位数回归)

**6-****进行特征选择**

我不是显式特征选择的超级粉丝。我通常选择用正则化和模型平均 (下面会展开讲述)来防止过度拟合。但是，如果数据真的很少，有时显式特征选择至关重要。可以的话，最好借助某一领域的专业知识来做特征选择或删减，因为穷举法 (例如所有子集或贪婪前向选择) 一样容易造成过度拟合。

**7-****使用正则化**

对于防止模型过拟合，且在不降低模型中参数实际数目的前提下减少有效自由度，正则化几乎是神奇的解决办法。L1正则化用较少的非零参数构建模型，有效地执行隐式特征选择。而 L2 正则化用更保守 (接近零) 的参数，相当于有效的得到了强零中心的先验参数 (贝叶斯理论)。通常，L2 拥有比L1更好的预测精度。【备注：L2正则化的效果使权重衰减，人们普遍认为：更小的权值从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好，这个法则也叫做奥卡姆剃刀。】

![](http://image.sciencenet.cn/album/201510/22/234905kmamhgahxhyxw8k6.jpg) L1正则化可以使得大多数参数变为零



**8 ****使用模型平均**

模型平均拥有类似正则化的效果，它减少方差，提高泛化，但它是一个通用的技术，可以在任何类型的模型上甚至在异构模型的集合上使用。缺点是，为了做模型平均，结果要处理一堆模型，模型的评估变得很慢。bagging和贝叶斯模型平均是两个好用的模型平均方法。

![](http://image.sciencenet.cn/album/201510/22/234905foaufvo2f4gfoog4.jpg)每条红线是一个拟合模型。

![](http://image.sciencenet.cn/album/201510/22/2349584r35t3thpwnl2whs.jpg)

平均这些高方差模型之后，我们得到一个平滑的曲线，它很好的拟合了原有数据点的分布。

**9-****尝试贝叶斯建模和模型平均**

这个依然不是我喜欢的技术，但贝叶斯推理可能适合于处理较小的数据集，尤其是当你能够使用专业知识构造好的先验参数时。

**10-****喜欢用置信区间**

通常，除了构建一个预测模型之外，估计这个模型的置信是个好主意。对于回归分析，它通常是一个以点估计值为中心的取值范围，真实值以95%的置信水平落在这个区间里。如果是分类模型的话，那么涉及的将是分类的概率。这种估计对于小数据集更加重要，因为很有可能模型的某些特征相比其它特征没有更好的表达出来。如上所述的模型平均允许我们很容易得到在回归、分类和密度估计中做置信的一般方法。当评估您的模型时它也很有用。使用置信区间评估模型性能将助于你避免得出很多错误的结论。

![](http://image.sciencenet.cn/album/201510/22/234959egi32ti24gw2ijy2.jpg)

你的数据不乐意出现在特征空间的某些区域，那么预测置信应该有所反应。

![](http://image.sciencenet.cn/album/201510/22/235000kkkgpaecjck3panv.jpg)

用ROCR得到的自举法性能图。



**四、总结**



上面讲的有点多，但他们都围绕着三个主题：约束建模，平滑和量化不确定性。这篇文章中所使用的图片来自Christopher Bishop的书《模式识别和机器学习》

以上内容翻译自What to do with “small” data?

**附录：翻译笔记：**



**一、用语**



**1****、****every now and then****和****now andthen ****有什么区别？**



根据<<美国传统词典[双解]>>的解释：

1。every now and then 或 every now and again：

（1）From time to time; occasionally.

不时地，时常地；偶尔地

（2） every once in a while

From time to time;occasionally.

不时地；偶尔地

2。now and then 或 now and again

（1）Occasionally. 偶尔地

这二个词组基本上是相等的，也可以认为，**now andthen****。事件发生的频率要低一些。****everynow and then ****。事件发生的频率要稍高一些。**



**2****、****Document****和****file**

document是文档，file是文件。file涵盖的范围更大，图像、音频、视频之类都可以叫file，而document主要指文本文档。

**3****、****trade-off**

权衡，文中提到几个变量对，偏方和方差，灵活性和稳定性，手工特征提取和自动化特征提取。需要在两方面之间取得平衡，不能只偏向一方。

**4****、****country, nation, state**

三者都可译为“国家”，但含义不同。

·country 指国家时，侧重疆土或人口，又作“乡下”讲。

如：Chinais a socialist country. 中国是一个社会主义国家。

·nation指国家时，侧重民族。

如： The whole nation is /are rejoicing. 举国欢腾。

·state 指国家时，侧重政体、政府，也可指组成国家的“州”。

如：Franceis one of the member states of the ELL. 法国是欧洲联盟成员国之一。

**5****、****population**



Aggregate modeling ofstates, countries, sports teams, or any situation where the population itselfis limited (or sampling is really expensive).这里是总体，而不是人口。



**6****、****general-purpose**



多用途，多功能，通用的



**7****、****in away in the way on the way on a way by the way**



in a way 在某种程度上，在某种意义上 in the way 挡路，挡道，碍事 eg.get in the way of妨碍某人做某事 on the way 在途中，即将到达有点类似于around the corner on away 不存在 by the way 顺便说一下，做插入语而by the way of 借由某种方式做

**二、****Bias****和****Variance****：****1****、概念理解**



在A Few Useful Things to Know about Machine Learning中提到，可以将泛化误差（generalization error）分解成bias和variance理解。

·Bias: a learner’s tendency to consistently learn the same wrongthing，即度量了某种学习算法的平均估计结果所能逼近学习目标(目标输出)的程度。

·Variance：the tendency to learn random thingsirrespective of the real signal，即度量了在面对同样规模的不同训练集时，学习算法的估计结果发生变动的程度。比如在同一现象所产生的不同训练数据上学习的决策树往往差异巨大，而实际上它们应当是相同的。



从图像角度
![](http://image.sciencenet.cn/album/201510/22/235000qm6daidj6z25g7jv.jpg)

靶心为某个能完美预测的模型，离靶心越远，则准确率随之降低。靶上的点代表某次对某个数据集上学习某个模型。纵向上，高低的bias：高的Bias表示离目标较远，低bias表示离靶心越近；横向上，高低的variance，高的variance表示多次的“学习过程”越分散，反之越集中。

![](http://image.sciencenet.cn/album/201510/22/235037p37uy02ay7az0rv2.jpg)**3****、****Bias****、****variance****与复杂度的关系**

![](http://image.sciencenet.cn/album/201510/22/235038irbe6vzs966jzriu.jpg)

![](http://image.sciencenet.cn/album/201510/22/235038x1cd0r1ormc4ozxx.jpg)

**三、****hand-crafted features vs. feature learning**



以个性化推荐系统中的特征工程进行简单说明:



特征工程：用目标问题所在的特定领域知识或者自动化的方法来生成、提取、删减或者组合变化得到特征。这些特征可能是显而易见比如说商品的品牌，也有可能需要复杂的模型计算，比如Facebook上用户A和用户B之间关系的紧密程度（FB使用了一个决策树来生成一个描述这个程度的向量，这个向量决定了他们News Feed推荐内容。）



**1****、利用领域知识生成和提取特征**



这几乎是特征工程里占大半时间的工作了：如何描述个性化并且用变量表示成特征。一般方法就是，想想你就是该商品的目标用户，你会想要什么样的个性化。



**2****、直接特征和间接特征**



直接特征 Extacted Feature 就是比如商品的品牌，间接特征 Derived Feature 可以是从直接特征或者各种数据组合里计算推导出来的。



**3****、特征选择**



这部分的工作就看起来比较高级一些，比较贴近机器学习的研究工作。一般来说是两个方法：基于领域知识的手工选择以及自动选择方法。



对于关联规则和统计规则的模型来说，手工选择的比重要大一些。比如我们已有了baseline的特征向量，现在加进去品牌偏好，给一定的权值，看评价函数输出的结果是否增强了推荐效果。



对于学习的模型来说，可以通过模型自动选择每个特征的权值，按照和效果的关联来调整模型的参数。



**四、多变量测试和****AB****测试**



1、A / B 测试:



A/B测试本质上是个分离式组间实验，以前进行A/B测试的技术成本和资源成本相对较高，但现在一系列专业的可视化实验工具的出现，A/B测试已越来越成为网站优化常用的方法。



使用A/B 测试首先需要建立一个测试页面（variation page），这个页面可能在标题字体，背景颜色，措辞等方面与原有页面（control page）有所不同，然后将这两个页面以随机的方式同时推送给所有浏览用户。接下来分别统计两个页面的用户转化率，即可清晰的了解到两种设计的优劣。



2、多变量测试



多变量(Multivariate)测试，是从A/B测试延伸出来的概念。A/B测试中，你需要创建多个页面来进行转化率测试，而多变量测试则是利用“模块化”的思维方法——你的页面（被划分成多个模块）在测试时不需要额外做多个版本，而是直接动态地分配页面的这些模块，让不同的页面模块组合显示给不同的访问者。这样，就能通过一些相对复杂的数学工具来研究页面各部分之间的关系和相互作用，而不仅仅只是哪个页面的版本更有用。



**五、****bootstrap-****自举法**



所谓的Bootstrapping法就是利用有限的样本资料经由多次重复抽样，重新建立起足以代表母体样本分布之新样本。



对于一个采样，我们只能计算出某个统计量(例如均值)的一个取值，无法知道均值统计量的分布情况。但是通过自助法(自举法)我们可以模拟出均值统计量的近似分布。有了分布很多事情就可以做了（比如说有你推出的结果来进而推测实际总体的情况）。



bootstrapping方法的实现很简单，假设你抽取的样本大小为n:



在原样本中有放回的抽样，抽取n次。每抽一次形成一个新的样本，重复操作，形成很多新样本，通过这些样本就可以计算出样本的一个分布。新样本的数量多少合适呢？大概1000就差不多行了，如果计算成本很小，或者对精度要求比较高，就增加新样本的数量。



最后这种方法的准确性和什么有关呢？这个我还不是清楚，猜测是和原样本的大小n，和Bootstrapping产生的新样本的数量有关系，越大的话越是精确，更详细的就不清楚了，想知道话做个搞几个已知的分布做做实验应该就清楚了。



**六、直方图的****bin**



“hist” is short for“Histogram(直方图、柱状图)”。



**1.N= hist(Y)**



bins the elements of Yinto 10 equally spaced containers and returns the number of elements in eachcontainer. If Y is a matrix, hist works down the columns.



（将向量Y的元素平均分到十个等间隔的容器中，并且返回每个容器的元素个数。如果Y是一个矩阵，hist指令逐列元素操作。Y为向量的情形见例1和2，为矩阵的情形见例3.）



**例****1.**执行指令

>> Y = [1:10];
>> hist(Y)

得到

![](http://image.sciencenet.cn/album/201510/22/2350388qulz0q0af28s8qf.jpg)

10个蓝色方条，每个方条对应一个容器，其长度代表容器中数据的多少。由图知，容器中的数据量均为1。这个例子不够典型，见例2.



**例****2.**执行指令



>> Y = [1, 2, 2,5, 6, 6, 8, 11];
>> hist(Y)



得到

![](http://image.sciencenet.cn/album/201510/22/235039k0nu96akffik9akg.jpg)

Y最大为11，最小为1，故而将区间[1,11]均分为10分，分别为[1, 2], (2,3], (3,4], (4,5], (5,6],(6,7], (7,8], (8,9], (9,10], (10,11].



**七、正则化方法：****L1****和****L2 regularization****、数据集扩增、****dropout**



时间：2015-03-14 18:32:59



标签：机器学习正则化过拟合



本文是《Neural networks and deep learning》概览中第三章的一部分，讲机器学习/深度学习算法中常用的正则化方法。



**1****、正则化方法：防止过拟合，提高泛化能力**

在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合）。其直观的表现如下图所示，随着训练过程，网络在training data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集，对训练集外的数据却不work。

![](http://image.sciencenet.cn/album/201510/22/235117jkbjzyvsbsi576z5.jpg)

为了防止overfitting，可以用的方法有很多，下文就将以此展开。有一个概念需要先说明，在机器学习算法中，我们常常将原始数据集分为三部分：training data、validation data，testing data。这个validation data是什么？它其实就是用来避免过拟合的，在训练过程中，我们通常用它来确定一些超参数（比如根据validation data上的accuracy来确定early stopping的epoch大小、根据validation data确定learning rate等等）。



那为啥不直接在testing data上做这些呢？因为如果在testing data做这些，那么随着训练的进行，我们的网络实际上就是在一点一点地overfitting我们的testing data，导致最后得到的testing accuracy没有任何参考意义。因此，training data的作用是计算梯度更新权重，validation data如上所述，testing data则给出一个accuracy以判断网络的好坏。



避免过拟合的方法有很多：early stopping、数据集扩增（Data augmentation）、正则化（Regularization）包括L1、L2（L2 regularization也叫weight decay），dropout。



**2****、****L2 regularization****（权重衰减）**



L2正则化就是在代价函数后面再加上一个正则化项：

![](http://image.sciencenet.cn/album/201510/22/2351173l0ezljec0g2jj00.jpg)

C0代表原始的代价函数，后面那一项就是L2正则化项，它是这样来的：所有参数w的平方的和，除以训练集的样本大小n。λ就是正则项系数，权衡正则项与C0项的比重。另外还有一个系数1/2，1/2经常会看到，主要是为了后面求导的结果方便，后面那一项求导会产生一个2，与1/2相乘刚好凑整。



L2正则化项是怎么避免overfitting的呢？我们推导一下看看，先求导：

![](http://image.sciencenet.cn/album/201510/22/235117dp7gww55xdd7wxll.jpg)

可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响:

![](http://image.sciencenet.cn/album/201510/22/235118z9wxj32wg0ew1919.jpg)

在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为 1-ηλ/n ，因为η、λ、n都是正的，所以 1-ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。



另外，需要提一下，对于基于mini-batch的随机梯度下降，w和b更新的公式跟上面给出的有点不同：

![](http://image.sciencenet.cn/album/201510/22/235118eojvy7zo4m4gdggg.jpg)

对比上面w的更新公式，可以发现后面那一项变了，变成所有导数加和，乘以η再除以m，m是一个mini-batch中样本的个数。



到目前为止，我们只是解释了L2正则化项有让w“变小”的效果，但是还没解释为什么w“变小”可以防止overfitting？人们普遍认为：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好（这个法则也叫做奥卡姆剃刀）。而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。



**3****、****L1 regularization**



在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n（这里不像L2正则化项那样，需要再乘以1/2，具体原因上面已经说过。）

![](http://image.sciencenet.cn/album/201510/22/2351454ll4o456zml3laol.jpg)

同样先计算导数：

![](http://image.sciencenet.cn/album/201510/22/23514580g878bjzjx0bbzq.jpg)

上式中sgn(w)表示w的符号。那么权重w的更新规则为：

![](http://image.sciencenet.cn/album/201510/22/235146m919h9im2h4z6sww.jpg)

比原始的更新规则多出了η * λ *sgn(w)/n这一项。当w为正时，更新后的w变小。当w为负时，更新后的w变大——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。



另外，上面没有提到一个问题，当w为0时怎么办？当w等于0时，|W|是不可导的，所以我们只能按照原始的未经正则化的方法去更新w，这就相当于去掉η*λ*sgn(w)/n这一项，所以我们可以规定sgn(0)=0，这样就把w=0的情况也统一进来了。（在编程的时候，令sgn(0)=0,sgn(w>0)=1,sgn(w<0)=-1）



**4****、****Dropout**



L1、L2正则化是通过修改代价函数来实现的，而Dropout则是通过修改神经网络本身来实现的，它是在训练网络时用的一种技巧（trike）。它的流程如下：

![](http://image.sciencenet.cn/album/201510/22/235146i66115u0i46006ih.jpg)

假设我们要训练上图这个网络，在训练开始时，我们随机地“删除”一半的隐层单元，视它们为不存在，得到如下的网络：

![](http://image.sciencenet.cn/album/201510/22/2351467ao63wwm23baqh6z.gif)

保持输入输出层不变，按照BP算法更新上图神经网络中的权值（虚线连接的单元不更新，因为它们被“临时删除”了）。



以上就是一次迭代的过程，在第二次迭代中，也用同样的方法，只不过这次删除的那一半隐层单元，跟上一次删除掉的肯定是不一样的，因为我们每一次迭代都是“随机”地去删掉一半。第三次、第四次……都是这样，直至训练结束。



以上就是Dropout，它为什么有助于防止过拟合呢？可以简单地这样解释，运用了dropout的训练过程，相当于训练了很多个只有半数隐层单元的神经网络（后面简称为“半数网络”），每一个这样的半数网络，都可以给出一个分类结果，这些结果有的是正确的，有的是错误的。随着训练的进行，大部分半数网络都可以给出正确的分类结果，那么少数的错误分类结果就不会对最终结果造成大的影响。



更加深入地理解，可以看看Hinton和Alex两牛2012的论文《ImageNet Classification with Deep Convolutional Neural Networks》



**5****、数据集扩增（****data augmentation****）**



“有时候不是因为算法好赢了，而是因为拥有更多的数据才赢了。”



不记得原话是哪位大牛说的了，hinton？从中可见训练数据有多么重要，特别是在深度学习方法中，更多的训练数据，意味着可以用更深的网络，训练出更好的模型。



既然这样，收集更多的数据不就行啦？如果能够收集更多可以用的数据，当然好。但是很多时候，收集更多的数据意味着需要耗费更多的人力物力，有弄过人工标注的同学就知道，效率特别低，简直是粗活。



所以，可以在原始数据上做些改动，得到更多的数据，以图片数据集举例，可以做各种变换，如：



将原始图片旋转一个小角度



添加随机噪声



一些有弹性的畸变（elastic distortions），论文《Best practices forconvolutional neural networks applied to visual document analysis》对MNIST做了各种变种扩增。



截取（crop）原始图片的一部分。比如DeepID中，从一副人脸图中，截取出了100个小patch作为训练数据，极大地增加了数据集。感兴趣的可以看《Deep learning facerepresentation from predicting 10,000 classes》.



*更多数据意味着什么？*



用50000个MNIST的样本训练SVM得出的accuracy94.48%，用5000个MNIST的样本训练NN得出accuracy为93.24%，所以更多的数据可以使算法表现得更好。在机器学习中，算法本身并不能决出胜负，不能武断地说这些算法谁优谁劣，因为数据对算法性能的影响很大。

![](http://image.sciencenet.cn/album/201510/22/235215xpps83zgsxsxgs11.jpg)

**八、****boosting****和****bagging**



Bagging 和 Boosting 都是一种将几个弱分类器（可以理解为分类或者回归能力不好的分类器）按照一定规则组合在一起从而变成一个强分类器。但二者的组合方式有所区别。



一、Bagging



Bagging的思想很简单，我选取一堆弱分类器用于分类，然后最终结果投票决定，哪个票数多就属于哪一类。不过Bagging的一个重要步骤就是在训练每一个弱分类器的时候不是用整个样本来做分类，而是在样本中随机抽取一系列的样本集，可以重复也可以数目少于原样本，这就是Bootstraping。Bagging的思想简单，应用很广泛，最出名的应用就是Random Forest。



二、Boosting



Booting的思想与Bagging有所不同。第一个不同，在输入样本的选取上，Bagging是随机抽取样本，而Boosting则是按照前一个分类器的错误率来抽取样本。



好比前一个分类器在样本A,B,F上出错了，那么我们会提升抽取这三个样本的概率来帮助我们训练分类器。第二个不同，在弱分类器组合上，Bagging就是投票就好啦，但是Boosting确实不是这样，Boosting主要是将分类器线性组合起来，以为着分类器前面带着个权重，错误率高的分类器的权重会低一些，正确率高的则高一些，这样线性组合起来就是最终的结果。当然也有非线性组合的权重，但在这里就不赘述了。



Boosting最出名的应用就是Gradient Boosting Decision Tree，我们会在一篇文章中介绍。

![](http://image.sciencenet.cn/album/201510/22/235216j0j3qaq4b3zc8436.jpg)

![](http://image.sciencenet.cn/album/201510/22/235217cjc1owl5vvcjenoc.jpg)

End.







转载本文请联系原作者获取授权，同时请注明本文来自王伟华科学网博客。
链接地址：[http://blog.sciencenet.cn/blog-81613-930209.html](http://blog.sciencenet.cn/blog-81613-930209.html)

上一篇：[[转载]吴国平:数学的魅力——苹果LOGO背后的数学秘密](blog-81613-928309.html)
下一篇：[[转载]学习R语言超强资源](blog-81613-930212.html)


