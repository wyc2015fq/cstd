# c的头文件和源文件静态动态链接_用户5706034127_新浪博客
|||
#include
仅仅是将.h文件添加到c源文件中，所以，不能有定义的部分，否则会被重复定义。
c中声明外部定义的变量，就得extern来声明，标识，。
1.如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编
译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定
义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错 
2.如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此
头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个
相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入
BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间 
3.如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相
应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成
了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一
下头文件就行了 
4.在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库，让别人来用你的代码，你又不想公布源码，那么人家如何利
用你的库呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的函数原型，这
样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家的头文件中的相关声明
啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用
#ifndef CIRCLE_H
#define CIRCLE_H
//你的代码写在这里
#endif
这样做是为了防止重复编译，不这样做就有可能出错。
至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。
=======================================================================
#include包含头文件，中的.h文件路径设置，
需要注意的是，新的vs，建立的是过滤器，而不是文件夹，只是一个视图，而不是真正的文件夹。所以，你包含头文件的时候，不用考虑路径问题，，所以你文件命名的时候，会出现冲突问题。
假设我们有如下一个工程，其中包含了几个源代码文件和头文件。其中main.c是主源代码文件，里面包含main函数。
[](http://photo.blog.sina.com.cn/showpic.html#blogid=6e0693f70100so42&url=http://s4.sinaimg.cn/orignal/6e0693f7ga5df6a7eaad3)![](http://my.csdn.net/uploads/201208/04/1344036597_5069.png)
在base中包含：func3.h，func3.c，文件夹main和文件夹func4
在main中包含：main.c，func1.h，func1.c和文件夹func2。
在func2中包含：func2.h和func2.c
在func4中包含：func4.h和func4.c
在main中包含头文件func1.h：#include 
"func1.h"
这里main.c和func1.h在同一个文件下。
在main中包含头文件func2.h：#include 
"func2\func2.h"
这里main.c和func2.h不在在同一个文件下，但文件夹func2和main.c同级。"func2\func2.h"表示main.c这一级func2文件夹下的func2.h头文件。
在main中包含头文件func3.h：#include 
"..\func3.h"
这里main.c和func3.h不在在同一个文件下，但文件夹main和func3.h同级。"..\func3.h"表示main.c上一级文件（base）夹下的func3.h头文件。
在main中使用func4.h：#include 
"..\func4\func4.h"
这里main.c和func4.h不在在同一个文件下，但文件夹main和文件夹func4同级。"..\func4\func4.h"表示main.c上一级文件夹（base）下的func4文件夹下的func4.h头文件。
==================================================================
静态链接和动态链接
程序的静态连接还是动态连接是根据编译器的连接参数指定的。
所谓静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。（所谓库就是一些功能代码经过编译连接后的可执行形式。）
所谓动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。
windows:
在windows上大家都是DLL是动态链接库，里面是一系列可执行的代码，开发过windows程序的人可能还知道有另外一种形式的库，就是LIB，大家可能普遍认为LIB就是静态库，至少我之前是这么认为的，但是在实际的开发过程中，纠正了我这个错误的想法。LIB形式的文件可能会有两种形式，这里并不排除第三种形式。1：包括符号表和二进制可执行代码，也就是传统意义上理解的静态库，可以被静态连接。2：只有符号表，也就是只有动态库的符号导出信息，通过这些信息可以在程序运行时定位到动态库中，最终实现动态连接。
linux:
在linux上大家也都知道SO是动态库，类似于windows下的DLL，实现方式也是大同小异，同时开发过linux下程序的人也都知道另外一种形式的库就是A库，同样道理普遍认为是和SO对立的，也就是静态库，不然没道理存在啊，呵呵。但是事实区却不是如此，A文件的作用和windows下的LIB文件作用几乎一样，也可能会有两种形式，和windows下的lib文件一样，在此就不在赘述。
