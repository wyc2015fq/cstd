# Skywind Inside » 如何写一个视频编码器演示篇
## 如何写一个视频编码器演示篇
December 24th, 2015[skywind](http://www.skywind.me/blog/archives/author/skywind)[Leave a comment](#respond)[Go to comments](#comments)
先前写过《[视频编码原理简介](http://www.skywind.me/blog/archives/1566)》，有朋友问光代码和文字不太真切，能否补充几张图片，今天我们演示一下：
这是第一帧画面：P1（我们的参考帧）
![output1](http://www.skywind.me/blog/wp-content/uploads/2015/12/output1_thumb.png)
这是第二帧画面：P2（需要编码的帧）
![output2](http://www.skywind.me/blog/wp-content/uploads/2015/12/output2_thumb.jpg)
从视频中截取的两张间隔1-2秒的画面，和实际情况类似，下面我们参考P1进行几次运动搜索：
搜索演示1：搜索P2中车辆的车牌在P1中最接近的位置（上图P1，下图P2）
![search1](http://www.skywind.me/blog/wp-content/uploads/2015/12/search1_thumb.jpg)
这是一个演示程序，鼠标选中P2上任意16×16的Block，即可搜索出P1上的 BestMatch 宏块。虽然车辆在运动，从远到近，但是依然找到了最接近的宏块坐标。
（点击 more 阅读剩下内容）
搜索演示2：空中电线交叉位置（上图P1，下图P2）
![search2](http://www.skywind.me/blog/wp-content/uploads/2015/12/search2_thumb.jpg)
搜索演示3：报刊停的广告海报
![search3](http://www.skywind.me/blog/wp-content/uploads/2015/12/search3_thumb.jpg)
同样顺利在P1中找到最接近P2里海报的宏块位置。
图片全搜索：根据P1和运动矢量数据（在P2中搜索到每一个宏块在P1中最相似的位置集合）还原出来的P2’，即完全用P1各个位置的宏块拼凑出来最像P2的图片P2’，效果如下：
![output3](http://www.skywind.me/blog/wp-content/uploads/2015/12/output3_thumb.png)
仔细观察，有些支离破碎对吧？肯定啊，拼凑出来的东西就是这样，现在我们用P2`和P2像素相减，得到差分图 D2 = (P2′ – P2) / 2 + 0x80：
![output4](http://www.skywind.me/blog/wp-content/uploads/2015/12/output4_thumb.png)
嗯，这就是P2`和P2两幅图片的不同处，看到没？基本只有低频了！高频数据少到我们可以忽略，这时用有损压缩方式比较差的效果来保存误差图D2，只要5KB的大小。
接着我们根据运动矢量还原的P2’以及差分图D2来还原新的 P2，NewP2 = P2′ + （D2 – 0x80）* 2：
![output5](http://www.skywind.me/blog/wp-content/uploads/2015/12/output5_thumb.png)
这就是之前支离破碎的 P2` 加上误差 D2后变成了清晰可见的样子，基本还原了原图P2。
由于D2仅仅占5KB，加上压缩过后的运动矢量不过7KB，所以参考P1我们只需要额外 7KB的数据量就可以完整表示P2了，而如果独立将P2用质量尚可的有损压缩方式独立压缩，则至少要去到50-60KB，这一下节省了差不多8倍的空间，这就是所谓运动编码的基本原理。
实际在使用中，参考帧并不一定是前面一帧，也不一定是同一个GOP的I帧，因为GOP间隔较长时，后面的图片离I帧变化可能已经很大了，因此常见做法是最近15帧中选择一帧误差最小的作为参考帧，虽然彩色画面有YUV三个分量，但是大量的预测工作和最有选择通常是根据Y分量的灰度帧进行判断的。
再者误差我们保存的是（P2-P2’）/2 + 0x80，实际使用时我们会用更有效率的方式，比如让[-64,64]之间的色差精度为1，[-255,-64], [64, 255] 之间的色差精度为2-3，这样会更加真实一些。
同时上文很多地方用的是直接lzma2进行简单存储，实际使用时一般会引入熵编码，对数据进行一定层次的整理然后再压缩，性能会好不少。
现代视频编码中，除了帧间预测，I帧还使用了大量帧内预测，而不是完全dct量化后编码，前面帧间预测我们使用了参考帧的宏块移动拼凑新帧的方式进行，而所谓帧内预测就是同一幅画面中，未编码部分使用已编码部分拼凑而成。。。。。。。
这些说来话就长了，不过此时相信各位理解起 MPEG2 来会发现并不是什么太深奥的东西，MPEG2的各项规范熟悉了，H264也就好说了，读资料的同时自己做一下试验参照理论，应该能轻松很多。
