# 机房重构——泛型使用详解 - Big Smile - CSDN博客
2016年01月29日 17:00:53[王啸tr1912](https://me.csdn.net/tr1912)阅读数：1596
所属专栏：[机房重构系列](https://blog.csdn.net/column/details/14105.html)

为什么要提到泛型呢，那是在看了很多重构完机房的人们的普遍的反应中体现出来的就是泛型比较好，dataTable比较抽象化了，一个虚拟的表，用它的人得知道数据库的布局才能了解dataTable中的数据结构，而泛型就不需要，我认为他就是容器和实体类的一个集合，中间的许多操作其实都是用的实体的东西，这个容器只是起到的转化的作用。下面来详细的描述一下泛型的用法。
# **一、了解泛型**
        什么是泛型呢？首先来看他的构成大纲<List(OF T)>      这也就是周洲师姐所说的T是什么的T的来源，T就是一个要引用的类型，或者是对象，而泛型最大的特点是什么呢？就是可以允许类型或者对象带着参数，这也就是我们的实体层里面的实体了，反观我们的7层的包图，会发现，每一层传递的都是实体，实际上泛型传递的也是实体，是包含的实体对象的容器，所以用泛型很好的保证了七层的结构，而用dataTable呢，如果传的数据是dataTable的话，就会破坏掉了七层的意思，回传的数据不是实体，而是DataTable表了，具体流程如图：
![](https://img-blog.csdn.net/20160129163639964?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
既然泛型那么好，我们又该如何使用呢？
# 二、使用方法
***1、声明泛型***
        泛型的声明方法其实很简单，具体就是在OF 后面加上实体类，具体如：
` Dim mylist As New List(Of Model.Work_Log_Info)`***2、使用泛型***
        在使用泛型之前，我们要先了解泛型是怎么通过数据查询语句来获取数据的。其实这个里面也用到了dataTable，只不过是一个转换的作用，如下代码：
```
Dim mylist As New List(Of Model.Work_Log_Info)       '声明泛型类
      Dim dt As New DataTable                              '声明一个DataTable表
      dt = SQLHelper.ExecDataTable(cmdText, CommandType.Text, paras)        '查询数据给DataTable
      mylist = ConvertHelper.ConvertHelper.convertToList(Of Model.Work_Log_Info)(dt)   '把dt转化为泛型
      Return mylist            '返回泛型
```
其他的东西都是一样的，只是多了一个转换，这个转换就是要用到的ConvertHelper这个类，具体在vb.net中声明为了模块：
```
Imports System.Reflection       '引用反射
Module ConvertHelper
    Public Class ConvertHelper
        '将datatable 转化为泛型集合
        Public Shared Function convertToList(Of Turn As {New})(ByVal dt As DataTable) As IList(Of Turn)
            '这里的new是用来约束T的
            Dim mylist As New List(Of Turn)             '定义最终返回的集合
            Dim myType As Type = GetType(Turn)          '得到实体类的类型名
            Dim dr As DataRow                           '定义行集
            Dim tempName As String = String.Empty       '定义一个临时变量
            '遍历DataTable的所有数据行
            For Each dr In dt.Rows
                Dim myTurn As New Turn
                Dim propertys() As PropertyInfo = myTurn.GetType().GetProperties()  '定义属性集合           
                Dim pr As PropertyInfo
                '遍历该对象的所有属性
                For Each pr In propertys
                    tempName = pr.Name   '将属性名称赋值给临时变量
                    If (dt.Columns.Contains(tempName)) Then   '将此属性与datatable 里的列名比较，查看datatable是否包含此属性
                        '判断此属性是否有Setter
                        If (pr.CanWrite = False) Then
                            Continue For
                        End If
                        Dim value As Object = dr(tempName) '定义一个对象型的变量来保存列的值
                        If (value.ToString <> DBNull.Value.ToString) Then     '如果非空，则赋给对象的属性
                            pr.SetValue(myTurn, value, Nothing)      '在运行期间，通过反射，动态的访问一个对象的属性
                        End If
                    End If
                Next
                mylist.Add(myTurn) '添加到集合
            Next
            Return mylist        '返回实体集合
        End Function
    End Class
End Module
```
其实这个里面用到了反射，来把DataTable中的数据表按照表头的对应关系向泛型中添加，还记得泛型中的实体吗？
泛型中的实体在这个时候就有用了，实体的属性名称必须是和数据表的字段相互对应的，否则就会返回Null值，这一点一定要注意，如果使用泛型，实体的属性名称必须和数据库表的字段名称是对应并且是一致的，这里还有一点要注意的是他默认把所有的数据都转化成了string类型因为有了.ToString这个命令，所以类型敏感的数据要注意。
**3、泛型数据的获取**
        在获取到泛型的数据了之后，肯定要读取里面的内容，在B层进行判断的时候也是必不可少的。这个时候有两种方法，其一就是判断是否有数据返回，在判断是否验证成功的时候用到了，这个时候需要检查泛型中的数据是否存在，用到了这个属性：mylist.Count，如果这个值为零，说明没有返回任何值，反之则有值，具体有多少就是这个count在指示。
        提取数据的语句是：mylist(0).UserID,其中的(0)就是显示的第几条记录，而后面的UserID则根据泛型里面的实体而定：
![](https://img-blog.csdn.net/20160129170024879?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
# 三、总结
        泛型的使用可谓是耗费了我不少的时间，从最开始的不理解到现在的知道了一部分，也是很有成就感的，这样一来判断字段数据就要方便多了，以上的方法仅供初学参考。
