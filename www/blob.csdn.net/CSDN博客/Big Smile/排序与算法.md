# 排序与算法 - Big Smile - CSDN博客
2016年04月30日 17:46:26[王啸tr1912](https://me.csdn.net/tr1912)阅读数：3246
   今天在三合班讲了选择排序和冒泡排序，回来又让查插入排序，由此有了这篇博客的内容。
# 一、百度的定义
**选择排序（Selection sort）**是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。
**冒泡排序（Bubble Sort）**，是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
**        插入排序法**,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。
# 二、横向比较
||**选择排序 **|**冒泡排序 **|**插入排序 **|
|----|----|----|----|
|**时间复杂度  **|O(n^2）|O(n^2）|O(n^2）|
|**稳定性**|稳定|稳定|稳定|
大致上看这三种排序都是稳定的排序，且都是原地排序，就是已有固定数据的排序，稳定度是一样的，稳定性是一样的但是在CPU的使用和一般情况下的作用却有所不同，详细内容如下图所示：
![](https://img-blog.csdn.net/20160430170527892?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
        由于选择排序交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
        当排序的数据量是一定的情况下，由于插入排序的优越性，性能比较高，选择排序的步骤是固定的只和数字个数有关，因此还要看此时的冒泡排序的步骤多少。最好情况下（顺序已经确定）是冒泡排序最省时间，而插入排序反而最费时间。
# 三、插入排序
由于书上没有插入排序的内容，所以我自己找了一下插入排序的东西，来加以说明。
插入排序的流程如下图所示：
![](https://img-blog.csdn.net/20160430172431232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如果针对一个没有排过序的数组来说的话，那么就假设第一个数是一个有序的组，然后把第二个数向这个组里面插入，进行比较。一次类推。具体的算法代码如下：
```cpp
#include<stdio.h>
void main()
{
	int a[7] = {5,2,5,8,7,4,1};   //需要排序的数组
	int i, temp, p;  //i是要循环的量，temp是要插入的数，p是i的前一个变量
	for ( i = 1; i < 7; i++)   //从1到6循环
	{
		temp = a[i];         //取得要插入的数
		p = i - 1;        //取得有序列最后一个数字的位置
		while (p >= 0 && temp < a[p])  //跳出条件：上一个数是第一数，或上一个数大于现在的数
		{
			a[p + 1] = a[p];  //符合条件的数后移
			p--; //变量减一比较上一个数
		}
		a[p + 1] = temp;    //将需要排序的数插入合适的位置
	}
}
```
注释写的很详细，有错误的地方可以即时指正。
# 四、其他算法
高级的排序算法还有很多，当然算法也不只是服务于排序，是以排序为主的，看下面几张图片，很快速，很独特的排序算法：
![](https://img-blog.csdn.net/20160430173953364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20160430174026551?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20160430174106521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如果你对排序算法或者其他上述图片的算法感兴趣，不放看看这篇文章：[十大编程算法····](http://www.lupaworld.com/article-242544-1.html)
# 五、总结
 通过了这一节课的学习，让我们明白了世界上的算法有很多，我们接触到的还只是冰山一角，所以我们还要继续的学习。另外在学习中逐步积累和编织知识网也是很有用的，因为同是排序，算法有很多种，效率和对于电脑的影响也很不一样，还需要我们具体的总结探索。
