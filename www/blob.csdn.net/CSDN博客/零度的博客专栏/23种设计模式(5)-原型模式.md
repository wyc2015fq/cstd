# 23种设计模式(5)-原型模式 - 零度的博客专栏 - CSDN博客
2017年07月11日 09:38:22[零度anngle](https://me.csdn.net/zmx729618)阅读数：267
原型模式(Prototype) 
一、概述 
二、结构 
三、浅度克隆和深度克隆 
　浅度克隆 
　深度克隆 
**一、概述**
　定义：原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。简言之：就是复制粘贴。这就是选型模式的用意。
**二、结构**
原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：
1、实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 CloneNotSupportedException异常。
2、重写Object类中的clone方法。Java中，所有类的父类都是 Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因 此，Prototype类需要将clone方法的作用域修改为public类型。
**三、浅度克隆和深度克隆**
　　浅度克隆 
　　只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。
```java
public class Person1  implements Cloneable{
    //基本数据类型
    private int age;
    //String引用类型
    private String name;
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Person1 clone() {
        Person1 person =null;
        try {
             person = (Person1) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}
public class Client {
    public static void main(String[] args) {
        Person1 p1=new Person1();
        p1.setName("汤高");
        p1.setAge(20);
//      Person p2=p1;//地址相同  只是把引用给了p2 指向同一个地址
//      System.out.println(p1==p2);//true
        Person1 p2=p1.clone();
        //拷贝  地址不同了 指向不同的地址
        System.out.println("前后地址相同吗:  "+(p2==p1));
        System.out.println("输出p1:" +p1.getName()+"\t"+p1.getAge());
        System.out.println("输出p2:" +p2.getName()+"\t"+p2.getAge());
        //修改拷贝后的对象的属性值
        p2.setName("周思远");
        p2.setAge(19);
        System.out.println("输出p1:" +p1.getName()+"\t"+p1.getAge());
        System.out.println("输出p2:" +p2.getName()+"\t"+p2.getAge());
    }
}
```
结果: 
前后地址相同吗: false 
输出p1:汤高 20 
输出p2:汤高 20 
输出p1:汤高 20 
输出p2:周思远 19
通过上诉测试可知对于基本类型和String类型的数据前后都是指向不同的地址空间,改变一个不会影响其他的对象
**浅度克隆图如下**
![这里写图片描述](https://img-blog.csdn.net/20160127181031316)
![这里写图片描述](https://img-blog.csdn.net/20160127180844746)
但是如果包含引用类型比如对象、数组、集合等,就只会克隆引用，结果指向同一个引用地址
```java
public class Person2  implements Cloneable{
    //基本数据类型
    private int age;
    //String引用类型
    private String name;
    //引用类型
    private List<String> friends=new ArrayList<String>();
    //对象
    private School school;
    public School getSchool() {
        return school;
    }
    public void setSchool(School school) {
        this.school = school;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public List<String> getFriends() {
        return friends;
    }
    public void setFriends(List<String> friends) {
        this.friends = friends;
    }
    public Person2 clone() {
        Person2 person =null;
        try {
             person = (Person2) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}
public class Client2 {
    public static void main(String[] args) {
        Person2 p1=new Person2();
        List<String> friends=new ArrayList<String>();
        friends.add("汤小高");
        friends.add("周小思");
        p1.setFriends(friends);
        Person2 p2=p1.clone();
        System.out.println(p1.getFriends());
        System.out.println(p2.getFriends());
        friends.add("TSY");
        p1.setFriends(friends);
        System.out.println(p1.getFriends());
        System.out.println(p2.getFriends());
        School school=new School();
        school.setName("清华");
    }
}
```
结果： 
[汤小高, 周小思] 
[汤小高, 周小思] 
[汤小高, 周小思, TSY] 
[汤小高, 周小思, TSY]
```
public class Client3 {
    public static void main(String[] args) {
        Person2 p1=new Person2();
        School school=new School();
        school.setName("清华");
        p1.setSchool(school);
        Person2 p2=p1.clone();
        System.out.println(p1.getSchool()==p2.getSchool());
        System.out.println(p1.getSchool());
        System.out.println(p2.getSchool());
        school.setName("北大");
        p1.setSchool(school);
        System.out.println(p1.getSchool());//北大
        System.out.println(p2.getSchool());//北大
    }
}
```
结果： 
true 
学校名: 清华 
学校名: 清华 
学校名: 北大 
学校名: 北大
我只改变了p1 结果p2也变了 原因如下图，共享一个引用
**浅度克隆图如下**
![这里写图片描述](https://img-blog.csdn.net/20160127181123019)
这时候就需要使用深度克隆了! 
　　深度克隆 
　　除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。
深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续 采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。
**要实现深度克隆 必须修改clone()方法**
```java
public class Person2  implements Cloneable{
    //基本数据类型
    private int age;
    //String引用类型
    private String name;
    //引用类型
    private List<String> friends=new ArrayList<String>();
    //对象
    private School school;
    public School getSchool() {
        return school;
    }
    public void setSchool(School school) {
        this.school = school;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public List<String> getFriends() {
        return friends;
    }
    public void setFriends(List<String> friends) {
        this.friends = friends;
    }
   //修改后的clone方法
    public Person2 clone() {
        try {
            Person2 person = (Person2) super.clone();
            if(this.getFriends()!=null){
                List<String> friends=new ArrayList<String>();
                for(String friend:this.getFriends()){
                    friends.add(friend);
                }
                person.setFriends(friends);
            }
            if(this.getSchool()!=null){
                 School school=new School();
                 school.setName(this.getSchool().getName());
                 person.setSchool(school);
            }
            return person;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```
测试类同上
结果： 
[汤小高, 周小思] 
[汤小高, 周小思] 
[汤小高, 周小思, TSY]
结果： 
false 
学校名: 清华 
学校名: 清华 
学校名: 北大 
学校名: 清华 
我修改了p1,p2的值没有改变 原因如下
深度克隆图如下 
![这里写图片描述](https://img-blog.csdn.net/20160127181711646)
**以上内容来自平时所看书籍和网络资源整理测试所得，如有不完善之处，欢迎指正！**
