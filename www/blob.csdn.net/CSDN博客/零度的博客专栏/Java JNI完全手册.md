# Java: JNI完全手册 - 零度的博客专栏 - CSDN博客
2016年04月20日 11:40:30[零度anngle](https://me.csdn.net/zmx729618)阅读数：340
个人分类：[JNI](https://blog.csdn.net/zmx729618/article/category/6193126)
最近在公司里做了一个手机的项目，需要JAVA程序在发送短信的时候和第三方的短信服务器连接。短信接口是用C++写的。琢磨了三天，大致搞懂了JNI的主体部分。先将心得整理，希望各位朋友少走弯路。
首先引用一篇文章，介绍一个简单的JNI的调用的过程。
JAVA以其跨平台的特性深受人们喜爱，而又正由于它的跨平台的目的，使得它和本地机器的各种内部联系变得很少，约束了它的功能。解决JAVA对本地操作的一种方法就是JNI。
JAVA通过JNI调用本地方法，而本地方法是以库文件的形式存放的（在WINDOWS平台上是DLL文件形式，在UNIX机器上是SO文件形式）。通过调用本地的库文件的内部方法，使JAVA可以实现和本地机器的紧密联系，调用系统级的各接口方法。
简单介绍及应用如下： 
一、JAVA中所需要做的工作 
在JAVA程序中，首先需要在类中声明所调用的库名称，如下： 
static { 
System.loadLibrary(“goodluck”); 
}
在这里，库的扩展名字可以不用写出来，究竟是DLL还是SO，由系统自己判断。 
还需对将要调用的方法做本地声明，关键字为native。且只需要声明，而不需要具体实现。如下： 
public native static void set(int i); 
public native static int get();
然后编译该JAVA程序文件，生成CLASS，再用JAVAH命令，JNI就会生成C/C++的头文件。 
例如程序testdll.java，内容为： 
public class testdll 
{ 
static 
{ 
System.loadLibrary("goodluck"); 
} 
public native static int get(); 
public native static void set(int i); 
public static void main(String[] args) 
{ 
testdll test = new testdll(); 
test.set(10); 
System.out.println(test.get()); 
} 
}
用javac testdll.java编译它，会生成testdll.class。 
再用javah testdll，则会在当前目录下生成testdll.h文件，这个文件需要被C/C++程序调用来生成所需的库文件。 
二、C/C++中所需要做的工作 
对于已生成的.h头文件，C/C++所需要做的，就是把它的各个方法具体的实现。然后编译连接成库文件即可。再把库文件拷贝到JAVA程序的路径下面，就可以用JAVA调用C/C++所实现的功能了。 
接上例子。我们先看一下testdll.h文件的内容： 
/* DO NOT EDIT THIS FILE - it is machine generated */ 
#include 
/* Header for class testdll */ 
#ifndef _Included_testdll 
#define _Included_testdll 
#ifdef __cplusplus 
extern "C" { 
#endif 
/* 
* Class: testdll 
* Method: get 
* Signature: ()I 
*/ 
JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 
/* 
* Class: testdll 
* Method: set 
* Signature: (I)V 
*/ 
JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint); 
#ifdef __cplusplus 
} 
#endif 
#endif
在具体实现的时候，我们只关心两个函数原型 
JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 和 
JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint);
这里JNIEXPORT和JNICALL都是JNI的关键字，表示此函数是要被JNI调用的。而jint是以JNI为中介使JAVA的int类型与本地的int沟通的一种类型，我们可以视而不见，就当做int使用。函数的名称是JAVA_再加上java程序的package路径再加函数名组成的。参数中，我们也只需要关心在JAVA程序中存在的参数，至于JNIEnv*和jclass我们一般没有必要去碰它。 
好，下面我们用testdll.cpp文件具体实现这两个函数： 
#include "testdll.h" 
int i = 0; 
JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass) 
{ 
return i; 
} 
JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint j) 
{ 
i = j; 
}
编译连接成库文件，本例是在WINDOWS下做的，生成的是DLL文件。并且名称要与JAVA中需要调用的一致，这里就是goodluck.dll 。把goodluck.dll拷贝到testdll.class的目录下，java testdll运行它，就可以观察到结果了。
我的项目比较复杂，需要调用动态链接库，这样在JNI传送参数到C程序时，需要对参数进行处理转换。才可以被C程序识别。
大体程序如下：
public class SendSMS { 
static 
{ 
System.out.println(System.getProperty("java.library.path")); 
System.loadLibrary("sms"); 
} 
public native static int SmsInit(); 
public native static int SmsSend(byte[] mobileNo, byte[] smContent); 
}
在这里要注意的是，path里一定要包含类库的路径，否则在程序运行时会抛出异常：
java.lang.UnsatisfiedLinkError: no sms in java.library.path
at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1491)
at java.lang.Runtime.loadLibrary0(Runtime.java:788)
at java.lang.System.loadLibrary(System.java:834)
at com.mobilesoft.sms.mobilesoftinfo.SendSMS.(SendSMS.java:14)
at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18)
Exception in thread "main"
指引的路径应该到.dll文件的上一级，如果指到.dll，则会报：
java.lang.UnsatisfiedLinkError: C:\sms.dll: Can't find dependent libraries
at java.lang.ClassLoader$NativeLibrary.load(Native Method)
at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1560)
at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1485)
at java.lang.Runtime.loadLibrary0(Runtime.java:788)
at java.lang.System.loadLibrary(System.java:834)
at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18)
Exception in thread "main"
通过编译，生成com_mobilesoft_sms_mobilesoftinfo_SendSMS.h头文件。（建议使用Jbuilder进行编译，操作比较简单！）这个头文件就是Java和C之间的纽带。要特别注意的是方法中传递的参数jbyteArray，这在接下来的过程中会重点介绍。
/* DO NOT EDIT THIS FILE - it is machine generated */ 
#include 
/* Header for class com_mobilesoft_sms_mobilesoftinfo_SendSMS */ 
#ifndef _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS 
#define _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS 
#ifdef __cplusplus 
extern "C" { 
#endif 
/* 
* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS 
* Method: SmsInit 
* Signature: ()I 
*/ 
JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsInit 
(JNIEnv *, jclass); 
/* 
* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS 
* Method: SmsSend 
* Signature: ([B[B)I 
*/ 
JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsSend 
(JNIEnv *, jclass, jbyteArray, jbyteArray); 
#ifdef __cplusplus 
} 
#endif 
#endif
对于我要调用的C程序的动态链接库，C程序也要提供一个头文件，sms.h。这个文件将要调用的方法罗列了出来。
/* 
* SMS API 
* Author: yippit 
* Date: 2004.6.8 
*/ 
#ifndef MCS_SMS_H 
#define MCS_SMS_H 
#define DLLEXPORT __declspec(dllexport) 
/*sms storage*/ 
#define SMS_SIM 0 
#define SMS_MT 1 
/*sms states*/ 
#define SMS_UNREAD 0 
#define SMS_READ 1 
/*sms type*/ 
#define SMS_NOPARSE -1 
#define SMS_NORMAL 0 
#define SMS_FLASH 1 
#define SMS_MMSNOTI 2 
typedef struct tagSmsEntry { 
int index; /*index, start from 1*/ 
int status; /*read, unread*/ 
int type; /*-1-can't parser 0-normal, 1-flash, 2-mms*/ 
int storage; /*SMS_SIM, SMS_MT*/ 
char date[24]; 
char number[32]; 
char text[144]; 
} SmsEntry; 
DLLEXPORT int SmsInit(void); 
DLLEXPORT int SmsSend(char *phonenum, char *content); 
DLLEXPORT int SmsSetSCA(char *sca); 
DLLEXPORT int SmsGetSCA(char *sca); 
DLLEXPORT int SmsSetInd(int ind); 
DLLEXPORT int SmsGetInd(void); 
DLLEXPORT int SmsGetInfo(int storage, int *max, int *used); 
DLLEXPORT int SmsSaveFlash(int flag); 
DLLEXPORT int SmsRead(SmsEntry *entry, int storage, int index); 
DLLEXPORT int SmsDelete(int storage, int index); 
DLLEXPORT int SmsModifyStatus(int storage, int index); /*unread -> read*/ 
#endif
在有了这两个头文件之后，就可以进行C程序的编写了。也就是实现对JNI调用的两个方法。在网上的资料中，由于调用的方法实现的都比较简单，（大多是打印字符串等）所以避开了JNI中最麻烦的部分，也是最关键的部分，参数的传递。由于Java和C的编码是不同的，所以传递的参数是要进行再处理，否则C程序是会对参数在编译过程中提出警告，例如；warning C4024: 'SmsSend' : different types for formal and actual
 parameter 2等。
Sms.c的程序如下：
#include "sms.h" 
#include "com_mobilesoft_sms_mobilesoftinfo_SendSMS.h" 
JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsInit(JNIEnv * env, jclass jobject) 
{ 
return SmsInit(); 
} 
JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsSend(JNIEnv * env, jclass jobject, jbyteArray mobileno, jbyteArray smscontent) 
{ 
char * pSmscontent ; 
//jsize theArrayLengthJ = (*env)->GetArrayLength(env,mobileno); 
jbyte * arrayBody = (*env)->GetByteArrayElements(env,mobileno,0); 
char * pMobileNo = (char *)arrayBody; 
printf("[%s]\n ", pMobileNo); 
//jsize size = (*env)->GetArrayLength(env,smscontent); 
arrayBody = (*env)->GetByteArrayElements(env,smscontent,0); 
pSmscontent = (char *)arrayBody; 
printf("<%s>\n", pSmscontent); 
return SmsSend(pMobileNo,pSmscontent); 
}
对于C或C++，在程序上是会有稍微的不同，这可以由读者对其进行适当的修改。这里要注意的是GetArrayLength，GetByteArrayElements等这些JNI中已经包含的方法，这些方法是专门对转换参数类型而提供的。具体的方法有很多，在下一篇中会做专门的介绍。
在完成了上述的文件后，可以对sms.c进行编译，生成.dll文件（建议在release中编译，这样动态链接库的容积会比较小！）
完成.dll文件的编译后，就可以在Java中调用C程序中的方法了。例如文件test.java
public class test { 
public test() { 
} 
public static void main(String[] args) { 
byte[] mobileno = { 
0x31, 0x33, 0x36, 0x36, 0x31, 0x36, 0x33, 0x30, 0x36, 0x36, 0x37, 0x00}; 
String smscontentemp = "早上好"; 
byte[] temp = {0}; 
try { 
byte[] smscontentdb = smscontentemp.getBytes("gbk"); 
byte[] smscontent = new byte[smscontentdb.length + temp.length]; 
System.arraycopy(smscontentdb, 0, smscontent, 0, smscontentdb.length); 
System.arraycopy(temp, 0, smscontent, smscontentdb.length, temp.length); 
SendSMS sendSMS = new SendSMS(); 
sendSMS.SmsInit(); 
if (sendSMS.SmsSend(mobileno, smscontent) >= 0) { 
System.out.println("chenggong !"); 
} 
else { 
System.out.println("shibai !"); 
} 
}catch (Exception ex) {} 
} 
}
在这个文件中要注意的有一点，就是在传递字节数组到C程序中时，最后的结尾一定要以0结束。这是一个偷懒的做法，不过是个有效的做法。因为大多数情况下，接口是由第三方提供的。所以我们一般是不知道在C的方法里，具体是怎么处理参数的。而C又是要求数组是有长度。所以，在Java中，如果你不想写程序传数组的长度，那么在数组中以0结尾就是最方便的方法了。当然，如果有更好的方法也希望大家提出。
到这里，一个完整的Java通过JNI调用动态链接库的程序就完成了。实际上也不是很复杂。只要多注意一下细节，是很容易得出来的。
