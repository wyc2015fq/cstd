# JAX-WS创建和JavaAPI发送和处理SOAP消息实例 - 零度的博客专栏 - CSDN博客
2016年05月09日 11:42:11[零度anngle](https://me.csdn.net/zmx729618)阅读数：6656
        JAX-WS规范是一组XML web services的JAVA API，在 JAX-WS中，一个远程调用可以转换为一个基于XML的协议例如SOAP，在使用JAX-WS过程中，开发者不需要编写任何生成和处理SOAP消息的代码。JAX-WS的运行时实现会将这些API的调用转换成为对应的SOAP消息。
 JAX-WS 也提供了一组针对底层消息进行操作的API调用，你可以通过Dispatch 直接使用SOAP消息或XML消息发送请求或者使用Provider处理SOAP或XML消息。通过web service所提供的互操作环境，我们可以用JAX-WS轻松实现JAVA平台与其他编程环境（.net等）的互操作。
     现在WebService的主要成熟的框架有axis、cxf等，都很好的支持了SOAP协议，而且CXF也提供了对 JAX-WS 全面的支持。可以算是JAX-WS进行封装的框架。
     这篇文章就对处理web services的JAVA基础API JAX-WS进行介绍。
     首先看如何发布web services服务。
     1、编写接口，使用@WebService注解
```
package zmx.jaxws.server;
import javax.jws.WebParam;  
import javax.jws.WebResult;  
import javax.jws.WebService;  
  
@WebService  
public interface IMyService {  
    @WebResult(name="addResult")  
    //对返回值和参数进行名字定义，否则默认为arg0，arg1...  
    public int add(@WebParam(name="firstA")int a ,@WebParam(name="SecondB")int b);  
    //与上面方法进行对比  
    public int minus(int a,int b);  
}
```
  2、编写编写实现类，标明@WebService注解
```
package zmx.jaxws.server;
import javax.jws.WebResult;
import javax.jws.WebService;
@WebService(endpointInterface="zmx.jaxws.server.IMyService")
public class MyServiceImpl implements IMyService {
	@Override
	@WebResult(name="addResult")
	public int add(int a, int b) {
		System.out.print(a+"+"+b+"="+(a+b));
		return a+b;
	}
	@Override
	public int minus(int a, int b) {
		System.out.print(a+"-"+b+"="+(a-b));
		return a-b;
	}
}
```
    3、编写服务类，根据url和是实现类启动服务
```
package zmx.jaxws.server;
import javax.xml.ws.Endpoint;
public class MyServicePublisher {
	
	public static void main(String[] args) {
		String address="http://localhost:6666/ws/myService";  
		Endpoint.publish(address, new MyServiceImpl()); 
		System.out.println("WS Published."); 
	}
}
```
    4、运行3中代码，发布服务，在浏览器可查看
[http://localhost:6666/ws/myService?wsdl](http://localhost:6666/ws/myService?wsdl)
```
<?xml version="1.0" encoding="UTF-8"?>
<!-- Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. -->
<!-- Generated by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. -->
-<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" name="MyServiceImplService" targetNamespace="http://server.jaxws.zmx/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://server.jaxws.zmx/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">-<types>-<xsd:schema><xsd:import schemaLocation="http://localhost:6666/ws/myService?xsd=1" namespace="http://server.jaxws.zmx/"/></xsd:schema></types>-<message name="add"><part name="parameters" element="tns:add"/></message>-<message name="addResponse"><part name="parameters" element="tns:addResponse"/></message>-<message name="minus"><part name="parameters" element="tns:minus"/></message>-<message name="minusResponse"><part name="parameters" element="tns:minusResponse"/></message>-<portType name="IMyService">-<operation name="add"><input message="tns:add" wsam:Action="http://server.jaxws.zmx/IMyService/addRequest"/><output message="tns:addResponse" wsam:Action="http://server.jaxws.zmx/IMyService/addResponse"/></operation>-<operation name="minus"><input message="tns:minus" wsam:Action="http://server.jaxws.zmx/IMyService/minusRequest"/><output message="tns:minusResponse" wsam:Action="http://server.jaxws.zmx/IMyService/minusResponse"/></operation></portType>-<binding type="tns:IMyService" name="MyServiceImplPortBinding"><soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>-<operation name="add"><soap:operation soapAction=""/>-<input><soap:body use="literal"/></input>-<output><soap:body use="literal"/></output></operation>-<operation name="minus"><soap:operation soapAction=""/>-<input><soap:body use="literal"/></input>-<output><soap:body use="literal"/></output></operation></binding>-<service name="MyServiceImplService">-<port name="MyServiceImplPort" binding="tns:MyServiceImplPortBinding"><soap:address location="http://localhost:6666/ws/myService"/></port></service></definitions>
```
5、使用jax-ws封装好的服务进行客户端调用
```
package zmx.jaxws.client;
import java.net.URL;
import javax.xml.namespace.QName;
import javax.xml.ws.Service;
import zmx.jaxws.server.IMyService;
public class MyServiceClient {
	
	public static void main(String[] args) throws Exception {
        URL url = new URL("http://localhost:6666/ws/myService?wsdl");  
        QName qname = new QName("http://server.jaxws.zmx/", "MyServiceImplService");  
        Service service = Service.create(url, qname);  
        IMyService myService = service.getPort(IMyService.class);     
        System.out.println(myService.add(12,33));   
	}
}
```
      这样的客户端调用直接使用封装好的service进行操作，在调用过程中将我们的代码转换为SOAP“信件”与服务进行交互，我们不需要编写任何生成和处理SOAP消息的代码。很是方便。不过既然是JAVA 
 底层API，它也提供了底层的SOAP操作API，我们来用易用，了解一下SOAP是怎样生成的。
     6、创建SOAP消息
```
private String ns = "http://server.jaxws.zmx/";
		private String wsdlUrl = "http://localhost:6666/ws/myService?wsdl";
		/**
		 * 创建SOAP消息
		 * @author zmx		 */
		@Test 
		public void createSoap() {
			try {
				// 创建消息工厂
				MessageFactory factory = MessageFactory.newInstance();
				// 根据消息工厂创建SoapMessage
				SOAPMessage message = factory.createMessage();
				// 创建SOAPPart
				SOAPPart part = message.getSOAPPart();
				// 获取SOAPEnvelope
				SOAPEnvelope envelope = part.getEnvelope(); 
				// 通过SoapEnvelope可以获取到相应的Body和Header等信息
				SOAPBody body = envelope.getBody();
				// 根据Qname创建相应的节点,Qname是一个带有命名空间的节点
				QName qname = new QName("http://server.jaxws.zmx/", "add", "ns");
				// <ns:add xmlns="http://java.wh/webservice/"
				SOAPBodyElement ele = body.addBodyElement(qname);
				ele.addChildElement("a").setValue("11");
				ele.addChildElement("b").setValue("22");
				// 打印消息信息
				message.writeTo(System.out);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
```
     代码比较容易理解，首先通过消息工厂MessageFactory创建SOAPMessage，然后创建SOAPPart，我的理解相当于创建了一个邮箱，然后创建信件SOAPEnvelope，之后是SOAP的BODY和Header部分，其中Header部分可以省略。不过现在的API可以省略SOAPPart，直接创建BODY和Header，鉴于Part是经典方式，所以还是按照传统来了。
     这里涉及到SOAP消息的格式，很形象的可以理解为一封信件，鉴于是基础知识，这里便不再赘述，不清楚的可以先补充一下SOAP格式，理解了SOAP的格式之后，上面那段代码是很容易理解的。
     这样进行运行后，我们便可以得到一个完整的SOAP消息：
![](https://img-blog.csdn.net/20130701212358500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2h1YW4yMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
     得到这样的SOAP消息后，怎么与我们发布的WSDL进行交互呢？
 7、SOAP消息传递和处理，使用Dispatch 
```
package zmx.jaxws.soap;
import java.net.URL;
import javax.xml.namespace.QName;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPBodyElement;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.ws.Dispatch;
import javax.xml.ws.Service;
import org.junit.Test;
import org.w3c.dom.Document;
public class SOAPTest {
		private String ns = "http://server.jaxws.zmx/";
		private String wsdlUrl = "http://localhost:6666/ws/myService?wsdl";
		/**
		 * 创建SOAP消息
		 * @author zwx		 */
		@Test 
		public void createSoap() {
			try {
				// 创建消息工厂
				MessageFactory factory = MessageFactory.newInstance();
				// 根据消息工厂创建SoapMessage
				SOAPMessage message = factory.createMessage();
				// 创建SOAPPart
				SOAPPart part = message.getSOAPPart();
				// 获取SOAPEnvelope
				SOAPEnvelope envelope = part.getEnvelope(); 
				// 通过SoapEnvelope可以获取到相应的Body和Header等信息
				SOAPBody body = envelope.getBody();
				// 根据Qname创建相应的节点,Qname是一个带有命名空间的节点
				QName qname = new QName("http://server.jaxws.zmx/", "add", "ns");
				// <ns:add xmlns="http://java.wh/webservice/"
				SOAPBodyElement ele = body.addBodyElement(qname);
				ele.addChildElement("a").setValue("11");
				ele.addChildElement("b").setValue("22");
				// 打印消息信息
				message.writeTo(System.out);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		
		/**
		 * 创建SOAP消息,并提交得到返回值
		 * @author WHuan
		 */
		@Test
		public void soapDispatch() {
			try {
				// 创建服务service
				URL url = new URL(wsdlUrl);
				QName sname= new QName(ns,"MyServiceImplService");
				Service service =Service.create(url,sname);
				
				//创建DIspatch
				Dispatch<SOAPMessage> dispatch=service.createDispatch(new QName(ns,"MyServiceImplPort"),
	            SOAPMessage.class, Service.Mode.MESSAGE);
				
				//创建SOAPMessage
				SOAPMessage msg=MessageFactory.newInstance().createMessage();
				SOAPEnvelope envelope =msg.getSOAPPart().getEnvelope();
				SOAPBody body=envelope.getBody();
				
				//创建QName来指定消息中传递数据
				QName ename=new QName(ns,"add","nn");
				//<nn:add xmlns="xx"/>
				SOAPBodyElement ele=body.addBodyElement(ename);
				ele.addChildElement("firstA").setValue("22");
				ele.addChildElement("SecondB").setValue("33");
				msg.writeTo(System.out);
				System.out.println("\n invoking....");
				
				//通过Dispatch传递消息,会返回相应消息
				SOAPMessage response = dispatch.invoke(msg);
				response.writeTo(System.out);
				System.out.println();
				
				//将相应的消息转换为doc对象
				Document doc= response.getSOAPPart().getEnvelope().getBody().extractContentAsDocument();
				String str=doc.getElementsByTagName("addResult").item(0).getTextContent();
				System.out.println(str);
				
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	
}
```
    这样直接创建了SOAP消息后使用dispatch便可以进行传递，通过extractConentAsDocument方法得到Document类型的返回值，从返回值的SOAP消息中取得我们想要的标签信息。输出结果如下：
![](https://img-blog.csdn.net/20130701212609843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2h1YW4yMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20130701212614234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2h1YW4yMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
    本文主要从使用JAVA自带API出发，介绍一些稍微底层些的SOAP消息的创建和传递处理。理解了底层，也对web Service的框架使用多一份熟悉，也当给大家复习下SOAP消息。
