# 数据库之排他(exclusive)锁和共享(shared)锁 - 零度的博客专栏 - CSDN博客
2016年04月27日 15:04:16[零度anngle](https://me.csdn.net/zmx729618)阅读数：904
    锁跟事务是联系在一起的，锁的生命周期是事务开始到事务结束（不管是提交还是回滚都是结束）。 所以，讲到锁就不能回避事务而单单去讲锁的含义。
但我们还是先讲例子再讲锁的定义.首先，根据锁类型划分有排他（exclusive）锁和共享（shared）锁。
    下面举例：
    通过DML语句对一张表的某一行数据进行修改，一个事务开始，背后的步骤是：
    1.对这张表加一个共享锁。这么做是为了防止别的会话通过DDL语句修改这张表的表结构。DDL语句要修改了这张表，就必须给表加上排他锁。但是现在给表加了共享锁了，也就排斥了DDL去加排他锁；
    2.对修改的那一行加一个排他锁，别的会话不能修改这一行。但是我对整张表加的是共享锁而不是排他锁，所以别的会话还是可以修改其他行（也经历1、2两个步骤）
    这样，对于共享和排它的含义应该清楚了。
    定义： 注意：这里用“修改”这个词取代真实的DML或DDL操作。
    1.排他锁：排他锁很好理解，是自己独占资源。其它会话想再在同一对象上加共享或排他锁都是不允许的。不过其它会话可以读，这也证明普通的读是不上锁的。如果查的对象被修改，查询操作还会会被重定向到对应的撤销块（原来的数据），以保证事务事物隔离和读一致；
    2.共享锁：共享锁是造成上锁对象必须被大家共享，它排斥排他锁，因此别的会话不能独占资源对其修改（“修改”会先给修改对象加上 排他锁 的）。但不排斥其他共享锁，所以一个对象可被多个会话同时加上共享锁。
     有两点补充：
     1.锁的意义就是为了保护对象，所以它们其实有一个共同的目的，那就是不允许其它会话对我的上锁对象本身进行修改。对表而言是表结构，对行而言是每个字段的数据。
    2.上锁对象可以是表，也可以是表里面的行（是整个行，给行上了排他锁后，所有字段的数据都不许别人动）。
但是给行加共享锁是没意义的，因为锁定一行就是为了自己能修改而别人不能，上共享锁自己也不能修改了
（说的有点牵强，希望多思考一下）
