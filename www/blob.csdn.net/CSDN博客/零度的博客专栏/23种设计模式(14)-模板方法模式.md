# 23种设计模式(14)-模板方法模式 - 零度的博客专栏 - CSDN博客
2017年07月18日 17:07:13[零度anngle](https://me.csdn.net/zmx729618)阅读数：270标签：[设计模式																[模板方法](https://so.csdn.net/so/search/s.do?q=模板方法&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)
个人分类：[设计模式](https://blog.csdn.net/zmx729618/article/category/6246650)
**模板方法模式**
    一、概述 
    二、结构 
    三、具体案例 
    四、优缺点和设计思想  
一、概述 
模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意
**二、结构**
　模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 
　　模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻 辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。
　　模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 
![这里写图片描述](https://img-blog.csdn.net/20160202125754464)
　　这里涉及到两个角色： 
**抽象模板(Abstract Template)角色**有如下责任： 
　　■定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 
　　■定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。
**具体模板(Concrete Template)角色**又如下责任： 
　　■实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 
　　■每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。
源代码 
　　抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。
```java
public abstract class AbstractTemplate {
    /**
     * 模板方法
     */
    public void templateMethod(){
        //调用基本方法        
    abstractMethod();
        hookMethod();
        concreteMethod();
    }
    /**
     * 基本方法的声明（由子类实现）
     */
    protected abstract void abstractMethod();
    /**
     * 基本方法(空方法)
     */
    protected void hookMethod(){}
    /**
     * 基本方法（已经实现）
     */
    private final void concreteMethod(){
        //业务相关的代码    }
}
```
　　具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。
```java
public class ConcreteTemplate extends AbstractTemplate{
    //基本方法的实现    @Override
    public void abstractMethod() {
        //业务相关的代码    }
    //重写父类的方法    @Override
    public void hookMethod() {
        //业务相关的代码    }
}
```
　　模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 
　　每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。
模板方法中的方法 
　　模板方法中的方法可以分为两大类：**模板方法和基本方法**。 
**模板方法**
　　一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 
　　一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 
**基本方法**
**抽象方法**：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 
**具体方法**：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 
**钩子方法**：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 
　　在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。 concreteMethod()是一个具体方法，它由抽象类声明并实现。
**默认钩子方法**
　　一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的 子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。
**三、具体案例**
本案例实现商店结账功能；该店客户分为两种 一种是普通客户：不打折 ，另一种是会员 ：打五折。所以同样价格的东西他们所付的钱就不同
源代码
```java
/**
 * 抽象模板角色   
 * @author Administrator
 *
 */
public abstract class Client {
    /**
     * 模板方法  加上final 确保不会被子类修改  
     * @return 返回 计算的价钱
     */
    public final double accountMoney(){
        double oldPrice=oldPrice(10000);//假设该商品原价10000
        double discount=accountDiscount();
        return oldPrice*discount;
    }
     /**
     * 基本方法(钩子方法)留给子类实现
     * 得到客户类型
     */
    protected String  doGetClienttype(){
        return null;
    }
     /**
     * 基本方法(抽象方法)留给子类实现
     * 计算折扣  不同类型的客户折扣不同
     */
    protected abstract double accountDiscount();
    /**
     * 基本方法(具体方法)，已经实现 
     * 计算原价 
     */
    private double oldPrice(double price){
        return price;
    }
}
```
```java
/**
 * 具体模板角色1  
 *  普通客户类
 * @author Administrator
 *
 */
public class CommonClient extends Client {
    @Override
    public double accountDiscount() {
        return 1.0;
    }
    @Override
    public String  doGetClienttype(){
        return "普通客户";
    }
}
```
```java
/**
 * 具体模板角色2  
 *  会员类
 * @author Administrator
 *
 */
public class Member extends Client{
    @Override
    public double accountDiscount() {
        return 0.5;
    }
    @Override
    public String  doGetClienttype(){
        return "会员客户";
    }
}
```
测试类：
```
public class MainClass {
    public static void main(String[] args) {
        Client c=new  CommonClient();
        String clentType1=c.doGetClienttype();
        double money1=c.accountMoney();
        System.out.println("客户种类 ："+clentType1);
        System.out.println("需支付: "+money1);
        Client m=new  Member();
        String clentType2=m.doGetClienttype();
        double money2=m.accountMoney();
        System.out.println("客户种类 ："+clentType2);
        System.out.println("需支付: "+money2);
    }
}
```
结果： 
客户种类 ：普通客户 
需支付: 10000.0 
客户种类 ：会员客户 
需支付: 5000.0 
四、优缺点和设计思想
优点 
模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。 
子类实现算法的某些细节，有助于算法的扩展。 
通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。
缺点 
每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。
设计思想： 
  作为模板的方法定义在父类（父类为抽象类），而方法定义使用抽象方法，实现抽象方法的是子类，要在子类实现方法，才能决定具体的操作。如果在不同的子类执行 不同实现就可以发展出不同的处理内容。不过，无论在哪个子类执行任何一种实现，处理的大致流程都还是要依照父类制定的方式。
