# 23种设计模式(11)-组合模式 - 零度的博客专栏 - CSDN博客
2017年07月13日 16:44:07[零度anngle](https://me.csdn.net/zmx729618)阅读数：183标签：[设计模式																[组合模式](https://so.csdn.net/so/search/s.do?q=组合模式&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)
个人分类：[设计模式](https://blog.csdn.net/zmx729618/article/category/6246650)
**组合模式**
        一、定义 
        二、结构 
        三、具体案例 
        四、适用性 
五、总结 
**一、定义**
     将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
**二、结构**
类图 
![这里写图片描述](https://img-blog.csdn.net/20160130204757865)
角色： 
　　1.Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管Component
　　2.Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。 
　　3.Composite 定义有子节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。
**三、具体案例**
源代码
```java
public abstract class Component {
    String name;
    public Component(String name) {
        this.name = name;
    }
    public abstract boolean add(Component c);
    public abstract boolean remove(Component c);
    public abstract void foreach();
}
```
```java
//组合类
public class Composite extends Component {
    List<Component> childList=new ArrayList<Component>();
    public Composite(String name) {
        super(name);
    }
    @Override
    public boolean add(Component c) {
        childList.add(c);
        return true;
    }
    @Override
    public boolean remove(Component c) {
        childList.remove(c);
        return true;
    }
    @Override
    public void foreach() {
         System.out.println("节点名:\t"+name);
        for(Component component:childList){
            component.foreach();
        }
    }
}
```
```java
//不存在子节点
public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }
    @Override
    public void foreach() {
         System.out.println("tself name-->"+this.name);
    }
    @Override
    public boolean add(Component c) {
        return false;
    }
    @Override
    public boolean remove(Component c) {
        return false;
    }
}
```
```
public class Client {
    public static void main(String[] args) {
        Component component = new Composite("根节点");
        Component child = new Composite("一级子节点child");
        //把两个叶子节点添加到一级子节点child
        Component child_1 = new Leaf("一级子节点child之子节点一");
        Component child_2 = new Leaf("一级子节点child之子节点二");
        child.add(child_1);
        child.add(child_2);
        Component child2 = new Composite("一级子节点child2");
        //把两个一级子节点添加到根节点
        component.add(child);
        component.add(child2);
        component.foreach();
    }
}
```
结果： 
节点名:    根节点 
节点名:    一级子节点child 
tself name–>一级子节点child之子节点一 
tself name–>一级子节点child之子节点二 
节点名:    一级子节点child2
**四、适用性**
以下情况下适用Composite模式： 
　　1．你想表示对象的部分-整体层次结构 
　　2．你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
**五、总结**
如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。本章使用了一个文件系统的例子来举例说明了组合模式的用途。在这个例子中，文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，从而实现将文件或者目录储存为目录的子级元素。
