# Hibernate使用索引及索引添加原则 - 零度的博客专栏 - CSDN博客
2017年08月31日 11:40:07[零度anngle](https://me.csdn.net/zmx729618)阅读数：7661

### 1、使用Hibernate添加索引的方式
       1）表上加索引
```java
@Table(name = "T_S_USER",indexes={@Index(name="trial_idIndex",columnList="trial_id"),@Index(name="material_idIndex",columnList="material_id")})
        public class User{
               ...
        }
```
        2）关联表上加索引
```
/**
	 * 试验点：用于数据权限控制
	 */
	@ManyToMany
	@Fetch(FetchMode.SUBSELECT)
	@JoinTable(name = "T_S_User_TrialLocation", 
	joinColumns = {@JoinColumn(name ="user_id" )}, indexes={@Index(name="trialLocation_id_Index",columnList="trialLocation_id")},
	inverseJoinColumns = {@JoinColumn(name = "trialLocation_id")})
        @OrderBy("code")
	private List<TrialLocation> trialLocationList = new ArrayList<TrialLocation>();
```
### 二、数据库建立索引常用的原则
1、表的主键、外键必须有索引;
2、数据量超过300的表应该有索引;
3、经常与其他表进行连接的表，在连接字段上应该建立索引;
4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引;
5、索引应该建在选择性高的字段上;
6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引;
7、复合索引的建立需要进行仔细分析;尽量考虑用单字段索引代替：
         A、正确选择复合索引中的主列字段，一般是选择性较好的字段;
         B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中?单字段查询是否极少甚至没有?如果是，则可以建立复合索引;否则考虑单字段索引;
         C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引;
         E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引;
8、频繁进行数据操作的表，不要建立太多的索引;
9、删除无用的索引，避免对执行计划造成负面影响;
       以上是一些普遍的建立索引时的判断依据，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。 另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的;相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。
       总的来说，小型表肯定不建索引，或者数据库记录在亿条数据级以上，还是建议使用非关系型数据库。还有些特殊字段的数据库，比如BLOB，CLOB字段肯定也不适合建索引。其实这个问题更感觉偏向于做软件项目的一种经验。
### 三、对千万级MySQL数据库建立索引的事项及提高性能的手段
1、注意事项：
        首先，应当考虑表空间和磁盘空间是否足够。我们知道索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题。
       其次，在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。
2、性能调整方面：
      首当其冲的考虑因素便是磁盘I/O。物理上，应当尽量把索引与数据分散到不同的磁盘上(不考虑阵列的情况)。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本准则。
     其次，我们知道，在建立索引的时候要对表进行全表的扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大。
     再次，建立索引除了要进行全表扫描外，同时还要对数据进行大量的排序操作，因此，应当调整排序区的大小。
