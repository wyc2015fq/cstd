# Java中int与byte数组转换详解 - 零度的博客专栏 - CSDN博客
2016年06月28日 14:33:51[零度anngle](https://me.csdn.net/zmx729618)阅读数：14902
#### 1、与运算符的理解（&）: 
      参加运算的两个数据，按二进位进行“与”运算。如果两个相应的二进位都为1，则该位的结果值为1，否则为0。即 0&0=0；0&1=0；1&0=0；1&1=1；
例子：int x = 62255550; y =0xff;
转二进制：x = 62255550 = 11101101011111000110111110;   
y  = 0xFF = 11111111;
11101101011111000110111110
&00 00000000 00000000 11111111
-----------------------------------------------
   00 00000000 00000000 10111110
     (从右到左做与运算，不足的补0)
      如果参加&运算的是负数(如-3 & -5)，则以补码形式表示为二进制数，然后按位进行“与”运算。
      注：计算机中的负数是以其补码形式存在的 补码=原码取反+1，一个字节有8位 可以表示的数值范围在 -128到+127 用二进制表示也就是 10000000 - 01111111（注意：最高位表示符号）最高位是1的都是负数 最高位是0的都是正数，如-7 原码是 10000111 然后取反（最高位是符合不用取反）得11111000加1
 得11111001 那么-7的二进制数就是 11111001；再如 -10 原码是 10001010 取反得 11110101 加一得 11110110，那么-10的二进制数就是 11110110。
#### 2、移位运算：java移位运算符三种：<<（左移）、>>（带符号右移）和>>>（无符号右移）:
**2.1、 左移运算符**
       左移运算符<<使指定值的所有位都左移规定的次数。
1）它的通用格式如下所示：
value << num
num 指定要移位值value 移动的位数。
左移的规则只记住一点：丢弃最高位，0补最低位
如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位。
2）运算规则
按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。
当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃；
当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。
当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。
3）数学意义
在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方
4）计算过程：
例如：3 <<2(3为int型)
1）把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011，
2）把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，
3）在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，
转换为十进制是12。
**2.2、 右移运算符**
右移运算符>>使指定值的所有位都右移规定的次数。
1）它的通用格式如下所示：
value >> num
num 指定要移位值value 移动的位数。
右移的规则只记住一点：符号位不变，左边补上符号位
2）运算规则：
按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1
当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。
例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移
操作时用来保持负数的符号。
3）数学意义
右移一位相当于除2，右移n位相当于除以2的n次方。
4）计算过程
11 >>2(11为int型)
1)11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011
2)把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。
3)最终结果是0000 0000 0000 0000 0000 0000 0000 0010。
转换为十进制是2。
35 >> 2(35为int型)
35转换为二进制：0000 0000 0000 0000 0000 0000 0010 0011
把低位的最后两个数字移出：0000 0000 0000 0000 0000 0000 0000 1000
转换为十进制： 8
5）在右移时不保留符号的出来
     右移后的值与0x0f进行按位与运算，这样可以舍弃任何的符号位扩展，以便得到的值可以作为定义数组的下标，从而得到对应数组元素代表的十六进制字符。
**2.3、无符号右移**
无符号右移运算符>>>
它的通用格式如下所示：
value >>> num
num 指定要移位值value 移动的位数。
无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位
无符号右移运算符>>> 只是对32位和64位的值有意义
#### 3、java中:
|1|一个byte占一个字节，即8位比特;|
|----|----|
|2|一个int 占4个字节，即32比特；|
|3|java的二进制采用的是补码形式：⑴一个数为正，则它的原码、反码、补码相同⑵一个数为负，则符号位为1，其余各位是对原码取反，然后整个数加1因为补码存在，所以右移运算后要与0xff相与运算|
|4|在Java中，当我们要将int转换为byte数组时，一个int就需要长度为4个字节的数组来存放，其中一次从数组下标为[0]开始存放int的高位到低位。|
|5|Java中的一个byte，其范围是-128~127的，而Integer.toHexString的参数本来是int，如果不进行&0xff，那么当一个byte会转换成int时，对于负数，会做位扩展，举例来说，一个byte的-1（即0xff），会被转换成int的-1（即0xffffffff），那么转化出的结果就不是我们想要的了。而0xff默认是整形，所以，一个byte跟0xff相与会先将那个byte转化成整形运算，这样，结果中的高的24个比特就总会被清0，于是结果总是我们想要的。|
#### 4、代码：
```
/**
     * int到byte[]
     * @param i
     * @return
     */
    public static byte[] intToByteArray(int i) {   
          byte[] result = new byte[4];  
          //由高位到低位
          result[0] = (byte)((i >> 24) & 0xFF);
          result[1] = (byte)((i >> 16) & 0xFF);
          result[2] = (byte)((i >> 8) & 0xFF);
          result[3] = (byte)(i & 0xFF);
          return result;
    }
 
        /**
         * byte[]转int
         * @param bytes
         * @return
         */
        public static int byteArrayToInt(byte[] bytes) {
               int value=0;
               //由高位到低位
               for(inti = 0; i < 4; i++) {
                   int shift= (4-1-i) * 8;
                   value +=(bytes[i] & 0x000000FF) << shift;//往高位游
               }
               return value;
         }
```
