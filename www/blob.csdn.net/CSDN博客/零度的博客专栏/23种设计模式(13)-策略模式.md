# 23种设计模式(13)-策略模式 - 零度的博客专栏 - CSDN博客
2017年07月14日 10:51:26[零度anngle](https://me.csdn.net/zmx729618)阅读数：264
策略模式 
一、概述 
二、策略模式的结构 
三、具体案例 
四、认识策略模式    
**一、概述**
1.定义
策略模式属于对象行为型模式，主要针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响 到客户端的情况下发生变化。通常，策略模式适用于当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
2.策略模式有什么好处？ 
策略模式的好处在于你可以动态的改变对象的行为。
3.设计原则 
设计原则是把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。
二、策略模式的结构
　　策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里 面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模 式实例的结构。
![这里写图片描述](https://img-blog.csdn.net/20160131184527903)
角色 
●环境(Context)角色：持有一个Strategy的引用。
●抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
●具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。
源代码 
　　环境角色类
```java
public class Context {
    //持有一个具体策略的对象
    private Strategy strategy;
    /**
     * 构造函数，传入一个具体策略对象
     * @param strategy    具体策略对象
     */
    public Context(Strategy strategy){
        this.strategy = strategy;
    }
    /**
     * 策略方法
     */
    public void contextInterface(){
        strategy.strategyInterface();
    }
}
```
　　抽象策略类
```java
public interface Strategy {
    /**
     * 策略方法
     */
    public void strategyInterface();
}
```
　　具体策略类
```java
public class ConcreteStrategyA implements Strategy {
    @Override
    public void strategyInterface() {
        //相关的业务    }
}
```
```java
public class ConcreteStrategyB implements Strategy {
    @Override
    public void strategyInterface() {
        //相关的业务    }
}
```
```java
public class ConcreteStrategyC implements Strategy {
    @Override
    public void strategyInterface() {
        //相关的业务    }
}
```
三、具体案例 
刘备要到江东娶老婆了，走之前诸葛亮给赵云（伴郎）三个锦囊妙计，说是按天机拆开能解决棘手问题，嘿，还别说，真解决了大问题，搞到最后是周瑜陪了夫人又折兵，那咱们先看看这个场景是什么样子的。
先说说这个场景中的要素：三个妙计(具体策略角色)，一个锦囊(环境角色)，一个赵云(客户端)，妙计是亮哥给的，妙计放在锦囊里，俗称就是锦囊妙计嘛，那赵云就是一个干活的人，从锦囊取出妙计，执行，然后获胜。用java程序怎么表现这些呢？
那我们先来看看图
![这里写图片描述](https://img-blog.csdn.net/20160131184900879)
三个妙计是同一类型的东西，那咱就写个接口：
```java
/**抽象策略角色：
 *  首先定义一个策略接口，这是诸葛亮老人家给赵云的三个锦囊妙计的接口。
 * @author Administrator
 *
 */
public interface IStrategy {
     //每个锦囊妙计都是一个可执行的算法。它有三种不同的实现  
    public void operate();  
}
```
然后再写三个实现类，有三个妙计嘛：
妙计一：初到吴国：
```java
/**
 * 具体策略角色1：
 * 开后门 找乔国老帮忙，使孙权不能杀刘备
 * @author Administrator
 *
 */
public class BackDoor implements IStrategy {
    @Override
    public void operate() {
        System.out.println("找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备...");
    }
}
```
妙计二：求吴国太开个绿灯，放行：
```java
/**
 *  具体策略角色2：
 *      开绿灯 求吴国太开个绿灯。
 * @author Administrator
 *
 */
public class GivenGreenLight implements IStrategy {
    @Override
    public void operate() {
        System.out.println("求吴国太开个绿灯，放行！");
    }
}
```
妙计三：孙夫人断后，挡住追兵：
```java
/**
 * 具体策略角色3
 * 挡住追兵 孙夫人断后，挡住追兵
 * @author Administrator
 *
 */
public class BlackEnemy implements IStrategy {  
    @Override  
    public void operate() {  
        System.out.println("孙夫人断后，挡住追兵...");  
    }  
}
```
好了，大家看看，三个妙计是有了，那需要有个地方放妙计啊，放锦囊里：
```java
/**
 * 环境(Context)角色：
 * @author Administrator
 *
 */
public class Context {
    private IStrategy strategy;  
    //构造函数，要你使用哪个妙计  
    public Context(IStrategy strategy){  
        this.strategy = strategy;  
    }  
    public void operate(){  
        this.strategy.operate();  
    }  
}
```
然后就是赵云雄赳赳的揣着三个锦囊，拉着已步入老年行列，还想着娶纯情少女的，色咪咪的刘备老爷子去入赘了，嗨，还别说，亮哥的三个妙计还真不错，瞧瞧：
```
public class ZhaoYun {
     /** 
     * 赵云出场了，他根据诸葛亮给他的交代，依次拆开妙计 
     */  
    public static void main(String[] args) {  
        Context context;  
        //刚到吴国的时候拆开第一个  
        System.out.println("----------刚刚到吴国的时候拆开第一个---------------");  
        context = new Context(new BackDoor());  
        context.operate();//拆开执行  
        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n");  
        //当刘备乐不思蜀时，拆开第二个  
        System.out.println("----------刘备乐不思蜀，拆第二个了---------------");  
        context = new Context(new GivenGreenLight());  
        context.operate();//拆开执行  
        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n");  
        //孙权的小追兵了，咋办？拆开第三个锦囊  
        System.out.println("----------孙权的小追兵了，咋办？拆开第三个锦囊---------------");  
        context = new Context(new BlackEnemy());  
        context.operate();//拆开执行  
        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n");  
    }  
}
```
后话：就这三招，搞得的周郎是“赔了夫人又折兵”呀！这就是策略模式，高内聚低耦合的特点也表现出来了，还有一个就是扩展性，也就是OCP原则，策略类可以继续添加下去气，只是修改Context.java就可以了
**四、认识策略模式**
**策略模式的重心**
　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 
**算法的平等性**
　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。
**运行时策略的唯一性**
　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。 
**公有的行为**
　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。
这其实也是典型的将代码向继承等级结构的上方集中的标准做法。
![这里写图片描述](https://img-blog.csdn.net/20160131184425604)
**优点**
　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 
　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。
**缺点**
　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。
　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。
