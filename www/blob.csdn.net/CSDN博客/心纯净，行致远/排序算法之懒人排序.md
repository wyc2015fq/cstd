# 排序算法之懒人排序 - 心纯净，行致远 - CSDN博客





2017年10月02日 16:23:58[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：184标签：[c语言																[排序算法																[懒人排序](https://so.csdn.net/so/search/s.do?q=懒人排序&t=blog)
个人分类：[【C】](https://blog.csdn.net/zhanshen112/article/category/7184374)





排序算法很多，快速排序、堆排序、选择排序、冒泡排序等等。最近一周一直再看排序算法，多数比较容易理解，其中多数理解起来都比较容易，但是实现起来感觉堆排序比较麻烦，还要建堆和处理堆。

再看快速排序的时候，突然想到如果根据一个基准值将其他数字分为大小两堆，再在两堆内继续实行二分比较……如果注意观察排好序的元素其下标和值在大小上的对应关系：下标小的元素其值也必定比较小。就比较好编程了，只要元素的下标大小关系和值得大小关系不对应，就将两者调换，就可以实现排序。虽然理论上这种想法时间复杂度很高（n^2），但是空间复杂度不高。不过在处理海量数据时显然时间复杂度影响更大，所以这种懒人排序价值有限，博友们看看便好！



```cpp
//给定数组懒人排序（下标与值对应），从小到大排列。

#include <stdio.h>

int main()
{
	int i,j,t,k,gap;
	int a[10]={1,23,41,31,45,767,48,90,6,88};

	for(i=0;i<10;i++)
		for(j=0;j<10;j++)
		{
			if((i<j&&a[i]>a[j])||(i>j&&a[i]<a[j]))         
//原理非常容易理解，排列好的数组其下标和值的大小关系严格对应。即下标小对应的值一定小于下标大对应的值
			{
				t=a[i];                                   
				a[i]=a[j];
				a[j]=t;
			}


		}

	printf("\nThe sorted numbers are:\n");
	for(i=0;i<10;i++)
	{	
		printf("%5d",a[i]);
	}
	printf("\n\n end\n");
}
```](https://so.csdn.net/so/search/s.do?q=排序算法&t=blog)](https://so.csdn.net/so/search/s.do?q=c语言&t=blog)




