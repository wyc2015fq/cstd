# 1025 反转链表——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月23日 02:00:41[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：63








# 题目

> 
1025 反转链表 （25 分）

给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10​5​​)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。

接下来有 N 行，每行格式为：

```
Address Data Next
```

其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。

### 输出格式：

对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。

### 输入样例：

```
00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
```

### 输出样例：

```
00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
```


# 算法

还是要使用库函数……自己写的代码3问题多多……调试了一会，还仍然有两个问题。主要原因是没有考虑可能有输入的节点不能算在内的原因。但是显然库函数掌握的太少，要花点时间好好整理一下。

代码2柳婼女神的代码就很好，膜拜！！！我代码3中复杂的排序过程在柳婼的代码中只用到了两行，简直是数量级上的提升。代码的详细解释见下。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int first, k, n, temp;
    cin >> first >> n >> k;
    int data[100005], next[100005], list[100005];
    for (int i = 0; i < n; i++) {
        cin >> temp;
        cin >> data[temp] >> next[temp];    //以地址为索引存储数据和下一个的地址
    }
    int sum = 0;//不一定所有的输入的结点都是有用的，加个计数器
    while (first != -1) {    //对合理的输入进行计数，并且存起来，筛选掉断开的节点输入
        list[sum++] = first;
        first = next[first];
    }
    for (int i = 0; i < (sum - sum % k); i += k)    //只需要对需要反转的部分反转即可
        reverse(begin(list) + i, begin(list) + i + k);
    for (int i = 0; i < sum - 1; i++)    //输出的时候注意最后一个元素的特殊性
        printf("%05d %d %05d\n", list[i], data[list[i]], list[i + 1]);
    printf("%05d %d -1", list[sum - 1], data[list[sum - 1]]);
    return 0;
}
```

reverse()函数的用法：[C++头文件algorithm的reverse函数](https://blog.csdn.net/zhanshen112/article/details/84317577)

这道题目充分验证了数据机构的重要性。这道题目如果用数据结构来做，使用vector会变得很简单。但是如果自己去写各种函数，性能会很差，还有很多问题。就比如我自己写的代码，没有用到高级一点的数据结构，有100多行，花了一两天调试（当然也不是全在调试）才通过题目给的测试案例，但是提交的时候通过不了几个提交的案例，说明代码质量还是太差。看来还是要好好学习更多的数据结构，要不然用原始人的方法征服不了星辰大海，哈哈哈

# 代码

1、C++

```cpp
//PAT1025V2 
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
struct node{
	int address;
	int data;
	int next;
};
int main(){
	int N,first,K,i;
	vector<node> shunxu,reverse;
	cin>>first>>N>>K;
	node n;	//临时节点 
	node addr[100000];	//链表数组
	for(i=0;i<N;i++){
		cin>>n.address>>n.data>>n.next;
		addr[n.address]=n;	//将节点赋值到相应下标的位置 
	} 
	int nextaddress=first;
	while(nextaddress!=-1){	//通过next作为下标寻找元素，添加到vector中，更新next继续寻找
		shunxu.push_back(addr[nextaddress]);
		nextaddress=addr[nextaddress].next ; 
	} 
	int size=shunxu.size();	//输入的节点可能有些不在链表中，记录链表长度
	int tmp=K-1;
	while(tmp<size){	//反转链表，每次翻转K个，不足k个不反转并退出循环
		for(i=tmp;i>tmp-K;i--)	reverse.push_back(shunxu[i]);  //每段内倒过来翻转 
		tmp+=K;
	} 
	for(i=tmp-K+1;i<size;i++) reverse.push_back(shunxu[i]);	//将最后没有反转的，复制到反转之后的链表
	for(i=0;i<size-1;i++){	//修改它们的next ，改为下一个元素的address
		reverse[i].next=reverse[i+1].address;
		printf("%05d %d %05d\n",reverse[i].address,reverse[i].data,reverse[i].next); 
	} 
	printf("%05d %d %d\n",reverse[size-1].address,reverse[size-1].data,-1); 
}
```

2、柳婼代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int first, k, n, temp;
    cin >> first >> n >> k;
    int data[100005], next[100005], list[100005];
    for (int i = 0; i < n; i++) {
        cin >> temp;
        cin >> data[temp] >> next[temp];
    }
    int sum = 0;//不一定所有的输入的结点都是有用的，加个计数器
    while (first != -1) {
        list[sum++] = first;
        first = next[first];
    }
    for (int i = 0; i < (sum - sum % k); i += k)
        reverse(begin(list) + i, begin(list) + i + k);
    for (int i = 0; i < sum - 1; i++)
        printf("%05d %d %05d\n", list[i], data[list[i]], list[i + 1]);
    printf("%05d %d -1", list[sum - 1], data[list[sum - 1]]);
    return 0;
}
```

3、代码仍有问题。估计是**没有考虑输入样例中有不在链表中的结点的情况**

```cpp
//1025
#include <iostream>
#include <algorithm>
using namespace std;
struct node{
	int addr,data,next;
};
int cmp(node a,node b){
	return a.data <b.data ;
}
int main(){
	int i,j,fstaddr,N,K;	cin>>fstaddr>>N>>K;
	node list[N];
	for(i=0;i<N;i++)	cin>>list[i].addr >>list[i].data >>list[i].next ;
	sort(list,list+N,cmp);	//min to max
	for(i=0;i<N/K;i++){
		if(i<N/K-1){	//K分段的倒数第一段之前 
			for(j=K-1;j>0;j--){	//K-1个 
			printf("%05d %d %05d\n",list[i*K+j].addr ,list[i*K+j].data ,list[i*K+j-1].addr);
			}
			printf("%05d %d %05d\n",list[i*K].addr ,list[i*K].data ,list[i*K+2*K-1].addr);
		}
		else{	//K分段的倒数第一段
			for(j=K-1;j>0;j--){	//前K-1个 
			printf("%05d %d %05d\n",list[i*K+j].addr ,list[i*K+j].data ,list[i*K+j-1].addr);
			}
			//最后一个 
			if(N%K!=0) printf("%05d %d %05d\n",list[i*K].addr ,list[i*K].data ,list[(N/K)*K].addr);
			else	printf("%05d %d -1\n",list[i*K].addr ,list[i*K].data);
		}	
	}
	for(i=(N/K)*K;i<N;i++){
		if(i<N-1)	
                printf("%05d %d %05d\n",list[i].addr ,list[i].data ,list[i].next);
		else printf("%05d %d -1\n",list[i].addr ,list[i].data);
	}	
	return 0;
}

/*
00100 6 3
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
*/
```

4、 我自己最开始的拙劣代码：

```cpp
//PAT1025V1
#include <stdio.h>

int main(){
    double i;
    int n,j,m=0,k,t;
    scanf("%lf %d %d",&i,&n,&k);    //i是首地址，是排序的关键 
    struct ChainTable{
        double add;
        int value;
        double NextAdd;
    }NodeInf[n],SortNode[n];
    for(j=0;j<n;j++){
        scanf("%lf %d %lf",&NodeInf[j].add,&NodeInf[j].value,&NodeInf[j].NextAdd);
    }

    //sort  原节点NodeInf[]排列之后为SortNode[] 
    j=0;
    while(j!=6){
        for(m=0;m<n;m++){
            if(NodeInf[m].add==i){
                if(NodeInf[m].NextAdd!=-1){
                    SortNode[j].add=NodeInf[m].add;
                    SortNode[j].value=NodeInf[m].value;
                    SortNode[j].NextAdd=NodeInf[m].NextAdd;
//                  printf("\n%05d %d %05d",NodeInf[m].add,NodeInf[m].value,NodeInf[m].NextAdd);    //0的位数补全方法 
                }   
                else{
                    SortNode[j].add=NodeInf[m].add;
                    SortNode[j].value=NodeInf[m].value;
                    SortNode[j].NextAdd=NodeInf[m].NextAdd;
//                  printf("\n%05d %d %d",NodeInf[m].add,NodeInf[m].value,NodeInf[m].NextAdd);
                }   
                i=NodeInf[m].NextAdd;
                j++;
            //  break;
            }
        }   
    } 
/*  
    for(m=0;m<n;m++){
        if(SortNode[m].NextAdd!=-1){
            printf("\n%05d %d %05d",SortNode[m].add,SortNode[m].value,SortNode[m].NextAdd); //0的位数补全方法 
        }   
        else{
            printf("\n%05d %d %d",SortNode[m].add,SortNode[m].value,SortNode[m].NextAdd);
       }    
    }
    printf("\n\n");
*/  
    //reverse
    //first step:divide 分段
    int d=n/k,y=n%(int)(k);     //分成d段，段内反转;剩余y个 
//  printf("%d %d",d,y);

    //second step:reverse in the section loop
    if(y!=0){   //分段之后有剩余 
        for(j=1;j<=d;j++){  //每段进行reverse 
            for(m=j*k-1;m>=(j-1)*k;m--){    //逆序输出 
                if(j<=d-1){     //倒数第二段(包含）之前的处理办法 
                    if(m>(j-1)*k)   // 倒数第二段之前的分段中倒数第二个元素（包含）之前的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m-1].add); //0的位数补全方法
                    else    // 倒数第二段之前的分段中最后一个元素的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m+1+k].add);   //0的位数补全方法
                }
                else{   //最后一段的处理办法 
                    if(m>(j-1)*k)   // 最后一段的分段中倒数第二个元素（包含）之前的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m-1].add); //0的位数补全方法
                    else    // 最后一段的分段中最后一个元素的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m+k].add); //0的位数补全方法
                }            
            }
        } 
        for(t=d*k;t<n;t++){ //分段剩余部分直接输出 
            if(SortNode[t].NextAdd!=-1) 
                printf("%05.0lf %d %05.0lf\n",SortNode[t].add,SortNode[t].value,SortNode[t].NextAdd);   //0的位数补全方法 
            else 
                printf("%05.0lf %d -1",SortNode[t].add,SortNode[t].value);
        }

    } 
    if(y==0){   //分段之后无剩余 
        for(j=1;j<=d;j++){  //每段进行reverse 
            for(m=j*k-1;m>=(j-1)*k;m--){    //逆序输出 
                if(j<=d-1){     //倒数第二段(包含）之前的处理办法 
                    if(m>(j-1)*k)   // 倒数第二段之前的分段中倒数第二个元素（包含）之前的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m-1].add); //0的位数补全方法
                    else    // 倒数第二段之前的分段中最后一个元素的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m+1+k].add);   //0的位数补全方法
                }
                else{   //最后一段的处理办法 
                    if(m>(j-1)*k)   // 最后一段的分段中倒数第二个元素（包含）之前的处理办法
                        printf("%05.0lf %d %05.0lf\n",SortNode[m].add,SortNode[m].value,SortNode[m-1].add); //0的位数补全方法
                    else    // 最后一段的分段中最后一个元素的处理办法
                        printf("%05.0lf %d -1",SortNode[m].add,SortNode[m].value);    //0的位数补全方法    
                }            
            }
        }   
    }   
}
```





