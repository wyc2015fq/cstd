# 1057 数零壹——c实现 - 心纯净，行致远 - CSDN博客





2018年11月06日 22:35:25[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：63








> 
1057 数零壹 （20 分）

给定一串长度不超过 10​5​​ 的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 `PAT (Basic)`，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。

### 输入格式：

输入在一行中给出长度不超过 10​5​​、以回车结束的字符串。

### 输出格式：

在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。

### 输入样例：

```
PAT (Basic)
```

### 输出样例：

```
3 4
```


# **思路：**

这道题的思路很明确：
- 存储数组；
- 全部转化为小写；
- 统计a~z字母之和；
- 转化为2进制，统计0和1的位数；

注意：当a~z字母之和为0时的特殊性，可能会导致0和1数的位数部队。因此判断之前需要先判断sum!=0，才可以进行转换。

# **代码：**

```cpp
//1057 数零壹v1
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main(){
	char str[100005]={0},str1[100005]={0},c;
	int i=0,cnt_0=0,cnt_1=0;
	long long int sum=0; 
//	fgets(str,100005,stdin);    //也可以用这句代码代替下面一行，都可以一次读入一行用户输入
	while((c=getchar())!='\n')  str[i++]=c;
	for(i=0;i<strlen(str);i++){
		str1[i]=tolower(str[i]);
		if(isalpha(str1[i]))	sum+=(str1[i]-'a'+1); 
	}	
	if(sum){
		while(sum/2)	//	sum/2!=0
		{
			if(sum%2==0)	cnt_0++;
			if(sum%2==1)	cnt_1++;
			sum/=2;
		}
		cnt_1++;
	}
	printf("%d %d",cnt_0,cnt_1);
	
}
```





