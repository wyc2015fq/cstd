# 1019 数字黑洞——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月23日 00:59:16[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：36








# 题目

> 
1019 数字黑洞 （20 分）

给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。

例如，我们从`6767`开始，将得到

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
```

现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。

### 输入格式：

输入给出一个 (0,10​4​​) 区间内的正整数 N。

### 输出格式：

如果 N 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。

### 输入样例 1：

```
6767
```

### 输出样例 1：

```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
```

### 输入样例 2：

```
2222
```

### 输出样例 2：

```
2222 - 2222 = 0000
```


# 算法

现在来做这道题，已经学会使用sort函数，因此简单了很多，也省了很多。看了一下以前写的C，其实思路还是没有变化。只是由于掌握更多的知识，因此代码量减少了很多，原来的两个子函数在这里只是两句sort()语句。工具很重要，工具可以塑造人的思维。见代码1/2两部分。

看了柳婼的代码，是将数字作为字符串处理，但是也要解决不不够四位补零的问题，相比之下，数字计算就没有这个问题。但是取出各位数字麻烦一些。    见代码3。

算法：每次讲四个数字取出来再升序排列依次，降序排列一次，作差直道出现6174和0000停止。

# 代码

代码1、C

```cpp
//PAT1019V1
#include <stdio.h>

int FeiDiZeng(int n){
	int a[4];
	a[0]=n%10;	//ge
	a[1]=n/10%10;	//shi
	a[2]=n/100%10;	//bai
	a[3]=n/1000;	//qian
	int tmp,i,j;
	for(i=0;i<3;i++){
		for(j=i+1;j<4;j++){
			if(a[i]<a[j]){	//a[0] is max
				tmp=a[j];
				a[j]=a[i];
				a[i]=tmp;
			}
		}
	}
	return a[0]*1000+a[1]*100+a[2]*10+a[3];	
}

int FeiDiJian(int n){
	int a[4];
	a[0]=n%10;	//ge
	a[1]=n/10%10;	//shi
	a[2]=n/100%10;	//bai
	a[3]=n/1000;	//qian
	int tmp,i,j;
	for(i=0;i<3;i++){
		for(j=i+1;j<4;j++){
			if(a[i]>a[j]){
				tmp=a[j];
				a[j]=a[i];
				a[i]=tmp;
			}
		}
	}
	return a[0]*1000+a[1]*100+a[2]*10+a[3];	
}

int main(){
	int n,a[4];
	scanf("%d",&n);
	a[0]=n%10;	//ge

	a[1]=n/10%10;	//shi
	a[2]=n/100%10;	//bai
	a[3]=n/1000;	//qian

//	if(a[0]==a[1]==a[2]==a[3]){	//debug
	if(a[0]==a[1]&&a[1]==a[2]&&a[2]==a[3]){	
		printf("%d - %d = 0000",n,n);
	}
	else{
		int FDZ=FeiDiZeng(n),FDJ=FeiDiJian(n);	
		while(FDZ-FDJ!=6174){
			const int result=FDZ-FDJ;
			printf("%04d - %04d = %04d\n",FDZ,FDJ,result);
			FDZ=FeiDiZeng(result);
			FDJ=FeiDiJian(result);
		}
		printf("%04d - %04d = %04d\n",FDZ,FDJ,FDZ-FDJ);

	}	

}
```

代码2、C++

```cpp
//1019
#include <iostream>
#include <algorithm>
using namespace std;

int cmp(int a,int b){	//max to min 
	return a>b?1:0;
}
int main(){
	int n,a[4]={0},b,c,t;	cin>>n;
	t=n;
	do{
		a[0]=t/1000;
  		a[1]=t%1000/100;
		a[2]=t%1000%100/10;
		a[3]=t%10;
		sort(a,a+4,cmp);
		b=a[0]*1000	+a[1]*100+a[2]*10+a[3];
		sort(a,a+4);	//min to max
		c=a[0]*1000	+a[1]*100+a[2]*10+a[3];
		t=b-c;
		printf("%04d - %04d = %04d\n",b,c,t);
	}while(t!=6174&&t!=0000);
	return 0;
}
```

代码3、柳婼的思路

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
bool cmp(char a, char b) {return a > b;}
int main() {
    string s;
    cin >> s;
    s.insert(0, 4 - s.length(), '0');
    do {
        string a = s, b = s;
        sort(a.begin(), a.end(), cmp);
        sort(b.begin(), b.end());
        int result = stoi(a) - stoi(b);
        s = to_string(result);
        s.insert(0, 4 - s.length(), '0');
        cout << a << " - " << b << " = " << s << endl;
    } while (s != "6174" && s != "0000");
    return 0;
}
```





