# 1090 危险品装箱——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月30日 19:52:32[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：81








# 题目

> 
1090 危险品装箱 （25 point(s)）

集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。

本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。

### 输入格式：

输入第一行给出两个正整数：N (≤10​4​​) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。

随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：

```
K G[1] G[2] ... G[K]
```

其中 `K` (≤1000) 是物品件数，`G[i]` 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。

### 输出格式：

对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 `Yes`，否则输出 `No`。

### 输入样例：

```
6 3
20001 20002
20003 20004
20005 20006
20003 20001
20005 20004
20004 20006
4 00001 20004 00002 20003
5 98823 20002 20003 20006 10010
3 12345 67890 23333
```

### 输出样例：

```
No
Yes
Yes
```


# 算法

见到映射关系很容易想到map，但是这里map用一对一肯定不行，因为输入里面可能会一对多。即一个物品可能与多个物品不相容。因此不能建立map<int,int>类型，而是要建立map<int,vector<int>>类型。

在查找的时候，需要将M个的每一行存起来，然后查找每一个对应的map，看是否能找到，找得到则有不相容，反之相容。这里map里面的value实际上是一个vector。

# 代码

```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;
int main(){
	int N,M,t1,t2;	cin>>N>>M;
	map<int,vector<int>> idx;
	for(int i=0;i<N;i++){
		cin>>t1>>t2;
		idx[t1].push_back(t2);
		idx[t2].push_back(t1);
	}
	for(int i=0;i<M;i++){
		int cnt,flag=0,a[100000]={0};
		cin>>cnt;
		vector<int> v(cnt);
		for(int i=0;i<cnt;i++){
			cin>>v[i];
			a[v[i]]=1;    //有的物品都设置为1
		} 
		for(int i=0;i<cnt;i++)
			for(int j=0;j<idx[v[i]].size();j++) //查找每一个map的vector型value
				if(a[idx[v[i]][j]]==1){    //if search,it means not match
					flag=1;
					break;
				} 
		printf("%s\n",flag?"No":"Yes");
	}
	return 0;
}
```





