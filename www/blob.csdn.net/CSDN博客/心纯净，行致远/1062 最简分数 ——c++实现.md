# 1062 最简分数 ——c++实现 - 心纯净，行致远 - CSDN博客





2018年11月12日 10:34:59[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：346








题目：

> 
1062 最简分数 （20 point(s)）

一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。

现给定两个不相等的正分数 N​1​​/M​1​​ 和 N​2​​/M​2​​，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。

### 输入格式：

输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。

### 输出格式：

在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。

### 输入样例：

```
7/18 13/20 12
```

### 输出样例：

```
5/12 7/12
```


思路：

这道题关键的是要判断找到的分子范围内的数与分母是不是可以约分。可以单独写一个函数，如下面的judge（）函数。如果找到可以约分的公因子，说明不是最简分数，返回0，否则返回1。

这道题我最早的思路是直接用题目输入的分母K除以经计算得到的分子i，这样计算是有问题的。比如56/72这样明明不是最简分数，却也是符合k/i!=0的。因此还是应该从2到i开始遍历，只要找到可以约分的数，就说明不是最简分数。后来我想不单独写一个函数去实现是不是最简分数的判断，调试了好久，终于调通了~~~

代码：

```cpp
//1062 最简分数v1
#include <iostream>
using namespace std;
int judge(int a,int k)
{
    for(int i=2;i<=a;i++)
        if(a % i == 0 && k % i == 0)
            return 0;
    return 1; //最简
}
int main(){
	int n1,m1,n2,m2,k,min,max,i=0,j=0,tmp;
	scanf("%d/%d %d/%d %d",&n1,&m1,&n2,&m2,&k);
	max=(int)(k*n2/m2);
	min=(int)(k*n1/m1);
	if(max<=min){
		tmp=max;
		max=min;
		min=tmp;
	}
	min=min+1;
	if(max==1.0*k*n2/m2)	max=max-1;
	for(i=min;i<=max;i++){	
			if(judge(i,k))	printf("%d/%d%c",i,k,i==max?'\n':' ');			
	}
	return 0;
}
```

不单独写一个judge（）函数的代码：

```cpp
//1062 最简分数v2
#include <iostream>
using namespace std;

int main(){
	int n1,m1,n2,m2,k,min,max,i=0,j=0,tmp;
	scanf("%d/%d %d/%d %d",&n1,&m1,&n2,&m2,&k);
	max=(int)(k*n2/m2);
	min=(int)(k*n1/m1);
	if(max<=min){
		tmp=max;
		max=min;
		min=tmp;
	}
	min=min+1;
	if(max==1.0*k*n2/m2)	max=max-1;
	int flag=1;
	for(i=min;i<=max;i++){	
		for(j=2;j<=i;j++){
			if(k%j==0&&i%j==0) flag=0;	
		}			
		if(flag==1)	printf("%d/%d%c",i,k,i==max?'\n':' ');	
		flag=1;	
	}
	return 0;
}
```





