# 1066 图像过滤——c++实现 - 心纯净，行致远 - CSDN博客





2018年11月13日 10:22:01[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：92








题目：

> 
1066 图像过滤 （15 point(s)）

图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。

### 输入格式：

输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0<M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A<B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。

### 输出格式：

输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 `000`），其间以一个空格分隔。行首尾不得有多余空格。

### 输入样例：

```
3 5 100 150 0
3 189 254 101 119
150 233 151 99 100
88 123 149 0 255
```

### 输出样例：

```
003 189 254 000 000
000 233 151 099 000
088 000 000 000 255
```


思路：

这道题目思路很简单，用c很容易实现。但是如果用c++实现，稍微不注意可能会出现超时的问题。后来经过查证，主要是因为

> 
iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能，设置为false后，不再同步了，iostream的性能提高了很多倍。


> 
可以用下面两个代码

来加速cin 与cout ，这样cin的速度就和sanf差不多了，

注意，这两个代码的头文件是 iostream

并且如果用了这两个，就不要用scanf ,getchar,gets,fgets,fscanf了，

他的作用是关于 iostream和stdio的同步，让c++和c的输入出不在挂钩了（具体原理我也不清楚哈）

还有就是，用“\n”而不是 endl，也可以提高速度。

std::ios::sync_with_stdio(false);

    cin.tie(0);

第二个是取消cin与cout的绑定，去掉了也没用。

但是数据量大还是推荐用scanf，

开加速也可能会卡。


因此，可以在使用cin之前加上一句代码

```cpp
cin.sync_with_stdio(false);
```

来关闭同步，提高速度。关于上面这一行代码的具体理解，可参考：[关于ios::sync_with_stdio(false);的最好文章](https://blog.csdn.net/zhanshen112/article/details/84024405)

代码：

c++实现

```cpp
#include <iostream>
using namespace std;

int main() {
    int M, N, A, B, replace, tmp, i;
    cin >> M >> N >> A >> B >> replace;
    cin.sync_with_stdio(false);    //也可以放在主函数里面的最前面
    for (i = 0; i < N*M; i++) {
        cin >> tmp;
        if (tmp >= A && tmp <= B)  
            tmp = replace;
        printf("%03d%c", tmp, (i + 1) % N == 0 ? '\n' : ' ');
    }
    return 0;
}
```

c实现

```cpp
//1066 图像过滤V1
#include <stdio.h> 

int main(){
	int M,N,A,B,replace,tmp,i,j;	scanf("%d%d%d%d%d",&M,&N,&A,&B,&replace);
	for(i=0;i<M*N;i++){
			scanf("%d",&tmp);
			if(tmp>=A&&tmp<=B)	tmp=replace;
			printf("%03d%c",tmp,(i+1)%N==0?'\n':' ');
	}
	return 0;
}
```





