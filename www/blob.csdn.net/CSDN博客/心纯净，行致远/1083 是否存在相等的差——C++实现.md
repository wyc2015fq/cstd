# 1083 是否存在相等的差——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月30日 11:47:08[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：56








# 题目

> 
1083 是否存在相等的差 （20 point(s)）

给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？

### 输入格式：

输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。

### 输出格式：

按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。

### 输入样例：

```
8
3 5 8 6 2 1 4 7
```

### 输出样例：

```
5 2
3 3
2 2
```


# 算法

这道题很简单。代码1借助map和普通数组实现，代码2借助map/vector，代码3只用普通方法采用hash映射即可实现

# 代码

1、使用map和普通数组

```cpp
#include <iostream>
#include <map>
using namespace std;
int main(){
	int N,cnt=0;	cin>>N;
	map<int,int> mp;
	int a[N],b[N];
	for(int i=0;i<N;i++){
		cin>>a[i];
		b[i]=abs(i+1-a[i]);
	}
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			if(b[i]==b[j]&&mp[b[i]]==0)	cnt++;
		}
		if(mp[b[i]]==0) mp[b[i]]=cnt;
		cnt=0;
	}	
	for(auto it=mp.rbegin();it!=mp.rend();it++)	
		if(it->second>1)	cout<<(it->first)<<" "<<(it->second)<<endl;
	return 0;
}
```

2、使用map和vector

```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;
int main(){
	int N,cnt=0,tmp;	cin>>N;
	map<int,int> mp;
	vector<int> a;
	for(int i=0;i<N;i++){
		cin>>tmp;
		a.push_back(abs(i+1-tmp));
	}
	for(int i=0;i<a.size();i++){
		for(int j=0;j<a.size();j++){
			if(a[i]==a[j]&&mp[a[i]]==0)	cnt++;
		}
		if(mp[a[i]]==0) mp[a[i]]=cnt;
		cnt=0;
	}	
	for(auto it=mp.rbegin();it!=mp.rend();it++)	
		if(it->second>1)	cout<<(it->first)<<" "<<(it->second)<<endl;
	return 0;
}
```

3、hash散列映射

```cpp
#include <iostream>
using namespace std;
int main(){
	int N,cnt=0,tmp;	cin>>N;
	int a[N]={0};
	for(int i=0;i<N;i++){
		cin>>tmp;
		a[abs(i+1-tmp)]++;
	}
	for(int i=N-1;i>=0;i--)	
		if(a[i]>1)	cout<<i<<" "<<a[i]<<endl;
	return 0;
}
```





