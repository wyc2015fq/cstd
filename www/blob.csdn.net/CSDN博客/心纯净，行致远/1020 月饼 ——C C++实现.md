# 1020 月饼 ——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月23日 01:30:29[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：79








# 题目

> 
1020 月饼 （25 分）

月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。

注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。

### 输入格式：

每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。

### 输出格式：

对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。

### 输入样例：

```
3 20
18 15 10
75 72 45
```

### 输出样例：

```
94.50
```


# 算法

典型的贪心算法的使用。不过这道题并不需要算法的知识，有小学知识就可以做出来。代码1是一个月前用C实现的。里面的排序可以按照单价进行排序，这样根据市场需求量输出就很方便。这也是代码2我所实现的改良的部分。至于输出部分只要根据库存判断即可。代码2提交还有三个测试案例未通过，待解决——主要问题是不一定就只有三种月饼，其次输入的库存/价格不一定是int，最好用double。见AC的代码3。

# 代码

1、C

```cpp
//PAT1020V1
#include <stdio.h>

int main(){
	int n,need,i,j;    scanf("%d %d",&n,&need);
	double tmpC,tmpA,tmpB,sum=0;
	struct mooncake{
		double a;	//库存量 
		double b;	//总售价 
		double c;	//单价 
	}cake[1000];
	
	for(i=0;i<n;i++)    scanf("%lf",&cake[i].a);
	for(i=0;i<n;i++)    scanf("%lf",&cake[i].b);
	for(i=0;i<n;i++)    cake[i].c=cake[i].b/cake[i].a;	//单价 

	//sort
	for(i=0;i<n-1;i++){
		for(j=i+1;j<n;j++){
			if(cake[i].c<cake[j].c){
				//
				tmpC=cake[j].c;
				cake[j].c=cake[i].c;
				cake[i].c=tmpC;
				//
				tmpB=cake[j].b;
				cake[j].b=cake[i].b;
				cake[i].b=tmpB;
				//
				tmpA=cake[j].a;
				cake[j].a=cake[i].a;
				cake[i].a=tmpA;
			}
		}
	}
	//sale
	for(i=0;i<n;i++){
		if(need>=cake[i].a){
			sum+=cake[i].b;
			need-=cake[i].a;
		}
		else if(need<cake[i].a&&need>0){
			sum+=need*cake[i].c;
			need=0;
		}
		else if(need==0){
			break;
		}		
	}
	printf("%.2lf",sum);

}
```

2、C++

```cpp
//1020
#include <iostream>
#include <algorithm>
using namespace std;
struct mooncake{
    int kucun,total;
    double price;
};
int cmp(mooncake a,mooncake b){
    return a.price >b.price ;
}
int main(){
    int N,D;    cin>>N>>D;
    double sum=0.0;
    mooncake m[N];
    for(int i=0;i<N;i++)    cin>>m[i].kucun;
    for(int i=0;i<N;i++)    cin>>m[i].total;
    for(int i=0;i<N;i++)    m[i].price=(double)m[i].total/(double)m[i].kucun;
    sort(m,m+N,cmp);
    if(m[0].kucun>=D)   
        printf("%.2lf",D*m[0].price);
    if(m[0].kucun+m[1].kucun>=D&&m[0].kucun<D)  
        printf("%.2lf",m[0].total+(D-m[0].kucun)*m[1].price);   
    if(m[0].kucun+m[1].kucun+m[2].kucun>=D&&m[0].kucun+m[1].kucun<D)            
        printf("%.2lf",m[0].total+m[1].total+(D-m[0].kucun-m[1].kucun)*m[2].price);
    if(m[0].kucun+m[1].kucun+m[2].kucun<D) 
        printf("%.2lf",m[0].total+m[1].total+m[2].total);
    return 0;
}
```

3、AC

```cpp
//1020
#include <iostream>
#include <algorithm>
using namespace std;
struct mooncake{
    double kucun,total;
    double price;
};
int cmp(mooncake a,mooncake b){
    return a.price >b.price ;
}
int main(){
    int N,D;    cin>>N>>D;
    double sum=0.0;
    mooncake m[N];
    for(int i=0;i<N;i++)    cin>>m[i].kucun;
    for(int i=0;i<N;i++)    cin>>m[i].total;
    for(int i=0;i<N;i++)    m[i].price=(double)m[i].total/(double)m[i].kucun;
    sort(m,m+N,cmp);
    for(int i=0;i<N;i++){
    	if(m[i].kucun <=D)    sum+=m[i].total;
	else{
		sum+=D*m[i].price ;
		break;
	}
	D=D-m[i].kucun ;
        if(D==0)    break;
    } 
    printf("%.2lf",sum);
    return 0;
}
```





