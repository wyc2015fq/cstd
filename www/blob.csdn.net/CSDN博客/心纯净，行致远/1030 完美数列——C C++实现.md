# 1030 完美数列——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年12月04日 10:01:57[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：190








# 题目

> 
1030 完美数列 （25 point(s)）

给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。

现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。

### 输入格式：

输入第一行给出两个正整数 N 和 p，其中 N（≤10​5​​）是输入的正整数的个数，p（≤10​9​​）是给定的参数。第二行给出 N 个正整数，每个数不超过 10​9​​。

### 输出格式：

在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。

### 输入样例：

```
10 8
2 3 20 4 5 1 6 7 8 9
```

### 输出样例：

```
8
```


# 算法

首先将输入的数字进行sort排序，从小到大。然后设定i,j记录符合的数组位置，count记录符合要求的中间数字的多少，初始为0，i从0~n，j从i+count开始，找到符合要求的j时（M≤mp），计算j-i+1与count的大小，比count大就进行更新。

下一次计算时，j直接从i+count开始，因为必然要满足统计的j-i+1要大于count才会记录，因此这里很巧妙，避免了还从j=i+1开始计算。最后输出count。

注意p是10^9，因此用int存储不了，直接都用long int比较好。

# 代码

1、C

```cpp
//PAT1030V1
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std; 
int main(){
	double p;
	int n,i,j,count=0;
	scanf("%d %lf",&n,&p);
	double a[n];
	for(i=0;i<n;i++)
		scanf("%lf",&a[i]);	
	sort(a,a+n);	
	for(i=0;i<n;i++){	//遍历，将a[i]作为最小值 
		for(j=i+count;j<n;j++){	//j为要满足可以更新数列长度的值，减少循环次数 
			if(a[j]>a[i]*p)
				break;
			if(j-i+1>count)
				count=j-i+1; 
		}
	}
	printf("%d",count);
	return 0;
}
```

2、C++

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
	long int N,p,cnt=0;	cin>>N>>p;
	vector<int> v(N);
	for(int i=0;i<N;i++)	cin>>v[i];
	sort(v.begin() ,v.end() );
	for(int i=0;i<N;i++){
		for(int j=i+cnt;j<N;j++){
			if(v[j]>p*v[i])	break;
			if(j-i+1>cnt)	cnt=j-i+1;
		}
	}
	cout<<cnt;
	return 0;
}
```





