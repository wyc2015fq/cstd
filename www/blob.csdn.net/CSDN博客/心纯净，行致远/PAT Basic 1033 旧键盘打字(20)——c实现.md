# PAT Basic 1033. 旧键盘打字(20)——c实现 - 心纯净，行致远 - CSDN博客





2018年10月31日 15:32:35[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：39








> 
题目


旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？

    输入格式：

    输入在2行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过10^5个字符的串。可用的字符包括字母[a-z, A-Z]、数字0-9、以及下划线“_”（代表空格）、“,”、“.”、“-”、“+”（代表上档键）。题目保证第2行输入的文字串非空。

    注意：如果上档键坏掉了，那么大写的英文字母无法被打出。

    输出格式：

    在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。

    输入样例：

    7+IE.

    7_This_is_a_test.

    输出样例：

    _hs_s_a_tst


思路

这道题目开始没有特别明确的思路。想着用两个字符串进行存储，然后逐个比对，但是还需要第三个字符串去存储特殊的字符才行……总之没有特别好的思路。

> 
学习了一下网上的教程，比较好的思路是这样的：

    读取：在记录坏键的时候很多种键，但是都是ASCII字符，因此用一个int[128]数组记录就好了，一视同仁，简单粗暴。

    输出：第二行是不会有'+'符号的，因此除了大写字母要特殊判断，只要这个键没有坏（数组没有记录），不管是哪一类符号，输出就行了。

    使用边读取边处理的方式，空间占用降到最低。

    toupper函数对非字母字符会返回参数本身，因此记录/查找的时候不必区分字符类型，全都转换成大写。

这种方法比有多少种字符就创建多大的数组去记录要方便的多，代码量极少。

注意：第一行可能为空，使用scanf这样跳过空白字符的函数就不行了。我一开始就用的逐字符读取的方法，每次读到换行，一直都没有发觉这一点……


所以相应思路也就出来了：
- 定义ASCII的128个整形字符串，初始为0；
- 读到一个坏键，将其都转化为大写字母，就置为1，这样知道哪个件事坏的。当然前提是读到换行为止，同时只要置为1就可以，坏键一般也就出现一次吧，两次置为1也完全没问题呀；
- 读到第二个字符串时，如果不是坏键（也就是值为1，!bad[toupper(c)]），同时还不是大写字母，这里“+”的特殊性。如果是+，同时判断读到的是不是大写字母，这里用到了<ctype.h>的isupper函数。如果是，则仍不输出。思路有一些乱，整理下是这样的：只需要判断输出的条件，如果输出第二行的字符，说明字符本身不是坏键，同时还得满足如果是大写字母，那第一行中就没有“+”。

代码如下：

```cpp
//PAT1033V1
#include <stdio.h>
#include <ctype.h>
int main()
{
    char c;
    int bad[128] = {0}; /* record keys are broken or not */
 
    while((c = getchar()) != '\n')      /* read broken keys */
        bad[toupper(c)] = 1;
 
    while((c = getchar()) != '\n')      /* read string and print */
        if(!bad[toupper(c)] && !(isupper(c) && bad['+']))
              putchar(c);

    return 0;
}
```





