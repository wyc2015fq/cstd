# 1042 字符统计——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月03日 12:05:49[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：228








> 
1042 字符统计 （20 point(s)）

请编写程序，找出一段给定文字中出现最频繁的那个英文字母。

### 输入格式：

输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。

### 输出格式：

在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。

### 输入样例：

```
This is a simple TEST.  There ARE numbers and other symbols 1&2&3...........
```

### 输出样例：

```
e 7
```


# 思路：

**1、数据存储的方法**

这道题的刚开始看题感觉不对，明明输入最后的省略号个数大于7呀，没有多想感觉可以用a[128]将ascii码撸一遍实现。但是后来运行结果和理论结果不一样，才知道人家统计的是英文字母。但是也完全没有影响呀，可以直接从a对应的ascii码97开始遍历呀。为什么是a而不是A，是因为输出是小写。由于输入有大写，因此可以将所有输入都转换为小写即可。

对应部分代码如下：

```cpp
int a[128]={0},i;
	char c;
	while((c=tolower(getchar()))!='\n')	a[(int)c]++;
```

**2、输出的判断**

由于题目说：

> 
在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。


因此，可以用一个key-value组合来存储字母（要转化为数字）和字母数量。同时首先选出value多的，其次如果value相等，而且目前的key比较大的话，就要更新成比较小的。

对应代码如下：


```cpp
int max[2]={0,0};	//max[0]=key,max[1]=value
	for(i=97;i<123;i++){
		if(max[1]<a[i]){	//选value多的
			max[0]=i;
			max[1]=a[i];
		}
		if(max[1]==a[i]&&max[0]>i){	//个数一样多的话，如果现在的key比较大，才更新 
			max[0]=i;
			max[1]=a[i];
		}
	}
```

2018.12.04 先进行判断是不是英文字母也是可以的，见代码2.



# 完整代码如下：

代码1、C

```cpp
//1042 字符统计 v1
#include <stdio.h>
#include <ctype.h>

int main(){
	int a[128]={0},i;
	char c;
	while((c=tolower(getchar()))!='\n')	a[(int)c]++;
	int max[2]={0,0};	//max[0]=key,max[1]=value
	for(i=97;i<123;i++){
		if(max[1]<a[i]){	//选value多的
			max[0]=i;
			max[1]=a[i];
		}
		if(max[1]==a[i]&&max[0]>i){	//个数一样多的话，如果现在的key比较大，才更新 
			max[0]=i;
			max[1]=a[i];
		}
	}
	printf("%c %d",(char)(max[0]),max[1]);
}
```

2、C++

```cpp
#include <iostream>
#include <cctype>
using namespace std;
int main(){
	char c;
	int a[128]={0},b[2]={0,0};
	while((c=tolower(getchar()))!='\n')
		if(c-'a'>=0&&c-'a'<=25)	a[int(c)]++;
	for(int i=int('a');i<=int('z');i++){
		if(b[1]<a[i]){
			b[0]=i;
			b[1]=a[i];
		}
		if(b[1]==a[i]&&b[0]>i){
			b[0]=i;
			b[1]=a[i];
		} 
	}
	cout<<char(b[0])<<" "<<b[1];
	return 0;
}
```





