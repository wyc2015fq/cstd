# 1085 PAT单位排行——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月30日 15:41:26[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：100








# 题目

> 
1085 PAT单位排行 （25 point(s)）

每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。

### 输入格式：

输入第一行给出一个正整数 N（≤10​5​​），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：

```
准考证号 得分 学校
```

其中`准考证号`是由 6 个字符组成的字符串，其首字母表示考试的级别：`B`代表乙级，`A`代表甲级，`T`代表顶级；`得分`是 [0, 100] 区间内的整数；`学校`是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。

### 输出格式：

首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：

```
排名 学校 加权总分 考生人数
```

其中`排名`是该单位的排名（从 1 开始）；`学校`是全部按小写字母输出的单位码；`加权总分`定义为`乙级总分/1.5 + 甲级总分 + 顶级总分*1.5`的**整数部分**；`考生人数`是该属于单位的考生的总人数。

学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。

### 输入样例：

```
10
A57908 85 Au
B57908 54 LanX
A37487 60 au
T28374 67 CMU
T32486 24 hypu
A66734 92 cmu
B76378 71 AU
A47780 45 lanx
A72809 100 pku
A03274 45 hypu
```

### 输出样例：

```
5
1 cmu 192 2
1 au 192 3
3 pku 100 1
4 hypu 81 2
4 lanx 81 2
```


# 算法

这道题目有这样几个难点，首先在于采用何种数据结构进行存储。由于map只能建立单一的key-value，因此在这道题目里面显得不够用。看到别人的代码采用两个map可以解决这个问题，两个map都以学校的字符串为key，一个以学生人数为value，一个以总分为value。由于这里总分是所有的某一类计算求和之后再进行加权，因此用double就可以解决这个问题。最后输出时在强制类型转换即可。学校的输入有大小写，可以先都转化成小写（题目输出要小写），再进行map存储。

**对于排名的处理：设立pres表示前一个学校的加权总分，如果pres和当前学校的加权总分不同，说明rank等于数组下标+1，否则rank不变～**

**更新后的pat系统会导致之前使用map的代码最后一个测试点超时，更改为unordered_map即可AC～因为无序的map没有进行排序，会使程序运行时间变短。**

# 代码

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <cctype>
#include <algorithm>
using namespace std;
struct node{
	string id;
	int score,cnt;	
}; 
bool cmp(node a,node b){
	if(a.score !=b.score )	return a.score >b.score ;
	else if(a.cnt!=b.cnt )	return a.cnt <b.cnt ;
	else return a.id <b.id ;
}
int main(){
	double N,tmp,rank=0,pres=-1;	cin>>N;
	unordered_map<string,int> idx;
	unordered_map<string,double> sum;
	vector<node> v;
	string s1,s2;
	for(int i=0;i<N;i++){
		cin>>s1>>tmp>>s2;
		for(int j=0;j<s2.length() ;j++)		s2[j]=tolower(s2[j]);//全部转化为小写
		idx[s2]++;	//计算每个学校的人数
		if(s1[0]=='T')	 sum[s2]+=tmp*1.5;
		if(s1[0]=='A')	 sum[s2]+=tmp;
		if(s1[0]=='B')	 sum[s2]+=tmp/1.5;
	}
	for(auto it=idx.begin();it!=idx.end();it++)	v.push_back(node{it->first,int(sum[it->first]),idx[it->first]});
	sort(v.begin(),v.end(),cmp);
	printf("%d\n",v.size());
	for(int i=0;i<v.size();i++){
		if(pres!=v[i].score)	rank=i+1;
		pres=v[i].score;
		cout<<rank<<" ";
		cout<<v[i].id;
		cout<<" "<<v[i].score<<" "<<v[i].cnt<<endl;
	}
	return 0;
}
```





