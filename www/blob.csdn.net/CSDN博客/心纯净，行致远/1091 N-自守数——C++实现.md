# 1091 N-自守数——C++实现 - 心纯净，行致远 - CSDN博客





2018年12月10日 10:51:55[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：461








# 题目

> 
1091 N-自守数 （15 分）

如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×92​2​​=25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。

本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。

### 输入格式：

输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。

### 输出格式：

对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK​2​​ 的值，以一个空格隔开；否则输出 `No`。注意题目保证 N<10。

### 输入样例：

```
3
92 5 233
```

### 输出样例：

```
3 25392
1 25
No
```


# 算法

使用字符串函数s.substr()截取计算数字的结尾与原来的数据对应，注意输入的数字前面如果带有0，比如044，那么比对的时候也需要和044比对，而不是和44比对。

调试了一下，和考试的时候一样，还是有一个2分的测试点过不去，看到的大神帮忙一下....

原因就是因为应该截取子串时，s.substr(begin,count)的第一个参数begin是字符串的下标位置，从0开始，count是截取的子字符串的长度，因此应该直接截取到字符串结尾才对。注释部分是原来的，注释下面是更改的。考试就因为这痛失两分。

# 代码

```cpp
#include <iostream>
#include <cmath>
#include <string>
using namespace std;
int main(){
	int M,j;	scanf("%d",&M);
	for(int i=0;i<M;i++){
		string s,str,sub;
		int tmp,res,lens;	cin>>s;
		tmp=stoi(s);
		lens=s.length() ;	
		for(j=1;j<10;j++){
			str=to_string(int(j*pow(tmp,2)));
			//sub=str.substr(str.length() -lens,str.length() -1) ;
                        sub=str.substr(str.length() -lens) ;
			if(sub==s){
				printf("%ld %ld\n",j,int(j*pow(tmp,2)));
				break;
			}
		}
		if(j==10)	printf("No\n"); 
	}
	return 0;
}
```





