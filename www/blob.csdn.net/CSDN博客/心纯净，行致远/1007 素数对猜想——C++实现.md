# 1007 素数对猜想——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月21日 09:15:17[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：112








# 题目

> 
1007 素数对猜想 （20 point(s)）

让我们定义d​n​​为：d​n​​=p​n+1​​−p​n​​，其中p​i​​是第i个素数。显然有d​1​​=1，且对于n>1有d​n​​是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。

现给定任意正整数`N`(<10​5​​)，请计算不超过`N`的满足猜想的素数对的个数。

### 输入格式:

输入在一行给出正整数`N`。

### 输出格式:

在一行中输出不超过`N`的满足猜想的素数对的个数。

### 输入样例:

```
20
```

### 输出样例:

```
4
```


# 算法

这道题的想法是现将N范围内的素数全部找出来，在比较相邻两个素数是否满足差为2，满足则计数cnt加1。求素数的算法也很经典了，i从2到sqrt(n)进行遍历，如果能被n整除，说明不是素数，break；如果一直循环到i>sqrt(n)，则说明是素数，存起来。

这道题现在做的思路和以前基本是一样的。

# 代码

代码1，以前做的

```cpp
//PAT1007V1
 #include <stdio.h>
 #include <math.h>
 
 int main(){
 	int n,i,j,t=0,count=0;
 	int a[10001];
 	scanf("%d",&n);
 	for(i=2;i<=n;i++){
		for(j=2;j<=sqrt(i);j++){
			if(i%j==0)	break;	// mean i is not prime
		}
		if(j>sqrt(i))	a[t++]=i;	//mean i is prime	
	}
	for(i=0;i<t-1;i++)
		for(j=i+1;j<t;j++){
			if(a[j]-a[i]==2)	count++;
		}
	printf("%d",count);	
 }
```

代码2，现在做的

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main(){
	int n,t=0,cnt=0,i,arr[100005]={0};	cin>>n;
	for(int j=2;j<=n;j++){
		for(i=2;i<=(int)sqrt(j);i++){
			if(j%i==0)	 break;	//没有余数，说明j不是素数
		}
		if(i>sqrt(j))	arr[t++]=j;
	}
	for(int i=0;i<t-1;i++)
		if(arr[i+1]-arr[i]==2)	cnt++;
	cout<<cnt;
	return 0;
}
```

代码3，另外一个判断的思路，本质上是一样的。

```cpp
#include <iostream>
using namespace std;
bool isprime(int a) {
    for (int i = 2; i * i <= a; i++)
        if (a % i == 0) return false;
    return true;
}
int main() {
    int N, cnt = 0;
    cin >> N;
    for (int i = 5; i <= N; i++)
        if (isprime(i-2) && isprime(i)) cnt++;
    cout << cnt;
    return 0;
}
```





