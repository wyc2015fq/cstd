# 胡凡《算法笔记》总结3——递归（全排列和n-皇后问题） - 心纯净，行致远 - CSDN博客





2018年12月11日 14:05:48[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：94








递归思想

递归的思想就在于反复调用自身函数，每次调用自身函数可以缩小求解的规模，直到将范围内缩小至递归边界。由于边界是已知的，代入可以求解，再依次返回得到原问题的求解。

递归的两个最重要概念是：
- 递归边界；
- 递归式；

例如：

1、n!的C++代码

```cpp
int F(int n){
    if(n==0) return 1;
    else    return F(n-1)*n;
}
```

2、求斐波那契数列的第n项

```cpp
int F(int n){
    if(n==1||n==0) return 1;
    else    return F(n-1)+F(n-2);
}
```

全排列问题

全排列问题是指给定n个数（当然也可能不是数），这n个数能组成的所有排列称为全排列。

例如，给定1/2/3三个数字，全排列就有3*2*1=6种，分别是123/132/213/231/312/321，而且这6个排列还是按照字典序从小到大排列的。

全排列问题

给定1~n一共n个数字，请按照字典序从小到大依次输出它们的全排列。

算法

从递归的角度考虑，问题可以被分治为以下的子问题：“输出以1开头的全排列”，“输出以2开头的全排列”……“输出以n开头的全排列”。于是不妨设定一个数组P，用来存放当前的排列，再设定一个散列数组hashtable，其中hashtable[x]是当整数x存在于P中时置为true。

现在按顺序从P的第1位到第n位中填入数字。不妨设定当前已经填好了P[1]~P[index-1]，正填P[index]时，显然填入的数字不能和P[1]~P[index-1]中的数字重复，需要从1~n遍历。如果当前枚举的数字x还没有在其中，就将hashtable[x]原先的false置为true，并将其填入P[index]，然后去处理P[index+1]，当递归完成时，再将hashtable[x]置为false，以便让P[index]填入下一个数字。

![](https://img-blog.csdnimg.cn/20181213220406157.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5zaGVuMTEy,size_16,color_FFFFFF,t_70)

递归的边界是index=n+1，此时可以输出数组，表示生成了一个排列，直接return。 下面是n=3时的代码。

```cpp
#include <iostream>
using namespace std;
const int maxn=11;
//P为当前全排列，hashtable记录当前x是否在P中 
int n,P[maxn],hashtable[maxn]={false},cnt=0;

//当前处理排列的第index位 
void generateP(int index){
	if(index==n+1){	//递归边界
		for(int i=1;i<=n;i++)	cout<<P[i];
		cout<<endl;
		cnt++;
		return ; 
	}
	for(int x=1;x<=n;x++){
		if(hashtable[x]==false){
			P[index]=x;
			hashtable[x]=true;
			generateP(index+1);
			hashtable[x]=false;
		}
	}
} 
int main(){
	n=3;
	generateP(1);
	cout<<cnt;
	return 0;
}
```







```cpp
#include <iostream>
using namespace std;
int n=8,cnt=0,hashtable[10]={0},P[10]={0};
void genP(int idx){
	if(idx==n+1){
		bool flag=true;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++)
				if(abs(i-j)==abs(P[i]-P[j])) 
					flag=false;
		}
		if(flag)	cnt++;
		return;
			
	}
	for(int x=1;x<=n;x++){
		if(hashtable[x]==false){
			P[idx]=x;
			hashtable[x]=true;
			genP(idx+1);
			hashtable[x]=false;
		}
	}
}
int main(){
	genP(1);
	return 0;
}
```





