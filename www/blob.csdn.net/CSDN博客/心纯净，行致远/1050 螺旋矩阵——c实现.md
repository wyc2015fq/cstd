# 1050 螺旋矩阵——c实现 - 心纯净，行致远 - CSDN博客





2018年11月04日 23:13:41[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：91








> 
1050 螺旋矩阵 （25 分）

本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。

### 输入格式：

输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10​4​​，相邻数字以空格分隔。

### 输出格式：

输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。

### 输入样例：

```
12
37 76 20 98 76 42 53 95 60 81 58 93
```

### 输出样例：

```
98 95 93
42 37 81
53 20 76
58 60 76
```


**思路：**

这道题的难点总共有两点，第一点是确定m*n；第二点是如何能够打印螺旋矩阵。

第一个问题比较简单，只需要对让n=(int)sqrt(n)，然后N%n==0,如果不满足,则n--,就会找到合适的m，n。

第二个问题稍微麻烦一些，关键是要有处理类似问题的经验，首先将封闭的一圈作为一个研究对象，而一圈又包含上下左右四个矩形边的输出，这里就可以看到需要两个for循环。注意每行的特点，一个圈子中的最上行，存数据时，行数不变列数增加；最右边则是列数不变行数减小……依次就可以存储进二维数组。

注意点：还有需要注意的是如何确定螺旋转多少圈的问题，画了4*3的矩阵和4*4的矩阵来帮助分析，他们都是转两圈虽然第二圈值转到中途。即其实每转一圈需要用掉两列，如果是偶数列即为n/2求圈数便可，但如果是奇数列n/2还会剩下一列同样要转圈，所以应该是n/2+n%2，这样在偶数的时候取余不起作用，在奇数的时候又可以多加1圈。

**代码：**

```cpp
//1050 螺旋矩阵 v1
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

int cmp(const void* a,const void* b){
	return *(int*)b-*(int*)a;	//b-a是降序，a-b是升序 
}

int main(){
	int N,n,m,i,j;	scanf("%d",&N);
	int a[N];
	for(n=0;n<N;n++)	scanf("%d",&a[n]);
	qsort(a,N,sizeof(int),cmp);
	n=(int)(sqrt(N));	//i是n 
	while(N%n!=0){	//不能整除 
		n--;
	}	
	m=N/n;	//j is m
//	printf("%d %d\n",m,n);
	int mat[m][n];
	int urow=0,drow=m-1,lcol=0,rcol=n-1,k;
	for(k=n/2+n%2;k>=0;k--){	//从外到里遍历的圈数 
		for(j=lcol;j<=rcol&&i!=N;j++,i++)	//遍历最上行 	
			mat[urow][j]=a[i];
		urow++;	//最上行遍历完毕 
		for(j=urow;j<=drow&&i!=N;j++,i++)	//遍历最右列 
			mat[j][rcol]=a[i];
		rcol--;
		for(j=rcol;j>=lcol&&i!=N;j--,i++) 
			mat[drow][j]=a[i];
		drow--;
		for(j=drow;j>=urow&&i!=N;j--,i++)
			mat[j][lcol]=a[i];
		lcol++;
	}
	for(i=0;i<m;i++){
		for(j=0;j<n;j++){
			if(j==n-1)	printf("%d\n",mat[i][j]);
			else	printf("%d ",mat[i][j]);
		}
	}
	return 0;
}
```

**参考：**

[PAT乙级1050. 螺旋矩阵（C语言）](https://blog.csdn.net/weixin_39345384/article/details/82351247)

[（PAT乙级）1050 螺旋矩阵（C语言实现）](https://blog.csdn.net/qq_40840749/article/details/82259542)



