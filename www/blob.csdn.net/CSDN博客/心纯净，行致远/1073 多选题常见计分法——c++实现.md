# 1073 多选题常见计分法——c++实现 - 心纯净，行致远 - CSDN博客





2018年11月14日 15:28:47[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：68








# **题目**

> 
1073 多选题常见计分法 （20 分）

批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。

### 输入格式：

输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 `(选中的选项个数 选项1 ……)`，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。

### 输出格式：

按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：`错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号`。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 `Too simple`。

### 输入样例 1：

```
3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)
```

### 输出样例 1：

```
3.5
6.0
2.5
2 2-e
2 3-a
2 3-b
```

### 输入样例 2：

```
2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)
```

### 输出样例 2：

```
5.0
5.0
Too simple
```


# **算法**

**这道题目充分展示了PAT乙级考试的风格，总有一些题用稍微高级一些的数据结构可以很好地解决，但是如果只知道基础的基本结构则很难做好。所以PAT高分的秘诀也就在这里，c++STL的常用容器要了解清楚。另外，下面也展示了使用基本数据结构也能解决这方面的问题，但是明显的会比较繁琐。**

pat乙级1058. 选择题(20)是一道类似题目，但比本题简单。

    用pair<int,char>来储存错误选项信息，其first成员记录错误的题目编号，second成员记录错误的选项，pair类型自定义的<运算符先比较first成员，如果相等比较second成员。然后pair<int,char>为键，错误次数为值，建立一个map。由于map会按键排序，那么整个map中就会按题目编号递增、选项字符的ascii码递增顺序存储元素，方便后续输出结果。

    定义一个Problem类，包含以下数据成员：该题分数score、该题选项个数num、正确答案answer（用vector储存）。

    在读取学生选项的过程中，定义bool类型的correct表示这道题有没有选错答案、less表示这道题有没有少选正确答案、数组option表示学生的选项。每输入一个选项，则将option对应选项下标下的元素置true；遍历该题正确答案，比较option元素和当前遍历的正确答案，得出学生的选择结果。

    读取过程中对于括号可以利用getchar()函数来处理。

    定义一个vector来储存错的最多的选项的信息，定义一个变量maxWrong表示当前错的选项的错误次数，遍历所有map中的选项，如果错误次数大于maxWrong，更新maxWrong，清空vector，将当前选项信息加入vector中；如果题目错误次数等于maxWrong，直接将当前选项信息加入vector中。最后按要求输出即可



参考：

[pat乙级1073. 多选题常见计分法(20)](https://blog.csdn.net/richenyunqi/article/details/79809481)

[1073. 多选题常见计分法(20)](https://www.cnblogs.com/asheng2016/p/7898389.html)



# **代码**

代码1：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Problem{
    double score=0.0;//该题分数
    int num=0;//选项个数、正确选项个数
    bool answer[5]={false};//正确答案
};
int main(){
    int N,M,n;
    char c;
    scanf("%d%d",&N,&M);
    Problem p[M];
    map<pair<int,char>,int>wrong;
//存储错误选项错误次数，map会按键排序
//pair类型自定义的<运算符先比较first元素，如果相等再比较second元素
    for(int i=0;i<M;++i){//读取题目数据
        scanf("%lf%d%d",&p[i].score,&p[i].num,&n);
        while(n--){
            scanf(" %c",&c);
            p[i].answer[c-'a']=true;
        }
    }
    for(int i=0;i<N;++i){//读取学生选项
        double score=0.0;
        for(int j=0;j<M;++j){
            while(getchar()!='(');//读取字符直至遇到(字符
            scanf("%d",&n);
            bool correct=true,less=false,option[5]={false};
            for(int ii=0;ii<n;++ii){
                scanf(" %c",&c);
                option[c-'a']=true;
            }
            for(int i=0;i<5;++i)//比较学生选的选项和正确选项
                if(option[i]!=p[j].answer[i]){//学生选的当前选项和正确选项不同
                    ++wrong[pair<int,char>(j+1,i+'a')];//这个选项选错了，递增对应的错误次数
                    if(option[i]&&!p[j].answer[i])//学生选了不是正确答案的选项
                        correct=false;//这道题错误，将correct置false
                    else if(!option[i]&&p[j].answer[i])//学生少选了正确选项
                        less=true;//将less置true
                }
            while(getchar()!=')');//读取字符直至遇到)字符
            if(correct&&!less)//选择了全部的正确选项
                score+=p[j].score;//得到全部分数
            else if(correct&&less)//漏选了正确选项
                score+=p[j].score/2;//得到一半分数
        }
        printf("%.1f\n",score);//输出该学生分数
    }
    int maxWrong=0;//错得最多的选项的错误次数
    vector<pair<int,char>>wrongIndex;//错得最多的选项的题目编号、选项编号
    for(auto i=wrong.cbegin();i!=wrong.cend();++i)
        if(i->second>maxWrong){//选项错误次数大于maxWrong
            maxWrong=i->second;//更新maxWrong
            wrongIndex.clear();//清空vector
            wrongIndex.push_back(i->first);//将当前选项信息加入vector中
        }else if(i->second==maxWrong)//选项错误次数等于maxWrong
            wrongIndex.push_back(i->first);//将当前选项信息加入vector中
    if(maxWrong==0)//不能以wrongIndex是否为空为判断条件
        printf("Too simple");
    else
        for(pair<int,char>& i:wrongIndex)
            printf("%d %d-%c\n",maxWrong,i.first,i.second);
    return 0;
}
```

代码2：

```cpp
#include <stdio.h>

struct Ques {
    int qscore;     // 满分
    int qsnum;      // 选项个数
    int qrnum;      // 正确选项个数
    int qawr[128];  // 所有正确选项
};
typedef struct Ques s_ques;

#define LEN 120
int main (void) {
    int snum;           // 学生人数
    int qnum;           // 题目个数
    s_ques ques[LEN];   // 每道题的信息
    int wrong[LEN][128] = {0}; // 错误信息矩阵
    int wmax = 0;              // 最大错误次数
    char ch;
    int i;
    int j;
    int k;

    scanf("%d %d", &snum, &qnum);
    for (i = 1; i <= qnum; i++) {
        ques[i].qawr['a'] = 0;
        ques[i].qawr['b'] = 0;
        ques[i].qawr['c'] = 0;
        ques[i].qawr['d'] = 0;
        ques[i].qawr['e'] = 0;
        scanf("%d %d %d", &ques[i].qscore, &ques[i].qsnum, &ques[i].qrnum);
        for (j = 1; j <= ques[i].qrnum; j++) {
            scanf(" %c", &ch);
            ques[i].qawr[(int)(ch)] = 1;
        }
    }
    getchar(); // 回车挡掉

    int len;   // 初始是第1道题
    int mys;   // 这个学生选了几个选项
    char slt;  // 选中选项
    for (i = 1; i <= snum; i++) {
        double score = 0.0;  // 每个学生的初始分数
        len = 1;
        // 一个 while 循环是一位学生答题的全部情况
        while ((ch = getchar()) != '\n') {
            if (ch == '(') {
                int cawr[128] = {0}; // 用来记录该题答题情况, 有1, 无0
                scanf("%d", &mys);
                for (j = 1; j <= mys; j++) {
                    scanf(" %c", &slt);
                    cawr[(int)(slt)] = 1;
                }

                // 学生这个选项答了, 而正确答案没有, 相应错误+1
                for (k = 'a'; k <= 'e'; k++) {
                    if (cawr[k] != ques[len].qawr[k]) wrong[len][k]++;
                    if (wrong[len][k] > wmax) wmax = wrong[len][k];
                }

                if (
                    // 所有选项全部匹配, 为完全正确
                    cawr['a'] == ques[len].qawr['a'] &&
                    cawr['b'] == ques[len].qawr['b'] &&
                    cawr['c'] == ques[len].qawr['c'] &&
                    cawr['d'] == ques[len].qawr['d'] &&
                    cawr['e'] == ques[len].qawr['e']
                ) {
                    score += (double)(ques[len].qscore);
                } else if (
                    // 这一项学生答了, 而正确答案没有这一项, 该题答错
                    (cawr['a'] == 1 && ques[len].qawr['a'] == 0) ||
                    (cawr['b'] == 1 && ques[len].qawr['b'] == 0) ||
                    (cawr['c'] == 1 && ques[len].qawr['c'] == 0) ||
                    (cawr['d'] == 1 && ques[len].qawr['d'] == 0) ||
                    (cawr['e'] == 1 && ques[len].qawr['e'] == 0) 
                ) {
                    // 该题答错
                    // do nothing
                } else {
                    // 部分正确
                    score += (double)(ques[len].qscore) / 2.0;
                }
                len++; // 进入到下一题
            }
        }
        printf("%.1f\n", score); // 打印这位同学的得分
    }

    if (wmax == 0) {
        printf("Too simple\n");
    } else {
        for (i = 1; i <= qnum; i++) {
            for (j = 'a'; j <= 'e'; j++) {
                if (wrong[i][j] == wmax) {
                    printf("%d %d-%c\n", wrong[i][j], i, j);
                }
            }
        }
    }

    return 0;
}
```





