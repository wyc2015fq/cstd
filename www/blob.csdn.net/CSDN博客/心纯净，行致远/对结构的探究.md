# 对结构的探究 - 心纯净，行致远 - CSDN博客





2018年05月24日 11:01:17[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：68








对结构，我们没有像对数组那样使用sizeof和&这两个工具来探究一下。我们把这个任务留给你。建议可以做这么几个方向的探究：
- 
不同的成员变量组合，结构的sizeof如何，是否正好等于全部成员的sizeof之和？

- 
结构内的成员之间是否连续，相邻的成员的地址的差是否等于对应的成员的sizeof？



![](https://nos.netease.com/edu-image/f8c76706-d48b-485f-820e-2fe8c5ec7f70.png?imageView)

第一个显然是不等于；

第二个说明内存也不是连续的。那到底是怎样存储的呢？


```cpp
#include <stdio.h>
    /*
    探究问题： 
    1、不同的成员变量组合，结构的sizeof如何，是否正好等于全部成员的sizeof之和？
    2、结构内的成员之间是否连续，相邻的成员的地址的差是否等于对应的成员的sizeof？
    date:2018.05.24 
    edit by qjx
    */
    struct date
    {
        float x;
        char y;
        double z;
    };
     
    main()
    {
        struct date p1={34,'a',3.0};
        printf("p1结构体占用空间：%d\n",sizeof(p1));
         
            printf("p1.x占用空间：%d\n",sizeof(float));
            printf("p1.y占用空间：%d\n",sizeof(char));
            printf("p1.z占用空间：%d\n",sizeof(double));
        printf("p1.x地址：%d\n",&p1.x);
        printf("p1.y地址：%d\n",&p1.y);
        printf("p1.z地址：%d\n",&p1.z);
     
    }
```


应该是这样存储的：

结构体中所需存储空间最小的元素会按照次小元素的类型分配内存空间，应该就是所谓的内存对齐：

规则：

1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。

2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

需要注意的是不同的编译器对其规则不同。

 下面的程序和之前的程序对比可以得到以上的结论。


![](https://nos.netease.com/edu-image/8e65ecee-afb3-42ea-a763-9d10d8c3e897.png?imageView)

```cpp
#include <stdio.h> 
    /*
    探究问题： 
    1、不同的成员变量组合，结构的sizeof如何，是否正好等于全部成员的sizeof之和？
    2、结构内的成员之间是否连续，相邻的成员的地址的差是否等于对应的成员的sizeof？
    date:2018.05.24 
    edit by qjx
    */
    struct date
    {
        double x;
        char y;
        double z;
    };
     
    main()
    {
        struct date p1={34,'a',3.0};
        printf("p1结构体占用空间：%d\n",sizeof(p1));
         
            printf("p1.x占用空间：%d\n",sizeof(double));
            printf("p1.y占用空间：%d\n",sizeof(char));
            printf("p1.z占用空间：%d\n",sizeof(double));
        printf("p1.x地址：%d\n",&p1.x);
        printf("p1.y地址：%d\n",&p1.y);
        printf("p1.z地址：%d\n",&p1.z);
     
    }
```






