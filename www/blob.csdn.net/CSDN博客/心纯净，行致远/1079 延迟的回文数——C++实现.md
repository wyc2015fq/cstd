# 1079 延迟的回文数——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月19日 08:46:26[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：73








# 题目

> 
1079 延迟的回文数 （20 分）

给定一个 k+1 位的正整数 N，写成 a​k​​⋯a​1​​a​0​​ 的形式，其中对所有 i 有 0≤a​i​​<10 且 a​k​​>0。N 被称为一个**回文数**，当且仅当对所有 i 有 a​i​​=a​k−i​​。零也被定义为一个回文数。

非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为**延迟的回文数**。（定义翻译自 [https://en.wikipedia.org/wiki/Palindromic_number](https://en.wikipedia.org/wiki/Palindromic_number) ）

给定任意一个正整数，本题要求你找到其变出的那个回文数。

### 输入格式：

输入在一行中给出一个不超过1000位的正整数。

### 输出格式：

对给定的整数，一行一行输出其变出回文数的过程。每行格式如下

```
A + B = C
```

其中 `A` 是原始的数字，`B` 是 `A` 的逆转数，`C` 是它们的和。`A` 从输入的整数开始。重复操作直到 `C` 在 10 步以内变成回文数，这时在一行中输出 `C is a palindromic number.`；或者如果 10 步都没能得到回文数，最后就在一行中输出 `Not found in 10 iterations.`。

### 输入样例 1：

```
97152
```

### 输出样例 1：

```
97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.
```

### 输入样例 2：

```
196
```

### 输出样例 2：

```
196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.
```


# 算法

确定以后编程的框架，采用面向结构编程，至少是在PAT乙级考试中是这样。

面向结构编程的主要方法是各种功能函数话，以便于实现良好的程序规范和阅读性。

这个题目可以凝炼为3个函数：字符串反转函数、回文生成函数、回文判断函数。这样可以使主函数大大简化，函数间通过返回值传递，实现信息的交换。

字符串反转函数：新建一个和原字符串等长的字符串，将原字符串的字符依次逆序输出储存即可。

回文生成函数：将原字符串与反转之后的字符串相加，这里要注意相应位置的字符叠加后可能会产生进位。如果进位要将进位加到下一次字符串叠加中，同时字符的叠加要先用int型计算，计算之后还要讲int转化为char。

回文判断函数：直接从生成的回文的0位置开始遍历，遍历到中间，和从最后一位倒叙遍历的字符进行对比。只要有一个不一样，就不是回文。可以用一个标志位flag表示。

下面的代码1还存在问题，有一个测试不能AC.

代码2是调用了<algorithm>中的reverse()函数，省了很多事，AC。经典思路！！！

2018.12.03

这道题思路并不难，但是细节比较多，第一次调试完之后提交却不行，花了大概40分钟才找到问题，原来是输出的时候，s2/s1两个字符串的位置搞反了，s2存储的才是原来的字符串，s1是逆转的……坑爹，调试的时候应该更细心才行。见代码3.

这里，判断是不是回文数，我写了一个函数，实际上不用这么麻烦，直接逆转，然后观察是否相等，即可，另外当不是回文数的情况下，逆转是必须做的事，因此就可以凝练代码。这一点要想思路2学习。这一点这一次做没想到。不过好在我这次的思路也很经典，正确了。

# 代码

1、

```cpp
// 1079 延迟的回文数 v1
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

string Reverse(string str){	//字符串反转 
	string rev;
	rev=str;
	for(int i=0;i<str.length();i++)
		rev[i] = str[str.length()-1-i];
	return rev;
}

int IsPal(string str){	//判断是不是回文数 
	int flag=1;
	for(int i=0;i<=str.length()/2;i++){
		if(str[i]!=str[str.length()-i-1]){	//如果找到不一样的，则不是回文数。否则一直找下去 
			flag=0;
			break;
		}
	}
	return flag;
}

string Pal(string str1,string str2){	//根据一个字符串求回文数 
	string pal;
	pal=str1;	//vital;
	int c=0;
	for(int i=0;i<str1.length();i++){	
		c=c+str1[i]-'0'+str2[i]-'0';
		pal[i]=c%10+'0';
		c/=10;
	}
	pal=Reverse(pal);
	if(c)	pal='1'+pal;
	return pal;
}

int main(){
	string str,rev,pal;	cin>>str;	//input is char type
	int cnt=0;
	while(cnt<10){
		rev=Reverse(str);
		pal=Pal(str,rev);
		if(IsPal(pal)){	//pal
			cout<<str<<" + "<<rev<<" = "<<pal<<endl;
			cout<<pal<<" is a palindromic number.";
			break;
		}
		else{
			cout<<str<<" + "<<rev<<" = "<<pal<<endl;
		}
		str=pal;
		cnt++;
	}
	if(cnt==10)	cout<<"Not found in 10 iterations.";
	return 0;
}
```

2、C++

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main(){
	string s1,s2,s3;	cin>>s1;
	int cnt=0,jinwei=0;
	for(cnt;cnt<10;cnt++){
		s2=s1;	//s2存储原来的 
		s3=s1;
		reverse(s1.begin() ,s1.end());	//s1逆转 
		if(s2==s1){
			cout<<s1<<" is a palindromic number.";
			break;
		}
		for(int j=0;j<s1.length() ;j++){
			s3[j]=(s1[j]-'0'+s2[j]-'0'+jinwei)%10+'0';    //从0位置开始加
			jinwei=(s1[j]-'0'+s2[j]-'0'+jinwei)/10;
		}
		reverse(s3.begin() ,s3.end() );    //加完之后要反转，将高位放在s3[0]处
		if(jinwei>0) s3='1'+s3;    //有进位则在字符串前面加1
		cout<<s2<<" + "<<s1<<" = "<<s3<<endl;
		s1=s3;
		jinwei=0;    //别忘了进位归零
	}
	if(cnt==10)	 cout << "Not found in 10 iterations.\n";
	return 0;
}
```

这里面注意

```cpp
s3=s1;
```

必须要有这么一句，也就是字符串的初始化。如果没有的话，后面的

```cpp
s3[i]=(s1[i]-'0'+s2[i]-'0'+jinwei)%10+'0';
```

# 就不能给s3[i]赋值成功。何解？

问题的根源不在必须对其初始化，而是在于如果不进行这个操作，会自动在s3的后面加上字符串

3、AC

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
bool judge(string s){
	int flag=1;
	for(int i=0;i<s.length() /2;i++)
		if(s[i]!=s[s.length() -1-i])	flag=0;
	return flag;
}
int main(){
	string s1,s2;	cin>>s1;
	int cnt=0,yushu=0;
	while(cnt<10){
		if(judge(s1)){
			cout<<s1<<" is a palindromic number.";
			break;
		}
		else{
			string s3;
			s2=s1;
			reverse(s1.begin() ,s1.end() );
			for(int i=0;i<s1.length() ;i++){
				s3+=(s1[i]-'0'+s2[i]-'0'+yushu)%10+'0';
				yushu=(s1[i]-'0'+s2[i]-'0'+yushu)/10;
			}
			if(yushu>0) s3=s3+'1';
			reverse(s3.begin() ,s3.end() );
			cout<<s2<<" + "<<s1<<" = "<<s3<<endl;
			cnt++;
			s1=s3;
			yushu=0;
		}	
	}
	if(cnt==10)	cout<<"Not found in 10 iterations.";
	return 0;
}
```





