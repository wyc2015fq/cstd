# 指针的应用场景 - 心纯净，行致远 - CSDN博客





2018年06月24日 19:42:37[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：345








**场景1：函数需要返回多个值时，通过把地址传入函数，修改地址，可以使传入的参数的地址发生变化。**

比如：

```cpp
#include <stdio.h>
    void swap(int x,int y);
    
    main()
    {
    	int x=5,y=6;
    	swap(x,y);
    	printf("%d%d",x,y);
    	
	}
	 void swap(int x,int y){
	 	int t;
	 	t=x;
	 	x=y;
	 	y=t;
	 }
```

这个函数不能交换x,y的值，输出仍是56。通过指针把地址传进去，可以实现地址的修改。

```cpp
#include <stdio.h>
    void swap(int *x,int *y);
    
    main()
    {
    	int x=5,y=6;
    	swap(&x,&y);
    	printf("%d%d",x,y);
    	
	}
	 void swap(int *x,int *y){
	 	int t;
	 	t=*x;
	 	*x=*y;
	 	*y=t;
	 }
```

**场景2：函数返回多个值，某些值就只能通过指针返回。传入的参数实际上是需要保存带回的结果的变量**

```cpp
#include <stdio.h>

void minmax(int a[],int len,int* min,int* max);

main(){
	int a[]={1,2,3,4,5,6,7,8,9,6,5,45,65};
	int min,max;
	minmax(a,sizeof(a)/sizeof(a[0]),&min,&max);
	printf("%d %d",min,max);
	return 0;
}

void minmax(int a[],int len,int* min,int* max){
	int i;
	*min=*max=a[0];
	for(i=1;i<len;i++){
		if(*min>a[i])
			*min=a[i];
		if(*max<a[i])
			*max=a[i];
	}
}
```

**场景3：函数返回运算的状态，结果通过指针返回**

常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错。例如-1或者0（在文件操作会看到大量的例子）。

但是当任何数值都是有效可能的结果时，就得分开返回。

后续的语言（c++，java）采用了异常机制类解决这个问题。

```cpp
#include <stdio.h>

int divide(int a,int b,int* c);

int main(){
	int a,b,c;
	scanf("%d%d",&a,&b);
	if(divide(a,b,&c))    //函数状态作为判断
	printf("a/b=%d",c);    //结果作为返回值，通过指针带出
	printf("输入有误！"); 
}

int divide(int a,int b,int* c){
	int ret=1;	//函数返回状态 
	if(b==0) ret=0;
	else{
		*c=a/b;
	}
	return ret;
}
```

**最常见的错误**

定义了指针变量，还没有指向任何变量，就开始使用指针。

例如：


```cpp
int k=12,*p;
	*p=12;
```

这里，还没有对指针p赋予其他变量的地址，就开始对指针所指内存空间写入数字，这是没有意义的。

应该像下面这样：

```cpp
#include <stdio.h>

int main(){
	int k=12,*p;
	p=&k; 
	*p=3;
	printf("%d",k);
}
```

这里，指针p被赋予了k的地址，*p=3;

则是将k原先的12改写为3.



