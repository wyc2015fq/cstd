# 1089 狼人杀-简单版——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年12月04日 22:15:29[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：328








# 题目

> 
1089 狼人杀-简单版 （20 point(s)）

以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？

本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？

### 输入格式：

输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。

### 输出格式：

如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],...,a[M] 和 B=b[1],...,b[M]，若存在 0≤k<M 使得 a[i]=b[i] （i≤k），且 a[k+1]<b[k+1]，则称序列 A 小于序列 B。若无解则输出 `No Solution`。

### 输入样例 1：

```
5
-2
+3
-4
+5
+4
```

### 输出样例 1：

```
1 4
```

### 输入样例 2：

```
6
+6
+3
+1
-5
-2
+4
```

### 输出样例 2（解不唯一）：

```
1 5
```

### 输入样例 3：

```
5
-2
-3
-4
-5
-1
```

### 输出样例 3：

```
No Solution
```


# 算法

这道题目很长，刚开始拿到，感觉无从下手，不知道如何分析……后来去看了别人的算法思想，还是不太理解，晚上毕业的博士师姐请吃饭，回来又看了电影《死侍》，刚才认真看了分析，终于看懂了。。。考试碰到类似的题目，一点思路都没有，才要头皮发麻……崩溃！！！

起初读完题目知道题目的意思是这样的：
- N个人有两个狼人，有2个说谎者；
- 2个说谎者中一个是狼人，一个是好人；

但是还是没有具体的思路，后来看懂之后感觉其实也挺简单。思路是这样的：由于不知道谁是狼人，因此可以采用计算思维 ，逐个进行验证，反正不缺算力，这对于习惯公式和推导的非计算机专业的理工科学生有时候真的想不到……

首先将数据存起来，存入vector型数组v(n+1)，设定i/j两个变量是狼人，i从1~n（由于很多参考算法采用vector都是从1开始存储的，因此也就从1~n了，从0~n-1也是一样的，只不过1~n比较方便），是外层for循环，j从i+1~n，是内层for循环。循环之前，先申请个vector数组a(N+1,1)，也就是n+1个数组元素的值都是1，这里a数组元素的值为1表示是好人，为-1表示是狼人，因此由于我们用i，j表示狼人，还需要将a[i]=a[j]=-1才行。同时还需要申请一个lie的vector，因为要往里面存入说谎者，由于不知道有几个，因此直接用vector就好，不用vector数组。这里显示了vector作为C++中动态数组的好处了，妙呀！！！如果有说谎者就存入lie，利用lie.push_back()就可以。

下面就需要知道如何判断说谎者的条件：
- 自己说别人是狼人（v[k]<0），然而别人并不是狼人（a[abs(v[k])] == 1）
- 自己说别人不是狼人（v[k]>0），然而别人就是狼人（a[abs(v[k])] == -1）
- 即：v[k]*a[abs(v[k])] < 0

只要指定判断说谎者的条件，即两个说谎者且其中一个为狼人（lie.size()==2&&a[lie[0]]+a[lie[1]]==0）,满足此条件输出即可。由于遍历的顺序是从1~n，自然会满足最小序列的要求。满足条件输出此时的 i,j（我们之前不是让他俩当狼嘛~~~），如果都不满足，输出 No Solution。

# 代码

```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
int main(){
	int n;	cin>>n;
	vector<int> v(n+1);
	for(int i=1;i<=n;i++)	cin>>v[i];
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			vector<int> lie,a(n+1,1);
			a[i]=a[j]=-1;
			for(int k=1;k<=n;k++)
				if(v[k]*a[abs(v[k])]<0)	lie.push_back(k) ;
			if(lie.size() ==2&&a[lie[0]]+a[lie[1]]==0){
				cout<<i<<" "<<j;
				return 0;
			}
		}	
	}
	cout<<"No Solution";
	return 0;
}
```





