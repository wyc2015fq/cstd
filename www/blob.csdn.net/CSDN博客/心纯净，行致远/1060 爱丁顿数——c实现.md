# 1060 爱丁顿数——c实现 - 心纯净，行致远 - CSDN博客





2018年11月11日 12:01:50[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：48








> 
1060 爱丁顿数 （25 point(s)）

英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。

现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。

### 输入格式：

输入第一行给出一个正整数 N (≤10​5​​)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。

### 输出格式：

在一行中给出 N 天的爱丁顿数。

### 输入样例：

```
10
6 7 6 9 3 10 8 2 7 8
```

### 输出样例：

```
6
```


思路：

涉及到排序的算法，以后都尽量用c++<algorithm>自带的sort函数实现比较好，可以很好滴满足时间复杂度的要求。排序之后注意是从小到大的，因此只要
`a[i]>n-i;    //a[i]之后的元素都会大于n-i`
无论从前往后还是从后往前遍历均可，有点绕。注意从前往后找到就要break，否则会一直找到最后；从后往前就不会有这个问题。

代码：

```cpp
//1060 爱丁顿数v1
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
	long int n,i,max=0;	cin>>n;
	long int a[n];
	for(i=0;i<n;i++)	cin>>a[i];
	sort(a,a+n); 
	for(i=n-1;i>=0;i--){  //a[i]之后又n-i个元素，a[i]>n-i说明有n-i天，每天都大于n-i英里
		if(a[i]>n-i)	max=n-i;
	}
	cout<<max;
}
```

或者是

```cpp
//1060 爱丁顿数v1
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
	int n,i,j,max=0;	cin>>n;
	int a[n],cnt[n]={0};
	for(i=0;i<n;i++)	cin>>a[i];
	sort(a,a+n); 
	for(i=0;i<n;i++){
		if(a[i]>n-i){
		  max=n-i; break;
		}	
	}
	cout<<max;
}
```





