# 结构体和联合体的区别——全网最佳文章 - 心纯净，行致远 - CSDN博客





2018年12月20日 21:52:04[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：55标签：[结构体																[共用体](https://so.csdn.net/so/search/s.do?q=共用体&t=blog)](https://so.csdn.net/so/search/s.do?q=结构体&t=blog)
个人分类：[【C++】																[【C】](https://blog.csdn.net/zhanshen112/article/category/7184374)](https://blog.csdn.net/zhanshen112/article/category/7639351)







**联合体**

用途：使几个不同类型的变量共占一段内存(相互覆盖)

**结构体**是一种构造数据类型

用途：把不同类型的数据组合成一个整体-------自定义数据类型



总结：

声明一个联合体：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- union abc{  
-           int i;  
-           char m;  
-          };  

1. 在联合体abc中，整型量i和字符m公用同一内存位置。

2. 当一个联合被说明时，编译程序自动地产生一个变量，其长度为联合中最大的变量长度。


========================================================================================================

结构体变量所占内存长度是各成员占的内存长度的总和。

共同体变量所占内存长度是各最长的成员占的内存长度。

共同体每次只能存放哪个的一种！！

共同体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！

=====================================================================================

Struct与Union主要有以下区别:

1. struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。

2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

在C/C++程序的编写中，当多个基本数据类型或复合数据结构要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n 选1”），我们也可以使用联合体来发挥其长处。

首先看一段代码：

**[html]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- union myun  
- {  
-      struct { int x; int y; int z; }u;  
-      int k;  
- }a;  
- int main()  
- {  
-      a.u.x =4;  
-      a.u.y =5;  
-      a.u.z =6;  
-      a.k = 0;  
-      printf("%d %d %d\n",a.u.x,a.u.y,a.u.z);  
-      return 0;  
- }  

union类型是共享内存的，以size最大的结构作为自己的大小，这样的话，myun这个结构就包含u这个结构体，而大小也等于u这个结构体的大小，在内存中的排列为声明的顺序x,y,z从低到高，然后赋值的时候，在内存中，就是x的位置放置4，y的位置放置5，z的位置放置6，现在对k赋值，对k的赋值因为是union，要共享内存，所以从union的首地址开始放置，首地址开始的位置其实是x的位置，这样原来内存中x的位置就被k所赋的值代替了，就变为0了，这个时候要进行打印，就直接看内存里就行了，x的位置也就是k的位置是0，而 y，z的位置的值没有改变，所以应该是0,5,6

==========================================================================================================================================================

1. struct的巨大作用

面对一个大型C/C++程序时，只看其对struct的使用情况我们就可以对其编写者的编程经验进行评估。因为一个大型的C/C++程序，势必要涉及一些(甚至大量)进行数据组合的结构体，这些结构体可以将原本意义属于一个整体的数据组合在一起。从某种程度上来说，会不会用struct，怎样用struct是区别一个开发人员是否具备丰富开发经历的标志。在网络协议、通信控制、嵌入式系统的C/C++编程中，我们经常要传送的不是简单的字节流（char型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体。经验不足的开发人员往往将所有需要传送的内容依顺序保存在char型数组中，通过指针偏移的方法传送网络报文等信息。这样做编程复杂，易出错，而且一旦控制方式及通信协议有所变化，程序就要进行非常细致的修改。一个有经验的开发者则灵活运用结构体，举一个例子，假设网络或控制协议中需要传送三种报文，其格式分别为packetA、packetB、packetC：



**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct structA   
- {  
-     int a;  
-     char b;  
- };  
- struct structB   
- {  
-     char a;  
-     short b;  
- };  
- struct structC  
- {  
-     int a;  
-     char b;  
-     float c;  
- }  



优秀的程序设计者这样设计传送的报文：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct CommuPacket  
- {  
-     int iPacketType;　　//报文类型标志  
-     union　　　　　　   //每次传送的是三种报文中的一种，使用union  
-     {  
-         struct structA packetA;  
-         struct structB packetB;  
-         struct structC packetC;  
-     }  
- };  

在进行报文传送时，直接传送struct CommuPacket一个整体。

　　假设发送函数的原形如下：

// pSendData：发送字节流的首地址，iLen：要发送的长度

Send(char * pSendData, unsigned int iLen);

发送方可以直接进行如下调用发送struct CommuPacket的一个实例sendCommuPacket：

Send( (char *)&sendCommuPacket , sizeof(CommuPacket) );

假设接收函数的原形如下：

// pRecvData：发送字节流的首地址，iLen：要接收的长度

//返回值：实际接收到的字节数

unsigned int Recv(char * pRecvData, unsigned int iLen)；

接收方可以直接进行如下调用将接收到的数据保存在struct CommuPacket的一个实例

recvCommuPacket中：

Recv( (char *)&recvCommuPacket , sizeof(CommuPacket) );

接着判断报文类型进行相应处理：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- switch(recvCommuPacket. iPacketType)  
- {  
-     case PACKET_A:  
-     …    //A类报文处理  
-     break;  
-     case PACKET_B:  
-     …　 //B类报文处理  
-     break;  
-     case PACKET_C:  
-     …   //C类报文处理  
-     break;  
- }  



以上程序中最值得注意的是

Send( (char *)&sendCommuPacket , sizeof(CommuPacket) );

Recv( (char *)&recvCommuPacket , sizeof(CommuPacket) );

中的强制类型转换：(char *)&sendCommuPacket、(char *)&recvCommuPacket，先取地址，再转化为char型指针，这样就可以直接利用处理字节流的函数。

　　利用这种强制类型转化，我们还可以方便程序的编写，例如要对sendCommuPacket所处内存初始化为0，可以这样调用标准库函数memset()：

memset((char *)&sendCommuPacket,0, sizeof(CommuPacket));



====================================================================================================================



2. struct成员对齐

Intel、微软等公司曾经出过一道类似的面试题：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- #include <iostream.h>  
- #pragma pack(8)  
- struct example1  
- {  
-     short a;  
-     long b;  
- };  
- struct example2  
- {  
-     char c;  
-     example1 struct1;  
-     short e;      
- };  
- #pragma pack()  
- int main(int argc, char* argv[])  
- {  
-     example2 struct2;  
-     cout << sizeof(example1) << endl;  
-     cout << sizeof(example2) << endl;  
-     cout << (unsigned int)(&struct2.struct1) - (unsigned int)(&struct2) << endl;  
-     return 0;  
- }  

问程序的输出结果是什么？

答案是：

8

16

4

不明白？还是不明白？下面一一道来：

2.1 自然对界

    struct是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如 array、struct、union等）的数据单元。对于结构体，编译器会自动进行成员变量的对齐，以提高运算效率。缺省情况下，编译器为结构体的每个 成员按其自然对界（natural alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

    自然对界(natural alignment)即默认对齐方式，是指按结构体的成员中size最大的成员对齐。

    例如：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct naturalalign  
- {  
-     char a;  
-     short b;  
-     char c;  
- };  

在上述结构体中，size最大的是short，其长度为2字节，因而结构体中的char成员a、c都以2为单位对齐，sizeof(naturalalign)的结果等于6；

如果改为：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct naturalalign  
- {  
-     char a;  
-     int b;  
-     char c;  
- };  

其结果显然为12。

2.2 指定对界

一般地，可以通过下面的方法来改变缺省的对界条件：



    使用伪指令#pragma pack (n)，编译器将按照n个字节对齐；

    使用伪指令#pragma pack ()，取消自定义字节对齐方式。

　　注意：如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。

例如：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- #pragma pack (n)  
- struct naturalalign  
- {  
-     char a;  
-     int b;  
-     char c;  
- };  

当n为4、8、16时，其对齐方式均一样，sizeof(naturalalign)的结果都等于12。而当n为2时，其发挥了作用，使得sizeof(naturalalign)的结果为8。

2.3 面试题的解答

　　至此，我们可以对Intel、微软的面试题进行全面的解答。

　　程序中第2行#pragma pack (8)虽然指定了对界为8，但是由于struct example1中的成员最大size为4（long变量size为4），故struct example1仍然按4字节对界，struct example1的size为8，即第18行的输出结果；

　　struct example2中包含了struct example1，其本身包含的简单数据成员的最大size为2（short变量e），但是因为其包含了struct example1，而struct example1中的最大成员size为4，struct example2也应以4对界，#pragma pack (8)中指定的对界对struct example2也不起作用，故19行的输出结果为16；

　　由于struct example2中的成员以4为单位对界，故其char变量c后应补充3个空，其后才是成员struct1的内存空间，20行的输出结果为4。



3. C和C++之间结构体的深层区别

      在C++语言中struct具有了“类”　的功能，其与关键字class的区别在于struct中成员变量和函数的默认访问权限为public，而class的为private。

例如，定义struct类和class类：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct structA  
- {  
-       char a;  
-       …  
- }  
- class classB  
- {  
-       char a;  
-       …  
- }  



则：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct A a;  
- a.a = 'a';    //访问public成员，合法  
- classB b;  
- b.a = 'a';    //访问private成员，不合法  



许多文献写到这里就认为已经给出了C++中struct和class的全部区别，实则不然，另外一点需要注意的是：

　　C++中的struct保持了对C中struct的全面兼容（这符合C++的初衷——“a better c”），因而，下面的操作是合法的：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- //定义struct  
- struct structA  
- {  
-     char a;  
-     char b;  
-     int c;  
- };  
- structA a = {'a' , 'a' ,1};    // 定义时直接赋初值  



即struct可以在定义的时候直接以{ }对其成员变量赋初值，而class则不能。



4. struct编程注意事项

看看下面的程序：



**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- #include <iostream.h>  
- struct structA  
- {  
-     int iMember;  
-     char *cMember;  
- };  
- int main(int argc, char* argv[])  
- {  
-     structA instant1,instant2;  
-     char c = 'a';      
-     instant1.iMember = 1;  
-     instant1.cMember = &c;  
-     instant2 = instant1;  
-     cout << *(instant1.cMember) << endl;  
-     *(instant2.cMember) = 'b';  
-     cout << *(instant1.cMember) << endl;  
-     return 0;  
- }  

14行的输出结果是：a

16行的输出结果是：b

　　Why?我们在15行对instant2的修改改变了instant1中成员的值！

　　原因在于13行的instant2 = instant1赋值语句采用的是变量逐个拷贝，这使得instant1和instant2中的cMember指向了同一片内存，因而对instant2的修改也是对instant1的修改。

　　在C语言中，当结构体中存在指针型成员时，一定要注意在采用赋值语句时是否将2个实例中的指针型成员指向了同一片内存。

　　在C++语言中，当结构体中存在指针型成员时，我们需要重写struct的拷贝构造函数并进行“=”操作符重载。



===================================================================================================================

C语言中的结构体(struct)和联合体(union)的简介

看到有朋友介绍union，我以前还没有用过这个东西呢，也不懂，就去搜了点资料来看，也转给大家，希望坛子里的给予改正或补充。谢谢！


联 合(union) 

1. 联合说明和联合变量定义 

联合也是一种新的数据类型, 它是一种特殊形式的变量。 

联合说明和联合变量定义与结构十分相似。其形式为: 

union 联合名{ 

数据类型 成员名; 

数据类型 成员名; 

... 

} 联合变量名; 

联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量。 

下例表示说明一个联合a_bc: 

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- union a_bc{   
-     int i;   
-     char mm;   
- };   



再用已说明的联合可定义联合变量。 

例如用上面说明的联合定义一个名为lgc的联合变量, 可写成: 

union a_bc lgc; 

在联合变量lgc中, 整型量i和字符mm公用同一内存位置。 

当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度。 

联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号,此时联合访问成员可表示成: 

联合名->;成员名 

另外, 联合既可以出现在结构内, 它的成员也可以是结构。

例如：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- struct{   
-     int age;   
-     char *addr;   
-     union{   
-         int i;   
-         char *ch;   
-     }x;   
- }y[10];   



若要访问结构变量y[1]中联合x的成员i, 可以写成: 

y[1].x.i; 

若要访问结构变量y[2]中联合x的字符串指针ch的第一个字符可写成: 

*y[2].x.ch; 

若写成"y[2].x.*ch;"是错误的。

2. 结构和联合的区别 

结构和联合有下列区别: 

1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。 

2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。 

下面举一个例了来加深对联合的理解。 

例4：

**[cpp]**[view plain](http://blog.csdn.net/dreamback1987/article/details/8504943#)[copy](http://blog.csdn.net/dreamback1987/article/details/8504943#)
- main()   
- {   
-     union{    
-     int i;   
-     struct{    
-         char first;   
-         char second;   
-     }half;   
- }number;   
- 
- number.i=0x4241;    
- printf("%c%cn", number.half.first, number.half.second);   
- number.half.first='a';    
- number.half.second='b';   
- printf("%xn", number.i);   
- getch();   
- }   

输出结果为：

AB

6261

从上例结果可以看出: 当给i赋值后, 其低八位也就是first和second的值;当给first和second赋字符后, 这两个字符的ASCII码也将作为i的低八~~~~这里没看太懂？？？



共用体

构造数据类型,也叫联合体

用途：使几个不同类型的变量共占一段内存(相互覆盖)



结构体是一种构造数据类型

用途：把不同类型的数据组合成一个整体-------自定义数据类型





