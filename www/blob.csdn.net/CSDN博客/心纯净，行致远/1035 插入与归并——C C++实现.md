# 1035 插入与归并——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月26日 20:08:14[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：49








# 题目

> 
1035 插入与归并 （25 point(s)）

根据维基百科的定义：

**插入排序**是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。

**归并排序**进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。

现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？

### 输入格式：

输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。

### 输出格式：

首先在第 1 行中输出`Insertion Sort`表示插入排序、或`Merge Sort`表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。

### 输入样例 1：

```
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
```

### 输出样例 1：

```
Insertion Sort
1 2 3 5 7 8 9 4 6 0
```

### 输入样例 2：

```
10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6
```

### 输出样例 2：

```
Merge Sort
1 2 3 8 4 5 7 9 0 6
```


# 算法

**先将i指向中间序列中满足从左到右是从小到大顺序的最后一个下标，再将j指向从i+1开始，第一个不满足a[j] == b[j]的下标，****如果j顺利到达了下标n，说明是插入排序，再下一次的序列是sort(a, a+i+2);否则说明是归并排序。归并排序就别考虑中间序列了，直接对原来的序列进行模拟归并时候的归并过程，i从0到n/k，每次一段段得sort(a + i * k, a + (i + 1) * k);最后别忘记还有最后剩余部分的sort(a + n / k * k, a + n);这样是一次归并的过程。直到有一次发现a的顺序和b的顺序相同，则再归并一次，然后退出循环～**

2018.12.04

这道题还做不好，比较了网上各种思路，觉得代码3的思路最容易理解掌握。代码2和3包括1的思路都是一样的，理解之后也并不难，要好好做，把它实现了。

# 代码

1、C

```cpp
#include <stdio.h>  
#include <stdlib.h> 
int comp(const void *a, const void *b){ 
	return *(int*)a - *(int*)b;
	} 
int main() { 
	int N, origin[100], halfsort[100], i, j, length; 
	scanf("%d", &N); 
	for(int i = 0; i < N; i++) 
	scanf("%d", origin + i); 
	for(int i = 0; i < N; i++) 
	scanf("%d", halfsort + i); 
	/* if it is insertion sort, return sorted length if yes, zero otherwise */ 
	for(i = 0; i < N - 1 && halfsort[i] <= halfsort[i + 1]; i++) ; 
	for(length = ++i; i < N && halfsort[i] == origin[i]; i++) ; 
	length = i == N ? length + 1 : 0; 
	if(length) /* insertion sort */ { 
		puts("Insertion Sort"); 
		qsort(origin, length, sizeof(int), comp); 
	} 
	else /* merge sort, operate on the original array */ { 
		puts("Merge Sort"); 
		for(length = 1, i = 0; i < N && length <= N; length *= 2) { 
		/* i == N means identical, also breaks the outer 'for' loop */ 
		for(i = 0; i < N && origin[i] == halfsort[i]; i++) ; 
		for(j = 0; j < N / length; j++) 
			qsort(origin + j * length, length, sizeof(int), comp); 
			qsort(origin + j * length, N % length, sizeof(int), comp); 
		} 
	} 
	for(int i = 0; i < N; i++) 
		printf("%d%c", origin[i], i == N - 1 ? '\n' : ' '); 
	return 0;
}
```

2、C++

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int n,i,j,a[100],b[100];  cin >> n;
    for (int i = 0; i < n; i++)   cin >> a[i];
    for (int i = 0; i < n; i++)   cin >> b[i];
    for (i = 0; i < n - 1 && b[i] <= b[i + 1]; i++);
    for (j = i + 1; a[j] == b[j] && j < n; j++);
    if (j == n) {
        cout << "Insertion Sort" << endl;
        sort(a, a + i + 2);
    } else {
        cout << "Merge Sort" << endl;
        int k = 1, flag = 1;
        while(flag) {
            flag = 0;
            for (i = 0; i < n; i++) {
                if (a[i] != b[i])      flag = 1;
            }
            k = k * 2;
            for (i = 0; i < n / k; i++)
                sort(a + i * k, a + (i + 1) * k);
            sort(a + n / k * k, a + n);
        }
    }
    for (j = 0; j < n; j++) {
        if (j != 0) printf(" ");
        printf("%d", a[j]);
    }
    return 0;
}
```

3、易理解

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
void insort(int a[], int b[]) {
	int key = 0;          //当匹配到中间序列时，key置1，下次排序后输出，结束程序就行
	for (int i = 2; i <= n; i++) {		//插入排序起始为2，结束为n，否则测试点2不通过
		sort(a, a + i);
		if (key) {
			cout << "Insertion Sort" << endl;
			cout << a[0];
			for (int j = 1; j < n; j++)
				cout << " " << a[j];
			return;
		}
		if (equal(a, a + n, b))  //equal是一个比较数组的函数
			key = 1;
	}
}
void mesort(int a[], int b[]) {
	int key = 0;
	for (int i = 2;; i *= 2) {   //这里不给结束条件，是因为当i>n时还要进行一次排序
		for (int j = 0; j < n; j += i) {
			sort(a + j, a + (j + i < n ? j + i : n));  //注意确定边界
		}
		if (key) {
			cout << "Merge Sort" << endl;
			cout << a[0];
			for (int j = 1; j < n; j++)
				cout << " " << a[j];
			return;
		}
		if (equal(a, a + n, b))    key = 1;
		if (i > n)    break;
	}
}
int main() {
	cin >> n;
	int a1[100], a2[100], b[100];
	for (int i = 0; i < n; i++) {
		cin >> a1[i];
		a2[i] = a1[i];
	}
	for (int i = 0; i < n; i++)	cin >> b[i];
	insort(a2, b);
	mesort(a1, b);
	return 0;
}
```





