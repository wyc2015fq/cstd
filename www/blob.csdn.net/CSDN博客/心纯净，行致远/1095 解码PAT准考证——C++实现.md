# 1095 解码PAT准考证——C++实现 - 心纯净，行致远 - CSDN博客





2018年12月10日 22:56:01[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：400








# 题目

> 
1095 解码PAT准考证 （25 分）

PAT 准考证号由 4 部分组成：
- 第 1 位是级别，即 `T` 代表顶级；`A` 代表甲级；`B` 代表乙级；
- 第 2~4 位是考场编号，范围从 101 到 999；
- 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；
- 最后 11~13 位是考生编号，范围从 000 到 999。

现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。

### 输入格式：

输入首先在一行中给出两个正整数 N（≤10​4​​）和 M（≤100），分别为考生人数和统计要求的个数。

接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。

考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：`类型 指令`，其中
- `类型` 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 `指令` 则给出代表指定级别的字母；
- `类型` 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 `指令` 则给出指定考场的编号；
- `类型` 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 `指令` 则给出指定日期，格式与准考证上日期相同。

### 输出格式：

对每项统计要求，首先在一行中输出 `Case #: 要求`，其中 `#` 是该项要求的编号，从 1 开始；`要求` 即复制输入给出的要求。随后输出相应的统计结果：
- `类型` 为 1 的指令，输出格式与输入的考生信息格式相同，即 `准考证号 成绩`。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；
- `类型` 为 2 的指令，按 `人数 总分` 的格式输出；
- `类型` 为 3 的指令，输出按人数非递增顺序，格式为 `考场编号 总人数`。若人数并列则按考场编号递增顺序输出。

如果查询结果为空，则输出 `NA`。

### 输入样例：

```
8 4
B123180908127 99
B102180908003 86
A112180318002 98
T107150310127 62
A107180908108 100
T123180908010 78
B112160918035 88
A107180908021 98
1 A
2 107
3 180908
2 999
```

### 输出样例：

```
Case 1: 1 A
A107180908108 100
A107180908021 98
A112180318002 98
Case 2: 2 107
3 260
Case 3: 3 180908
107 2
123 2
102 1
Case 4: 2 999
NA
```


# 算法

因为类型1，3两个输出的排序规则类似，构建一个结构体数组分别来保存学生和考场的情况。其中学生保存的是准考证号和成绩，考场保存的是考场编号和人数。创建两个结构体数组stu和dat。stu按考生等级将考生分为3类分别保存。dat按日期将考场分别保存。再创建三个map：Nm，Sm，Dm。Nm记录每个考场出现的次数，Sm记录每个考场的总分。Dm记录每个日期，每增加一个日期对应的Key值为上一个日期对应的key值加1，每个日期的key值就可以作为dat数组的下标。最后对应3种类型分别排序输出。

注意：

1.使用scanf，printf输入输出。

2.类型2输出中考场的人数为该考场出现的总次数，而类型3输出中考场的人数为对应日期的考场出现的次数。

3.dat数组应定义为动态数组，否则容易产生段错误。


# 代码

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
using namespace std;
 
struct StudentOrHall
{
	string id;                                                                            //stu数组中为准考证号，dat数组中为考场编号
	int number;                                                                           //stu数组中为考生成绩，dat数组中为考场人数
};
 
bool cmp(struct StudentOrHall s1, struct StudentOrHall s2)
{
	if (s1.number != s2.number) return s1.number > s2.number;
	return s1.id < s2.id;
}
 
int main()
{
	int n, m, i, j, k = 1, score, date, command;
	vector<struct StudentOrHall> stu[3];
	vector<vector<struct StudentOrHall>> dat;
	string Hid, level = "TAB";
	char Sid[13], s[6];
	scanf("%d %d", &n, &m);
	map<string, int> Nm, Sm;
	map<int, int> Dm;
	for (i = 0; i < n; i++)
	{
		scanf("%s %d", &Sid, &score);
		stu[level.find(Sid[0])].push_back({ Sid,score });
		Hid = string(Sid).substr(1, 3);
		date = stoi(string(Sid).substr(4, 6));
		if (!Dm[date]) Dm[date] = k++;                                                     //设置每个日期在dat数组中对应的下标
		dat.resize(k);                                                                     //动态调整dat数组大小
		for (j = 0; j < dat[Dm[date] - 1].size() && dat[Dm[date] - 1][j].id != Hid; j++);  //判断该日期相应考场编号是否出现过
		if (j == dat[Dm[date] - 1].size()) dat[Dm[date] - 1].push_back({ Hid,0 });         
		dat[Dm[date] - 1][j].number++;                                                     //该日期相应考场的人数+1
		Nm[Hid]++;                                                                         //考场的总人数
		Sm[Hid] += score;                                                                  //考场的总成绩
	}
	for (i = 0; i < m; i++)
	{
		scanf("%d %s", &command, &s);
		printf("Case %d: %d %s\n", i + 1, command, s);
		if (command == 1)
		{
			command = level.find(s[0]);
			sort(stu[command].begin(), stu[command].end(), cmp);
			for (j = 0; j < stu[command].size(); j++)
				printf("%s %d\n", stu[command][j].id.c_str(), stu[command][j].number);
			if (!j) printf("NA\n");
		}
		else if (command == 2)
		{
			if (Nm[s]) printf("%d %d\n", Nm[s], Sm[s]);
			else printf("NA\n");
		}
		else
		{
			command = stoi(s);
			if (!Dm[command]) printf("NA\n");
			else
			{
				sort(dat[Dm[command] - 1].begin(), dat[Dm[command] - 1].end(), cmp);
				for (j = 0; j < dat[Dm[command] - 1].size(); j++)
					printf("%s %d\n", dat[Dm[command] - 1][j].id.c_str(), dat[Dm[command] - 1][j].number);
			}
		}
	}
	return 0;
}
```





