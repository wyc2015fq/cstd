# 最小包围矩形 - 心纯净，行致远 - CSDN博客





2018年06月24日 12:52:23[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：422









最小包围矩形（10分）





**题目内容：**

给定一组二维坐标，表示直角坐标系内的一个多边形的连续的顶点的坐标序列。计算能包围这个多边形的平行于坐标轴的最小矩形，输出它的左下角和右上角的坐标。




**输入格式:**


第一行是一个正整数n表示顶点的数量，第二行是n组整数，依次表示每个顶点坐标的x和y值。




**输出格式：**


四个整数，依次表示所计算的矩形的左下角的坐标的x、y值和右上角坐标的x、y值。输出最后带有回车换行。




**输入样例：**


5

1 1 1 4 3 7 4 4 4 1




**输出样例：**


1 1 4 7





时间限制：500ms内存限制：32000kb

```cpp
#include <stdio.h>
#include <stdlib.h>
 
int Xmin(int a[],int n);
int Xmax(int a[],int n);
int Ymin(int a[],int n);
int Ymax(int a[],int n);
 
main(){
    int num;   //存储顶点数量
    scanf("%d",&num); 
    int *array;    //用一位数组存储顶点坐标
    array=(int*)malloc(num*sizeof(int));    //应该是2*num的内存
    int i,j;   //循环存储结点
    for(i=0;i<2*num;i++)
    {
        scanf("%d",&array[i]);
        //  printf("%d",array[i]);
    } 
    printf("%d %d %d %d\n",Xmin(array,num*2),Ymin(array,num*2),Xmax(array,num*2),Ymax(array,num*2));
    free(array);    return 0;}  
int Xmin(int a[],int n){
    int i;
    int ret=-1;    //输出接口 
    int tem=a[0];
    for(i=2;i<n;i=i+2){
        if(tem<a[i]);
        else {
            tem=a[i];
        }
    }
    ret=tem;
    return ret;
}
 
int Xmax(int a[],int n){
    int i;
    int ret=-1;    //输出接口 
    int tem=a[0];
    for(i=2;i<n;i=i+2){
        if(tem>a[i]);
        else {
            tem=a[i];
        }
    }
    ret=tem;
    return ret;
}
 
int Ymin(int a[],int n){
    int i;
    int ret=-1;    //输出接口 
    int tem=a[1];
    for(i=3;i<n;i=i+2){
        if(tem<a[i]);
        else {
            tem=a[i];
        }
    }
    ret=tem;
    return ret;
}
 
int Ymax(int a[],int n){
    int i;
    int ret=-1;    //输出接口 
    int tem=a[1];
    for(i=3;i<n;i=i+2){
        if(tem>a[i]);
        else {
            tem=a[i];
        }
    }
    ret=tem;
    return ret;
}
```


请教各位大神，注释的那句//	printf("%d",array[i]);为什么一定要加，不加程序就会停止运行，不应该啊。加了之后，程序就没有问题了。

问题的核心不在这里，而是申请的内存不够，array=(int*)malloc(2*num*sizeof(int));这样就对了。下面是两个其他的参考程序。

```cpp
#include <stdio.h>  
#define ARRAY_SIZE 100  
struct Point {  
    int x;  
    int y;  
};  
struct Point p[ARRAY_SIZE];  
int main(void) {  
    int i, n;  
    int min_x, max_x, min_y, max_y;  
    scanf("%d", &n);  
    for(i = 0; i < n; ++i)  
        scanf("%d%d", &p[i].x, &p[i].y);  
    min_x = max_x = p[0].x;  
    min_y = max_y = p[0].y;  
    for(i = 1; i < n; ++i) {  
        if(min_x > p[i].x)  
            min_x = p[i].x;  
        if(max_x < p[i].x)  
            max_x = p[i].x;  
        if(min_y > p[i].y)  
            min_y = p[i].y;  
        if(max_y < p[i].y)  
            max_y = p[i].y;  
    }  
    printf("%d %d %d %d\n", min_x, min_y, max_x, max_y);  
    return 0;  
}
```

```cpp
#include<stdio.h>
int main(){
int n,i;
scanf("%d",&n);
int a[n],b[n];
for( i=0;i<n;i++){
scanf("%d%d",&a[i],&b[i]);
}
for(i=0;i<n;i++){
printf("(%d,%d)",a[i],b[i]);
}
printf("\n");
int minx,maxx;
minx=maxx=a[0];
for(i=1;i<n;i++){
if(a[i]<minx){
minx=a[i];
}
if(a[i]>maxx){
maxx=a[i];
}
}
int miny,maxy;
miny=maxy=b[0];
for(i=1;i<n;i++){
if(b[i]<miny){
miny=b[i];
}
if(b[i]>maxy){
maxy=b[i];
}
}
printf("%d%d%d%d",minx,miny,maxx,maxy);
printf("\n");
return 0;
}
```

下面是动态结构体数组的方法，这种方法比较好，实用性比较强！

```cpp
/**/

#include <stdio.h>
#include <stdlib.h>

//定义顶点坐标结构体 
struct PointXY{
	int x;
	int y;
};

main(){
	int num,i,j,min_x,max_x,min_y,max_y;
	scanf("%d",&num); 
	struct PointXY *p; 
	p=(struct PointXY*)malloc(num*sizeof(struct PointXY));    //申请内存空间并强制转换
	for(i=0;i<num;i++){
		scanf("%d%d",&p[i].x,&p[i].y);
		min_x = max_x = p[0].x;    
	    min_y = max_y = p[0].y;    
	    for(j = 1; j < num; j++) {    
        if(min_x > p[j].x)    
            min_x = p[j].x;    
        if(max_x < p[j].x)    
            max_x = p[j].x;    
        if(min_y > p[j].y)    
            min_y = p[j].y;    
        if(max_y < p[j].y)    
            max_y = p[j].y;   
		}
	} 
	printf("%d %d %d %d\n", min_x, min_y, max_x, max_y);  
free(p);  
    return 0;    
}
```





