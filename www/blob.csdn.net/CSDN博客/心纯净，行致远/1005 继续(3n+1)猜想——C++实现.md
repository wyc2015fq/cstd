# 1005 继续(3n+1)猜想——C++实现 - 心纯净，行致远 - CSDN博客





2018年11月20日 21:59:41[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：606








# 题目

> 
1005 继续(3n+1)猜想 （25 point(s)）

卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。

当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。

现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。

### 输入格式：

每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (<100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1<n≤100)的值，数字间用空格隔开。

### 输出格式：

每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。

### 输入样例：

```
6
3 5 6 7 8 11
```

### 输出样例：

```
7 6
```


# 算法

这道题目和第一道题目有联系[1001 害死人不偿命的(3n+1)猜想 ——C++实现](https://blog.csdn.net/zhanshen112/article/details/84254230)。在找出某个数字迭代过程的非关键数时，需要将后面的输入进行标记，从而不需要在对后面的数据进行标记。这是一般的思路。

### 笨方法

至于实现的方法，最开始我用的方法比较笨，用C实现，建立四个数组

```cpp
int K[100];	//save the test numbers;
int r[100];    //the copy of K[100]
int FuGai[100];	//save the fugai numbers
int KeyNum[10000];	//save the key numbers
```

 将所有计算的覆盖数存起来，再和输入数据对照。如果输入数据有，则说明输入的数据不是关键数，筛选之后，最后剩下的输入数据就是关键数了。这种方法容易理解，但是技巧性显然不足，因为需要将后面的所有数字的关键数都计算出来。实际上，后面的数字经过判断，有些数字是不需要计算的。这种思路的代码是代码1部分

### 升级版

在做了很多PAT乙级的题目之后，现在来做，思路是这样的：使用vector容器存储，使用<algorithm>的sort（）函数进行排序。一次将所有数据存入vector，计算每个数字的覆盖数之后，就将后面vector中属于覆盖数的数字进行标记，赋值为0。这样后面只要进行非零数就可以跳过是覆盖数的vector。最后进行sort（）排序。

sort函数是极其好用的函数，要和返回值为bool类型的cmp函数结合使用，注意使用时要带上头文件<algorithm>。最后输出的时候，由于第一个数字前面不需要带空格，因此可以设置一个标志位flag=0，第一个数据输出后（输出时需要满足flag==1，才输出空格），将flag=1即可，就可以保证第二个数字开始，每个数字之前都有空格。这里实际上是把第一个数字之后的每一个数字和其前面的空格捆绑在一起看待。具体见代码2部分。

### 哈希散列——高级版

上面的升级版可以很好地解决这个问题。但是随之而来的问题是必须要用户全部输入才可以进行判断。也就是现在根据用户输入的某一个数字，只能针对之前输入的数据有效。此次输入的数字是不是关键数已经形成结论，无法在后续输入计算后调整之前的是不是关键数的判断。

带来的问题也显然，就是时间复杂度2*O(n)。因为前后有两个0~n-1的for循环。

哈希散列就可以解决这个问题，并且将时间复杂度降低到升级版的一般，也就是O(n)。这也是理论上最低的时间复杂度了。

哈希散列的思想是这样的：类似于函数因变量与自变量的关系，自变量到因变量的映射只能是一对一和多对一。因此，在计算出用户输出的某个数字的覆盖数之后，将覆盖数部分放置在一个新数组中，并全部置1，这样当有新的数字计算后使得原来不是覆盖数的原始数字也会置1。这样，最后剩下的就是没有置1的数字，它们就是关键数。

这里存在两个映射：

每一个InputNum，会将其覆盖数全部置1；

每一个输入数字的序号对应一个InputNum.

因此只要每一个输入数字序号对应的数字的散列数组值仍然为0，就说明不是覆盖数，就可以输出。对应代码3部分。

2018.12.04

vector也可以不申请大小，动态申请，采用v.push_back(i)。但是一定不能先申请大小，又v.push_back()，因为这样会把申请大小的vector都认为是0，也带进去。见代码4.

# 代码

代码1

```cpp
#include <stdio.h>
 
 int main(){
 	int n;	//save the number's of input
	scanf("%d",&n);
	int K[100];	//save the test numbers;
	int r[100];
	int FuGai[100];	//save the fugai numbers
	int KeyNum[10000];	//save the key numbers
	int i;	//cyclic variable 
	
	for(i=0;i<100;i++){ 
		K[i]=0;	//K[100] init value
	    FuGai[i]=0;	//FuGai[100] init value
	}
	
	for(i=0;i<n;i++) 
		scanf("%d",&K[i]);
	for(i=0;i<n;i++) 
		r[i]=K[i];
			
	int j=0,tem,t=0,m=0,y=0;
	for(j=0;j<n;j++){
		while((K[j]!=0)&&(K[j]!=1)){
			if(K[j]%2==0)	//even number
			   {
					tem=K[j]/2;
			   }
			if(K[j]%2==1)	//odd number
			   {
					tem=(K[j]*3+1)/2;
			   }
			K[j]=tem;
			FuGai[t]=K[j];
			t++;
			}	
	}
	
	// screen out the key numbers
	int flag=1;	//if flag==0,not kaynum;else,keynum
	for(m=0;m<n;m++){
		for(j=0;j<t;j++)
	    {
			if(r[m]-FuGai[j]==0){
				flag=0;
				break;
			}
		}
		if(flag==1){
			KeyNum[y++]=r[m];
		}
		flag=1;	
	}
	
	//sort out KeyNum,from max to min 
	int temp;
	for(i=0;i<y-1;i++){
		for(j=i;j<y;j++){
			if(KeyNum[i]<KeyNum[j]){
				temp=KeyNum[j];
				KeyNum[j]=KeyNum[i];
				KeyNum[i]=temp;
			}
		}
	}
	
	for(i=0;i<y-1;i++)
	printf("%d ",KeyNum[i]);
	printf("%d",KeyNum[y-1]);

 	return 0;
 }
```

代码2

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool cmp(int a,int b){	//搭配sort()函数，根据返回值可确定排列方式 
	return a>b;
}
int main(){
	int n,tmp,flag=0;	cin>>n;
	vector<int> m(n);
	for(int i=0;i<n;i++){
		cin>>tmp;
		m[i]=tmp;
	}
	for(int i=0;i<n;i++){	 
		if(m[i]){	//vector必须是非零的 
			tmp=m[i];
			while(tmp!=1){
				if(tmp%2==1) tmp=3*tmp+1;
				tmp/=2;
				for(int j=0;j<n;j++){	//将非keynum置零 
					if(tmp==m[j]&&m[j]!=0)	//置零之后无需再次置零 
						m[j]=0;	
				}
			}
		}	
	}
	sort(m.begin() ,m.end() ,cmp);	//根据cmp的返回值类型确定排序方式 
	for(int i=0;i<n;i++){
		if(m[i]){
			if(flag==1)	cout<<" ";
			cout<<m[i];
		}
		flag=1;
	}
	return 0;
}
```

代码3

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int arr[10000];
bool cmp(int a, int b) {return a > b;}
int main() {
    int k, n, flag = 0;
    cin >> k;
    vector<int> v(k);
    for (int i = 0; i < k; i++) {
        cin >> n;
        v[i] = n;
        while (n != 1) {
            if (n % 2 != 0) n = 3 * n + 1;
            n = n / 2;
            if (arr[n] == 1) break;
            arr[n] = 1;
        }
    }
    sort(v.begin(), v.end(), cmp);
    for (int i = 0; i < v.size(); i++) {
        if (arr[v[i]] == 0) {
            if (flag == 1) cout << " ";
            cout << v[i];
            flag = 1;
        }
    }
    return 0;
}
```

**对每一个输入的数字n进行验证，把验证过的数字对应的arr标记为1，然后对这些输入的数字从大到小排序，输出所有arr=0的数字即为关键数字～ **

**代码4**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool cmp(int a,int b){
	return a>b;
}
int main(){
	int K,flag=0;	cin>>K;
	int a[10000]={0};
	vector<int> v;
	for(int i=0;i<K;i++){
		int tmp;	cin>>tmp;
		v.push_back(tmp) ;
		while(tmp!=1){
			if(tmp%2==1)	tmp=3*tmp+1;
			tmp/=2;
			if(a[tmp]==0)	a[tmp]=1;;		
		}
	}
	sort(v.begin() ,v.end() ,cmp);
	for(int i=0;i<v.size() ;i++){
		if(a[v[i]]==0){
			if(flag==1)	cout<<" ";
			cout<<v[i];
			flag=1;
		}
	}
	return 0;
}
```





