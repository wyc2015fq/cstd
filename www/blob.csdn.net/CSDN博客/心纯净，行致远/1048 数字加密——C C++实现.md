# 1048 数字加密——C/C++实现 - 心纯净，行致远 - CSDN博客





2018年11月04日 20:42:01[吉大秦少游](https://me.csdn.net/zhanshen112)阅读数：141








> 
1048 数字加密 （20 分）

本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。

### 输入格式：

输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。

### 输出格式：

在一行中输出加密后的结果。

### 输入样例：

```
1234567 368782971
```

### 输出样例：

```
3695Q8118
```


**思路：**

由于A/B均是不超过100位，所以显然用字符串数组存储更好。在使用过程中再利用

```cpp
a[i]-'0'
```

转换为数字。还有要注意的是很可能A短或者B短，这时候短的字符串数组就需要在前面补0了。求出的数字可以先存储起来，再逆序输出。代码1是第一次做。

2018.12.02

这道题第二次做竟然也花了很长时间，一直调试不对，大约有一个半小时。。。。。很大的原因是以为当B比A短时，不能直接把剩余的B存起来，因为还要进行奇数偶数的判断和处理。。。麻烦得要死，好在最后调试对了。不知道是我的理解有问题还是题目可以叙述的在明确一些，真是蛋疼~~~

当然我当时也想到了补全0 的想法，但是感觉我自己的想法也没问题啊，这条路应该是通的，谁知道还有这么多坑，代码2是辛苦调试一个半小时的。。。

核心部分：**当两个字符串不一样长时，也应该按照法则去处理，千万不要跳过这一步。比如B-A中的字符串如果有‘0’而且在偶数位就不能采用10-‘c’的形式。**

**代码3是看了别人补全0的思路实现的代码，使用append()函数确实很方便将其补全，可以AC。**

**如果不知道这个函数，也可以利用for循环在字符串的后面加上‘0’形成新的字符串。见代码4，但是很奇怪却不能AC。**

**代码：**

**代码1：C**

```cpp
//1048 数字加密 V1
#include <stdio.h>
#include <string.h>
int main(){
	char a[110],b[110];
	char ref[13]={'0','1','2','3','4','5','6','7','8','9','J','Q','K'};
	scanf("%s %s",a,b);
	int n1=strlen(a),n2=strlen(b);
	int flag=1,i,j;	//flag用来记录奇数或偶数
	char ans[110]={0};int k=0;
	for(i=n1-1,j=n2-1;i>=0&&j>=0;i--,j--){
		if(flag%2==1){	//奇数 
			ans[k++]=ref[(a[i]-'0'+b[j]-'0')%13];
		}
		else{	//偶数 
			int t=b[j]-'0'-(a[i]-'0');
			if(t<0)	t+=10;
			ans[k++]=t+'0'; 
		}
		flag++;
	} 
	if(i<0){	//A短 
		int p;
		for(p=j;p>=0;p--){
			if(flag%2==1){
				ans[k++]=ref[(0+b[p]-'0')%13];
			}
			else{
				int t=b[p]-'0'-0;
				if(t<0)	t+=10;
				ans[k++]=t+'0'; 
			}
			flag++;
		} 
	}
	if(j<0){	//B短 
		int p;
		for(p=i;p>=0;p--){
			if(flag%2==1){
				ans[k++]=ref[(a[p]-'0'+0)%13];
			}
			else{
				int t=0-(a[p]-'0');
				if(t<0)	t+=10;
				ans[k++]=t+'0'; 
			}
			flag++;
		} 
	}
	int n3=strlen(ans);
	for(i=n3-1;i>=0;i--){
		printf("%c",ans[i]);
	}
	return 0;
}
```

代码2：C++

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
int main(){
	string s1,s2,s3,s4="0123456789JQK";	cin>>s1>>s2;
	int i,k,j=0;
	reverse(s1.begin() ,s1.end() );
	reverse(s2.begin() ,s2.end() );
	for(i=0;i<s2.length() ;i++){
		if(i<s1.length() ){	//s2[i]小于s1长度的部分 
			if((i+1)%2==1)		s3+=s4[(s1[i]-'0'+s2[i]-'0')%13];
			else{
				if(s2[i]-'0'-(s1[i]-'0')<0)	s3+=s2[i]-'0'-(s1[i]-'0')+'0'+10;
				else	s3+=s2[i]-'0'-(s1[i]-'0')+'0';
			}
		}
		else{
			if((i+1)%2==1)		s3+=s4[(s2[i]-'0')%13];
			else	s3+=s2[i];
		}	
	}
	for(i;i<s1.length() ;i++){
		if((i+1)%2==1)	s3+=s4[(s1[i]-'0')%13];
		else{
			if(s1[i]-'0') s3+=10-(s1[i]-'0')+'0';
			else s3+='0';
		}	
	}		
	reverse(s3.begin() ,s3.end() );
	cout<<s3;
	return 0;
}
```

从代码2可以看出我的代码很大比例集中在分类处理上，这么多if-else。。。实际上核心处理的代码不应该很多的。

代码3：补全0的思路

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
	string s1,s2,s3,s4="0123456789JQK";	cin>>s1>>s2;
	reverse(s1.begin() ,s1.end() );
	reverse(s2.begin() ,s2.end() );
	if(s1.length() <s2.length() )	s1.append(s2.length() -s1.length() ,'0') ;
	else	s2.append(s1.length() -s2.length(),'0') ;
	for(int i=0;i<s1.length() ;i++){
		if((i+1)%2==1)	s3+=s4[(s1[i]-'0'+s2[i]-'0')%13];
		else{
			if(s2[i]-'0'-(s1[i]-'0')<0)	s3+=s2[i]-'0'-(s1[i]-'0')+10+'0';
			else s3+=s2[i]-'0'-(s1[i]-'0')+'0';
		}
	}
	reverse(s3.begin() ,s3.end() );
	cout<<s3;
	return 0;
}
```

代码4：存在bug

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
int main(){
	string s1,s2,s3,s4="0123456789JQK";	cin>>s1>>s2;
	reverse(s1.begin() ,s1.end() );
	reverse(s2.begin() ,s2.end() );
	if(s1.length() <s2.length() )
		for(int i=0;i<s2.length()-s1.length()  ;i++)	s1=s1+'0';	
	else
		for(int i=0;i<s1.length()-s2.length()  ;i++)	s2=s2+'0';		
	for(int i=0;i<s1.length() ;i++){
		if((i+1)%2==1)	s3+=s4[(s1[i]-'0'+s2[i]-'0')%13];
		else{
			if(s2[i]-'0'-(s1[i]-'0')<0)	s3+=s2[i]-'0'-(s1[i]-'0')+10+'0';
			else s3+=s2[i]-'0'-(s1[i]-'0')+'0';
		}
	}
	reverse(s3.begin() ,s3.end() );
	cout<<s3;
	return 0;
}
```





