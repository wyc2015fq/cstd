# [多重纹理技术] - gauss的专栏 - CSDN博客
2011年12月13日 22:56:43[gauss](https://me.csdn.net/mathlmx)阅读数：649
**第二卷 更完美的3D世界**
第十三集 多重纹理技术
RGB或Alpha的N次混合的美化名称 --- "多重纹理技术".
纹理可以理解为存放ARGB数据的特殊图片, 纹理的混合实质是上一集的Alpha-Blend更完美的应用. 当然, 纹理的混合更被重视, 所以DirectX Graphics中专门为它建立了高效的流水线,
HRESULT IDirect3DDevice9::SetTextureStageState
                          (DWORD Stage, 
                           D3DTEXTURESTAGESTATETYPE Type,
                           DWORD Value);
参考DirectX9c SDK中的Texture Blending主题.
**13.1 Texture Stage**
    现在的显卡基本都支持多重纹理, 区别在于流水线的多少和混合类型的多少. 而且流水线的输入参数可能也有区别, 普通的有两个输入参数, 特殊的有三个输入参数. 下面默认使用两个输入参数.
13.1.1 Texture Stage的工作原理
    每个Texture Stage有两个输入的颜色参数, 两个输入参数不能同时都是纹理. 在内部, 将输入的参数拆分为RGB部分和Alpha部分, 将每个参数的RGB按颜色操作系数进行混合, 同样每个参数的Alpha按Alpha操作系数进行混合, 如图13.1,
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C01.JPG)
图13.1
13.1.2 Texture Blending Cascade
    多个Texture Stage组成一个整体的瀑布型纹理流水线, 当前Texture Stage的一个输入参数是上一级Texture Stage的混合结果, 最终瀑布型纹理流水线的输出将映射到物体上. 瀑布型纹理流水线如图13.2
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C02.JPG)
图13.2
DirectX Graphics默认支持8层, 但实际还要看显卡能支持的层数.
**13.2 输入参数和混合类型**
    瀑布型纹理流水线提供了纹理混合的场所, 最后混合的纹理颜色则取决于每层Texture Stage的输入参数和混合类型.
13.2.1 输入参数
输入参数可以分为以下几种,
(1). 纹理图片. 
(2). 物体自身的颜色(包括光源对物体颜色的贡献).
(3). 静态常量颜色. 
(4). 上层Texture Stage的输出颜色
13.2.2 混合类型
纹理混合运算类型定义RGB和Alpha混合可以使用的运算类型, 在D3DTEXTUREOP中有详细的描述, 可以大致分成以下几种类型,
(1). 禁用(D3DTOP_DISABLE). 当上层颜色系数使用这个类型时, 余下的Texture Stage将不在进行任何混合运算.
(2). 选择(D3DTOP_SELECTARG1, D3DTOP_SELECTARG2). 不进行两个参数的混合运算,
     直接选取输入参数中的一个为当前层的输出结果.
(3). 一般算术运算. 两个参数之间的普通算术运算.
     D3DTOP_MODULATE,  D3DTOP_MODULATE2X,  D3DTOP_MODULATE4X
     D3DTOP_ADD,       D3DTOP_ADDSIGNED,   D3DTOP_ADDSIGNED2X
     D3DTOP_SUBTRACT,  D3DTOP_ADDSMOOTH,   D3DTOP_DOTPRODUCT3
(4). 和Alpha属性有关的算术运算. 算术运算中有Alpha值的参与, Alpha来源按运算的不同而不同.
(5). 有凹凸纹理参与的运算.
**13.3 简单混合实现**
13.3.1 单层混合结果
只使用Texture Stage 0, 这层的DirectX Graphics默认设置为,
a.
参数1为纹理颜色 : SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE)
b. 参数2因为没有上层Texture Stage的输出颜色, 所以是物体的漫反射颜色.
SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT)
c. 混合系数 : SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE)
可以观察game5 project中5个物体的纹理, game5中使用的是点光源, 将纹理和光源产生的漫反射颜色混合(这里是相乘), 得到混合的纹理, 如图13.3,
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C03.JPG)
图13.3
当混合系数改为SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE), 物体表面只显示漫反射颜色. 效果同SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG2)一样,
 表示最终的颜色直接是输入参数2.
13.3.2 带Alpha的单层混合
现在给顶点加上漫反射属性, 设置漫反射数值D3DCOLOR_ARGB(128, 0, 128, 0), 按Texture Stage 0 的默认设置, 结果如图13.4,
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C04.JPG)
图13.4
改变混合系数改为SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_BLENDDIFFUSEALPHA), 这时物体漫反射颜色数值带的Alpha数值就成为了颜色混合的一个比例系数, 单位化Alpha = 0.5, 输出的颜色按Color = Arg1 * Alpha + Arg2 * (1 - Alpha)得到,
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C05.JPG)
图13.5
**13.4 单层混合的例子**
13.4.1 代码更新
我们来看看game14的主要更新的代码(下载game14 project),
---------------------------------------------------------------
// d9graphics.cpp中, 根据鼠标选取的混合类型更新
VOID CD9Graphics::UpdateOP(INT nFlag)
{
   g_operator += nFlag;
   if (g_operator < 0)
   {
        g_operator = 18;
   }
   else if (g_operator > 18)
   {
        g_operator = 0;
   }
   m_pDev->SetTextureStageState(0, D3DTSS_COLOROP, g_aTexOP[g_operator]);
}
VOID CD9Graphics::Render()
{
//...
m_pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
    if (FAILED(m_pDev->BeginScene()))
   {
        return;
   }
   m_pDev->SetStreamSource(0, m_pVB, 0, sizeof(MYVERTEXTEX));
   m_pDev->SetFVF(D3DFVF_MYVERTEXTEX);
   m_pDev->SetTexture(0, m_pTexture);
   m_pDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0,  2);  
   m_pDev->EndScene();
    h = m_pDev->Present(NULL, NULL, NULL, NULL);
//...
}
---------------------------------------------------------------
13.4.2 例子说明
例子中使用物体顶点都包含ARGB(128, 0, 128, 0)的颜色, 纹理中包含Alpha数值, 根据不同的混合操作, 最终的纹理不同. 例子中使用点光源. 这个例子中的Alpha混合基本没有任何作用.
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C06.JPG)
**13.5 多层混合**
这里使用两层, 3 – 8层的设置同2层相似. 这里每层的输入参数取固定值, 其他输入参数类型参考DirectX 9c SDK中的D3DTA主题.
Texture Stage 0-1 的两个输入参数为，
Color – Arg1 : D3DTA_TEXTURE; Alpha – Arg1 : D3DTA_TEXTURE
Color - Arg2 : D3DTA_CURRENT; Alpha - Arg2 : D3DTA_CURRENT
13.5.1 多层混合
理解了单层混合后, 多层混合就很简单了, 多层混合的两个特点,
(1). 当前层的一个输入参数是上一层的输出结果.
(2). 可以实现多张纹理的混合.
//将第二张纹理设置到第二层
m_pDev->SetTexture(1, m_pTexture2);
// 第二层的纹理坐标和第一层的相同
m_pDev->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);
// 第二层的颜色参数设置, 颜色混合类型的设置
m_pDev->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
m_pDev->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);
m_pDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_ADDSMOOTH);
// 第二层的Alpha参数设置, Alpha混合类型的设置
// …
// 绘制图元
m_pDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0,  2);
// 建议完成以后关闭不需要的层
m_pDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
// …
**13.6 多层混合的例子**
13.6.1 例子说明
game15类似game14, 选取每层的混合系数, 混合的最终纹理效果不同. 例子固定了每层两个输入参数的类型, 可以改成其他类型再测试效果. 先选取不同的Texture Stage层, 然后点击color blend operator和Alpha blend opeartor选择框中的箭头为每层的混合选取不同的系数.
例子代码中的hard code希望大家谅解, 哈哈.
![](https://p-blog.csdn.net/images/p_blog_csdn_net/Jaredz/193444/o_C07.JPG)
本文转载:http://blog.csdn.net/jaredz/article/details/871692
