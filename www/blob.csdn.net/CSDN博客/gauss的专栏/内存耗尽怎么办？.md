# 内存耗尽怎么办？ - gauss的专栏 - CSDN博客
2013年01月04日 00:23:43[gauss](https://me.csdn.net/mathlmx)阅读数：325
个人分类：[C/C++/内存管理](https://blog.csdn.net/mathlmx/article/category/605906)
                
如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。
　　（1）判断指针是否为NULL，如果是则马上用return语句终止本函数。例如：
void Func(void)
{
　A *a = new A;
　if(a == NULL)
　{
　　return;
　}
　…
}
　（2）判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。例如：
void Func(void)
{
　A *a = new A;
　if(a == NULL)
　{
　　cout << “Memory Exhausted” << endl;
　　exit(1);
　}
　…
}
　　（3）为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。详细内容请参考C++使用手册。
　　上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。
　　很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”
　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。
　　有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。我在Windows 98下用Visual C++编写了测试程序，见示例7。这个程序会无休止地运行下去，根本不会终止。因为32位操作系统支持“虚存”，内存用完了，自动用硬盘空间顶替。我只听到硬盘嘎吱嘎吱地响，Window 98已经累得对键盘、鼠标毫无反应。
　　我可以得出这么一个结论：对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。
我不想误导读者，必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。
void main(void)
{
　float *p = NULL;
　while(TRUE)
　{
　　p = new float[1000000]; 
　　cout << “eat memory” << endl;
　　if(p==NULL)
　　　exit(1);
　}
}
1.1.9 malloc/free的使用要点
函数malloc的原型如下：
void * malloc(size_t size);
用malloc申请一块长度为length的整数类型的内存，程序如下：
int *p = (int *) malloc(sizeof(int) * length);
我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。
* malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型。
* malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：
cout << sizeof(char) << endl;
cout << sizeof(int) << endl;
cout << sizeof(unsigned int) << endl;
cout << sizeof(long) << endl;
cout << sizeof(unsigned long) << endl;
cout << sizeof(float) << endl;
cout << sizeof(double) << endl;
cout << sizeof(void *) << endl;
在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。
函数free的原型如下：
void free( void * memblock );
为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。
1.1.10 new/delete的使用要点
运算符new使用起来要比函数malloc简单得多，例如：
int *p1 = (int *)malloc(sizeof(int) * length);
int *p2 = new int[length];
这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如
class Obj
{
　public :
　　Obj(void); // 无参数的构造函数
　　Obj(int x); // 带一个参数的构造函数
　　…
}
void Test(void)
{
　Obj *a = new Obj;
　Obj *b = new Obj(1); // 初值为1
　…
　delete a;
　delete b;
}
如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：
Obj *objects = new Obj[100]; // 创建100个动态对象
不能写成：
Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1
在用delete释放对象数组时，留意不要丢了符号‘[]’。例如：
delete []objects; // 正确的用法
delete objects; // 错误的用法
后者有可能引起程序崩溃和内存泄漏。
转自：[http://hi.baidu.com/yzhangtong/blog/item/c53325b78258f9f230add1d7.html](http://hi.baidu.com/yzhangtong/blog/item/c53325b78258f9f230add1d7.html)
