# 纯虚函数的使用汇总 - gauss的专栏 - CSDN博客
2013年01月04日 00:17:57[gauss](https://me.csdn.net/mathlmx)阅读数：255
个人分类：[C/C++/内存管理](https://blog.csdn.net/mathlmx/article/category/605906)
[http://hi.baidu.com/%C3%E2%B7%D1%B4%F3%BB%B0%D0%F2%C1%D0%BA%C5/blog/item/e8c7c10fc021a1e7aa645729.ht](http://hi.baidu.com/%C3%E2%B7%D1%B4%F3%BB%B0%D0%F2%C1%D0%BA%C5/blog/item/e8c7c10fc021a1e7aa645729.ht)
一、抽象类
含有纯虚函数的类被称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承结构的上层。抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为受保护的访问控制权限。
抽象类的主要作用就是描述一组相关子类的通用操作接口。一般而言，抽象类只描述这组子类共同的操作接口，而实现交给子类来完成。
抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类没有重新定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它就可以创建该类的实例了。
举个例子来说，比如我们设计了一个交通工具的抽象类。显而易见的，由交通工具类可以派生出汽车类，飞机类等具备具体特性的类。但是对于基类交通工具来说，它的特性却是模糊的，广泛的，此时建立一个交通工具类的对象是没有任何实际意义的，对于这种没有必要建立对象的类进行约束，c++引入了抽象类的特性，而抽象类的约束控制来自于纯虚函数。
示例代码：
class Vehicle
{
public:
Vehicle(float speed,int total)
{
Vehicle::speed = speed;
Vehicle::total = total;
}
virtual void ShowMember()=0;//纯虚函数的定义
protected:
float speed;
int total;
};
class Car:public Vehicle
{
public:
Car(int aird,float speed,int total):Vehicle(speed,total)
{
Car::aird = aird;
}
virtual void ShowMember()//派生类成员函数重载
{
cout<<speed<<"|"<<total<<"|"<<aird<<endl;
}
protected:
int aird;
};
int main()
{
//Vehicle a(100,4);//错误,抽象类不能创建对象
Car b(250,150,4);
b.ShowMember();
system("pause");
}
二、纯虚函数
1、定义
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
virtual void funtion()=0；
虚函数的定义是：virtual void funtion()；
2、引入原因
1、为了方便使用多态特性，我们常常需要在基类中定义虚函数。
2、但在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重载以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
3、如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。
4、在子类中一定要实现纯虚函数的定义，不然编译时会出错。
程序举例：
基类:
class A
{
public:
A();
void f1();
virtual void f2();
virtual void f3()=0;
virtual ~A();
};
子类:
class B : public A
{
public:
B();
void f1();
void f2();
void f3();
virtual ~B();
};
void main()
{
A *m_j=new B();
m_j->f1();
m_j->f2();
m_j->f3();
delete m_j;
}
f1()是一个普通的重载. 调用m_j->f1();会去调用A类中的f1(),它是在我们写好代码的时候就会定好的. 也就是根据它是由A类定义的,这样就调用这个类的函数.
f2()是虚函数. 调用m_j->f2();会调用m_j中到底保存的对象中,对应的这个函数.这是由于new的B对象.
f3()与f2()一样,只是在基类中不需要写函数现实
1． 虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类（abstract class），而只含有虚函数的类（class）不能被称为抽象类（abstract class）。
2． 虚函数可以被直接使用，也可以被子类（sub class）重载以后以多态的形式调用，而纯虚函数必须在子类（sub class）中实现该函数才可以使用，因为纯虚函数在基类（base class）
只有声明而没有定义。
3． 虚函数和纯虚函数都可以在子类（sub class）中被重载，以多态的形式被调用。
4． 虚函数和纯虚函数通常存在于抽象基类（abstract base class -ABC）之中，被继承的子类重载，目的是提供一个统一的接口。
5． 虚函数的定义形式：virtual    {method body}
    纯虚函数的定义形式：virtual    { } = 0;
      在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定（run-time bind），而且被两者修饰的函数生命周期（life recycle）也不一样。
   6.如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类（ABC）是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。
       以下为一个简单的虚函数和纯虚寒数的使用演示，目的是抛砖引玉！
#include <>
//father class
class Virtualbase
{
public:
        virtual void Demon()= 0; //prue virtual function
        virtual void Base() {cout<<"this is farther class"<<endl};
}
//sub class
class SubVirtual :public Virtualbase
{
public:
    void Demon() { cout<<" this is SubVirtual!"<<endl};
    void Base() { cout<<"this is subclass Base"<};
}
/* instance class and sample */
int main()
{
        Virtualbase* inst = new SubVirtual(); //multstate pointer
        inst->Demon();
        inst->Base();
}
虚函数和纯虚函数区别
观点一：
类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，这样的话，这样编译器就可以使用后期绑定来达到多态了
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
class A{
protected:
    void foo();//普通类函数
    virtual void foo1();//虚函数
    virtual void foo2() = 0;//纯虚函数
}
观点二：
虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现
观点三：
虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然我们也可以完成自己的实现。纯虚函数的类用于“介面继承”，主要用于通信协议方面。关注的是接口的统一性，实现由子类完成。一般来说，介面类中只有纯虚函数的。
观点四：
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，（否则会出现错误！）而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。虚函数是为了继承接口和默认行为
纯虚函数只是继承接口，行为必须重新定义。           
