# QT的信号与槽机制介绍（1） - gauss的专栏 - CSDN博客
2011年12月11日 09:25:07[gauss](https://me.csdn.net/mathlmx)阅读数：232标签：[qt																[编程																[compiler																[工具																[linux																[桌面环境](https://so.csdn.net/so/search/s.do?q=桌面环境&t=blog)](https://so.csdn.net/so/search/s.do?q=linux&t=blog)](https://so.csdn.net/so/search/s.do?q=工具&t=blog)](https://so.csdn.net/so/search/s.do?q=compiler&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=qt&t=blog)
转http://www.lupaworld.com/tutorial-view-aid-10463.html
QT是一个跨平台的C++ GUI应用构架，它提供了丰富的窗口部件集，具有面向对象、易于扩展、真正的组件编程等特点，更为引人注目的是目前Linux上最为流行的
KDE桌面环境就是建立在QT库的基础之上。QT支持下列平台：MS/WINDOWS-95、98、NT和2000；UNIX/X11-Linux、Sun Solaris、HP-UX、Digital Unix、IBM AIX、SGI IRIX；EMBEDDED-支持framebuffer的Linux平台。伴随着KDE的快速发展和普及，QT很可能成为Linux窗口平台上进行软件开发时的GUI首选。
一、概述
信号和槽机制是QT的核心机制，要精通QT编程就必须对信号和槽有所了解。信号和槽是一种高级接口，应用于对象之间的通信，它是QT的核心特性，也是QT区别于其它工具包的重要地方。信号和槽是QT自行定义的一种通信机制，它独立于标准的C/C++语言，因此要正确的处理信号和槽，必须借助一个称为moc（Meta Object Compiler）的QT工具，该工具是一个C++预处理程序，它为高层次的事件处理自动生成所需要的附加代码。
在我们所熟知的很多GUI工具包中，窗口小部件(widget)都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在QT中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。信号和槽能携带任意数量和任意类型的参数，他们是类型完全安全的，不会像回调函数那样产生core dumps。
所有从QObject或其子类(例如Qwidget)派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射(emit)出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。
你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。
二、信号
当某个信号对其客户或所有者发生的内部状态发生改变，信号被一个对象发射。只有定义过这个信号的类及其派生类能够发射这个信号。当一个信号被发射时，与其相关联的槽将被立刻执行，就象一个正常的函数调用一样。信号-槽机制完全独立于任何GUI事件循环。只有当所有的槽返回以后发射函数（emit）才返回。如果存在多个槽与某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地执行，但是它们执行的顺序将会是随机的、不确定的，我们不能人为地指定哪个先执行、哪个后执行。
信号的声明是在头文件中进行的，QT的signals关键字指出进入了信号声明区，随后即可声明自己的信号。例如，下面定义了三个信号：
signals:
void mySignal();
void mySignal(int x);
void mySignalParam(int x,int y);
在上面的定义中，signals是QT的关键字，而非C/C++的。接下来的一行void mySignal() 定义了信号mySignal，这个信号没有携带参数；接下来的一行void mySignal(int x)定义了重名信号mySignal，但是它携带一个整形参数，这有点类似于C++中的虚函数。从形式上讲信号的声明与普通的C++函数是一样的，但是信号却没有函数体定义，另外，信号的返回类型都是void，不要指望能从信号返回什么有用信息。
信号由moc自动产生，它们不应该在.cpp文件中实现。
三、槽
槽是普通的C++成员函数，可以被正常调用，它们唯一的特殊性就是很多信号可以与其相关联。当与其关联的信号被发射时，这个槽就会被调用。槽可以有参数，但槽的参数不能有缺省值。
既然槽是普通的成员函数，因此与其它的函数一样，它们也有存取权限。槽的存取权限决定了谁能够与其相关联。同普通的C++成员函数一样，槽函数也分为三种类型，即public slots、private slots和protected slots。
public slots：在这个区内声明的槽意味着任何对象都可将信号与之相连接。这对于组件编程非常有用，你可以创建彼此互不了解的对象，将它们的信号与槽进行连接以便信息能够正确的传递。
protected slots：在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。这适用于那些槽，它们是类实现的一部分，但是其界面接口却面向外部。
private slots：在这个区内声明的槽意味着只有类自己可以将信号与之相连接。这适用于联系非常紧密的类。槽也能够声明为虚函数，这也是非常有用的。
槽的声明也是在头文件中进行的。例如，下面声明了三个槽：
public slots:
void mySlot();
void mySlot(int x);
void mySignalParam(int x,int y);
