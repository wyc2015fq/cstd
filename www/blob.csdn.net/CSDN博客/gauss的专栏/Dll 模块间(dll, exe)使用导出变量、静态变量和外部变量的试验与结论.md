# Dll 模块间(dll, exe)使用导出变量、静态变量和外部变量的试验与结论 - gauss的专栏 - CSDN博客
2013年01月04日 00:14:45[gauss](https://me.csdn.net/mathlmx)阅读数：465
转自：http://blog.csdn.net/pizi0475/article/details/7951738
非常感谢博主奉献
[原]模块间(dll, exe)使用导出变量、静态变量和外部变量的试验与结论
Technorati 标签: vc,模块,导出变量,静态变量,外部变量
// Dll头文件声明 
AFX_EXT_DATA int D1_nCount; 
extern int D1_nCountE; 
static int D1_nCountS = 0; 
AFX_EXT_API int D1_GetCount(); 
// 结论：多模块调用时，或重复调用时，模块内的静态变量是唯一的，不会重复分配内存
int nCount = D1_GetCount();
nCount = D2_GetCount();
nCount = D1_GetCount(); 
// 结论：dll中声明的静态变量在每个使用的cpp下均有一份拷贝，多模块更是如此（静态变量在编译时会分别拷贝）
nCount = D1_nCountS;
D1_nCountS = 2; 
// 结论：dll中声明的外部变量不能用于其他模块，链接失败（基地址都不一样，肯定不行）
nCount = D1_nCountE;
D1_nCountE = 2; 
// 结论：dll中导出的数据到处都可以用，在模块内部只有一份拷贝，每个用到的模块各有一份拷贝
nCount = D1_nCount;
D1_nCount = 2; 
---- 2008年6月2日 
以下后续试验得出了新的结论： 
// Dll头文件声明 
#ifdef DLL2_EXPORTS
#define D2_API        __declspec(dllexport)
#else
#define D2_API        __declspec(dllimport)
#endif 
D2_API extern int D2_nCount; 
// 结论：dll中导出变量在其所在模块为导出，在其他模块必须为导入
// 结论：dll中导出的外部变量到处都可以用，在所有模块中都只有一份拷贝
// 结论：dll中导出的变量到处都可以用，在所有模块中都只有一份拷贝，
// 但是在其所在模块只能包含一次（否则为重定义），所以只能声明为外部变量
nCount = D2_nCount;
D2_nCount = 2; 
// 总结论：dll中的变量一般情况下是以函数接口形式导出，
// 但在某些情况下可能需要在模块间直接使用，那么就有两种方法：
// 如果需要该变量在每个模块都有一份拷贝，那么可以使用static声明，
// 不过这种用途一般比较少。。还有就是使用__declspec(dllexport) extern声明，
// 一般都是需要各个模块公用一份拷贝，注意在其他模块使用时需要用
// __declspec(dllexport)导入该变量，否则就又是导出了，而且没有实现
DLL文件(Dynamic Linkable Library 即动态链接库文件)，是一种不能单独运行的文件，它允许程序共享执行特殊任务所必需的代码和其他资源
比较大的应用程序都由很多模块组成，这些模块分别完成相对独立的功能，它们彼此协作来完成整个软件系统的工作。可能存在一些模块的功能较为通用，在构造其它软件系统时仍会被使用。在构造软件系统时，如果将所有模块的源代码都静态编译到整个应用程序 EXE 文件中，会产生一些问题：一个缺点是增加了应用程序的大小，它会占用更多的磁盘空间，程序运行时也会消耗较大的内存空间，造成系统资源的浪费；另一个缺点是，在编写大的 EXE 程序时，在每次修改重建时都必须调整编译所有源代码，增加了编译过程的复杂性，也不利于阶段性的单元测试。
Windows 系统平台上提供了一种完全不同的较有效的编程和运行环境，你可以将独立的程序模块创建为较小的 DLL 文件，并可对它们单独编译和测试。在运行时，只有当 EXE 程序确实要调用这些 DLL 模块的情况下，系统才会将它们装载到内存空间中。这种方式不仅减少了 EXE 文件的大小和对内存空间的需求，而且使这些 DLL 模块可以同时被多个应用程序使用。Windows 自己就将一些主要的系统功能以 DLL 模块的形式实现。
一般来说，DLL 是一种磁盘文件，以.dll、.DRV、.FON、.SYS 和许多以 .EXE 为扩展名的系统文件都可以是 DLL。它由全局数据、服务函数和资源组成，在运行时被系统加载到调用进程的虚拟空间中，成为调用进程的一部分。如果与其它 DLL 之间没有冲突，该文件通常映射到进程虚拟空间的同一地址上。DLL 模块中包含各种导出函数，用于向外界提供服务。DLL 可以有自己的数据段，但没有自己的堆栈，使用与调用它的应用程序相同的堆栈模式；一个 DLL 在内存中只有一个实例；DLL 实现了代码封装性；DLL 的编制与具体的编程语言及编译器无关。
在 Win32 环境中，每个进程都复制了自己的读/写全局变量。如果想要与其它进程共享内存，必须使用内存映射文件或者声明一个共享数据段。DLL 模块需要的堆栈内存都是从运行进程的堆栈中分配出来的。Windows 在加载 DLL 模块时将进程函数调用与 DLL 文件的导出函数相匹配。Windows 操作系统对 DLL 的操作仅仅是把 DLL 映射到需要它的进程的虚拟地址空间里去。DLL 函数中的代码所创建的任何对象（包括变量）都归调用它的线程或进程所有。
调用方式： 
1、静态调用方式：由编译系统完成对 DLL 的加载和应用程序结束时 DLL 卸载的编码（如还有其它程序使用该 DLL，则 Windows 对 DLL 的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。
隐式的调用：需要把产生动态连接库时产生的 .LIB 文件加入到应用程序的工程中，想使用 DLL 中的函数时，只须说明一下。隐式调用不需要调用 LoadLibrary() 和 FreeLibrary()。程序员在建立一个 DLL 文件时，链接程序会自动生成一个与之对应的 LIB 导入文件。该文件包含了每一个 DLL 导出函数的符号名和可选的标识号，但是并不含有实际的代码。LIB 文件作为 DLL 的替代文件被编译到应用程序项目中。
当程序员通过静态链接方式编译生成应用程序时，应用程序中的调用函数与 LIB 文件中导出符号相匹配，这些符号或标识号进入到生成的 EXE 文件中。LIB 文件中也包含了对应的 DL L文件名（但不是完全的路径名），链接程序将其存储在 EXE 文件内部。
当应用程序运行过程中需要加载 DLL 文件时，Windows 根据这些信息发现并加载 DLL，然后通过符号名或标识号实现对 DLL 函数的动态链接。所有被应用程序调用的 DLL 文件都会在应用程序 EXE 文件加载时被加载在到内存中。可执行程序链接到一个包含 DLL 输出函数信息的输入库文件(.LIB文件)。操作系统在加载使用可执行程序时加载 DLL。可执行程序直接通过函数名调用 DLL 的输出函数，调用方法和程序内部其 它的函数是一样的。
2、动态调用方式：是由编程者用 API 函数加载和卸载 DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。
显式的调用： 
是指在应用程序中用 LoadLibrary 或 MFC 提供的 AfxLoadLibrary 显式的将自己所做的动态连接库调进来，动态连接库的文件名即是上面两个函数的参数，再用 GetProcAddress() 获取想要引入的函数。自此，你就可以象使用如同本应用程序自定义的函数一样来调用此引入函数了。在应用程序退出之前，应该用 FreeLibrary 或 MFC 提供的 AfxFreeLibrary 释放动态连接库。直接调用 Win32 的 LoadLibary 函数，并指定 DLL 的路径作为参数。LoadLibary
 返回 HINSTANCE 参数，应用程序在调用 GetProcAddress 函数时使用这一参数。GetProcAddress 函数将符号名或标识号转换为 DLL 内部的地址。程序员可以决定 DLL 文件何时加载或不加载，显式链接在运行时决定加载哪个 DLL 文件。使用 DLL 的程序在使用之前必须加载（LoadLibrary）加载DLL从而得到一个DLL模块的句柄，然后调用 GetProcAddress 函数得到输出函数的指针，在退出之前必须卸载DLL(FreeLibrary)。
正因为DLL 有占用内存小，好编辑等的特点有很多电脑病毒都是DLL格式文件。但不能单独运行。 
动态链接库通常都不能直接运行，也不能接收消息。它们是一些独立的文件，其中包含能被可执行程序或其它DLL调用来完成某项工作的函数。只有在其它模块调用动态链接库中的函数时，它才发挥作用。
