# thrift框架使用C++ - gauss的专栏 - CSDN博客
2015年04月22日 13:25:44[gauss](https://me.csdn.net/mathlmx)阅读数：993
1. 编写thrift接口文件student.thrift 
[?](http://my.oschina.net/zmlblog/blog/177245#)
```
```cpp
struct
```
```cpp
Student{
```
```cpp
```
```cpp
1:
 i32 sno,
```
```cpp
```
```cpp
2:
 string sname,
```
```cpp
```
```cpp
3:
```
```cpp
bool
```
```cpp
ssex,
```
```cpp
```
```cpp
4:
 i16 sage,
```
```cpp
}
```
```cpp
service
 Serv{
```
```cpp
```
```cpp
i32
 put(1: Student s),
```
```cpp
}
```
```
2. 用“thrift -r --gen cpp student.thrift”在gen-cpp文件夹中生成cpp及头文件，其中自动生成了Serv_server.skeleton.cpp文件，它是简单的server端代码，可以修改（一般都重新参照来写server端代码） 
可以用g++ -g -DHAVE_NETINET_IN_H -I. -I/usr/local/include/thrift -L/usr/local/lib Serv.cpp student_types.cpp student_constants.cpp Serv_server.skeleton.cpp
 -o server -lthrift 
生成server可执行程序； 
3. 可以修改Serv_server.skeleton.cpp文件，做成非阻塞server: 
    新建server.cpp文件（参照Serv_server.skeleton.cpp并参照nonblockingServer的写法）： 
[?](http://my.oschina.net/zmlblog/blog/177245#)
```
```cpp
#include
 <concurrency/ThreadManager.h> //zml
```
```cpp
#include
 <concurrency/PosixThreadFactory.h> //zml
```
```cpp
#include
 "Serv.h"
```
```cpp
#include
 <protocol/TBinaryProtocol.h>
```
```cpp
#include
 <server/TSimpleServer.h>
```
```cpp
#include
 <transport/TServerSocket.h>
```
```cpp
#include
 <transport/TBufferTransports.h>
```
```cpp
#include
 <server/TNonblockingServer.h> //zml
```
```cpp
using
```
```cpp
namespace
```
```cpp
::apache::thrift;
```
```cpp
using
```
```cpp
namespace
```
```cpp
::apache::thrift::protocol;
```
```cpp
using
```
```cpp
namespace
```
```cpp
::apache::thrift::transport;
```
```cpp
using
```
```cpp
namespace
```
```cpp
::apache::thrift::server;
```
```cpp
using
```
```cpp
namespace
```
```cpp
::apache::thrift::concurrency;
```
```cpp
//zml
```
```cpp
using
```
```cpp
boost::shared_ptr;
```
```cpp
#define
 THREAD_NUM 2
```
```cpp
const
```
```cpp
int
```
```cpp
g_port = 9090;
```
```cpp
class
```
```cpp
ServHandler
 :
```
```cpp
virtual
```
```cpp
public
```
```cpp
ServIf {
```
```cpp
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
ServHandler()
 {
```
```cpp
```
```cpp
//
 Your initialization goes here
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
int32_t
 put(
```
```cpp
const
```
```cpp
Student&
 s) {
```
```cpp
```
```cpp
//
 Your implementation goes here
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"put
 student.sno=%d\n"
```
```cpp
,
 s.sno);
```
```cpp
```
```cpp
return
```
```cpp
s.sno;
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
int
```
```cpp
thrift_server_run()
```
```cpp
{
```
```cpp
```
```cpp
//创建thrift
 server
```
```cpp
```
```cpp
shared_ptr<ServHandler>
 handler(
```
```cpp
new
```
```cpp
ServHandler());
```
```cpp
```
```cpp
shared_ptr<TProcessor>
 processor(
```
```cpp
new
```
```cpp
ServProcessor(handler));
```
```cpp
```
```cpp
shared_ptr<TProtocolFactory>
 protocolFactory(
```
```cpp
new
```
```cpp
TBinaryProtocolFactory());
```
```cpp
```
```cpp
```
```cpp
shared_ptr<ThreadManager>
 threadManager = ThreadManager::newSimpleThreadManager(THREAD_NUM);
```
```cpp
```
```cpp
shared_ptr<PosixThreadFactory>
 threadFactory = shared_ptr<PosixThreadFactory> (
```
```cpp
new
```
```cpp
PosixThreadFactory());
```
```cpp
//PosixThreadFactory可以自定义（继承于ThreadFactory）
```
```cpp
```
```cpp
threadManager->threadFactory(threadFactory);
```
```cpp
```
```cpp
threadManager->start();
```
```cpp
```
```cpp
TNonblockingServer
 server(processor, protocolFactory, g_port, threadManager);
```
```cpp
```
```cpp
try
```
```cpp
{
```
```cpp
```
```cpp
server.serve();
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
catch
```
```cpp
(TException
 e) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server.serve()
 failed\n"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(-1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
**argv)
 {
```
```cpp
```
```cpp
thrift_server_run();
```
```cpp
```
```cpp
while
```
```cpp
(1)
 {
```
```cpp
```
```cpp
sleep(10);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
    生成server可执行程序： 
    g++ -g -DHAVE_NETINET_IN_H -I. -I/usr/local/include/thrift -L/usr/local/lib Serv.cpp student_types.cpp student_constants.cpp server.cpp -o server -lthriftnb
 -levent -lthrift -lrt 
4. 编写对接nonblockingServer的client端代码： 
[?](http://my.oschina.net/zmlblog/blog/177245#)
```
```cpp
#include
 "Serv.h"  // 替换成你的.h
```
```cpp
#include
 <transport/TSocket.h>
```
```cpp
#include
 <transport/TBufferTransports.h>
```
```cpp
#include
 <protocol/TBinaryProtocol.h>
```
```cpp
using
```
```cpp
namespace
```
```cpp
apache::thrift;
```
```cpp
using
```
```cpp
namespace
```
```cpp
apache::thrift::protocol;
```
```cpp
using
```
```cpp
namespace
```
```cpp
apache::thrift::transport;
```
```cpp
using
```
```cpp
boost::shared_ptr;
```
```cpp
int
```
```cpp
main()
```
```cpp
{
```
```cpp
```
```cpp
boost::shared_ptr<TSocket>
 socket(
```
```cpp
new
```
```cpp
TSocket(
```
```cpp
"localhost"
```
```cpp
,
 9090));
```
```cpp
```
```cpp
```
```cpp
//对接nonblockingServer时必须的，对普通server端时用boost::shared_ptr<TTransport>
 transport(new TBufferedTransport(socket));
```
```cpp
```
```cpp
boost::shared_ptr<TTransport>
 transport(
```
```cpp
new
```
```cpp
TFramedTransport(socket));
```
```cpp
```
```cpp
```
```cpp
boost::shared_ptr<TProtocol>
 protocol(
```
```cpp
new
```
```cpp
TBinaryProtocol(transport));
```
```cpp
```
```cpp
ServClient
 client(protocol);
```
```cpp
```
```cpp
```
```cpp
//设置发送、接收、连接超时
```
```cpp
```
```cpp
socket->setConnTimeout(2000);
```
```cpp
```
```cpp
socket->setRecvTimeout(2000);
```
```cpp
```
```cpp
socket->setSendTimeout(2000);
```
```cpp
```
```cpp
```
```cpp
transport->open();
```
```cpp
```
```cpp
```
```cpp
//insert
 your code here
```
```cpp
```
```cpp
Student
 stu;
```
```cpp
```
```cpp
stu.sno
 = 1;
```
```cpp
```
```cpp
stu.sname
 =
```
```cpp
"zml"
```
```cpp
;
```
```cpp
```
```cpp
stu.ssex
 = 0;
```
```cpp
```
```cpp
stu.sage
 = 25;
```
```cpp
```
```cpp
int
```
```cpp
ret
 = client.put(stu);
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"client
 put ret=%d\n"
```
```cpp
,
 ret);
```
```cpp
```
```cpp
```
```cpp
transport->close();
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
    编译生成client可执行程序： 
    g++ -g -DHAVE_NETINET_IN_H -I/usr/local/include/thrift -L/usr/local/lib/ Serv.cpp student_types.cpp student_constants.cpp client.cpp -o client -lpthread
 -lthrift -lrt
