# 全屏抗锯齿技术-FSAA - gauss的专栏 - CSDN博客
2011年12月04日 09:02:08[gauss](https://me.csdn.net/mathlmx)阅读数：920
**序言**
FullSceneAnti-aliasing(FSAA)是一种能够消除画面中图形边缘的锯齿，使画面看起来更为平滑的一种技术。而此抗锯齿(Anti-aliasing)的技术通常被运用於3D或文字的画面。其主要的方法就是将在图形边缘会造成锯齿的这些像素(pixel)与其周围的像素作一个平均的运算，来达到图形平滑的效果，但其缺点就是会造成画面有些许的模糊。在此篇文章中，将介绍两种被用来实现FSAA的主要技术-OrderedGridSuperSampling(OGSS)和RotatedGridSuperSampling(RGSS)。所谓的OGSS就是将原来的画面放大并且在这放大的画面中进行上色的动作，之後再将画面还原到原来的大小显示在萤幕上，这样的做法所得到画面会将画面中影像边缘的锯齿消除。而RGSS比OGSS多了一个调整取样(Jitter)的步骤来达成消除锯齿的目的。
**何为锯齿(aliasing)?**
首先，让我们先来了解何为锯齿以及产生锯齿的原因。我们用图1来加以说明，在图1(a)中有一个类似山的形状的图形，而我们用一个网格来描绘此图形，在这网格中的每一个小方格我们称它为像素(pixel)，现在对这些像素作上色的动作，并以"0"，"1"来表示，若图形有通过像素的中心部分，我们称这像素被取样(sample)，则我们以"0"表示(或以黑色表示)，反之则以"1"表示(或以白色表示)；藉由这样规则，我们将上完色的图形显示在图1(b)。在图1(b)中我们发现在图形边缘的部分由原先平滑的边缘变成阶梯状边缘，这样的结果就是因为取样而造成的，我们称像这样阶梯状的边缘为锯齿(aliasing或jaggies)。
![](http://www.mypcera.com/yin/10/image/022801.gif)
**锯齿在电脑动画中的影响**
接下来我们以图2来讨论锯齿在电脑动画中的影响。图2(a)为原始平滑的影像，图2(b)为图2(a)经由取样过後的图形，现在请各位想像一下图2(a)中的图形垂直的往下移动，移动过後的图形我们以图2(c)表示，而图2(d)为图2(c)经过取样後的图形。
![](http://www.mypcera.com/yin/10/image/022802.gif)
首先我们先将焦点放在图2(a)及图2(c)中绿色的长方形上，在图2(a)中此绿色的长方形是涵盖四个像素的中心位置，因此这四个像素会被取样(如图2(b)所示)然而当它向下移动到图2(c)的位置时，此时这绿色的长方形并不涵盖任何的像素中心位置，因此没有任何一个像素被取样(如图2(d))。所以当我们比较图2(b)及图2(d)时，发现此绿色的长方形在图2(d)中消失了，因此当图形上下移动时，我们会发现此绿色的长方形会一下出现，一下消失，而产生闪动(flash)的现象，像这样的问题，我们可以藉由抗锯齿的演算法及技术来减少锯齿及闪动的现象。
在抗锯齿的演算法中，使用了一个重要的取样技术，我们称之为超级取样(SuperSampling)，我们将在下一个章节中详细的介绍这个技术。
**超级取样(SuperSampling)**
所谓的超级取样，就是藉着对一个像素作多次的取样来解决锯齿的问题，以这样的取样方式所获得的图形会更接近原来的图形，因此超级取样就是利用更多的取样点来增加图形的密度。举一个例子来说，图3(a)是一般的取样方式，也就是一个像素只取样一次，而图3(b)就是经过超级取样的结果。由图3(b)可以发现我们对每一个像素作多次的取样(此例为对每个像素作四次的取样)，而每一个取样的点我们称它为子取样(sub-sample)。
![](http://www.mypcera.com/yin/10/image/022803.gif)
根据每个像素中子取样的位置可分为：OrderedGridSuper-Sampling(OGSS)以及RotatedGridSuper-Sampling(RGSS)两种超级取样抗锯齿的技术。
**OrderedGridSuper-Sampling(OGSS)**
OrderedGridSuper-Sampling是一种最常被使用来作为抗锯齿的超级取样技术。"OrderedGrid"就如它的名称一样，它将每一个像素中的子取样以整齐的方式排列，这些子取样像榘阵(matrix)的元素一样，依照水平和垂直的方式整齐的排列着(如图4(a)所示)。在图4(a)中，使用了水平和垂直皆向上取样(up-sampling)两倍(2X)的方式，我们可以用一个系数(如:2X,4X,16X,..等)来表示OGSS的形式，例如："2XOGSS"(如图4(a)所示)或是"4XOGSS"(如图4(b)所示)。有时候我们也可以用"tap"这个字来表示子取样的数目，如"4-tap"""16-tap"。所以一个16-tap的OGSS，就表示在水平及垂直这两个方向皆取样四次，如图4(b)所示。
　　我们可以利用上面介绍的OGSS的技术来实现FullSceneAnti-aliasing(FSAA)，在下一个章节中，我们将仔细的描述如何透过OGSS来达到FSAA的效果。
![](http://www.mypcera.com/yin/10/image/022804.gif)
**利用OGSS来实现FSAA的技术**
在这个章节中，我们将描述如何以OGSS的方式来实现FSAA，其流程方块图如图5所示。
![](http://www.mypcera.com/yin/10/image/022805.gif)
**转换(Transform)及打光(Lighting)过程**
游戏引擎将一个真实的3D世界制造成一个虚拟的3D环境再藉由转换的过程转换到一个2D的萤幕上。在这个转换的过程中是使用了Direct3D以及OpenGL这两个3DAPI(ApplicationProgramInterface)。Direct3D和OpenGL是利用许多三角形来构成3D图形，每一个三角形在3D的空间中都有它们自己的顶点座标(Vertexcoordinates)，这些座标藉由3D显示卡及API的连结，来达成转换及打光的过程。
**将3D虚拟座标作向上取样(Up-sampling)或超级取样(Super-sampling)**
当经过转换及打光的过程後，接着我们将对这些转换过後的座标作向上取样(Up-sampling)或超级取样(Super-sampling)的动作，将做完取样後的座标放在off-screen缓冲区(buffer)中。此off-screen缓冲区与Z和Stencil缓冲区类似，它最主要就是用来储存每个经过Super-sampling後的画面，但是它与front或back缓冲区不同，off-screenbuffer中的画面是不会显示在萤幕上的。Up-sampling的方法很简单，就是将整个萤幕的座标乘上一个系数(如：2,4,┅.等)，举个例子来说：如果有一个萤幕的解析度(resolution)是10＇10，而在这萤幕中一个三角形，此三角形的三个顶点分别是：(5,5)，(10,10)，(10,0)。现在我们将up-sampling的系数设成2，所以在经过up-sampling後的画面将变为20＇20(因为在水平及垂直方向都乘以2，也就是10＇2=20)，而画面中的三角形的座标也将变成(10,10)，(20,20)，(20,0)。所以在经过up-sampling的过程後我们得到一个比原来大四倍的画面，而此画面是储存於off-screenbuffer中。
**在off-screenbuffer中上色(render)**
接着我们将经过up-sampling的画面在off-screenbuffer中作上色(render)的动作，此上色的方式与一般绘图上色的方式相同。
**以Anti-aliasingfilter作向下取样(Down-sampling)**
当off-screenbuffer中的画面上色完成後，我们将得到一个高解析度的画面，但是此画面并不能显示在萤幕上，我们还必须经过向下取样(Down-sampling)的动作，将此高解析度的画面变成低解析度(也就是还原成原来画面的大小)。此Down-sampling的动作就是将四个子取样点的色彩值加以混和(假设up-sampling的系数为2)成为一个像素，简单的说就是将此四个邻近的子取样点的色彩值相加後再除以四，得到一个新的色彩值，举例来说：如果四个邻近的色彩值分别为150，200，100以及50，则我们可藉由(150+200+100+50)/4的运算式得到混合後的色彩值为125，所以这最後所得到的色彩值会介於四个邻近子取样色彩值的中间，藉由这样向下取样及平均值滤波器(averagefilter)的作用，使图形中高频的部分(通常是指图形的边缘部分)变的平滑，而达到抗锯齿的效果。
**frontbuffer及backbuffer的互换**
当我们由off-screenbuffer得到一平滑的画面後，将此平滑的画面置於backbuffer中，之後再将backbuffer与frontbuffer中的画面互换并显示在萤幕上。
以上所描述的步骤就是以OGSS来实现FSAA的方法，在下一个章节中，我们将介绍如何以另外一种超级取样的方式　　　　-RotateGridSuper-Sampling(RGSS)来实现FSAA。 　　
**RotateGridSuper-Sampling(RGSS)**
第二种利用超级取样来抗锯齿的技术为RotateGridSuper-Sampling(RGSS)，RGSS与OGSS的取样方式很类似，其两者最大的差别就在於子取样点的位置不同。OGSS的子取样点是在水平及垂直的方向整齐的排列(如图6(a)所示)，而RGSS的子取样点的位置则是旋转了一个角度(如图6(b))。
![](http://ctc.qzs.qq.com/ac/qzone_v5/photo/photo_none_s.gif)
**利用RGSS来实现FSAA的技术**
以RGSS的方式来实现FSAA的技术，基本上与OGSS的方式大同小异，不过两者的差异就在於RGSS比OGSS多了一个"jitter"的步骤(图5)，而此"jitter"的步骤就是在於改变取样点的位置(如图7)。要改变(调整)取样点的位置有两种方式：一种是根据图形的特性来动态的调整取样点的位置，以获的更好抗锯齿功效；另一种则是将取样点固定旋转一个角度来达到抗锯齿的效果。
![](http://ctc.qzs.qq.com/ac/qzone_v5/photo/photo_none_s.gif)
至目前为止，我们已经介绍了两种实现FSAA的方法(OGSS与RGSS)，这两种方式最大的差别就在於取样点的位置不同，而因为取样点的位置不一样，对於抗锯齿的效果也有所不同，在下一个章节里，我们将对这两种抗锯齿的方式做一个比较。
**OGSS与RGSS的比较**
图8(a)及图8(b)中分别显示OGSS与RGSS的取样点位置，有一个近似水平的边缘图形通过图上的六个像素(pixel)，我们藉着这两个图来比较OGSS与RGSS取样点的位置及最後混和後颜色的平滑度(smooth)。在图8(a)中，我们可发现OGSS的方式决定的取样点呈水平及垂直整齐的排列，而每个像素所得到的平均色彩值只有三种组合：0%(白色)，50%以及100%(黑色)，因此所的到的平滑效果并不理想，我们将混和後的颜色绘於每个图形下变的长方形中。在RGSS方面(图8(b)及图8(c))，可发现其混和後的颜色要比OGSS来的平滑许多。
![](http://ctc.qzs.qq.com/ac/qzone_v5/photo/photo_none_s.gif)
图9说明两个子取样的RGSS与四个子取样的OGSS分别对接近水平边缘的图形作抗锯齿的效果。比较图9(b)与图9(c)可发现两个子取样(2sub-sample)的RGSS与四个子取样(4sub-sample)的OGSS效果相当的接近。
![](http://ctc.qzs.qq.com/ac/qzone_v5/photo/photo_none_s.gif)
由上面的图形，也许各位读者会认为RGSS在水平方向或是垂直方向的表现皆优於OGSS，其实这并不全然正确，读者应该还记得RGSS在做Anti-aliasing的效果时，必须去调整取样点的位置，调整位置的方式可分为动态调整或固定旋转某个角度来取样，这样的一个步骤，会消耗一些系统的资源及时间来做变换，而且若是使用固定旋转一个角度的方式来做RGSS的Anti-aliasing，其所呈现出来的效果未必会比OGSS的效果好，反观OGSS的方式是不需花费这样的资源及时间就可达到Anti-aliasing的效果，虽然效果不及RGSS来的好，但经由许的的实验证明，这两种方式所产生Anti-aliasing的效果，对於人眼的感知度来说，事实上并没有多的差别。
**结论**
无疑的，FSAA在现在或不久的将来，对於画面品质的改善是相当重要的技术。如果你很重视画面的更新率(framerate)，则FSAA是不值得你去用的。但是对於3DRTS或3DRPG这样不需太高FPS(FramePerSecond)的游戏来说，则FSAA是最好的选择。
