# 关于链接的几点建议 - 工作笔记 - CSDN博客





2013年09月21日 18:20:44[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5566








    绝大多数编译器不只是一个单一庞大的程序，通常由多达六七个稍小的程序所组成，这些程序由一个编译器驱动程序来控制，这些程序包含预处理器，语法与语义检查器，代码生成器，汇编程序，优化器，链接器。PC的链接器一般只提供基本的I/O服务，即BIOS的程序。

    关于链接，有静态链接和动态链接之分，**静态链接，即函数库在链接时便加入到可执行文件中。动态链接，则只在可执行文件中包含了函数库的文件名，程序在运行时由载入器寻找程序所在的函数库。静态链接的模块被链接编辑并载入运行，动态链接的模块被链接编辑后载入，并在运行时进行链接以便运行。程序执行时，main函数被调用前，运行时载入器把共享的数据对象载入到进程的地址空间，外部函数被真正调用之前，运行时载入器并不解析他们。因此，即使链接了函数库，如果没有实际调用，也不会带来额外开销。**

    实际上，动态链接是可执行文件的体积非常小，虽然运行速度稍慢一些，但可以更加充分的利用磁盘空间，而且链接-编辑的时间也会缩短。**其主要目的就是把程序与它们使用的特定的函数库版本中分离开来，取而代之的是，我们约定系统向程序提供一个接口，该接口保持稳定，不随时间和操作系统的后续版本发生任何变化。程序可以调用接口所承诺的服务，而不必担心这些功能是怎样提供的或者它们的底层实现是否改变，由于它是介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，所以称它为应用二进制接口，即Application Binary Interface， ABI。**

    另外，**所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝，OS内核保证映射到内存中的函数库可以被所有使用它们的进程共享。这就提供了更好的I/O和交换空间利用率，节省了物理内存，从而提高了系统的整体性能。**

    当然，ABI也使得函数库的版本升级更容易。

    最后，动态链接库允许用户在运行时选择需要执行的函数库。

    动态库的路径会被植入可执行文件，因此，函数库的路径不能随意改变。

在使用函数库时，要注意下面几点：

1.动态库文件的扩展名是.so,静态库文件的扩展名是.a

2.通过-lthread选项，告诉编译链接到xxxx.so,这种传递中，并没有提供函数库的完整路径。实际上，根据选项-lnam编译器被告知接连到相应的函数库，即linbname.so,即lib部分和文件扩展名被省略掉了，在前面加个l。

3.编译器希望在确定的目录找到库。

即最好将,so文件放置在/usr/lib/XXX.so

4.观察头文件，确认所使用的函数库。

实际上，#include 文件名，可能就是必须包含一个库，但不幸的是，C语言在这里设计的比较混乱。

**interpositioning，有些人称为interposing,即编写与库函数同名的函数来取代库函数，这是把双刃剑，用的好，会提高性能，但用不好，会引入严重的bug。实际上，不仅你自己所进行的所有对该库函数的调用将被自己的函数取代，而且所有调用该库函数的系统调用也会将用你的函数取代。但编译器对这一行为，不会给出错误信息。**





