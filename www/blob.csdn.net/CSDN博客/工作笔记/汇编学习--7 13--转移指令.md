# 汇编学习--7.13--转移指令 - 工作笔记 - CSDN博客





2012年07月13日 08:45:44[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5403








1. 8086转移行为有：

    只修改IP,段内转移。根据修改范围，分近转移（-32768~32767）和短转移（-128~127）.

    同时修改CS和IP，段间转移



2. 8086转移指令分类：

    无条件转移指令

   条件转移指令 

   循环

   过程

   中断



3. 操作符offset是伪指令，用来获得标号的偏移地址。eg：s：mov ax，offset s         等价于mov ax，0



4. jmp转移原理：

    根据给出的目的地址方法和不同位置分为：

    a. 依据位移转移：

        1 jmp short 标号

           段内短转移 -128~127  CPU在执行jmp指令的时候并不需要转移的目的地址。而是（IP） = （IP） + 8位位移，该位移由编译器计算得出。

        2 jmp near ptr 标号 段内近转移,原理与1类似。

     b, 转移目的地址在指令中：

         jmp far ptr 标号   段间转移，又称远转移。指定了目的地址，(CS) = 标号所在的段地址，（IP） = 标号所在段的偏移地址。

     c. 转移地址在寄存器中：

        jmp 16位reg

        功能：同时修改段地址：便宜地址

      d.转移地址在内存中：

         1.jmp word ptr 内存单元地址（段内转移）

            从内存单元地址处开始存放一个字，是转移的目的便宜地址。即跳转到该字位置

         2. jmp dword ptr 内存单元地址（段间转移）

           从内存单元地址处存放2个字，高地址处的字是转移的目的段地址，低地址处是转移目的地址的偏移地址. 

5.jcxz 条件转移转移指令，所有的条件转移指令都是短转移。

    jcxz 标号 若cx = 0；则跳转到标号。

6. loop 所有的循环指令都是短转移。

所有的短转移都是-128~127,机器码包含8位位移，不包含目的地址。

7. jmp short 标号 jmp near ptr 标号 jcxz标号， loop标号都根据位移来转移。机器码不包含目的地址。这种设计，方便了程序段在内存中的浮动装配。即，不受内存中不同位置的限制。编译器对转移位移超界会做检测，报错。

8. ret 指令用栈中数据，修改IP的内容，从而实现近转移

    retf 指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

9. call指令 不能实现短转移，其他和jmp相同、

     1 call 标号 ：将当前的IP压栈后，转到标号处执行

     2 call far ptr 标号 段间转移 相当于push cs push ip jmp far ptr 标号

     3 call 16位reg 

     4 call word ptr 内存单元地址

     5 call dword ptr 内存单元地址

10 .call和ret配合使用，完成子程序机制。

       子程序框架：

        标号：

                  指令

                  ret

          具有子程序的源程序框架：

assume cs：code

code segment

main： ：

               ：

                call sub1

                ：

                 mov ax，4c00h

                 int 21h

       sub1：

                 ：

                   call sub2

                 :

                 ret

         sub2:

                   :

                  ret

code ends

end main

11. mul 乘法指令 因子必须具有相同位。

12.模块化程序设计中：

      1. 参数传递和返回值

         a.利用寄存器保存参数，返回值。对于该寄存器的操作，读写操作相反。批量参数，放在内存。

         b.压栈，出栈方式

      2. 寄存器冲突问题

           采用栈的方式，保存寄存器内容，不受冲突影响。

           因此，以后编子程序的框架：

      子程序开始：子程序使用的寄存器入栈

                              子程序内容

                              子程序使用的寄存器出栈

                               ret









