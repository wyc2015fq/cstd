# 系统学习NLP（十三）--词向量（word2vec原理） - 工作笔记 - CSDN博客





2019年03月10日 12:14:43[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：110








## 词向量简介

自然语言是一套用来表达含义的复杂系统。在这套系统中，词是表义的基本单元。在机器学习中，如何使用向量表示词？

顾名思义，词向量是用来表示词的向量，通常也被认为是词的特征向量。近年来，词向量已逐渐成为自然语言处理的基础知识。

一种最简单的词向量方式是**one-hot representation**，就是用一个很长的向量来表示一个词，向量的长度为词典的大小，向量的分量只有一个 1，其他全为 0，1 的位置对应该词在词典中的位置。比如：

'中国'表示为 [00010000000......]

'美国'表死为[0000000010000...]

每个词都是茫茫 0 海中的一个 1。这种 One-hot Representation 如果采用稀疏方式存储，会是非常的简洁：也就是给每个词分配一个数字 ID。比如刚才的例子中，中国记为 3，美国记为 8（假设从 0 开始记）。如果要编程实现的话，用 Hash 表给每个词分配一个编号就可以了。这么简洁的表示方法配合上最大熵、SVM、CRF 等等算法已经很好地完成了 NLP 领域的各种主流任务。

但这种词表示有两个缺点：

（1）容易受维数灾难的困扰，尤其是将其用于 Deep Learning 的一些算法时；

（2）不能很好地刻画词与词之间的相似性（术语好像叫做“**词汇鸿沟**”）：任意两个词之间都是孤立的。光从这两个向量中看不出两个词是否有关系，哪怕是丈夫和老公这样的同义词也不能幸免于难。

（个人认为，主要原因在于one-hot编码是把不适合欧式距离度量的类别数据，转换到欧式空间，适合距离度量，而文本分析中，更常用的是余弦距离，此时one-hot编码体现不出角度概念，因为余弦距离将距离归一化了）

另一种就是Distributed Representation 这种表示，它最早是 Hinton 于 1986 年提出的，可以克服 one-hot representation 的缺点。它的思路是通过训练，将每个词都映射到一个较短的词向量上来。所有的这些词向量就构成了向量空间，进而可以用普通的统计学的方法来研究词与词之间的关系。这就是word embedding，即指的是将词转化成一种分布式表示，又称词向量。分布式表示将词表示成一个定长的连续的稠密向量，这个较短的词向量维度是多大呢？这个一般需要我们在训练时自己来指定。这种向量一般长成这个样子：[0.792, −0.177, −0.107, 0.109, −0.542, ...]，也就是普通的向量表示形式。维度以 50 维和 100 维比较常见。当然在实际情况中，我们并不能对词向量的每个维度做一个很好的解释。

分布式表示优点: 

(1)词之间存在相似关系： 

是词之间存在“距离”概念，这对很多自然语言处理的任务非常有帮助。 

(2)包含更多信息： 

词向量能够包含更多信息，并且每一维都有特定的含义。在采用one-hot特征时，可以对特征向量进行删减，词向量则不能

当然一个词怎么表示成这么样的一个向量是要经过一番训练的，训练方法较多，word2vec是其中一种，在后面会提到，这里先说它的意义。还要注意的是每个词在不同的语料库和不同的训练方法下，得到的词向量可能是不一样的。

由于是用向量表示，而且用较好的训练算法得到的词向量的向量一般是有空间上的意义的，也就是说，将所有这些向量放在一起形成一个词向量空间，而每一向量则为该空间中的一个点，在这个空间上的词向量之间的距离度量也可以表示对应的两个词之间的“距离”。所谓两个词之间的“距离”，就是这两个词之间的语法，语义之间的相似性。

一个比较实用的场景是找同义词，得到词向量后，假如对于词老婆来说，想找出与这个词相似的词，这个场景对人来说都不轻松，毕竟比较主观，但是对于建立好词向量后的情况，对计算机来说，只要拿这个词的词向量跟其他词的词向量一一计算欧式距离或者cos距离，得到距离小于某个值那些词，就是它的同义词。

这个特性使词向量很有意义，自然会吸引很多人去研究，google的word2vec模型也是基于这个做出来的。

## 如何生成词向量

本小节来简单介绍词向量的生成技术。生成词向量的方法有很多，这些方法都依照一个思想：任一词的含义可以用它的周边词来表示。生成词向量的方式可分为：基于统计的方法和基于语言模型(language model)的方法。

### **1. 基于统计方法**



1.1 共现矩阵

通过统计一个事先指定大小的窗口内的word共现次数，以word周边的共现词的次数做为当前word的vector。具体来说，我们通过从大量的语料文本中构建一个共现矩阵来定义word representation。 

例如，有语料如下： 

I like deep learning. 

I like NLP. 

I enjoy flying. 

则其共现矩阵如下：
![](https://img-blog.csdnimg.cn/20190310123338401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

矩阵定义的词向量在一定程度上缓解了one-hot向量相似度为0的问题，但没有解决数据稀疏性和维度灾难的问题。

1.2 SVD（奇异值分解）

既然基于co-occurrence矩阵得到的离散词向量存在着高维和稀疏性的问题，一个自然而然的解决思路是对原始词向量进行降维，从而得到一个稠密的连续词向量。 

对1.1中矩阵，进行SVD分解，得到矩阵正交矩阵U，对U进行归一化得到矩阵如下：
![](https://img-blog.csdnimg.cn/2019031012372944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

SVD得到了word的稠密（dense）矩阵，该矩阵具有很多良好的性质：语义相近的词在向量空间相近，甚至可以一定程度反映word间的线性关系。

![](https://img-blog.csdnimg.cn/20190310123813117.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

### 2.基于语言模型(language model)



语言模型生成词向量是通过训练神经网络语言模型NNLM（neural network language model），词向量做为语言模型的附带产出。NNLM背后的基本思想是对出现在上下文环境里的词进行预测，这种对上下文环境的预测本质上也是一种对共现统计特征的学习。 较著名的采用neural network language model生成词向量的方法有：Skip-gram、CBOW、LBL、NNLM、C&W、GloVe等。接下来，以word2vec为例，讲解基于神经网络语言模型的词向量生成。

**word2vec**

2013年，Google团队发表了word2vec工具。word2vec工具主要包含两个模型：跳字模型（skip-gram）和连续词袋模型（continuous bag of words，简称CBOW），以及两种高效训练的方法：负采样（negative sampling）和层序softmax（hierarchical softmax）。值得一提的是，word2vec词向量可以较好地表达不同词之间的相似和类比关系。

这里skip-gram和CBOW是**word2vec架构的两种类型，可以理解为两种实现方式，不是说，word2vec包含这两个模型。**

word2vec自提出后被广泛应用在自然语言处理任务中。它的模型和训练方法也启发了很多后续的词向量模型。本节将重点介绍word2vec的模型和训练方法。

在word2vec出现之前，已经有用神经网络DNN来用训练词向量进而处理词与词之间的关系了。采用的方法一般是一个三层的神经网络结构（当然也可以多层），分为输入层，隐藏层和输出层(softmax层)。这个模型是如何定义数据的输入和输出呢？一般分为CBOW(Continuous Bag-of-Words 与Skip-Gram两种模型。

CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量（单词的one-hot编码），而输出就是这特定的一个词的词向量(单词的one-hot编码）。比如下面这段话，我们的上下文大小取值为4，特定的这个词是"Learning"，也就是我们需要的输出词向量(单词Learning的one-hot编码）,上下文对应的词有8个，前后各4个，这8个词是我们模型的输入（8个单词的one-hot编码）。由于CBOW使用的是词袋模型，因此这8个词都是平等的，也就是不考虑他们和我们关注的词之间的距离大小，只要在我们上下文之内即可。

![](https://img-blog.csdnimg.cn/20190311095614868.png)

这样我们这个CBOW的例子里，我们的输入是8个词向量（8个单词的one-hot编码），输出是所有词的softmax概率（训练的目标是期望训练样本特定词（中心词）对应的softmax概率最大），对应的CBOW神经网络模型输入层有8个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某8个词对应的最可能的输出中心词时，我们可以通过一次DNN前向传播算法并通过softmax激活函数找到概率最大的词对应的神经元即可。　　　　

Skip-Gram模型和CBOW的思路是反着来的（互为镜像），即输入是特定的一个词的词向量（单词的one-hot编码），而输出是特定词对应的上下文词向量（所有上下文单词的one-hot编码）。还是上面的例子，我们的上下文大小取值为4， 特定的这个词"Learning"是我们的输入，而这8个上下文词是我们的输出。

这样我们这个Skip-Gram的例子里，我们的输入是特定词， 输出是softmax概率排前8的8个词，对应的Skip-Gram神经网络模型输入层有1个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某1个词对应的最可能的8个上下文词时，我们可以通过一次DNN前向传播算法得到概率大小排前8的softmax概率对应的神经元所对应的词即可。

以上就是神经网络语言模型中如何用CBOW与Skip-Gram来训练模型与得到词向量的大概过程。但是这和word2vec中用CBOW与Skip-Gram来训练模型与得到词向量的过程有很多的不同。

word2vec为什么 不用现成的DNN模型，要继续优化出新方法呢？最主要的问题是DNN模型的这个处理过程非常耗时。我们的词汇表一般在百万级别以上，这意味着我们DNN的输出层需要进行softmax计算各个词的输出概率的的计算量很大。有没有简化一点点的方法呢？

所以，只要简单理解为CBOW与Skip-Gram互为镜像，输入/输出都是词的one-hot编码，训练上下文->中心词/中心词->上下文词的关系权重就可以了

**word2vec基础之霍夫曼树 **

word2vec也使用了CBOW与Skip-Gram来训练模型与得到词向量，但是并没有使用传统的DNN模型。最先优化使用的数据结构是用霍夫曼树来代替隐藏层和输出层的神经元，霍夫曼树的叶子节点起到输出层神经元的作用，叶子节点的个数即为词汇表的小大。 而内部节点则起到隐藏层神经元的作用。

具体如何用霍夫曼树来进行CBOW和Skip-Gram的训练我们在下一节讲，这里我们先复习下霍夫曼树。

霍夫曼树的建立其实并不难，过程如下：

输入：权值为(w1,w2,...wn)的n个节点

输出：对应的霍夫曼树

1）将(w1,w2,...wn)看做是有n棵树的森林，每个树仅有一个节点。

2）在森林中选择根节点权值最小的两棵树进行合并，得到一个新的树，这两颗树分布作为新树的左右子树。新树的根节点权重为左右子树的根节点权重之和。

3） 将之前的根节点权值最小的两棵树从森林删除，并把新树加入森林。

4）重复步骤2）和3）直到森林里只有一棵树为止。

下面我们用一个具体的例子来说明霍夫曼树建立的过程，我们有(a,b,c,d,e,f)共6个节点，节点的权值分布是(20,4,8,6,16,3)。

首先是最小的b和f合并，得到的新树根节点权重是7.此时森林里5棵树，根节点权重分别是20,8,6,16,7。此时根节点权重最小的6,7合并，得到新子树，依次类推，最终得到下面的霍夫曼树。

![](https://img-blog.csdnimg.cn/20190311101752437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

那么霍夫曼树有什么好处呢？一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。如何编码呢？一般对于一个霍夫曼树的节点（根节点除外），可以约定左子树编码为0，右子树编码为1.如上图，则可以得到c的编码是00。注意，是从左到右，从上到下（根节点除外）的顺序开始编码。

在word2vec中，约定编码方式和上面的例子相反，即约定左子树编码为1，右子树编码为0，同时约定左子树的权重不小于右子树的权重。

**Hierarchical Softmax**

由于word2vec有两种改进方法，一种是基于Hierarchical Softmax的，另一种是基于Negative Sampling的。本文关注于基于Hierarchical Softmax的改进方法，在下一篇讨论基于Negative Sampling的改进方法。

**基于Hierarchical Softmax的模型概述**

我们先回顾下传统的神经网络词向量语言模型，里面一般有三层，输入层（词向量），隐藏层和输出层（softmax层）。里面最大的问题在于从隐藏层到输出的softmax层的计算量很大，因为要计算所有词的softmax概率，再去找概率最大的值。这个模型如下图所示。其中VV是词汇表的大小， 

![](https://img-blog.csdnimg.cn/20190311103231751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

word2vec对这个模型做了改进，首先，对于从输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用简单的对所有输入词向量求和并取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)。这里是从多个词向量变成了一个词向量。

第二个改进就是从隐藏层到输出的softmax层这里的计算量个改进。为了避免要计算所有词的softmax概率，word2vec采样了霍夫曼树来代替从隐藏层到输出softmax层的映射。我们在上一节已经介绍了霍夫曼树的原理。如何映射呢？这里就是理解word2vec的关键所在了。

由于我们把之前所有都要计算的从输出softmax层的概率计算变成了一颗二叉霍夫曼树，那么我们的softmax概率计算只需要沿着树形结构进行就可以了。如下图所示，我们可以沿着霍夫曼树从根节点一直走到我们的叶子节点的词w2w2。

![](https://img-blog.csdnimg.cn/20190311103312864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

和之前的神经网络语言模型相比，我们的霍夫曼树的所有内部节点就类似之前神经网络隐藏层的神经元,其中，根节点的词向量对应我们的映射后的词向量，而所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小。在霍夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着霍夫曼树一步步完成的，因此这种softmax取名为"Hierarchical Softmax"。

如何“沿着霍夫曼树一步步完成”呢？在word2vec中，我们采用了二元逻辑回归的方法，即规定沿着左子树走，那么就是负类(霍夫曼树编码1)，沿着右子树走，那么就是正类(霍夫曼树编码0)。判别正类和负类的方法是使用sigmoid函数，输入是当前内部节点的词向量，训练逻辑回归参数。

使用霍夫曼树有什么好处呢？首先，由于是二叉树，之前计算量为V,现在变成了log2V。第二，由于使用霍夫曼树是高频的词靠近树根，这样高频词需要更少的时间会被找到，这符合我们的贪心优化思想。

依据内部节点的逻辑回归值（即概率）来分配为左右子树。

回到基于Hierarchical Softmax的word2vec本身，我们的目标就是找到合适的所有节点的词向量和所有内部节点θ, 使训练样本达到最大似然。那么如何达到最大似然呢？

**基于Hierarchical Softmax的模型梯度计算**

我们使用最大似然法来寻找所有节点的词向量和所有内部节点θθ。先拿上面的w2w2例子来看，我们期望最大化下面的似然函数：

![](https://img-blog.csdnimg.cn/20190311111357896.jpg)

对于所有的训练样本，我们期望最大化所有样本的似然函数乘积。

为了便于我们后面一般化的描述，我们定义输入的词为w,其从输入层词向量求和平均后的霍夫曼树根节点词向量为xw, 从根节点到w所在的叶子节点，包含的节点总数为lw w在霍夫曼树中从根节点开始，经过的第i个节点表示为pwi,对应的霍夫曼编码为dwi∈{0,1},其中i=2,3,...lw。而该节点对应的模型参数表示为θwi, 其中i=1,2,...lw−1，没有i=lwi是因为模型参数仅仅针对于霍夫曼树的内部节点。

定义ww经过的霍夫曼树某一个节点j的逻辑回归概率为P(dwj|xw,θwj−1)，其表达式为：

![](https://img-blog.csdnimg.cn/20190311111648376.jpg)

那么对于某一个目标输出词ww,其最大似然为：

![](https://img-blog.csdnimg.cn/20190311111758134.jpg)

在word2vec中，由于使用的是随机梯度上升法，所以并没有把所有样本的似然乘起来得到真正的训练集最大似然，仅仅每次只用一个样本更新梯度，这样做的目的是减少梯度计算量。这样我们可以得到w的对数似然函数L如下： 

![](https://img-blog.csdnimg.cn/20190311111857134.jpg)

要得到模型中w词向量和内部节点的模型参数θ, 我们使用梯度上升法即可。首先我们求模型参数θwj−1的梯度： 

![](https://img-blog.csdnimg.cn/20190311112000371.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

同样的方法，可以求出xwxw的梯度表达式如下：

![](https://img-blog.csdnimg.cn/20190311112034292.jpg)

有了梯度表达式，我们就可以用梯度上升法进行迭代来一步步的求解我们需要的所有的θwj−1和xw。 

所以，word2vec 使用**Hierarchical Softmax**对CBOW和Skip-Gram损失结构进行了改进，同时，又利用负采样方式，改进了模型训练。

在讲基于Negative Sampling的word2vec模型前，我们先看看Hierarchical Softmax的的缺点。的确，使用霍夫曼树来代替传统的神经网络，可以提高模型训练的效率。但是如果我们的训练样本里的中心词ww是一个很生僻的词，那么就得在霍夫曼树中辛苦的向下走很久了。能不能不用搞这么复杂的一颗霍夫曼树，将模型变的更加简单呢？

Negative Sampling就是这么一种求解word2vec模型的方法，它摒弃了霍夫曼树，采用了Negative Sampling（负采样）的方法来求解，下面我们就来看看Negative Sampling的求解思路。

既然名字叫Negative Sampling（负采样），那么肯定使用了采样的方法。采样的方法有很多种，比如之前讲到的大名鼎鼎的MCMC。我们这里的Negative Sampling采样方法并没有MCMC那么复杂。

比如我们有一个训练样本，中心词是w,它周围上下文共有2c个词，记为context(w)。由于这个中心词w,的确和context(w)相关存在，因此它是一个真实的正例。通过Negative Sampling采样，我们得到neg个和w不同的中心词wi,i=1,2,..neg，这样context(w)和wi就组成了neg个并不真实存在的负例。利用这一个正例和neg个负例，我们进行二元逻辑回归，得到负采样对应每个词wi对应的模型参数θi，和每个词的词向量。从上面的描述可以看出，Negative Sampling由于没有采用霍夫曼树，每次只是通过采样neg个不同的中心词做负例，就可以训练模型，因此整个过程要比Hierarchical Softmax简单。

现在我们来看看如何进行负采样，得到neg个负例。word2vec采样的方法并不复杂，如果词汇表的大小为V,那么我们就将一段长度为1的线段分成V份，每份对应词汇表中的一个词。当然每个词对应的线段长度是不一样的，高频词对应的线段长，低频词对应的线段短。每个词w的线段长度由词的个数占比确定：

![](https://img-blog.csdnimg.cn/2019031111290691.jpg)

在采样前，我们将这段长度为1的线段划分成M等份，这里M>>V，这样可以保证每个词对应的线段都会划分成对应的小块。而M份中的每一份都会落在某一个词对应的线段上。在采样的时候，我们只需要从M个位置中采样出neg个位置就行，此时采样到的每一个位置对应到的线段所属的词就是我们的负例词。

![](https://img-blog.csdnimg.cn/20190311113015376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9lYXNvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

在word2vec中，MM取值默认为10^8

**负采样补充**

我们以跳字模型为例讨论负采样。

词典V大小之所以会在目标函数中出现，是因为中心词w c生成背景词w o的概率P ( w o ∣ w c )使用了softmax，而softmax正是考虑了背景词可能是词典中的任一词，并体现在softmax的分母上。

我们不妨换个角度，假设中心词wc生成背景词w o由以下相互独立事件联合组成来近似中心词 w c 和背景词 w o 同时出现在该训练数据窗口中心词 w c 和第1个噪声词 w 1 不同时出现在该训练数据窗口（噪声词 w 1 按噪声词分布 P ( w ) 随机生成，假设一定和 w c 不同时出现在该训练数据窗口）…中心词 w c 和第k个噪声词 w K 不同时出现在该训练数据窗口（噪声词 w K 按噪声词分布 P ( w ) 随机生成，假设一定和 w c 不同时出现在该训练数据窗口）

我们可以使用σ ( x ) = 1 / ( 1 + exp ( − x ) )函数来表达中心词w c和背景词w o同时出现在该训练数据窗口的概率：

![](https://00.imgmini.eastday.com/mobile/20180126/20180126031303_1ad5ff1640ee0a6f6227641568f1b4d6_10.jpeg)

当我们把K取较小值时，每次随机梯度下降的梯度计算开销将由O ( | V | )降为O ( K )。

![](https://00.imgmini.eastday.com/mobile/20180126/20180126031303_1ad5ff1640ee0a6f6227641568f1b4d6_11.jpeg)

同样地，当我们把K取较小值时，每次随机梯度下降的梯度计算开销将由O ( | V | )降为O ( K )。

**层序softmax补充**

层序softmax利用了二叉树。树的每个叶子节点代表着词典V中的每个词。每个词w i相应的词向量为v i。我们以下图为例，来描述层序softmax的工作机制。

![](https://00.imgmini.eastday.com/mobile/20180126/20180126031303_1ad5ff1640ee0a6f6227641568f1b4d6_12.png)

假设l( w )为从二叉树的根到代表词w的叶子节点的路径上的节点数，并设n( w , i )为该路径上第i个节点，该节点的向量为u n ( w , i )。以上图为例，l( w 3 ) = 4。那么，跳字模型和连续词袋模型所需要计算的任意词w i生成词w的概率为：

![](https://00.imgmini.eastday.com/mobile/20180126/20180126031303_1ad5ff1640ee0a6f6227641568f1b4d6_13.jpeg)

我们可以使用随机梯度下降在跳字模型和连续词袋模型中不断迭代计算字典中所有词向量v和非叶子节点的向量u。每次迭代的计算开销由O ( | V | )降为二叉树的高度O ( log | V | )。



