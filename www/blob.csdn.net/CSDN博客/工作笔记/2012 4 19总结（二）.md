# 2012.4.19总结（二） - 工作笔记 - CSDN博客





2012年04月19日 12:33:13[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5561标签：[constructor																[class																[initialization																[string																[编译器																[date](https://so.csdn.net/so/search/s.do?q=date&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





**复制对象时勿忘其每一个成分**



假设设计一个顾客类，构造函数由自己写出：

void logCall(const std::string& funcName);

class Customer

{

public:

 Customer(const Customer &rhs);

 Customer &operator =(const Customer &rhs);

 ~Customer(void);

private:

 std::string name;

};

Customer::Customer(const Customer &rhs):name(rhs.name)

{

 logCall("Customer copy constructor");

}

Customer::~Customer(void)

{

}

Customer & Customer::operator =(const Customer &rhs)

{

 logCall("Customer copy assignment operator");

 name = rhs.name;

 return *this;

}

void logCall(const std::string& funcName)

{

 cout << "Customer copy assignment operator!";

}

到这里都没有问题，现在加入另外一个成员变量。

class Date { ... };

class Customer {

public:

private:

std::string name;

Date lastTransaction;

}

此时，拷贝构造函数是局部拷贝，因此，它没有拷贝复制新添加的成员变量，但是多数编译器不对这个问题做出错误提示，因此，**如果你为类添加了一个成员变量，请同时修改你的拷贝构造函数，所有构造函数，以及非标准形式的赋值操作符函数。**

  假如发生继承;

class PriorityCustomer: public Customer {

public:

PriorityCustomer(const PriorityCustomer& rhs);

PriorityCustomer& operator=(const PriorityCustomer& rhs);

private:

int priority;

}

PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)

: priority(rhs.priority)

logCall("PriorityCustomer copy constructor");

PriorityCustomer& PriorityCustomer::operator=(const PriorityCustomer& rhs)

logCall("PriorityCustomer copy assignment operator");

priority = rhs.priority;

return *this;

}

Priorit yCustomer 的copying 函数看起来好像复制了PriorityCustomer 内的每一样东西，但是请再看一眼。是的，它们复制了Priorit yCustomer 声明的成员变量，但每个Priorit yCustomer还内含它所继承的Customer 成员变量复件(副本) ，而那些成员变量却未被复制。Priorit yCustomer 的copy 构造函数并没有指定实参传给其base class 构造函数(也就是说它在它的成员初值列( member initialization
 list) 中没有提到Customer) ，因此PriorityCustomer对象的Customer成分会被不带实参之Customer 构造函数(即default构造函数必定有一个否则无法通过编译)初始化。default构造函数将针对name 和lastTransaction执行缺省的初始化动作。

**任何时候只要你承担起"为derived class 撰写copying 函数"的重责大任，必须很小心地也复制其base class 成分。那些成分往往是private ，所以你无法直接访问它们，你应该让derived class 的copying 函数调用相应的base class 函数:**PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)

: Customer (rhs) , II调用base class 的copy 构造函数

priority(rhs.priority)

logCall("PriorityCustomer copy constructor");

PriorityCustomer&

PriorityCustomer::operator=(const PriorityCustomer& rhs)

logCall("PriorityCustomer copy assignment operator");

Customer::operator=(rhs); II对baseclass成分进行赋值动作

priority = rhs.priority;

return *this;

}

当然，这两个拷贝构造函数，有近似相同的实现体，然而，如果你想用其中之一的函数，调用另外一个函数，则无法达到你想要的效果：

令copyassignment 操作符调用copy 构造函数是不合理的，因为这就像试图构造一个已经存在的对象。这件事如此荒谬，乃至于根本没有相关语法。是有一些看似如你所愿的语法，但其实不是:也的确有些语法背后真正做了它，但它们在某些情况下会造成你的对象败坏，所以我不打算将那些语法呈现给你看。单纯地接受这个

叙述吧:**你不该令copyassignment 操作符调用copy 构造函数。**反方向：令copy 构造函数调用copyass 匈nment 操作符一一同样无意义。构造函数用来初始化新对象，而assignment 操作符只施行于己初始化对象身上。对一个

尚未构造好的对象赋值，就像在一个尚未初始化的对象身上做"只对己初始化对象才有意义"的事一样。无聊嘛!别尝试。

如果你发现你的copy 构造函数和copyassignment 操作符有相近的代码，**消除重复代码的做法**是，**建立一个新的成员函数给两者调用。这样的函数往往是private 而且常被命名为init，这个策略可以安全消除copy 构造函数和copy assignment 操作符之间的代码重复。**](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=string&t=blog)](https://so.csdn.net/so/search/s.do?q=initialization&t=blog)](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=constructor&t=blog)




