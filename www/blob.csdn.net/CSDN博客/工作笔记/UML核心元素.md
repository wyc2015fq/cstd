# UML核心元素 - 工作笔记 - CSDN博客





2014年03月10日 10:04:37[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5569








**1.版型**

也称为类型，构造型。是对一个元素基础定义的扩展，在同一个元素基础定义的基础上赋予特别的含义，以适应特定场合。可自己根据项目需求定义。它只是UML的一种扩展手段。

**2.参与者**

准确定义参与者，是寻找抽象角度的开始，是系统之外与系统交互的人或事物。

因此，寻找参与者可通过下面两点来找出参与者从而确定系统边界：

a.谁对系统有着明确的目标和需求并且主动发出动作。

b.系统为谁服务

如何发现参与者：

1>.涉众分析

2>.客户的岗位设置

3>.与客户代表访谈

参与者的其他版型：

业务主角，特别用于定义业务的参与者，在需求阶段使用。它的特殊性在于，它针对的是业务人员而非计算机用户。在查找业务主角是必须抛开计算机，没有计算机这些业务人员也客观存在，因为在初始需求阶段，我们需要获得的是客户的业务模型，根据业务模型才能建立计算机系统模型。如果在了解业务的阶段就引入计算机系统，会混淆现有业务和将来有计算机参与时的业务。切记：要建立一个客户需要的计算机系统，首要条件是彻底搞清楚客户的业务，而不是预先假设一个计算机系统，让客户假象该系统能帮客户做什么。

业务主角非常重要，建立业务模型，查找业务用例，都必须使用业务主角。需求分析人员不能一开始就加入自己的主观判断，假设了业务在计算机里的实现方式，而没有真正去理解客户的实际业务。

因此，在初始需求阶段，请必须使用业务主角。牢记业务主角是客户实际业务里的参与者，没有计算机系统，没有抽象的计算机角色。业务主角必须能在实际业务里找到对应的岗位或者人。如果你对业务主角不是那么自信，请回答以下几个问题：

1.业务主角的名称是否是客户的业务术语

2.业务主角的职责是否在客户的岗位手册里有对应的定义

3.业务主角的业务用例是否都是客户的业务术语

4.客户是否对业务主角能顺利理解

业务工人

在系统内，参与业务过程，其工作是完成主角的业务目标，因此不需要为他们建立业务模型，他们只在主角的业务模型中出现，他们经常出现的地方是领域模型和用例场景。

涉众

与系统有利益关系的，都是涉众，又叫干系人。


用户

系统的使用者，是参与者的代表，或者说是参与者的实例或代理

角色

参与者职责的抽象，从众多参与者的职责当中抽象出相同的那部分，并命名为角色。代表了系统中的一类职责，一般在概念阶段的模型里，以表达业务的逻辑理解。

3.用例

捕获现实世界的需求的方法，一个系统由世界上的各种各样的愿望组成，如果要描述系统 的功能，就应该找到对这个系统有愿望的人，让他们来说明他们会在这个系统里做什么事情，想要什么结果。如果所有对系统有愿望的人要做的事情都找全了。那这个系统的功能性就确定下来了。

官方定义：用例定义了一组用例实例，其中每个实例都是系统所执行的一系列操作，这些操作可生成特定主角可观测的值。

也就是说，用例其实是与参与者交互的，给参与者提供可观测的有意义的结果的一系列活动的集合。用例其实就是一件事情，要完成这件事情，要做一些列活动，而做一件事情又有不同的方法和步骤，也可能遇到各种意外的事情，这在UML中称之为场景，一个场景就是一个用例的实例。

用例由参与者，前置条件，场景，后置条件构成。

用例特征：

相对独立，也就是说，他独立完成参与者的目的。

执行结果对参与者来说是可观测的和有意义的。

必须由参与者发起，不存在没有参与者的用例，用例不应该自动启动，也不应该主动启动另外一个用例。

以动宾短语出现

一个用例就是一个需求单元，分析单元，设计单元，开发单元，测试单元，部署单元

用例以行业术语定义，不应该以计算机术语定义。

用例粒度：

在项目的不同阶段，使用不同的粒度。

在业务建模阶段，用例能够说明一个完整的事情为宜。即一个用例可以描述一个完整的业务流程。也就是不需要详细到业务中的步骤。

在业务分析阶段，即概念模型阶段，以每个用例能描述一个完整的事件流为宜。可理解为一个用例描述一项完整业务中的一个步骤。

在系统建模阶段，描述操作者与计算机的一次完整交互为宜。在RUP中，项目计划要依据系统模型编写，一个用例的开发工作量在一周左右。

用例的粒度大小不是从用例包含的多少步骤来判定的。

一般来说，一个系统的业务用例定义在10~50个之间。对粒度的选择本质上还是因为边界认定不停而造成的。因此首先要确定边界。

用例的获取

发现主角，然后对业务代表进行访谈，只针对他自己的本质工作来谈谈他的期望，千万不要涉及到业务细节，业务规则，业务流程，更不要让代表理解将来的计算机系统如何工作。

千万不要把用例理解为功能的划分和描述。请注意，用例是捕获功能性需求的，但这个需求是从参与者角度出发的，用例并不是功能。

从功能的角度出发，由于缺少上下文，采用功能分解的方式来获取需求，功能可能变成对使用者无用的，或者使用者不知道怎么用的东西。因此，从使用者的角度来描述软件，是非常合适的，使用者的观点实际上是用例的观点。

也就是说，功能是脱离使用者愿望的，功能也是孤立的，有输入，固定输出，用例则是系统性的，该系统非常明确额去达成一个目标。

用例粒度的误区

产生这个误区的原因首先是分不清目标和步骤，用步骤划分用例会导致不准确的需求获取，分不清目标和步骤的另一个后果是用例的粒度过于细小，使得系统没有抽象的余地。

另外一个误区是在同一个需求阶段的用例粒度大小不一。这个问题产生的本质是因为建模者心中没有一个清楚的边界，没有时时检查现阶段处于那个抽象层次而造成的。




业务用例

业务用例是专门用于需求阶段的业务建模的用例的版型，它面对的问题领域就是没有将来计算机系统参与的，目前客观存在的业务领域。相对的，它的参与者就是业务主角。站在业务主角的角度去看的边界是业务边界，而不是系统边界。业务范围也不等于系统范围。

业务用例实现

也称业务用例实例，专门用于需求阶段的业务建模，也是用例版型的一种，一个业务用例，可以有不同的实现方式，也就有了不同的业务用例实例。它表达了同一种业务的不同实现方式。

概念用例

用于概念建模，用来获取业务模型中的关键概念，分析出业务模型中的核心业务结构以得到一个易于理解的业务框架。它用来获取业务用例中的核心业务逻辑，这些核心逻辑揭示了业务模式，成为业务架构的重要指导。同时它还是从业务用例到系统用例过度时非常重要的指导。

系统用例

实际就是用例，用来定义系统范围，获取功能性需求的。也就是软件系统开发的全部范围，是我们得到的最终需求。




4.业务实体

是类的一种版型，特别用于在业务建模阶段建立领域模型，它代表业务角色执行业务用例时所处理的和所使用的“事物”。一个业务实体经常代表某个对多个业务用例或用例实例有价值的事物。

如何获取业务实体？

首先，我们要建立业务用例场景，即参与者实现其业务目标的过程描述。从业务场景中每个过程的动词后面的名词，就是业务实体的备选对象。在经过筛选后，分析这些业务实体之间的关系，并决定哪些应该单独建模，哪些应该作为属性。通过得到的这些业务实体，代表了该业务场景中的关键概念，再进一步，如果为这些业务实体之间的关系建模，为他们的交互建模，就得到了该问题领域的领域模型。

5.包

分包的好坏，是由包之间的依赖关系来评判的，事实上，UML中包之间的关系，只有依赖关系，UML认为好的分包，必须是高内聚，低耦合的性质。尽量避免双向，循环依赖关系。

包最主要的用途就是分类元素，常见的包的版型定义：

领域包，子系统，组织结构，层




6.分析类

用于获取系统中的主要职责簇，代表系统的原型类，是系统必须处理的主要抽象概念的第一个关口。其实，分析类就是跨越需求到设计实现的桥梁。分析类，包含边界类，控制类，实体类。它是从业务需求到系统设计转换的主要元素，他们在高层次抽象出系统实现业务需求的原型，业务需求通过分析类逻辑化，被计算机所理解。虽然UP过程中，将分析类定义为一种 过度类型，而非强制过程，但建立花大量时间维护分析类。

三高：

高于设计实现，即在为需求考虑系统实现的时候，可以不理会复杂的设计要求，例如框架，设计模式的要求等。

高于语言实现，即在为需求考虑系统实现的时候，可以不理会使用哪种语言实现。

高于实现方式。即在为需求考虑系统实现的时候，可以不理会用哪种实现方式。

边界类：用于对系统外部环境和其内部运作之间交互进行建模的类。任何两个有交互的关键对象都应该考虑边界类。常用场景：

参与者与用例

即用例提供给参与者的操作，可以用边界类。

用例与用例之间的交互，为了防止耦合的发生，采用边界类来隔离这种直接访问。

用例与系统之外非人对象的交互，例如第三方系统，应当为其建立边界类。

在相关联的业务对象有明显的独立性要求，他们可能在各自的领域内发展和变化，但又不希望互相影响时，也应该为他们建立边界类。

从架构角度讲，边界类主要位于展现层。

一个好的边界类有如下特点：

边界类应该有助于提高系统的可用性。

边界类应该尽可能的保持在较高的层次上，如概念层次

边界类应该合理封装介于系统与主角之间的交互。

如果主角改变他们为系统提供输入的方式，边界类就应该是唯一需要改变的对象。

如果系统改变他们为主角提供的输出的方式，边界类就应该是唯一需要改变的对象。

边界类必须知道其他对象类型的需求,如实体对，控制对象，以便他们能够得以实施，并相对于系统内部元素保持其可用性和有效性。

控制类

从架构角度讲，控制类属于业务逻辑层，它用于对一个或多个用例特有的控制行为进行建模，控制对象通常控制其他对象，因此他们的行为有协调性。来源于对用例场景中行为的定义。

实体类

用于对必须存储的信息和相关行为建模的类，实体对象用于保存和更新一些现象的有关信息，例如事件，人员或者一些现实生活中的对象，实体类通常是永久性的，他们所具有的属性和关系是长期的，甚至维系在系统的整个生命周期。其源于业务实体。

从架构角度讲，实体类属于数据持久层。

以上可以看出，由于分析类的抽象层次高，概括能力强，也就比设计和实现要稳定。也不用投入太多的精力维护。

7.设计类

设计类已经直接映射到实现代码了，依赖于实施语言。用于设计模型中。由于设计类与实现语言有密切关系，因此设计类加上特定的版型，来说明该设计类对应的实现体。

8.关系

关联：一段时间内，多个类的实例链接在一起，通俗的讲，就表示一段时间内，一个对象知道另外一个对象。例如A对象保存了B对象的ID，表示A对象知道B对象。

依赖：临时，同时，修改一个对象，会导致另外一个对象的修改。即，除了知道对象，还会使用其他对象的属性和方法。尽量避免双向依赖关系。

扩展：用于用例模型中说明在基本用例中的某个扩展点插入扩展用例。即分支，它是可选的，而不是必需的。

          表明用例是系统可选的行为。

          特定条件下的执行分流

          根据基本用例与主角的交互插入的一组行为段。

          多个用例中都有可能触发一个可选的分支流。即可复用部分。

包含：用于说明在执行基本用例的用例实现过程中插入的行为段。要注意的是，基本用例和包含用例都不能访问对方的属性。


包含用例表示的是必需的，而非可选。

          对于基本用例不是必需的，只有执行结果才重要。

          分解出多个用例的共有行为

实现：连接用例和用例实现

精化：用例模型中，一个用例分解出许多更小的关键精华用例，更细致的展现了基本用例的核心业务。

泛化：用于两个对象之间的继承关系。

精化与泛化关系的区别：

精化关系分解出的子对象，并不会改变和增加减少基本对象的行为和属性，泛化关系的子对象可以增加，修改基本对象的属性和行为。

精化关系仅仅用于建模阶段，在实现语言中，并没有。泛化则等同于实现语言中的继承。

聚合：整体由部分构成，整体消失，部分还存在。

组合：强聚合﻿﻿

﻿﻿



