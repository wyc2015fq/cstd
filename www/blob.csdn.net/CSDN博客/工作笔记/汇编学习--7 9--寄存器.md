# 汇编学习--7.9--寄存器 - 工作笔记 - CSDN博客





2012年07月09日 16:11:48[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5943








1.  CPU 由运算器 控制器 寄存器等器件构成，这些器件靠内部总线相连，它们之间进行数据传送。 

     对于一个汇编程序员来说： CPU里的主要部件是 寄存器。通过改变寄存器的内容实现对CPU的控制。

　　不同的CPU，寄存器的个数，结构都不相同。



2.  8086CPU的所有寄存器都是 16位，存放两个字节，8086共有14个寄存器。 AX, BX, CX, DX四个寄存器通常存放一般性的数据，称为 通用寄存器。

     每个寄存器都可以分为两个独立的8位寄存器， 比如：AX -> AH,AL ; BX-> BH, BL; CX-> CH, CL; DX-> DH, DL;



3. 为了区分不同的进制： 十六进制的数据后面加H标识，二进制的数据后面加B标识，十进制则不必加标识符。



4. 汇编指令或寄存器名称不区分大小写：mov ax，18；等效于 MOV AX, 18;



5. 进行数据传送或运算时，指令的两个操作对象的位数必须一致。

    mov ax, bx (mov ax, BL //ax寄存器的位数和 BL寄存器的位数不一致，这是错误的指令)



6. 在CPU内部形成一个物理地址，然后通过地址总线传送这个内存单元的物理地址到寄存器。

  8086CPU有20位地址总线，达到 1 MB的寻址能力，但是8086CPU是16位 结构，在内部一次性只能处理，传输，暂时存储的地址为16位。



  如何实现传输20位地址的能力呢?

  8086CPU将内部的两个16位地址合成一个20位物理地址。物理地址=段地址x16+偏移地址。

  CPU里的段寄存器提供两个16位地址，即段地址和偏移地址，然后把这两个地址通过内部总线传送到地址加法器的部件里，地址加法器将这两个16位地址合成一个20位物理地址，接着将这个20位物理地址传输到 输入输出控制电路，输入输出控制电路再将这个20位物理地址传送到地址总线，最后传送到存储器。

   (2个16地址->地址加法器合成20位物理地址->->输入输出控制电路->地址总线->存储器)    8086内存中一个段最大不超过64kb。范围0~FFFF。例如，给定一个段地址2000H，则段范围20000H~2FFFFH.因此，数据在某段中，应该表示为段:偏移中，或者段中的偏移单元中。

7. 8086CPU的4个段寄存器: CS, DS, SS, ES. 提供内存单元的段地址。

8. CS 和 IP是8086CPU里两个最关键的寄存器，指示了CPU当前读取指令的地址。 CS为代码段寄存器，IP为指令指针寄存器。

9. 8086CPU读取 执行指令的工作过程：

    1. 从CS:IP指向内存单元读取指令，读取的指令进入CPU里的输入输出控制器，然后输入输出控制器将指令送入指令缓冲器。

　　2. IP=IP + 所读取指令的长度，从而指向下一条指令。

    3. 执行控制器 执行指令。转到步骤(1)，继续重复这个过程。



10.  CPU如何识别指令和数据?

     CPU将CS:IP指向的内存单元的内容看作指令.

11. 在CPU里，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。

12.  修改通用寄存器(AX,BX,CX,DX)内容的指令：mov 传送指令

13.  修改寄存器(CS,IP)内容的指令：jmp 转移指令

    1.  同时修改两个寄存器(CS,IP)的内容: jmp 段地址：偏移地址 

        用指令里给出的段地址修改CS，偏移地址修改IP。

    2.  若只单独修改IP寄存器的内容： jmp  某一合法寄存器  功能：用寄存器的值修改IP。



14.  如何使代码段的指令被执行呢?

     首先要使用CS:IP 指向所定义的代码段中的第一条指令的首地址，即设置代码段首地址。



15. Debug是 DOS，Windows提供的实模式程序的调试工具。Debug可以查看CPU各种寄存器里的内容，内存的情况，和在机器码级跟踪程序的运行。



*********************  基本指令功能  ****************************

启动Debug程序：

1.在运行栏里输入Debug或者debug

2.在运行栏里输入cmd或command，进入dos窗口，然后再输入Debug。

退出Debug程序: q 或者 quit

16. Debug功能：

    1. 用Debug的 R命令查看 修改CPU寄存器的内容。

       R命令可以查看CPU寄存器(主要的6个寄存器:AX,BX,CX,DX,DX,CS,IP)的内容. CS:IP指向的内存单元里存放着机器码。

       比如：CS:IP指向的内存单元为: 14EB:0100 存放着机器码为E9ABD8, 对应的汇编指令为 JMP D9AE.

       R命令修改CPU寄存器的内容： (R 寄存器名)-> 按 Enter键 -> 显示当前寄存器的内容 -> 输入任意值作为寄存器的内容


    2. 用Debug的 D命令查看 内存(存储器)里的内容。 

       D命令查看指定内存单元的内容: D 段地址:偏移地址。即可查看从指定内存单元开始的 128 个内存单元的内容。

       D命令查看指定范围的内存单元的内容: D 段地址:起始偏移地址 结尾偏移地址   (注意：结尾偏移地址 肯定大于等于 起始偏移地址)

       左边是 每行的起始地址，中间的内存单元的内容，右边是每个内存单元中的数据对应的可显示的ASCII码字符，没有对应可显示的ASCII码字符，Debug就用 " . " 来显示

       提示：不同的计算机内存单元里的内容是不一样的，而且每个用Debug看到的内容也可能都不相同，因为这些内容随时都有可能受到系统环境的影响。



    3. 用Debug的 E命令修改 内存(存储器)里的内容。

       E 段地址:偏移地址 数据1 数据2 数据3.... (修改之后 可以使用D命令进行查看)

       E命令可以用提问的方式来逐个修改某一地震开始的内存单元的内容。

       输入: E 段地址:偏移地址 -> 按Enter键 -> 显示当前地址内存单元的内容以及光标停止" . "后面 -> 输入任意值作为内存单元的内容 -> 按空格键 继续显示下一个内存单元的内容 -> 若不修改当前内存单元的内容 则又按空格键

       E命令向内存里写入字符或字符串或机器码:

       比如：写入字符: e 段地址:偏移地址 'w' 'e' 'n'


             写入机器码: e 段地址:偏移地址  b8 34 00  //机器码翻译成汇编指令为: mov ax 34



    4. 用Debug的 U命令将内存里的机器码(机器指令)翻译成 汇编指令， 即查看内存里的机器码对应的汇编指令



        U命令显示输出： 每条机器指令的地址， 机器指令，机器指令对应的汇编指令

        U命令既可以查看默认的范围，也可以查看指定范围的汇编指令: U 起始地址 结束地址 (比如 u 1000:0 4)



    5. 用Debug的 T命令执行一条机器指令(此机器指令对应的汇编指令)



       首先要确定CS:IP物理地址存储的机器码 以及对应汇编指令，即R命令查看CS和IP寄存器的内容；然后T命令执行CS:IP指向的指令。

       Debug显示输出CPU中寄存器的状态。


       可能涉及到的指令: R命令 修改CS和IP寄存器的内容，E命令输入机器码，D命令查看内存的内容。



    6. 用Debug的 A命令 将一条汇编指令对应的机器指令往内存里写入

       由于使用E命令写入机器指令，这样非常不方便，所以最好能直接以汇编指令的形式写入指令。

       使用a命令 输入汇编指令到指定的内存单元里，然后d命令查看刚才指定的内存单元的内容，再用r命令查看CS和IP寄存器的内容，最后使用T命令执行CS:IP指向的指令。

       比如： a 段地址:偏移地址 -> 按Enter键 -> 即可在指定的内存单元里输入 汇编指令

******************************************************************



17.  寄存器 和 存储器的区别：

     寄存器在CPU的内部，容量小，速度快，所有数据必须从存储器传入寄存器后，CPU才能使用； 

     存储器就是内存, 存储器一般都在CPU外部，容量大，速度慢。

18. 在存储器里，内存单元是字节单元，则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元，高位字节存放在高地址单元。



19. 字单元：即存放一个字型数据的内存单元，由两个地址连续的内存单元组成。



20. CPU要读取一个内存单元的内容时候，必须先给出这个内存单元的物理地址(内存地址)，内存地址由段地址和偏移地址组成。

     8086CPU中有一个DS寄存器，通常用来存放 要访问数据的段地址。

21. CS和DS段寄存器的区别：

    CS提供CPU执行的当前指令的段地址，DS提供数据存放的段地址。

    通俗来讲，CS是告诉CPU，去哪个内存单元执行指令，DS是告诉CPU，去哪个内存单元读取数据。

    mov bx, 1200H

    mov cs, bx //CS寄存器的内容不能通过mov指令来赋值

    mov ds, 1200H //不能直接赋值给寄存器DS，8086CPU不支持将数据直接传送到段寄存器，需要使用一般的寄存器进行中转。

    mov ds,  bx //DS寄存器的内容却可以通过mov指令来赋值

22. 将内存单元的内容传送到寄存器里：

   比如：将1000:0内存单元的内容传送到寄存器ax里  

    mov bx, 1000H

    mov ds, bx

    mov ax, [0]

    mov  寄存器名，内存单元地址 // mov  ax, [0]

//[...] 表示一个内存单元，[0]中的0表示内存单元的偏移地址。

    执行指令时，8086CPU自动读取DS里的数据作为内存单元的段地址



  同理：mov  [0],ax  //将寄存器的内容传送到内存单元里

  mov 寄存器, 数据

  mov 寄存器, 寄存器

  mov 段寄存器, 寄存器

  mov 寄存器, 段寄存器



23.  将一组长为N(N<=64K)地址连续，起始地址为16的倍数的内存单元当做专门存储数据的内存空间，则称为一个数据段。



24.  8086CPU提供相关的指令(入栈PUSH 和出栈POP)来以栈的方式访问内存空间，即将一段内存当作栈空间使用。

     比如: push ax 表示将寄存器的内容传送到栈里


           pop  ax 表示将从栈顶取出内容传送到ax里

     注意: 8086CPU的入栈和出栈都是以 字 为单位进行。



25. 如何确定进栈和出栈的栈顶地址呢?

    CS:IP存放当前执行指令的段地址和偏移地址；SS:SP存放栈顶元素的段地址和偏移地址。

    PUSH指令和POP指令执行时，CPU从SS:SP取得栈顶的地址。




    PUSH  AX的执行, 进栈由以下两步完成:

    进栈时, 栈顶从高地址向低地址方向增长。

    1. SP=SP-2, SS:SP指向当前栈顶前面的内存单元，以当前栈顶前面的单元为新的栈顶。

    2. 将AX中的内容传送到SS:SP指向的内存单元里，SS:SP此时指向新栈顶。



    POP  AX的执行, 出栈由以下两步完成:

    出栈时, 栈顶从低地址向高地址方向增长。    

    1. 将SS:SP指向的内存单元里的数据传送到AX寄存器里，SS:SP此时指向新栈顶。

    2. SP=SP+2, SS:SP指向当前栈顶下面的内存单元，以当前栈顶下面的单元为新的栈顶。



26. 如何确保进栈和出栈时，栈顶不会超出栈空间?

    如果栈顶越界，那么栈空间之外的内存单元内容都会被覆盖，这些内容可能是其他用途的数据,代码等，一旦覆盖将会引发一连串的错误。


27. 将一段内存当作栈段,  一个栈段的内存最大为 64KB, 栈顶的变化范围: 0-FFFF H



28. 一段内存，既可以是代码空间，也可以是数据空间，还可以是栈空间，也可以什么都不是，关键在于CPU里寄存器的设置, 即CS,IP,SS,SP,DS的指向。



 CPU通过总线与其他芯片进行数据传输， 物理上，总线就是一根根导线集合，逻辑上，分三类，地址，数据，控制。

 CPU通过地址总线，发送地址信息，然后通过控制总线，发出内存读写命令，选择存储器芯片，通知它，要读取数据。存储器发送对应地址的数据给CPU。

 地址总线的总数量，被定义为CPU地址总线的宽度。

  数据总线宽度决定了CPU与外界的数据传输速度。8根总线一次传送一个8位二进制，即一个字节，16位 2个。

  控制总线的宽度决定了CPU对外部器件的控制能力。

 对于与CPU关联的各种物理存储器，CPU将其定义为一个逻辑地址空间，即内存地址空间。通过分配不同段的地址，操作不同的芯片。



