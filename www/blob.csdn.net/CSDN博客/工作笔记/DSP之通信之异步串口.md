# DSP之通信之异步串口 - 工作笔记 - CSDN博客





2012年08月16日 10:16:57[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：10868








        异步串口UART外围设备是基于工业标准TL16C550的异步通信模块，对于TL16C550的功能进行升级。除了支持单字符模式，还支持交替FIFO模式。通过对接收和发送的数据缓冲来减小CPU软件的开销。

        UART把从外设接收到的串行数据转换成并行数据，以及把CPU接收到的并行数据转换成串行数据，它本身具有控制能力和一个处理的中断系统，可以减少通信连接的软件管理。

**1 异步串口基本结构 **

异步串口是常用的通信方式之一，它具有连接简单，不需要时钟同步的特点。

        C55x异步串口的操作同TL16C550相同，即DSP通过缓存完成异步串口的字节收发，C55x的接收和发送FIFO最多可以分别存储16个字节，其中接收FIFO还存储了每个字节的3个错误状态位。异步串口内部包含一个波特率产生器，它可以对UART模块的输入时钟进行1到65535倍分频，从而产生16倍波特率的模块工作时钟，接下来给出异步串口模块框图。


**异步串口模块框图 **


![](https://img-my.csdn.net/uploads/201208/16/1345084712_5283.jpg)


**1****．异步串口发送部分**






异步串口发送部分包括一个发送保持寄存器（URTHR）和一个发送移位寄存器（URTSR），当异步串口工作在FIFO模式下时，发送保持寄存器可以缓存16个字节。发送部分由异步串口线路控制寄存器（URLCR）控制，发送格式如下：



**1****个起始位**

**5****、****6****、****7****或者****8****个数据位**

**1****个奇偶校验位（可选）**

**1****、****1.5****或者****2****个停止位**









如果串口发送保持寄存器从内部数据总线接收到数据，当发送移位寄存器准备好时，异步串口模块将数据从送到保持寄存器发送到发送移位寄存器，发送移位寄存器通过TX引脚将串行数据发送出去。

        在非FIFO模式下，当发送保持寄存器没有数据存储时，如果中断使能寄存器使能发送寄存器空中断，则产生该中断，而当一个新的字节被装入发送保持寄存器时这个中断被清除；在FIFO模式下，发送FIFO为空时产生中断，当新的字节被装入FIFO时中断被清除。


**2．异步串口接收部分 **



异步串口接收部分包括一个接收移位寄存器（URRSR）和一个接收缓冲寄存器（URRBR）。当异步串口工作在FIFO模式下时，接收缓冲寄存器可以缓冲16个字节。接收部分的定时器由16倍接收时钟提供，在异步串口控制寄存器的控制下，接收部分可以接收如下格式数据：



**1****个起始位**

**5****、****6****、****7****或者****8****个数据位**

**1****个奇偶校验位（可选）**

**1****个停止位**




当接收移位寄存器从RX引脚收到数据后，将组合好的数据送到接收缓冲寄存器或者接收FIFO，异步串口可以为每个收到的字节存储3个错误状态信息位，包括奇偶校验错误、帧错误和接收间断。

        在非FIFO模式下时，如果一个字符被放到接收数据缓冲寄存器中，并且中断使能时将产生中断，该字符被读走时中断被清除；在FIFO模式下时，如果FIFO存储的数据量达到FIFO控制寄存器（URFCR）设定的触发值时将产生中断，而当FIFO存储的数据量小于触发值时中断被清除。






**3****．波特率产生器**



异步串行通信需要满足各种不同通信速率的要求，模块采用波特率产生器，通过对输入时钟分频来适应串口的通信速率。波特率产生器的分频数可以从1到65535任意选择，异步串口的工作时钟BCLK应为波特率的16倍，即每个输入输出的位都将持续16个工作时钟，而如果串口工作在接收状态下，将在第8个工作时钟对该位采样，下面给出分频数的计算公式：


分频数 = UART输入时钟频率/希望的波特率 *16

**4****．异步串口的中断申请与****DMA****事件的产生**


**异步串口模块可以通过中断和****DMA****事件通知****CPU****接收和发送数据，下表给出了****UART****的中断类型：**



**异步串口中断类型 **


|**中断申请**|**中断源**|**触发条件**|
|----|----|----|
|**THREINT**|**发送空：当所有数据已经从发****送保持寄存器拷贝到发送移位****寄存器，发送保持寄存器****（****URTHR****）或者发送****FIFO****为****空**|**如果****THREINT****被中断使能寄存器使能，而它被中断标****志寄存器记录****一个替代****THREINT****中断的方法是****CPU****可以通过访问线****路状态寄存器中的****THRE****位来确定发送数据是否为空**|
|**RDRINT**|**接收数据准备好：当数据已经****读到接收缓冲寄存器或者接收****FIFO****存储数据量达到触发值。****如果过了****4****个字符周期****FIFO****中****的数据还没有被访问，将再次****发送****RDRINT****中断**|**如果****RDRINT****被中断使能寄存器使能，并且被中断标****志寄存器记录****替代的方法是可以通过访问线路状态寄存器中的****DR****位****，但在****FIFO****模式下时，由于****DR****位不能被****FIFO****的触发****值改变，****DR****位只能标志是否有未被读取的字符**|


|**RTOINT**|**接收超时：当在****4****个符号周期****内没有字符被送到接收****FIFO****中，并且这段时间内****FIFO****中至****少有一个字符**|**当接收****FIFO****中的数据数小于触发值而不能产生数据准****备好中断时，可以通过发送接收超时中断防止****UART****长****时间等待****如果****RTOINT****被中断使能寄存器使能，而它被中断标****志寄存器记录**|
|----|----|----|
|**RLSINT**|**接收线路状态：接收溢出，奇****偶校验位错误，帧错误，或者****接收发生间断**|**如果****RLSINT****被中断使能寄存器使能，而它被中断标志****寄存器记录****替代的方法是访问线路标志寄存器中的相应位，包括****接收溢出****OE****，奇偶校验位错误****PE****，帧错误****FE****，或者****接收发生间断****BI****。当****CPU****读取线路标志寄存器时，****OE****标志将自动被清除**|






当中断被中断使能寄存器使能，并被中断标志寄存器记录时，这些中断将通过一个仲裁器向CPU发送一个UART中断，中断标志寄存器中记录这些中断可以分为两个过程：

1）当中断标志码被写到中断标志字中时，如果有多个中断申请同时发生并被使能，则拥有高优先级的申请将被写到标志字中。被记录的标志码在如下情况下才能被改变：

可以引起中断清除的行为，这时中断标志字被填入000b；

另一个中断发生，中断标志字被填入新的标志码； 

发生一次硬件复位，中断标志字被填入000b。



2）如果之前未被响应的中断一直没有被响应，则中断未响应IP位为0，直到未响应中断被清除或者发生硬件复位。





如果中断申请发生而该中断未被使能，则中断申请被禁止，该中断申请不会记录到中断标志寄存器中，也不会被提交给CPU。异步串口中断也是一个可屏蔽中断，如果该中断被CPU使能，CPU将执行相应的中断服务程序，中断服务程序读取中断标志寄存器中的标志字，之后执行到相应的中断服务程序。


如果有多个中断没有被响应，中断服务程序可以通过线路标志寄存器（URLSR）的值来判断哪些中断没有响应，但通过线路标志寄存器无法检测超时事件，或者接收FIFO是否达到设定的触发值，这是因为这些情况在线路标志寄存器中没有对应的状态位。

 在FIFO模式下，异步串口可以产生下面两种DMA事件，DMA通道可以利用这些事件来进行同步，在非FIFO模式下，则没有DMA事件产生。


接收事件（REVT）：如果通过FIFO控制寄存器中的RFITR字段设定接收FIFO的触发值时（1、4、8或者14个字符），每次达到触发值或者接收超时时将向DMA控制器发出一个接收事件，而DMA控制器可以通过接收缓冲寄存器URRBR读取数据。

发送事件（XEVT）：当发送FIFO为空时，异步串口发出一个XEVT信号到DMA控制器，DMA控制器可以通过发送保持寄存器向FIFO发送数据；而当使用供电和仿真寄存器中URST位使异步串口脱离复位状态后也会向DMA控制器发出XEVT信号。









**5****．****FIFO****工作模式**




**FIFO****模式下可以采用下面两种方法处理发送和接收：**

FIFO中断模式：如果FIFO被使能而相关的中断也被使能，在事件发生时向CPU发送中断。

                            在URFCR中使能接受FIFO， 在URIER里使能接收中断，接收FIFO就选了中断模式

FIFO轮寻模式：FIFO被使能而相关的中断被禁止，CPU通过轮寻状态位来检测事件。



**如果工作在****FIFO****中断模式下，如果接收****FIFO****被使能，并且接收中****断被使能时，应注意下面的几点：**




1 当FIFO达到触发值时将向CPU发送一个数据准备好中断，而当CPU或者DMA控制器从FIFO中读走数据使得FIFO低于触发值时，中断将被清除；

2 如果发生溢出错误、奇偶校验错、帧错误和接收间断错误时会产生接收线路状态中断，该中断比数据准备好中断优先级更高；

3 线路状态寄存器URLSR中的数据准备好位（DR）表示接收FIFO中是否有数据，当字符从接收移位寄存器中被拷贝到空的接收FIFO中时， DR被置为1，当FIFO被清空时DR被清0；





**4 如下情况发生时将触发一个接收超时中断： **



    1)在FIFO中至少有一个字符；

    2) 接收上一个字符之后超过4个连续的字符周期，  一个字符周期包括一个起始位、n个数据位、1个奇偶校验位和1个停止位，这里n代表字符长度；

    3) DSP读取上一个字符后时间超过4个字符周期；

5 字符周期可以通过波特率来计算；



6 当接收超时中断发生后，CPU或者DMA控制器从接收FIFO中读取一个字符后中断被清除，而当FIFO接收到一个新的字符，或者URST位被清除时中断也可以被清除；

7 如果没有发生超时中断，则当收到新的字符或者DSP读取接收FIFO后，超时计数器被清0；








当发送FIFO和发送保持寄存器空中断被使能时，则选择了发送FIFO中断模式。这时如果发送FIFO是空的时候产生一个发送保持寄存器空中断，当发送保持寄存器被装入数据时中断被清除。

         工作在FIFO轮寻模式下时，CPU可以通过访问线路状态寄存器中的状态位来检测事件。RFIER位表示是否接收FIFO有错误，TEMT位表示接收保持寄存器和接收移位寄存器为空，THRE位表示接收保持寄存器空，而BI、FE、PE和OE位表示错误发生，而DR位表示接收FIFO中至少有一个字符。




**6****．供电和仿真**



**为了减小电源消耗，用户可以选择相应的空闲等级，如果当前的空闲等级将外设关闭，异步串口将进入静止、低功耗模式：**


**如果正在进行数据传输，异步串口首先停止传输，产生中断或者DMA同步事件，之后进入静止状态；**
**如果没有数据传输，异步串口立刻进入静止状态。 **





**异步串口单元还会受到其他外设状态的影响，如果时钟产生单元处在静止状态，则异步串口将没有时钟输入，如果DMA单元处于静止，则DMA控制器将无法响应DMA事件。**

**供电和仿真控制寄存器中的****FREE****位决定异步串口在仿真模式遇到调试断****点下如何操作。当****FREE****＝****0****时而串口正在传输时，将在这个字传输结束后停止****，如果没有在传输，异步串口将立即停止；如果****FREE=1****时，异步串口将不停****止。**





**异步串口可以通过两种方式复位：**





异步串口复位：当向供电和仿真控制寄存器的URST写入0时，将复位异步串口状态机但不复位寄存器；

DSP复位：RESET引脚为低时，DSP将被复位并保持复位状态直到RESET引脚变高。当DSP复位时，异步串口状态机将复位，而寄存器也将被设成缺省状态。



应注意分频数锁存寄存器不受硬件复位和UART软件复位影响，它必须在上电后载入；为了正确操作UART，分频数必须大于0；为了保证UART和DMA控制器的正常通信，串口FIFO控制寄存器中的DMA模式位（DMAMOD）必须为1，而在硬件复位后，应当把DMAMOD从0改写为1。





**2 UART寄存器**

       异步串口寄存器的地址分配在DSP的IO空间。

 接收缓冲寄存器URRBR、发送保持寄存器URTHR和分频数锁存寄存器（低位）URDLL共用一个地址，当线路控制寄存器URLCR中的DLAB位为0时，DSP从这个地址读到的是接收缓冲寄存器的内容，而从这个地址写入到发送保持寄存器，当DLAB为1时，访问的是分频数锁存寄存器；

中断使能寄存器和分频数锁存寄存器（高位）共用一个地址，当DLAB=0时访问中断使能寄存器，DLAB=1访问分频数锁存寄存器（高位）；

 中断标志寄存器和FIFO控制寄存器共用一个地址，读操作访问中断标志寄存器，写操作访问FIFO控制寄存器；

实际上中断标志寄存器和分频数锁存寄存器（高位）也分配了地址，如果使用这些地址访问的话，可以将DLAB位清0，这时将在确定地址访问接收缓冲寄存器、发送保持寄存器和中断使能寄存器。

应当注意在串口发送过程中不能写控制寄存器，应当在发送过程中保持控制寄存器不变。 





**1****．接收缓冲寄存器（****URRBR****）**


         异步串口接收部分包括接收移位寄存器和接收缓冲寄存器，接收缓冲寄存器的低8位用来存放接收到的字符。当异步串口工作于FIFO模式下时，接收缓冲寄存器是一个16字节FIFO，而时钟由16倍接收时钟提供，接收部分由线路控制寄存器控制。

         接收移位寄存器接收来自RX引脚的串行数据，之后将数据移入接收缓冲寄存器或者接收FIFO中。在非FIFO的工作模式下，当一个字符被放入接收缓冲寄存器中时并且接收数据准备好中断被使能（中断使能寄存器中DR=1），这时会产生一个中断，在字符被从接收缓冲寄存器中读走后中断被清除；工作在FIFO模式下，当FIFO中存储数据达到设定值时也将产生一个中断，而当FIFO中的内容小于设定值时中断被清除。






**2****．发送保持寄存器（****URTHR****）**




         发送部分包括发送保持寄存器和发送移位寄存器，发送保持寄存器的低8位用来保存发送字节，当工作于FIFO模式下时，发送保持寄存器为一个16字节FIFO，发送部分由线路控制寄存器控制。

         当发送保持寄存器从内部数据总线收到数据，如果发送移位寄存器处于空闲状态，异步串口将会把数据从发送保持寄存器送到发送移位寄存器，之后数据被从TX引脚串行输出。当工作于非FIFO模式下时，如果发送保持寄存器为空并且中断使能寄存器中的ETBEI=1时，将产生一个发送保持寄存器空中断，当数据写入到寄存器中时中断被清除；在FIFO模式下时，当发送FIFO为空时产生中断，当字节写入到FIFO中时中断被清除。


**3****．分频数锁存寄存器（****URDLL****和****URDLM****）**


**分频数锁存寄存器由高位和低位组成，而存储的****16****位分频数用来产生波特率产生器的时钟，其中****DLM****保存高****8****位，****DLL****保存低****8****位，而分频数必须在异步串口初始化时被写入寄存器从而保证产生正确的时钟，当分频数写入波特率产生器时会插入两个等待周期。**



**注意： **

**           1 无论是硬件复位，还是UART软件复位，都不会影响URDLL和URDLM，上电后，它的值一定会倍重新装入，在开始串行通信前，确定这些寄存器装入了正确的除数。**

**           2 为了使UART正常工作，URDLM和URDLL中的16位除数必须大于0**


**4****．中断使能寄存器（****URIER****）**



**中断使能寄存器用来使能或者禁止异步串口产生的中断申请，下表给出了寄存器的详细说明。**


**中断使能寄存器****URIER**


|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15~4**|**保留**|**0**|**读取为****0**|
|**3**|**保留**|**0**|**该位应当总被写入****0**|
|**2**|**ELSI**|**0****1**|**使能线路状态中断申请****中断申请禁止****中断申请使能**|
|**1**|**ETBEI**|**0****1**|**使能发送保持寄存器空中断申请****中断申请禁止****中断申请使能**|
|**0**|**ERBEI**|**0****1**|**使能接收数据准备好空和接收超时中断申请****中断申请禁止****中断申请使能**|






**5****．中断标志寄存器（****URIIR****）**




**针对上述****3****种中断，异步串口为其规定了不同的优先级别，其中线路状态中断优先级最高，接收数据准备好和接收超时中断其次，发送保持寄存器中断优先级最低。当中断产生并被使能时，中断标志寄存器通过规定位和中断类型编码来标志未响应的中断。**



**中断标志寄存器****URIIR**


|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15~8**|**保留**|**0**|**读取为****0**|
|**7~6**|**FIENR**|**00****01****10****11**|**FIFO****状态位****非****FIFO****模式（****FIFO****控制寄存器中****FIEN=0****）****保留****保留****FIFO****模式（****FIFO****控制寄存器中****FIEN=1****）**|
|**5****～****4**|**保留**|**0**|**读取为****0**|
|**3****～****1**|**IID**|**011b****010b****110b ****001b****000b**|**中断标志字段。当中断产生并被使能时，通过****IID****字段来显示中断的类型，如****果多个中断同时产生，则具有最高优先级的被记录在****IID****中。当下面的事件发****生时，****IID****的内容将被改写：**l**中断被清除时，****IID****字段被添****0**l**另一个中断发生，****IID****中被装入新的中断类型**l**发生硬件复位，****IID****被添****0****接收线路状态中断****接收数据准备好中断****接收超时中断****发送保持寄存器空中断****没有中断**|
|**0**|**IP**|**0****1**|**中断未响应位。当中断产生并被使能时，****IP****被置入****0****直到该中断被清除或者发****生硬件复位，如果没有中断被使能，****IP****不能置****0****一个中断未被响应****没有中断未被响应**|




**6****．****FIFO****控制寄存器（****URFCR****）**




**FIFO****控制寄存器用来使能和清除****FIFO****，还可以设定接收****FIFO****触发值。**




**FIFO****控制寄存器****URFCR**


|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15~8**|**保留**|**0**|**读取为****0**|
|**7~6**|**RFITR**|**00b****01b****10b****11b**|**接收****FIFO****触发值设定。****1****个字节****4****个字节****8****个字节****14****个字节**|
|**5****～****4**|**保留**|**0**|**读取为****0**|
|**3**|**DMAMOD**|**1**|**DMA****模式，这一位应当写入****1****。在硬件复位后，此位由****0****变****为****1**|
|**2**|**TFIRS**|**0****1**|**发送****FIFO****复位位****此位被清****0****当被设为****1****时，清除发送****FIFO****指针，这时接收****FIFO****中的字****符将被忽略，移位寄存器不会被清****0****，而被写入****1**|
|**1**|**RFIRS**|**0****1**|**接收****FIFO****复位位****此位被清****0****当被设为****1****时，清除接收****FIFO****指针，这时接收****FIFO****中的字****符将被忽略，移位寄存器不会被清****0****，而被写入****1**|
|**0**|**FIEN**|**0****1**|**FIFO****使能位****非****FIFO****模式。接收和发送****FIFO****被禁止，****FIFO****指针被清除****FIFO****模式。接收和发送****FIFO****寄存器被使能**|






**7****．线路控制寄存器（****URLCR****）**






**系统通过线路控制寄存器控制异步通信的数据格式，寄存器的内容可以被获取、查询和修改。**





**线路控制寄存器****URLCR**

|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15~8**|**保留**|**0**|**读取为****0**|
|**7**|**DLAB**|**0 ****1**|**共享地址选择位 ****选择串口接收缓冲寄存器、发送保持寄存器和中断使能寄存器 ****选择分频数锁存寄存器（高位和低位）**|
|**6**|**BC**|**0 ****1**|**间断控制位。当该位被设为****1****时，****TX****信号被强制清除****间断被禁止 ****间断使能**|
|**5**|**STPAR**|**0 ****1**|**添加奇偶校验位。当****3****、****4****和****5****位为****1****时，奇偶校验将被传输但不****检测；当****3****和****5****位为****1****，****4****位为****0****，奇偶校验将被传输并且检测；****如果第****5****位为****0****，将不添加奇偶校验位****不添加奇偶校验位 ****添加奇偶校验位**|
|**4**|**EPS**|**0 ****1**|**偶数校验选择位。 ****奇数校验 ****偶数校验**|


|**3**|**PEN**|**0 ****1**|**奇偶校验使能位 ****奇偶校验禁止 ****奇偶校验使能**|
|----|----|----|----|
|**2**|**STB**|**0 ****1**|**停止位模式位 ****1****个停止位在数据中产生****停止位数量由****WLS****决定**|
|**1****～****0**|**WLS**|**00b ****01b ****10b ****11b**|**字长度选择 ****5****比特****6****比特****7****比特****8****比特**|






**给出了线路控制寄存器中的****STPAR****、****EPS****和****PEN****位之间的相互关****系。**




|**STPAR**|**EPS**|**PEN**|**说明**|
|----|----|----|----|
|**X**|**X**|**0**|**奇偶校验禁止，奇偶校验位不传输和检测**|
|**0**|**0**|**1**|**奇数校验：奇数时为****1**|
|**0**|**1**|**1**|**偶数校验：偶数时为****1**|
|**1**|**0**|**1**|**奇偶校验位传输并检测**|
|**1**|**1**|**1**|**奇偶校验位传输但不检测**|






**接着给出停止位的长度。**




|**STB**|**字长度**|**停止位长度**|**时钟**|
|----|----|----|----|
|**0**|**任何长度**|**1**|**16**|
|**1**|**5****位**|**1****＋****1/2**|**24**|
|**1**|**6****位**|**2**|**32**|
|**1**|**7****位**|**2**|**32**|
|**1**|**8****位**|**3**|**32**|














**8****．循环模式控制寄存器（****URMCR****）**




寄存器中的LOOP位用来使能和禁止异步串口的循环模式，LOOP在寄存器的第4位，当该位为0时，循环模式被禁止；为1时，循环模式被使能，而这时TX为高，RX引脚不连接，这时发送移位寄存器的输出直接接到接收移位寄存器的输入。





**9****．线路状态寄存器（****URLSR****）**





**线路状态寄存器为****CPU****通过数据传输的状态，该寄存器为只读寄存器。**

|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15~8**|**保留**|**0**|**读取为****0**|
|**7**|**RFIER**|**0****1****0****1**|**接收****FIFO****错误指示****非****FIFO****模式****没有错误，或者****CPU****从接收缓冲寄存器中读走了出错的字符造成该****位被清除****有奇偶校验错、帧错误或者通信间断****FIFO****模式****没有错误，或者错误字符被从接收****FIFO****中读走并且在接收****FIFO****中没****有错误****至少有一个奇偶校验错、帧错误或者通信间断**|
|**6**|**TEMT**|**0****1****0****1**|**发送空指示****非****FIFO****模式****发送保持寄存器或发送移位寄存器中装有一个字符****发送保持寄存器和发送移位寄存器为空****FIFO****模式****发送****FIFO****或发送移位寄存器中装有一个字符****发送****FIFO****和发送移位寄存器为空**|


|**5**|**THRE**|**0 ****1 ****0 ****1**|**发送保持寄存器空指示，如果****THRE****为****1****时并且中断被使能，一个中****断申请产生****非****FIFO****模式****发送保持寄存器已经被****CPU****装入****发送保持寄存器空，该寄存器的内容已经被装入发送移位寄存器 ****FIFO****模式****发送****FIFO****中装有一个字符，如果发送****FIFO****不满时还可以写入发送****FIFO****发送****FIFO****为空，****FIFO****中的最后一个字符已经被传到发送移位寄存****器**|
|----|----|----|----|
|**3**|**FE**|**0 ****1 ****0 ****1**|**帧错误指示。当字符接收时没有检测到一个有效的停止位时产生一****个帧错误。当发生帧错误时，异步串口将****FE****设为****1****一直到****RX****引脚变****高；如果****RX****引脚变高，接收器开始检测新数据的起始位。****非****FIFO****模式****没有检测到帧错误，或****CPU****已经从接收缓冲寄存器中读走出错数据****，使得****FE****被清除****在接收缓冲寄存器中的字符被检测到帧错误 ****FIFO****模式****没有检测到帧错误，或****CPU****已经从接收****FIFO****读走出错数据并且下一****个数据没有帧错误，使得****FE****被清除****在接收****FIFO****中的头个字符被检测到帧错误**|


|**2**|**PE**|**0 ****1 ****0 ****1**|**奇偶校验错误指示。当收到的字符奇偶校验出错时该位被设****置****非****FIFO****模式****没有检测到奇偶校验错误，或****CPU****已经从接收缓冲寄存器中****读走出错数据，使得****PE****被清除****在接收缓冲寄存器中的字符被检测到奇偶校验错误 ****FIFO****模式****没有检测到奇偶校验错误，或****CPU****已经从接收****FIFO****读走出错****数据并且下一个数据没有奇偶校验错误，使****PE****被清除****在接收****FIFO****中的头个字符被检测到奇偶校验错误**|
|----|----|----|----|
|**1**|**OE**|**0 ****1 ****0 ****1**|**溢出错误指示。 ****非****FIFO****模式****没有检测到溢出错误，或****CPU****读取线路状态寄存器的内容，****使得****OE****被清除****检测到一个溢出错误，当发生这个错误时，接收缓冲寄存器****中的上一个字符被当前字符覆盖****FIFO****模式****没有检测到溢出错误，或****CPU****读取线路状态寄存器的内容，****使得****OE****被清除****检测到一个溢出错误。当****FIFO****的数据超出容量而数据已经在****移位寄存器中被完整接收时会发生一个溢出错误，这时新的****数据将覆盖移位寄存器中的内容，但不被传输给****FIFO**|


|**0**|**DR**|**0 ****0 ****0 ****1**|**数据准备好指示。 ****非****FIFO****模式****数据没有准备好，或字符被从接收缓冲寄存器中读取，****DR****位被清除****数据准备好。一个完整的字符被接收并被传到接收缓冲寄存****器****FIFO****模式****数据没有准备好，或字符被从****FIFO****中读取，****DR****位被清除****数据准备好。至少还有一个未读字符在接收****FIFO****中。**|
|----|----|----|----|






**10****．供电和仿真控制寄存器（****URPECR****）**

|**位**|**字段**|**数值**|**说明**|
|----|----|----|----|
|**15**|**URST**|**0 ****1**|**异步串口软件复位位 ****串口在复位状态下接收和发送被禁止，异步串口将不产生中****断和****DMA****事件，但是，发送保持寄存器可以被载入数据，接****收缓冲寄存器可以被读取****当向****URST****写入****0****时，异步串口状态机被复位，如果有超时中****断，中断将被清除，但寄存器不受影响****接收和发送被使能**|
|**14~1**|**保留**|**0001h**|**读取返回****0001h**|
|**0**|**FREE**|**0 ****1**|**仿真模式下串口工作设置，如遇到一个调试断点 ****如果没有字符传输，串口将立即停止；如果有字符正在传输****，串口将在传输结束后停止****串口继续工作**|







**11****．草稿寄存器（****URSCR****）**

        该寄存器包含一个8位的域，可以用来保存临时数据，不影响UART的其他工作。




**3 异步串口的应用 **




**调用异步串口函数库首先需要包含****csl_uart.h****库文件，异步串口的****配置结构如下：**





**UART_Setup mySetup = { **

20, //**输入时钟频率**

UART_BAUD_9600, // **波特率 **

UART_WORD8,        // **字长度 **

UART_STOP1,           // **停止位 **

UART_DISABLE_PARITY, // **奇偶校验位 **

UART_FIFO_DMA0_TRIG14,    //FIFO**模式设置**

UART_NO_LOOPBACK, // **禁止循环模式 **

**}; **





**设置函数如下：**




**UART_setup(&mySetup); **



**下面给出查询模式下串口操作的例子：**



**void UART_rec() **

**{ **

**Search: **//**搜索****$****字符**

pStr=ttt;  

ReturnFlag=UART_read(pStr,1,2000);


if(ReturnFlag==false)goto Enddata;


if(pStr[0]!='$')goto Search;


pStr++; 

ReturnFlag=UART_read(pStr,1000,4000000000);


**Enddata****：**

**} **















































