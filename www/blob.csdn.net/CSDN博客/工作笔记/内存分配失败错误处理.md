# 内存分配失败错误处理 - 工作笔记 - CSDN博客





2012年02月28日 16:11:19[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：9173标签：[null																[编译器																[c																[语言](https://so.csdn.net/so/search/s.do?q=语言&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





一、C语言中的malloc/calloc/realloc/valloc/alloca/memalign函数:

这样的内存分配函数在内存分配失败时都返回空指针,因此,在调用返回时,检查返回值的方法比较简单,只需要与空指针比较即可;

如:

char* p = (char*)malloc(1204);

if(p == NULL)

{

 //error handle;

};

char* pp = (char*)calloc(3,1024);

if(pp == NULL)

{

 //error handle;

};

二、C++中的new操作符:

C++中的new操作符在分配内存失败时默认的操作是抛出一个内置的异常,而并不是直接返回空指针;这样的话,再把返回值与空指针比较,就没有什么意义了;因为,C++抛出异常之后,就直接跳出new操作符所在的那一行代码,而不再执行后续的代码行了,所以,对new操作符返回值的判断代码就执行不到了;当然,标准C++也提供了抑制抛出异常的方法,使之不再排除内存分配失败的异常,转而直接返回空指针,这是因为比较古老的编译器里面可能没有异常处理机制,不能捕获到异常;如:

int* p = new int[SIZE];

if(p == 0) //检查p是否是空指针;这个判断没有意义;

{

 return -1;

}

所以,在C++中有两种方法来处理new操作符分配内存失败的错误;

1、通过捕获new操作符抛出的异常:

 char* p = NULL;

 try

 {

  p = new char[1024];

 }

 catch(const std::bad_alloc& ex)

 {

  //exception handle;

  return -1;

 }

2、抑制异常的抛出:

 char* p = NULL;

 p = new(std::nothrow)char[1024]; //这样的话,如果new分配内存失败,就不会再抛出异常,而是返回空指针了;

 if(p == NULL)                    //这样的判断就有意义了;

 {

  //error handle;

  return -1;

 }](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)




