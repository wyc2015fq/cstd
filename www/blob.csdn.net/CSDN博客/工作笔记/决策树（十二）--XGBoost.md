# 决策树（十二）--XGBoost - 工作笔记 - CSDN博客





2018年11月11日 16:11:14[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5336








转自：[https://cloud.tencent.com/developer/article/1005611](https://cloud.tencent.com/developer/article/1005611) 个人感觉这篇文章还是跟网上很多文章一样，把xgboost按gbdt来解释来。我这里略删改。不对之处，还请指正～

原始论文：[https://arxiv.org/pdf/1603.02754v1.pdf](https://arxiv.org/pdf/1603.02754v1.pdf)

实际上，xgboost是对gbdt的优化，所以，先说gbdt.

GBDT 是常用的机器学习算法之一，因其出色的特征自动组合能力和高效的运算大受欢迎。 这里简单介绍一下 GBDT 算法的原理，后续再写一个实战篇。

## 1、决策树的分类

决策树分为两大类，分类树和回归树。

分类树用于分类标签值，如晴天/阴天/雾/雨、用户性别、网页是否是垃圾页面；

回归树用于预测实数值，如明天的温度、用户的年龄、网页的相关程度；

两者的区别：
- 分类树的结果不能进行加减运算，晴天 晴天没有实际意义；
- 回归树的结果是预测一个数值，可以进行加减运算，例如 20 岁 3 岁=23 岁。
- GBDT 中的决策树是回归树，预测结果是一个数值，在点击率预测方面常用 GBDT，例如用户点击某个内容的概率。

## 2、GBDT 概念

GBDT 的全称是 Gradient Boosting Decision Tree，梯度提升决策树。

要理解 GBDT，首先就要理解这个 B(Boosting)。

Boosting 是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting 方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是"三个臭皮匠顶个诸葛亮"的道理。

基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。GBDT 实际上是 GBM 的一种情况。

为什么梯度提升方法倾向于选择决策树作为基学习器呢？(也就是 GB 为什么要和 DT 结合，形成 GBDT) 决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征。

不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。

至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。

**演示例子：**

考虑一个简单的例子来演示 GBDT 算法原理。

下面是一个二分类问题，1 表示可以考虑的相亲对象，0 表示不考虑的相亲对象。

特征维度有 3 个维度，分别对象 身高，金钱，颜值

![](https://blog-10039692.file.myqcloud.com/1501642956355_9623_1501642956595.jpg)

对应这个例子，训练结果是 perfect 的，全部正确， 特征权重可以看出，对应这个例子训练结果颜值的重要度最大，看一下训练得到的树。

**Tree 0：**

![](https://blog-10039692.file.myqcloud.com/1501642975765_6260_1501642976002.jpg)

**Tree 1：**

![](https://blog-10039692.file.myqcloud.com/1501642989663_421_1501642989882.jpg)

## 3、原理推导

### 3.1 目标函数

监督学习的关键概念：模型（model）、参数（parameters）、目标函数（objective function）

模型就是所要学习的条件概率分布或者决策函数，它决定了在给定特征向量时如何预测出目标。

参数就是我们要从数据中学习得到的内容。模型通常是由一个参数向量决定的函数。

目标函数通常定义为如下形式：

![](https://blog-10039692.file.myqcloud.com/1501643033959_4316_1501643034178.jpg)

其中，L 是损失函数，用来衡量模型拟合训练数据的好坏程度；Ω称之为正则项，用来衡量学习到的模型的复杂度。

对正则项的优化鼓励算法学习到较简单的模型，简单模型一般在测试样本上的预测结果比较稳定、方差较小（奥坎姆剃刀原则）。也就是说，优化损失函数尽量使模型走出欠拟合的状态，优化正则项尽量使模型避免过拟合。

### 3.2 加法模型

GBDT 算法可以看成是由 K 棵树组成的加法模型：

![](https://blog-10039692.file.myqcloud.com/1501643159062_4093_1501643159278.jpg)

如何来学习加法模型呢？

解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为 Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下：

![](https://blog-10039692.file.myqcloud.com/1501643175179_8337_1501643175388.jpg)

在第 t 步，这个时候目标函数可以写为：

![](https://blog-10039692.file.myqcloud.com/1501643190325_9227_1501643190542.jpg)

举例说明，假设损失函数为平方损失（square loss），则目标函数为：

![](https://blog-10039692.file.myqcloud.com/1501643530792_8221_1501643531003.jpg)

其中，称

![](https://blog-10039692.file.myqcloud.com/1501643566431_532_1501643566607.jpg)

之为残差（residual）。因此，使用平方损失函数时，GBDT 算法的每一步在生成决策树时只需要拟合前面的模型的残差。

### 3.3 泰勒公式(xgboost优化开始了)

定义：

![](https://blog-10039692.file.myqcloud.com/1501643596877_7984_1501643597159.jpg)

泰勒公式简单的理解，就是函数某个点的取值可以用参考点取值和 n+1 阶导数的来表示，而且这个公式是有规律的比较好记。

根据泰勒公式把函数

![](https://blog-10039692.file.myqcloud.com/1501643642254_3181_1501643642431.jpg)

在

![](https://blog-10039692.file.myqcloud.com/1501643652104_1930_1501643652272.jpg)

点处二阶展开，可得到如下等式：

![](https://blog-10039692.file.myqcloud.com/1501643677719_7983_1501643678144.jpg)

则等式(1) 可转化为：

![](https://blog-10039692.file.myqcloud.com/1501643695330_7395_1501643695522.jpg)

假设损失函数为平方损失函数，把对应的一阶导数和二阶导数代入等式(4) 即得等式(2)。

由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4) 中移除掉常量项，得：

![](https://blog-10039692.file.myqcloud.com/1501643721348_276_1501643721529.jpg)

![](1)![](https://img-blog.csdnimg.cn/20181111164335237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwcF8xMjA2MjAxMQ==,size_16,color_FFFFFF,t_70)

至于为什么要这样展开呢,这里就是xgboost的特点了，通过这种近似，你可以自定义一些损失函数（只要保证二阶可导），树分裂的打分函数是基于gi,hi（Gj，Hj）计算的。 

### 3.4 XGboost算法

一颗生成好的决策树，假设其叶子节点个数为T

决策树的复杂度可以由正则项

![](https://blog-10039692.file.myqcloud.com/1501643770059_803_1501643770241.jpg)

来定义，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的 L2 范数决定。

定义集合![](https://blog-10039692.file.myqcloud.com/1501643782351_8623_1501643782510.jpg)

为所有被划分到叶子节点的训练样本的集合。等式(5) 可以根据树的叶子节点重新组织为 T 个独立的二次函数的和：

![](https://blog-10039692.file.myqcloud.com/1501643829832_7433_1501643830044.jpg)

这里补充一下：

实际上，从这开始，重新定义每棵树：

1.用叶子节点集合以及叶子节点得分表示 

2.每个样本都落在一个叶子节点上 

3.q(x)表示样本x在某个叶子节点上，wq(x)是该节点的打分,即该样本的模型预测值。 

![](https://img-blog.csdnimg.cn/20181112141542455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwcF8xMjA2MjAxMQ==,size_16,color_FFFFFF,t_70)

定义

![](https://blog-10039692.file.myqcloud.com/1501643841474_1618_1501643841649.jpg)

，则等式(6) 可写为：

![](https://blog-10039692.file.myqcloud.com/1501643855958_6279_1501643856128.jpg)

因为一元二次函数最小值处，一阶导数等于 0:

![](https://blog-10039692.file.myqcloud.com/1501643878529_9216_1501643878701.jpg)

此时，目标函数的值为

![](https://blog-10039692.file.myqcloud.com/1501643889509_6268_1501643889675.jpg)

综上，为了便于理解，单颗决策树的学习过程可以大致描述为：

1. 枚举所有可能的树结构 q

2. 用等式(8) 为每个 q 计算其对应的分数 Obj，分数越小说明对应的树结构越好

3. 根据上一步的结果，找到最佳的树结构，用等式(7) 为树的每个叶子节点计算预测值

然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。

1. 从深度为 0 的树开始，对每个叶节点枚举所有的可用特征

2. 针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益（采用最佳分裂点时的收益）

3. 选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集

4. 回到第 1 步，递归执行到满足特定条件为止

### 3.5 收益的计算

如何计算每次分裂的收益呢？假设当前节点记为 C,分裂之后左孩子节点记为 L，右孩子节点记为 R，则该分裂获得的收益定义为当前节点的目标函数值减去左右两个孩子节点的目标函数值之和：

![](https://blog-10039692.file.myqcloud.com/1501643944893_232_1501643945037.jpg)

根据等式(8) 可得：

![](https://blog-10039692.file.myqcloud.com/1501643975754_9322_1501643975923.jpg)

其中，

![](https://blog-10039692.file.myqcloud.com/1501643985291_6528_1501643985636.jpg)

项表示因为增加了树的复杂性（该分裂增加了一个叶子节点）带来的惩罚。

最后，总结一下 XGboost 的学习算法：

1. 算法每次迭代生成一颗新的决策树 ;

2. 在每次迭代开始之前，计算损失函数在每个训练样本点的一阶导数和二阶导数 ;

3. 通过贪心策略生成新的决策树，通过等式(7) 计算每个叶节点对应的预测值

4. 把新生成的决策树

![](https://blog-10039692.file.myqcloud.com/1501644059271_1472_1501644059430.jpg)

添加到模型中：

![](https://blog-10039692.file.myqcloud.com/1501644064883_2052_1501644065000.jpg)

**保持简单**

易经中说道"易则易知，简则易从"，就是越是简易的东西，越是容易被理解和得到执行。很多机器学习模型都会尽量让学习到的模型尽量简单，尽量减少参数，越是简单的模型，通用性越好，也是这个道理。

**Xgboost 和 GBDT 的区别：**

GBDT：
- GBDT 它的非线性变换比较多，表达能力强，而且不需要做复杂的特征工程和特征变换。
- GBDT 的缺点也很明显，Boost 是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征；
- 传统 GBDT 在优化时只用到一阶导数信息。

Xgboost：

它有以下几个优良的特性：

1. 显示的把树模型复杂度作为正则项加到优化目标中。

2. 公式推导中用到了二阶导数，用了二阶泰勒展开。（GBDT 用牛顿法貌似也是二阶信息）

3. 实现了分裂点寻找近似算法。

4. 利用了特征的稀疏性。

5. 数据事先排序并且以 block 形式存储，有利于并行计算。

6. 基于分布式通信框架 rabit，可以运行在 MPI 和 yarn 上。（最新已经不基于 rabit 了）

7. 实现做了面向体系结构的优化，针对 cache 和内存做了性能优化。



