# 汇编学习--7.16--int指令 - 工作笔记 - CSDN博客





2012年07月16日 13:04:04[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：10606








int指令

中断信息可以来自CPU的内部和外部，当CPU的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。

上一章讲解了0号中断和单步中断，这一章将讲解另一种重要的内中断，由int指令引发的中断。





**int指令**

格式：int n

n为中断类型码，它的功能是引发中断过程。



CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：

1）取中断类型码n；

2）标志寄存器入栈，IF=0，TF=0；

3）CS、IP入栈

4）（IP）=（n*4），(CS)=(n*4+2)

从此处转去执行n号中断的中断处理程序。

可以在程序中使用int指令调用任何一个中断的中断处理程序。

assume cs:code

code segment

 start:mov ax,0b800h

move s,ax

mov byte ptr es:[12*160 +40*2],’!’

int 0

code ends

end start



这个程序在Windows2000中的DOS方式下执行时，将在屏幕中间显示一个“！”，然后显示“Divide overflow”后返回到系统中。“！”是我们编程显示的，而“Divide overflow”是哪里来的呢？我们的程序中又没有做除法，不可能产生除法溢出。



程序是没有做除法，但是在结尾使用了int 0指令。

CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，而系统设置的0号中断处理程序的功能是显示“Divide overflow”，然后返回系统。





int指令的最终功能和call指令相似，都是调用一段程序。



一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。我们在编程的时候，可以用int指令调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。

中断处理程序可简称为中断例程。







**编写供应用程序调用的中断例程**



前面已经编写过中断0的中断例程了，现在我们讨论可以供应用程序调用的中断例程的编写方法。

1，示例一

编写、安装中断7ch的中断全程，功能：求一word型数据的平方。

参数：(ax)=要计算的数据。

返回值：dx、ax中存放结果的高16位和低16位。

应用举例：求2*3456^2

assume cs:code

code segment

 start:mov ax,3456
;(ax)=3456

int 7ch
;调用中断7ch的中断例程，计算ax中的数据的平方

add ax,ax

adc dx,dx
;dx:ax存放结果，将结果乘以2



mov ax,4c00h

int 21h

code ends

end start



分析，我们要做三部分工作：

1）编写实现求平方功能的程序；

2）安装程序，我们将其安装在0:200处；

3）设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。



安装程序如下：

assume cs:code

code segment

 start:mov ax,cs

mov ds,ax

mov si, offset sqr;设置ds:si指向源地址



mov ax,0

mov es,ax

mov di, 200h;设置es:di指向目的地址



mov cx, offset sqrend – offset sqr;设置cx为传输长度

cld
;设置传输方向为正

rep movsb



mov ax,0

mov es,ax

mov word ptr es:[7ch*4],200h
;设置中断向量表偏移地址

mov word ptr es:[7ch*4+2],0;设置中断向量表，段地址



mov ax,4c00h

int 21h



 sqr:mul ax

iret

 sqrend: nop

code ends

end start



注意，在中断例程sqr的最后，要使用iret指令。用汇编语法描述，iret指令的功能为：

pop IP

pop CS

popf



CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch执行前的标志寄存器和CS、IP的值，从而接着执行应用程序。



int指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。







2，示例二

编写、安装中断7ch的中断例程，功能：将一个全是字母，以0结尾的字符串，转化为大写。

参数：ds:si指向字符串的首地址。

应用举例：将data段中的字符串转化为大写。



assume cs:code

data segment

db ‘conversation’,0

data ends



code segment

 start:mov ax,data

mov ds,ax

mov si,0



int 7ch



mov ax,4c00h

int 21h

code ends

end start



安装程序如下：

assume cs:code

code segment

 start:mov ax,cs

mov ds,ax

mov si,offset capital



mov ax,0

mov es,ax

mov di,200h



mov cx,offset capitalend – offset capital

cld

rep movsb



mov ax,0

mov es,ax

mov word ptr es:[7ch*4],200h

mov word ptr es:[7ch*4+2],0



mov ax,4c00h

int 21h



 capital:push cx

push si

change:mov cl,[si]

mov ch,0

jcxz ok

and byte ptr [si],11011111b

inc si

jmp short change

ok:pop si

pop cx

iret

 capitalend:nop

code ends

end start



在中断例程capital中用到了寄存器si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。







**对int、iret和栈的深入理解**

问题：用7ch中断例程完成loop指令的功能。

loop s的执行需要两个信息，循环次数和到s的位移，所以7ch中断例程要完成loop指令的功能，也需要这两个信息作为参数。我们用cx存放循环次数，用bx存放位移。







**BIOS和DOS所提供的中断例程**

在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含以下几部分内容：

1）硬件系统的检测和初始化程序；

2）外部中断和内部中断的中断例程；

3）用于对硬件设备进行了I/O操作的中断例程；

4）其他和硬件系统相关的中断例程。



操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。



BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。



和硬件设备相关的DOS中断例程中，一般都调用了BIOS中的中断例程。









**BIOS和DOS中断例程的安装过程**

前面我们都是自己编写中断例程，将它们放到安装程序中，然后运行安装程序，将它们安装到指定的内存区中。此后，别的应用程序才可以调用。



而BISO和DOS提供的中断例程是如何安装到内存中的呢？

1）开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

2）初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。

3）硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。

4）DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。



检测点13.2

1）我们可以编程改变FFFF:0处的指令，使得CPU不去执行BIOS中的硬件系统检测和初始化程序。错，此处内存单元为只读，无法改写。

2）int 19h中断例程，可以由DOS提供。错，int 19h指令是用于引导操作系统的比如DOS，DOS没有机会改变它。









**BIOS中断例程应用**

int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。

一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。



我们看一下int 10h中断例程的设置光标位置功能。

mov ah,2;置光标

mov bh,0;第0页

mov dh,5;行号

mov dl,12;列号

int 10h



(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号(80*25字符模式中：0~24)、列号（80*25字符模式下：0~79），和页号作为参数。

(bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第5页，第12列。



bh中页号的含义：内存地址空间中，B8000h~BFFFFh共32K的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓冲区中共占4000字节。



显示缓冲区分为8页，每页4K（≈4000），显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000~B8F9F中的4000个字节的内容将出现在显示器上。(2*80*25=4000个字节)



再看一下int 10h中断例程的在光标位置显示字符功能。

mov ah,9;置光标

mov al,’a’;字符

mov bl,7;颜色属性

mov bh,0;第0页

mov cx,3;字符重复个数

int 10h



(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。

bh中的颜色属性的格式如下：


||**7**|**6**|**5**|**4**|**3**|**2**|**1**|**0**|
|----|----|----|----|----|----|----|----|----|
|含义|**BL**|**R**|**G**|**B**|**I**|**R**|**G**|**B**|
||闪烁|红色|绿色|蓝色|高亮|红色|绿色|蓝色|
|||背景||前景| | | | |
|例子|1|1|||1||1||

与显存中的属性字节的格式相同。



编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’。

assume cs:code

code segment

 start: mov ah,2;置光标

mov bh,0;第0页

mov dh,5;行号

mov dl,12;列号

int 10h



mov ah,9;置光标

mov al,'a' ;字符

mov bl,11001010b ;颜色属性，闪烁的效果必须在全屏DOS方式下才能看到。

mov bh,0;第0页

mov cx,3;字符重复个数

int 10h



mov ax,4c00h

int 21h

code ends

end start







**DOS中断例程应用**

int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。



我们从前一直使用的是int 21h中断例程的4ch号功能。即程序返回功能，如下：

mov ah,4ch;程序返回

mov al,0;返回值

int 21h

(ah)=4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。



我们前面使用这个功能的时候经常写作：

mov ax,4c00h

int 21h





我们看一下int 21h中断例程的在光标位置显示字符串功能：

ds:dx 指向字符串;要显示的字符串需用“$”作为结束符

mov ah,9;功能号9，表示在光标位置显示字符串

int 21h



(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。



编程：在屏幕的5行12列显示字符串“Welcome to masm!”。

;在屏幕的5行12列显示字符串“Welcome to masm!”

assume cs:code

data segment

 db 'Welcome to masm!','$' ;'$'本身不显示，只起到边界的作用。

data ends



code segment

 start:mov ah,2;置光标

mov bh,0;第0页

mov dh,5;行号

mov dl,12;列号



int 10h



mov ax,data

mov ds,ax

mov dx,0;ds:dx指向字符串地首地址data:0

mov ah,9

int 21h



mov ax,4c00h

int 21h



code ends

end start



上述程序在屏幕的5行12列显示字符串“Welcome to masm”，直到遇见“$”（“$”本身并不显示，只起到边界的作用）。



如果字符串比较长，遇到行尾，程序会自动转到下一行开头处继续显示；如果到了最后一行，还能自动上卷一行。



DOS为程序员提供了许多可以调用的子程序，都包含在int 21h中断例程中，我们这里只对原理进行了讲解，对于DOS提供的所有可调用子程序的情况，读者可以参考相关的书籍。





