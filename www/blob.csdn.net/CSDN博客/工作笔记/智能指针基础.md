# 智能指针基础 - 工作笔记 - CSDN博客





2012年04月20日 09:07:26[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5400标签：[delete																[架构设计																[框架																[编程																[null																[语言](https://so.csdn.net/so/search/s.do?q=语言&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





很遗憾，工作一年，才开始了解这个

由于C++没有GC机制，而我们在设计大型程序时，难免会忘记delete，或者程序遇到异常而过早退出等等情况下，发生内存泄漏问题，此时，用智能指针，便能解决这个问题。

   实际上，智能指针不是指针类型，它是一个栈对象，在它生命周期结束时，利用自身的析构函数，销毁所管理的堆内存，所有智能指针都重载了operator->操作符，返回

对象的引用，用来操作对象，访问指针原来用“.”操作符。

  由于智能指针是一种对象，所以判定智能指针的裸指针是否为空，应该这样if（my_samrt_ptr.get()）。同时智能指针包含了reset（），如果智能指针不传递对象，或者传递一个NUll参数，则指针会释放当前管理对象的内存空间，如果传递一个新对象，则智能指针会释放当前对象，来管理新入的对象。常见的智能指针有以下几种：

**std::auto_ptr**

std::auto_ptr 属于 STL，当然在 namespace std 中，包含头文件 #include<memory> 便可以使用。std::auto_ptr 能够方便的管理单个堆内存对象。但是auto_ptr支持赋值操作，因此赋值后，不能在 使用之前的对象，因为内存管理权已经交到了新指针身上，同时，auto_ptr包含release函数，但它只是交出内存管理权，但不销毁对象，因此可能发生异常。还要注意的是，auto_ptr最好不要作为参数传递，由此产生了下面一种智能指针类型：

**boost::scoped_ptr**

boost::scoped_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。boost::scoped_ptr 跟 std::auto_ptr 一样，可以方便的管理单个堆内存对象，特别的是，boost::scoped_ptr 独享所有权，避免了 std::auto_ptr 恼人的几个问题。

即，它不支持赋值，同时，没有release函数。即，它独享所有权。然而，当我们真正需要复制指针时，却不能用它了，为此，有下面这种指针：

**boost::shared_ptr**

boost::shared_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。在上面我们看到 boost::scoped_ptr 独享所有权，不允许赋值、拷贝，boost::shared_ptr 是专门用于共享所有权的，由于要共享所有权，其在内部使用了引用计数。boost::shared_ptr 也是用于管理单个堆内存对象的。

同样，它也没有release函数。



以上都是管理单个内存的，下面介绍管理数组的：

**boost::scoped_array**

boost::scoped_array 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。boost::scoped_array 便是用于管理动态数组的。跟 boost::scoped_ptr 一样，也是独享所有权的。

**boost::shared_array**

boost::shared_array 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。

    由于 boost::scoped_array 独享所有权，显然在很多情况下（参数传递、对象赋值等）不满足需求，由此我们引入 boost::shared_array。跟 boost::shared_ptr 一样，内部使用了引用计数。

     至此，我们讲过的智能指针有 std::auto_ptr、boost::scoped_ptr、boost::shared_ptr、boost::scoped_array、boost::shared_array。这几个智能指针已经基本够我们使用了，90% 的使用过标准智能指针的代码就这 5 种。可如下还有两种智能指针，它们肯定有用，但有什么用处呢，一起看看吧。

**boost::weak_ptr** 属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。

weak_ptr 是专门为 boost::shared_ptr而准备的。有时候，我们只关心能否使用对象，并不关心内部的引用计数。boost::weak_ptr
是 boost::shared_ptr 的观察者（Observer）对象，观察者意味着 boost::weak_ptr只对 boost::shared_ptr
进行引用，而不改变其引用计数，当被观察的 boost::shared_ptr失效后，相应的 boost::weak_ptr
也相应失效。

其实 boost::weak_ptr主要用在软件架构设计中，可以在基类（此处的基类并非抽象基类，而是指继承于抽象基类的虚基类）中定义一个 boost::weak_ptr，用于指向子类的
 boost::shared_ptr，这样基类仅仅观察自己的 boost::weak_ptr是否为空就知道子类有没对自己赋值了，而不用影响子类 boost::shared_ptr
的引用计数，用以降低复杂度，更好的管理对象。

**boost::intrusive_ptr**

boost::intrusive_ptr属于 boost 库，定义在 namespace boost 中，包含头文件 #include<boost/smart_ptr.hpp> 便可以使用。

讲完如上 6 种智能指针后，对于一般程序来说 C++ 堆内存管理就够用了，现在有多了一种 boost::intrusive_ptr，这是一种插入式的智能指针，内部不含有引用计数，需要程序员自己加入引用计数，不然编译不过（⊙﹏⊙b汗）。个人感觉这个智能指针没太大用处，至少我没用过。有兴趣的朋友自己研究一下源代码哦J。





**三、总结**

如上讲了这么多智能指针，有必要对这些智能指针做个总结：

1、在可以使用 boost 库的场合下，拒绝使用 std::auto_ptr，因为其不仅不符合 C++ 编程思想，而且极容易出错[2]。

2、在确定对象无需共享的情况下，使用 boost::scoped_ptr（当然动态数组使用 boost::scoped_array）。

3、在对象需要共享的情况下，使用 boost::shared_ptr（当然动态数组使用 boost::shared_array）。

4、在需要访问 boost::shared_ptr 对象，而又不想改变其引用计数的情况下，使用 boost::weak_ptr，一般常用于软件框架设计中。

5、最后一点，也是要求最苛刻一点：在你的代码中，不要出现 delete 关键字（或 C 语言的 free 函数），因为可以用智能指针去管理。](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=框架&t=blog)](https://so.csdn.net/so/search/s.do?q=架构设计&t=blog)](https://so.csdn.net/so/search/s.do?q=delete&t=blog)




