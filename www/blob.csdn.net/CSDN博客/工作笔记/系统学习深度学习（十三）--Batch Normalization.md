# 系统学习深度学习（十三）--Batch Normalization - 工作笔记 - CSDN博客





2017年02月25日 15:57:43[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：7062








    Batch Normalization，简称BN，来源于[《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》](http://arxiv.org/pdf/1502.03167.pdf)，也是GoogLeNet v2

**1-Motivation**

    作者认为：网络训练过程中参数不断改变导致后续每一层输入的分布也发生变化，而学习的过程又要使每一层适应输入的分布，因此我们不得不降低学习率、小心地初始化。作者将分布发生变化称之为**internal covariate shift**。

大家应该都知道，我们一般在训练网络的时会将输入减去均值，还有些人甚至会对输入做白化等操作，目的是为了加快训练。为什么减均值、白化可以加快训练呢，这里做一个简单地说明：

    首先，图像数据是高度相关的，假设其分布如下图a所示(简化为2维)。由于初始化的时候，我们的参数一般都是0均值的，因此开始的拟合y=Wx+b，基本过原点附近，如图b红色虚线。因此，网络需要经过多次学习才能逐步达到如紫色实线的拟合，即收敛的比较慢。如果我们对输入数据先作减均值操作，如图c，显然可以加快学习。更进一步的，我们对数据再进行去相关操作，使得数据更加容易区分，这样又会加快训练，如图d。
![这里写图片描述](https://img-blog.csdn.net/20160223160020989)





**白化**的方式有好几种，常用的有PCA白化：即对数据进行PCA操作之后，在进行方差归一化。这样数据基本满足0均值、单位方差、弱相关性。作者首先考虑，对每一层数据都使用白化操作，但分析认为这是不可取的。因为白化需要计算协方差矩阵、求逆等操作，**计算量很大**，此外，反向传播时，白化操作**不一定可导**。于是，作者采用下面的Normalization方法。


**2-Normalization via Mini-Batch Statistics**

数据归一化方法很简单，就是要让数据具有**0均值和单位方差**，如下式： 
![这里写图片描述](https://img-blog.csdn.net/20160223160039062)
但是作者又说如果简单的这么干，会降低层的表达能力。比如下图，在使用sigmoid激活函数的时候，如果把数据限制到0均值单位方差，那么相当于只使用了激活函数中近似线性的部分，这显然会降低模型表达能力。
![这里写图片描述](https://img-blog.csdn.net/20160223160053859)

为此，作者又为BN增加了2个参数，用来保持模型的表达能力。 
于是最后的输出为： 
![这里写图片描述](https://img-blog.csdn.net/20160223160123115)
上述公式中用到了均值E和方差Var，需要注意的是理想情况下E和Var应该是针对整个数据集的，但显然这是不现实的。因此，作者做了简化，**用一个Batch的均值和方差作为对整个数据集均值和方差的估计。**
整个BN的[算法](http://lib.csdn.net/base/datastructure)如下：
![这里写图片描述](https://img-blog.csdn.net/20160223160132599)



输入：输入数据x1..xm（这些数据是准备进入激活函数的数据） 
计算过程中可以看到, 
1.求数据均值； 
2.求数据方差； 
3.数据进行标准化（个人认为称作正态化也可以） 
4.训练参数γ，β 
5.输出y通过γ与β的线性变换得到新的值 
*在正向传播的时候，通过可学习的γ与β参数求出新的分布值*

*在反向传播的时候，通过链式求导方式，求出γ与β以及相关权值*
![这里写图片描述](https://img-blog.csdn.net/20161128140208600)

**3-BN的意义**

解决的问题是梯度消失与梯度爆炸。 
关于*梯度消失*，以sigmoid函数为例子，sigmoid函数使得输出在[0,1]之间。 
![这里写图片描述](https://img-blog.csdn.net/20161128122840646)
事实上x到了一定大小，经过sigmoid函数的输出范围就很小了，参考下图 
![这里写图片描述](https://img-blog.csdn.net/20161128123239868)
如果输入很大，其对应的斜率就很小，我们知道，其斜率（梯度）在反向传播中是权值学习速率。所以就会出现如下的问题， 
![这里写图片描述](https://img-blog.csdn.net/20161128123955871)
在深度网络中，如果网络的激活输出很大，其梯度就很小，学习速率就很慢。假设每层学习梯度都小于最大值0.25，网络有n层，因为链式求导的原因，第一层的梯度小于0.25的n次方，所以学习速率就慢，对于最后一层只需对自身求导1次，梯度就大，学习速率就快。 
这会造成的影响是在一个很大的深度网络中，浅层基本不学习，权值变化小，后面几层一直在学习，结果就是，后面几层基本可以表示整个网络，失去了深度的意义。

关于*梯度爆炸*，根据链式求导法， 
第一层偏移量的梯度=激活层斜率1x权值1x激活层斜率2x…激活层斜率(n-1)x权值(n-1)x激活层斜率n 
假如激活层斜率均为最大值0.25，所有层的权值为100，这样梯度就会指数增加。

**4-BN在CNN中的用法**

先解释一下对于图片卷积是如何使用BN层。 
![这里写图片描述](https://img-blog.csdn.net/20161021135241205)
这是文章卷积神经网络CNN（1）中5x5的图片通过valid卷积得到的3x3特征图（粉红色）。特征图里的值，作为BN的输入，也就是这9个数值通过BN计算并保存γ与β，通过γ与β使得输出与输入不变。假设输入的batch_size为m，那就有m*9个数值，计算这m*9个数据的γ与β并保存。正向传播过程如上述，对于反向传播就是根据求得的γ与β计算梯度。 
这里需要着重说明2个细节：
1.网络训练中以batch_size为最小单位不断迭代，很显然，新的batch_size进入网络，机会有新的γ与β，因此，在BN层中，有*总图片数/batch_size*组γ与β被保存下来。 
2.图像卷积的过程中，通常是使用多个卷积核，得到多张特征图，对于多个的卷积核需要保存多个的γ与β。

结合论文中给出的使用过程进行解释 
![这里写图片描述](https://img-blog.csdn.net/20161128135212556)
输入：待进入激活函数的变量 
输出： 
1.对于K维的输入，假设每一维包含m个变量，所以需要K个循环。每个循环中按照上面所介绍的方法计算γ与β。这里的K维，在卷积网络中可以看作是卷积核个数，如网络中第n层有64个卷积核，就需要计算64次。 
*需要注意，在正向传播时，会使用γ与β使得BN层输出与输入一样。*
2.在反向传播时利用γ与β求得梯度从而改变训练权值（变量）。 
3.通过不断迭代直到训练结束，求得关于不同层的γ与β。如网络有n个BN层，每层根据batch_size决定有多少个变量，设定为m，这里的mini-batcherB指的是*特征图大小*batch_size*，即*m=特征图大小*batch_size*，因此，对于batch_size为1，这里的m就是每层特征图的大小。 
4.不断遍历训练集中的图片，取出每个batch_size中的γ与β，最后统计每层BN的γ与β各自的和除以图片数量得到平均直，并对其做无偏估计直作为每一层的E[x]与Var[x]。 
5.在预测的正向传播时，对测试数据求取γ与β，并使用该层的E[x]与Var[x]，通过图中11:所表示的公式计算BN层输出。 
*注意，在预测时，BN层的输出已经被改变*，所以BN层在预测的作用体现在此处




**5-BN before or after Activation**


作者在文章中说应该把BN放在激活函数之前，这是因为Wx+b具有更加一致和非稀疏的分布。但是也有人做实验表明放在激活函数后面效果更好。这是实验链接，里面有很多有意思的对比实验：[https://github.com/ducha-aiki/caffenet-benchmark](https://github.com/ducha-aiki/caffenet-benchmark)

### 6-Experiments

作者在文章中也做了很多实验对比，我这里就简单说明2个。 
下图a说明，**BN可以加速训练**。图b和c则分别展示了训练过程中输入数据分布的变化情况。 
![这里写图片描述](https://img-blog.csdn.net/20160223170548936)

下表是一个实验结果的对比，需要注意的是在使用BN的过程中，作者发现Sigmoid激活函数比Relu效果要好。 
![这里写图片描述](https://img-blog.csdn.net/20160223170557093)



