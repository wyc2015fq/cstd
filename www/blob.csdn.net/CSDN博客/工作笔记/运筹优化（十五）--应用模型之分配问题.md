# 运筹优化（十五）--应用模型之分配问题 - 工作笔记 - CSDN博客





2019年01月21日 22:48:02[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5752
所属专栏：[运筹优化](https://blog.csdn.net/column/details/32251.html)









### 一般分配模型

一、问题描述

问题描述：N个人分配N项任务，一个人只能分配一项任务，一项任务只能分配给一个人，将一项任务分配给一个人是需要支付报酬，如何分配任务，保证支付的报酬总数最小。

问题数学描述：

![](http://images.cnitblog.com/blog/414008/201308/16105403-ca358c7ba10f471ab61b85c5b71aa15a.png)

注意，这个规划问题是整数线性规划（ILP）问题，也就是说，两个约束方程，保证每个任务被分配一次。决策变量仅允许取离散值0/1 

二、实例分析---穷举法

在讲将匈牙利算法解决任务问题之前，先分析几个具体实例。

以3个工作人员和3项任务为实例，下图为薪酬图表和根据薪酬图表所得的cost矩阵。

![](http://images.cnitblog.com/blog/414008/201308/16111408-144da453ef0e4201a04ed3b68295345d.png)

利用最简单的方法(穷举法)进行求解，计算出所有分配情况的总薪酬开销，然后求最小值。

total_cost1 = 250 + 600 + 250 = 1100;  x00 = 1,x11 = 1,x22 = 1;

total_cost2 = 250 + 350 + 400 = 1000;  x00 = 1,x12 = 1,x21 = 1;

total_cost3 = 400 + 400 + 250 = 1050;  x01 = 1,x10 = 1,x22 = 1;

total_cost4 = 400 + 350 + 200 = 950;   x01 = 1,x12 = 1,x20 = 1;  //最优分配

total_cost5 = 350 + 400 + 400 = 1150; x02 = 1,x10 = 1,x21 = 1;

total_cost6 = 350 + 600 + 250 = 1150; x02 = 1,x11 = 1,x22 = 1;

对于任务数和人员数较少时，可利用穷举法计算结果。

若将N任务分配给N个人员，其包含的所有分配情况数目为N!，N增大时，穷举法将难以完成任务。

三、匈牙利算法

下面简要介绍匈牙利算法。

其基本的理论基础是针对cost矩阵，将cost矩阵的一行或一列数据加上或减去一个数，其最优任务分配求解问题不变。

![](http://images.cnitblog.com/blog/414008/201308/16113449-c920c502e1734f95bb2d105d54ba3114.png)

算法的基本步骤如下：

![](http://images.cnitblog.com/blog/414008/201308/16113637-a12debf2e52347ad960dc3a6891fac67.png)

四、实例分析---匈牙利算法

下面结合具体实例，分析匈牙利算法如何解决任务分配问题。

以N = 4为实例，下图为cost列表和cost矩阵。

![](http://images.cnitblog.com/blog/414008/201308/16122650-083d9a2261f347b0b737e223459cfd56.png)

Step1.从第1行减去75，第2行减去35，第3行减去90，第4行减去45。

![](http://images.cnitblog.com/blog/414008/201308/16125145-47d34bd691344df9b3dab303d567103f.png)

Step2.从第1列减去0，第2列减去0，第3列减去0，第4列减去5。

![](http://images.cnitblog.com/blog/414008/201308/16125155-3cff99fac0cd470e96bb5742ed185749.png)

Step3.利用最少的水平线或垂直线覆盖所有的0。

![](http://images.cnitblog.com/blog/414008/201308/16125204-a57077fd4f4143f195084c60f5d0b235.png)

Step4.由于水平线和垂直线的总数是3，少于4，进入Step5。

Step5.没有被覆盖的最小值是5，没有被覆盖的每行减去最小值5，被覆盖的每列加上最小值5，然后跳转到步骤3.

![](http://images.cnitblog.com/blog/414008/201308/16125836-41bc7b5323c64e52acb5fdf26b8c5323.png)

Step3.利用最少的水平线或垂直线覆盖所有的0。

![](http://images.cnitblog.com/blog/414008/201308/16130048-b4f256090cb14943848a35b9d031ef91.png)

Step4.由于水平线和垂直线的总数是3，少于4，进入Step5。

Step5.没有被覆盖的最小值是20，没有被覆盖的每行减去最小值20，被覆盖的每列加上最小值20，然后跳转到步骤3.

![](http://images.cnitblog.com/blog/414008/201308/16130731-4b7faf6e2d9d42628dd96545f9e25844.png)

Step3.利用最少的水平线或垂直线覆盖所有的0。

![](http://images.cnitblog.com/blog/414008/201308/16130909-9f3aae88e42b4d75bf865a64a5d8d49b.png)

Step4.由于水平线和垂直线的总数是4，算法结束，分配结果如下图所示。

![](http://images.cnitblog.com/blog/414008/201308/16131548-66b7fc602a0a4c79bb8140bd49abb0e9.png)

其中，黄色框表示分配结果，左边矩阵的最优分配等价于左边矩阵的最优分配。

注意：若分配问题中需要配对两个集合大小不同，则小的一个可以利用伪成员进行扩张，这些伪成员可以分配给另外一个集合里的所有成员，且相应的费用为零。

### 二次分配模型

我们在上面一般分配问题的约束下，最小化或者最大化如下形式的二次目标函数：

![\sum_{i} \sum_{j} \sum_{k > i}\sum_{i \neq j} c_{i,j,k,l} x_{i,j}x_{k,l}](https://private.codecogs.com/gif.latex?%5Csum_%7Bi%7D%20%5Csum_%7Bj%7D%20%5Csum_%7Bk%20%3E%20i%7D%5Csum_%7Bi%20%5Cneq%20j%7D%20c_%7Bi%2Cj%2Ck%2Cl%7D%20x_%7Bi%2Cj%7Dx_%7Bk%2Cl%7D)

其中![c_{i,j,k,l}](https://private.codecogs.com/gif.latex?c_%7Bi%2Cj%2Ck%2Cl%7D)是将i分配给j且k分配给l的收益或者成本

注意到，目标函数的每一项包含两个分配决策：![c_{i,j,k,l} x_{i,j}x_{k,l}](https://private.codecogs.com/gif.latex?c_%7Bi%2Cj%2Ck%2Cl%7D%20x_%7Bi%2Cj%7Dx_%7Bk%2Cl%7D)，也就是只有![x_{i,j} = 1\, and \, x_{k,l} = 1](https://private.codecogs.com/gif.latex?x_%7Bi%2Cj%7D%20%3D%201%5C%2C%20and%20%5C%2C%20x_%7Bk%2Cl%7D%20%3D%201)才会有![c_{i,j,k,l}](https://private.codecogs.com/gif.latex?c_%7Bi%2Cj%2Ck%2Cl%7D)的成本。

这种模型的应用，主要是在购物商场的店铺装修布局。

注意：计算二次分配模型的全局最优点是很困难的，这是因为目标函数变成了非线性，此时不再是整数规划问题了，解这类问题通常采用启发式算法。

### 广义分配模型

我们之前的分配问题约束是每个i必须被分配到一个j中，反之亦然。现在假设每一个i必须被分配给一些事物j，每一个事物j可以与多个i配对。具体来说，定义如下变量：

bj 表示j的容量

si,j表示如果i被分配j，那么j需要消耗的容量、空间、或者类似的量

ci,j表示i分配给j的成本或者收益

此时，用来找到在不超过容量限制的情况下最佳分配所有事物i的方案的模型，就是广义分配模型，形式如下：

![min \, or \, max \sum_{i}\sum_{j} c_{i,j} x_{i,j}](https://private.codecogs.com/gif.latex?min%20%5C%2C%20or%20%5C%2C%20max%20%5Csum_%7Bi%7D%5Csum_%7Bj%7D%20c_%7Bi%2Cj%7D%20x_%7Bi%2Cj%7D)

![s.t. \sum_{j} x_{i,j} = 1 \, \forall i](https://private.codecogs.com/gif.latex?s.t.%20%5Csum_%7Bj%7D%20x_%7Bi%2Cj%7D%20%3D%201%20%5C%2C%20%5Cforall%20i)

![\sum_{j} s_{i,j}x_{i,j} \leq b_{j} \, \forall j](https://private.codecogs.com/gif.latex?%5Csum_%7Bj%7D%20s_%7Bi%2Cj%7Dx_%7Bi%2Cj%7D%20%5Cleq%20b_%7Bj%7D%20%5C%2C%20%5Cforall%20j)

![x_{i,j} =0 \, or \, 1 \, \forall i,j](https://private.codecogs.com/gif.latex?x_%7Bi%2Cj%7D%20%3D0%20%5C%2C%20or%20%5C%2C%201%20%5C%2C%20%5Cforall%20i%2Cj)

广义分配模型，还是属于整数规划问题，在规模适中时可以用整数规划求解方式求解。

### 匹配模型

最后一种分配模型是消除集合之间的区别，即寻找同一类事物之间的最佳配对，此时，我们把一般分配模型中的j换成i',同时，约束条件变为：

![\sum_{i' < i} x_{i',i} + \sum_{i' > i} x_{i,i'} = 1 \, \forall i](https://private.codecogs.com/gif.latex?%5Csum_%7Bi%27%20%3C%20i%7D%20x_%7Bi%27%2Ci%7D%20&plus;%20%5Csum_%7Bi%27%20%3E%20i%7D%20x_%7Bi%2Ci%27%7D%20%3D%201%20%5C%2C%20%5Cforall%20i)

![x_{i,i'} =0 \, or \, 1 \, \forall i,i' > i](https://private.codecogs.com/gif.latex?x_%7Bi%2Ci%27%7D%20%3D0%20%5C%2C%20or%20%5C%2C%201%20%5C%2C%20%5Cforall%20i%2Ci%27%20%3E%20i)

一般来说，令i‘ > i的目的在于消去重复计数。

其应用如扬声器匹配模型，同一批扬声器由于生产工艺的差别，搭配成一个立体声系统时，两个扬声器之间存在干扰失真，建模的意义在于，如何搭配两个扬声器，使得整体的干扰失真最小。

下面补充一点二分图匹配问题，仔细体会，跟上面分配问题还是不太一样，上面定义为整数线性规划问题，下面采用图的方式，差别在于，上面分配问题已经考虑了分配成本或者收益，下面图分两种，一种带权（就是上面分配问题），一种不带权。

以下参考：[https://www.renfei.org/blog/bipartite-matching.html](https://www.renfei.org/blog/bipartite-matching.html)

### 无权二分图

**二分图**：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集U和V，使得每一条边都分别连接U,V的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。

![](https://img-blog.csdnimg.cn/20190122130023649.png)![](https://img-blog.csdnimg.cn/20190122130035330.png)![](https://img-blog.csdnimg.cn/20190122130046154.png)![](https://img-blog.csdnimg.cn/20190122130101698.png)

我们定义**匹配点**、**匹配边**、**未匹配点**、**非匹配边**，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完备匹配。如果两个集合的顶点数相同，且是完备匹配则成为一个完美匹配，图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。

举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是**完美匹配**问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是**最大匹配**问题。

![](https://img-blog.csdnimg.cn/20190122131425894.png)

基本概念讲完了。求解最大匹配问题的一个算法是**匈牙利算法**，下面讲的概念都为这个算法服务。

![](https://img-blog.csdnimg.cn/20190122131442655.png)

**交替路**：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。

**增广路**：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：

![](https://img-blog.csdnimg.cn/20190122131609617.png)

增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是**改进匹配**。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。

我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。

**匈牙利树**一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：

![](https://img-blog.csdnimg.cn/20190122131703564.png)![](https://img-blog.csdnimg.cn/20190122131712408.png)![](https://img-blog.csdnimg.cn/20190122131722927.png)

这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。

下面给出**匈牙利算法**的 DFS 和 BFS 版本的代码：

```
// 顶点、边的编号均从 0 开始
// 邻接表储存

struct Edge
{
    int from;
    int to;
    int weight;

    Edge(int f, int t, int w):from(f), to(t), weight(w) {}
};

vector<int> G[__maxNodes]; /* G[i] 存储顶点 i 出发的边的编号 */
vector<Edge> edges;
typedef vector<int>::iterator iterator_t;
int num_nodes;
int num_left;
int num_right;
int num_edges;
```

```
int matching[__maxNodes]; /* 存储求解结果 */
int check[__maxNodes];

bool dfs(int u)
{
    for (iterator_t i = G[u].begin(); i != G[u].end(); ++i) { // 对 u 的每个邻接点
        int v = edges[*i].to;
        if (!check[v]) {     // 要求不在交替路中
            check[v] = true; // 放入交替路
            if (matching[v] == -1 || dfs(matching[v])) {
                // 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功
                matching[v] = u;
                matching[u] = v;
                return true;
            }
        }
    }
    return false; // 不存在增广路，返回失败
}

int hungarian()
{
    int ans = 0;
    memset(matching, -1, sizeof(matching));
    for (int u=0; u < num_left; ++u) {
        if (matching[u] == -1) {
            memset(check, 0, sizeof(check));
            if (dfs(u))
                ++ans;
        }
    }
    return ans;
}
```

```
queue<int> Q;
int prev[__maxNodes];
int Hungarian()
{
    int ans = 0;
    memset(matching, -1, sizeof(matching));
    memset(check, -1, sizeof(check));
    for (int i=0; i<num_left; ++i) {
        if (matching[i] == -1) {
            while (!Q.empty()) Q.pop();
            Q.push(i);
            prev[i] = -1; // 设 i 为路径起点
            bool flag = false; // 尚未找到增广路
            while (!Q.empty() && !flag) {
                int u = Q.front();
                for (iterator_t ix = G[u].begin(); ix != G[u].end() && !flag; ++ix) {
                    int v = edges[*ix].to;
                    if (check[v] != i) {
                        check[v] = i;
                        Q.push(matching[v]);
                        if (matching[v] >= 0) { // 此点为匹配点
                            prev[matching[v]] = u;
                        } else { // 找到未匹配点，交替路变为增广路
                            flag = true;
                            int d=u, e=v;
                            while (d != -1) {
                                int t = matching[d];
                                matching[d] = e;
                                matching[e] = d;
                                d = prev[d];
                                e = t;
                            }
                        }
                    }
                }
                Q.pop();
            }
            if (matching[i] != -1) ++ans;
        }
    }
    return ans;
}
```

**匈牙利算法的要点如下**
- 
从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。
- 如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。
- 如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。

- 
由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 `prev` 数组。


**性能比较**

两个版本的时间复杂度均为O(V⋅E)O(V⋅E)。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。

补充定义和定理：

**最大匹配数**：最大匹配的匹配边的数目

**最小点覆盖数**：选取最少的点，使任意一条边至少有一个端点被选择

**最大独立数**：选取最多的点，使任意所选两点均不相连

**最小路径覆盖数**：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。

定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）

定理2：最大匹配数 = 最大独立数

定理3：最小路径覆盖数 = 顶点数 - 最大匹配数

### 带权二分图

在一个二分图内，左顶点为X，右顶点为Y，现对于每组左右连接XiYj有权wij，求一种匹配使得所有wij的和最大。也就是最大权匹配一定是完备匹配。如果两边的点数相等则是完美匹配。如果点数不相等，其实可以虚拟一些点，使得点数相等，也成为了完美匹配。最大权匹配还可以用最大流去解决。从这里可以看出，本文开头提到的一般分配问题，就是带权二分图的完美匹配问题。

Kuhn－Munkras算法流程：

　　(1)初始化可行顶标的值

　　(2)用匈牙利算法寻找完备匹配

　　(3)若未找到完备匹配则修改可行顶标的值

　　(4)重复(2)(3)直到找到相等子图的完备匹配为止　

详细的KM算法这里不提了，本文的主要目的在于区分清楚这几个模型概念，且找到每个问题的最佳求解方式。

KM算法是求最大权完备匹配，如果要求最小权完备匹配怎么办？方法很简单，只需将所有的边权值取其相反数，求最大权完备匹配，匹配的值再取相反数即可。

KM算法的运行要求是**必须存在一个完备匹配**，如果求一个最大权匹配(不一定完备)该如何办？依然很简单，把不存在的边权值赋为0。

KM算法求得的最大权匹配是**边权值和**最大，如果我想要**边权之积**最大，又怎样转化？还是不难办到，每条边权取自然对数，然后求最大和权匹配，求得的结果a再算出e^a就是最大积匹配。至于精度问题则没有更好的办法了。

**求最小(大)权匹配的费用流建模方法**

求最小(大)权匹配，可以用最小(大)费用最大流的方法。和二分图最大匹配的构图方法类似，添加附加源S和附加汇T，从S向二分图X集合中每个顶点连接一条权值为0，容量为1的有向边，从Y集合中每个顶点向T也连接一条权值为0，容量为1的有向边。然后把原有的边变成容量为1，权值不变的有向边。求从S到T的最小(大)费用最大流，就能求得最小(大)权匹配。

上述建模求最大权匹配的方法求得的**一定**是最佳匹配(如果存在完备匹配)，因为S到X集合每条边全部满流。如下图所示，最小费用最大流为2。

![](https://img-blog.csdnimg.cn/20190122134957100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwcF8xMjA2MjAxMQ==,size_16,color_FFFFFF,t_70)

要求最大权匹配(不一定完备匹配)。如下图，只需再引入一个顶点A，从X集合的每个顶点向A连接一条容量为1，权值为0的边，然后再由A向T连接一条权值为0，容量不小于|X|的边，求最大费用最大流，这时是100。

![](https://img-blog.csdnimg.cn/20190122135109190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwcF8xMjA2MjAxMQ==,size_16,color_FFFFFF,t_70)

最小权匹配也类似，不过新加的边权要为一个极大值，大于所有已有边权值。

**KM算法与费用流的比较**

从理论上分析，KM算法的时间复杂度比费用流要好，但是实际上和较好的费用流算法比起来运行效率是差不多的，KM算法优势仅仅在于编程容易。对于十分稀疏的图，许多优秀的费用流算法效率是很高的。这并不说明KM算法不如费用流，毕竟在信息学竞赛中，编程的复杂度也是一个相当重要的需要考虑的因素。



