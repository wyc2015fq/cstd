# 匈牙利算法 - 工作笔记 - CSDN博客





2016年12月13日 09:42:02[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：6829








转自：http://blog.csdn.net/dark_scope/article/details/8880547（很有意思的博主，再次感谢！）

【书本上的[算法](http://lib.csdn.net/base/datastructure)往往讲得非常复杂，我和我的朋友计划用一些简单通俗的例子来描述算法的流程】




匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。


-------等等，看得头大？那么请看下面的版本：



通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（![惊讶](http://static.blog.csdn.net/xheditor/xheditor_emot/default/ohmy.gif)-_-||暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉![快哭了](http://static.blog.csdn.net/xheditor/xheditor_emot/default/fastcry.gif)），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。

![](https://img-blog.csdn.net/20130503155150538)




本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做：

===============================================================================

**一：** 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got
 it，连上一条蓝线

![](https://img-blog.csdn.net/20130503155256629)




===============================================================================

**二**：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got
 it

![](https://img-blog.csdn.net/20130503155344972)




===============================================================================

**三**：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？

我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。



(黄色表示这条边被临时拆掉)

![](https://img-blog.csdn.net/20130503155428908)



与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配(![发火](http://static.blog.csdn.net/xheditor/xheditor_emot/default/angry.gif)![发火](http://static.blog.csdn.net/xheditor/xheditor_emot/default/angry.gif))重新找个妹子(注意这个步骤和上面是一样的，这是一个递归的过程)




![](https://img-blog.csdn.net/20130503155441032)



此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去



2号男生可以找3号妹子~~~1号男生可以找2号妹子了~~~3号男生可以找1号妹子

![](https://img-blog.csdn.net/20130503155453501)![](https://img-blog.csdn.net/20130503155626560)![](https://img-blog.csdn.net/20130503162147840)

所以第三步最后的结果就是：

![](https://img-blog.csdn.net/20130503160156253)




===============================================================================

**四**： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子，我们实在是无能为力了……香吉士同学走好。



===============================================================================

这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字

其原则大概是：有机会上，没机会创造机会也要上

【code】



bool find(int x){int i,j;for (j=1;j<=m;j++){ //扫描每个妹子if (line[x][j]==true && used[j]==false) //如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了）{used[j]=1;if (girl[j]==0
 || find(girl[j])) { //名花无主或者能腾出个位置来，这里使用递归girl[j]=x;return true;}}}return false;}



在主程序我们这样做：每一步相当于我们上面描述的一二三四中的一步





for (i=1;i<=n;i++){memset(used,0,sizeof(used)); //这个在每一步中清空if find(i) all+=1;}




喜欢推导的看这里:

http://www.cnblogs.com/dwdxdy/archive/2013/08/16/3261742.html

**一、问题描述**

问题描述：N个人分配N项任务，一个人只能分配一项任务，一项任务只能分配给一个人，将一项任务分配给一个人是需要支付报酬，如何分配任务，保证支付的报酬总数最小。

问题数学描述：

![](https://img-blog.csdn.net/20161213100300202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**二、实例分析---穷举法**

在讲将匈牙利算法解决任务问题之前，先分析几个具体实例。

以3个工作人员和3项任务为实例，下图为薪酬图表和根据薪酬图表所得的cost矩阵。

![](https://img-blog.csdn.net/20161213100314718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

利用最简单的方法**(穷举法)**进行求解，计算出所有分配情况的总薪酬开销，然后求最小值。

total_cost1 = 250 + 600 + 250 = 1100;  x00 = 1,x11 = 1,x22 = 1;

total_cost2 = 250 + 350 + 400 = 1000;  x00 = 1,x12 = 1,x21 = 1;

total_cost3 = 400 + 400 + 250 = 1050;  x01 = 1,x10 = 1,x22 = 1;

**total_cost4 = 400 + 350 + 200 = 950;   x01 = 1,x12 = 1,x20 = 1;  //最优分配**

total_cost5 = 350 + 400 + 400 = 1150; x02 = 1,x10 = 1,x21 = 1;

total_cost6 = 350 + 600 + 250 = 1150; x02 = 1,x11 = 1,x22 = 1;

对于任务数和人员数较少时，可利用穷举法计算结果。

**若将N任务分配给N个人员，其包含的所有分配情况数目为N!，**N增大时，穷举法将难以完成任务。

**三、匈牙利算法**

下面简要介绍匈牙利算法。

**其基本的理论基础是针对cost矩阵，将cost矩阵的一行或一列数据加上或减去一个数，其最优任务分配求解问题不变。**

![](https://img-blog.csdn.net/20161213100328343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

算法的基本步骤如下：

![](https://img-blog.csdn.net/20161213100339783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**四、实例分析---匈牙利算法**

下面结合具体实例，分析匈牙利算法如何解决任务分配问题。

以N = 4为实例，下图为cost列表和cost矩阵。

![](https://img-blog.csdn.net/20161213100435174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step1.**从第1行减去75，第2行减去35，第3行减去90，第4行减去45。

![](https://img-blog.csdn.net/20161213100447721?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step2.**从第1列减去0，第2列减去0，第3列减去0，第4列减去5。

![](https://img-blog.csdn.net/20161213100457345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step3.**利用最少的水平线或垂直线覆盖所有的0。

![](https://img-blog.csdn.net/20161213100901711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step4.**由于水平线和垂直线的总数是3，少于4，进入Step5。

**Step5.**没有被覆盖的最小值是5，没有被覆盖的每行减去最小值5，被覆盖的每列加上最小值5，然后跳转到步骤3.

![](https://img-blog.csdn.net/20161213100919535?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step3.**利用最少的水平线或垂直线覆盖所有的0。

![](https://img-blog.csdn.net/20161213100929477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step4.**由于水平线和垂直线的总数是3，少于4，进入Step5。

**Step5.**没有被覆盖的最小值是20，没有被覆盖的每行减去最小值20，被覆盖的每列加上最小值20，然后跳转到步骤3.

![](https://img-blog.csdn.net/20161213100938602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step3.**利用最少的水平线或垂直线覆盖所有的0。

![](https://img-blog.csdn.net/20161213100949071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**Step4.**由于水平线和垂直线的总数是4，算法结束，分配结果如下图所示。

![](https://img-blog.csdn.net/20161213100958676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

其中，黄色框表示分配结果，左边矩阵的最优分配等价于左边矩阵的最优分配。






