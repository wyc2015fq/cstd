# osea/ 5.0-6.0 - 工作笔记 - CSDN博客





2012年01月17日 14:19:12[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5404








Adapting Beat Detection and Classification for Different Sample Rates

 调整心拍检测和分类适应不同采样率



As of release 1.2, two #define statements allow the beat detection and beat classification functions to be changed to accommodate different sample rates. The SAMPLE_RATE constant defined in qrsdet.h specifies the base sample rate for the software. This is
 the rate at which data should be passed to QRSDet or BeatDetectAndClassify. The BEAT_SAMPLE_RATE constant defined in bdac.h specifies the sample rate for the beat templates used for beat classification.

从版本1.2 开始，两个#define 声明 允许拍检测和分类函数适应不同的采样率。SAMPLE_RATE常量在qrsdet.h中定义 指定软件用的基本采样率。数据以这个速率传递给 QRSDet 或 BeatDetectAndClassify。bdac.h中定义的常量BEAT_SAMPLE_RATE 指定用于心拍分类的心拍模板采样率。



In our original implementation, the base sample rate was set to 200 samples-per-second and the beat sample rate was set to 100 samples-per-second. Comparing beats at a lower temporal resolution reduced the processing time required for classification without
 significantly changing the classification performance. We down sampled beats before classifying them by averaging pairs of beat samples. Down sampling is taken care of by the function DownSampleBeat in bdac.cpp.

在原来的实现里，基本采样率为200 sps ，心拍采样率100sps。以低的时间分辨率来比较模板 减少分类需要的处理时间，不显著改变分类性能。通过平均心拍样本点对在分类之前对心拍进行抽样。下采样由bdac.cpp 中DownSampleBeat 函数完成。



If you wished, for example, to run the beat detection at 250 samples-per-second and the beat classification at 125 samples per second, you would change SAMPLE_RATE to 250 and BEAT_SAMPLE_RATE to 125. Because the beat sample rate is half the base sample rate,
 DownSampleBeat would not need to be changed. If, on the other hand, you wanted to run the beat detector at 1000 samples-per-second because that was the base sample rate for your system, but you still wanted to classify beats using 100 samples-per-second beat
 templates, you would have to change SAMPLE_RATE to 1000, leave BEAT_SAMPLE_RATE at 100, and modifiy DownSampleBeat to average 10 consecutive samples of the input beat to produce a single sample of the output beat.

举个例子，如果你愿意运行拍检测程序 用 250 sps速率 及心拍分类用125sps，你可以将SAMPLE_RATE 改成250，BEAT_SAMPLE_RATE改成125。由于心拍采样率是基本采样率的一半，不需要改DownSampleBeat函数。另一方面，如果你想 以1000sps速率运行心拍检测程序，因为那是你的系统的基本采样率，但是你仍想利用100 sps 的心拍模板来分类心拍，你必须将SAMPLE_RATE 改为1000，BEAT_SAMPLE_RATE 保持100不变，修改DownSampleBeat 
 使输入心拍10个连续采样点平均产生输出心拍的一个采样点。



5.1 Performance at Different Sample Rates  ----------------用不同采样率的性能



We have designed the software so that all filter lengths and time related constants scale with sample rate changes so that the constants and filter lengths are equivalent to the constants and filter lengths in the original 200/100 samples-per-second implementation.


我们已经设计这个软件 使得 所有滤波器 长度和 与时间有关的常数 随着采样率变化而伸缩，于是常数 和 滤波器长度 等效于 在原始的200/100 sps 实现中的常数和滤波器长度。



Ideally, implementations at other sample rates would perform the same as the 200/100 samples-per-second implementation, but round off approximations in constants and filter lengths result in slight differences in performance. Table 1 lists the sensitivities
 and positive predictivities for beat detection and beat classification on the MIT/BIH database and the AHA database (through 7210) for three combinations of base rate and beat rate. Table 2 lists the sensitivities and positive predictivities for beat detection
 alone on a wider range of sample rates. Performance differences only seem significant when the base sample rate is dropped as low as 100 or 125 SPS.

 理想情况下，在其它采样率 的实现 应该与 200/100sps 实现 有相同的表现，但是四舍五入的近似常数和滤波器长度 导致性能上的轻微不同。表1 列举了 在MIT/BIH数据库和AHA数据库（直到7210）上拍检测和拍分类 对三种基本速率和心拍速率组合的 敏感度和正预测率。表2  仅列举了心拍检测在更大范围采样率下的敏感度和正预测率。性能差异仅当基本采样率下降到 100 或125 sps 时 才看起来明显。



5.1 Optimization at Different Sample Rates -----------不同采样率下的优化



In generalizing the QRS detection filters in qrsfilt.cpp, we substituted division operations for some operations that had been implemented as shifts. In a processor with limited power, this will slow the execution of the filter functions. In lpfilt, the division
 in:

为一般化 文件qrsfilt.cpp 中的QRS检测滤波，我们用除法运算替代了一些曾用移位实现的运算。在一个处理能力有限的处理器上，这将减慢滤波函数执行速度。在lpfilt中，除法公式：



output = y0 / ((LPBUFFER_LGTH*LPBUFFER_LGTH)/4);



only serves to scale the filter output, substituting the shift operation that provides the closest approximation to this operation will speed the operation up without a significant change in performance. Similarly, in hpfilt the operation:

仅用来规范滤波输出，用最为接近的移位运算替代这个运算将提高运算速度，性能上没有明显变化。类似地，hpfilt 中的运算：



z = data[halfPtr] - (y / HPBUFFER_LGTH);



can be speeded up by choosing HPBUFFER_LGTH to be the closest power of 2 to the optimal buffer length. This would allow the division to be implemented with a shift operation.

能够通过选取 HPBUFFER_LGTH 为最接近的2 的幂优化缓冲长度 来提高运算速度。这将允许除法用移位运算来实现。



The algorithm may be tuned for better performance with different base frequencies by experimenting with different values for the many constants used in classification. At a given base frequency, there may be constant values and filter lengths that were not
 possible to use with a base sampling frequency of 200 samples-per-second, but it is hard to say whether this type of tuning actually represents an improvement in the algorithm performance.

 使用不同的基频，通过试验 将不同的值赋给在分类中使用的许多常量，算法有可能在调整后获得更好的性能。



6.0 Easytest & Bxb         -----------测试和统计函数



We have included the source code for two applications that we have used to test our beat detection and classification software, easytest.cpp and bxb.cpp.

源码中包含两个应用程序easytest.cpp 和bxb.cpp，用来测试拍检测和分类。



Easytest uses the beat detection and classification functions to analyze records from either the MIT/BIH database or the AHA database and creates an annotation record for each file containing the beat detections and classifications for that record. The annotation
 files produced by easytest have the extension “.ate” (atest) and are copied into the same directory as the database files.

Easytest 使用拍检测和分类函数来分析MIT/BIH 或 AHA 数据库中记录，并为每个文件创建一个注释记录，包含那个记录心拍检测和分类的结果。 easytest 生成的注释文件有扩展名“.ate”（atest）并被拷贝到数据库文件所在目录。



Bxb.cpp is a modified version of the bxb.c distributed as a utility application with the WFDB library on physionet.org. The original bxb.c uses a command line interface and compares beat-by-beat annotations in two annotation files. Our version of bxb does not
 take any input and compares “.ate” (generated by easytest) and “.atr” annotation files for all records in the MIT/BIH database or 35 minute files through 7210 in the AHA database.

Bxb.cpp 是网站physionet.org 上 随着WFDB库发布的一个实用的应用程序bxb.c 的改版。 原始的bxb.c 使用命令行接口 并逐拍比较两个注释文件中的标注。我们的bxb版本没有任何输入， 并比较MIT/BIH数据库或者AHA数据库（35分钟，截止到7210）中 所用记录的“.ate”（easytest 生成的）和“.atr”注释文件。



Bxb creates two output files, adstat.txt and testrpt.txt. Adstat.txt contains a summary listing of the results for each file in the format:

Bxb 创建两个输出文件，adstat.txt 和 testrpt.txt，adstat.txt 包含一个分析结果的汇总表， 对每个文件用下面格式：



<record> <QRS TP> <QRS FN> <QRS FP> <PVC TP> <PVC FN> <PVC FP>



testrpt.txt contains a more detailed record of the types of detection errors for each record.

testrpt.txt 包含一个更为详细的 对每个记录检测错误类型的 记录。



Easytest requires the following files to be compiled and linked together:

easytest 需要下面的文件进行编译连接：



Easytest.cpp

Bdac.cpp

Classify.cpp

Rytmchk.cpp

Noisechk.cpp

Match.cpp

Postclas.cpp

Analbeat.cpp

Qrsfilt.cpp

Qrsdet.cpp

Wflib.lib



Wflib.lib is a library of functions for accessing the database files. I used Turbo C++ to compile this library from the WFDB source code available on
[www.physionet.org](http://www.physionet.org/). You may wish to compile your own WFDB library from more recent versions of the source code. Bxb only requires the files bxb.cpp and wflib.lib.

Wflib.lib是一个用来访问数据库文件的函数库。我使用Turbo C++ 编译 从网站[www.physionet.org](http://www.physionet.org/) 上获得的WFDB源码 得到这个库。你可能愿意从更新版本的源码编译你自己的WFDB 库。bxb 仅需要文件bxb.cpp 和wflib.lib。



Both easytest and bxb were written to run on a PC under windows and look for MIT/BIH database files in the directory “c:\mitdb\”. Easytest and bxb look for AHA database files in the directory “c:\AHA Database\.”


easytest 和bxb 是运行在windows PC 上的代码，在目录“c:\mitdb\”. 下查找MIT/BIH 数据库文件，在“c:\AHA Database\”中查找AHA数据库文件。



You may either create these directories and copy the database files into them, or you can change the define statements at the top of easytest and bxb to the names the directories containing database files on your system.


你可以创建这些目录并将数据库文件拷贝进去，或者将easytest 和bxb 顶部的define 声明 改成你系统上包含数据库文件的路径名。



Note that the directory names in the define statement need double backslashes because they are C strings, and the “c:\AHA Database\” directory is represented as “c:\\AHAdat~1\\” because of the way windows represents directory names containing spaces and
 more than eight characters.

注意到define 声明中的目录名需要双反斜杠，因为它们是C 字符串，并且 “c:\AHA Database\”要表示成“c:\\AHAdat~1\\”，这是因为windows 表示包含空格的目录名的方式 并且它超过了 8个字符。



Easytest and bxb are configured to analyze the MIT/BIH data. If you comment out the line:

Easytest 和bxb 被默认配置成分析MIT/BIH 数据。如果你注释掉下面easytest 和 bxb 中一行：



#define MITDB



in easytest and bxb and recompile, easytest and bxb will analyze the AHA data.

 并且重新编译，easytest 和 bxb 将分析AHA 数据。（--------------实际上，现在需要修改input.h 中的define声明）





**如何获得附件中的测试结果？**



1.  打开Cygwin 终端；

2.  进入osea20-gcc 目录；

3. 修改input.h 中关于数据库的配置：

           保留声明   #define MITDB 

           修改路径  #define ECG_DB_PATH ". /home/username/MIT-BIH"

4.  输入： make 回车

5. 输入： ./easytest

6. 输入： ./bxbep

7. 结果保存在 adtstat.txt 中。



