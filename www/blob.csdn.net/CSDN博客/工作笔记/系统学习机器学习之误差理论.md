# 系统学习机器学习之误差理论 - 工作笔记 - CSDN博客





2016年01月25日 10:07:01[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：8669








**一、偏倚（bias）和方差(variance)**

在讨论线性回归时，我们用一次线性函数![](http://latex.codecogs.com/gif.latex?y=%5Ctheta_0+%5Ctheta_1x)对训练样本进行拟合（如图1所示）；然而，我们可以通过二次多项式函数对训练样本进行拟合（如图2所示），函数对样本的拟合程序看上去更“好”；当我们利用五次多项式函数对样本进行拟合（如图3所示），函数通过了所有样本，成为了一次“完美”的拟合。


![](https://img-blog.csdn.net/20150109220951904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150109220954656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150109221115006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





图3建立的模型，在训练集中通过x可以很好的预测y，然而，我们却不能预期该模型能够很好的预测训练集外的数据。换句话说，这个模型没有很好的泛化能力。因此，模型的泛化**误差(generalization error**)不仅包括其在样本上的期望误差，还包括在训练集上的误差。

图1和图3中的模型都有较大的泛化误差，然而他们的误差原因却不相同。图1建立了一个线性模型，但是该模型并没有精确的捕捉到训练集数据的结构，我们称图1有较大的**偏倚（bias）**，也称欠拟合；图3通过5次多项式函数很好的对样本进行了拟合，然而，如果将建立的模型进行泛化，并不能很好的对训练集之外数据进行预测，我们称图3有较大的，也称过拟合。

通常，在偏倚和方差之间，这样一种规律：如果模型过于简单，其具有大的偏倚，而如果模型过于复杂，它就有大的方差。调整模型的复杂度，建立适当的误差模型，就变得极其重要了。




**二、预备知识**

首先我们先介绍两个非常有用的引理：

**引理1：一致限（the union bound）**令![](http://latex.codecogs.com/gif.latex?A_1,A_2,...,A_k)为k个不同的事件（不一定相互独立），那么有：

![](http://latex.codecogs.com/gif.latex?P(A_1%5Ccup&space;...%5Ccup&space;A_k)%5Cle&space;P(A_1)+...+P(A_k))




一致限说明：k个事件中任一个事件发生的概率小于等于这k个事件发生的概率和（等号成立的条件为这k个事件相两两互斥）。

**引理2：Hoeffding 不等式（Hoeffding inequality）**令![](http://latex.codecogs.com/gif.latex?Z_1,...,Z_m)为m个独立同分布的随机变量，由参数为
 的伯努利分布（即![](http://latex.codecogs.com/gif.latex?P(Z_i=1)=%5Cphi,P(Z_i=0)=1-%5Cphi)）生成。令![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cphi%7D=%5Cfrac%7B1%7D%7Bm%7D%5Cunderset%7Bi=1%7D%7B%5Coverset%7Bm%7D%7B%5Csum%7D%7DZ_%7Bi%7D)，为这些随机变量的均值，对于任意![](http://latex.codecogs.com/gif.latex?%5Cgamma)有：

![](http://latex.codecogs.com/gif.latex?P(%7C%5Cphi-%5Chat%7B%5Cphi%7D%7C)


![](http://latex.codecogs.com/gif.latex?P(%7C%5Cphi-%5Chat%7B%5Cphi%7D%7C%5Cle%5Cgamma))


在机器学习中，引理2称为**Chernoff边界（Chernoff bound）**,它说明：假设我们用随机变量的均值![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cphi%7D)去估计参数![](http://latex.codecogs.com/gif.latex?%5Cphi)，估计的参数和实际参数的差超过一个特定数值的概率有一确定的上界，并且随着样本量m的增大，![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cphi%7D)与![](http://latex.codecogs.com/gif.latex?%5Cphi)很接近的概率也越来越大。


通过以上两个引理，我们能够引出机器学习中很重要结论。
为简单起见，我们只讨论二分类问题，即类标签为 ![](http://latex.codecogs.com/gif.latex?y%5Cin%5C%7B0,1%5C%7D)。


假设给定的训练集为![](http://latex.codecogs.com/gif.latex?S=%5C%7B(x%5E%7B(i)%7D,y%5E%7B(i)%7D);i=1,...,m%5C%7D)，且各训练样本![](http://latex.codecogs.com/gif.latex?(x%5E%7B(i)%7D,y%5E%7B(i)%7D))独立同分布，皆为某个特定分布D生成。对于一个**假设函数（hypothesis）**，定义训**练误差（training error）**（也称为经验风险（empirical risk）或经验误差(empiriacal error)）为：


![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D(h)=%5Cfrac%7B1%7D%7Bm%7D%5Cunderset%7Bi=1%7D%7B%5Coverset%7Bm%7D%7B%5Csum%7D%7D%5C&hash;%5C%7Bh(x%5E%7B(i)%7D)%5Cneq&space;y%5E%7B(i)%7D%5C%7D)


训练误差为模型在训练样本中的错分类的比例，如果我们要强调![](http://latex.codecogs.com/gif.latex?%5Chat&space;%7B%5Cvarepsilon%7D(h))是依赖训练集的，也可以将其写作![](http://latex.codecogs.com/gif.latex?%5Chat&space;%7B%5Cvarepsilon%7D_S&space;(h))。


我们再定义泛化**误差（generalization error）**：


![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(h)=P_%7B(x,y)%5Csim&space;D%7D(h(x)%5Cneq&space;y))




这里得到的是一个概率，表示通过特定的分布D生成的样本（x，y）中的y与通过预测函数h(x)生成的结果不同的概率。



注意，我们假设训练集的数据是通过某种分布D生成的，我们以此为依据来衡量假设函数。这里的假设有时称为PAC(probablyapproximately correct)假设。

在线性分类中，假设函数![](http://latex.codecogs.com/gif.latex?h_%7B%5Ctheta%7D(x)=1%5C%7B%5Ctheta%5E%7BT%7Dx%5Cge0%5C%7D)中参数![](http://latex.codecogs.com/gif.latex?%5Ctheta)如何得来？其中一个方法就是调整参数![](http://latex.codecogs.com/gif.latex?%5Ctheta)，使得训练误差最小，即：

![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Ctheta%7D=arg%5C;%5Cunderset%7B%5Ctheta%7D%7Bmin%7D%5C;%5Chat%7B%5Cvarepsilon%7D(h_%7B%5Ctheta%7D))


我们称这样的方法为**经验风险最小化（empirical risk mininmization，ERM）**，其中![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D=h_%7B%5Chat%7B%5Ctheta%7D%7D)
 ，基于ERM原则的算法可视作最基本的学习算法。线性回归和logistic回归都可以看作是遵守ERM的算法。




我们定义假设类集合![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)（hypothesis class）为所有假设函数的集合。例如线性分类问题中，![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H&space;=%5C%7Bh_%7B%5Ctheta%7D:h_%7B%5Ctheta%7D=1,%5Ctheta%5E%7BT%7Dx%5Cge0,%5Ctheta%5Cin&space;%5Cmathbb&space;R%5E%7Bn+1%7D%5C%7D)，其为所有的![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;X)（输入的定义域），对应的线性决策边界。



因此，ERM也可以认为是一组分类器的集合中，使得训练误差最小的那个分类器，即：

![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D=arg%5C;%5Cunderset%7Bh%5Cin%5Cmathcal&space;H%7D%7Bmin%7D%5C;%5Chat%7B%5Cvarepsilon%7D(h))



3.**有穷集![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)**



我们定义假设类集合![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H=%5C%7Bh_1,...,h_k%5C%7D)由k个假设类(hypotheses)构成。其中，![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)为k个由![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;X)至{0,1}的映射函数构成，ERM从集合中k个元素选择![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D)使得训练误差最小。
为了确保![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D)和泛化误差的差值是有上界的，即如果训练误差很小，那么泛化误差也不会太大，我们需要完成两个步骤：首先，证明对于任意h，![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D&space;(h))是对![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(h))的可靠估计；其次，证明![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(%5Chat%7Bh%7D))存在上界。

我们令![](http://latex.codecogs.com/gif.latex?h_%7Bi%7D%5Cin&space;%5Cmathcal&space;H)，随机变量Z服从伯努利分布，样本由分布![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;D)生成：即：![](http://latex.codecogs.com/gif.latex?(x,y)%5Csim&space;%5Cmathcal&space;D)。并且定义：![](http://latex.codecogs.com/gif.latex?Z=1%5C;if%5C%7Bh_i(x)%5Cneq&space;y%5C%7D)，即Z为指示变量，用来标记被假设函数![](http://latex.codecogs.com/gif.latex?h_i(x))错误分类的样本。

泛化误差![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(h))定义为随机变量Z的期望，训练误差![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D&space;(h_i))为训练样本被假设函数误分类的比例，即：[](http://www.codecogs.com/eqnedit.php?latex=%5Chat%7B%5Cvarepsilon%7D&space;(h_i))

![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D&space;(h_i)=%5Cfrac%7B1%7D%7Bm%7D%5Cunderset%7Bj=1%7D%7B%5Coverset%7Bm%7D%7B%5Csum%7D%7DZ_j=%5Cfrac%7B1%7D%7Bm%7D%5Cunderset%7Bi=1%7D%7B%5Coverset%7Bm%7D%7B%5Csum%7D%7D%5C&hash;%5C%7Bh_%7Bj%7D(x%5E%7B(i)%7D)%5Cneq&space;y%5E%7B(i)%7D%5C%7D)




利用Hoeffding不等式，可以得到：

![](http://latex.codecogs.com/gif.latex?P(&space;%7C%5Cvarepsilon(h_i)-%5Chat%7B%5Cvarepsilon%7D(h_i)%7C)

从上式可以看出，对于特定的的![](http://latex.codecogs.com/gif.latex?h_i)，当m很大时，训练误差和泛化误差很接近的概率很大。但是，我们不仅仅需要考察对于特定的
 ，训练误差和泛化误差的接近程度，而是需要验证对于所有的![](http://latex.codecogs.com/gif.latex?h%5Cin&space;%5Cmathcal&space;H)不等式也成立。


现令![](http://latex.codecogs.com/gif.latex?A_i)代表事件![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h_i)-%5Chat%7B%5Cvarepsilon%7D(h_i)%7C)，对于任意![](http://latex.codecogs.com/gif.latex?A_i)，存在![](http://latex.codecogs.com/gif.latex?P(A_i)%5Cle2exp(-2%5Cgamma%5E2m))，因此，由引理1可得：


![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Baligned%7DP(%5Cexists&space;h%5Cin%5Cmathcal&space;H.%7C%5Cvarepsilon(h_i)-%5Chat%7B%5Cvarepsilon%7D(h_i)%7C)




也可以得到他的等价式：

![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Baligned%7DP(%5Cneg&space;%5Cexists&space;h%5Cin%5Cmathcal&space;H&space;.&space;%5Cleft%7C%5Cvarepsilon(h_i)-%5Chat%7B%5Cvarepsilon%7D(h_i)%5Cright%7C)



上式表示了假设集![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)内任意假设函数的训练误差和泛化误差的的接近程度小于一个常数![](http://latex.codecogs.com/gif.latex?%5Cgamma)的概率有下界，并且随着样本量的增加，训练误差接近泛化误差的概率随之增大。上式的结果称为一致收敛。下面以此不等式引出个推论：

**样本量下界：**

以上的不等式有三个元素：样本量m，误差阈值![](http://latex.codecogs.com/gif.latex?%5Cgamma)和概率，通过任意两个元素，可以确定第三个元素。例如，我们可以关心下列问题：如果给定![](http://latex.codecogs.com/gif.latex?%5Cgamma)和![](http://latex.codecogs.com/gif.latex?%5Cdelta)，我们需要多大的样本量才能保证训练误差和泛化误差相差不超过![](http://latex.codecogs.com/gif.latex?%5Cgamma)的概率最小为![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)？令![](http://latex.codecogs.com/gif.latex?%5Cdelta&space;=2k%5C,exp(-2%5Cgamma%5E2m))可以解出m：




![](http://latex.codecogs.com/gif.latex?m%5Cge&space;%5Cfrac%7B1%7D%7B2%5Cgamma%5E2%7Dlog%5Cfrac%7B2k%7D%7B%5Cdelta%7D)

上面的不等式确定了一个m的下界，该下界称为算法的**样本复杂度（algorithm’s sample complex）**，也就是说，如果我们想通过样本对总体有个较为准确的估计，我们需要采集最小的样本量是多少。
**误差界限：**


如果我们固定m和![](http://latex.codecogs.com/gif.latex?%5Cdelta)的值，求解![](http://latex.codecogs.com/gif.latex?%5Cgamma)，可以得到：


![](http://latex.codecogs.com/gif.latex?%5Cgamma=%7C%5Chat%7B%5Cvarepsilon%7D(h)-%5Cvarepsilon(h)%7C%5Cle%5Csqrt%7B%5Cfrac%7B1%7D%7B2m%7Dlog%5Cfrac%7B2k%7D%7B%5Cdelta%7D%7D)


假设一致收敛成立，那么对于所有![](http://latex.codecogs.com/gif.latex?h%5Cin%5Cmathcal&space;H)，有![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h)-%5Chat%7B%5Cvarepsilon%7D(h)%7C%5Cle&space;%5Cgamma)，那么，可以得到样本泛化误差和总体泛化误差的距离：


令![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D=arg%5C,min_%7Bh%5Cin&space;%5Cmathcal&space;H%7D%5Chat%7B%5Cvarepsilon%7D&space;(h)) ，![](http://latex.codecogs.com/gif.latex?h%5E*=arg%5C,min_%7Bh%5Cin%5Cmathcal&space;H%7D%5Cvarepsilon&space;(h))，即h*表示在集合![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)中使得泛化误差最小的那个假设函数。那么有：


![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D&space;%5Cvarepsilon(%5Chat%7Bh%7D)&%5Cle%5Chat%7B%5Cvarepsilon%7D(%5Chat%7Bh%7D)+%5Cgamma%5C%5C&%5Cle&space;%5Chat%7B%5Cvarepsilon%7D(h%5E*)+%5Cgamma%5C%5C&%5Cle%5Cvarepsilon(h%5E*)+2%5Cgamma&space;%5Cend%7Baligned%7D)


上式第一行不等式依据的是![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h)-%5Chat%7B%5Cvarepsilon%7D(h)%7C%5Cle&space;%5Cgamma)和![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D(%5Chat%7Bh%7D)%5Cle&space;%5Chat%7B%5Cvarepsilon%7D(h))，不等式第二行是由![](http://latex.codecogs.com/gif.latex?%5Chat%7B%5Cvarepsilon%7D(%5Chat%7Bh%7D))是对样本最小的误差的假设函数，因此小于
 ，第三行是根据不等式![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h)-%5Chat%7B%5Cvarepsilon%7D(h)%7C%5Cle&space;%5Cgamma)。从不等式可以看出，对于![](http://latex.codecogs.com/gif.latex?%5Chat%7Bh%7D)（即利用训练集得到的假设函数）的泛化误差在任何情况下也不会比最理想的泛化误差多![](http://latex.codecogs.com/gif.latex?2%5Cgamma)。结合前面的结论，我们可以得到定理1：


定理1：令![](http://latex.codecogs.com/gif.latex?%7C%5Cmathcal&space;H%7C=k)，且m和![](http://latex.codecogs.com/gif.latex?%5Cdelta)值固定，在误差小于一个阈值的概率为至少为![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)的情形下，有：


![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(%5Chat%7Bh%7D)%5Cle(%5Cunderset%7Bh%5Cin%5Cmathcal&space;H%7D%7Bmin%7D%5Cvarepsilon(h))+2%5Csqrt%7B%5Cfrac%7B1%7D%7B2m%7Dlog%5Cfrac%7B2k%7D%7B%5Cdelta%7D%7D)


定理1给出了一个很重要的结论：如果我们扩充假设类集合的范围，即由原来的假设类![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)扩充为![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H')即![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H&space;%5Csubseteq&space;%5Cmathcal&space;H')，则上式第一项（可以非正式的视其为偏差）的值会变小，因为扩充假设类集，可能有更好的假设函数使得最小泛化误差下降；第二项（可以非正式的视其为方差）的值会增大，因为k的值增加了。因此，如果假设类过小，则第一项过大，会造成欠拟合，通过扩充假设类![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)，可以使得第一项的值下降，但是第二项值上升，如果扩充过大，会造成过拟合，同样会增加泛化误差。因此要想得到最小的泛化误差，需要在选择合适的![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)，即在方差和偏差之间进行权衡。


![](https://img-blog.csdn.net/20150110162649578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


假如固定![](http://latex.codecogs.com/gif.latex?%5Cgamma)和![](http://latex.codecogs.com/gif.latex?%5Cdelta)，去求解m，我们可以得到一条关于样本复杂度的推论：


推论1：令![](http://latex.codecogs.com/gif.latex?%7C%5Cmathcal&space;H%7C=k)，![](http://latex.codecogs.com/gif.latex?%5Cgamma)和![](http://latex.codecogs.com/gif.latex?%5Cdelta)为定值，再令![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(%5Chat%7Bh%7D)%5Cle&space;min_%7Bh%5Cin&space;%5Cmathcal&space;H%7D%5Cvarepsilon(h)+2%5Cgamma)的概率不低于![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)，那么样本量需满足：

![](http://latex.codecogs.com/gif.latex?m%5Cge&space;%5Cfrac%7B1%7D%7B2%5Cgamma%5E2%7Dlog%5Cfrac%7B2k%7D%7B%5Cdelta%7D=O(%5Cfrac%7B1%7D%7B%5Cgamma%5E2%7Dlog%5Cfrac%7Bk%7D%7B%5Cdelta%7D))




4.**无穷集 **

前一节我们介绍了在假设类集合是有穷集的情况下泛化误差、训练误差和样本量之间的关系。然而，存在很多以实数为参数的模型，假设类集合中元素数量是无穷的（如线性分类问题）。我们将如何处理？

下面以线性分类为例，假设分类的决策边界由线性函数表示，且该线性函数有d个实数参数。如果我们用计算机表示这些实数，根据IEEE双精度浮点数的标准，用64位二进制表示一个实数，那么，这d个实数需要用64d个2进制位表示，因此，这里假设类集合最多由![](http://latex.codecogs.com/gif.latex?k=2%5E%7B64d%7D)个元素构成。由推论1可得，如果需要保证![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(%5Chat%7Bh%7D)%5Cle&space;%5Cvarepsilon(h%5E*)+2%5Cgamma)的概率不小于![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)，需满足![](http://latex.codecogs.com/gif.latex?m%5Cle&space;O(%5Cfrac%7B1%7D%7B%5Cgamma%5E2%7Dlog%5Cfrac%7B2%5E%7B64d%7D%7D%7B%5Cdelta%7D)=O(%5Cfrac%7Bd%7D%7B%5Cgamma%5E2%7Dlog%5Cfrac%7B1%7D%7B%5Cdelta%7D)=O_%7B%5Cgamma,%5Cdelta%7D(d))，因此可以看出，训练样本量和模型参数数量为线性关系。事实上，依赖64位浮点数无法得出准确的参数，然而，
 如果我们尝试去最小化训练误差，也会得出理想的假设函数。


前文的结论是依赖于![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)的参数设置。如在线性分类器中![](http://latex.codecogs.com/gif.latex?h_%5Ctheta=1%5C%7B%5Ctheta_0+%5Ctheta_1x_1+...+%5Ctheta_nx_n%5C%7D)
 ，此处有n+1个参数。如果这样定义分类器：![](http://latex.codecogs.com/gif.latex?h_%7Bu,v%7D&space;=1%5C%7B(u_0%5E2-v_0%5E2)+(u_1%5E2-v_1%5E2)x_1+...+(u_n%5E2-v_n%5E2)x_n%5C%7D)，此时有2n+2个参数，但是这二者定义了相同的![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)：在n维空间的线性分类器。


最后通过引入VC维的概念，将误差理论推广到更加一般的情形：



**VC维**

给定一个集合；![](http://latex.codecogs.com/gif.latex?S=%5C%7Bx%5E%7B(1)%7D,...,x%5E%7B(d)%7D%5C%7D)，![](http://latex.codecogs.com/gif.latex?x%5E%7B(i)%7D%5Cin%5Cmathcal&space;X),这d个点可以用![](http://latex.codecogs.com/gif.latex?2%5Ed)种方法正负样本。如果存在![](http://latex.codecogs.com/gif.latex?h%5Cin%5Cmathcal&space;H)可以将这![](http://latex.codecogs.com/gif.latex?2%5Ed)种标记的情况都能够有效分类，我们就称![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)可以**散列**（shatter）S。通过![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)集合中的某个假设函数h，可以对这个点构成的任何情况进行无误差的分类。将一个假设集能够无误差分类的最大的点的数量称为改假设集的VC维，记作![](http://latex.codecogs.com/gif.latex?VC(%5Cmathcal&space;H))。

下面举例说明，假设有三个点如下图所示：

![](https://img-blog.csdn.net/20150110164533884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




这三个样本点有23=8种分类可能，如果使用线性分类器对其进行分类，可以得到“零训练误差”，如下图所示：

![](https://img-blog.csdn.net/20150110164941784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165023498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165022062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165041312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20150110165339544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165338453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165417202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20150110165417515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


然而，线性分类器最多对3个点构成的所有可能分类情况进行无误差分类。如果超过3个点线性分类器将无法进行分类。如下图所示：

![](https://img-blog.csdn.net/20150110165518713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlua2luMTAwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


这里的结论可能很悲观，线性分类器在二维平面上至多只能给3个点进行无误差的分类。（更一般的，k维线性分类器最多只能给k+1个点进行无误差分类。）然而，实际的应用中，并不需要构建一个模型使得对于训练集进行无误差的分类，甚至分类过于精确，会使得模型的泛化能力变得很弱，因此VC维仅仅是保证理论的严密，以及可以相关证明的前提条件，并不能完全做为分类算法准确程度的度量。

最后，介绍两个重要的定理：


**定理2：**令![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)为给定的假设集，且![](http://latex.codecogs.com/gif.latex?d=VC(%5Cmathcal&space;H))，在概率不小于![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)的情况下，对于任意![](http://latex.codecogs.com/gif.latex?h%5Cin%5Cmathcal&space;H)，有：

![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h)-%5Chat%7B%5Cvarepsilon%7D(h)%7C%5Cle&space;O(%5Csqrt%7B%5Cfrac%7Bd%7D%7Bm%7Dlog%5Cfrac%7Bm%7D%7Bd%7D+%5Cfrac%7B1%7D%7Bm%7Dlog%5Cfrac%7B1%7D%7B%5Cdelta%7D%7D&space;))




同样有

![](http://latex.codecogs.com/gif.latex?%5Cvarepsilon(%5Chat%7Bh%7D)%5Cle%5Cvarepsilon(h%5E*)+O(%5Csqrt%7B%5Cfrac%7Bd%7D%7Bm%7Dlog%5Cfrac%7Bm%7D%7Bd%7D+%5Cfrac%7B1%7D%7Bm%7Dlog%5Cfrac%7B1%7D%7B%5Cdelta%7D%7D&space;))


也就是说，如果一个假设集![](http://latex.codecogs.com/gif.latex?%5Cmathcal&space;H)，VC维是有限的，那么，随着m的增大，任意![](http://latex.codecogs.com/gif.latex?h%5Cin%5Cmathcal&space;H)的训练误差和泛化误差一致收敛。并且有如下推论：


**推论2：**假设![](http://latex.codecogs.com/gif.latex?%7C%5Cvarepsilon(h)-%5Chat%7B%5Cvarepsilon%7D(h)%7C%5Cle%5Cgamma)且对于所有![](http://latex.codecogs.com/gif.latex?h%5Cin%5Cmathcal&space;H)要确保其概率不低于![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)，需满足![](http://latex.codecogs.com/gif.latex?m=O_%7B%5Cgamma,%5Cdelta%7D(d))。


推论2的含义是，如果需要确保训练误差和泛化误差的差值在一个给定的范围内，并且发生的概率不低于![](http://latex.codecogs.com/gif.latex?1-%5Cdelta)，需要的样本数量和假设集的VC维大小呈线性相关。


**5.总结**

本文给出了训练误差和泛化误差的一般性定义；并介绍了ERM原则；证明了泛化误差和训练误差间差距、样本量和误差概率之间的关系；最后通过引入VC维，推出了更一般的情况下他们之间的关系。



