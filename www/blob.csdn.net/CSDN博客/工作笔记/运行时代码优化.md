# 运行时代码优化 - 工作笔记 - CSDN博客





2013年09月22日 22:40:58[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5576








理解运行时系统，可以：

1.有助于优化代码，获得最佳效率

2.有助于理解更高级的材料

3.更容易分析出现的问题


1.a.out

它是汇编语言程序输出（assembler output）的缩写形式，实际上，它是链接器生成的结果，而不是汇编器生成的结果，之所以这么命名，是历史原因。因为早期的编程，是不存在链接器的，先把所有源文件连接在一起，然后汇编，汇编产生的结果保存在a.out文件中，但后来增加了链接器后，该习惯还是保留下来了。

2.段

目标文件和可执行文件有几种不同的方式，其中ELF（原意为可扩展链接器格式，现在为可执行文件和链接格式），以及COFF(普通目标文件格式)。。。。

所有这些文件格式具有同一个概念，即段。这里的段是UNIX的段，即数据段，文本段，bss段。就目标文件而言，段是二进制文件中简单的区域，里面保存了和某种特定类型相关的所有信息。术语section是ELF文件中的最小组织单位，一个段一般包含几个section。

3.**操作系统与a.out**

为什么a.out文件要以段形式组织呢？

**段可以方便的映射到链接器在运行时可以直接载入的对象中。载入器只是读取文件中每个段的影像，并直接将其放入内存中**。本质上，段是正在执行的程序中的一块内存区域。其中，文本段包含程序的指令。链接器直接将文本段的指令拷贝到内存中。这些指令不会再改变，有些操作系统和链接器甚至可以向段中不同section赋予适当的属性。例如读写属性等。

![](https://img-blog.csdn.net/20131220131829859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

数据段，则包含经过初始化的全局和静态变量。

BSS段（由符号表开始的块，它是旧式IBM704汇编程序的一个伪指令，UNIX借用了这个名字，至今依然沿用。）只保存没有值的变量，所以事实上它并不需要保存这些变量的映像，运行时所需要的BSS段的大小可以从可执行文件中读取，BSS段并不占据目标文件的任何空间。然后链接器得到这个区域的内存块大小，紧跟在数据段之后，当该内存区域进入程序的地址空间后被全部清零。数据段和BSS段通常称为数据区。一般数据段在所有段中最大。**而堆栈段则用于保存局部变量，临时数据，传递到函数的参数等。另外，还需要堆空间，动态分配空间。**

**注意虚拟地址空间最低部分未映射，也就是说，它位于进程的地址空间，但未赋予物理地址，所以任何对他的引用都是非法的。典型情况下，它是从地址0开始的几K字节，用于捕捉使用空指针和小整型值得指针引用内存的情况。当考虑共享库时，进程的地址空间的样子如图：**

**![](https://img-blog.csdn.net/20131220135048703)**

**运行时系统在a.out里的行为：**

**维护sp指针**

堆栈：

给函数内部声明的局部变量提供存储空间

进行函数调用时，保存进栈出栈的相关寄存器状态信息以及维护性信息。

也可以用做暂时存储区，alloca函数可以在堆栈空间动态分配内存，但该内存在函数调用结束后，被自动释放。

除了递归调用之外，堆栈并非必需。允许递归调用意味着必须找到一种方法，在同一时刻允许局部变量的多个实例存在，但只有最新被创建的那个才能被访问，这很像堆栈的经典定义。

**函数调用时在a.out里的行为：**

**这里描述的是C运行时系统在它自己的地址空间内如何管理程序，事实上，C语言的运行时函数非常少。**

**C语言自动提供的服务之一就是跟踪调用链。**

过程活动记录：

当每个函数被调用时，都会产生一个活动记录，它是一种数据结构，用于支持过程调用，并记录调用结束后返回调用点所需要的全部信息。如下图：

![](https://img-blog.csdn.net/20131220150703890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBwXzEyMDYyMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在不同的编译器中，这些字段的次序可能不相同，而且可能还存在一个在调用函数前保存寄存器值的区域。运行时系统维护一个fp指针，用于提示活动堆栈结构。它的值最靠近堆栈顶部的过程活动记录的地址。

这里所谓的静态链接是指一个指向它的外层函数的活动记录的指针。允许内存过程访问外层函数的活动记录，因此也可以访问外层过程的局部数据。记住，在同一时刻一个外层过程可能有好几个处于活动状态的调用，内存过程记录的静态链接将指向合适的活动记录，以访问局部变量的正确实例。这种类型的访问被称为上层引用。之所以叫静态链接是因为和动态链接相比，后置是一个活动记录指针链。C本上不允许函数嵌套，因此，它的活动记录中没有静态链接。下图举例说明动态控制流：

代码：

a(int i)

{

if (i > 0)

{

a(--i);

}

else

{

printf("i has reached 0!\n");

}

}

main()

{

a(1);

}

![](https://img-blog.csdn.net/20131220152334343)

setjmp和longjmp函数




#include <setjmp.h>

jmp_buf buf;

void banana(void)

{

 printf("In banana();\n");

 longjmp(buf, 1);//回到buf所记录的位置，让它看上去像从原先setjmp()函数返回的一样。但是函数返回1，使代码能够知道它实际是通过longjmp()返回的一样。buf的内容被销毁。

 printf("You will never see this, because i longjmp");

}

main()

{

   if (setjmp(buf)) //setjmp函数首先被调用，它表示使用变量j记录现在的位置，函数返回0.

   {

    printf("back in main\n");

   }

   else

   {

    printf("First time through\n");

    banana();

   }

}

这两个函数都是通过操纵过程活动记录来实现的。它们部分弥补了C语言有限的转移能力。

setjmp函数，setjmp（jmp_buf j）表示使用变量j记录现在的位置，返回0.该函数必须先被调用。

longjmp函数，可以接着调用longjmp(jmp_buf j, int i).表示回到j所记录的位置，让它看上去像是从原先的setjmp函数返回一样。但是函数返回i，让代码能够知道它是实际上是通过longjmp函数返回的。该函数使用后，j的内容被销毁。这种跳转方式与goto不同，区别如下：

1.goto语句不能跳出当前函数。

2.longjmp函数只能调回原来的地方。

需要注意的是：保证在setjmp和longjmp函数之间的局部变量一直保持它的值得唯一可靠方式是volatile。

setjmp和longjmp函数最大的用处是错误恢复。其在C++中变异为catch和throw。

UNIX中的堆栈段，可自动增长，dos中在建立可执行文件时，堆栈的大小必须同时确定，而且它不能在运行时增长。


﻿﻿

﻿﻿

﻿﻿



