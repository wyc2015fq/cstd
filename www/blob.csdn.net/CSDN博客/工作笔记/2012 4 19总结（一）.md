# 2012.4.19总结（一） - 工作笔记 - CSDN博客





2012年04月19日 10:11:33[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5559








**类的赋值函数**

    为了实现链式表达式（或者连锁赋值），我们在设计类的赋值函数时，将其返回一个*this指针的引用。这是实现类的赋值操作符时应该遵循的协议。同时，这个协议，不近适用于标准赋值运算，也适用于所有赋值运算。例如+=，-=，*=等。但它无强制性。

   由于程序员的疏忽，总会间接或者直接倒置自我赋值操作。假设你建立一个class 用来保存一个指针指向一块动态分配的位图(bitmap) :

class Bitmap { ... };

class Widget {

private:

Bitmap* pb; //指针，指向一个从heap 分配而得的对象

下面是operator= 实现代码，表面上看起来合理，但自我赋值出现时并不安全(它也不具备异常安全性〉。

Widget& Widget::operator=(const Widget& rhs)

{

delete pb;

pb = new Bitmap(*rhs.pb);

return *this;

}

当传递的rhs参数，是自己时，delete pb不只销毁了当前pb的bitmap，同时，也销毁了rhs的bitmap。从而发生不安全行为。

防止这种错误的传统方法是，增加证同测试达到自我幅值的检测目的：

Widget& Widget::operator=(const Widget& rhs)

{

if(this == &other) return *this;

delete pb;

pb = new Bitmap(*rhs.pb);

return *this;

}

这样做，虽然能防止自我赋值问题，但是，具有异常安全性问题。

因为，如果"new Bitmap" 导致异常(不论是因为分配时内存不足或因为Bitmap 的copy构造函数抛出异常) , Widget 最终会持有一个指针指向一块被删除的Bitmap 。

幸运的是，让赋值操作符具有异常安全性，能自动解决自我赋值的问题。

widget& Widget::operator=(const Widget& rhs)

{

Bitmap* pOrig = pb;//复制一份

pb = new Bitmap(*rhs.pb);//指向新的地址

delete pOrig;//删除原来的

return *this;

}

然而，我们可以采用copy and swap技术，解决这个问题，实现如下：

class Widget {

void swap(Widget& rhs); II交换*this 和rhs 的数据

};

Widget& Widget::operator=(const Widget& rhs)

{

Widget temp(rhs);

swap (temp);

return *this;

}



