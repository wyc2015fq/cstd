# 2012.4.16总结(四) - 工作笔记 - CSDN博客





2012年04月16日 11:25:01[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5399标签：[编译器																[语言																[constructor																[存储																[reference																[数据结构](https://so.csdn.net/so/search/s.do?q=数据结构&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





**++前缀和后缀运算符**

前缀效率优于后缀运算符，这是因为在运行操作符之前编译器需要建立一个临时的对象，而这还要从函数重载说起。

重载函数间的区别取决于它们在参数类型上的差异，但不论是自增的前缀还是后缀，都只有一个参数。为了解决这个语言问题，C++ 规定后缀形式有一个int 类型的参数，当函数被调用时，编译器传递一个0 作为int 类型参数的值给该函数：

// 成员函数形式的重载

< Type > ClassName :: operator ++ ( ); // 前缀

< Type > ClassName :: operator ++ ( int ); // 后缀

// 非成员函数形式的重载

< Type > operator ++ (ClassName & ); // 前缀

< Type > operator ++(ClassName &,int); // 后缀

在实现中，后缀操作会先构造一个临时对象，并将原对象保存，然后完成自增操作，最后将保存对象原值的临时对象返回。代码如下所示：

ClassName & ClassName::operator++()

{

ClassAdd (1); //increment current object

return *this; //return by reference the current object

}

ClassName ClassName::operator++(int unused)

{

ClassName temp(*this); //copy of the current object

ClassAdd (1); //increment current object

return temp; //return copy

}

由于前缀操作省去了临时对象的构造，因此它在效率上优于后缀操作。不过，在应用到整型和长整型的操作时，前缀和后缀操作在性能上的区别通常是可以忽略的。但对于用

户自定义类型，这还是非常值得注意的。当然就像80-20 规则告诉我们的那样，如果在80-20 规则：一个典型的程序将花去 80% 的时间仅仅运行 20% 的代码。

一个很大的程序里，程序数据结构和算法不够优秀，它所能带来的效率提升也是微不足道的，不能使大局有所改变。但是既然它们有差异，我们为什么不在必要的时候采用更有效率的呢？

请记住：
**对于整型和长整型的操作，前缀操作和后缀操作的性能区别通常是可以忽略的。对于用户自定义类型，优先使用前缀操作符。因为与后缀操作符相比，前缀操作符因为无须构造临时对象而更具性能优势。**





**在定义变量时，要三思而后行，掌握变量定义的时机与位置，在合适的时机于合适的位置上定义变量。尽可能推迟变量的定义，直到不得不需要该变量为止；同时，为了减少变量名污染，提高程序可读性，尽量缩小变量的作用域。**



**typedef 与#define 的不同：typedef 后面是一个整体声明，是不能分割的部分，就像整型变量声明int i;，只不过typedef 声明的是一个别名。宏定义只是简单的字符串替换，不过，typedef 并不是原地扩展，它的新名称具有一定的封装性，更易于定义变量，它可以同时声明指针类型的多个对象，而宏则不能。使用typedef 声明多个指针对象，形式直观，方便省事：char *pa, *pb, *pc, *pd; // 方式1typedef char* PTR_CHAR;PTR_CHAR pa, pb, pc, pd; // 方式2，直观省事除此之外，typedef 还有多种用途，下面来看看。**

**1 在结构体使用过程中，少写声明头部的struct，使用typedef**

**2 用typedef 定义一些与平台无关的类型**

**3 为复杂的声明定义一个简单的别名在typedef 的使用过程中，还必须记住：typedef 在语法上是一个存储类的关键字，类似于auto、extern、mutable、static、register 等，虽然它并不会真正影响对象的存储特性，如：**

**typedef static int INT2; // 不可行，编译将失败编译器会提示“指定了一个以上的存储类型”。请记住：区分typedef 与#define 之间的不同；不要用理解宏的思维方式对待typedef，typedef 声明的新名称具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字。**



**编译器对可变参数函数的原型检查不够严格，所以容易引起问题，难于查错，不利于写出高质量的代码。所以应当尽量避免使用C 语言方式的可变参数设计，而用C++ 中更为安全的方式来完美代替之。**



**隐式转换问题：**

C/C++ 隐式转换主要发生在以下几种情形：

**1. 基本类型之间的隐式转换**

 C 语言规定的转换规则是由低级向高级转换。两个通用的转换原则是：

（1）为防止精度损失，类型总是被提升为较宽的类型。

（2）所有含有小于整型类型的算术表达式在计算之前其类型都会被转换成整型。

这两点在C++ 中依旧有效，这已无须多言。它最直接的害处就是有可能导致重载函数产

生二义性，

**2 T* 指针到 void* 的隐式转换**

在C 语言中，标准允许T* 与void* 之间的双向转换，这也就间接导致了各种数据类型之间的隐式转换是被允许的，无论是从低级到高级，还是从高级到低级。这样的转换存在着

太多的不安全因素，所以到了C++ 中，双向变单向，只允许T* 隐式地转换为void* 了

**3. non-explicit constructor 接受一个参数的用户定义类对象之间隐式转换**

控制隐式转换的两条有效途径：

提防隐式转换所带来的微妙问题，尽量控制隐式转换的发生；通常采用的方式包括：

（1）使用非C/C++ 关键字的具名函数，用operator as_T() 替换operato T()（T 为C++ 数据类型）。

（2）为单参数的构造函数加上explicit 关键字。



**DRY— Don’t Repeat Yourself Principle，直译为“不要重复自己”。简而言之，就是不要写重复的代码。DRY 利用的方法就是抽象：把共同的事物抽象出来，把代码抽取到一个地方去，这样就可以避免重复写代码。**





**void和void*区别**

1. 在C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理，而非void类型

2.void指针是单向赋值，即，可以将任何类型的指针赋给void类型指针，但不能反之赋值。

3 ANSI 中规定，void指针不允许++ --运算。GNU可以。指定void * 的算法操作与char *一致。

实际设计中，还是应该尽可能地迎合ANSI 标准。在实际的程序设计中，为迎合ANSI 标准，并提高程序的可移植性，可以采用以下方式进行代码设计：

void * pVoid;

(char *)pVoid ++; // ANSI：正确；GNU：正确

(char *)pVoid += 2; // ANSI：错误；GNU：正确](https://so.csdn.net/so/search/s.do?q=reference&t=blog)](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=constructor&t=blog)](https://so.csdn.net/so/search/s.do?q=语言&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)




