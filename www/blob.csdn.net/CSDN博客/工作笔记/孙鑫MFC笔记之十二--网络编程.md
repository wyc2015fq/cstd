# 孙鑫MFC笔记之十二--网络编程 - 工作笔记 - CSDN博客





2012年06月25日 12:53:30[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：6468标签：[网络																[mfc																[sockets																[网络应用																[服务器																[windows](https://so.csdn.net/so/search/s.do?q=windows&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





网络状况：


ü多种通信媒介——有线、无线…… 

ü不同种类的设备——通用、专用…… 

ü不同的操作系统——Unix、Windows …… 

ü不同的应用环境——固定、移动…… 

ü不同业务种类——分时、交互、实时…… 

ü宝贵的投资和积累——有形、无形…… 

ü用户业务的延续性——不允许出现大的跌宕起伏。 

**它们互相交织，形成了非常复杂的系统应用环境**




**网络异质性问题的解决**






n网络体系结构 就是使这些用不同媒介连接起来的不同设备和网络系统在不同的应用环境下实现互操作性，并满足各种业务需求的一种粘合剂，它营造了一种“生存空间”——任何厂商的任何产品、以及任何技术只要遵守这个空间的行为规则，就能够在其中生存并发展。

n网络体系结构 解决异质性问题采用的是分层方法——把复杂的网络互联问题划分为若干个较小的、单一的问题，在不同层上予以解决。 

就像我们在编程时把问题分解为很多小的模块来解决一样。 



就是说，通过分层的方式，让任何产品，任何技术，只要遵守这个规则，便可在网络中生存，发展，而不需要考虑通信介质，设备，应用环境等等因素。





n**OSI(Open System Interconnection)参考模型将网络的不同功能划分为7层。**

**各层从上到下，分别为：**

** 1 应用层：处理网络应用。就是面向用户这一块。**

**    所使用协议：远程登录协议Telnet、文件传输协议FTP、 超文本传输协议HTTP、域名服务DNS、简单邮件传输协议SMTP、邮局协议POP3等。**

** 2 表示层：处理被传递数据的表示问题，即信息的语法和语义。即数据表示，如有必要，可采用固定数据格式。**

** 3 会话层：在两个相互通信的应用进程之间建立，组织和协调相互之间的通信。**

** 4 传输层：为源端主机到目的主机提供可靠的数据传输服务，隔离网络的上下协议，使得网络应用与下层协议无关**

**    所使用协议：**

   n传输控制协议TCP、用户数据报协议UDP。 

    TCP：面向连接的可靠的传输协议。 

    UDP：是无连接的，不可靠的传输协议。



** 5  网络层：提供IP地址寻址和路由。负责找出最佳路线。**

**      所使用协议：**

   n网际协议IP、Internet互联网控制报文协议ICMP、Internet组管理协议IGMP。



** 6 数据链路层：提供介质访问，加强物理层的传输功能，建立一条无差错传输线路**

** 7 物理层：提供二进制传输，确定如何传输比特流**



**注意：**



n通信实体的对等层之间不允许直接通信。 

n各层之间是严格单向依赖。 

n上层使用下层提供的服务 — Service user； 

n下层向上层提供服务 — Service provider。







n**对等层实体之间虚拟通信。 **

n**下层向上层提供服务，实际通信在最底层完成。 **





**数据封装**





n**一台计算机要发送数据到另一台计算机，数据首先必须打包，打包的过程称为封装。**

n**封装就是在数据前面加上特定的协议头部。**





n**OSI参考模型中，对等层协议之间交换的信息单元统称为协议数据单元(PDU，Protocol Data Unit)。**

n**OSI参考模型中每一层都要依靠下一层提供的服务。 **

n**为了提供服务，下层把上层的PDU作为本层的数据封装，然后加入本层的头部（和尾部）。头部中含有完成数据传输所需的控制信息。**

n**这样，数据自上而下递交的过程实际上就是不断封装的过程。到达目的地后自下而上递交的过程就是不断拆封的过程。由此可知，在物理线路上传输的数据，其外面实际上被包封了多层“信封”。**

n**但是，某一层只能识别由对等层封装的“信封”，而对于被封装在“信封”内部的数据仅仅是拆封后将其提交给上层，本层不作任何处理。**



**TCP/IP模型**



因为osi参考模型比较复杂，目前主要采用TCP/IP模型

该模型分四层：

应用层：（包含了osi的应用层，表示层，会话层）

传输层：（osi传输层）

网络层：（osi网络层）

网络接口层：（物理层，数据链路层）



端口：





n按照OSI七层模型的描述，传输层提供进程（应用程序）通信的能力。为 了标识通信实体中进行通信的进程（应用程序），TCP/IP协议提出了协议端口（protocol port，简称端口）的概念。

n端口是一种抽象的软件结构（包括一些数据结构和I/O缓冲区）。应用程序通过系统调用与某端口建立连接（binding）后，传输层传给该端口的数据都被相应的进程所接收，相应进程发给传输层的数据都通过该端口输出。

n端口用一个整数型标识符来表示，即端口号。端口号跟协议相关，TCP/IP传输层的两个协议TCP和UDP是完全独立的两个软件模块，因此各自的端口号也相互独立。

n端口使用一个16位的数字来表示，它的范围是0~65535，1024以下的端口号保留给预定义的服务。例如：http使用80端口。



SOCKET



n为了能够方便的开发网络应用软件，由美国伯克利大学在Unix上推出了一种应用程序访问通信协议的操作系统调用socket(套接字)。socket的出现，使程序员可以很方便地访问TCP/IP，从而开发各种网络应用的程序。

n随着Unix的应用推广，套接字在编写网络软件中得到了极大的普及。后来，套接字又被引进了Windows等操作系统，成为开发网络应用程序的非常有效快捷的工具。

n套接字存在于通信区域中。通信区域也叫地址族，它是一个抽象的概念，主要用于将通过套接字通信的进程的共有特性综合在一起。套接字通常只与同一区域的套接字交换数据（也有可能跨区域通信，但这只在执行了某种转换进程后才能实现）。Windows Sockets只支持一个通信区域：网际域( AF_INET)，这个域被使用网际协议簇通信的进程使用。





nTCP/IP协议使用16位整数和32位整数的高位先存格式。



客户机/服务器模式：



n在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户机/服务器模式(client/server)，即客户向服务器提出请求，服务器接收到请求后，提供相应的服务。

n客户机/服务器模式的建立基于以下两点：首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用。其次，网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区，因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户机/服务器模式的TCP/IP。







n客户机/服务器模式在操作过程中采取的是主动请求的方式。 

**首先服务器方要先启动，并根据请求提供相应的服务： **

①打开一个通信通道并告知本地主机，它愿意在某一地址和端口上接收客户请求。 

②等待客户请求到达该端口。 

③接收到重复服务请求，处理该请求并发送应答信号。接收到并发服务请求，要激活一个新的进程(或线程)来处理这个客户请求。新进程(或线程) 处理此客户请求，并不需要对其它请求作出应答。服务完成后，关闭此新进程与客户的通信链路，并终止。

④返回第二步，等待另一客户请求。 

⑤关闭服务器。 

**客户方： **

①打开一个通信通道，并连接到服务器所在主机的特定端口。 

②向服务器发服务请求报文，等待并接收应答；继续提出请求。 

③请求结束后关闭通信通道并终止。 







nWindows Sockets是Microsoft Windows的网络程序设计接口，它是从Berkeley Sockets扩展而来的，以动态链接库的形式提供给我们使用。Windows Sockets在继承了Berkeley Sockets主要特征的基础上，又对它进行了重要扩充。这些扩充主要是提供了一些异步函数，并增加了符合Windows消息驱动特性的网络事件异步选择机制。

nWindows Sockets 1.1和Berkeley Sockets都是基于TCP/IP协议的；Windows Sockets 2从Windows Sockets 1.1发展而来，与协议无关并向下兼容，可以使用任何底层传输协议提供的通信能力，来为上层应用程序完成网络数据通讯，而不关心底层网络链路的通讯情况，真正实现了底层网络通讯对应用程序的透明。



套接字类型：



n流式套接字（SOCK_STREAM） 

提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送，且按发送顺序接收。 

n数据报式套接字（SOCK_DGRAM） 

提供无连接服务。数据包以独立包形式发送，不提供无错保证，数据可能丢失或重复，并且接收顺序混乱。 

n原始套接字（SOCK_RAW）。



基于TCP的socket编程：

1  加载套接字库



int WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData ); 

wVersionRequested参数用于指定准备加载的Winsock库的版本。高位字节指定所需要的Winsock库的副版本，而低位字节则是主版本。可用MAKEWORD(x,y)(其中，x是高位字节，y是低位字节)方便地获得wVersionRequested的正确值。

lpWSAData参数是指向WSADATA结构的指针，WSAStartup用其加载的库版本有关的信息填在这个结构中。 





WSADATA结构定义如下： 

typedef struct WSAData { 

  WORD wVersion; 

  WORD wHighVersion; 

  char szDescription[WSADESCRIPTION_LEN+1]; 

  char szSystemStatus[WSASYS_STATUS_LEN+1]; 

  unsigned short iMaxSockets; 

  unsigned short iMaxUdpDg; 

  char FAR * lpVendorInfo; 

} WSADATA, *LPWSADATA; 

         WSAStartup把第一个字段wVersion设成打算使用的Winsock版本。wHighVersion 参数容纳的是现有的Winsock库的最高版本。

记住，这两个字段中，高位字节代表的是Winsock副版本，而低位字节代表的则是Winsock主版本。

szDescription和szSystemStatus这两个字段由特定的Winsock实施方案设定，事实上没有用。不要使用下面这两个字段：iMaxSockets和iMaxUdpDg，它们是假定同时最多可打开多少套接字和数据报的最大长度。然而，要知道数据报的最大长度应该通过WSAEnumProtocols来查询协议信息。同时最多可打开套接字的数目不是固定的，很大程度上和可用物理内存的多少有关。最后，lpVendorInfo字段是为Winsock实施方案有关的指定厂商信息预留的。任何一个Win32平台上都没有使用这个字段。

          如果WinSock.dll或底层网络子系统没有被正确初始化或没有被找到，WSAStartup将返回WSASYSNOTREADY。此外这个函数允许你的应用程序协商使用某种版本的WinSock规范，如果请求的版本等于或高于DLL所支持的最低版本，WSAData的wVersion成员中将包含你的应用程序应该使用的版本，它是DLL所支持的最高版本与请求版本中较小的那个。反之，如果请求的版本低于DLL所支持的最低版本，WSAStartup将返回WSAVERNOTSUPPORTED。关于WSAStartup更详细的信息，请查阅MSDN中的相关部分。

          对于每一个WSAStartup的成功调用(成功加载WinSock DLL后)，在最后都对应一个WSACleanUp调用，以便释放为该应用程序分配的资源。



2 创建套接字



**SOCKET socket( int ***af***, int ***type***, int***protocol***);**

n该函数接收三个参数。第一个参数*af*指定地址族，对于TCP/IP协议的套接字，它只能是AF_INET(也可写成PF_INET)。第二个参数指定Socket类型，对于1.1版本的Socket，它只支持两种类型的套接字，SOCK_STREAM指定产生流式套接字，SOCK_DGRAM产生数据报套接字。第三个参数是与特定的地址家族相关的协议，如果指定为0，那么它就会根据地址格式和套接字类别，自动为你选择一个合适的协议。这是推荐使用的一种选择协议的方法。

n如果这个函数调用成功，它将返回一个新的SOCKET数据类型的套接字描述符。如果调用失败，这个函数就会返回一个INVALID_SOCKET，错误信息可以通过WSAGetLastError函数返回。



3 绑定套接字



**int bind( SOCKET ***s***, const struct sockaddr FAR****name***, int***namelen***);**

n这个函数接收三个参数。第一个参数*s*指定要绑定的套接字，第二个参数指定了该套接字的本地地址信息，是指向sockaddr结构的指针变量，由于该地址结构是为所有的地址家族准备的，这个结构可能（通常会）随所使用的网络协议不同而不同，所以，要用第三个参数指定该地址结构的长度。 sockaddr结构定义如下：

    struct sockaddr { 

**u_short **sa_family; 

**char** sa_data[14]; 

    }; 

nsockaddr的第一个字段sa_family指定该地址家族，在这里必须设为AF_INET。sa_data仅仅是表示要求一块内存分配区，起到占位的作用，该区域中指定与协议相关的具体地址信息。由于实际要求的只是内存区，所以对于不同的协议家族，用不同的结构来替换sockaddr。除了sa_family外，sockaddr是按网络字节顺序表示的。在TCP/IP中，我们可以用sockaddr_in结构替换sockaddr，以方便我们填写地址信息。





sockaddr_in的定义如下： 

**struct** sockaddr_in{ 

**short** sin_family; 

**unsigned short** sin_port; 

**struct   in_addr** sin_addr; 

**char **sin_zero[8]; 

}; 

              其中，sin_family表示地址族，对于IP地址，sin_family成员将一直是AF_INET。成员sin_port指定的是将要分配给套接字的端口。成员sin_addr给出的是套接字的主机IP地址。而成员sin_zero只是一个填充数，以使sockaddr_in结构和sockaddr结构的长度一样。如果这个函数调用成功，它将返回0。如果调用失败，这个函数就会返回一个SOCKET_ERROR，错误信息可以通过WSAGetLastError函数返回。

             将IP地址指定为INADDR_ANY，允许套接字向任何分配给本地机器的IP地址发送或接收数据。多数情况下，每个机器只有一个IP地址，但有的机器可能会有多个网卡，每个网卡都可以有自己的IP地址，用INADDR_ANY可以简化应用程序的编写。将地址指定为INADDR_ANY，允许一个独立应用接受发自多个接口的回应。如果我们只想让套接字使用多个IP中的一个地址，就必须指定实际地址，要做到这一点，可以用inet_addr()函数，这个函数需要一个字符串作为其参数，该字符串指定了以点分十进制格式表示的IP地址(如192.168.0.16)。而且inet_addr()函数会返回一个适合分配给S_addr的u_long类型的数值。inet_ntoa()函数会完成相反的转换，它接受一个in_addr结构体类型的参数并返回一个以点分十进制格式表示的IP地址字符串。

 4 监听

listen(

    SOCKET s,//套接字

    int backlog//等待连接队列的最大长度，注意，不是说， 能容纳的最大长度。

    ); 



5 死循环

 接受

accept(

    SOCKET s,//套接字

    struct sockaddr FAR * addr,//连接实体的地址

    int FAR * addrlen//地址长度

    );

 6 发送信息

 7 接受信息

 8 关闭套接字



客户端，不需要绑定，。只要进行连接。



基于UDP网络编程



接受函数recvfrom，在服务器程序中，要WSAcleanup。即不需要监听，或者叫建立连接。



应该注意的是：

基于TCP和UDP编写的网络程序，在发送和接受数据时使用的函数不一样，前者使用send和recv，后者使用sendto和recvfrom。](https://so.csdn.net/so/search/s.do?q=服务器&t=blog)](https://so.csdn.net/so/search/s.do?q=网络应用&t=blog)](https://so.csdn.net/so/search/s.do?q=sockets&t=blog)](https://so.csdn.net/so/search/s.do?q=mfc&t=blog)](https://so.csdn.net/so/search/s.do?q=网络&t=blog)




