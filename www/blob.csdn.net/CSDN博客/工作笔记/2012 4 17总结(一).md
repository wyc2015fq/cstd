# 2012.4.17总结(一) - 工作笔记 - CSDN博客





2012年04月17日 08:41:46[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5398标签：[编译器																[class																[processing																[function																[string																[gcc](https://so.csdn.net/so/search/s.do?q=gcc&t=blog)
个人分类：[基础编程](https://blog.csdn.net/App_12062011/article/category/952065)





**1  要区分哪些数据对象是POD，哪些是非POD。由于非POD 对象的存在，在C++ 中使用memcpy() 系列函数时要保持足够的小心。**

对于C，所有数据对象，都是POD，因此不存在非POS对象，可以任意使用memcpy系列函数。

对于C++，由于虚函数支持下的动多态型，使得C++对象有可能不是一个POD,因此实现memcpy系列函数要小心。对非POD对象，不能使用该系列函数。

在使用虚函数时，类的每一次继承都会产生一个虚函数表（vtable），其中存放的是指向虚函数的指针。这些虚函数表必须存放在对象体中，也就是和对象的数据存放在一起。因而，对象数据在内存里并不是以连续的方式存放的，而是被分割成了不同的部分，甚至“身首异处” 。既然对象数据不再集中在一起，如果此时再贸然使用memcpy()、memset() 函数，那么所带来的后果将不可预计。

**2 尽量使用new/delete代替C中的malloc/free。**

**3 注释风格**

                   版权和版本声明，使用C 风格的 /* */

                  内嵌注释用 //

                  宏尾端的注释用/* */

                 默认参数函数的定义。代码片段如下所示：

// 声明文件

class A

{

public:

void Function( int para1, int para2 = 0 );

};

// 实现文件

void A::Function( int para1, int para2 /* = 0*/ )

{

// processing code

}

我们一般将类的声明与实现进行分离，放置在不同的文件之中。此时如果函数存在默认参数，它只能出现在声明中，不过，在实现中缺少默认参数的说明可能会影响我们对函数

的设计或理解，所以有必要在实现中对默认参数进行一些说明。使用C 风格的注释语法按照上述形式进行说明确实是一个值得推荐的方式。在这种情形下，C++ 风格的注释变得无能为力了。

**4 尽量用const、enum、inline 替换#define**

**a 常量宏，用const替代。**

**   当你设计如下代码：**

**   #define ASPECT RATIO 1.653**

**   记号名称ASPECT RATIO 也许从未被编译器看见:也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称ASPECT RATIO 有可能没进入记号表(symbol table) 内。当你运用此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到1.653 而不是ASPECT RATIO 。如果ASPECT RATIO 被定义在→个非你所写的头文件内，你肯定对1.653 以及它来自何处毫无概念，于是你将因为追踪它而浪费时间。这个问题也可能出现在记号式调试器(symbolic debugger) 中，原因相同z 你所使用的名称可能并未进入记号表(symboltable) 。解决之道是以一个常量替换上述的宏(#define) :作为→个语言常量， AspectRatio 肯定会被编译器看到，当然就会进入记号表内。此外对浮点常量(floating point constant，就像本例)而言，使用常量可能比使用#define 导致较小量的码，因为预处理器"盲目地将宏名称ASPECT RATIO 替换为1.653"可能导致目标码(object code) 出现多份1.653 ，若改用常量AspectRa tio绝不会出现相同情况。**

   当我们以常量替换#defines ，有两种特殊情况值得说说。

**b 在头文件中定义常量指针时，是将指针声明为const 了，而不是指针指向的数据。所以，如果定义一个指向常量字符串的常量指针，我们选择的就是最后一种，需要用两个const 进行修饰。然而在定义指向常量字符串的常量指针时，用两个const 修饰并不是我们推荐的形式。我们推荐使用更加安全、更加高级的const string 形式：const string bookName("150 C++ Tips");注意：**

**c**常量数据成员的主要目的就是为了将常量的作用域限制在一个特定的类里，为了让限制常量最多只有一份，还必须将该常量用static 进行修饰，例如：

class CStudent

{

private:

static const int NUM_LESSONS = 5; // 声明常量

int scores[NUM_LESSONS]; // 使用常量

};

注意，上述注释中说的是“声明常量”，而非“定义常量”，并且在声明的同时，完成了“特殊形式”的初始化。之所以谓之“特殊形式”，是因为我们熟悉的一般形式的初始化是不允许放在声明里的。**这种“特殊形式”的初始化在C++ 中被称为“类内初始化”。**还有一点需要明确的是，在**不同的编译器中对类内初始化的支持情况也不尽相同。在VC++ 2010 中，并不是所有的内置类型都可以实现类内初始化，它只对整数类型（比如int、char、bool）的静态成员常量才有效。**如果静态成员变量是上述类型之外的其他类型，如double
 型，那么需要将该类的初始化放到其实现文件该变量的定义处，如下所示：

/* VC++ 2010 */

// CMathConstants 声明文件（.h）

class CMathConstants

{

private:

static const double PI;

};

// CMathConstants 实现文件（.cpp）

const double CMathConstants::PI = 3.1415926;
**而在GCC 编译器中，内置的float、double 类型的静态成员常量都可以采用类内初始化，如下所示：**/* Gcc 4.3 */

// CMathConstants 声明文件（.h）

class CMathConstants

{

private:

static const double PI = 3.1415926;

};

当然，如果不习惯类内初始化，讨厌其破坏了静态成员常量声明、定义的统一形式，可以选择将类内初始化全部搬到类实现文件中去，这也是我们比较推荐的形式。更何况早

期的编译器可能不接受在声明一个静态的类成员时为其赋初值，那又何必去惹这些不必要的麻烦呢？

另外，如果编译器不支持类内初始化，而此时类在编译期又恰恰需要定义的成员常量值，身处如此左右为难的境地，我们该采取怎样的措施？那就求助于enum ！巧用enum 来

解决这一问题。这一技术利用了这一点：**枚举类型可以冒充整数给程序使用**。代码如下所示：

// CStudent 声明文件（.h）

class CStudent

{

private:

enum{ NUM_LESSONS = 5 };

int scores[NUM_LESSONS];

};

需要说明的一点是，类内部的静态常量是绝对不可以使用#define 来创建的，#define 的世界中没有域的概念。这不仅意味着#define 不能用来定义类内部的常量，同时还说明它无法为我们带来任何封装效果。

**d使用内联函数的模板，既可以得到宏的高效，又能保证类型安全，不必为一些鸡毛蒜皮的小问题耗费宝贵的精力。**](https://so.csdn.net/so/search/s.do?q=string&t=blog)](https://so.csdn.net/so/search/s.do?q=function&t=blog)](https://so.csdn.net/so/search/s.do?q=processing&t=blog)](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)




