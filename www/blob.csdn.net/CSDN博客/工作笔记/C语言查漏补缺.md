# C语言查漏补缺 - 工作笔记 - CSDN博客





2015年03月23日 08:25:19[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：5569








﻿﻿

严格来说，C语言中没有“实型”(real type)这种数据类型。

C语言中非构造类型只有整型（int、short、long、long long和对应的unsigned修饰的类型，以及同义写法），以及浮点型（包括单精度浮点型float，双精度浮点型double，长双精度浮点型long double）两大类。其中float和double内部储存形式遵循IEEE 754标准，long double取决于编译平台。C语言中的浮点型数内部储存形式为指数计数法分段存储的二进制形式的小数，即使在规定大小和字长精度范围之内也不能严格无误差地表示所有十进制小数、有理数，更不用说实数。（而C语言源代码中除了16进制整数表示的实际存储形式以外，直接表示的所有浮点数都只能是十进制的，因此除非在二进制下也是有限小数（分数形式中分母是2的幂），且不是太长，否则在编译过程中即会产生误差。）

尽管如此，有时候float、double、long double这三者（或者前两者）会被不严格地统称为“实型”。

C语言中，数值常量的后缀（大小写同义）可以表达常量的类型，例如0UL表示unsigned long型数0。如果没有后缀，则通过具体的写法来确定。总的原则是尽可能避免精度损失。不过也不是范围越小越好，例如0是int型而不是char型常量。对于没有后缀的十进制小数（小数部分或整数部分之一完全不写的也算，当作省略了0），默认为double常量，例如3.1415等同于3.1415D。（如果要用float常量，应该使用3.1415f或3.1415F。）对于指数形式的，默认也是double，例如0.329e2（或者0.329E+2之类的也可以）。至于0.329*10^2如果出现在源代码中，会被当做是一个表达式，先计算0.329和10的积，结果再和2作^（位异或）运算。但由于积是double类型的，不能参与位运算，会给出编译错误。

871是int常量，不是“实型”常量。

871.、871.f、871.0F、871.d、871.0D、8.71E+2、0.871e3这类才是“实型”常量。

函数指针，可以用作分段函数，或者有不同处理核心，但相同功能的函数情况下，将核心部分代码，用不同名称相同类型的函数实体实现，然后将该函数体直接传递给通用函数，如此便减少了代码体积，方便维护，否则，需要两种功能需要各自编写，会有重复代码。

联合体，需要分析所面对问题是否完全不相干。



