# 2012.4.17内存相关 - 工作笔记 - CSDN博客





2012年04月17日 09:55:50[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：6371








**         在VC中，栈空间未初始化的字符默认是-52，补码为0XCC，两个0xcc即0xcccc在GBK编码中，就“烫”；堆空间未初始化的字符默认是-51，两个-51 在GBK编码中就是“屯”。 二者都是未初始化的内存。**

内存分布：

**   程序运行时，必须将可执行程序加载到计算机内存中，程序加载完毕后，就形成一个运行空间，并按下面方式布局：**

**   代码区（Code Area）：存放程序的执行代码。**

**   数据区（Data Area）：存放全局数据，常量，静态变量等。**

**   堆区（Heap Area）： 存放的则是动态内存，供程序随机申请使用。**

**  栈区（Stack Area）： 存放着程序中所用到的局部数据。**

**  在C++ 中，数据区又被分成自由存储区、全局/ 静态存储区和常量存储区。**

**   栈（Stack）区：**

**   在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是所分配的内存容量有限。   堆（Heap）区**

**   堆就是那些由new 分配的内存块，其释放编译器不会管它，而是由我们的应用程序控制它，一般一个new 就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统就会自动回收。   自由存储区   自由存储区是那些由malloc 等分配的内存块，它和堆十分相似，不过它是用free 来结束自己生命的。   全局/ 静态存储区   全局变量和静态变量被分配到同一块内存中，在以前的C 语言中，全局变量又分为初始化的和未初始化的，在C++ 里面没有作此区分，它们共同占用同一块内存区。   常量存储区这是一块比较特殊的存储区，里面存放的是常量，不允许修改。**

**   堆区和栈区的区别：**

**   管理方式不同对于栈来讲，它是由编译器自动管理的，无须我们手工控制；对于堆来说，它的释放工作由程序员控制，容易产生memory leak。**

**空间大小不同   一般来讲在32 位系统下，堆内存可以达到4GB 的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的。**

**   碎片问题   对于堆来讲，频繁的new/delete 势必会造成内存空间的不连续，从而产生大量的碎片，使程序效率降低。**

**   对于栈来讲，则不存在这个问题，其原因还要从栈的特殊数据结构说起。栈是一个具有严明纪律的队列，其中的数据必须遵循先进后出的规则，相互之间紧密排列，绝不会留给其他数据可插入之空隙，所以永远都不可能有一个内存块从栈中间弹出，它们必须严格按照一定的顺序一一弹出。**

**生长方向   对于堆来讲，其生长方向是向上的，也就是向着内存地址增加的方向增长；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长的。**

**   分配方式   堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca 函数完成，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放的，无须我们手工实现。**

**   分配效率   栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：它会分配专门的寄存器存放栈的地址，而且压栈出栈都会有专门的指令来执行，这就决定了栈的效率比较高。堆则是C/C++ 函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/ 操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），则可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存了，然后返回。显然，堆的效率比栈要低得多。**



**   堆和栈相比，由于堆使用了大量new/delete，容易造成大量的内存碎片，而且它没有专门的系统支持，效率很低，另外它还可能引发用户态和核心态的切换，以及内存的申请，代价会变得很高。所以栈在程序中是应用最广泛的，就算是函数的调用也会利用栈去完成，函数调用过程中的参数、返回的地址、EBP 和局部变量都是采用栈的方式存放的。所以，我们推荐大家尽量多用栈，而不是用堆。虽然栈有如此多的好处，但是由于和堆相比它不是那么灵活，有时候会分配大量的内存空间，在遇到这种情况时还是用堆好一些。**

**new的三种形态：**

**    new operator    operator new    placement new    下面的代码片段展示的是我们印象中熟悉的那个new：    string *pStr = new string("Memory Management");    int *pInt = new int(2011);    这里所使用的new 是它的第一种形态new operator。它与sizeof 有几分类似，它是语言内建的，不能重载，也不能改变其行为，无论何时何地它所做的有且只有以下三件事：**

//
 为string 对象分配raw 内存
    void *memory = operator new( sizeof(string) );
// 调用构造函数，初始化内存中的对象

    call string::string()on memory;
// 获得对象指针

    string *pStr = static_cast<string*>(memory);
当然，对于内置类型，第二步是被忽略的，即：

    // 为int 分配raw 内存

    void *memory = operator new( sizeof(int) );
// 获得对象指针

    int *pInt = static_cast<int*>(memory);

    其实new operator 背后还藏着一个秘密，即它在执行过程中，与其余的两种形态都发生了密切的关系：第一步的内存申请是通过operator new 完成的；而在第二步中，关于调用什么构造函数，则由new 的另外一种形态placement new 来决定的。对于new 的第二种形态—内存申请中所调用的operator new，它只是一个长着“明星脸”的普通运算符，具有和加减乘除操作符一样的地位，因此它也是可以重载的。

**     operator new 在默认情况下首先会调用分配内存的代码，尝试从堆上得到一段空间，同时它对事情的结果做了最充分的准备：如果成功则直接返回；否则，就转而去调用一个new_hander，然后继续重复前面过程，直到异常抛出为止。**

**    所以如果operator new 要返回，必须满足以下条件之一：内存成功分配。    抛出bad_alloc 异常。    通常，operator new 函数通过以下方式进行声明：    void* operator new(size_t size);    注意，这个函数的返回值类型是void*，因为这个函数返回的是一个未经处理的指针，是一块未初始化的内存，它像极了C 库中的malloc 函数。可以重载operate new函数，实现自己想要的功能。或者干预该函数执行过程。**

**    placement new 是用来实现定位构造的，可以通过它来选择合适的构造函数。虽然通常情况下，构造函数是由编译器自动调用的，但是不排除你有时确实想直接手动调用，比如对未初始化的内存进行处理，获取想要的对象，此时就得求助于一个叫做placement new 的特殊的operator new 了。placement new 是标准C++ 库的一部分，被声明在了头文件<new> 中，所以只有包含了这个文件，我们才能使用它。**



内存申请失败处理：

**    新标准下的new 在申请内存失败时具备了新的处理方式：抛出一个bad_alloc exception（异常）。所以，在新的标准里，Test-for-NULL 处理方式不再被推荐和支持。**

**    如果出现了这个异常，那就意味着内存耗尽，或者有其他原因导致内存分配失败。所以，按照C++ 标准，如果想检查 new 是否成功，则应该捕捉异常：try{　 int* pStr = new string[SIZE];　　... // processing codes}catch ( const bad_alloc& e ){　　return -1;}**

**但是市面上还存在着一些古老编译器的踪迹，这些编译器并不支持这个标准。同时，在这个标准制定之前已经存在的很多代码，如果因为标准的改变而变得漏洞百出，肯定会引起很多人抗议。C++ 标准化委员会并不想遗弃这些 Test-for-NULL 的代码，所以他们提供了operator new 的另一种可选形式— nothrow ，用以提供传统的Failure-yields-NULL 行为。采用不抛出异常的new 形式，上面的代码片段就应该改写为以下形式：int* pStr = new(std::nothrow) string[SIZE];if(pStr==NULL){... // 错误处理代码} **

需要注意的是，编译器在表达式 new (std::nothrow) ClassName 中一共完成了两项任务。首先，operator new 的 nothrow 版本被调用来为一个ClassName
 object 分配对象内存。假如这个分配失败，operator new 返回null 指针；假如内存分配成功，ClassName 的构造函数则被调用，而在此刻，对象的构造函数就能做任何它想做的事了。如果此时它也需要new一些内存，但是没有使用 nothrow new 形式，那么，虽然在"new (std::nothrow) ClassName"中调用的operator new 不会抛出异常，但其构造函数却无意中办了件错事。假如它真的这样做了，exception 就会像被普通的operator new 抛出的异常一样在系统里传播。所以使用nothrow
 new 只能保证operator new 不会抛出异常，无法保证"new(std::nothrow) ClassName"这样的表达式不会抛出exception。所以，慎用nothrow new。

**    最后还需要说明一个比较特殊但是确实存在的问题：在Visual C++ 6.0 中目前operator new、operator new(std::nothrow) 和 STL 之间不兼容、不匹配，而且不能完全被修复。如果在非MFC 项目中使用Visual C++6.0 中的STL，其即装即用的行为可能导致STL 在内存不足的情况下让应用程序崩溃。对于基于MFC 的项目，STL 是否能够幸免于难，完全取决于你使用的 STL 针对operator new 的异常处理。**



new_handler函数

**   在使用operator new 申请内存失败后，编译器并不是不做任何的努力直接抛出std::alloc异常，在这之前，它会调用一个错误处理函数（这个函数被称为new-handler），进行相应的处理。通常，一个好的new-handler 函数的处理方式必须遵循以下策略之一：   Make more memory available（使更大块内存有效）   operator new 会进行多次的内存分配尝试，这可能会使其下一次的内存分配尝试成功。其中的一个实现方法是在程序启动时分配一大块内存，然后在new-handler 第一次被调用时释放它供程序使用。   Install a different new-handler（装载另外的new-handler）   程序中可以同时存在多个new-handler， 假如当前的new-handler 不能获得更多的内存供operator new 分配使用，但另一个new-handler 却可以做到。在这种情形下，当前的new-handler 则会通过调用set_new_handler 在它自己的位置上安装另一个new-handler。当operator new 下一次调用 new-handler 时，它会调用最新安装的那一个。**

**   Deinstall the new-handler（卸载new-handler）   换句话说，就是将空指针传给set_new_handler，此时就没有了相应的new-handler。当内存分配失败时，operator new 则会抛出一个异常。   Throw an exception（抛出异常）抛出一个类型为bad_alloc 或继承自bad_alloc 的其他类型的异常。****   Not return（无返回）  直接调用abort 或exit 结束应用程序。以上的这些处理方式让我们在实现new-handler functions 时拥有了更多的选择与自由。这些各式各样的new-handler 函数是可以通过调用标准库函数set_new_handler 进行特殊定制的，你可以按照自己的方式来对编译器的这一行为进行设定。**

**检测内存泄漏方法：**

**  1.MS C-Runtime Library 内建的检测功能**

**   使用MFC 开发的应用程序时，会在Debug 模式下编译执行，程序运行结束后，VisualC++ 会输出内存的使用情况，如果发生了内存泄漏，在Debug 窗口中会输出所有发生泄漏的内存块的信息，如下所示：Detected memory leaks!Dumping objects ->mainFrm.cpp(45) : {352} normal block at 0x0058A4B8, 40 bytes long.Data: < > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CDObject dump complete.这是因为在编译过程中，IDE 自动加入了内存泄漏的检测代码。MFC 在程序执行过程中维护了一个内存链，以便跟踪每一块内存的生命周期。在程序退出的时候，dbgheap.c 文件中的extern "C" _CRTIMP int __cdecl _CrtDumpMemoryLeaks(void) 函数被调用，遍历当前的内存链，如果发现存在没有被释放的内存，则打印出内存泄露的信息。一般，大家都误以为这些内存泄漏的检测功能是由MFC 提供的，其实不然。这是VC++ 的C 运行库（CRT）提供的功能，MFC 只是封装和利用了MS C-Runtime Library 的Debug Function 而已。所以，在编写非MFC 程序时我们也可以利用MS C-Runtime Library的Debug Function 加入内存泄漏的检测功能。要在非MFC 程序中打开内存泄漏的检测功能非常容易，只须在程序的入口处添加以下代码：_CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)| _CRTDBG_LEAK_CHECK_DF );这样，在程序运行结束时，如果还有内存块没有释放，它们的信息就会被打印到Debug窗口里.**

**   2.外挂式的检测工具**

**   检测工具BoundsChecker 或Insure++.**

**BoundsChecker 采用的是一种被称为Code Injection 的技术，来截获对分配内存和释放内存的函数的调用的。简单地说，当程序开始运行时，BoundsChecker 的DLL 被自动载入进程的地址空间中，然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。BoundsChecker 在做这些动作时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常简便、直接。而Insure++ 则是利用其专利技术（源码插装和运行时指针跟踪）来发现大量的内存操作错误，准确报告错误的源代码行和执行轨迹。   如果开发环境是Linux，MS C-Runtime Library 内建检测功能就会彻底失效，BoundsChecker或Insure++ 也无能为力。这时，外挂式的检测工具Rational Purify 或Valgrind 便派上了用场。Rational Purify主要是针对软件开发过程中难以发现的内存错误、运行时错误。它可以在软件开发过程中自动地发现错误，准确地定位错误，并提供完备的错误信息，从而减少调试时间。同时它也是市场上唯一支持多种平台的相关工具，并且可以和很多主流开发工具集成。Purify 可以检查应用的每一个模块，甚至可以查出复杂的多线程或进程应用中的错误。另外，它不仅可以检查 C/C++，还可以对 Java 或 .NET 中的内存泄漏问题给出报告。在 Linux 系统中，使用 Purify 非常简单，只须重新编译程序：purify g++ -g main.cpp -o LeakDetector运行编译生成的可执行文件LeakDetector，就可以定位出内存泄漏的具体位置。除了Rational Purify，Valgrind 也是Linux 系统下开发应用程序时用于调试内存问题的有效工具。它尤其擅长发现内存管理的问题，检查发现程序运行时的内存泄漏。**

**上面有个概念有错，补充：**

**[C++ 自由存储区是否等价于堆？](http://www.cnblogs.com/QG-whz/p/5060894.html)**



# “free store” VS “heap”



当我问你C++的内存布局时，你大概会回答：

> 

“在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区”。


如果我接着问你自由存储区与堆有什么区别，你或许这样回答：

> 

“malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”


这样听起来似乎也没错，但如果我接着问：

> 

自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？


你可能就懵了。

事实上，我在网上看的很多博客，划分自由存储区与堆的分界线就是new/delete与malloc/free。然而，尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？

从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：

> 

堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。






