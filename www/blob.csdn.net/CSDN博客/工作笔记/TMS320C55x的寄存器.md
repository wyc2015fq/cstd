# TMS320C55x的寄存器 - 工作笔记 - CSDN博客





2012年08月06日 09:22:21[Eason.wxd](https://me.csdn.net/App_12062011)阅读数：10621









1.累加器A0~A3

   协助D单元的算术逻辑单元（ALU），乘加单元（MAC）以及移位器里的数据计算。

**C55x的CPU包括4个40位的累加器AC0、AC1、AC2、AC3**



**在C54x兼容模式（C54CM=1）下，累加器AC0、AC1分别对应于C54x里的累加器A、B**



**每个累加器分为低字（ACxL）、高字（ACxH） 和8个保护位（ACxG）,用户可以使用访问存储器映射寄存器的寻址方式，分别访问这3部分.**



2,变换寄存器（TRN0,TRN1）

**C55x有2个变换寄存器TRN0、TRN1 **

**用途：在比较-选择-极值指令里使用,能自动记录比较的结果**

**比较两个累加器的高段字后更新TRN0，比较两个累加器的低段字后更新TRN1 **

**在比较完两个累加器的全部40位后，更新被选中的变换寄存器（TRN0或TRN1）**


**3.T寄存器（T0-T3）**

**    CPU包含4个16位通用T寄存器，T0~T3。   **

**用途：**

**           存放乘法、乘加以及乘减运算里的一个乘数 **

**           存放D单元里加法、减法和装入运算的移位数 **

**           用交换指令交换辅助寄存器（AR0-AR7）和T寄存器中的内容时，跟踪多个指针值**

**           在D单元ALU里作双16位运算时，存放Viterbi蝶形的变换尺度**

**4.用作数据地址空间和I/O空间的寄存器**

**    4.1辅助寄存器（XAR0~XAR7/AR0~AR7）**

**         这8个辅助寄存器的高7位（ARxH）用于访问数据空间的数据页，低字用途：**

**        1.7位数据页内的16位偏移量。**

**        2.存放位地址。**

**        3.通用寄存器或者计数器。**



**     访问属性： **

     XARn只能用专用指令访问； 

     ARn可用专用指令访问，也可以作为存储器映射寄存器访问； 

     ARnH不能单独访问，必须通过访问XARn来访问ARnH 



**5.系数数据指针（XCDP/CDP）**

****CPU在存储器中映射了一个系数数据指针（CDP）和一个相关的扩展寄存器（CDPH）****



**CPU可以连接这个寄存器形成一个扩展系数数据指针（XCDP） .**

**     高7位（CDPH）用于指定要访问数据空间的数据页，低字（CDP）用来作为16位偏移量与7位数据页形成一个23位地址。**

**     访问属性：**

**     XCDP 只能用专用指令访问，不是映射到存储器的寄存器。**

**     CDP 可用专用指令访问，也可作存储器映射寄存器访问。**

**     CDPH 与CDP一样。**

**6.**循环缓冲区首地址寄存器****

****CPU有5个16位的循环缓冲区首地址寄存器： ****

**BSA01，BSA23，BSA45，BSA67，BSAC **

**作用：定义循环的首地址 **

**每个循环缓冲区首地址寄存器与一个或两个特殊的指针相关联 **



**7.循环缓冲区大小寄存器**

**三个16位的循环缓冲区大小寄存器（BK03，BK47，BKC） **

**用途：指定循环缓冲区大小（最大为65535） **

**每个循环缓冲区大小寄存器与一个或四个特殊的指针相关联**


**8.数据页寄存器（****XDP/DP****）**


**   CPU在存储器中映射了一个数据页寄存器（DP）和一个相关的扩展寄存器（DPH）**

**CPU连接这两个寄存器形成一个扩展数据页寄存器（XDP） **

**DPH指定要访问数据空间的7位数据页 **



**低字（DP）用来代表一个16位偏移地址 **



**用途：  **

**在基于DP的****直接寻址方式中，XDP指定23位地址**

**在k16****绝对寻址方式中，DPH与一个16位的立即数连接形成23****位地址**

9.**外设数据页指针（****PDP****）**



**   对于PDP直接寻址方式， ****9位****的外设数据页指针（PDP）****选择64K字I/O空间中的一个128字页面**

10.堆栈指针

**有关堆栈指针 **

**     数据堆栈指针（SP） **

**     系统堆栈指针（SSP） **

**     相关扩展寄存器（SPH） **





**     当访问数据堆栈时， **

**     CPU连接SPH和SP形成一个扩展的堆栈指针（XSP）， 指向最后压入数据堆栈的数据，SPH代表7位数据页，SP指向页中某个地址。**

**     当访问系统堆栈时， **

**     CPU连接SPH和SSP形成一个扩展的堆栈指针（XSSP）**

**11.程序流寄存器（PC、RETA、CFCT）**

**PC 24位的程序计数器。存放I单元里解码的1~6字节代码的地址.当CPU执行中断或调用子程序时，当前的PC值（返回地址）存起来，然后把新的地址装入PC。当CPU从中断服务或子程序返回时，返回地址重新装入PC    RETA 返回地址寄存器。如果所选择的堆栈配置使用快速返回，则在执行子程序时，RETA就作为返回地址的暂存器。RETA和CFCT一起，高效执行多层嵌套的子程序。可用专门的32位装入和存储指令，成对地读写RETA和CFCT    CFCT 控制流关系寄存器。CPU保存有激活的循环记录（循环的前后关系）。如果选择的堆栈配置使用快速返回，则在执行子程序时，CFCT就作为8位循环关系的暂存器。RETA和CFCT一起，高效执行多层嵌套的子程序。可用专门的32位 装入和存储指令，成对地读写RETA和CFCT。**

**12.中断管理寄存器**

![](https://img-my.csdn.net/uploads/201208/06/1344256245_2918.jpg)

      12.1 中断向量指针

             DSP中断向量指针（IVPD） 16位，指向256字节的程序空间中的中断向量表（IV0～IV15和IV24～IV31），这些中断向量供DSP专用

             主机中断向量指针（IVPH） 16位，指向256字节的程序空间中的中断向量表（IV16～ IV23），这些中断向量供DSP和主机共享使用

            ☼  说明：

            12.1.1 如果IVPD和IVPH的值相同，所有中断向量可能占有相同的256字节大小的程序空间；

            12.1.2 DSP硬件复位时，IVPD和IVPH都被装入到FFFFH地址处；

            12.1.3 IVPD和IVPH均不受软复位的影响  

             中断向量表：

![](https://img-my.csdn.net/uploads/201208/06/1344256652_5765.jpg)

                  由16位的中断向量指针加上一个5位的中断编号后左移3位组成一个24位的中断地址。

☼  在修改IVP之前应确保：

                 INTM=1，即所有可屏蔽中断不能响应。

                  每个硬件不可屏蔽中断对于原来的IVPD和修改后的IVPD都有一个中断向量和中断服务程序。

      12.2. 中断标志寄存器（IFR0，IFR1）

                        16位的中断标志寄存器IFR0和IFR1包括所有可屏蔽中断的标志位

                当一个可屏蔽中断向CPU提出申请时，IFR中相应的标志位置1，等待CPU应答中断

                中断被响应后将相应位清0，器件复位将所有位清0    

       12.3.中断使能寄存器（IER0，IER1） 

                通过设置IER0、IER1的位为：

                                                                 1 ，打开相应的可屏蔽中断

                                                                  0 ，关闭相应的可屏蔽

               上电复位时，将所有IER位清0。

               在全局可屏蔽中断使能（INTM=1）之前应初始化它们。

       12.4. 调试中断使能寄存器（DBIER0，DBIER1）

                当CPU工作在 实时 仿真模式 调试 暂停 时，这两个16位的调试中断使能寄存器才会使用

                如果CPU工作在实时方式下，DBIER0、DBIER1将被忽略

 13 循环控制寄存器

         1.单指令循环控制寄存器（RPTC，CSR）

       单循环指令可以重复执行一个单周期指令或并行执行两个单周期指令，重复次数N被装在RPTC中，指令将被重复执行N+1次。
在一些无条件单指令循环操作中，可以使用CSR设置重复次数。

         2.块循环寄存器（BRC0，BRC1，BRS1，RSA0，RSA1，REA0，REA1）

            块循环指令可以实现2级嵌套，一个块循环（1级）嵌套在另一个块循环（0级）内部

            当C54CM=0，即工作在C55x方式下，才实现2级嵌套

            当无循环嵌套时，CPU使用0级寄存器

            当出现循环嵌套时，CPU对于1级嵌套使用1级寄存器

            当C54CM=1，即工作在C54x方式下

           只能使用0级寄存器，通过借助块重复标志寄存器（BRAF）完成嵌套

14 状态寄存器

C55x含有4个16位的状态寄存器（ST0_55~ST3_55）其控制位影响C55xDSP的工作，状态位反映了C55xDSP当前工作状态或运行结果

          ST0_55

![](https://img-my.csdn.net/uploads/201208/06/1344257507_5759.jpg)

           ST0_55（以及ST1_55和ST3_55）有两个访问地址。所有位都可以由第一个地址访问，而在另一个地址（保护地址）里，加黑部分不能修改；保护地址是为了支持把C54x的代码写入ST0、ST1和PMST


1.累加器溢出标志（ACOV0，ACOV1，ACOV2，ACOV3）       

当累加器AC0、AC1、AC2或AC3有数据溢出时,相应的ACOV0、ACOV1、ACOV2或ACOV3被置1，直到发生以下任一事件：

 复位

     CPU执行条件跳转、调用、返回，或执行一条测试ACOVx状态的指令

     被指令清0


溢出方式受M40位的影响
  当M40=0时，溢出检测在第31位，与C54x兼容

     当M40=1时，溢出检测在第39位

2. 进位位（CARRY）

     当D单元ALU做加法运算时，若产生进位，则置位CARRY；如果不产生进位时，则将CARRY清0
例外：使用以下语句（将Smem移动16位），有进位时置位CARRY，无进位时不清0。ADD Smem<<#16,[ACx,]ACy
     当D单元ALU做减法运算时，若产生借位，将CARRY清0；如果不产生借位，则置位CARRY。
例外：使用以下语句（将Smem移动16位），有借位时 CARRY 清0，无借位时CARRY不变。SUB Smem<<#16,[ACx,]ACy

CARRY位可以被逻辑移位指令修改。对带符号移位指令和循环移位指令，可以选择CARRY位是否需要修改

     MIN、MAX、ABS、NEG在目的寄存器是累加器时，修改CARRY位，以指示计算结果。

     例：MIN  [src,]dst

     进位/借位的检测取决于M40位

     当M40=0时，由第31位检测进位/借位

     当M40=1时，由第39位检测进位/借位
3. DP位域
 DP位域

    占据ST0_55的第8～0位

    提供与C54x兼容的数据页指针

    C55x有一个独立的数据页指针DP

    DP（15～7）的任何变化都会反映在ST0_55的DP位域上。

    基于DP的直接寻址方式，C55x使用完整的数据页指针DP（15～0），因此不需要使用ST0_55的DP位域。

    如果想装入ST0_55，但不想改变DP位域的值，可以用OR或AND指令。
4. 测试/控制位（TC1，TC2）

测试/控制位用于保存一些特殊指令的测试结果。

    所有能影响一个测试/控制位的指令，都可以选择影响TC1还是TC2

    TCx或关于TCx的布尔表达式，都可以在任何条件指令里用作触发器
ST1_55
![](https://img-my.csdn.net/uploads/201208/06/1344266751_3039.jpg)

1. ASM位

如果C54CM=0

    C55x忽略ASM，C55x移位指令在暂存寄存（T0～T3）里指定累加器的移位值，或者直接在指令里用常数指定移位值。

如果C54CM=1

    C55x以兼容方式运行C54x代码，ASM用于给出某些C54x移位指令的移位值，移位范围-16～15。

2. BRAF位

如果C54CM=0，C55x不使用BRAF。

如果C54CM=1，C55x以兼容方式运行C54x代码，BRAF用于指定或控制一个块循环操作的状态。

在由调用、中断或返回引起的代码切换过程中，都要保存和恢复BRAF的值。

当执行远程跳转（FB）或远程调用（FCALL）指令时，BRAF自动清零。
3.  C16位

如果C54CM=0，C55x忽略C16

        指令本身决定是用单32位操作还是双16位操作。

如果C54CM=1，C55x以兼容方式运行C54x代码，C16会影响某些指令的执行。

        当C16=0时，关闭双16位模式，D单元ALU执行一条指令是以单32位操作（双精度运算）形式

        当C16=1时，打开双16位模式， D单元ALU执行一条指令是以两个并行的16位操作（双16位运算）形式

4. C54CM位

   如果C54CM＝0，C55x CPU不支持C54x代码

   如果C54CM＝1，C55x的CPU支持C54x编写的代码

   在使用C54x代码时就必须置位该模式，所有C55x CPU的资源都可以使用

   在移植代码时，可以利用C55x增加的特性优化代码

5.  CPL位

   如果CPL＝0，CPL决定选择DP直接寻址模式

   如果CPL＝1，CPL决定选择SP直接寻址模式
6. FRCT位

   如果FRCT＝0，C55x打开小数模式。 乘法运算的结果左移一位进行小数点调整。两个带符号的Q15制数相乘，得到一个Q31制数时，就要进行小数点调整。

   如果FRCT＝1，C55x关闭小数模式。乘法运算的结果不移位。

7. HM位

   当DSP得到HOLD信号时，会将外部接口总线置于高阻态。根据HM的值，DSP也可以停止内部程序执行。

   如果HM＝0，C55x继续执行内部程序存储器的指令。

   如果HM＝1，C55x停止执行内部程序存储器的指令。

8. INTM位

   如果INTM＝0，C55x使能所有可屏蔽中断

   如果INTM＝1，C55x禁止所有可屏蔽中断

使用INTM位需要注意的要点：

   INTM位能够全局使能或禁止可屏蔽中断；

   CPU响应中断请求时，自动保存INTM位。特别地，CPU把ST1_55保存到数据堆栈时，INTM位也被保存起来。

   执行中断服务子程序（ISR）之前，CPU自动置位INTM位，禁止所有的可屏蔽中断。ISR可以通过清零INTM位，来重新开放可屏蔽中断。

   中断返回指令，从数据堆栈恢复INTM位的值。

9. M40位

如果M40＝0，D单元的计算模式选择32位模式：

   第31位是符号位

   计算过程中的进位取决于第31位

   由第31位判断是否溢出

   饱和过程，饱和值是00 7FFF FFFFh（正溢出）或FF 8000 0000h（负溢出）

   累加器和0的比较，用第31～0位来进行

   可对整个32位进行移位和循环操作

   累加器左移或循环移位时，从第31位移出

   累加器右移或循环移位时，移入的位插入到第31位上

   如果M40＝1，D单元的计算模式选择40位的带符号移位模式：

10. SATD位

   如果SATD＝0，关闭D单元的饱和模式，不执行饱和模式

   如果SATD＝1，打开D单元的饱和模式

11. SXMD位

如果SXMD＝0，关闭D单元的符号扩展模式

   ALU运算时，高位补0扩展至40位

   累加器带符号右移时，移位值补零扩展

如果SXMD＝1时，打开符号扩展模式：

ALU运算时，都要符号扩展至40位

累加器带符号移位时，其值带符号扩展
例外：

限定符uns()表明它是无符号的。

无符号运算（布尔逻辑运算、循环移位和逻辑移位运算），补零扩展

MAC里的运算，带符号扩展至17位

12. XF位

    XF是通用的输出位，能用软件处理且可输出至DSP引脚

用下面的指令清零和置位XF：

BCLR   XF     ;清零XF

BSET   XF     ;置位XF
ST2_55

![](https://img-my.csdn.net/uploads/201208/06/1344267918_1052.jpg)

1. AR0LC～AR7LC位域

  ARnLC （n＝0、1、2、3、4、5、6、7）位决定ARn用作线性寻址还是循环寻址。

ARnLC＝0：线性寻址

ARnLC＝1：循环寻址


 用状态位清零/置位  指令来清零/置位ARnLC。

例:

    BCLR   AR3LC    ;清零AR3LC

    BSET    AR3LC    ;置位AR3LC

2. ARMS位

决定辅助寄存器（AR）间接寻址的CPU采用DSP模式操作数还是采用控制模式操作数

如果ARMS＝0，采用DSP模式操作数，该操作数能有效执行DSP专用程序。

如果ARMS＝1，采用控制模式操作数，该操作数能为控制系统的应用优化代码的大小。


3. CDPLC位

CDPLC位决定系数数据指针（CDP）是用线性寻址（CDPLC＝0），还是循环寻址（CDPLC位＝1）

用下面的指令清零和置位CDPLC：

BCLR   CDPLC    ;清零CDPLC

BSET   CDPLC    ;置位CDPLC

4. DBGM位

DBGM位用于调试程序里有严格时间要求的部分

    如果DBGM＝0，使能该位

    如果DBGM＝1，禁止该位。仿真器不能访问存储器和寄存器。软件断点仍然可以使CPU暂停，但不会影响硬件断点或暂停请求

5.EALLOW位

EALLOW使能（EALLOW＝0）或禁止（EALLOW＝1）对非CPU仿真寄存器的写访问

6. RDM位


RDM位影响对操作数取整rnd()的结果

如果RDM=0，CPU给40位的操作数加上8000h（即215），然后CPU清零第15～0位，产生一个24位或16位的取整结果

如果RDM=1,取整至最接近的整数。取整结果取决于40位操作数的第15～0位：

If（0=<（位15-0）<8000h）

   CPU 清零第15～0位

     If（8000h<（位15-0）<10000h）

       CPU给该操作数加上8000h，再清零第15～0位

       If (（位15-0）= =8000h)

     If （位31-16）是奇数

              CPU给该操作数加上8000h，再清零第15～0位

ST3_55

![](https://img-my.csdn.net/uploads/201208/07/1344269003_8913.jpg)

1. CACLR位

检查是否已完成程序cache清零

CACLR＝0：已经完成。清零过程完成时, cache硬件清零CACLR位

CACLR＝1：未完成。所有的cache块无效

清零cache所需的时间周期数取决于存储器的结构

当cache清零后，指令缓冲器单元里的预取指令队列的内容会自动清零

2. CAEN位

使能或禁止程序cache

CAEN＝0：禁止。cache控制器不接收任何程序要求,所有的程序要求都由片内存储器或片外存储器（根据解码的地址而定）来处理。

CAEN＝1：使能。依据解码的地址，可以从cache、片内存储器或片外存储器提取程序代码。

当清零CAEN位禁止cache时，I单元的指令缓冲队列的内容会自动清零

3. CAFRZ位

CAFRZ能锁定程序cache

CAFRZ＝0 ：cache工作在默认操作模式

CAFRZ＝1 ：cache被冻结（其内容被锁定）。没有访问该cache时，它的内容不会更改，但被访问时仍然可用。cache内容一直保持不变，直到CAFRZ位清零

4. CBERR位

检测到一个内部总线错误时，置位CBERR。该错误使CPU在中断标志寄存器1（IFR1）里置位总线错误中断标志BERRINTF

对CBERR位写1无效。该位只在发生内部总线错误时才为1。

总线错误的中断服务子程序，返回控制中断程序的代码以前，必须清零CBERR。

5. CLKOFF位

当CLKOFF＝1，CLKOUT引脚的输出被禁止，且保持高电平

用下面的指令清零和置位CLKOFF：

BCLR   CLKOFF    ;清零CLKOFF

BSET   CLKOFF    ;置位CLKOFF

6. HINT位

用HINT位通过主机接口，发送一个中断请求给主机处理器。

先清零，然后再给HINT置位，产生一个低电平有效的中断脉冲：

BCLR   HINT      ;清零HINT

BSET   HINT      ;置位HINT
7. MPNMC位

MPNMC位使能或禁止片上ROM

MPNMC＝0：微计算机模式。使能片上ROM，可以在程序空间寻址。

MPNMC＝1：微处理器模式。禁止片上ROM，不映射在程序空间里。

MPNMC的改变，反映复位过程中MP/MC引脚的逻辑电平（高电平－1，低电平－0）

仅在复位时才对MP/MC引脚采样。

软件中断指令不影响MPNMC

8. SATA位

SATA决定A单元ALU的溢出结果是否饱和

SATA＝0：关闭。不执行饱和

SATA＝1：打开。如果A单元的ALU里的计算产生溢出，则结果饱和至7FFFh（正向饱和）或8000h（负向饱和）

9. SMUL位

SMUL位打开或关闭乘法的饱和模式

如果SMUL＝0：关闭。

如果SMUL＝1：打开。

在SMUL＝1、FRCT＝1且SATD＝1的情况下，8000h与8000h相乘的结果饱和至7FFF FFFFh（不受M40位的影响）。这样，两个负数的乘积就是一个正数。

对于乘加/减指令，在乘法之后、加法/减法以前，执行饱和运算

10. SST位

C54CM＝0，CPU忽略SST，仅用指令判断是否产生饱和

C54CM＝1，在C54x兼容模式下，SST打开或关闭饱和-存储模式

SST将影响一些累加器-存储指令的执行。SST＝1时，在存储之前，40位的累加器值要饱和为一个32位的值。如果累加器值要移位，则CPU执行移位后饱和。






























