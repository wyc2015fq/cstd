# 车道线检测学习总结 - sinat_31425585的博客 - CSDN博客
2018年08月24日 21:01:34[Mirror_Yu_Chen](https://me.csdn.net/sinat_31425585)阅读数：6408
    之前学习了一个非常酷炫的车道线检测项目：[Advanced Lane Finding Project](https://github.com/udacity/CarND-Advanced-Lane-Lines)
    现在写一个学习笔记，备注一下，方便以后复习：
** 项目总体流程如下：**
![](https://img-blog.csdn.net/20180824182622621?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**第一步，采用棋盘对相机进行校正：**
![](https://img-blog.csdn.net/20180824182952121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**第二步，对图像进行截取，**由于获取到的图像中一半为天空及背景：基于这个先验知识，预先对图像进行截取，可以为后面更准确定位车道线奠定基础。
![](https://img-blog.csdn.net/20180824183222266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**第三步，基于图像的梯度和颜色特征，定位车道线所在位置**
1）梯度信息：使用了sobelX，sobelY，sobelXY，direction四个信息，保留图像中四个信息同时满足：
`(35, 100), (30, 255), (30, 255), (0.7, 1.3)的像素；`
![](https://img-blog.csdn.net/20180824184043938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
2）颜色信息：先将图像转换成HLS通道，然后判断图像像素值信息及三个通道信息，保留图像中四个信息同时满足：
(180, 255), (10, 100), (0, 60), (85, 255)的像素：
![](https://img-blog.csdn.net/201808241845560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
3）将两种信息直接叠加组合起来，就是最终的车道线对应像素所在位置：
![](https://img-blog.csdn.net/20180824184757910?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**第四步，使用仿射变换，将二值图像转换成鸟瞰图（感觉就是从上往下看的俯视图），**这样做是为了将图像进行拉伸，方便后面的滑窗多项式拟合来对车道线进行精确定位：
![](https://img-blog.csdn.net/20180824185328111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**第五步，精确定位车道线所在位置**
1）定位滑窗左右两条车道线的搜寻起始点：首先，划分搜素区域，按照x轴方向将图像一分为二，划分为左右两个部分；然后，对二值图像两个部分在x方向做直方图统计，定位峰值作为左右两条车道线的搜寻起点
![](https://img-blog.csdn.net/20180824192405924?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
2）搜寻过程：首先，设置搜寻窗口大小（width和height）；然后，以搜寻起始点作为当前搜寻的基点，并以当前基点为中心，做一个网格化搜寻，其实就是由初始位置x，width为手工设定，height为图片大小除以设置搜寻窗口数目计算得到，这里假设窗口数目为4；其次，对每个搜寻窗口分别做水平和垂直方向直方图统计（实际实现更加简单，这里这样描述主要是为了方便理解），统计在搜索框区域内非零像素个数，并过滤掉非零像素数目小于50的框；最后，计算非零像素坐标的均值作为当前搜索框的中心，并对这些中心点做一个二阶的多项式拟合，得到当前搜寻对应的车道线曲线参数。
![](https://img-blog.csdn.net/20180824195921874?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
3）更新搜寻基点：步骤2)中，二阶多项式逼近后，会得到一个曲线方程：![ay^{2}+by+c=x](https://private.codecogs.com/gif.latex?ay%5E%7B2%7D&plus;by&plus;c%3Dx)，令![y=img.height](https://private.codecogs.com/gif.latex?y%3Dimg.height)，这样就可以得到新的搜寻基点。
4）优化：如果已经得到10个曲线方程（十个步长中均存在曲线），可以利用之前的参数方程来做一个平滑处理，具体过程——首先，10个曲线方程中断开（每三个曲线选取其中两个）；然后，将曲线方程离散化后的坐标点取均值，再做二阶多项式逼近。
     这里补充一下，什么叫曲线方程离散化：例如，已知方程为![y=x^{2}+1](https://private.codecogs.com/gif.latex?y%3Dx%5E%7B2%7D&plus;1)，离散化的过程就是，我选取一组x：[0， 1， 2， 3]，对应y：[1， 2， 5， 10]，这样，我们就可以用采样点集{(0, 1), (1, 2), (2, 5), (3, 10)}来表示曲线![y=x^{2}+1](https://private.codecogs.com/gif.latex?y%3Dx%5E%7B2%7D&plus;1)，这个表示过程，就是将曲线方程离散化。
**补充：**作者说，直接对颜色信息和梯度信息叠加，会出现检测结果漂移，因为梯度信息存在裂缝状态，导致融合后，检测得到车道线结果偏离了真实位置：
![](https://img-blog.csdn.net/20180824205426846?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
因此，在计算过程中，对梯度信息和颜色信息采取加权平均方式，梯度信息的权重为0.2，颜色信息的权重为0.8，这样就可以得到一个比较好的结果：
![](https://img-blog.csdn.net/20180824205725967?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
最后，计算车道线曲率及将结果反投影会原图展示效果就不说了，到这里，基本就是理解这个工程的全部核心内容了。
表演结束enjoy！！！
