# 图像处理（十）：模板匹配 - sinat_31425585的博客 - CSDN博客
2018年07月05日 15:24:20[Mirror_Yu_Chen](https://me.csdn.net/sinat_31425585)阅读数：1650
模板匹配就是按照一定的相似性规则，在一张图像中寻找与模板最相似的区域。
参考opencv官网：https://docs.opencv.org/3.4.1/de/da9/tutorial_template_matching.html
模板匹配的过程如下：
![](https://img-blog.csdn.net/20180705151206392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
    左上角小狗图像为定义的模板，下面的图片为待匹配图像，匹配的过程就是按照从左到右，从上到下的顺序，依次遍历全图，通过定义的相似度评判准则，计算模板与当前位置图像块的相似度，进而得到最相似位置，实现目标定位。
    常见的相似度准则有：
![](https://img-blog.csdn.net/2018070515163939?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
    即：平方差、归一化平方差、相关系数、归一化相关系数、互相关五种。
    下面就是代码，这里只实现了两种：平方误差及绝对误差
```cpp
#include <opencv2/opencv.hpp>
#include <math.h>
#include <iostream>
using namespace cv;
using namespace std;
#define SQDIFF 0
#define SADIFF 1
float templateMatch(const Mat & src, const Mat & temp, int & i_match, int & j_match, int Match_methold)
{
	int src_cols = src.cols;
	int src_rows = src.rows;
	int temp_cols = temp.cols;
	int temp_rows = temp.rows;
	int i_end = src_rows - temp.rows + 1;
	int j_end = src.cols - temp.cols + 1;
	float match_degree = FLT_MAX;
	for (int i = 0; i < i_end; i++)
	{
		for (int j = 0; j < j_end; j++)
		{
			float match_ij = 0.0;
			for (int m = 0; m < temp_rows; m++)
			{
				for (int n = 0; n < temp_cols; n++)
				{
					uchar val_s = src.at<uchar>(i + m, j + n);
					uchar val_t = temp.at<uchar>(m, n);
					if (Match_methold == SQDIFF)
					{
						match_ij += float((val_t - val_s) * (val_t - val_s));
					}
					else if (Match_methold == SADIFF)
					{
						match_ij += float(abs(val_t - val_s));
					}
				}
			}
			
			//cout << match_ij << endl;
			if (match_ij < match_degree)
			{
				match_degree = match_ij;
				i_match = i;
				j_match = j;
			}
		}
	}
	
	return match_degree;
}
int main()
{
	Mat src = imread("messi5.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	Mat temp = imread("face.png", CV_LOAD_IMAGE_GRAYSCALE);
	
	float match_degree = 0;
	int i_match = -1, j_match = -1;
	match_degree = templateMatch(src, temp, i_match, j_match, SQDIFF);
	
	cout << i_match << j_match << match_degree << endl;
	Mat src_color;
	cvtColor(src, src_color, COLOR_GRAY2BGR);
	rectangle(src_color, Rect(j_match, i_match, temp.cols, temp.rows), Scalar(255, 0, 0));
	imshow("result", src_color);
	waitKey(0);
	return 0;
}
```
匹配结果：
![](https://img-blog.csdn.net/20180705152407364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
改进方法：
1）增加步长
2）随机抽样匹配
    增加步长就不多讨论了，随机抽样，利用的是目标所在矩形区域位置中，目标应该位于矩形区域中央，边界部分大部分为背景，因此考虑对模版进行随机采样，采样方法为：越靠近中心位置，生成越多的采样点，反之，越远离中心位置，生成较少的采样点，这里采用的随机生成函数为Gaussian函数。
```cpp
int main()
{
	Mat src = imread("messi5.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	Mat temp = imread("messi_face.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	float match_degree = 0;
	int i_match = -1, j_match = -1;
	
	vector <Point2i> real_sample_points;
	computeSamplePoints(real_sample_points, Rect(0, 0, temp.cols - 1, temp.rows - 1));
	match_degree = templateMatch(src, temp, i_match, j_match, SQDIFF, real_sample_points);
	cout << i_match << j_match << match_degree << endl;
	Mat src_color;
	cvtColor(src, src_color, COLOR_GRAY2BGR);
	for (int i = 0; i < 1000; i++){
		circle(src_color, Point(j_match, i_match) + real_sample_points[i], 1, Scalar(0, 255, 0));
	}
	rectangle(src_color, Rect(j_match, i_match, temp.cols, temp.rows), Scalar(255, 0, 0));
	imshow("result", src_color);
	waitKey(0);
	return 0;
}
```
匹配结果如下：
![](https://img-blog.csdn.net/20180818213247581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNDI1NTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
里面绿色点表示采样位置。
参考资料：
opencv 官网
