# 【算法学习】双调欧几里得旅行商问题（动态规划） - 江南烟雨 - CSDN博客
2012年10月20日 10:36:02[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：17693
双调欧几里得旅行商问题是一个经典动态规划问题。《算法导论（第二版）》思考题15-1和北京大学OJ2677都出现了这个题目。
旅行商问题描述：平面上n个点，确定一条连接各点的最短闭合旅程。这个解的一般形式为NP的（在多项式时间内可以求出）
J.L. Bentley 建议通过只考虑双调旅程(bitonictour)来简化问题,这种旅程即为从最左点开始，严格地从左到右直至最右点，然后严格地从右到左直至出发点。下图(b)显示了同样的7个点的最短双调路线。在这种情况下，多项式的算法是可能的。事实上，存在确定的最优双调路线的O(n*n)时间的算法。
![](https://img-my.csdn.net/uploads/201210/20/1350699544_3595.jpg)
上图中，a是最短闭合路线，这个路线不是双调的。b是最短双调闭合路线。
**求解过程：**
（1）首先将各点按照x坐标从小到大排列，时间复杂度为O(nlgn)。
（2）寻找子结构：定义从Pi到Pj的路径为：从Pi开始，从右到左一直到P1，然后从左到右一直到Pj。在这个路径上，会经过P1到Pmax(i,j)之间的所有点且只经过一次。
在定义d(i,j)为满足这一条件的最短路径。我们只考虑i>=j的情况。
同时，定义dist(i,j)为点Pi到Pj之间的直线距离。
（3）最优解：我们需要求的是d(n,n)。
关于子问题d(i,j)的求解，分三种情况：
A、当j < i - 1时，d(i,j) = d(i-1,j) + dist(i - 1,i)。
由定义可知，点Pi-1一定在路径Pi-Pj上，而且又由于j<i-1,因此Pi的左边的相邻点一定是Pi-1.因此可以得出上述等式。
B、当j = i - 1时，与Pi左相邻的那个点可能是P1到Pi-1总的任何一个。因此需要递归求出最小的那个路径：
d(i,j) = d(i,i-1) = min{d(k,j) + dist(i,k)},其中1 <= k <= j。
C、当j=i时，路径上最后相连的两个点可能是P1-Pi、P2-Pi...Pi-1-Pi。
因此有：
d(i,i) = min{d(i,1)+dist(1,i),...,d(i,i-1),dist(i-1,i)}.。
下面以北京大学OJ2677 Tour为例，编程实现（C++）：
AC代码：
```cpp
//双调欧几里得旅行商问题
//《算法导论（第二版）》思考题15-1
//PKU 2677
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
const int n = 7;//点的数目
const int MaxVal = 999999;
const int MaxLen = 201;
struct tagPoint{
	double x,y;
};
//计算点i和点j之间的直线距离
double distance(tagPoint *points,int i,int j)
{
	return sqrt((points[i].x - points[j].x) * (points[i].x - points[j].x) +
		(points[i].y - points[j].y) * (points[i].y - points[j].y));
}
double DP(tagPoint *points,int n)
{
	double b[MaxLen][MaxLen];//记录最短路径的长度
	//计算所有情况下的b[i][j]，1 <= i <= j
	//初始化
	b[1][2] = distance(points,1,2);
	for (int j = 3;j <= n;++j)
	{
		//i < j-1
		for (int i = 1;i <= j - 2;++i)
		{
			b[i][j] = b[i][j - 1] + distance(points,j - 1,j);
		}
		//i = j - 1,b[i][j] = min(b[k][j - 1] + distance(k,j));
		b[j - 1][j] = MaxVal;
		for (int k = 1;k <= j - 2;++k)
		{
			double temp = b[k][j - 1] + distance(points,k,j);
			if (temp < b[j - 1][j])
			{
				b[j - 1][j] = temp;
			}
		}
	}
	b[n][n] = b[n - 1][n] + distance(points,n - 1,n);
	return b[n][n];
}
int main()
{
	int NUM;
	while(cin >> NUM)
	{
		tagPoint *points = new tagPoint[NUM + 1];
		for (int i = 1;i <= NUM;++i)
		{
			cin >> points[i].x;
			cin >> points[i].y;
		}
		double minDis = DP(points,NUM);
		//设置输出格式：精确到小数点后2位
		cout.setf(ios::fixed);
		cout << setprecision(2) << minDis << endl;
	}
}
```
运行结果：
![](https://img-my.csdn.net/uploads/201210/20/1350700757_8117.jpg)
