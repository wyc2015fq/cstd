# 【数字图像处理】一种求图像边缘的方法 - 江南烟雨 - CSDN博客
2011年11月01日 14:34:02[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：6565
一幅图像，背景为黑色。其中有一个白色物体，其边缘连续。现在要求出其外边缘，即与黑色背景相交的部分，组成边缘线，并且由单个像素组成。
思想：
首先找到位于图像最上方的那个白色点。
然后从这个白色点（当前点）开始搜索下一个相邻的位于边缘上的点。并且定义当前起始搜索方向为方向1（如图一）.搜索的方式为：从当前方向开始，按顺时针依次检查每个方向上的相邻点(8连通域)，看是否为白色点。如果是，则其为下一个边缘点。在8个方向搜索完毕之前，一定能够搜索到下一个边缘点，因为图像边缘是连续的。
接着，把当前点定义为刚刚搜索到的相邻的下一个边缘点。并且修改当前起始搜索方向为：上一步搜索到下一个边缘点的方向逆时针旋转90度。为什么要旋转90度是因为边缘可能是弯折的。但是即便是弯折，下一个边缘点也一定在旋转90度后的范围之内。这个画图就可以看出，因为我们求得是外边缘。然后从此方向按顺时针搜索下一个相邻的边缘点。一直到搜索到的下一个相邻的边缘点就是最初的起始点为止，边缘点全部找到。
这个方法只能寻找外层的单像素边缘。对于有空洞的则无能为力。而且要求边缘连续，规则。
实现代码（matlab）：
```python
%构造一幅图像
% height = 256;
% width = 256;
% I = zeros(height,width);
% I(100:160,80:160) = 255;
% I(70:100,100:130) = 255;
% I(160:180,120:150) = 255;
I = imread('1.jpg');
I = rgb2gray(I);
I = im2bw(I);
I = double(I);
[height,width] = size(I);
for i = 1:height
    for j = 1:width
        if I(i,j) == 1
            I(i,j) = 255;
        end
    end
end
I = 255 - I;%程序适用于黑色背景、白色前景的图像
figure,imshow(I);
%寻找最上方的白色点
for i = 1:height
    flag = 0;%标记是否找到
    for j = 1:width
        if I(i,j) == 255
            flag = 1;
            highest_i = i;%记录最上方的点的坐标
            highest_j = j;
            break;
        end
    end
    if flag == 1
        break;
    end
end
%以最上方的点为起始点进行搜索
MAXNUM = 99999;
EdgeCount = 0;%边缘点得个数
EdgeLoc = zeros(MAXNUM,2);
%把最上方的点加入边缘点数组
EdgeCount = EdgeCount + 1;
EdgeLoc(EdgeCount,1) = highest_i;
EdgeLoc(EdgeCount,2) = highest_j;
current_i = highest_i;%记录当前点得坐标
current_j = highest_j;
next_i = -1;%记录边缘上的与当前点相邻的下一个点得坐标
next_j = -1;
direct = zeros(8,2);%记录搜索方向：8个
direct(1,1) = 0;
direct(1,2) = 1;
direct(2,1) = 1;
direct(2,2) = 1;
direct(3,1) = 1;
direct(3,2) = 0;
direct(4,1) = 1;
direct(4,2) = -1;
direct(5,1) = 0;
direct(5,2) = -1;
direct(6,1) = -1;
direct(6,2) = -1;
direct(7,1) = -1;
direct(7,2) = 0;
direct(8,1) = -1;
direct(8,2) = 1;
while next_i ~= highest_i || next_j ~= highest_j
    if current_i == highest_i && current_j == highest_j
        direct_index = 1;%记录搜索方向:起始点，搜索方向从1开始
    end
    while 1 == 1%按序搜索
        next_i = current_i + direct(direct_index,1);
        next_j = current_j + direct(direct_index,2);
        if I(next_i,next_j) == 255%搜索到下一个边缘点
            EdgeCount = EdgeCount + 1;
            EdgeLoc(EdgeCount,1) = next_i;
            EdgeLoc(EdgeCount,2) = next_j;
            break;
        end
        direct_index = direct_index + 1;
        if direct_index > 8
            direct_index = direct_index - 8;
        end
    end
    %更新变量的值
    current_i = next_i;
    current_j = next_j;
    direct_index = direct_index - 2;%逆时针旋转90度
    if direct_index < 1
        direct_index = direct_index + 8;
    end
end
ImageEdge = zeros(height,width);
for i = 1:EdgeCount
    ImageEdge(EdgeLoc(i,1),EdgeLoc(i,2)) = 255;
end
figure,imshow(ImageEdge)
```
运行结果：
读入的一幅用Windows7自带画图工具随手画得图像（白色背景、黑色前景，程序中进行了处理，转化为了黑色背景，白色前景）：
![](http://hi.csdn.net/attachment/201112/9/0_13234375478ZI9.gif)
![](http://hi.csdn.net/attachment/201112/9/0_1323437380KhuW.gif)
检测出来的边缘：
![](http://hi.csdn.net/attachment/201112/9/0_1323437436kyoo.gif)
