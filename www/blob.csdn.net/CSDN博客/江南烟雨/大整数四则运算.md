# 大整数四则运算 - 江南烟雨 - CSDN博客
2010年07月10日 22:40:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2355
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
////1. 输入形式为：A[空格或换行]O[空格或换行]B;  
//// 2. 1中A、B为大数，O为运算符（如输入：123456789 / 432432);  
//// 3. 既然处理大数，就没必要输入小数点位了;  
//// 4.加减不能处理负号，乘除可以;  
//// 5. 用于学习交流，若发现错误或不妥之处可联系 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
#include<iostream>  
#include<string>  
using namespace std;  
class BigFigure{  
    string num1,num2;  
    string outcome;  
    int precision;  
    char operation;  
public:  
    BigFigure(){  
        num1=num2="0";  
        outcome="0";  
        precision=5;  
    }  
    string& plus(string &, string &);  
    string& subtration(string &, string &);  
    string& multiplication(string &, string &);  
    string& division(string &, string &);  
    void show();  
    void BigFigureInterface();  
    string &revese(string&);  
    friend istream& operator>>(istream& i, BigFigure& a){  
         return i>>a.num1>>a.operation>>a.num2;  
    }  
    ~BigFigure(){ }  
};  
void BigFigure::show(){  
    cout<<"Result: "<<outcome<<endl;  
}  
void BigFigure::BigFigureInterface(){  
    BigFigure a;  
    cout<<"*********************************************************/n";  
    cout<<"      Welcome...                                     /n";  
    cout<<"            Four Arithmetic Operations of Big Figures/n";  
    cout<<"*********************************************************/n/n";  
    cout<<"Notes:/n";  
    cout<<"       1. 输入形式为：A[空格或换行]O[空格或换行]B。/n";  
    cout<<"       2. 1中A、B为大数，O为运算符（如输入：123456789 / 432432)。/n";  
    cout<<"       3. 既然处理大数，就没必要输入小数点位了。/n";  
    cout<<"       4. 加减不能处理负号，乘除可以。/n";  
    cout<<"       5. 用于学习交流，若发现错误可联系519916178@qq.com。/n/n";  
    cout<<"Now Start, Input 0 0 0 to end if you want to quit!/n/n";  
    cout<<"[BigFigure #] ";  
    cin>>a;  
    while(a.operation!='0'){  
        switch(a.operation){  
            case '+': a.plus(a.num1, a.num2);  
                      a.show(); break;  
            case '-': a.subtration(a.num1, a.num2);  
                      a.show(); break;  
            case '*': a.multiplication(a.num1, a.num2);  
                      a.show(); break;  
            case '/': a.division(a.num1, a.num2);  
                      a.show(); break;  
            default:cout<<a.operation<<" is not Arithmetic Operation./n";  
        }  
        cout<<"[BigFigure #] ";  
        cin>>a;  
    }  
    system("cls");  
    cout<<"/n/n/n/n/n/n/t/t Quited.../n/n/n/n/n/n/n";  
    system("pause");  
}  
  
string&  BigFigure::revese(string& s){  
    char c;  
    int t=s.size();  
    for(int i=0; i<t/2; i++){  
        c=s[i];  
        s[i]=s[t-i-1];  
        s[t-i-1]=c;  
    }  
    return s;  
}  
string& BigFigure::plus(string &str1, string &str2){//加法运算，未处理符号  
    int min=0,i,t=0;  
    string temp;  
    outcome.clear();  
    str1=revese(str1);  
    str2=revese(str2);  
    min=str1.size()<str2.size() ? str1.size() : str2.size();  
    for(i=0; i<min; i++){  
        temp+=(str1[i]+str2[i]-96+t)%10+48;  
        t=(str1[i]+str2[i]-96+t)/10;  
    }  
    if(min==str1.size()){  
        while(i<str2.size()){  
            temp+=(str2[i]+t-48)%10+48;  
            t=(str2[i]-48+t)/10;  
            i++;  
        }  
        if(t) temp+='1';  
    }  
    else{  
         while(i<str1.size()){  
            temp+=(str1[i]+t-48)%10+48;  
            t=(str1[i]-48+t)/10;  
            i++;  
        }  
        if(t) temp+='1';  
    }  
    outcome=revese(temp);  
    return outcome;  
}  
  
string &BigFigure::subtration(string &str1, string &str2){//减法运算，未处理符号  
    int min=0,flag,i,t=0;  
    string temp;  
    outcome.clear();  
    if(str1.size()>str2.size() || (str1.size()==str2.size() && str1.compare(str2)==1)){  
        str1=revese(str1);  
        str2=revese(str2);  
        flag=0;  
        min=str2.size();  
    }  
    else if(str1.size()==str2.size()){  
              if(!str1.compare(str2)){  
                   outcome='0';  
                   return outcome;  
               }  
               if(str1.compare(str2)==-1){  
                   temp=str1;  
                   str1=revese(str2);  
                   str2=revese(temp);  
                   flag=1;  
                   min=str2.size();  
                }  
    }  
    else{  
        temp=str1;  
        str1=revese(str2);  
        str2=revese(temp);  
        flag=1;  
        min=str2.size();  
    }  
    temp.clear();  
    for(i=0; i<min; i++){  
        if(str1[i]-t<str2[i]){  
            temp+=str1[i]+10-t-str2[i]+48;  
            t=1;  
        }  
        else{  
            temp+=str1[i]-t-str2[i]+48;  
            t=0;  
        }  
    }  
    while(i<str1.size()){  
        if(!t){  
            while(i<str1.size()){  
                temp+=str1[i];  
                i++;  
            }  
            break;  
        }  
        if(str1[i]!='0'){ temp+=str1[i]-t; t=0; }  
        else temp+='9';  
        i++;  
    }  
    string s;  
    for(unsigned int k=temp.size()-1; k>=0; k--){  
        if(temp[k]!='0'){  
            for(int n=k; n>=0; n--)  
                s+=temp[n];  
            break;  
        }  
    }  
    if(flag) s='-'+s;  
    outcome=s;  
    return outcome;  
}  
string& BigFigure::multiplication(string &str1, string &str2){//乘法运算，已处理符号  
    char c='0',flag=0;  
    string temp1,temp2="0";  
    if(str1[0]=='0' || str2[0]=='0'){  
        outcome="0";  
        return outcome;  
    }  
    if(str1[0]=='-'){ flag++; str1.erase(0,1); }  
    if(str2[0]=='-'){ flag++; str2.erase(0,1); }  
    str1=revese(str1);  
    str2=revese(str2);  
    for(unsigned int i=0; i<str2.size(); i++){  
        c='0';  
        for(unsigned int j=0; j<str1.size(); j++){  
            temp1+=((str2[i]-48)*(str1[j]-48)+c-48)%10+48;  
            c=((str2[i]-48)*(str1[j]-48)+c-48)/10+48;  
        }  
        if(c!='0') temp1+=c;  
        temp1=revese(temp1);  
        for(int k=0; k<i; k++)  
            temp1+='0';  
        temp2=plus(temp1, temp2);  
        temp1.clear();  
    }  
    if(flag%2) temp2='-'+temp2;  
    outcome=temp2;  
    return outcome;  
}  
  
string& BigFigure::division(string &str1, string &str2){//除法运算，已处理符号  
    int str=0,flag=0,flag1=0,flag2=0;  
    string temp,temps,tempt;  
    if(str2=="0"){  
        outcome="Inf";  
        return outcome;  
    }  
    if(str2=="1" || str1=="0"){  
        outcome=str1;  
        return outcome;  
    }  
    if(str1[0]=='-'){ flag++; str1.erase(0,1); }  
    if(str2[0]=='-'){ flag++; str2.erase(0,1); }  
    for(unsigned int i=0; i<str1.size(); i++){//整除处理  
        str=0;  
        temp+=str1[i];  
        if(temp[0]=='0') temp.erase(0,1);  
        if(temp.size()>str2.size() ||  
              (temp.size()==str2.size() && temp.compare(str2)>=0)){  
            while(temp.size()>str2.size() ||  
                 (temp.size()==str2.size() && temp.compare(str2)>=0)){  
                tempt=str2;  
                temp=subtration(temp, tempt);  
                str++;  
            }  
            temps+=str+48;  
        }  
        else if(temp.size()==str2.size() && temp.compare(str2)==0) temps+='1';  
        else temps+='0';  
    }  
    flag1=temps.size();  
    if(temp!="0" && precision) temps+='.';  
    for(int i=0; i<=precision && temp!="0"; i++){//小数后位的处理  
        str=0;  
        temp+='0';  
        if(temp.size()>str2.size() ||  
               (temp.size()==str2.size() && temp.compare(str2)>=0)){  
            while(temp.size()>str2.size() ||  
                    (temp.size()==str2.size() &&temp.compare(str2)>=0)){  
                tempt=str2;  
                temp=subtration(temp, tempt);  
                str++;  
            }  
            temps+=str+48;  
        }  
        else if(temp.size()==str2.size() && temp.compare(str2)==0) temps+='1';  
        else temps+='0';  
    }  
    flag2=temps.size()-2;  
    if(temps[temps.size()-1]>='5' && flag2-flag1==precision){//四舍五入处理  
        temps.erase(flag1,1);  
        temps.erase(temps.size()-1, 1);  
        temp="1";  
        temps=plus(temps, temp);  
        if(temps.size()>flag2) temps.insert(flag1+1, 1, '.');  
        else temps.insert(flag1, 1, '.');  
    }  
    else if(flag2-flag1==precision) temps.erase(temps.size()-1, 1);  
    temp.clear();  
    for(unsigned int k=0; k<temps.size(); k++){//左端去零处理  
        if(temps[k]!='0' || temps[k+1]=='.'){  
            for(int n=k; n<temps.size(); n++)  
                temp+=temps[n];  
            break;  
        }  
    }  
    if(flag%2) temp='-'+temp;  
    outcome=temp;  
    return outcome;  
}  
int main(){//主函数  
    BigFigure a;  
    a.BigFigureInterface();  
    return 0;  
}  
