# 华科计算机考研复试机试【零散大汇总】 - 江南烟雨 - CSDN博客
2011年03月14日 09:32:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2898
【1】
屏幕的格式化输出：给出一幅图形，用程序实现。如下所示。
![](http://hi.csdn.net/attachment/201103/14/0_1300066333zNbB.gif)
我的代码：
#include<stdio.h>
int main(){
	char c;
	int sum,i,j;
	while(scanf("%c",&c)!=EOF){
		sum=c-'A'+1;
		for(i=0;i<sum;i++){
			for(j=0;j<2*(sum-1-i);j++){
				printf(" ");//输出前边的空格；
			}
			for(j=0;j<=i;j++){
				printf("%c",'A'+j);//输出前边一串字符串；
			}
			for(j=0;j<i;j++){
				printf("  ");//输出中间的字符串；
			}
			for(j=i;j>=0;j--){
				printf("%c",'A'+j);
			}
			printf("/n");
		}
		for(i=sum-2;i>=0;i--){
			for(j=0;j<2*(sum-1-i);j++){
				printf(" ");//输出前边的空格；
			}
			for(j=0;j<=i;j++){
				printf("%c",'A'+j);//输出前边一串字符串；
			}
			for(j=0;j<i;j++){
				printf("  ");//输出中间的字符串；
			}
			for(j=i;j>=0;j--){
				printf("%c",'A'+j);
			}
			printf("/n");
		}
		getchar();//接受回车符；
	}
}
数据测试：
![](http://hi.csdn.net/attachment/201103/14/0_1300066344xqmU.gif)
【2】已知二叉树的前序和中序序列，要求写出后序序列。如果不能构成一棵树，输出：“No Answer!”
参考代码：
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
typedef struct node{
        char data;
        struct node *lchild,*rchild;
}BTNode,*BTree;
BTree createBTree(char *pre,int st1,int en1,char *in,int st2,int en2){
	BTree boot;
	boot=(BTree)malloc(sizeof(BTNode));
	int temp;
	temp=st2;
	int len_left;//左子树长度；
	//printf("***/n");
	if((en2-st2)!=(en1-st1)){
		printf("No Answer!/n");//不能构成一棵树； 
		exit(0);
	}
	if(en1-st1<0||en2-st2<0){
		boot=NULL;
		return boot;
	}
	while(temp<=en2&&in[temp]!=pre[st1]){
          temp++;                    
    }
    if(temp>en2){//注意：没有等号！
         printf("No Answer!/n");//不能构成一棵树； 
		 exit(0);        
    }
	boot->data=pre[st1];
	len_left=temp-st2;
	boot->lchild=createBTree(pre,st1+1,st1+len_left,in,st2,temp-1);//构造左子树； 
	boot->rchild=createBTree(pre,st1+len_left+1,en1,in,temp+1,en2);//构造左子树； 
	return boot;
}
void display(BTree T){//后序遍历二叉树；
	if(T!=NULL){
		display(T->lchild);
		display(T->rchild);
		printf("%c",T->data);
		free(T);//释放结点指针；
	}
}
int main(){
	char pre[1000],in[1000];
	int len1,len2;
	BTree T;
	T=(BTree)malloc(sizeof(BTNode));
	while(scanf("%s%s",pre,in)!=EOF){
		len1=strlen(pre);
		len2=strlen(in);
		T=createBTree(pre,0,len1-1,in,0,len2-1);
		display(T);
		printf("/n");
	}
	//system("pause");
}
数据测试：
![](http://hi.csdn.net/attachment/201103/15/0_1300195354tdlF.gif)
![](http://hi.csdn.net/attachment/201103/20/0_1300611102i8ET.gif)
【3】
1 生成一个长度为21的数组，依次存入1到21 
2 建立一个长度为21的单向链表，将上述数组中的数字依次存入链表每个结点中
3 将上述链表变为单向封闭（循环）链表
4 从头结点开始数，将第17个结点删除，将它的下一个结点作为新的头结点
5 重复上述过程，直到该链表中只剩一个结点，显示该结点中存入的数字
参考代码：
#include<stdio.h>
#include<stdlib.h>
typedef struct node{
	int data;
	struct node *next;
}LNode,*LinkList;
LinkList createList(int a[],int len){//创建单链表；
	LinkList L,p,r;
	int i;
	if(len<=0){
		return NULL;
	}
	L=(LinkList)malloc(sizeof(LNode));
	L->data=a[0];
	p=L;
	for(i=1;i<len;i++){
		r=(LinkList)malloc(sizeof(LNode));
		r->data=a[i];
		p->next=r;
		p=r;
	}
	p->next=NULL;//表尾；
	return L;
}
LinkList changeList(LinkList L){//把单链表变成单循环链表；
	LinkList p;
	p=L;
	while(p->next!=NULL){
		p=p->next;//p移至表尾；
	}
	p->next=L;
	return L;
}
LinkList deleteLNode(LinkList L){//从链表中删除结点；
	LinkList p,r;
	int count=1;
	p=L;
	while(count<=16){
		r=p;//r指向前驱；
		p=p->next;//p移至第17个结点；
		count++;
	}
	r->next=p->next;
	free(p);
	return r->next;//新的头结点；
}
void display(LinkList L){//输出单链表；
	if(L!=NULL){
		LinkList p;
		p=L;
		while(p!=NULL){
			printf("%d ",p->data);
			p=p->next;
		}
	}
}
int main(){
	int a[21],i;
	LinkList L,p;
	for(i=0;i<21;i++){
		a[i]=i+1;
	}
	L=createList(a,21);
	L=changeList(L);
	//L=deleteLNode(L);
	while(L->next!=L){
		L=deleteLNode(L);
	}
	printf("链表中最后剩下的结点是：%d/n",L->data);
	//display(L);
}
数据测试：
![](http://hi.csdn.net/attachment/201103/16/0_1300274438pw07.gif)
【4】对输入的5个数排序，输出的结果到文件里。
参考代码：
#include<stdio.h>
#include<stdlib.h>
int cmp(const void *a,const void *b){
 return (*(int *)a)-(*(int *)b);
}
int main(){
 int a[5],i;
 //char s[5];
 FILE *foutput;
 printf("请输入5个待排序的数：/n");
 for(i=0;i<5;i++){
  scanf("%d",&a[i]);
 }
 qsort(a,5,sizeof(int),cmp);
 if((foutput=fopen("0000华科复试机试题(4).txt","w"))==NULL){
  printf("File open error!/n");
 }
 for(i=0;i<5;i++){
  fputc(a[i]+'0',foutput);
 }
 fclose(foutput);
}
数据测试：
![](http://hi.csdn.net/attachment/201103/18/0_1300454355dZ9p.gif)
