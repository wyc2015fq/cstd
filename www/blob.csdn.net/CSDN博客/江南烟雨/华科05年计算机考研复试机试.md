# 华科05年计算机考研复试机试 - 江南烟雨 - CSDN博客
2011年03月12日 20:45:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：1858
【1】
第一题：对给定的一个字符串，找出有重复的字符，并给出其位置，如：
输入：abcaaAB12ab12
输出：a，1；a，4；a，5；a，10
b，2；b，11
1，8；1，12
2，9；2，13
参考代码：
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int main(){
    char s[1000];
    int len,i,j,k,flag,cnt,a[1000],temp;
    while(gets(s)!=NULL){
          len=strlen(s);
          for(i=0;i<len;i++){
               flag=0;//标记是否出现重复。
               cnt=0;//记录重复出现次数。 
               temp=0;//记录字符是否在前已经出现过。
               for(k=0;k<i-1;k++){
                   if(s[k]==s[i]){
                        temp=1;          
                   }              
               } 
               for(j=i+1;j<len;j++){
                     if(s[j]==s[i]&&temp==0){
                           flag=1;
                           a[cnt++]=j;//记录重复出现的下标。         
                     }               
               }
               if(flag==1){
                      printf("%c,%d;",s[i],i+1); 
                      for(j=0;j<cnt;j++){
                           printf("%c,%d;",s[a[j]],a[j]+1);               
                      } 
                      printf("/n");   
               }              
          }               
    }
}
数据测试：
![](http://hi.csdn.net/attachment/201103/12/0_1299933910fU4y.gif)
【2】
输入一个四行五列的矩阵，找出每列最大的两个数，如：
输入： 12498
-1 4 9 8 8
12 9 8 7 0
7 8 9 7 0
输出：12 9 9 8 9
7 8 9 7 8
参考代码：
#include<stdio.h>
#include<stdlib.h>
int cmp(const void *a,const void *b){//qsort的比较函数；
	return (*(int *)a)-(*(int *)b);
}
int main(){
	int a[4][5],i,j,b[5][4];
	for(i=0;i<4;i++){
		for(j=0;j<5;j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(i=0;i<5;i++){
		for(j=0;j<4;j++){
			b[i][j]=a[j][i];//逆置数组a；
		}
	}
	for(i=0;i<5;i++){
		qsort(b[i],4,sizeof(int),cmp);
		printf("%d %d/n",b[i][2],b[i][3]);
	}
}
数据测试：
![](http://hi.csdn.net/attachment/201103/12/0_1299935198eLOe.gif)
 【3】
第三题：输入一个字符串，建立一个二叉排序树，并中序遍历输出；
参考代码：
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
typedef struct node{//二叉树结点数据结构定义；
	char value;
	struct node *lchild,*rchild;
}BTNode,*BTree;
void insertNode(BTree &t,char c){//向二叉排序树中插入节点；
	BTree p,q,temp;
	p=(BTree)malloc(sizeof(BTNode));
	p->value=c;
	p->lchild=NULL;//貌似没有这2行不行，纠结了半天啊！！！ 
	p->rchild=NULL;
	if(t==NULL){
		t=p;
	}
	else{
	q=t;
	while(q!=NULL){
		temp=q;
		if(c<q->value){
			q=q->lchild;
		}
		else{
			q=q->rchild;
		}
	}
	if(c<temp->value){
		temp->lchild=p;
	}
	else{
		temp->rchild=p;
	}
    }
}
void inOrderTra(BTree t){//中序遍历二叉排序树；
	if(t!=NULL){
		inOrderTra(t->lchild);
		printf("%c ",t->value);
		inOrderTra(t->rchild);
	}
}
int main(){
	char s[1000];
	int len,i;
	while(gets(s)!=NULL){
	    len=strlen(s);
	    BTree t;
	    t=NULL;
	    for(i=0;i<len;i++){
		    insertNode(t,s[i]);
	    }
	    inOrderTra(t);
	    printf("/n");
    }
}
数据测试：
![](http://hi.csdn.net/attachment/201103/12/0_1299937962QYAv.gif)
