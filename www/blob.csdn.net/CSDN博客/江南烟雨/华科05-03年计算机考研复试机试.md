# 华科05-03年计算机考研复试机试 - 江南烟雨 - CSDN博客
2011年02月23日 14:41:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2463标签：[struct																[null																[数据结构																[system																[测试																[input](https://so.csdn.net/so/search/s.do?q=input&t=blog)](https://so.csdn.net/so/search/s.do?q=测试&t=blog)](https://so.csdn.net/so/search/s.do?q=system&t=blog)](https://so.csdn.net/so/search/s.do?q=数据结构&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=struct&t=blog)
个人分类：[华科计算机考研复试](https://blog.csdn.net/xiajun07061225/article/category/790315)
【1】输入一个数列以0为结束标志，建立链式线性表，查找其中最大的数并输出删除释放节点，然后对剩余的进行排序，并输出释放节点。
参考代码：
#include<stdio.h>
#include<stdlib.h>
typedef struct LinkNode{//链表结点结构体定义； 
        int data;
        struct LinkNode *next;  
}LinkNode,*SqList;
void createList(SqList &L){//创建单链表的函数； 
     SqList p=L,q,s;
     int value;
     scanf("%d",&value);
     if(value==0)return;
     L->data=value;
     s=NULL;
     while(1){
         int v;
         scanf("%d",&v);
         if(v==0)
              return;   
         q=(SqList)malloc(sizeof(LinkNode));
         q->data=v;
         q->next=s;
         p->next=q;
         p=q;
     }
     L=L->next;
}
void display(SqList L){//输出单链表;
     SqList p=L;
     while(p->next!=NULL){
          printf("%d->",p->data); 
          SqList q=p->next;
          free(p);//释放结点； 
          p=q;         
     }
     printf("%d",p->data); 
     free(p);//释放结点； 
     printf("/n");
}
int getMax(SqList L){//获取最大结点值； 
    int MaxNum=0;
    SqList p=L;
    while(p!=NULL){
        if(p->data>MaxNum)MaxNum=p->data;  
        p=p->next;         
    }
    return MaxNum;
}
void freeMax(SqList &L){//释放此链表中值最大的结点；
     
     if(L!=NULL){ 
         SqList p,q;
         p=L;
         q=L->next;
         if(p->data==getMax(L)){
              free(p);
              L=q;                  
         }
         else{
              while(q!=NULL){
                   if(q->data==getMax(L)){
                         p->next=q->next;
                         free(q);   
                         break;              
                   }
                   p=q;
                   q=q->next;               
              }
         }
     } 
}
void sortList(SqList &L){//对链表结点进行排序； 
     SqList p,q;
     p=L;
     while(p->next!=NULL){
          q=p->next;
          while(q!=NULL){
               if(p->data>q->data){
                     int temp;
                     temp=p->data;
                     p->data=q->data;
                     q->data=temp;              
               }  
               q=q->next;       
          }  
          p=p->next;      
     }
}
int main(){
    SqList L;
    L=(SqList)malloc(sizeof(LinkNode));
    printf("创建链表：/n");
    createList(L);
    int maxnumber; 
    maxnumber=getMax(L);
    printf("链表中结点的最大值：%d/n",maxnumber);
    
    freeMax(L);
    printf("释放值最大的结点后的链表：/n");
    //
    sortList(L);
    printf("对剩余结点进行排序后：/n");
    display(L);
    //printf("所创建的链表：/n");
    //display(L);
    system("pause");
}
【2】输入一个先序遍历数列以0为结束标志，建立二叉遍历树，并对其进行逆中序遍历，释放空间。
参考代码：
#include<stdio.h>
#include<stdlib.h>
typedef struct BiTNode{//二叉树数据结构定义； 
    int data;
    BiTNode *lchild,*rchild;    
}BiTNode,*BiTree;
BiTree CreateTree(){//创建二叉树； 
    int value;
    BiTree t;
    scanf("%d",&value);
    if(value==0)return NULL;
    else{
         t=(BiTree)malloc(sizeof(BiTNode));
         t->data=value;
         t->lchild=CreateTree();
         t->rchild=CreateTree();
         return t;
    }   
} 
void ReInOrder(BiTree t){//逆中序遍历二叉树； 
     if(t!=NULL){
          ReInOrder(t->rchild);
          printf("%d ",t->data);
          ReInOrder(t->lchild);   
          free(t);    
     }
}
int main(){
    BiTree t;
    printf("请按序输入二叉树结点的值(以0为标志结束)：/n");
    t=CreateTree();
    printf("逆中序遍历二叉树：/n");
    ReInOrder(t);
    system("pause");
}
数据测试：
![](http://hi.csdn.net/attachment/201102/23/0_1298444074oDVY.gif)
【3】给出年分m和一年中的第n天，算出第n天是几月几号（提示中给出了判断闰年的方法），按 yyyy-mm-dd的格式打印出来；
参考代码：
**#include<stdio.h>#include<stdlib.h>int ping[12]={31,28,31,30,31,30,31,30,31,30,31,30};int run[12]={31,29,31,30,31,30,31,30,31,30,31,30};int main(){    int m,n,flag,i,day,days;    while(scanf("%d %d",&m,&n)!=EOF){          if(m%400==0)flag=1;          else if(m%4==0&&m%100!=0)flag=1;          else flag=0;          if(flag==1){//是闰年                days=0;               for(i=0;i<12;i++){                   days+=run[i];                   if(days>=n){                          break;                   }                         }                if(i<12){                   days=days-run[i];                   day=n-days;                   printf("%d-%d-%d/n",m,i+1,day);                    }                 else printf("illegal input!/n");              }           else if(flag==0){//是平年;                days=0;               for(i=0;i<12;i++){                   days+=ping[i];                   if(days>=n){                          break;                   }                         }                if(i<12){                   days=days-ping[i];                   day=n-days;                   printf("%d-%d-%d/n",m,i+1,day);                    }                 else printf("illegal input!/n");              }             }    system("pause");}**
数据测试：
**![](http://hi.csdn.net/attachment/201102/23/0_1298445642l1lC.gif)**
【4】职工有职工号，姓名，年龄.输入n个职工的信息，找出3个年龄最小的职工打印出来。
代码：
#include<stdio.h>
#include<stdlib.h>
struct node{//职工信息数据结构； 
       int id;//职工号； 
       char name[20];//姓名 
       int age;//年龄； 
}emp[1000];
int cmp(const void *a,const void *b){//比较函数； 
    return (*(struct node *)a).age-(*(struct node *)b).age;
}
int main(){
    int n,i;
    printf("请输入职工数及其各职工的职工号、姓名、年龄:/n");
    scanf("%d",&n);
    for(i=0;i<n;i++){
          scanf("%d %s %d",&emp[i].id,emp[i].name,&emp[i].age);           
    }
    qsort(emp,n,sizeof(node),cmp);
    printf("年龄最小的三位职工是:/n");
    for(i=0;i<3;i++){
           printf("%d %s %d/n",emp[i].id,emp[i].name,emp[i].age);          
    }
}
数据测试：
![](http://hi.csdn.net/attachment/201102/27/0_12988046673C21.gif)
【5】n个人排一圈123报数，报到3的人退到圈外，直到剩最后一个人为止。
代码：
#include<stdio.h>
#include<stdlib.h>
typedef struct node{//链表结点数据结构定义； 
       int data;
       struct node *next;
}LNode,*LinkList;
void Josephus(int n,int k,int m){//约瑟夫环问题；n：人数，k：开始计数位置，m：数到几退出一个人； 
     LinkList p,q,r;//p指向表头； 
     int i,cnt;
     p=(LinkList)malloc(sizeof(LNode));
     p->data=1;
     p->next=NULL;
     q=p;
     for(i=2;i<=n;i++){//创建单循环链表； 
          r=(LinkList)malloc(sizeof(LNode));
          r->data=i;
          r->next=NULL;
          q->next=r;
          q=q->next;             
     }
     q->next=p;
     for(i=1;i<k;i++){
         q=p;//q始终指向前驱； 
         p=p->next; //p移到开始的结点；            
     }
     cnt=1;
     while(q->next!=q){
          cnt++;
          q=p;
          p=p->next;
          if(cnt%m==0){//将要退出一个人； 
                printf("%d ",p->data);
                q->next=p->next;
                p=p->next;
                cnt++;       
          }          
     }
     printf("%d/n",q->data);
}
int main(){
    int n,k;
    printf("请输入人数n、从谁开始数k:/n");
    scanf("%d %d",&n,&k);
    Josephus(n,k,3);
    system("pause");
}
数据测试：
![](http://hi.csdn.net/attachment/201102/27/0_1298806967lD2O.gif)
【7】建立二叉树,并中序遍历。
代码：
#include<stdio.h>
#include<stdlib.h>
typedef struct node{
     int data;
     node *lchild,*rchild;   
}BTNode,*BiTree;
BiTree createBiTree(){//创建二叉树； 
     int value;
     BiTree T;
     T=(BiTree)malloc(sizeof(BTNode));
     scanf("%d",&value);
     if(value!=0){
          T->data=value;
          T->lchild=createBiTree();
          T->rchild=createBiTree(); 
          return T;      
     }
     else{
          return NULL;
     }
}
void InOrderTraverse(BiTree T){//中序遍历二叉树； 
     if(T!=NULL){  
           InOrderTraverse(T->lchild);
           printf("%d ",T->data);   
           InOrderTraverse(T->rchild);
           free(T);
     }                  
}
int main(){
    BiTree T=createBiTree();
    InOrderTraverse(T);
    system("pause");
}
数据测试：
![](http://hi.csdn.net/attachment/201102/27/0_1298808231Z5Ni.gif)
 【8】生成一个长度为21的数组，依次存入1到21；建立一个长度为21的单向链表，将上述数组中的数字依次存入链表每个结点中；将上述链表变为单向封闭(循环)链表；从头结点开始数，将第17个结点删除，将它的下一个结点作为新的头结点；重复上述过程，直到该链表中只剩一个结点，显示该结点中存入的数字。
分三个文件，一个main; 一个.h; 一个.c 文件。
参考代码：
count21.h文件：
#ifndef COUNT_21_H_INCLUDED
#define COUNT_21_H_INCLUDED
#define NUM 21//链表节点数； 
typedef struct node{//链表结点数据结构定义； 
     int data;
     struct node *next;   
}LNode,*LinkList;
LinkList CreateList();//创建单循环链表；  
#endif
count21.c文件：
#include<stdio.h>
#include<stdlib.h>
#include"Count21.h"
LinkList CreateList(){//建立单循环链表； 
      LinkList L,p,q;
      int i;
      L=(LinkList)malloc(sizeof(LNode));
      p=L;
      L->data=1;
      L->next=NULL;
      for(i=2;i<=NUM;i++){
           q=(LinkList)malloc(sizeof(LNode));
           q->data=i;
           q->next=NULL;
           p->next=q;
           p=p->next;               
      }
      p->next=L;//构成循环链表；
      return L;   
}
main.c文件：
#include<stdio.h>
#include<stdlib.h>
#include"Count21.h"
int main(){
    LinkList L,p,q;
    L=CreateList();
    p=L;//p指向当前节点；
    q=L; 
    while(q->next!=L){
          q=q->next;            
    }//q指向前驱； 
    int cnt=1;
    while(q->next!=q){
         cnt++;
         q=p;
         p=p->next;             
         if(cnt%17==0){
              printf("%d ",p->data);
              q->next=p->next;
              p=p->next;
              cnt++;         
         }
    }
    printf("%d/n",p->data);
    system("pause");
}
数据测试：
![](http://hi.csdn.net/attachment/201102/28/0_129889417240Rd.gif)

