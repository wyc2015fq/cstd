# 【C++基础学习】引起类模板被实例化情形总结 - 江南烟雨 - CSDN博客
2012年02月17日 19:31:30[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2596
在我们使用类模板时，只有当代码中使用了类模板的一个实例的名字，而且上下文环境要求必须存在类的定义时，这个类模板才被实例化。并不是每次使用一个类都要求知道该类的定义。
（1）声明一个类模板的指针和引用，不会引起类模板的实例化，因为没有必要知道该类的定义。例如：
```cpp
class Matrix;
Matrix *pm;//不需要类的定义
void inverse(Matrix &);//也不需要类的定义
```
以及
```cpp
void foo(Queue<int> &qi)
{
	Queue<int> *pqi = &qi;
	//...
}
```
但是如果检查这个指针或引用所值的那个对象时，类模板才会被实例化。比如在上例中，如果指针pqi被解引用，qi被用来获得它所指向的对象值，或者pqi或qi被用来访问Queue<int>的数据成员或成员函数时，Queue<int>才会被实例化。
```cpp
void foo(Queue<int> &qi)
{
	Queue<int> *pqi = &qi;
	//因为成员函数被调用，所以Queue<int>被实例化
	pqi ->add(255);
	//...
}
```
（2）定义一个类类型的对象时需要该类的定义，因此类模板会被实例化、例如：
```cpp
class Matrix;
Matrix obj1;//Error
class Matrix{...};
Matrix obj1;//OK
```
下面的例子中，对象qi的定义引起类模板Queue<int>被实例化：
```cpp
Queue<int> qi;
```
（3）在使用sizeof()时，它是计算对象的大小，编译器必须根据类型将其实例化出来，所以类模板被实例化：
```cpp
int iobj = sizeof(Stack<string>);
```
（4）new表达式要求类模板被实例化。
Queue<int> *p_qi = new Queue<int>;
（5）引用类模板的成员会导致类模板被编译器实例化。
（6）需要注意的是，类模板的成员函数本身也是一个模板。标准C++要求这样的成员函数只有在被调用或者取地址的时候，才被实例化。（在标准C++之前有些编译器在实例化类模板时，就实例化类模板的成员函数。）用来实例化成员函数的类型，就是其成员函数要调用的那个类对象的类型。
