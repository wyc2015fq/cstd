# 华科10年保送生计算机考研复试机试  - 江南烟雨 - CSDN博客
2011年02月27日 20:37:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2719
【1】不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。
貌似比较简单，这是我写的代码，也不知道是否正确。
仅供参考！
代码：
#include<stdio.h>
#include<stdlib.h>
int main(){
    char s1[200],s2[100];
    int i,len1,len2;
    scanf("%s %s",s1,s2);
    for(i=0;i<200;i++){
         if(s1[i]=='/0'){
            len1=i;
            break;
         }              
    }
    for(i=0;i<100;i++){
         if(s2[i]=='/0'){
            len2=i;
            break; 
         }             
    }
    for(i=len1;i<len1+len2;i++){
          s1[i]=s2[i-len1];                      
    }
    printf("%s/n",s1);
    system("pause"); 
}
数据测试：
![](http://hi.csdn.net/attachment/201102/27/0_12988102431taD.gif)
【2】建立平衡二叉树，并中序遍历。
copy别人的代码，感觉这道题好难...
代码：
#include <stdio.h>
#include <stdlib.h>
//节点数据结构
struct node{
int val;//值
int bf;//平衡因子
struct node* left;
struct node* right;
};
 
struct node* root;
//struct node* top;
//获得父节点的函数
struct node* GetFather(struct node* son){
	struct node* temp;
	if(son==root)
		return NULL;
	temp=root;
	while(1){
		if(temp==NULL)
			return NULL;
		else if(son->val<=temp->val){
			if(temp->left == son)
				return temp;
			else{
				temp = temp->left;
				continue;
			}
		}
		else if(son->val>temp->val){
			if(temp->right == son)
				return temp;
			else{
				temp = temp->right;
				continue;
			}
		}
	}
}
 
//LL类型旋转
int RorateLL(struct node* inode, struct node* blance){
	struct node* father;
	struct node* left;
	left = blance->left;
	if(father=GetFather(blance)){
		if(blance->val<=father->val)
			father->left = left;
		else 
			father->right = left;
	}
	else
		root = left;
	left->bf = 0;
	blance->bf = 0;
	blance->left = left->right;
	left->right=blance;
	father = left->left;
	while(father!=inode){
		if(inode->val<=father->val){
			father->bf++;
			father = father->left;
		}
		else{
			father->bf--;
			father = father->right;
		}
 
	}
}
//RR类型旋转
int RorateRR(struct node* inode, struct node* blance){
	struct node* father;
	struct node* right;
	right = blance->right;
	if(father=GetFather(blance)){
		if(blance->val<=father->val)
			father->left = right;
		else 
			father->right = right;
	}
	else 
		root = right;
	right->bf = 0;
	blance->bf = 0;
	blance->right = right->left;
	right->left=blance;
	father = right->right;
	while(father!=inode){
		if(inode->val<=father->val){
			father->bf++;
			father = father->left;
		}
		else{
			father->bf--;
			father = father->right;
		}
 
	}
}
//LR类型旋转
int RorateLR(struct node* inode, struct node* blance){
	struct node* father;
	struct node* newtop;
	father = blance;
	while(father!=inode){
		if(inode->val<=father->val){
			father->bf++;
			father = father->left;
		}
		else{
			father->bf--;
			father = father->right;
		}
 
	}
 
	newtop = blance->left->right;
	if(father=GetFather(blance)){
 
		if(blance->val<=father->val)
			father->left = newtop;
		else 
			father->right = newtop;
	}
	else 
		root = newtop;
	blance->left->right = newtop->left;
	newtop->left = blance->left;
	blance->left = newtop->right;
	newtop->right=blance;
	if(newtop->bf == 0){
		newtop->left->bf==0;
		newtop->right->bf==0;
	}
	else if(newtop->bf == 1){
		newtop->left->bf==0;
		newtop->right->bf==-1;
	}
	else if(newtop->bf == -1){
		newtop->left->bf==1;
		newtop->right->bf==0;
	}
	return 1;
 
}
//RL类型旋转
int RorateRL(struct node* inode, struct node* blance){
	struct node* father;
	struct node* newtop;
	father = blance;
	while(father!=inode){
		if(inode->val<=father->val){
			father->bf++;
			father = father->left;
		}
		else{
			father->bf--;
			father = father->right;
		}
 
	}
 
	newtop = blance->right->left;
	if(father=GetFather(blance)){
 
		if(blance->val<=father->val)
			father->left = newtop;
		else 
			father->right = newtop;
	}
	else root=newtop;
	blance->right->left = newtop->right;
	newtop->right = blance->right;
	blance->right = newtop->left;
	newtop->left=blance;
	if(newtop->bf == 0){
		newtop->left->bf==0;
		newtop->right->bf==0;
	}
	else if(newtop->bf == 1){
		newtop->right->bf==0;
		newtop->left->bf==-1;
	}
	else if(newtop->bf == -1){
		newtop->right->bf==1;
		newtop->left->bf==0;
	}
	return 1;
 
}
//插入函数
int AvlInsert(struct node* inode){
	struct node* blance;
	struct node* temp;
	temp=root;
	while(1){
		if(temp->bf==1|temp->bf==-1)
			blance = temp;
		if(inode->val<=temp->val){
			if(temp->left){
				temp=temp->left;
				continue;
			}
			else{
				temp->left=inode;
				break;
			}
		}
		else if(inode->val>temp->val){
			if(temp->right){
				temp=temp->right;
				continue;
			}
			else{
				temp->right=inode;
				break;
			}
		}
	}
 
	if(!blance){
		temp=root;
		while(temp!=inode){
			if(inode->val<=temp->val){
				temp->bf++;
				temp=temp->left;
			}
			else{
				temp->bf--;
				temp=temp->right;
			}
 
		}
		return 1;
 
	}
	else{
		if(blance->bf==-1 && blance->val>=inode->val || blance->bf==1 && blance->val<inode->val){
			blance->bf=0;
			return 1;
		}
		else if(inode->val<=blance->val && inode->val<=blance->left->val)
			RorateLL(inode, blance);
		else if(inode->val<=blance->val && inode->val>blance->left->val)
			RorateLR(inode, blance);
		else if(inode->val>blance->val && inode->val<=blance->right->val)
			RorateRL(inode, blance);
		else if(inode->val>blance->val && inode->val>blance->right->val)
			RorateRR(inode, blance);
 
	}	
	return 1;
 
}
 
int AvlCreate(struct node* inode){
 
	if(!root){
		root = inode;
		return 1;
	}	
	AvlInsert(inode);
 
}
 
//打印整个树的函数
void Traveser(struct node* r)
{   
     if(r->left) Traveser(r->left);
     if(r) printf("%d, %d/n",r->val, r->bf);
     if(r->right) Traveser(r->right);   
}
 
int main(){
 
	int a;
	struct node* Node;
	while(1){
		scanf("%d",&a);
		if (a==-1)
			break;
		Node = malloc(sizeof(struct node));
		Node->val=a;
		Node->bf=0;
		Node->left=NULL;
		Node->right=NULL;
		AvlCreate(Node);
	}
	Traveser(root);
 
}
【3】有4个小问，是超长整数的存储、计算、输出。要把超长整数存在一个单向循环链表中，是每四位一个节点。
搞不清楚题目为啥要求用循环链表，我是用单链表写的....
参考代码：
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define MAXLEN 100
typedef struct node{
	int data;
	struct node *next;
}LNode,*LinkList;
int changeString(char s[],int len){//把字符串长度变成4的整数倍；
	int i,temp;
	char ss[MAXLEN];
	if(len%4!=0){
		temp=4-len%4;//需要在前面添加的0的个数；
		for(i=0;i<len;i++){
			ss[i]=s[i];
		}
		for(i=0;i<temp;i++){
			s[i]='0';
		}
		for(i=temp;i<temp+len;i++){
			s[i]=ss[i-temp];
		}
	}
	return temp;
}
LinkList createList(char *s,int len){//创建单链表；
	int i,temp,add_len;
	LinkList L,p,start;
	if(len<=0){
		return NULL;
	}
	add_len=changeString(s,len);
	len+=add_len;
	i=0;
	temp=0;
	while(i<4&&i<len){//给头结点赋值；
		temp=temp*10+s[i]-'0';
		i++;
	}
	L=(LinkList)malloc(sizeof(LNode));//头结点；
	L->data=temp;
	L->next=NULL;
	start=L;
	temp=0;
	while(i<len){//继续创建单链表；
		if((i+1)%4==1){//需新建一个结点；
			p=(LinkList)malloc(sizeof(LNode));
		}
		temp=temp*10+s[i]-'0';
		if((i+1)%4==0||i==len-1){//一个结点结束；
			p->data=temp;
			p->next=NULL;
			start->next=p;//插入结点；
			start=p;
			temp=0;//重新计数；
		}
		i++;
	}
	start->next=NULL;
	return L;
}
LinkList reverse(LinkList L){//逆转单循环链表；
	LinkList p,q,r;
	if(L!=NULL){
		p=L->next;
		L->next=NULL;
		while(p!=NULL){
			q=p;
			p=p->next;
			q->next=L;
			L=q;
			//printf("**%d/n",L->data);
		}
		
		return L;
	}
	return NULL;
}
void display(LinkList L){//打印输出单链表；
	LinkList p;
	printf("%d ",L->data);
	p=L->next;
	while(p!=NULL){
		printf("%d ",p->data);
		p=p->next;
	}
	printf("/n");
}
LinkList add_LNumber(LinkList L1,LinkList L2){//2大数相加，单链表实现；
	LinkList L,p,q,head,r;
	int c;//进位；
	int temp;
	L=(LinkList)malloc(sizeof(LNode));
	head=(LinkList)malloc(sizeof(LNode));
	head->next=NULL;
	L=head;
	p=L1;
	q=L2;
	c=0;
	while(p!=NULL&&q!=NULL){
		r=(LinkList)malloc(sizeof(LNode));
		temp=p->data+q->data+c;
		r->data=temp%10000;
		//printf("***%d/n",r->data);
		r->next=NULL;
		c=temp/10000;
		head->next=r;
		head=r;
		p=p->next;
		q=q->next;
	}
	while(p!=NULL){//L1剩余部分非空；
		r=(LinkList)malloc(sizeof(LNode));
		temp=p->data+c;
		r->data=temp%10000;
		r->next=NULL;
		c=temp/10000;
		head->next=r;
		head=r;
		p=p->next;
	}
	while(q!=NULL){//L2剩余部分非空；
		r=(LinkList)malloc(sizeof(LNode));
		temp=q->data+c;
		r->data=temp%10000;
		r->next=NULL;
		c=temp/10000;
		head->next=r;
		head=r;
		q=q->next;
	}
	if(c!=0){//还有进位；
		r=(LinkList)malloc(sizeof(LNode));
		r->data=c;
		r->next=NULL;
		head->next=r;
	}
	return L->next;
}
int main(){
	char s1[MAXLEN],s2[MAXLEN];
	int len1,len2,add_len,i;
	LinkList L1,L2,L;
	L1=(LinkList)malloc(sizeof(LNode));
	L2=(LinkList)malloc(sizeof(LNode));
	printf("请输入第一个大数：/n");
	scanf("%s",s1);
	len1=strlen(s1);
	L1=createList(s1,len1);
	printf("请输入第二个大数：/n");
	scanf("%s",s2);
	len2=strlen(s2);
	L2=createList(s2,len2);
	printf("输入的第一个大数：/n");
	display(L1);
	printf("输入的第二个大数：/n");
	display(L2);
	L1=reverse(L1);
	L2=reverse(L2);
	//display(L1);
	//display(L2);
	L=add_LNumber(L1,L2);
	//display(L);
	L=reverse(L);
	printf("大数之和：/n");
	display(L);
}
数据测试：
![](http://hi.csdn.net/attachment/201103/18/0_1300451025G1C6.gif)
