# HDOJ3791 二叉搜索树 - 江南烟雨 - CSDN博客
2011年03月08日 20:18:00[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：1624
题目：[http://acm.hdu.edu.cn/showproblem.php?pid=3791](http://acm.hdu.edu.cn/showproblem.php?pid=3791)
先建立二叉排序树，然后进行比较。比较时采用递归。
代码：
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct node{//树节点数据结构定义； 
     int data;
     struct node *left,*right;  
}*BiTree,BTNode;
void insert(BiTree &t, BiTree s)//插入节点； 
{
    if(s==NULL)return;
    BiTree p,temp;
    if(t==NULL){
         t=s;      
    }
    else{
         p=t;
         while(p!=NULL){
              temp=p;
              if(s->data<p->data){//往左； 
                    p=p->left;             
              }          
              else{//往右； 
                    p=p->right;
              }
         }
         if(s->data<temp->data){//插入到左子树； 
                temp->left=s;                
         }
         else{//插入到右子树； 
              temp->right=s;
         }
    }
}
int check(BiTree s,BiTree t){//比较两树是否相同；0表示相同，否则不相同； 
    if(s==NULL&&t==NULL){
         return 0;                
    } 
    else if((s==NULL&&t!=NULL)||(s!=NULL&&t==NULL)){
         return 1;
    }
    else{
         if(s->data!=t->data){
               return 1;               
         }
         else{
              return check(s->left,t->left)+check(s->right,t->right);
         }
    }
}
int main(){
    int n,len1,len2,i,result;
    char s[11],q[11];
    while(scanf("%d",&n)!=EOF){
           if(n==0)break;
           getchar();
           scanf("%s",s);
           len1=strlen(s);
           BiTree t;
           t=NULL;
           for(i=0;i<len1;i++)//建立示范序列的二叉树； 
           {
                 BiTree p;
                 p=(BiTree)malloc(sizeof(BTNode));
                 p->data=s[i]-'0';  
                 p->left=NULL;
                 p->right=NULL;
                 insert(t,p);                 
           }
           while(n--){
                 scanf("%s",q);
                 len2=strlen(q);
                 BiTree r;
                 r=NULL;
                 for(i=0;i<len1;i++)//建立示范序列的二叉树； 
                 {
                     BiTree p;
                     p=(BiTree)malloc(sizeof(BTNode));
                     p->data=q[i]-'0';  
                     p->left=NULL;
                     p->right=NULL;
                     insert(r,p);                 
                 }
                 result=check(r,t);
                 if(result==0){
                      printf("YES/n");         
                 }     
                 else{
                      printf("NO/n");
                 }
           }
                          
    }
}
