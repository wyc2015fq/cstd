# 【GPU编程】基于GPU的光线投射体绘制(GPU-Based Ray-Casting Volume Rendering)入门学习 - 江南烟雨 - CSDN博客
2012年02月24日 20:18:26[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：5266
基于GPU的光线投射体绘制
![](http://hi.csdn.net/attachment/201202/24/0_1330085789z2QH.gif)
这篇文字将会讲述怎么运用OpenGL和nVidia Cg进行基于GPU的光线投射体绘制。 读者最好具有OpenGL和顶点-片段渲染的相关经验。
首先，我们为什么需要这个算法？因为我们需要高质量的体绘制效果，而且光线投射非常实用于现在的GPU。由于统一渲染系统尤其是适用新的8800系列。
因为在渲染如上图那样的体数据的时候，遇到了一些技术上的困难，所以这篇文字主要是为了帮助人们初步认识GPU光线投射算法。
算法的核心是很对每一个屏幕像素发出一束光线，并且在体数据中跟踪这条光线。这在片段程序中是可行的，而且渲染可以实时完成。这种技术对于一些实例效果是很灵活的，比如阴影可以通过几行代码即可实现。
![](http://hi.csdn.net/attachment/201202/24/0_1330085834rhzR.gif)
这是光线投射算法的概念图片，每个像素都产生一条光线，并且在体数据中进行跟踪。
为了产生我们需要的光线，我们使用了一个巧妙的方法，那就是通过OpenGL渲染几何体。你可能会问：这能够给我们带来什么样的帮助啊？
首先，我们定义一条光线：
(1)一条光线可以用一个初始点o和一个方向向量dir即可表示。
(2)一条光线表示了三维空间中得一条直线，可以用公式P(t)=o+dir*t。
(3)所以为了产生光线我们需要找到初始点和方向向量。
这可以通过这样的方法来完成：渲染一个立方体，其颜色即代表该点的坐标。然后让OpenGL的插值功能去完成剩下的事情。如下图所示，方法就是渲染一个单位立方体的前面和后面。
![](http://hi.csdn.net/attachment/201202/24/0_1330085929qvB8.gif)
如果我们用后面（右图）的点减去前面的点，那么就可得到每个像素对应的方向向量。这个就是我们的光线的方向。初始点 就是立方体的前面的值。所以我们必须做两次渲染工作：一次渲染前面，一次渲染后面。在渲染背面的时候，我们启用前向面剔除功能。在我的实现中，我用OpenGL帧缓存来存储背面的渲染结果，用前面渲染来产生片段以开始光线投射过程。
所以为了计算光线投射结果我们需要创建一条光线然后在体数据中一步步跟踪。这全部可以在一个片段程序中完成，并且由GPU来运算。片段程序非常简单，唯一的难点是计算用来索引背面缓存的纹理坐标以得到光线穿出体数据的点。这些纹理坐标可以看成是标准设备坐标，在实现中我们通过下面的计算来在存储背面的缓存中找到对应的像素。
float2 texc = ((IN.Pos.xy / IN.Pos.w) + 1) / 2;
在上面的式子中，IN.Pos是经过模型视图投影之后的坐标位置，这个计算给出了片段屏幕位置，其值在0和1之间。这样光线出射点就可以通过用texc去索引存储背面渲染结果的缓存得到：
float4 exit_position  = tex2D(backface_buffer, texc);
现在我们完成了光线的创建，然后使用渲染模型3.0的循环功能来建立一个for循环。这个循环将会以一个特定的步进值delta在体数据中前进，根据体数据集的性质我们可以计算累计阻光度和颜色值。
