# 寻找逆序对 - 江南烟雨 - CSDN博客
2011年10月23日 22:50:23[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：2777
设A[1...n]是一个包含n个不同数的数组。如果在i<j的情况下，有A[i]>A[j]，则(i,j)就成为A中的一个逆序对(inversion)。
要确定一个数组中的逆序对的个数，可以采取分治法。将A分为两部分A1和A2，则A中逆序对的数目等于A1中逆序对的数目、A2中逆序对的数目和A1，A2合并时A1中比A2中元素大的数目。
参考代码：
```cpp
#include <iostream>
using namespace std;
#define MAX_VALUE 99999
//合并时计算逆序对数目
int MergeCountReverse(int *a,int low,int mid,int high)
{
	int num1 = mid - low + 1;
	int num2 = high - mid;
	int count = 0;
	int* a1 = (int*)malloc((num1 + 1) * sizeof(int));
	int* a2 = (int*)malloc((num2 + 1) * sizeof(int));
	for(int i = 0;i < num1;++i)
		*(a1 + i) = *(a + low + i);
	*(a1 + num1) = MAX_VALUE;
	for(int i = 0;i < num2;++i)
		*(a2 + i) = *(a + mid + 1 + i);
	*(a2 + num2) = MAX_VALUE;
	int index1 = 0;
	int index2 = 0;
	for(int k = low;k <= high;++k)
	{
		if(*(a1 + index1) > *(a2 + index2))
		{
			*(a + k) = *(a2 + index2);
			++index2;
			count += num1 - index1;//逆序对数
		}
		else
		{
			*(a + k) = *(a1 + index1);
			++index1;
		}
	}
	free(a1);
	free(a2);
	return count;
}
//递归计算逆序对数目：采用分治法
int CountReverse(int *a,int low,int high)
{
	int mid,count = 0;
	if(high > low)
	{
		mid = (low + high) / 2;
		count += CountReverse(a,low,mid);
		count += CountReverse(a,mid + 1,high);
		count += MergeCountReverse(a,low,mid,high);
	}
	return count;
}
int main()  
{  
    int n,temp;  
    cout<<"please input the number of the values:"<<endl;  
    cin>>n;  
    int *a = (int*)malloc(n * sizeof(int));  
    cout<<"please input each value:"<<endl;  
    for(int i = 0;i < n;++i)  
    {  
        cin>>temp;  
        *(a + i) = temp;  
    }  
    int count = CountReverse(a,0,n - 1);
	cout<<"the number of reverse pairs :"<<count<<endl;
}
```
```cpp
数据测试：
```
![](http://hi.csdn.net/attachment/201110/23/0_1319381477t8hy.gif)![](http://hi.csdn.net/attachment/201110/23/0_13193814856p30.gif)
