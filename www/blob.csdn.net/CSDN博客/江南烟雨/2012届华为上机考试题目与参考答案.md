# 2012届华为上机考试题目与参考答案 - 江南烟雨 - CSDN博客
2011年09月09日 22:50:48[江南烟雨](https://me.csdn.net/xiajun07061225)阅读数：3325
 题目一共三道，都比较简单，主要还是注重基础知识的考察。
答案是自己编写的，不一定正确，仅供参考。欢迎大家提出宝贵的意见~~![大笑](http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif)
1、选秀节目打分，分为专家评委和大众评委，score[] 数组里面存储每个评委打的分数，judge_type[] 里存储与 score[] 数组对应的评委类别，judge_type[i] == 1，表示专家评委，judge_type[i] == 2，表示大众评委，n表示评委总数。打分规则如下：专家评委和大众评委的分数先分别取一个平均分（平均分取整），然后，总分 = 专家评委平均分  * 0.6 + 大众评委 * 0.4，总分取整。如果没有大众评委，则 总分 = 专家评委平均分，总分取整。函数最终返回选手得分。
函数接口   int cal_score(int score[], int judge_type[], int n) 
我的参考代码：
```cpp
#include <iostream>
using namespace std;
#define MAX 100
int cal_score(int score[],int judge_type[],int n)
{
	int score1 = 0,score2 = 0;//分别记录专家评委总分和大众评委总分
	int num1 = 0,num2 = 0;//分别记录专家评委和大众评委人数
	int score_last,score_av1 = 0,score_av2 = 0;//分别记录平均分
	for(int i = 0;i < n;++i){
		if(judge_type[i] == 1)
		{
			score1 += score[i];
			++num1;
		}
		else
		{
			score2 += score[i];
			++num2;
		}
	}
	score_av1 = score1 / num1;
	if(num2)
	{
		score_av2 = score2 / num2;
		score_last = score_av1 * 0.6 + score_av2 * 0.4;
	}
	else
	{
		score_last = score_av1;
	}
	return score_last;
}
int main()
{
	int n;
	int score[MAX];
	int judge_type[MAX];
	cout<<"请输入评委个数:"<<endl;
	cin>>n;
	cout<<"请输入各个评委的分数:"<<endl;
	for(int i = 0;i < n;++i)
	{
		cin>>score[i];
	}
	cout<<"请输入各个评委类别:"<<endl;
	for(int i = 0;i < n;++i)
	{
		cin>>judge_type[i];
	}
	int score_last = cal_score(score,judge_type,n);
	cout<<"最终评委分数："<<score_last<<endl;
}
```
数据测试：
![](http://hi.csdn.net/attachment/201109/9/0_13155798911ag0.gif)![](http://hi.csdn.net/attachment/201109/9/0_1315579896Uef9.gif)
2、给定一个数组input[] ，如果数组长度n为奇数，则将数组中最大的元素放到 output[] 数组最中间的位置，如果数组长度n为偶数，则将数组中最大的元素放到 output[] 数组中间两个位置偏右的那个位置上，然后再按从大到小的顺序，依次在第一个位置的两边，按照一左一右的顺序，依次存放剩下的数。
      例如：input[] = {3, 6, 1, 9, 7}   output[] = {3, 7, 9, 6, 1};             input[] = {3, 6, 1, 9, 7, 8}    output[] = {1, 6, 8, 9, 7, 3}
函数接口   void sort(int input[[, int n, int output[])
 我的参考代码：
```cpp
#include <iostream>
using namespace std;
#define MAX 100
void sort(int input[],int n,int output[])
{
	int temp,index;
	//降序排列input[]数组
	for(int i = 0;i < n - 1;++i)
	{
		for(int j = i + 1;j < n;++j)
		{
			if(input[i] < input[j])
			{
				temp = input[i];
				input[i] = input[j];
				input[j] = temp;
			}
		}
	}
	if(n % 2 == 1)//数组长度为奇数
	{
		index = 0;//记录要取出的数在input数组中的下标
		output[n / 2] = input[index++];
		for(int i = 1;i <= n / 2;++i)
		{
			output[n / 2 - i] = input[index++];
			output[n / 2 + i] = input[index++];
		}
	}
	else//数组长度为偶数
	{
		index = 0;
		output[n / 2] = input[index++];
		for(int i = 1;i <= n / 2 -1;++i)
		{
			output[n / 2 - i] = input[index++];
			output[n / 2 + i] = input[index++];
		}
		output[0] = input[index];//存放最后一个数
	}
}
int main()
{
	int n,input[MAX],output[MAX];
	cout<<"请输入数组input长度n:"<<endl;
	cin>>n;
	cout<<"请输入input各个元素值："<<endl;
	for(int i = 0;i < n;++i)
		cin>>input[i];
	sort(input,n,output);
	cout<<"排序后的数组："<<endl;
	for(int i = 0;i < n;++i)
		cout<<output[i]<<endl;
}
```
一个改进型代码：
```cpp
#include <iostream>
using namespace std;
#define MAX 100
void sort(int input[],int n,int output[])
{
	int temp,index;
	//降序排列input[]数组
	for(int i = 0;i < n - 1;++i)
	{
		for(int j = i + 1;j < n;++j)
		{
			if(input[i] < input[j])
			{
				temp = input[i];
				input[i] = input[j];
				input[j] = temp;
			}
		}
	}
	/*if(n % 2 == 1)//数组长度为奇数
	{
		index = 0;//记录要取出的数在input数组中的下标
		output[n / 2] = input[index++];
		for(int i = 1;i <= n / 2;++i)
		{
			output[n / 2 - i] = input[index++];
			output[n / 2 + i] = input[index++];
		}
	}
	else//数组长度为偶数
	{
		index = 0;
		output[n / 2] = input[index++];
		for(int i = 1;i <= n / 2 -1;++i)
		{
			output[n / 2 - i] = input[index++];
			output[n / 2 + i] = input[index++];
		}
		output[0] = input[index];//存放最后一个数
	}*/
// another implement
	int m = -1;
for (int i = 0; i < n; i++)
{
	m *= -1;
	output[n/2 + (i+1)/2*m ] = input[i];	
}
}
int main()
{
	int n,input[MAX],output[MAX];
	cout<<"请输入数组input长度n:"<<endl;
	cin>>n;
	cout<<"请输入input各个元素值："<<endl;
	for(int i = 0;i < n;++i)
		cin>>input[i];
	sort(input,n,output);
	cout<<"排序后的数组："<<endl;
	for(int i = 0;i < n;++i)
		cout<<output[i]<<endl;
}
```
数据测试：
![](http://hi.csdn.net/attachment/201109/10/0_13156212104dJ2.gif)![](http://hi.csdn.net/attachment/201109/10/0_1315621214cW25.gif)
      3、操作系统任务调度问题。操作系统任务分为系统任务和用户任务两种。其中，系统任务的优先级 < 50，用户任务的优先级 >= 50且 <= 255。优先级大于255的为非法任务，应予以剔除。现有一任务队列task[]，长度为n，task中的元素值表示任务的优先级，数值越小，优先级越高。函数scheduler实现如下功能，将task[] 中的任务按照系统任务、用户任务依次存放到 system_task[] 数组和 user_task[] 数组中（数组中元素的值是任务在task[] 数组中的下标），并且优先级高的任务排在前面，优先级相同的任务按照入队顺序排列（即先入队的任务排在前面），数组元素为-1表示结束。
      例如：task[] = {0, 30, 155, 1, 80, 300, 170, 40, 99}    system_task[] = {0, 3, 1, 7, -1}    user_task[] = {4, 8, 2, 6, -1}
函数接口    void scheduler(int task[], int n, int system_task[], int user_task[])
我的参考代码：
```cpp
#include <iostream>  
    using namespace std;  
      
    //定义结构体  
    typedef struct node{  
        int date;//记录task元素值  
        int index;//记录在task数组中的下标  
    }node;  
      
    void schedule(int task[],int n,int system_task[],int user_task[])  
    {  
        int temp,index1,index2;  
        node* node_task = (node*)malloc(n * sizeof(node));  
        for(int i = 0;i < n;++i){  
            node_task[i].date = task[i];  
            node_task[i].index = i;  
        }  
        //非增序排列node_task结构体数组  
        for(int i = 0;i < n - 1;++i)  
        {  
            for(int j = i + 1;j < n;++j)  
            {  
                if(node_task[i].date > node_task[j].date)  
                {  
                    temp = node_task[i].date;  
                    node_task[i].date = node_task[j].date;  
                    node_task[j].date = temp;  
      
                    temp = node_task[i].index;  
                    node_task[i].index = node_task[j].index;  
                    node_task[j].index = temp;  
                }  
            }  
        }  
        index1 = 0;  
        index2 = 0;  
        for(int i = 0;i < n;++i)  
        {  
            if(node_task[i].date < 50)  
                system_task[index1++] = node_task[i].index;  
            else if(node_task[i].date >= 50 && node_task[i].date <= 255)  
            {  
                user_task[index2++] =  node_task[i].index;  
            }  
        }  
    }  
      
    int main(){  
        int n,num1 = 0,num2 = 0;  
        cout<<"请输入task数组的元素个数："<<endl;  
        cin>>n;  
        int* task = (int*)malloc(n * sizeof(int));  
        cout<<"请输入task数组各元素的的值："<<endl;  
        for(int i = 0;i < n;++i)  
            cin>>task[i];  
        for(int i = 0;i < n;++i)  
        {  
            if(task[i] < 50)  
                ++num1;  
            else if(task[i] >= 50 && task[i] <= 255)  
                ++num2;  
        }  
        int* system_task = (int*)malloc((num1 + 1) * sizeof(int));  
        int* user_task = (int*)malloc((num2 + 1) * sizeof(int));  
        schedule(task,n,system_task,user_task);  
        system_task[num1] = -1;  
        user_task[num2] = -1;  
        for(int i = 0;i < num1 + 1;++i)  
            cout<<system_task[i]<<" ";  
        cout<<endl;  
        for(int i = 0;i < num2 + 1;++i)  
            cout<<user_task[i]<<" ";  
        cout<<endl;  
        //不要忘记了释放数组内存  
        free(task);  
        free(system_task);  
        free(user_task);  
    }
```
数据测试：
![](http://hi.csdn.net/attachment/201109/10/0_131563493970aB.gif)
