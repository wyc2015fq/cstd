# C#系列 ---2 类型转换 - 墨流觞的博客 - CSDN博客





2018年10月30日 21:49:37[墨氲](https://me.csdn.net/dss_dssssd)阅读数：39








**一定要对比着c++学习！！！**

对于第一个作业，创建C#的控制台应用即可
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181030214715499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rzc19kc3Nzc2Q=,size_16,color_FFFFFF,t_70)
创建程序后：

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
        
        }
    }
}
```
- 
C# recognizes a method called Main as signaling the default entry point of execution.

main 函数作为程序执行的入口点。

- 
命名空间 namespace 和 using理解 [https://www.w3cschool.cn/csharp/csharp-namespace.html](https://www.w3cschool.cn/csharp/csharp-namespace.html)


以此段代码为例子讲解基本语法：

```
using System;
class Test
{
static void Main()
{
int x = 12 * 30;
Console.WriteLine (x);
}
}
```

## 语法(syntax)

启发于c和c++，因而比较好理解
- 
indentifiers(标识符) and keywards（关键字）
- 
标识符，**也可以叫做变量名**，是程序员为类，方法，变量起的名字，程序员可以自己定义、修改

比如： System, Test(类名), Main（函数/方法名）， x(变量名)， Consloe

- 
关键字： 对编译器而言，有特殊含义的字母，不允许程序员自己定义、修改；程序员也不能使用关键字作为变量名标识符

比如： using， void， static, int


保留的关键字：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181030214730725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rzc19kc3Nzc2Q=,size_16,color_FFFFFF,t_70)- 
Literals, Punctuators, and Operators(操作符)
- 
Literals：在源代码中表示值的任何*记号*，与标识符 （indentifiers）不同，标识符要指向内存中某一个值

[https://stackoverflow.com/questions/485119/what-does-the-word-literal-mean](https://stackoverflow.com/questions/485119/what-does-the-word-literal-mean)

Examples:
- `"hey"`  (a string)
- `false`  (a boolean)
- `3.14`  (a real number)
- `[1,2,3]`  (a list of numbers)
- `(x) => x*x`  (a function)
- `/^1?$|^(11+?)\1+$/`  (a regexp)

- 
Punctuators : {}  ;   ()

- 
Operators:  * / +  - = == %


- 
comment 注释

单行注释： //

多行注释： /**/

```
int x = 3; // Comment about assigning 3 to x

int x = 3; /* This is a comment that
             spans two lines */
```


4.Type

A type defines the blueprint for a value（

类型决定了该值拥有的方法，属性）

`int x = 12 * 30`

比如说， int 类型 决定了 variable(变量)x 拥有int类型的所有属性和方法。在这里可以将c#的type简单的理解为C++的class，而x是int类的对象。注意，**int在C#被重写为类。相似的还有float，string等， 这是C#和C++最大的不同之处**

```
static int FeetToInches(int feet)
       {
           int inches = feet * 12;
           // int 类型的inches可以调用ToString方法
           Console.WriteLine(inches.ToString());
           return inches;
       }
```

variable: 指向的内存地址包含的变量是可变的

const: 常量  指向的内存地址包含的变量是不可变的

这和C++的概念相同

```
int x = 12 * 30;
const int y = 360;
```
- 
预定义(内建类型 built-in types)的类型： bool， string, int, float；

**在C#中，内建类型为关键字（keyword），包含在System 的命名空间中， 这也就是在代码开始部分为什么使用 `using namespace`了**

- 
用户自定义类型， 其实就是C++中的自定义类


```
using System;
//自定义UnitConverter type
public class UnitConverter
{
int ratio; // Field
public UnitConverter (int unitRatio) {ratio = unitRatio; } // Constructor
public int Convert (int unit) {return unit * ratio; } // Method
}
class Test
{
static void Main()
{
// 用自定义的类， 创建对象
UnitConverter feetToInchesConverter = new UnitConverter (12);
UnitConverter milesToFeetConverter = new UnitConverter (5280);
Console.WriteLine (feetToInchesConverter.Convert(30)); // 360
Console.WriteLine (feetToInchesConverter.Convert(100)); // 1200
Console.WriteLine (feetToInchesConverter.Convert(
milesToFeetConverter.Convert(1))); // 63360
}
}
```

**以后要适应type的定义。。。**
- type 的成员（members）：
- data members: `ratio`
- function members: `UnitConverter`(构造函数) 和 `Convert`
- Constructors and instantiation（构造函数和实例化）
- 对于内建类型，简单的使用 literal就可以创建一个对象了。
`string myWord = 'Hello World'`
- 对于自定义类型， 需要使用操作符new来创建type的实例对象
`UnitConverter feetToInchesConverter = new UnitConverter (12);`
- 静态成员(static members)

调用对象不是实例对象（instances） ，而是类型本身。

同样的，如果只想让type本身调用某一个成员，而不想让实例对象调用，需要在成员前加static关键字
```
public class Panda
{
public string Name; // Instance field
public static int Population; // Static field
public Panda (string n) // Constructor
{
Name = n; // Assign the instance field
Population = Population + 1; // Increment the static Population field
}
}

using System;
class Test
{
static void Main()
{


Panda p1 = new Panda ("Pan Dee");
Panda p2 = new Panda ("Pan Dah");
Console.WriteLine (p1.Name); // Pan Dee
Console.WriteLine (p2.Name); // Pan Dah
Console.WriteLine (Panda.Population); // 2
}
}
```

以上代码中，如果调用`p1.Population`和`Panda.Name`，编译时都会报错
- public： 对于type的成员而言，public和c++中完全一样，实例对象可以直接调用

### conversions 类型转换

C#在可兼容类型的实例对象之间是可转换的

分为隐式转换或显式转换(implicit or explicit)。和C++一样的

```
int x = 12345; // int is a 32-bit integer
long y = x; // Implicit conversion to 64-bit integer
short z = (short)x; // Explicit conversion to 16-bit integer
```

在以上两种情况都满足的情况下才能完成隐式转换：
- 编译器总是能够保证编译成功
- 在转换过程中没有信息丢失

否则，只能使用显式转换

**简单的说，高精度想低精度转换，需要显式转换，因为转换过程中会有精度丢失，比如32位int类型转换为16位的short类型需要丢失掉一半的精度信息，因而需要显式转换；而低精度向高精度转换，隐式转换就可以。**

其实vs 2017编译器会自动检查错误的，







