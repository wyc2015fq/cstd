# 守护进程概念及实例 - yixianfeng41的专栏 - CSDN博客
2017年03月01日 20:08:27[第2梦](https://me.csdn.net/yixianfeng41)阅读数：584
守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种很有用的进 程。Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器inetd，Web服务器httpd等。同时，守护进程完成许多系统任 务。比如，作业规划进程crond，打印进程lpd等。
在了解守护进程前，先看看进程组、会话、控制终端以及作业的概念及关系
### **一、进程组、会话、控制终端的概念及关系**
#### **1、进程组**
每个进程除了有一个进程ID之外，还属于一个进程组，那什么是进程组呢？
顾名思义，进程组就是一个或多个进程的集合。这些进程并不是孤立的，他们彼此之间或者存在父子、兄弟关系，或者在功能上有相近的联系。每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。
那为啥Linux里要有进程组呢？其实，提供进程组就是为了方便对进程进行管理。假设要完成一个任务，需要同时并发100个进程。当用户处于某种原因要终止 这个任务时，要是没有进程组，就需要手动的一个个去杀死这100个进程，并且必须要严格按照进程间父子兄弟关系顺序，否则会扰乱进程树。有了进程组，就可以将这100个进程设置为一个进程组，它们共有1个组号（pgrp），并且有选取一个进程作为组长（通常是“辈分”最高的那个，通常该进程的ID也就作为进程组的ID）。现在就可以通过杀死整个进程组，来关闭这100个进程，并且是严格有序的。组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。
进程必定属于一个进程组，也只能属于一个进程组。 一个进程组中可以包含多个进程。 进程组的生命周期从被创建开始，到其内所有进程终止或离开该组。
内核中，sys_getpgrp()系统调用用来获取当前进程所在进程组号；sys_setpgid(int pid, int pgid)调用用来设置置顶进程pid的进程组号为pgid。
#### **2、会话**
由于Linux是多用户多任务的分时系统，所以必须要支持多个用户同时使用一个操作系统。当一个用户登录一次系统就形成一次会话 。一个会话可包含多个进程组，但只能有一个前台进程组。每个会话都有一个会话首领（leader），即创建会话的进程。
一个会话可以有一个控制终端。这通常是登陆到其上的终端设备（在终端登陆情况下）或伪终端设备（在网络登陆情况下）。建立与控制终端连接的会话首进程被称为控制进程。一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组。所以一个会话中，应该包括控制进程（会话首进程），一个前台进程组和任意后台进程组。 
一次登录形成一个会话。一个会话可包含多个进程组，但只能有一个前台进程组
#### **3、控制终端**
会话的领头进程打开一个终端之后, 该终端就成为该会话的控制终端 (SVR4/Linux)  。与控制终端建立连接的会话领头进程称为控制进程 (session leader) 
一个会话只能有一个控制终端 。产生在控制终端上的输入和信号将发送给会话的前台进程组中的所有进程 。终端上的连接断开时 (比如网络断开或 Modem 断开), 挂起信号将发送到控制进程(session leader)
#### **4、相互关系**
进程属于一个进程组，进程组属于一个会话，会话可能有也可能没有控制终端。
一般而言，当用户在某个终端上登录时，一个新的会话就开始了。进程组由组中的领头进程标识，领头进程的进程标识符就是进程组的组标识符。类似地，每个会话也对应有一个领头进程。
同一会话中的进程通过该会话的领头进程和一个终端相连，该终端作为这个会话的控制终端。一个会话只能有一个控制终端，而一个控制终端只能控制一个会话。用户通过控制终端，可以向该控制终端所控制的会话中的进程发送键盘信号。
同一会话中只能有一个前台进程组，属于前台进程组的进程可从控制终端获得输入，而其他进程均是后台进程，可能分属于不同的后台进程组。
当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。
### **二． 守护进程及其特性**
守护进程最重要的特性是后台运行。在这一点上DOS下的常驻内存程序TSR与之相似。其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的 文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程（特别是shell）中继承下来的。最后，守 护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端 （通常是shell）执行。 
总之，除开这些特殊性以外，守护进程与普通进程基本上没有什么区别。因此，编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。如果读者对进程有比较深入的认识就更容易理解和编程了。
### **三． 守护进程的编程要点**
前面讲过，不同Unix环境下守护进程的编程规则并不一致。所幸的是守护进程的编程原则其实都一样，区别在于具体的实现细节不同。这个原则就是要满足守护 进程的特性。同时，Linux是基于Syetem V的SVR4并遵循Posix标准，实现起来与BSD4相比更方便。编程要点如下；
#### **1. fork一个子进程，并把父进程退出**
为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。 
```
if(pid=fork())
   exit(0);//是父进程，结束父进程，子进程继续
```
#### **2. 使这个子进程脱离控制终端，登录会话和进程组**
有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系： 
这个控制终端通常是创建进程的登录终端。 
进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。 
登录会话可以包含多个进程组。这些进程组共享一个控制终端。
控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长： setsid();
说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。
#### **3. 禁止进程重新打开控制终端**
现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端： 
```
if(pid=fork())
   exit(0);//结束第一子进程，第二子进程继续（第二子进程不再是会话组长）
```
#### **4. 关闭打开的文件描述符**
进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：
```matlab
for(i=0;i 关闭打开的文件描述符close(i);>
```
#### **5. 改变当前工作目录**
进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如/tmpchdir(“/”)
#### **6. 重设文件创建掩模**
进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);
其实我觉得对于守护进程创建的思路可以这样梳理： 
首先我们根据守护进程的定义知道，它是运行在后台的，没有控制终端的一类进程。那么我们如何使其没有控制终端了？先fork一个子进程，然后setsid(),这里fork一个子进城后可以保证不是进程组长，那么就可以成功调用setsid(),然后setsid()创建一个全新的会话，进程组，这样也就脱离了控制终端，同时为了避免重新申请控制终端，再fork一个子进程，然后将父进程退出。不过fork后，子进程是父进程的副本，然后就会继承父进程的文件描述符以及文件模式创建屏蔽字还有工作目录等，这些不是我们要要的，因此要对其更改，以满足需求。
### **四． 守护进程实例**
守护进程实例包括两部分：主程序test.c和初始化程序init.c。主程序每隔一分钟向/tmp目录中的日志test.log报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。读者可以利用init_daemon函数生成自己的守护进程。
#### 1、init.c
```cpp
#include < unistd.h > 
#include < signal.h > 
#include < sys/param.h > 
#include < sys/types.h > 
#include < sys/stat.h >
void init_daemon(void) 
{ 
    int pid; 
    int i;
    if(pid=fork()) 
       exit(0);//是父进程，结束父进程 
    else if(pid< 0) 
       exit(1);//fork失败，退出 
    //是第一子进程，后台继续执行
    setsid();//第一子进程成为新的会话组长和进程组长 
    //并与控制终端分离 
    if(pid=fork()) 
       exit(0);//是第一子进程，结束第一子进程 
    else if(pid< 0) 
       exit(1);//fork失败，退出 
    //是第二子进程，继续 
    //第二子进程不再是会话组长
    for(i=0;i< NOFILE;++i)//关闭打开的文件描述符 
        close(i); 
    chdir("/tmp");//改变工作目录到/
    umask(0);//重设文件创建掩模 
    return; 
}
```
#### 2、test.c
```
#include < stdio.h > 
#include < time.h >
void init_daemon(void);//守护进程初始化函数
main() 
{ 
    FILE *fp; 
    time_t t; 
    init_daemon();//初始化为Daemon
    while(1)//每隔一分钟向test.log报告运行状态 
    { 
        sleep(60);//睡眠一分钟 
        if((fp=fopen("test.log",”a”)) >=0) 
        { 
            t=time(0); 
            fprintf(fp,”I'm here at %sn”,asctime(localtime(&t)) ); 
            fclose(fp); 
        } 
    } 
}
```
### 参考：
1、《unix 环境高级编程》 
2、[Linux-进程、进程组、作业、会话、控制终端详解](http://www.cnblogs.com/JohnABC/p/4079669.html)
3、[C语言编写Linux守护进程实例](http://www.jb51.net/article/60741.htm)
