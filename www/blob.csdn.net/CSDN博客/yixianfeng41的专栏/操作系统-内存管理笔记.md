# 操作系统-内存管理笔记 - yixianfeng41的专栏 - CSDN博客
2017年02月23日 13:58:27[第2梦](https://me.csdn.net/yixianfeng41)阅读数：612
所属专栏：[Linux/Unix 网络编程](https://blog.csdn.net/column/details/14513.html)
内存管理最基本的操作就是由处理器把程序装入内存中运行。技术有固定分区、动态分区、简单分页、简单分段、虚拟内存分页、虚拟内存分段等。在现代操作系统中基本都有虚拟内存技术。下面了解下各个方法的思想。
### **1、固定分区**
管理用户内存空间的最简单的方法是就是把它分成许多固定边界的区域。对于分区大小，我们可以采用大小相等分区，或者大小不相等分区。
1）大小相等的分区。 
在这种情况下，小于或者等于分区大小的任何进程都可以装入可用分区中。如果分区满了，并且没有进程处于就绪态，则操作系统可以换出一个进程的分区，并装入另一个进程。对于这种方法会产生两个问题：程序太大放不进去（必须使用覆盖技术）；内存利用率低，有内部碎片。
2）大小不等分区 
大小不等分区，就是产生一些大小不等的固定分区，这可以一定程度上缓解大小相等分区方法产生的两个问题，但是不能完全解决这两个问题。
固定分区技术简单，只需要很小的处理开销，但是它有以下缺点：
- 限制了系统中活动（没有挂起）进程的数目；  
- 小作业不能有效利用分区空间
目前没有什么场合使用这个技术了，历史上成功操作系统例子是IBM主机操作系统OS/MFT.
### **2、动态分区**
为了克服固定分区的缺点，又出现了一种动态分区方法。动态分区，分区长度和数目是可变的。当进程进入内存时，系统会为它分配一块和它所需容量完全相等的空间。
动态分区在开始是很好的，但是随着时间推移，它会出现越来越多的碎片，内存利用率随之降低。这种现象称为外部碎片。克服这个缺点的一种技术是压缩，操作系统不时的移动进程，使得进程占用空间连续，并且所有空闲空间连成一片。
现在来介绍下，内部碎片与外部碎片。
- **内部碎片**：由于被装入的数据块小于这块内存大小，从而导致这块内存内部有空间浪费了。通俗来讲就是已经分出去了，但是你没有完全利用，所造成的浪费；  
- **外部碎片**：在所有分区外的不能被利用的小空间，成为外部碎片。通俗来讲，太小了，分不出去了，造成了浪费。
同样，这个方法现在也已经被更先进的内存管理技术取代。历史上，使用这个方法成功的操作系统是IBM主机操作系统OS/MVT.
### **3、伙伴系统**
固定分区和动态分区都有缺陷。固定分区方案限制了活动进程的数目，并且内存利用率低。动态分区技术维护特别复杂，压缩会带来额外开销。因此，产生了一种折中方案，伙伴系统
在伙伴系统中，可用内存块的大小为2^k个字，L<=K<=U.其中2^L表示最小尺寸，2^U表示最大尺寸，也就是可分配的整个内存大小。对于请求的s，满足2^(U-1)<s<=2^U，则分配整个空间，否则一分为二，均为2^(U-1)；判断是否满足2^(U-2)<s<=2^(U-1)，如果满足分配，不满足，继续一分为二，直到找到满足的。
举个例子，内存为1M大小，而允许的最小块为64K，那么当我们申请一块200K大小的内存时，就要先将1M的块分裂成两等分，各为512K，这两分之间的关系就称为伙伴，然后再将第一个512K的内存块分裂成两等分，各位256K，将第一个256K的内存块分配给内存，这样就是一个分配的过程
### **4、简单分页**
固定分区和动态分区都是低效的，前者会产生内部碎片，后者会产生外部碎片。因此出现分页，分段机制。分页机制就是将内存分成大小相等的块，且块相对比较小，每个进程也被分成同样大小的块，那么进程中称为页的块可以指定到内存中称为页框的可用块。
使用分页技术在内存中为每个进程浪费的空间呢仅仅是进程最后一页的一小部分形成的碎片，没有任何外部碎片。
在分页机制中，操作系统为每一个进程维护一个页表。页表中记录着进程的每一项对应的页框位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移。
### **4、简单分段**
分段机制就是将内存分成大小不等的段，会有一个最大长度限制。为执行一个程序，需要将他所有段都装入内存，不过这些段不要求连续。分段技术的逻辑地址也是类似分页机制的，是“段号和偏移量”。
分段机制消除了内部碎片，但是会产生外部碎片。
总结一下，我觉得简单分页就是固定分区的升级版，只是它可以把进程也分页装入；而简单分段就是动态分区的升级版，同样的它可以把进程也分段装入。因此他们都存在相同问题，固定分区和简单分页都存在内部碎片，后者碎片更少；动态分区和简单分段都存在外部碎片，后者碎片更少。
接下来，看看虚拟内存技术………..
