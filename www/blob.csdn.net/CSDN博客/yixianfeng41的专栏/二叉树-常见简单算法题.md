# 二叉树-常见简单算法题 - yixianfeng41的专栏 - CSDN博客
2017年02月19日 01:02:10[第2梦](https://me.csdn.net/yixianfeng41)阅读数：1133
所属专栏：[数据结构与算法](https://blog.csdn.net/column/details/14515.html)
[篇一：二叉树-遍历终极版](http://blog.csdn.net/yixianfeng41/article/details/55228458)
[篇二：二叉树-创建、重建、转化](http://blog.csdn.net/yixianfeng41/article/details/55225750)
[篇三：二叉树-详解二叉排序树](http://blog.csdn.net/yixianfeng41/article/details/52802855)
[篇四：二叉树-详解平衡二叉树AVL](http://blog.csdn.net/yixianfeng41/article/details/53229734)
[篇五：二叉树-常见简单算法题](http://blog.csdn.net/yixianfeng41/article/details/55702141)
### 求二叉树高度
```
int maxDepth(TreeNode* root)
{
    if(!root) return 0;
    else
    {
        int left=maxDepth(root->left);
        int right=maxDepth(root->right);
        return 1+max(left,right);
    }
}
```
### 求二叉树最小深度
上面试求最大深度（也就是二叉树高度），下面来求一下最小深度。
```
int minDepth(TreeNode* root) 
{
    if (root == NULL) return 0;
    if (root->left == NULL) 
       return minDepth(root->right) + 1;
    else if (root->right == NULL) 
       return minDepth(root->left) + 1;
    else 
       return min(minDepth(root->left), minDepth(root->right)) + 1;
}
```
### 判断二叉树是否高度平衡
```
bool isBalanced(TreeNode* root) 
{
    if(!root) return true;
    if(abs(maxDepth(root->left)-maxDepth(root->right))>1)
      return false;
    return isBalanced (root->left)&&isBalanced(root->right);
}
```
### 判断两个二叉树是否相等
```
bool isSameTree(TreeNode* p, TreeNode* q) 
{
    if(!p&&!q) 
       return true;
    if(p&&!q||!p&&q||p->val!=q->val)  
       return false;
    return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);     
}
```
### 判断二叉树是不是对称树
```
bool Symmetry(TreeNode* left, TreeNode* right)
  {
      if(!left && !right) return true;
      if(!left || !right) return false;
      if(left->val != right->val) return false;
      return  Symmetry(left->left, right->right) && Symmetry(left->right, right->left);  
  }
  bool isSymmetric(TreeNode* root)
  {
       if(root==NULL) return true;
       else
           return Symmetry(root->left,root->right); 
       return false;        
  }
```
## 翻转二叉树
递归版：
```
TreeNode *invertTree(TreeNode *root) 
{
     if (root == NULL) return NULL;
     TreeNode *tempRight = root->right;
     root->right = invertTree(root->left);
     root->left = invertTree(tempRight);
     return root;
}
```
上免得交换，也可以直接用std:swap实现：
```
TreeNode* invertTree(TreeNode* root) {
    if (root==NULL) return NULL;
    invertTree(root->left);
    invertTree(root->right);
    std::swap(root->left, root->right);
    return root;
}
```
非递归版：
```cpp
TreeNode* invertTree(TreeNode* root) 
 {
     if(!root) return NULL;
     queue<TreeNode*>  myqueue;
     myqueue.push(root);
     while(myqueue.size()>0)
     {
         TreeNode* pnode=myqueue.front();
         myqueue.pop();
         if(pnode)
         {
             myqueue.push(pnode->left);
             myqueue.push(pnode->right);
             TreeNode* pleft=pnode->left;
             pnode->left=pnode->right;
             pnode->right=pleft;
         }
     }
     return root;
 }
```
这个当然也可以用std::swap,代码如下：
```cpp
TreeNode* invertTree(TreeNode* root) 
 {
     if(!root) return NULL;
     queue<TreeNode*>  myqueue;
     myqueue.push(root);
     while(myqueue.size()>0)
     {
         TreeNode* pnode=myqueue.front();
         myqueue.pop();
         if(pnode)
         {
             myqueue.push(pnode->left);
             myqueue.push(pnode->right);           
             std::swap(pnode->left,pnode->right);
         }
     }
     return root;
 }
```
