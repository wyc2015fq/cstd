# 软件工程的安全问题 - 無名黑洞 - CSDN博客
2012年04月30日 03:59:25[wangxiaojun911](https://me.csdn.net/wangxiaojun911)阅读数：4556
**1、軟件安全概論**
軟件安全：軟件按我們所期待的方式運行就叫軟件安全。
信任度(Trust)：描衡量一個軟件是不是能按我們所期待的方式運行的指標。
产生安全问题的原因：制作时期的不一致(in-consistency)，没有针对故障(Violation, incidents, and disaster)的对应机制，或没有经过详尽的测试。
怎样是一个好的软件安全机制：限制。(limit WHAT, WHO, HOW, happen and can change the system)。具体来说就是：容易使用，警报（False alarm），不频繁更新，不需要专家爱来修正等。
修正补丁：安装必须容易，不要牵扯没有问题的部分，不使用补丁来实现某个目的（应该靠设计实现）。
现在流行的操作系统或多或少都有安全漏洞。由于招聘具有安全软件编程技能的员工有大量成本，公司倾向使用大量测试人员来弥补。
安全计划（Security Planning）:如风险评估，收益分析等，制作政策Policy来实现。具体比如：保密性（Conﬁdentiality），数据完整性(Integrity)，可用性(Availability)，一致性，控制等。这也是安全目标（Security goals）
风险评估(Risk Assessment)：提问自己要保护的对象是什么(主要是硬件、软件和数据)，要保护那些方面，需要投入多少时间、金钱、劳动力来实现？即Assets（有形、无形资产）, Threats（各种损失，雷电，洪水，盗窃，病毒，罢工，bug等。分为Interruption, interception, modification和fabrication四类或分为Involuntary和Voluntary两类）和Calculation(Cost
 Benefit Analysis, 损失花销，保护花销)。
风险评估的三个关键步骤如下：
– 确定资产 Identify assets
– 确定威胁 Identify threats
– 计算风险 Calculate risks
软件威胁：删除、修改和盗窃（非法拷贝）。
数据威胁：打印数据的拷贝泄露，非法串改，交易途中修改，竞争者收益，非常常见。按照数据的价值来决定安全级别。
其他威胁：存储媒介，网络，授权，关键人员，骗局等。
软件安全的相关人员：
业余者Amateur（发现了系统漏洞的普通员工），Crackers（如以破解软件为乐的学生），职业人员（专门从事犯罪行动的人，间谍等）。
防守方法：数据加密。从开发、操作系统等方面进行控制。
控制方法：硬件方面（硬件加密，设置权限），政策方面（密码保护，训练管理员），物理方面（门禁，备份，分布存储等），人员方面（认识安全问题的严重性）。并且控制要有可操作性。另外要考虑控制重叠，定期评测等。
安全条约：选择有价值的财产并定立条约（Policy）来保护。条约明确了What,Why，Responsibility进行保护。条约是普遍的和不经常改变的。并且不需要把具体的威胁或个体写出来。记录了组织安全问题的实现标准。通常用Shall叙述。与平台无关。有度量方式。有支援方式。以积极方式而不是消极方式撰写。以教育为主。选择一个简单的Philosophy并且前后一致。要有防御深度。对于个体授权要具体。对于硬件软件都要保护，还要设定备份机制。安全条约的内容包括：密码条约，软件安装条约，保密和敏感数据条约，网络接入条约，电子邮件条约，远程登录条约，笔记本使用条约，电脑室条约等。条约的负责方分为Dispatcher，管理层，技术支持专家，公共关系专家等。
建立一个更安全的电脑的简单步骤：1、评估你的数据的重要性；2、教育你的社区；3、定理一个备份的计划；4、保持好奇心和怀疑心。
攻击方法：DOS(Denial of Service)，使网络或系统瘫痪；电子邮件炸弹；病毒；欺骗（Spooﬁng）等。
安全服务：隐私保护，授权，接入控制（Access Control），完整性，不可抵赖性（Non-repudiation），重放保护（Replay Prevention）
**2、加密和解密**
加密(Encryption)：把信息伪装的机制。它把信息处理成不明显的形式。
解密(Decryption)：把加密的信息还原。
Encode/decode：把phrase变成词语(word)或另一个phrase的过程。
Encipher/deceipher: 把单个字母或符号互相转换的过程。
Plaintext：原信息P。
Ciphertext：加密后的信息C。
以上的关系：C=E(P); P=D(C); P=D(E(P))
加入Key的情况：C=E(P)
对称加密：P=D(K, E(K,P))
不对称加密：P=D(K_D, E(K_E,P))
Cryptography:隐藏文本。
Crypt-analyst： 分析加密的信息。与Cryptographer的区别是前者通常是非法获取信息者。方法有寻找加密算法，分割单信息，识别加密模式等。
Cryptology: 关于加密解密的研究。
Breakable Encryption：给予一定的时间，能够通过Break的方式破解的加密。
实例说明：S（Sender）传递信息T(Transmission Medium)给R(Receiver)，O(Outsider)想要获取信息。O有如下四种方式：
阻断；
Intercept（悄悄读取信息）；
修改；
Fabricate（伪造信息传给R）。
Substitution-based Encryption：通过分析词频可以解开这种简单的加密方法或它的变种（如Polyalphabetic Substitution ）。
Transposition:  以字母重新排列的方式加密。
NP完全：用NP完全算法进行加密。
数字理论：使用质数，欧几里得算法等数学算法进行加密。
公开密钥技术：传统的加密方法在S和R之间建立一组Key，如果有N个人，就需要N(N-1)/2组Key。加入设计一种Public Key:
P = D(K_priv, E(K_pub, P))
每个人只需保留两个Key，总数变为2N个。
**3 系统保证和评审(System with Assurance Evaluation Auditing)**
**概述**
动机：防御来自各个方面的威胁，修补系统自身的漏洞（Vulnerability）。
关注点：操作系统（data），应用程序(Operation/transaction)
集中式系统比分布式系统更容易保证。
安全机制需要在各个层次(Layer)实现。四级Layer举例：应用层（传递控制）；服务/中转层（支持）；操作系统层（内存管理，scheduling控制）；硬件层（固件）。根据特定需要把安全机制放在特定的层次，比如文件访问管理放在操作系统层。前面的层次安全性要考虑更低级的层次的安全性，比如应用程序的安全需要操作系统支持。
安全问题要在设计层面上考虑。
Trusted Computing Base (TCB): TCB是用于建立安全政策(Policy)的基础。
Specification: 清楚， 无歧义(Unambiguous)，完整。
设计保证：指出设计瑕疵。指出如何满足需求。技巧：模块化，层次化和抽象化。
设计文档：安全函数和方法，用户接口，内部低级设计。从技术上，要求上，信息熵入手。
需求映射：
-1、安全需求
-2、外部specification
-3、内部specification
-4、代码实现
4映射(Mapping, tracing)1、2、3。
2、3、4互相Informal correspondence。
实现的保证：
模块化、最小接口。
语言选择：C（不可靠pointer, memory, error），Java（改善C的安全缺陷）
管理的保证：
管理配置(Configuration Management, CM)源代码和文档。
安全测试：功能FT（黑盒），结构ST（白盒）。系统综合测试(FT)，模块化测试(ST)
补丁方式：
Hot fix：紧急、严重问题的处理
Regular fix：长期解决方案，适用于不紧急的问题。
**评测(Evaluation)**
Formal evaluation: 获取信任的方法。
评测方法包括：安全需求，保证需求，过程，度量结果。
目的： 防御。使产品获得信任。
Trusted Computer System Evaluation Criteria （TCSEC）: 美国政府用于评测的标准。分类保证：
C1：酌情保护(Discretionary)
C2：控制保护
B1：标识安全(Labeled security)保护
B2：结构保护
B3：安全领域
A1：认证保护
TCSEC谁来评测？政府资助独立的评测者。
TCSEC三个阶段：
Design analysis 设计分析
Test analysis 测试分析
Final review 最终审查
问题：
基于保密性，没有完整性和可用性检查
把安全和功能结合到一起
基本系统：TNI(Trusted Network Interpretation), TDI (Trusted Database management System Interpretation)
ITSEC(欧洲的TCSEC)
ITSEC(欧洲)级别(Levels)：
E1：安全目标定义和测试
E2：非正式设计描述
E3：代码和安全的一致性(Correspondence)
E4：正式安全政策
E5：代码和设计的一致性
E6：正式的构建（）Architecture方法
ITSEC(欧洲)问题:
没有验证安全需求
评测的不一致性（Inconsistency）
**Common Criteria (CC)**
CC是取代TCSEC, ITSEC的评测标准。
CC文档：功能需求，保证（Assurance）需求，评测保证级别(Evaluation Assurance Level, EAL)
CC评测方法：对每个EAL作出详尽的guideline
国家级的Scheme
TOE： Target of Evaluation
TSFI： TOE Security Functions Interface
Functional Requirement: 包括 Security Audit, Communication, Cryptography等。
Assurance Requirement: Protection Profile Evaluation, Configuration management等。
CC Evaluation Assurance 层级：
-1、功能测试
-2、结构测试
-3、方法(Methodically)测试
-4、方法设计，测试和评测(Review)
-5、半正式设计和测试
-6、半正式验证（Verified）设计和测试
-7、正式设计和·测试
当前有80个产品注册了CC测试，只有一个是5层，若干4层。
**Auditing（审核）**
Logging的定义：记录事件和数据用以保证系统性能。
Auditing的定义：分析log记录来呈现清晰的可理解的系统行为（Manner）。
目标：用户问责（accountability），伤害评估，安全调查，问题监控，保护效率评测等。
问题：那些数据需要log？Audit哪些对象？
重要结构：
Logger记录信息，以参数控制。有的记录可以直接供人们阅读，有的不行。
Analyzer分析log的记录。
Notifier：报告分析结果。
设计一个审核系统：关键安全机制模块，由目标决定哪些内容被log
Constraint限制：P(action->condition)
举例：对于读写操作(从S到O)，在两端记录L(S), L(O), 读或写，成功或失败。不需要把S和O本身记录下来。且L(S) >= L(O)
实现的问题：如何定义Violation，多重命名等。
语法问题：记录的歧义性。解决方法是定义严格的语法。
Log Sanitization:  一种Policy规定用户和数据之间的关系。两种Policy:
-1、信息限制在网站内；
-2、信息限制在系统内。
Pseudonyms： 通过改名来规避敏感问题，仍然保持了关系Relation。用随机key把公开数据加密，用秘密的方法分享key。
Application Logging：应用程序的log。
System Logging：在Kernel级别的记录。
以上的区别是前者关注应用事件，比如登录错误；后者关注系统事件，比如内存映射。后者信息量往往大得多。
Posteriori设计：在系统完成后设计Auditing。目的是检测所有潜在的安全问题。从State和Transition两个方向入手。
**4 安全模式(Security Patterns)**
动机：今天的系统有很多不同的通讯特点。安全问题是一个很难评测的非功能需求（Non-functional requirement）。需要专业知识进行设计。
方法：使用模式的方法来克服不同开发人员之间的知识鸿沟。具体来说使用了Design pattern template模板。
十大原则（Principle）：
-1、确保最薄弱环节；
-2、提高防御深度；
-3、错误事件的安全处理（Fail securely）；（错误无法避免，设计应对策略）
-4、最小权限原则（least privilege）；
-5、划分（Compartmentalize）原则；
-6、简单化原则；
-7、促进隐私原则（Promote privacy）；（最小化能收集到的隐私信息）
-8、记住隐藏秘密是很难的；
-9、不要任意信任（Be reluctant to trust）；（不要任意扩展信任权限）
-10、使用社区资源。
冲突：2、5、7和6，期间需要取舍。
如前文所述，设计模式指出了问题（Problem）和对应的解决方案（Solution）。它促进了开发人员之间的交流，提供了总体的结构信息，统一了设计和提高了理解度。而安全模式针对特定的反复出现的安全问题提出了解决方案。
模式分类：同普通设计模式一样，分为Structural, Behavioral和Creational三类。
模式分层：Application level, host level和network level。
以下是三种安全模式的举例。
**单访问点（Single Access Point, SAP）**
一种Structural模式，通过建立单一的界面，用于加强系统控制，从而提升安全性。
约束：真实性，保密性，完整性。
后果（Consequences）：可说明性（Accountability），保密和完整性，可用性，性能需求，花销（试情况而定），管理性（安全代码很集中），Usability(方便性下降)。
已知的运用：Linux telnet, Windows NT
相关安全模式：Check Point, Role-Based Access Control, Session
相关模式： Singleton
相关原则：1, 6, 9
**检查点（Check Point）**
CP用于检查进入的请求和处理Violation。运用在监控领域。
参与者：Check Point, Countermeasure, Security Policy。CP检查进入的消息是否符合Security Policy。Countermeasure（对策）在合适的时候被触发。
约束：真实性，完整性，保密性。
后果：保密，完整，性能（降低），额外花销，简化管理，可能会阻挡一些正常的信息。
相关安全模式：SAP, Role-Based Access Control, Session
相关模式： Strategy
相关原则：1, 2, 4, 9
**基于角色的访问控制（Role-Based Access Control）**
促使一个安全的内部访问资源的机制。
参与者：保护对象（Protection Object），Right, Role, Roles，User。Roles就是一些对象的组合，Right object定义了之间的关系，每个用户都可以被指定到某个Roles中。
限制：只有授权目标可以指定Role。
后果：保密性，完整性，可用性增强，性能提高（减少访问消耗），花销减少（开发阶段花销提高），管理更加简便（以Group的形式管理）。
相关安全模式：Limited View, CP, Session
相关模式： Strategy，Oberserver
相关原则：4, 6, 7
结论：安全模式有助于追踪系统的非功能性安全需求。
**參考資料**
Betty Cheng, MichiganState University, softwareengineering lectures
