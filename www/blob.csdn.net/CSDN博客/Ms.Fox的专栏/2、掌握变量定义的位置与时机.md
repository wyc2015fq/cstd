# 2、掌握变量定义的位置与时机 - Ms.Fox的专栏 - CSDN博客
2014年10月18日 09:32:11[lulu-lu](https://me.csdn.net/smbluesky)阅读数：280
个人分类：[C++：注意事项](https://blog.csdn.net/smbluesky/article/category/2641013)
变量的定义建议离使用位置越近越好，尽量避免变量作用域的膨胀。
如下代码：
string  GetSubStr(const string& str,size_t iPos)
{
string strSubstr;
if (str.size()<iPos)
{
throw logic_error("iPos is too larger!");
}
strSubstr=str.substr(iPos);
return strSubstr;
}
**在上述代码中，对象strSubstr没有完全被使用。如果抛出异常，得付出strSubstr构造和析构的代价。**
string  GetSubStr(const string& str,size_t iPos)
{
if (str.size()<iPos)
{
throw logic_error("iPos is too larger!");
}
string strSubstr;
strSubstr=str.substr(iPos);
return strSubstr;
}
**改了后，也不是最优的，strSubstr虽然定义，但未对它进行初始化，也就是说在赋值之前strSubstr还需要进行default构造初始化。**
**更受欢迎的做法是直接通过初始化的方法实现，跳过无意义的default构造过程：**
string  GetSubStr(const string& str,size_t iPos)
{
if (str.size()<iPos)
{
throw logic_error("iPos is too larger!");
}
string strSubstr（str.substr(iPos)）;
return strSubstr;
}
通过这种方式，能够有效的减少命名污染问题，同时提高代码的可读性和执行效率。
在C++中，避免命名污染问题：
1、命名空间
2、延迟变量定义的位置
注意：
如果变量定义在循环体内试验，那么把它定义于循环体内还是循环体外？
方法A
ClassA obj;
for (int i=0;i<n;i++)
{
obj=与i相关的某个值;
}
方法B
for (int i=0;i<n;i++)
{
ClassA obj=与i相关的某个值;
}
方法A和方法B两种模式，操作代价可总结如下：
          方法A：1个ClassA构造+ N个赋值操作+ 1个ClassA析构
         方法B：N个ClassA构造+ N个赋值操作+ N个ClassA析构
当n很大时，赋值操作代价较高，则B较好；
如果构造和析构代价较高，则B较好。
