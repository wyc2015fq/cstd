# 数组和指针，怎么去理解？ - Ms.Fox的专栏 - CSDN博客
2014年10月22日 16:35:39[lulu-lu](https://me.csdn.net/smbluesky)阅读数：640
个人分类：[C++：注意事项](https://blog.csdn.net/smbluesky/article/category/2641013)
指针可以帮助开发人员处理复杂的数据结构，直接处理内存地址。
但是不恰当地使用指针将会导致内存泄露、内存悬挂、野指针（不安全指向）等问题的出现，
将威胁到软件系统的稳定性和安全性。
内存悬挂：如果已释放了对象，却没有将对应的指针置为NULL，该指针就是所谓的“悬挂指针”。
delete p; p=NULL;
野指针：指向被释放的或者访问受限的垃圾内存的指针。
成因：没有被初始化，delete或free后没有置NULL，指针操作超越了变量的作用范围。
class A
{
public:
void Func(void){ cout << “Func of class A” << endl; }
};
class B
{
public:
A *p;
void Test(void)
{
A a;
p = &a; // 注意 a 的生命期 ，只在这个函数Test中，而不是整个class B
}
void Test1()
{
p->Func(); // p 是“野指针”
}
};
一个指针变量有两个属性，一个是它的值（即地址），另外一个是它的类型。
指针的数据类型有两个作用：
1、指示编译在解引用时从内存中读取几个字节，指针指向 下一个元素内存 跳变几个字节； 
——关于这个还是要继续找找资料看看吧
2、指示编译在进行指针类型转换时如何进行类型检查和匹配。       int nValue=0xFF00;
**C/C++中有两类特殊指针：空指针和void型指针**
空指针可以给任何指针赋值，所以空指针一般用于判断指针是否合法。
void型指针，又称通用指针，可指向任何变量。C语言允许把任何变量的地址作为指针赋给通用指针。
表示这个指针指向的内存中的数据的类型要由用户来指定。
比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换；
也就是显式说明该指针指向的内存中是存放的什么类型的数据。如：
（int *)malloc(1024)————表示强制规定malloc返回的void*指针指向的内存中存放的是一个int型数据。
**指针变量支持解引用、算数操作等基本操作。**
解引用：
> 
对于c语言中指针的操作符有两个：&和*。
对于&，好理解，翻译的也不错，就是“取地址”的意思。
但对于*，翻译为“解引用”，是“取指针指向的地址的内容”。
算数操作：
   可实现指针的移动。如果指针指向一个数组，通过指针的算数操作在指向数组某个元素的指针上加上（减去）一个整型数值，
就可以计算出指向数组另外一个元素的指针值。
int ia[]={1,2,3,4};
int *pa=ia;            //pa 指向ia[0]
int *pa2=pa+4;    //pa2指向ia[4]
注意：算数操作仅支持两种形式：指针+/-整数 （如上面代码）； 指针 - 指针。
如果两个指针指向同一个数组,它们就可以相减,其结果为两个指针之间的元素数目。
无指针+指针，以及不能对void *指针进行算数操作。
如果还不是很懂，可以看看http://blog.csdn.net/gdmmhym/article/details/6451554 这个网页的东西，解释的还挺清楚的。
**const 修饰指针**
有两种：指向const对象的指针； const 指针。
指向const对象的指针，不允许用指针修改指针所指向的对象。
const指针，能过指针可实现所指向对象的修改，但不允许指针的值发生变化。“自以为指向const的指针”

