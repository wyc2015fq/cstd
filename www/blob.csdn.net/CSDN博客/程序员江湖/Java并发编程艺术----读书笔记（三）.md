# Java并发编程艺术----读书笔记（三） - 程序员江湖 - CSDN博客





2017年03月23日 23:59:15[黄小斜](https://me.csdn.net/a724888)阅读数：300








3java内存模型

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235321846-979627907.png)



java线程利用共享内存进行通信

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235327268-1175468287.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235342205-465988006.png)





实例、静态内容、数组、类都存在堆内存，在线程间共享。

而局部变量和方法参数等不共享。

a线程将共享变量写入主内存再被b读取到。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235356424-1571368527.png)



java的源代码编译和处理会经过指令重排。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235415252-189669784.png)



缓冲区可以提高效率，但可能导致指令重排。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235425205-1333108338.png)



读脏数据：

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235433674-352043173.png)



内存屏障可以组织特定重排序

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235439440-1228423215.png)



一个模型用来保证先后顺序

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235444643-1841593035.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235450283-1173683896.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235454705-1275204855.png)



保证重排序不影响单线程的的执行结果。即不会对存在数据依赖的操作做重排序

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235459205-480145351.png)



单线程按顺序执行指令只是一个幻觉！

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235503924-836198595.png)



指令重排可能导致多线程结果出错。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235508361-1883641375.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235513315-994516593.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235518471-883478438.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235523143-1737843900.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235528127-316719992.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235535299-91892438.png)



volatile变量的读写过程。volatile变量改写时，其他线程的内存中改变量会置为无效

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235543455-1466724053.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235552518-236929615.png)



volatile通过内存屏障实现增强语义

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235603893-403966620.png)








![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235608033-1172609908.png)



锁的语义与volatile几乎一致。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235613143-1771135734.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235618658-1368738257.png)



公平锁：读volatile变量，如果可以则获取锁，执行操作，再写volatile变量。

非公平：不论是否可以获取锁，先用cas操作读volatile变量并修改。

于是这两个锁都有volatile的读写语义。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235624955-1191465828.png)



什么是cas？

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235632783-1466006551.png)



cas操作就是比较并交换，可以用这个原理实现原子操作，但是本身存在一些不足。

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235638393-1874814044.png)



新版jdk解决了cas操作所存在的一些问题，可以赋予cas读写volatile变量的语义，从而使多线程的指令不会产生错误重排序，并且可以较好地实现原子操作，使多线程的通信成为可能，这也是并发包concurrent的基础

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235643346-1794069842.png)



并发包实现原理

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235648252-1527790586.png)



final：略



单例模式中使用的双重检查锁定

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235653205-485529838.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235658908-1431128510.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235703861-779032914.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235708440-958021110.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235712502-760462230.png)





![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235716471-387493028.png)



比较两个可行方案

![](http://images2015.cnblogs.com/blog/1092007/201703/1092007-20170323235720705-861752204.png)







