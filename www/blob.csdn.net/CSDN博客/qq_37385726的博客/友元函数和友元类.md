# 友元函数和友元类~ - qq_37385726的博客 - CSDN博客





2017年04月29日 17:55:00[啧啧啧biubiu](https://me.csdn.net/qq_37385726)阅读数：156
个人分类：[C++](https://blog.csdn.net/qq_37385726/article/category/6862768)









我们知道类内的私有成员是不能被类外访问的，但是总会有时候有这个需求去访问，那怎么办到类外可以去访问到类内的数据成员呢？这时就出现了友元函数和友元类。

**①友元函数：**

1.友元函数在类内声明，但是但不属于类的成员函数（所以在类外定义定义的时候不可以加上作用域限定符【：：】）。可以在类内的任何地方声明，不受访问控制符的限制（不是类内的成员函数当然就不受限制）

2.友元函数可以是普通函数，也可以是其他类的成员函数。

3.通过友元函数去访问类内的成员的时候，要通过参数传递该类的对象来进行，具体形式是用对象名或对象指针去访问类的数据成员。

4.友元函数的声明方式：

First： 当友元函数是普通函数的时候。——friend void 友元函数名 ( 把它当朋友的类的类名 对象名 )  {}；

Second：当友元函数是其他类的成员函数的时候。——friend void 其他类名::友元函数名（把它当朋友的类的类名 对象名）{}；

5.思考终究话题（笑哭），友元函数存在的意义是什么？

至少对于我而言，如果这个友元函数只是一个普通函数，与其它类一点关系都没有的时候，我觉得这是没有什么意义的。(这个想法现在不对了)

友元函数作为普通成员函数的意义是可以直接用函数名去调用，而不是用对象去调用，因为有时候这个函数的返回值并不希望是另一个对象的函数

见下例：




```cpp
#ifndef _WOSHILEIA_H_
#define _WOSHILEIA_H_
#include
using namespace std;
class Integer
{
public:
	Integer(int num);
	~Integer(void);
	void GetInteger(void);
	friend int SumInteger(Integer a, Integer b);  //定义友元函数可以是这个函数被调用的时候只要给到函数名，不用是某个对象的函数
				 //这大概就是普通函数做友元函数的意义吧
	//static int SumInteger(Integer a, Integer b); //定义静态成员函数也可以使这个函数被调用的时候不用用对象去调用，而是用类名去调用
private:
	int value;
	static int sum;
};
#endif
```



```
#include"woshileia.h"
int Integer::sum = 0;
Integer::Integer(int num)
{
	value = num;
	
}
Integer::~Integer(void){};
void Integer::GetInteger(void)
{
	cout << "value=" << value << endl;
}
int SumInteger(Integer a, Integer b)
{
	Integer::sum = a.value + b.value;
	return Integer::sum;
}
```



```cpp
#include"woshileia.h"
#include
int main(void)
{
	Integer a(3), b(5);
	cout<<"sum="<
```





在友元函数是其他类的成员函数的时候，和友元类的成员函数的时候，意义是——在其他类里可以去访问类内的数据成员。




**②友元类**

声明方式见如下代码：




```cpp
#include
using namespace std;
#include
class distance;//因为我们要把distance声明成CPoint的友元类，所以先要告诉编译器distance是一个类。
class CPoint
{
public:
	CPoint(int xx, int yy)
	{
		x = xx;
		y = yy;
	}
	friend class distance;//将distance声明成CPoint的友元类  的格式
private:
	int x, y;
};
class distance
{
public:
	double point_to_oralpoint(CPoint p1) //可以通过参数为CPoint的类的对象去访问CPoint中的数据成员
	{
		return sqrt(p1.x*p1.x + p1.y*p1.y);
	}
};
```





B为A的友元类，那么B中的每一个函数都是A的友元函数，也就都满足上面说的那些性质了。



