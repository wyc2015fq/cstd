# 有坑的最短路径问题 - qq_37385726的博客 - CSDN博客





2018年05月30日 22:18:12[啧啧啧biubiu](https://me.csdn.net/qq_37385726)阅读数：55标签：[最短路径问题																[多重边																[Floyd																[有坑...](https://so.csdn.net/so/search/s.do?q=有坑...&t=blog)
个人分类：[ACM																[ACM 图论](https://blog.csdn.net/qq_37385726/article/category/7693052)](https://blog.csdn.net/qq_37385726/article/category/7683299)







## [A - The Road to Radio](https://vjudge.net/problem/HDU-1874)
[HDU - 1874](https://vjudge.net/problem/17632/origin)




**题目看起来很简单，直接用floyd算法就能过的题，但是WA了无数次，因为存在两点之间有多重边的情况....此时就取最小**



![](https://img-blog.csdn.net/20180530221604930?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mzg1NzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)




**Floyd算法重点**

**1.初始化操作，对于邻接矩阵，对角线初始化为0，非对角线初始化为INF，然后根据有的边和权值进行初始化**

**2.算法核心，三重循环**

**![](https://img-blog.csdn.net/20180530221743566?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mzg1NzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)**



```cpp
#include<iostream>
using namespace std;
#include<algorithm>
#include<memory.h>

int graph[200][200];
int n;

void floyd()
{
	for(int i=0;i<n;i++)
	{
		for(int k=0;k<n;k++)
		{
			for(int p=0;p<n;p++)
			{
				graph[k][p]=min(graph[k][p],graph[k][i]+graph[i][p]);
			}
		}
	}
	
}

int main(void)
{
	int m;
	while(~scanf("%d %d",&n,&m))
	{
		for(int i=0;i<n;i++)
		{
			for(int k=0;k<n;k++)
			{
				graph[i][k]=100000000;
			}
			graph[i][i]=0;
		}
		int x,y,w;
		for(int i=0;i<m;i++)
		{
			cin>>x>>y>>w;
			if(w<graph[x][y])
			{
				graph[x][y]=w;
				graph[y][x]=w;
			}
			
		}
		floyd();
		int v1,v2;
		cin>>v1>>v2;
		if(graph[v1][v2]==100000000)
		{
			int ppp=-1;
			cout<<ppp<<endl;
		}
		else
		{
			cout<<graph[v1][v2]<<endl;
		}
	}	
	return 0;
}
```](https://so.csdn.net/so/search/s.do?q=Floyd&t=blog)](https://so.csdn.net/so/search/s.do?q=多重边&t=blog)](https://so.csdn.net/so/search/s.do?q=最短路径问题&t=blog)




