# 关于EOF和Ctrl+Z~ - qq_37385726的博客 - CSDN博客





2017年03月28日 17:25:52[啧啧啧biubiu](https://me.csdn.net/qq_37385726)阅读数：289










```
#include
#include
#include
int main(void)
{
	int ch;//可以留意一下为什么这里用int型的变量哦
	while ((ch = getchar()) != EOF)
	{
		putchar(ch);
	}
	system("pause");
	return 0;
}
```




**在说正题之前，让我们先来扯三个重要的事情（好像有点多。。）**

**1.关于EOF：是end of file的缩写，是定义在<stdio.h>里面的一个宏定义#define EOF (-1)，是getchar(),scanf()读取到文件结尾时所返回的值，所以我们会用while ((ch = getchar()) != EOF)去判断是否读到了文件尾。**

**  关于为什么是-1，因为getchar()函数的返回值介于0~127之间，扩展后也介于0~255之间，无论哪一种情况，-1都不对应任何字符，所以该值可以直接标记文件结尾。**

**   但是我们也应该注意到，并不是所有的系统都是将EOF规定成-1的，但是不管规定成什么，这个值一定与字符所对应的返回值是不同的。而我们只用include<stdio.h>文件，并且使用EOF而不是-1，就没得任何问题，这样还可以提高文件的可移植性。**

**2.关于Ctrl+Z：文件结尾标识符**

**  在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D是作为文件结尾的信号**

**  在PC和许多微型计算机中，是按下Ctrl+Z作为文件结束的信号**

**3.先解决上面代码留下来的问题：为什么用int型的变量？**

**我们的反应应该是char ch;但是关于char有没有符号这个事情，是编译器自己规定的，所以如果规定是无符号的，将-1赋给变量必定会造成下溢，导致的结果会是一个正数（255）得不到理想的效果，并且我们还知道getchar函数的返回值是int型的，putchar(ch)可以将int型的变量转换成char型的变量打印出来，并不会影响，所以为了提高程序的可移植性我们还是一般将这个ch设置成int型的~**



**进入正题**

=================================================================

输入：helloCrtl+Z[回车]

输出：hello→【光标在这里】Ctrl+Z[回车]

结束程序

//思考这里的光标为什么没有换行






输入：helloCrtl+ZCrtl+Z[回车]

输出：hello→【光标在这里】Ctrl+Z[回车]

结束程序

//思考这里为什么只出现了一个箭头




输入：hello[回车]

输出：hello

          【光标在这里】Ctrl+Z[回车]

结束程序




**=================================================================**



**分析一下上面输入和输出和结束程序的时候，有几点要说明的：**

1.如果Crtl+Z前面有字符（非回车）的话，编译器并不会停止程序，而是会把输入的这个Crtl+Z理解成你是想让计算机输出一个Crtl+Z对应的字符，即→。只有这时候当它输出完以后再输入一个Crtl+Z才会结束程序。（这是一种结束的办法但是不好，因为我们还输出了我们不需要的一个→）

2.Crtl+Z位于字符串或字符后面还有一个作用是告诉编译器该行输入已经结束了，后面再有的东西不用看了，这也就是为什么第一个输入案例里光标没有换行，这也就是为什么第二个输入案例里只输出了一个箭头。

3.正确的结束文件输入的办法应该是，如果这行前面没有字符或字符串，直接Ctrl+Z[回车]

                                                             如果这行前面有字符或字符串，则先换行再Ctrl+Z[回车]






