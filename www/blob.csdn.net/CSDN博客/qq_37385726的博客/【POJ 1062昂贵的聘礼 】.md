# 【POJ 1062昂贵的聘礼 】 - qq_37385726的博客 - CSDN博客





2018年05月27日 12:17:22[啧啧啧biubiu](https://me.csdn.net/qq_37385726)阅读数：40








![](https://img-blog.csdn.net/20180527121143372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mzg1NzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180527121158160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mzg1NzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





将Input转化成图，求解最短路径问题

![](https://img-blog.csdn.net/20180527121652464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mzg1NzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


```cpp
#include<iostream>
using namespace std;
#include<memory.h>
#include<limits.h>

int Graph[105][105];
bool mark[105];
int v[105];
int grade[105];
int nodeal;
int M,N,quizhangL;


int getMin()
{
	int temp,i;
	for(i=0;i<N+1;i++)
	{
		if(mark[i]==0&&grade[i]>=(quizhangL-M))
		{
			temp=i;
			break;
		}
	}
	for(int k=i+1;k<N+1;k++)
	{
		
		if(mark[k]==0&&grade[k]>=(quizhangL-M)&&v[k]<v[temp])
		{
			temp=k;
		}
	}
	return temp;
}

int first(int v)
{
	for(int i=0;i<N+1;i++)
	{
		if(Graph[v][i]!=0)
		{ 
			return i;
		}
	}
	return N+2;
}

int next(int v,int w)
{
	for(int i=w+1;i<N+1;i++)
	{
		if(Graph[v][i]!=0)
		{
			return i;
		}
	}
	return N+2;
}

void Dijkstral()
{
	int min=getMin();
	mark[min]=1;
	for(int i=first(min);i<N+1;i=next(min,i))
	{
		if(v[i]>v[min]+Graph[min][i])
		{
			v[i]=v[min]+Graph[min][i];
		}
	}
}

int main(void)
{
	while(~scanf("%d %d",&M,&N))
	{
		int P,L,X;
		int temp;
		memset(mark,0,sizeof(mark[0])*(N+2));
		for(int i=0;i<N+1;i++)
		{
			v[i]=100000;
		}
		v[0]=0;
		for(int i=0;i<N+1;i++)
		{
			memset(Graph[i],0,sizeof(Graph[i][0])*(N+1));
		}
		for(int i=0;i<N;i++)
		{
			cin>>P>>L>>X;
			if(i==0)
			{
				quizhangL=L;
				grade[0]=L;
				Graph[0][N]=P;
				Graph[N][0]=P;
				for(int k=0;k<X;k++)
				{
					int tempnum,tempP;
					cin>>tempnum>>tempP;
					Graph[tempnum-1][N]=tempP;
					Graph[N][tempnum-1]=tempP;
				}
			}
			else
			{
				Graph[0][i]=P;
				Graph[i][0]=P;
				grade[i]=L;
				for(int k=0;k<X;k++)
				{
					int tempnum,tempP;
					cin>>tempnum>>tempP;
					Graph[tempnum-1][i]=tempP;
					Graph[i][tempnum-1]=tempP;
				}
			}
			if(L<quizhangL-M)
			{
				nodeal++;
			}
		}
		for(int i=0;i<N+1-nodeal;i++)
		{
			Dijkstral();
		}
		cout<<v[N]<<endl;
	}
	return 0;
}
```




