# 关于浮点值的上溢和下溢和不符合“常识”的情况&整数上溢和整数下溢~ - qq_37385726的博客 - CSDN博客





2017年03月04日 14:56:00[啧啧啧biubiu](https://me.csdn.net/qq_37385726)阅读数：1292








**一：关于浮点值的上溢**

上溢：是指由于数字过大，超过当前类型所能表示的范围

这种行为在过去是没定义的，不过现在C语言规定，在这种情况下会给toobig赋上一个表示无穷大的特定值，而且printf显示该值为inf或infinity。

比如对于vs2010来说，如果一个值发生了上溢，显示的就是1.#INF00e+000~




**二：关于浮点数的下溢**

下溢：是指由于数值太小，低于当前类型所能表示的最小的值，计算机就只好把尾数位向右移，空出第一个二进制位，但是与此同时，却损失了原来末尾有效位上面的数字，这种情况就叫做下溢。




PS.C语言把损失了精度的浮点值称为低于正常的浮点值。

由此看来，如果这是的值正好介于最小的浮点数那里，除以10都会使其变成一个低于正常的值，比如，除以10后向右移了1位，则会舍掉丢失的那一位，但是C编译器本身会产生一些十分接近原来丢失这位的值补在后面，eg.下面这个程序所显示的。


当然，如果除以一个很大的数，就会造成所有位均为0的结果，因为每一位在右移的过程中都舍去了==







```
#include
int main(void)
{
	float toobig = 9999999e100*100.0f;
	float temp = 0.1234e-37 / 10;
	float toosmall = 0.1234e-38/10;
	printf("%e\n", toobig);
	printf("%e\n", temp);
	printf("%e\n", toosmall);
	getchar();
	return 0;
}


//输出结果：1.#INF00e+000     1.23000e-039     1.233997e-040
//从输出结果上分析，toobig发生了上溢，temp正常，toosmall发生了下溢~
```








**三：不符合“常识”的情况**

比如：asin()函数里面的值应该是-1~1的，返回值是参数对应的弧度值。但是如果参数输入的是1.5，那么这就是一个不符合常识的情况了；还有像sqrt(-1),这也是一个不符合常识的情况。

所以综上，我们对什么叫不符合常识的情况有了一个基本的了解，那么下面我们来看看在这种情况下会输出什么呢？




在c语言里，输出的是IND，在linux里面输出的是NAN(not a number)。

下面就举具体的代码来说明这种不符合尝试的情况~






```
#include
#include
int main(void)
{
	double a = asin(1.5);
	printf("%lf", a);
	getchar();
	return 0;
}

//输出结果为-1.#IND00
//IND也就是我们所说的不符合常识的情况在C语言里面的输出结果
```





**&**



**整数上溢，整数下溢**

这两种其实是一个道理，比如signed char型的变量，赋值128就是上溢了，那么输出结果就是-128；赋值-129就是下溢了，那么输出结果就是127；赋值256，那么输出结果就是0。

是熟悉的套路~

就不细说啦~





