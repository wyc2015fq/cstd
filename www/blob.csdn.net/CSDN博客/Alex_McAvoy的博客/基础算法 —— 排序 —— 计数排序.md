# 基础算法 —— 排序 —— 计数排序 - Alex_McAvoy的博客 - CSDN博客





2018年04月17日 15:18:46[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：57








# 【分类】

 非比较类排序

# 【基本思想】

 对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，在代码中作适当的修改即可。

# 【特点】

 数据结构：数组

 稳定性：稳定

 要求：待排序数中最大数值不能太大。

# 【复杂度与辅助空间】

输入的元素是 n 个 0 到 k 之间的整数时 

 时间复杂度：O(n+k)

 所需辅助空间：O(k)

# 【算法步骤】
- 找出待排序的数组中最大和最小的元素
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

# 【源程序】

```cpp
#define MAXNUM 20//待排序数的最大个数
#define MAX 100//待排序数的最大值
int sorted_arr[MAXNUM]={0};
/*arr:待排序数组，sorted_arr：排好序的数组，n：待排序数组长度*/
void countSort(int *arr, int *sorted_arr, int n)  
{   
    int i;   
    int *count_arr=new int[MAX+1];

    memset(count_arr,0,sizeof(int) * (MAX+1));//初始化计数数组   
    
    for(i = 0;i<n;i++)  //统计i的次数   
        count_arr[arr[i]]++;  
    
    for(i = 1; i<=MAX; i++)  //对所有的计数累加，作用是统计arr数组值和小于小于arr数组值出现的个数
        count_arr[i] += count_arr[i-1];   
     
    for(i = n-1; i>=0; i--)  //逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到新的数组中  
    {  
        sorted_arr[count_arr[arr[i]]-1] = arr[i];//count_arr[arr[i]]表示arr数组中包括arr[i]和小于arr[i]的总数
        count_arr[arr[i]]--; //如果arr数组中有相同的数，arr[i]的下标减一
    }
    delete []count_arr;
}
```





