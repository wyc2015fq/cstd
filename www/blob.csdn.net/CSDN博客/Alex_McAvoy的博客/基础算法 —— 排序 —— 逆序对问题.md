# 基础算法 —— 排序 —— 逆序对问题 - Alex_McAvoy的博客 - CSDN博客





2018年04月20日 13:17:26[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：119








# 【概述】

设A为一个有n个数字的有序集，其中所有数字各不相同。如果存在整数i、j，使得1<=i<j<=n且A[i]>A[j]，则{A[i],A[j]}这个有序对称为A的一个逆序对。

例如：集合{3,1,4,5,2}的逆序对有{3,1}、{3,2}、{4,2}、{5,2}共4个。

而逆序对问题，即：对给定的数组序列，求其逆序对的数量。

# 【分析】

从定义上分析，逆序对就是数列中任意两个数满足大的在前，小的在后的组合。如果将这些逆序对都调整为顺序，那么整个数列就变的有序，即排序。

因而容易想到冒泡排序的机制正好是利用消除逆序来实现的，也就是说，交换相邻两个逆序数，最终实现整个序列有序，那么交换的次数即为逆序对的数量。

但由于冒泡排序本身效率不高，时间复杂度为O（n^2），对于n较大的情况下不适用，因此我们用归并排序来解决逆序对问题。

# 【程序实现】

```cpp
/*只需修改原有归并程序，当右边序列元素为较小值时，就统计其产生的逆序对数量，即可完成逆序对统计*/
void msort(int s,int t)
{
    if(s==t)//只有一个数字则返回
        return;
        
    int mid=(s+t)/2;
    msort(s,mid);//分解左序列
    msort(mid+1,t);//分解右序列
    
    int i=s,j=mid+1,k=s;
    while(i<=mid&&j<=t)
    {
        if(a[i]<=a[j])
        {
            r[k]=a[j];
            k++;
            i++;
        }
        else
        {
            r[k]=a[j];
            k++;
            j++;
            ans+=mid-i+1;//统计产生逆序对的数量
        }
    }
    while(i<=mid)//复制左边子序列剩余
    {
        r[k]=a[i];
        k++;
        i++;
    }
    while(j<=t)//复制右边子序列剩余
    {
        r[k]=a[j];
        k++;
        j++;
    }
    for(i=s;i<=t;i++)
        a[i]=r[i];
}
```





