# 食物链（POJ-1182） - Alex_McAvoy的博客 - CSDN博客





2018年11月17日 16:08:04[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：55








> 
# Problem Description

动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 

现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 

有人用两种说法对这N个动物所构成的食物链关系进行描述： 

第一种说法是"1 X Y"，表示X和Y是同类。 

第二种说法是"2 X Y"，表示X吃Y。 

此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 

1）    当前的话与前面的某些真的话冲突，就是假话； 

2）    当前的话中X或Y比N大，就是假话； 

3）    当前的话表示X吃X，就是假话。 

你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。 

# **Input**

第一行是两个整数N和K，以一个空格分隔。 

以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 

若D=1，则表示X和Y是同类。 

若D=2，则表示X吃Y。

# Output

只有一个整数，表示假话的数目。

# Sample Input

**100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5**

# Sample Output

**3**


———————————————————————————————————————————————————————

思路：带权并查集的种类问题。

对于这三种种类，同类可以用0表示，其他两种分别用1表示该结点被父节点吃，2表示该节点吃父节点。 

该题之所以能用并查集进行路径压缩，是因为存在A吃B，B吃C，C吃A的三角关系。这是我们能在路径压缩中使用**num[x] = (num[x] + num[fa]) % 3**和更新时使用**num[fb] = (3 - num[v] + num[u] + (p - 1)) % 3**的原因（否则就是一种链式关系了）。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define MOD 16007
#define INF 0x3f3f3f3f
#define N 100001
#define LL long long
using namespace std;
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
int f[N], num[N];
int find(int x){
    if(x != f[x]){
        int fa = f[x];
        f[x] = find(f[x]);
        num[x] = (num[x] + num[fa]) % 3;
    }
    return f[x];
}

int main()
{
    int n, q, ans = 0;
    scanf("%d%d", &n, &q);
    for(int i = 0; i < n; i++)
        f[i] = i;
    for(int i = 0; i < q; i++){
        int p, u, v;
        scanf("%d%d%d", &p, &u, &v);

        if(u > n || v > n)
            ans++;
        else if(p == 2 && u == v)
            ans++;
        else{
            int fa = find(u);
            int fb = find(v);
            if(fa == fb){
                if(num[v] != (num[u] + (p - 1)) % 3)
                    ans++;
            }
            else{
                f[fb] = fa;
                num[fb] = (3 - num[v] + num[u] + (p - 1)) % 3;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```





