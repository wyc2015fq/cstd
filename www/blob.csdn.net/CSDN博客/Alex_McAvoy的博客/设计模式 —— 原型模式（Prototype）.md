# 设计模式 —— 原型模式（Prototype） - Alex_McAvoy的博客 - CSDN博客





2019年04月13日 21:10:52[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：53
个人分类：[设计模式](https://blog.csdn.net/u011815404/article/category/8856120)

所属专栏：[设计模式学习笔记](https://blog.csdn.net/column/details/35125.html)









# 【概述】

原型模式：给出一个原型对象来指明所要创建的对象类型，然后用复制这个原型对象创建出更多的同类型对象。 

其本质是**克隆生成对象，通过自身复制自身来创建新对象。**

当要生成一大批很相像的类的实例时，不用每次去做重复的赋值工作，有了原型，只要生成一个实例，再通过 clone 来生成其它的实例，然后再一一修改其它实例不同的地方。

Java 语言中提供了 clone 方法，定义在 Object 类中，需要实现克隆功能的类，只需要实现 java.lang.Cloneable 接口即可。

# 【与工厂模式关系】

原型引入的初衷是减少重复的赋值工作，但其实现起来，完全可以达到工厂模式的效果，甚至比工厂模式更方便、灵活，因而原型模式在功能上可以代替工厂模式。 

工厂模式实现的生产产品的功能，关键是利用了继承的特性，即生成的产品一定是由同一个抽象产品类派生出来的，因此在工厂模式下，如果要生成一类产品，就要引入一个抽像产品类，然后再由它派生出具体产品。

同样，在原型模式中，完全可以同样定义一个 “ 抽象产品－具体产品 ” 层次，再利用具体产品本身的 clone 功能来产生具体产品本身，从而达到实现工厂模式功能的目的。

实际上，在原型模式中，由于每个具体产品都具有生成自己拷贝的功能，每个具体产品就扮演了工厂模式里的具体工厂的角色。 

# 【UML】

![](https://img-blog.csdnimg.cn/2019041321511548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)
- 客户角色：Client，客户类提出创建对象的请求。 
- 抽象原型角色：Prototype，是抽象角色，通常由一个接口或抽象类实现，其给出所有的具体原型类所需的接口。
- 具体原型角色：Concrete Prototype，被复制的对象，需要实现抽象原型角色所要求的接口。

# 【优缺点】

浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。

深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。

优点
- 允许动态增加或减少产品类，由于创建产品类实例的方法是产品类内部具有的，因此增加新产品对整个结构没有影响。
- 提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的等级结构，而原型模式不需要。

缺点
- 每个原型的子类都必须实现克隆的操作，当需要深复制时，克隆方法十分麻烦，必须要能够递归地让所有的相关对象都要正确地实现克隆。



