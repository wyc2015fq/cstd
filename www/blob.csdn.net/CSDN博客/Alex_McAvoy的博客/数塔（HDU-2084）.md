# 数塔（HDU-2084） - Alex_McAvoy的博客 - CSDN博客





2018年03月27日 23:25:59[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：66








# Problem Description

    在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：

    有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？

    已经告诉你了，这是个DP的题目，你能AC吗?

![](https://img-blog.csdn.net/20180327232324788)

# Input

    输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。

# Output

    对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。

# Sample Input

**1573 88 1 0 2 7 4 44 5 2 6 5**

# Sample Output

**30**

————————————————————————————————————————————

思路：经典的dp题

设：dp[i][j]为第i行第j列的最大和

则：

    状态转移方程：dp[i][j]=max(dp[i-1][j-1],f[i-1][j])+num[i][j];

    边界条件：dp[1][1]=dp[1][1]

记得在最后一行寻找最大值即可

# Source Program

```cpp
#include<iostream>
#include<cstring>
#define N 101
using namespace std;

int num[N][N];
int dp[N][N];

int main()
{
    int c,n;
    int i,j;

    cin>>c;
    while(c--)
    {
        memset(dp,0,sizeof(dp));/*初始化*/

        cin>>n;
        for(i=1;i<=n;i++)
            for(j=1;j<=i;j++)
                cin>>num[i][j];

        dp[1][1]=num[1][1];/*边界条件*/
        for(i=2;i<=n;i++)
            for(j=1;j<=i;j++)
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+num[i][j];//状态方程

        int maxx=-99999999;
        for(i=1;i<=n;i++)//寻找最后一行最大值
            maxx=max(maxx,dp[n][i]);
        cout<<maxx<<endl;
    }
}
```





