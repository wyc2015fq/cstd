# 找连续数（HDU-5247） - Alex_McAvoy的博客 - CSDN博客





2019年01月14日 22:02:18[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：147








> 
# Problem Description

小度熊拿到了一个无序的数组，对于这个数组，小度熊想知道是否能找到一个k 的区间，里面的 k 个数字排完序后是连续的。

现在小度熊增加题目难度，他不想知道是否有这样的 k 的区间，而是想知道有几个这样的 k 的区间。

# **Input**

输入包含一组测试数据。

第一行包含两个整数n，m，n代表数组中有多少个数字，m 代表针对于此数组的询问次数，n不会超过10的4次方，m 不会超过1000。第二行包含n个正整数，第 I 个数字代表无序数组的第 I 位上的数字，数字大小不会超过2的31次方。接下来 m 行，每行一个正整数 k，含义详见题目描述，k 的大小不会超过1000。

# Output

第一行输"Case #i:"。(由于只有一组样例，只输出”Case #1:”即可)

然后对于每个询问的 k，输出一行包含一个整数，代表数组中满足条件的 k 的大小的区间的数量。

# Sample Input

**6 23 2 1 4 3 534**

# Sample Output

**Case #1:22**


思路：只有一组输入，但有 m 个询问，不难想出打表记录所有情况，关键在于 k 个数字排序后是连续的。

k 个数字排序后连续就意味着该区间的最大值减最小值等于区间长度-1，即：maxx-minn=j-i，因此如果一个区间满足上述情况，那么这个长度的数组值 +1 即可，此外，由于 k<=1000，因此要注意 j-i<=1000

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define MOD 16007
#define INF 0x3f3f3f3f
#define N 1000001
#define LL long long
using namespace std;
int n,m;
int a[N];
int res[N];
set<int> s;
void solve(){
    for(int i=0;i<n;i++){
        int minn=a[i],maxx=a[i];
        s.clear();
        for(int j=i;j<n&&j-i<=1000;j++){
            minn=min(minn,a[j]);
            maxx=max(maxx,a[j]);
            s.insert(a[j]);//统计当前个数

            if(maxx-minn==j-i)
                if(s.size()==maxx-minn+1)
                    res[s.size()]++;
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    solve();

    printf("Case #1:\n");
    while(m--){
        int k;
        scanf("%d",&k);
        printf("%d\n",res[k]);
    }

    return 0;
}
```





