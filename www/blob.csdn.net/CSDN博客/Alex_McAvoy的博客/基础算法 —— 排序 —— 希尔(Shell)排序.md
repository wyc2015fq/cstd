# 基础算法 —— 排序 —— 希尔(Shell)排序 - Alex_McAvoy的博客 - CSDN博客





2018年03月18日 10:13:54[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：102








# 【分类】

    插入类排序

# 【基本思想】    

    对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。

   开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量d逐渐缩小，分组数减少，各组的记录数增多，但由于已经按d−1分组排序，文件接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。

# 【工作原理】

    在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。

    步骤：
- 从第一个元素开始，该元素可以认为已经被排序选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1
- 按增量序列个数k，对序列进行k 趟排序
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

# 【特点】

     数据结构：数组

     稳定性：不稳定

# 【过程】

![](https://img-blog.csdn.net/20180318102343878)

            宏观排序

# 【复杂度与辅助空间】

 最差时间复杂度：O(n(logn)^2)

 最优时间复杂度：O(n)

 平均时间复杂度：根据步长序列的不同而不同

 所需辅助空间：O(1) 

# 【源程序】

```cpp
//A：输入数组，len:数组长度
void shell_sort(int A[],int len)
{
    int d;
  	int i,j;
    int temp;
    
    d=0;
    while (d<=n)// 生成初始增量(分组数)d
        d=3*d+1;
    
    while(d>=1)//循环的次数为增量缩小至1的次数
    {        
        for(i=d;i<len;i++)//循环的次数为第一个分组的第二个元素到数组的结束
        {      
            j=i-d;
            temp=A[i];
            while(j>=0&&A[j]>temp)
            {
                A[j+d]=A[j];
                j=j-d;
            }
            if((j+d)!=i)//防止自我插入
                A[j+d]=temp;//插入记录
        }
    }
    d=(d-1)/3;//递减增量
}
```





