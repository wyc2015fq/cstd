# 数字三角形（洛谷-P1216） - Alex_McAvoy的博客 - CSDN博客





2018年08月19日 22:21:17[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：107








## 题目描述

观察下面的数字金字塔。

写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

```
7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5
```

在上面的样例中，从7 到 3 到 8 到 7 到 5 的路径产生了最大

## 输入输出格式

**输入格式：**

第一个行包含 R(1<= R<=1000) ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

所有的被供应的整数是非负的且不大于100。

**输出格式：**

单独的一行,包含那个可能得到的最大的和。

## 输入输出样例

**输入样例#1：**

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**输出样例#1：**
`30`
## 源代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int dp[1005][1005]={0};
int num[1005][1005];
int main()
{
    int r;
    int i,j;

    cin>>r;
    for(i=1;i<=r;i++)
        for(j=1;j<=i;j++)
        {
            cin>>num[i][j];
            dp[i][j]=num[i][j];
        }

    for(i=r-1;i>0;i--)//从下向上找，直接输出dp[1][1]即可，可以省去一个循环查找最大值
        for(j=1;j<=i;j++)
            dp[i][j]+=max(dp[i+1][j],dp[i+1][j+1]);//当前值=左下值、右下值中的最大值
    
    cout<<dp[1][1]<<endl;

    return 0;
}
```





