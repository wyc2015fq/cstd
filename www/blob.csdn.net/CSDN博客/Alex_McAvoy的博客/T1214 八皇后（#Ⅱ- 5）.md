# T1214 八皇后（#Ⅱ- 5） - Alex_McAvoy的博客 - CSDN博客





2018年05月11日 15:49:15[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：1087








### 【题目描述】



会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 × 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。

对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。

给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。

### 【输入】

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1≤b≤92)。



### 【输出】

输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。

### 【输入样例】

```
2
1
92
```

### 【输出样例】

```
15863724
84136275
```

### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define N 100
using namespace std;
int a[N][N],b[N];
int vis[N][N];
int tot;
int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
void dfs(int step)
{
    if(step==8+1)
    {
        tot++;
        for(int i=1;i<=8;i++)
            a[tot][i]=b[i];
        return;
    }
    for(int i=1;i<=8;i++)
    {
        if(vis[0][i]==0&&vis[1][step+i]==0&&vis[2][step-i+8]==0)
        {
            vis[0][i]=1;
            vis[1][i+step]=1;
            vis[2][step-i+8]=1;
            b[step]=i;
            dfs(step+1);
            vis[0][i]=0;
            vis[1][i+step]=0;
            vis[2][step-i+8]=0;
        }
    }
}
int main()
{
    int n;
    cin>>n;
    dfs(1);
    while(n--)
    {
        int i;
        cin>>i;
        for(int j=1;j<=8;j++)
            cout<<a[i][j];
        cout<<endl;
    }
    return 0;
}
```





