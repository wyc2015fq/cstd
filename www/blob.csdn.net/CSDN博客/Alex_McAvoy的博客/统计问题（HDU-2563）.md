# 统计问题（HDU-2563） - Alex_McAvoy的博客 - CSDN博客





2018年03月29日 20:02:35[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：66
个人分类：[基础算法——递推																[HDU](https://blog.csdn.net/u011815404/article/category/7923257)](https://blog.csdn.net/u011815404/article/category/7615003)








# Problem Description

    在一无限大的二维平面中，我们做如下假设：
-  每次只能移动一格
- 不能向后走（假设你的目的地是“向上”，那么你可以向左走，可以向右走，也可以向上走，但是不可以向下走）
- 走过的格子立即塌陷无法再走第二次

求走n步不同的方案数（2种走法只要有一步不一样，即被认为是不同的方案）。

# Input

    首先给出一个正整数C，表示有C组测试数据

    接下来的C行，每行包含一个整数n (n<=20)，表示要走n步。

# Output

    请编程输出走n步的不同方案总数；

    每组的输出占一行。

# Sample Input

**212**

# Sample Output

**37**

————————————————————————————————————————————

思路：

设：第n步的走法为F(n)，往上走的步数为a(n)，往左或往右走的步数为b(n)

故：F(n)=a(n)+b(n)

由于不能往下走，所以向上走：a(n)=a(n-1)+b(n-1)（前（n-1）步内往上走的步数+前（n-1）步内往左或右的步数）

由于走过的不能返回，所以往左或右走：b(n)=2*a(n-1)+b(n-1)（向上走可以是左上和右上）

综上：F(n)=2*F(n-1)+F(n-2);

# Source Program

```cpp
#include<iostream>
using namespace std;
int main()
{
    int c,n;
    int a[21];
    int i;
    
    /*预处理*/
    a[1]=3;
    a[2]=7;
    for(i=3;i<=20;i++)
        a[i]=2*a[i-1]+a[i-2];

    cin>>c;
    while(c--)
    {
        cin>>n;
        cout<<a[n]<<endl;
    }
    return 0;
}
```






