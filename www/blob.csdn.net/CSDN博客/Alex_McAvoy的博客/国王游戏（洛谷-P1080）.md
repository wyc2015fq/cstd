# 国王游戏（洛谷-P1080） - Alex_McAvoy的博客 - CSDN博客





2018年04月14日 23:36:44[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：103








## 题目描述

恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。

## 输入输出格式

**输入格式：**

第一行包含一个整数 n，表示大臣的人数。

第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。

接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。

**输出格式：**

输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。

## 输入输出样例

**输入样例#1：**

```
3 
1 1 
2 3 
7 4 
4 6
```

**输出样例#1：**
`2`
## 说明

【输入输出样例说明】

按 1、2、3 号大臣这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；

按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；

按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；

按 2、3、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；

按 3、1、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；

按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。

因此，奖赏最多的大臣最少获得 2 个金币，答案输出 2。

【数据范围】

对于 20%的数据，有 1≤ n≤ 10，0 < a、b < 8；

对于 40%的数据，有 1≤ n≤20，0 < a、b < 8；

对于 60%的数据，有 1≤ n≤100；

对于 60%的数据，保证答案不超过 10^9；

对于 100%的数据，有 1 ≤ n ≤1,000，0 < a、b < 10000。

———————————————————————————————————————————————

思路：注意高精度！

## 源代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n;
int len=1;//表示高精度中字符串的长度
int a[100010],b[100010],c[100010],g[1000010];//a表示乘积，b表示左手，c表示右手
void multiplicative(int x)
{
    int i;
    for(i=1;i<=len;i++)
        g[i]*=b[x];
    for(i=1;i<=len;i++)
    {
        g[i+1]+=(g[i]/10);//进位
        g[i]%=10;
    }
    len++;
    while(g[len]>9)//>9的位置上进位
    {
        g[len+1]+=(g[len]/10);
        g[len]%=10;
        len++;
    }
    if(g[len]==0)//删前导0
        len--;
}
void division()//高精除
{
    int i;
    for(i=len;i>=1;i--)
    {
        g[i-1]+=((g[i]%c[n])*10);//将前一位%第n位大臣右手给下一位
        g[i]/=c[n];
    }
    while(g[len]==0)//处理首位
        len--;
    if(len==0)//防止减完
        cout<<1<<endl;

}
void quick_sort(int l,int r)
{
    int i,j,mid;
    int temp;

    i=l;
    j=r;
    mid=a[(l+r)/2];
    while(i<=j)
    {
        while(a[i]<mid) i++;
        while(a[j]>mid) j--;
        if(i<=j)
        {
            temp=a[i],a[i]=a[j],a[j]=temp;
            temp=b[i],b[i]=b[j],b[j]=temp;
            temp=c[i],c[i]=a[j],c[j]=temp;
            i++;
            j--;
        }
    }
    if(l<j) quick_sort(l,j);
    if(i<r) quick_sort(i,r);
}

int main()
{
    int i;

    cin>>n;
    cin>>b[0]>>c[0];
    for(i=1;i<=n;i++)
    {
        cin>>b[i]>>c[i];//输入每人左右手的金币数
        a[i]=b[i]*c[i];//两手金币数相乘
    }
    quick_sort(1,n);//从第一位大臣处开始排序

    g[1]=b[0];//从国王左手开始乘，赋初值
    for(i=1;i<n;i++) //所有左手的数字相乘
        multiplicative(i);
    division();//最后一个得到的最多，所以由n-1个左手乘积/第n个右手乘积
    for(i=len;i>=1;i--)//倒序输出
        cout<<g[i];

    return 0;
}
```





