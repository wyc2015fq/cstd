# T1280 滑雪（#Ⅱ- 9 - 3） - Alex_McAvoy的博客 - CSDN博客





2018年06月05日 23:25:39[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：331








### 【题目描述】

小明喜欢滑雪，因为滑雪的确很刺激，可是为了获得速度，滑的区域必须向下倾斜，当小明滑到坡底，不得不再次走上坡或等着直升机来载他，小明想知道在一个区域中最长的滑坡。滑坡的长度由滑过点的个数来计算，区域由一个二维数组给出，数组的每个数字代表点的高度。下面是一个例子：

11615141321724231231825221141920211056789

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小，在上面的例子中，一条可行的滑坡为25-24-17-16-1（从25开始到1结束），当然25-24……2-1更长，事实上这是最长的一条。

### 【输入】

输入的第一行为表示区域的二维数组的行数R和列数C（1≤R、C≤100），下面是R行，每行有C个数代表高度。

### 【输出】

输出区域中最长的滑坡长度。

### 【输入样例】

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

### 【输出样例】
`25`
### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 101
#define MOD 2520
#define E 1e-12
using namespace std;
int a[N][N],f[N][N];
int r,c;
int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
int dfs(int x,int y,int step)
{
    int temp=1;

    if(f[x][y]>0)
        return f[x][y];

    for(int i=0;i<4;i++)
    {
        int nx=x+dir[i][0];
        int ny=y+dir[i][1];
        if(nx>=1&&nx<=r&&ny>=1&&ny<=c&&a[x][y]>a[nx][ny])
            temp=max(temp,dfs(nx,ny,step+1)+1);
    }
    f[x][y]=temp;
    return temp;
}
int main()
{
    cin>>r>>c;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin>>a[i][j];

    int maxx=-INF;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            maxx=max(maxx,dfs(i,j,1));

    cout<<maxx<<endl;
    return 0;
}
```





