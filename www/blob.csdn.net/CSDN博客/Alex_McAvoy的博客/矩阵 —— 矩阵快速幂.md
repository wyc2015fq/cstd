# 矩阵 —— 矩阵快速幂 - Alex_McAvoy的博客 - CSDN博客





2019年03月27日 13:04:31[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：44
个人分类：[——————矩阵——————																[矩阵——矩阵快速幂](https://blog.csdn.net/u011815404/article/category/8800018)](https://blog.csdn.net/u011815404/article/category/8799708)








# 【概述】

矩阵快速幂利用矩阵的乘法与整数快速幂的结合，能够快速的算出 n 阶方阵 A 的 M 次幂 A^b，其结果仍是一个矩阵，无具体含义

矩阵快速幂的主要作用是：将数放到矩阵的不同位置，然后把普通递推式变成矩阵的等比数列，最后快速幂求解递推式，可以极大的降低时间复杂度

例如，对于递推公式：![f[n] = f[n-1]+ f[n-2] * 2+1](https://private.codecogs.com/gif.latex?f%5Bn%5D%20%3D%20f%5Bn-1%5D&plus;%20f%5Bn-2%5D%20*%202&plus;1)

可以构造矩阵：![\begin{bmatrix}f(n) \\ f(n-1) \\ 1 \end{bmatrix}= \begin{bmatrix} 1 &2 &1 \\ 1&0 &0 \\ 0 &0 &1 \end{bmatrix} \begin{bmatrix}f(n-1) \\ f(n-2) \\ 1 \end{bmatrix}](https://private.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7Df%28n%29%20%5C%5C%20f%28n-1%29%20%5C%5C%201%20%5Cend%7Bbmatrix%7D%3D%20%5Cbegin%7Bbmatrix%7D%201%20%262%20%261%20%5C%5C%201%260%20%260%20%5C%5C%200%20%260%20%261%20%5Cend%7Bbmatrix%7D%20%5Cbegin%7Bbmatrix%7Df%28n-1%29%20%5C%5C%20f%28n-2%29%20%5C%5C%201%20%5Cend%7Bbmatrix%7D)

然后进一步矩阵快速幂来求 f(n)

矩阵的基础知识：[点击这里](https://blog.csdn.net/u011815404/article/details/88838007)

# 【共轭矩阵的构造】

## 1.问题

对于给出的 a、b、m、n，当满足 ![(a-1)^2<b<a^2](https://private.codecogs.com/gif.latex?%28a-1%29%5E2%3Cb%3Ca%5E2) 时，求：![S_n=[(a+\sqrt b)^n]\:mod\:\:m](https://private.codecogs.com/gif.latex?S_n%3D%5B%28a&plus;%5Csqrt%20b%29%5En%5D%5C%3Amod%5C%3A%5C%3Am)

## 2.思路

设 ![A_n=(a+\sqrt b)^n](https://private.codecogs.com/gif.latex?A_n%3D%28a&plus;%5Csqrt%20b%29%5En)，配项 ![B_n=(a-\sqrt b)^n](https://private.codecogs.com/gif.latex?B_n%3D%28a-%5Csqrt%20b%29%5En)，并令 ![C_n=A_n+B_n](https://private.codecogs.com/gif.latex?C_n%3DA_n&plus;B_n)

由于 An、Bn 恰好共轭，因此 An、Bn 的和与积均为有理数

根据 ![(a-1)^2<b<a^2](https://private.codecogs.com/gif.latex?%28a-1%29%5E2%3Cb%3Ca%5E2) ，可知 Bn<1

因此 ![C_n=[A_n]](https://private.codecogs.com/gif.latex?C_n%3D%5BA_n%5D)，那么 ![S_n=[(a+\sqrt b)^n]\:mod\:\:m=[A_n]\:mod\:\:m=C_n\:mod \:\:m](https://private.codecogs.com/gif.latex?S_n%3D%5B%28a&plus;%5Csqrt%20b%29%5En%5D%5C%3Amod%5C%3A%5C%3Am%3D%5BA_n%5D%5C%3Amod%5C%3A%5C%3Am%3DC_n%5C%3Amod%20%5C%3A%5C%3Am)

故而可根据 Cn 来构造共轭矩阵，进行矩阵快速幂来求 Sn

## 3.共轭式的构造

根据 ![C_n=A_n+B_n=(a+\sqrt b)^n+(a-\sqrt b)^n](https://private.codecogs.com/gif.latex?C_n%3DA_n&plus;B_n%3D%28a&plus;%5Csqrt%20b%29%5En&plus;%28a-%5Csqrt%20b%29%5En) 构造共轭矩阵

对 Cn 两端同乘 ![[(a+\sqrt b)+(a-\sqrt b)]](https://private.codecogs.com/gif.latex?%5B%28a&plus;%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5D)，有：![C_n[(a+\sqrt b)+(a-\sqrt b)]=[(a+\sqrt b)^n+(a-\sqrt b)^n][(a+\sqrt b)+(a-\sqrt b)]](https://private.codecogs.com/gif.latex?C_n%5B%28a&plus;%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5D%3D%5B%28a&plus;%5Csqrt%20b%29%5En&plus;%28a-%5Csqrt%20b%29%5En%5D%5B%28a&plus;%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5D)

进行化简：

![2aC_n=[(a+\sqrt b)^{n+1}+(a+\sqrt b)^n(a-\sqrt b)+(a-\sqrt b)^n(a+\sqrt b)+(a-\sqrt b)^{n+1}]](https://private.codecogs.com/gif.latex?2aC_n%3D%5B%28a&plus;%5Csqrt%20b%29%5E%7Bn&plus;1%7D&plus;%28a&plus;%5Csqrt%20b%29%5En%28a-%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5En%28a&plus;%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5E%7Bn&plus;1%7D%5D)

![2aC_n=C_{n+1}+(a+\sqrt b)^n(a-\sqrt b)+(a-\sqrt b)^n(a+\sqrt b)](https://private.codecogs.com/gif.latex?2aC_n%3DC_%7Bn&plus;1%7D&plus;%28a&plus;%5Csqrt%20b%29%5En%28a-%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5En%28a&plus;%5Csqrt%20b%29)

![2aC_n=C_{n+1}+(a+\sqrt b)^{n-1}(a+\sqrt b)(a-\sqrt b)+(a-\sqrt b)^{n-1}(a-\sqrt b)(a+\sqrt b)](https://private.codecogs.com/gif.latex?2aC_n%3DC_%7Bn&plus;1%7D&plus;%28a&plus;%5Csqrt%20b%29%5E%7Bn-1%7D%28a&plus;%5Csqrt%20b%29%28a-%5Csqrt%20b%29&plus;%28a-%5Csqrt%20b%29%5E%7Bn-1%7D%28a-%5Csqrt%20b%29%28a&plus;%5Csqrt%20b%29)

![2aC_n=C_{n+1}+(a-\sqrt b)(a+\sqrt b)((a+\sqrt b)^{n-1}+(a-\sqrt b)^{n-1})](https://private.codecogs.com/gif.latex?2aC_n%3DC_%7Bn&plus;1%7D&plus;%28a-%5Csqrt%20b%29%28a&plus;%5Csqrt%20b%29%28%28a&plus;%5Csqrt%20b%29%5E%7Bn-1%7D&plus;%28a-%5Csqrt%20b%29%5E%7Bn-1%7D%29)

![2aC_n=C_{n+1}+(a^2-b)C_{n-1}](https://private.codecogs.com/gif.latex?2aC_n%3DC_%7Bn&plus;1%7D&plus;%28a%5E2-b%29C_%7Bn-1%7D)

写成矩阵形式：![\begin{bmatrix}C_{n+1} \\ C_n \end{bmatrix} = \begin{bmatrix}2a&-(a^2-b) \\ 1&0 \end{bmatrix} \begin{bmatrix}C_n \\ C_{n-1} \end{bmatrix}](https://private.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7DC_%7Bn&plus;1%7D%20%5C%5C%20C_n%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D2a%26-%28a%5E2-b%29%20%5C%5C%201%260%20%5Cend%7Bbmatrix%7D%20%5Cbegin%7Bbmatrix%7DC_n%20%5C%5C%20C_%7Bn-1%7D%20%5Cend%7Bbmatrix%7D)

再递推一步：![\begin{bmatrix}C_{n} \\ C_{n-1} \end{bmatrix} = \begin{bmatrix}2a&-(a^2-b) \\ 1&0 \end{bmatrix}^{n-1} \begin{bmatrix}C_1 \\ C_0 \end{bmatrix}](https://private.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7DC_%7Bn%7D%20%5C%5C%20C_%7Bn-1%7D%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D2a%26-%28a%5E2-b%29%20%5C%5C%201%260%20%5Cend%7Bbmatrix%7D%5E%7Bn-1%7D%20%5Cbegin%7Bbmatrix%7DC_1%20%5C%5C%20C_0%20%5Cend%7Bbmatrix%7D)

其中，![\left\{\begin{matrix}C_0=2 \\C_1=(a+\sqrt b)^1+(a+\sqrt b)^{1}=2a \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DC_0%3D2%20%5C%5CC_1%3D%28a&plus;%5Csqrt%20b%29%5E1&plus;%28a&plus;%5Csqrt%20b%29%5E%7B1%7D%3D2a%20%5Cend%7Bmatrix%7D%5Cright.)

然后根据构造的矩阵进行矩阵快速幂计算结果即可

# 【实现】

```cpp
struct Matrix{
    LL s[N][N];
};
Matrix e;//单位矩阵E
Matrix x;//构造矩阵
void init(){
    for(int i=1;i<=n;i++)//主对角线为1
        e.s[i][i]=1;
}
Matrix mul(Matrix A,Matrix B,LL n){//矩阵乘法，n代表A、B两个矩阵是n阶方阵
    Matrix temp;//临时矩阵，存放A*B结果

    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            temp.s[i][j]=0;

    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                temp.s[i][j]=((temp.s[i][j]+A.s[i][k]*B.s[k][j])%MOD+MOD)%MOD;
    return temp;
}
Matrix quickPower(Matrix a,LL b,LL n){//矩阵快速幂，求矩阵n阶矩阵的b次幂
    Matrix ans=e;
    while(b){
        if(b&1)
            ans=mul(ans,a,n);//ans=e*a
        a=mul(a,a,n);//a=a*a
        b>>=1;
    }
    return ans;
}

int main(){
    init();

    LL n;//构造矩阵的大小
    LL m;//构造矩阵的阶
    cin>>n>>m;

    //输入构造矩阵，也可通过题目的递推公式来构造矩阵
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>x.s[i][j];

    Matrix res=quickPower(x,m,n);

    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            cout<<res.s[i][j]<<" ";
        cout<<endl;
    }

    return 0;
}
```

# 【例题】
- Reading comprehension（HDU-4990）**(递推构造矩阵)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88849353)
- 233 Matrix（HDU-5051）**(递推构造矩阵)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88842138)
- Jzzhu and Sequences（CF-450B）**(递推构造矩阵)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88866583)
- Bear in the Field（CF-385E）**(递推构造矩阵)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88911769)
- Fast Matrix Calculation（HDU-4965）**(矩阵化简)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88875454)
- So Easy!（HDU - 4565）**(共轭矩阵的构造)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88877343)
- M斐波那契数列（HDU-4549）**(斐波那契矩阵构造+费马小定理)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88879546)




