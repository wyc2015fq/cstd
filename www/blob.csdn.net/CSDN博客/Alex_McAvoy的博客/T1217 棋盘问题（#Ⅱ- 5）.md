# T1217 棋盘问题（#Ⅱ- 5） - Alex_McAvoy的博客 - CSDN博客





2018年05月11日 15:53:24[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：1117








> 
# 【题目描述】

在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。

# 【输入】

输入含有多组测试数据。

每组数据的第一行是两个正整数n,k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 (n≤8,k≤n)

当为−1 −1时表示输入结束。

随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域，. 表示空白区域（数据保证不出现多余的空白行或者空白列）。

# 【输出】

对于每一组数据，给出一行输出，输出摆放的方案数目C（数据保证C<2^31）。

# 【输入样例】

**2 1#..#4 4...#..#..#..#...-1 -1**

# 【输出样例】

**21**


# 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define N 10
using namespace std;
int n,k;
char maps[N][N];
int vis[N];
int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
int cnt;
void dfs(int x,int y)
{
    if(y==k)
    {
        cnt++;
        return;
    }
    for(int i=x;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(maps[i][j]=='#'&&vis[j])
            {
                vis[j]=0;
                dfs(i+1,y+1);
                vis[j]=1;
            }
    return;
}
int main()
{
    while(scanf("%d%d",&n,&k)!=EOF)
    {
        if(n==-1&&k==-1)
            break;

        memset(vis,1,sizeof(vis));

        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                cin>>maps[i][j];

        cnt=0;
        dfs(1,0);
        cout<<cnt<<endl;
    }
    return 0;
}
```



