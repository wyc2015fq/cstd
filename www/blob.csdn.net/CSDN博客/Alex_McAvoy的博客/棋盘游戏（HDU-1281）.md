# 棋盘游戏（HDU-1281） - Alex_McAvoy的博客 - CSDN博客





2018年11月28日 21:20:12[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：33








> 
# Problem Description

小希和Gardon在玩一个游戏：对一个N*M的棋盘，在格子里放尽量多的一些国际象棋里面的“车”，并且使得他们不能互相攻击，这当然很简单，但是Gardon限制了只有某些格子才可以放，小希还是很轻松的解决了这个问题（见下图）注意不能放车的地方不影响车的互相攻击。 

所以现在Gardon想让小希来解决一个更难的问题，在保证尽量多的“车”的前提下，棋盘里有些格子是可以避开的，也就是说，不在这些格子上放车，也可以保证尽量多的“车”被放下。但是某些格子若不放子，就无法保证放尽量多的“车”，这样的格子被称做重要点。Gardon想让小希算出有多少个这样的重要点，你能解决这个问题么？

![](https://img-blog.csdnimg.cn/20181128205839359.gif)

# **Input**

输入包含多组数据， 

第一行有三个数N、M、K(1<N,M<=100 1<K<=N*M)，表示了棋盘的高、宽，以及可以放“车”的格子数目。接下来的K行描述了所有格子的信息：每行两个数X和Y，表示了这个格子在棋盘中的位置。

# Output

对输入的每组数据，按照如下格式输出： 

Board T have C important blanks for L chessmen.

# Sample Input

**3 3 41 21 32 12 23 3 41 21 32 13 2**

# Sample Output

**Board 1 have 0 important blanks for 2 chessmen.Board 2 have 3 important blanks for 3 chessmen.**


思路：先考虑在棋盘上尽可能的放棋子，使得任意棋子不在同一行同一列，将棋盘的行看做左边的点集，棋盘的列看做右边的点集，若某个格子（i,j）可行，那么就从左 i 连到 右 j，这个二分图的最大匹配即为这个棋盘能放的最多棋子数。

现要找出有二分图中有多少关键边，很明显关键边要在算出来的匹配中找，因此只需将棋盘点对应的边删除再求一次最大匹配，看匹配数是否减小，若减小了，则说明这个边也即棋盘的点是关键的，输出即可。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define MOD 16007
#define INF 0x3f3f3f3f
#define N 10001
#define LL long long
using namespace std;
int n,m,k;
bool vis[N];
int link[N];
bool G[N][N];
bool dfs(int x){
    for(int y=1;y<=m;y++){
        if(G[x][y]&&!vis[y]){
            vis[y]=true;
            if(link[y]==-1 || dfs(link[y]))	{
                link[y]=x;
                return true;
            }
        }
    }
    return false;
}
int hungarian()
{
    int ans=0;
    for(int i=1;i<=n;i++){
        memset(vis,false,sizeof(vis));
        if(dfs(i))
            ans++;
    }
    return ans;
}
int main(){
    int Case=1;
    while(scanf("%d%d%d",&n,&m,&k)!=EOF&&(n+m+k)){
        memset(G,false,sizeof(G));
        memset(link,-1,sizeof(link));

        while(k--){
            int x,y;
            scanf("%d%d",&x,&y);
            G[x][y]=true;
        }
        int tot=hungarian();
        int key=0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(G[i][j]){
                    G[i][j]=false;
                    memset(link,-1,sizeof(link));
                    int ans=hungarian();
                    if(ans<tot)
                        key++;
                    G[i][j]=true;
                }
            }
        }
        printf("Board %d have %d important blanks for %d chessmen.\n",Case++,key,tot);
    }
    return 0;
}
```





