# Java —— 多线程 - Alex_McAvoy的博客 - CSDN博客





2018年11月01日 23:43:13[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：37
个人分类：[Java学习笔记](https://blog.csdn.net/u011815404/article/category/8863016)

所属专栏：[Java 学习笔记](https://blog.csdn.net/column/details/34317.html)









# 【概述】

多线程使程序同时存在多个执行片段，根据不同的条件与环境同步或异步工作。

线程与进程的实现原理类似，但他们服务对象不同，进程代表操作系统平台中运行的一个程序，而一个进程中可以包含多个线程。

## 1.进程

进程是一个包含自身执行地址的程序，在多任务操作系统中，可以将 CPU 时间分配给每一个进程，CPU 在指定时间片段内执行某个进程，在下一个时间片段内执行另一个进行，由于 CUP 运转速度很快，因此使人感觉进程是在同步运行。

## 2.线程

在一个进程内部可以执行多个任务，将在进程内部执行的任务称为线程。

一个线程是进程内一个单一的顺序控制流程，通常说的多线程是指一个进程可以同时运行几个任务，每个任务由一个线程完成，即多个线程可以同时运行并且在一个进程内执行不同的任务。

# 【线程的创建】

在 Java 中，线程也是一种对象，但不是所有的对象都能成为线程，只有继承 Thread 类或实现 Runnable 接口的对象才能成为线程。

## 1.Thread 类

构造方法：
- Thread thread= new Thread()：默然构造方法
- Thread thread=new Thread(Runnable simple)：包含 Runnable 类型参数，实现 Runnable 接口的类的实例对象，基于该构造方法创建的线程对象，将线程的业务逻辑交由参数传递的 Runnable 对实现
- Thread thread=new Thread(String name)：指定线程名称参数，该参数将作为新创建的线程对象的名称
- Thread thread=new Thread(Runnable simple,String name)：基于 Runnable 对象并指定线程名称

在 Java 中，要实现线程功能，可以继承 java.lang.Thread 类，该类具备创建和运行线程的所有必要架构，通过覆写该类的 run() 方法，可以实现用户所需功能。

```java
public class Test extends Thread{
    public Test(String name){
        setName(name);
    }
    public void run(){
        int i=1;
        while(i<=5){
            System.out.println(getName()+":"+i);
            Thread.sleep(1000);
            i++;
        }
    }
}
public static void main(String[] args){
    Test thread1=new Test("Thread one");
    Test thread2=new Test("Thread two");
    thread1.start();
    thread2.start();
}
```

## 2.Runnable 接口

Runnable 是 Java 中用于实现线程的接口，任何实现线程功能的类都必须实现这个接口，Thread 类就是因为实现了 Runnable 接口才得以具有相应线程功能。

虽然可以使用继承 Thread 类的方式来实现线程，但在 Java 中只能继承一个类，若用户定义类已继承其它类，就无法继承 Thread 类，因此可以使用 java.lang.Runnable，这个接口与继承 Thread 类具有相同的效果。

Runnable 接口只有一个方法，run() 方法，在实例化一个 Thread 对象时，可以传入一个 Runnable 接口的对象作为参数，Thread 类会调用 Runnable 对象的 run() 方法，继而执行 run() 方法中的内容。

```java
public class Test implements Runnable{
    public void run(){
        int i=1;
        while(i<=5){
            System.out.println(+i);
            Thread.sleep(1000);
            i++;
        }
    }
}
public static void main(String[] args){
    Thread thread=new Thread(new Test(),"Thread");
    thread.start();
}
```

# 【线程的生命周期】

线程主要有四个状态：创建、可执行、非可执行、消亡

![](https://img-blog.csdnimg.cn/2018121020111216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

## 1.创建

当实例化一个 Thread 对象并执行 start() 方法后，线程进入可执行状态并开始执行，虽然多线程给用户一种同时执行的感觉，但实际上在同一时间点上只有一个线程在执行，只是线程间转换很快，看起来好像同时执行一样。

## 2.可执行

当线程进入可执行状态后，执行 run() 方法，在可执行状态下，线程可能被执行完毕，也可能没有执行完毕，处于执行权等待的状态中。

而一个线程进入可执行状态下并不代表其可一直执行到 run() 结束为止，实际上它只是加入该进程的线程执行安排队列中，可能正在等待取得 CPU 时间，即等待执行权，而在何时给予线程执行权，则有 JVM 与线程优先级来决定。

## 3.非可执行

使用 Thread 类中的 wait()、sleep() 方法可以使线程进入非可执行状态。

当线程离开可执行状态下的等待队列时，线程进入非可执行状态，当线程进入非可执行状态下，CPU 不分配时间片给这个线程，若希望线程回到可执行状态，可以使用 notify()、notifyAll() 、interrupt() 方法，

## 4.消亡

当 Thread 类调用 start() 方法时，JVM 自动调用他的 run() 方法，而当 run() 方法结束时，该线程会自动消亡。

# 【线程的优先级】

在 Java 中，线程执行有不同的优先级，其范围是 1~10，默认为 5，使用 Thread 类的 setPriority() 方法可以更改优先级，但其范围必须在 1~10 的范围内，否则将抛出异常。

优先级高的线程会被提前执行，当优先级高的线程执行完毕后才会轮到优先级较低的线程执行，若优先级线程相同，那么采用轮流执行的方式。

绝大多数的操作系统都支持 Time slicing，即操作系统会为每个线程分配一小段 CPU 时间，时间一到就轮换到下一个线程，即使这个线程没有执行完毕。

若需要某线程礼让一下其他线程，可以使用 Thread 中的 yield() 方法，但该方法只是一种礼让的暗示，没有任何一种机制保证它会被采纳，同时在支持 Time slicing 的操作系统中，线程不需要调用 yield() 方法，因为操作系统会合理安排时间使线程轮流执行。

# 【线程的控制】

## 1.线程的启动

一个新的线程被创建后处于初始状态，此时并没有立刻进入运行状态，而是处于准备就绪的状态，只有当轮到这个线程执行时，才开始执行 run() 方法中的代码，而执行 run() 方法中的代码是通过调用 Thread 类中的 start() 方法实现的。

调用 start() 方法启动线程的 run() 方法不同于一般的调用方法，一般的方法必须等到方法执行完毕后才返回，而对于 start() 方法来说，调用线程的 start() 方法后，该方法告诉系统该线程准备就绪并可以启动 run() 方法后就返回，并继续执行调用 start()  方法下面的语句，而此时 run() 方法可能还在运行，这样就实现了多任务操作。

## 2.线程的挂起

线程的挂起操作实质是使线程进入非可执行状态，该状态下，CPU 不会给线程分配时间片，这个状态可以用于暂停一个线程的运行，在线程挂起后，可以通过重新唤醒来使之恢复运行。

当线程进入非可执行状态，可能是以下 3 种情况：

1）sleep() 方法使线程进入休眠状态，使得线程在指定时间内不会运行

sleep() 方法是一个使线程执行暂时停止的方法，暂停时间由给定的毫秒数决定，执行该方法后，当前线程将休眠指定的时间段，若任何一个线程中断了当前线程的休眠，该方法将抛出异常，因此使用该方法时必须进行捕获异常

```java
try{
    thread.sleep(1500);//休眠1500ms
} catch(InterruptedException e){
    e.printStackTrace();
}
```

2）join() 方法使线程挂起，若线程 A 调用了 线程 B 的 join() 方法，则线程 A 会被挂起，直到线程 B 执行完毕为止

若有一线程 A 正在运行，用户希望插入一线程 B，并要求线程 B 执行完毕，然后再执行线程 A，此时可用 B.join() 来完成这个需求。

```java
public class A extends Thread{
    Thread B;
    run(){
        ...
        B.join();//插入线程B
        ...
    }
}
```

3）wait() 方法与 notify() 方法挂起线程

wait() 方法同样可用对线程进行挂起操作，当该方法存在给定的时间参数时，与 sleep() 相同，而当不存时间参数时，需要与 notify() 方法配合使用，这种方式让 wait() 无限等下去，直到线程收到 notify() 或 notifyAll() 消息为止。

## 3.线程状态检查

一般情况下无法确定一个线程的运行状态，对于这些处于未知状态的线程，可以通过 isAlive() 方法来确定是否仍处于活动状态，但要注意的是，线程处于活动状态并不意味着其正在运行。

```java
Thread A;
if(A.isAlive())
    System.out.println("Thread is alive!");
else
    System.out.println("Thread isn't alive!");
```

## 4.结束线程

结束线程有两种情况，一种是线程从 run() 方法的结尾处返回，自然消亡且不再运行，一种是强制死亡，调用 Thread 类中的 stop() 方法强制停止。

## 5.后台线程

后台线程是一个在后台执行服务的线程，比如操作系统中的隐藏线程、Java 中的垃圾自动回收线程等，如果所有的非后台线程都结束，那么后台线程会自动终止。

可以使用 Thread 类中的 setDaemon() 方法来设置一个线程为后台线程，当必须要在线程启动前调用该方法，才能设为后台线程。

若想要判断一个线程是否为后台线程，可以使用 isDaemon() 方法来判断。

# 【线程的同步】

如果程序是单线程的，执行起来毋须担心线程会被其他线程打扰，但若程序中同时使用多个线程，此时就需要控制，避免共享资源发生冲突。

为避免多线程共享资源发生冲突，只要在线程使用资源时给该资源加一把锁，当一个线程访问共享资源，就为该资源上锁，使得其他线程无法使用该资源，直到锁解除为止。

Java 中提供同步机制，该机制使得两个线程同时操作一个对象时，保持对象数据的统一性与整体性，其提供了 synchronized 关键字，为防止资源冲突提供了内置支持。

## 1.同步方法

同步方法将访问共享资源的方法都标记为 synchronized，这样在需要调用这个方法的线程执行完之前，其他调用该方法的线程都会被堵塞。

```java
synchronized void sum(){
    ...
}
```

## 2.同步代码块

同步的设定除方法外，还可将代码块设为同步区域。

```java
synchronized(Object obj){
    ...
}
```

如上，obj 代表当前对象，同步的作用区域是 synchronized 关键字后加花括号的部分，在程序执行到设定的同步化区块时，锁定当前对象，从而保证其他线程无法执行这个被同步化的区域块。

# 【线程通信】

在程序开发中，经常要创建多个不同的线程来完成不想关的任务，然而有时执行的任务可能有一定联系，这样就需要这些线程之间进行交互。

在 Java 中，用于线程间通信的方法是之前提到的 wait() 与 notify() 方法，notify() 方法最多只能释放等待队列中的第一个线程，如果有多个线程在等待，可以使用 notifyAll() 方法释放等待队列中的所有线程。

实际应用中，wait() 与 notify() 方法必须在同步方法或同步块中调用，线程对一个对象调用 wait() 或 notify() 方法，必须锁定那个特定的对象，此时就需要同步机制进行保护。

# 【多线程产生死锁】

由于线程可以堵塞，且具有同步控制机制可以防止其他线程在锁还没有释放的情况下访问该对象，此时就会发生矛盾，比如：线程 A 在等待线程 B，而线程 B 又再等待线程 A，这样就造成了死锁。

一般造成死锁必须同时满足以下 4 个条件：
- 互斥条件：线程使用的资源必须至少有一个是不能共享的
- 请求与保持条件：至少有一个线程必须持有一个资源且正在等待获取一个当前被其他线程持有的资源
- 非剥夺条件：分配的资源不能从相应的线程中被强制剥夺
- 循环等待条件：第一个线程等待其他线程，后者又在等待第一个线程

由于发生死锁必须要同时满足以上 4 个条件，因此若想防止死锁，只需破坏其中一个条件即可。



