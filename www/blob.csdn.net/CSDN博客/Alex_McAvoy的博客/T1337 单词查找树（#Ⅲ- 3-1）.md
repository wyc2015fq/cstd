# T1337	单词查找树（#Ⅲ- 3 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年06月09日 23:34:34[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：484








### 【题目描述】

在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都画出与单词列表所对应的单词查找树，其特点如下：



1．根结点不包含字母，除根结点外每一个结点都仅包含一个大写英文字母；

2．从根结点到某一结点，路径上经过的字母依次连起来所构成的字母序列，称为该结点对应的单词。单词列表中的每个单词，都是该单词查找树某个结点所对应的单词；

3．在满足上述条件下，该单词查找树的结点数最少。

4．例如图3-2左边的单词列表就对应于右边的单词查找树。注意，对一个确定的单词列表，请统计对应的单词查找树的结点数（包含根结点）。

![](http://ybt.ssoier.cn:8088/pic/1337.gif)



### 【输入】



为一个单词列表，每一行仅包含一个单词和一个换行/回车符。每个单词仅由大写的英文字母组成，长度不超过63个字母 。文件总长度不超过32K，至少有一行数据。

### 【输出】

仅包含一个整数，该整数为单词列表对应的单词查找树的结点数。

### 【输入样例】

```
A
AN
ASP
AS
ASC
ASCII
BAS
BASIC
```

### 【输出样例】
`13`
### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 100001
#define MOD 123
#define E 1e-6
using namespace std;
int main()
{
    string a[N];
    int n=0;
    while(cin>>a[++n]);
    sort(a+1,a+1+n);

    int sum=a[1].length();
    for(int i=2;i<=n;i++)//依次计算每个单词对前一单词的差
    {
        int j=0;
        while(a[i][j]==a[i-1][j]&&j<a[i-1].length())//求两个单词相同部分的长度
            j++;
        sum+=a[i].length()-j;//累加两个单词的差
    }
    cout<<sum+1<<endl;

    return 0;
}
```





