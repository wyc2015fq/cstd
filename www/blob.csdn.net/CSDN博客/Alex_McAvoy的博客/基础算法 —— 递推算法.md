# 基础算法 —— 递推算法 - Alex_McAvoy的博客 - CSDN博客





2018年04月23日 20:48:32[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：206








# 【概述】
- 递推算法：通过已知条件，利用相邻的数据项间的关系（即：递推关系），得出中间推论，直至得到结果的算法。
- 递推关系：给定一个数的序列H0,H1,…,Hn，若存在整数N0，使当n>N0时,可以用=/>/<将Hn与其前面的某些项Hi(0<i<n)联系起来。
- 特点：避开了求通项公式的麻烦，把一个复杂问题的求解，分解成了连续的若干简单运算。
- 基本思想：把一个复杂的庞大的计算过程转化为简单过程的多次重复。
- 逆推与顺推：在计算时，如果可以找到前后过程之间的数量关系（即：递推式），那么，从已知条件推到问题叫顺推，从问题出发推到已知条件叫逆推。
- 递推与递归的比较：相对于递归算法,递推算法免除了数据进出栈的过程，也就是说，不需要函数不断的向边界值靠拢,而直接从边界出发，直到求出函数值。

# 【经典应用】

## 1.斐波那契数列的递推实现

```cpp
int Fibonacci(int n)  
{  
    if (n<0)  
        return -1;  
    
    int n1=1,n2=2,n3=3;
    for (int i=3;i<=n;++i)  
    {  
        n3=n1+n2;  
        n1=n2;  
        n2=n3;  
    }  
    
    return n3;  
}
```

## 2.汉诺塔问题的递推实现

```cpp
#include<stdio.h>
int ct=1;//记录步数,在步骤中输出
void move(int n,char from,char to)
{
    printf("第 %2d 步：把第 %d 个盘子：  %c >>>>>>> %c\n",ct++,n,from,to);
}
int hanoi(int n)//输出步数：
{
    int cnt = 2,ans = 1;
    if(n == 1)
        return 1;
    else
        return 2* hanoi(n-1) +1;
}
void hanoi_tower(int n,char x,char y, char z) //输出步骤
{
    if(n==1)
        move(1,x,z);
    else{
        hanoi_tower(n-1,x,z,y);
        move(n,x,z);
        hanoi_tower(n-1,y,x,z);
    }
}
int main()
{
    int n;//盘子个数
    printf("输入盘子个数:\n");
    scanf("%d",&n);
    char x = 'A',y = 'B',z = 'C';
    int t = hanoi(n);
    printf("一共需要%2d步。\n",t);
    hanoi_tower(n,x,y,z);
    return 0;
}
```

关于汉诺塔问题：[点击这里](https://blog.csdn.net/u011815404/article/details/80057146)

# 【例题】
- Cantor表（洛谷-P1014）：[点击这里](https://blog.csdn.net/u011815404/article/details/79430230)
- 猜数字（HDU-2178）：[点击这里](https://blog.csdn.net/u011815404/article/details/79574501)
- 母牛的故事（HDU-2018）：[点击这里](https://blog.csdn.net/u011815404/article/details/79747963)
- 折线分割平面（HDU-2050）：[点击这里](https://blog.csdn.net/u011815404/article/details/79747964)
- 统计问题（HDU-2563）：[点击这里](https://blog.csdn.net/u011815404/article/details/79747957)
- Sumsets（POJ-2229）：[点击这里](https://blog.csdn.net/u011815404/article/details/81264638)
- Moo Volume（POJ-2231）：[点击这里](https://blog.csdn.net/u011815404/article/details/81267600)
- 台阶问题（洛谷-P1192）：[点击这里](https://blog.csdn.net/u011815404/article/details/81808365)
- 钥匙计数之一（HDU-1483）：[点击这里](https://blog.csdn.net/u011815404/article/details/82935237)
- 数楼梯（洛谷-P1255）：[点击这里](https://blog.csdn.net/u011815404/article/details/79921483)
- Numbers on the Chessboard（CF-1027B）：[点击这里](https://blog.csdn.net/u011815404/article/details/82013897)
- 昆虫繁殖（信息学奥赛一本通-T1312）：[点击这里](https://blog.csdn.net/u011815404/article/details/80085037)
- 位数问题（信息学奥赛一本通-T1313）：[点击这里](https://blog.csdn.net/u011815404/article/details/80085036)
- 过河卒（信息学奥赛一本通-T1314）：[点击这里](https://blog.csdn.net/u011815404/article/details/80085034)
- Pell数列（信息学奥赛一本通-T1189）：[点击这里](https://blog.csdn.net/u011815404/article/details/80085032)
- 上台阶（信息学奥赛一本通-T1190）：[点击这里](https://blog.csdn.net/u011815404/article/details/80188369)
- 流感传染（信息学奥赛一本通-T1191）：[点击这里](https://blog.csdn.net/u011815404/article/details/80188367)
- 放苹果（信息学奥赛一本通-T1192）：[点击这里](https://blog.csdn.net/u011815404/article/details/80188368)
- 吃糖果（信息学奥赛一本通-T1193）：[点击这里](https://blog.csdn.net/u011815404/article/details/80196551)
- 移动路线（信息学奥赛一本通-T1194）：[点击这里](https://blog.csdn.net/u011815404/article/details/80196552)
- 踩方格（信息学奥赛一本通-T1196）：[点击这里](https://blog.csdn.net/u011815404/article/details/80196555)
- Binary Tree（HDU-5573）**(二进制枚举)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86529422)
- 处女座与汉明距离（2019牛客寒假算法基础集训营 Day2-E）**(格雷码的构造)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86655578)



