# T1262	挖地雷（#Ⅱ- 9 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年05月31日 21:05:21[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：418
个人分类：[信息学奥赛一本通																[动态规划——线性 DP](https://blog.csdn.net/u011815404/article/category/7813170)](https://blog.csdn.net/u011815404/article/category/7429967)








### 【题目描述】

在一个地图上有n个地窖（n≤200）,每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径，并规定路径都是单向的,且保证都是小序号地窖指向在序号地窖，也不存在可以从一个地窖出发经过若干地窖后又回到原来地窖的路径。某人可以从任一处开始挖地雷，然后沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使他能挖到最多的地雷。

### 【输入】



第一行：地窖的个数；

第二行为依次每个地窖地雷的个数；

下面若干行：

xi yi  //表示从xi可到yi，xi<yi。

最后一行为"0 0"表示结束。

### 【输出】

k1−k2−…−kv   //挖地雷的顺序

挖到最多的雷。

### 【输入样例】

```
6
5 10 20 5 4 5
1 2
1 4
2 4
3 4
4 5
4 6
5 6
0 0
```

### 【输出样例】

```
3-4-5-6
34
```

### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 201
#define MOD 2520
#define E 1e-12
using namespace std;
int g[N][N];
int w[N],pre[N];
int f[N];
void print(int k)
{
    if(k==0)
        return;

    print(pre[k]);

    if(pre[k]==0)
        cout<<k;
    else
        cout<<"-"<<k;
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>w[i];
        f[i]=w[i];
    }

    int x,y;
    while(scanf("%d%d",&x,&y)!=EOF&&x&&y)
        g[x][y]=1;

    int maxx=-INF,k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if( g[j][i]==1 && f[j]+w[i]>f[i] )
            {
                f[i]=f[j]+w[i];
                pre[i]=j;
            }
        }
        if(f[i]>maxx)
        {
            maxx=f[i];
            k=i;
        }
    }
    print(k);
    cout<<endl<<maxx<<endl;
    return 0;
}
```








