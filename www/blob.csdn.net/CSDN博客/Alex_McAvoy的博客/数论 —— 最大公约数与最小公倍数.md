# 数论 —— 最大公约数与最小公倍数 - Alex_McAvoy的博客 - CSDN博客





2018年07月30日 16:35:22[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：1374








# 【概念】

1.公约数：有 k 个非零整数 ![a_{1},a_{2},...,a_{k}](https://private.codecogs.com/gif.latex?a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bk%7D)，若 ![\exists \: d \in Z^+](https://private.codecogs.com/gif.latex?%5Cexists%20%5C%3A%20d%20%5Cin%20Z%5E&plus;)，s.t. ![d|a_{1},d|a_{2},...,d|a_{k}](https://private.codecogs.com/gif.latex?d%7Ca_%7B1%7D%2Cd%7Ca_%7B2%7D%2C...%2Cd%7Ca_%7Bk%7D)，则称 d 为 ![a_{1},a_{2},...,a_{k}](https://private.codecogs.com/gif.latex?a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bk%7D) 的公约数。

2.最大公约数：公约数中最大的一个数称为最大公约数，记为：![GCD(a_1,a_2,...,a_k)](https://private.codecogs.com/gif.latex?GCD%28a_1%2Ca_2%2C...%2Ca_k%29)

**注：**

**  ① 最大公约数一定是存在的，其最小值为 1。**

**  ② 当 GCD=1 时，则称这些数是互质的。**

**  ③ 公约数一定是最大公约数的约数。**

3.公倍数：有 k 个非零整数 ![a_{1},a_{2},...,a_{k}](https://private.codecogs.com/gif.latex?a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bk%7D)，若 ![\exists \: d \in Z^+](https://private.codecogs.com/gif.latex?%5Cexists%20%5C%3A%20d%20%5Cin%20Z%5E&plus;)，s.t. ![a_{1}|d,a_{2}|d,...,a_{k}|d](https://private.codecogs.com/gif.latex?a_%7B1%7D%7Cd%2Ca_%7B2%7D%7Cd%2C...%2Ca_%7Bk%7D%7Cd)，则称 d 为 ![a_{1},a_{2},...,a_{k}](https://private.codecogs.com/gif.latex?a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bk%7D) 的公倍数。

4.最小公倍数：公倍数中最小的一个数称为最小公倍数，记为：![LCM(a_1,a_2,...,a_k)](https://private.codecogs.com/gif.latex?LCM%28a_1%2Ca_2%2C...%2Ca_k%29)

**注：公倍数一定是最小公倍数的倍数。**

# 【欧几里德算法】

欧几里德算法又称为辗转相除法，用于求两个数的最大公约数，其原理为：![GCD(x,y)=GCD(x,y-x),x>y](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3DGCD%28x%2Cy-x%29%2Cx%3Ey)，即：![GCD(x,y)=GCD(y,x\:\, mod\:\, y),x>y](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3DGCD%28y%2Cx%5C%3A%5C%2C%20mod%5C%3A%5C%2C%20y%29%2Cx%3Ey)

## 1.实现

```cpp
int GCD(int x,int y){
    if(y==0)
        return x;
    else
        return GCD(y,x%y);
}
```

## 2.二进制算法

### 1）原理

为提高效率，可将欧几里德算法进行优化，通过不断去除因子 2 来降低常数。
- 当 ![x=y](https://private.codecogs.com/gif.latex?x%3Dy) 时，![GCD(x,y)=x=y](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3Dx%3Dy)
- 当 x、y 均为偶数时，![GCD(x,y)=2*GCD(x/2,y/2)](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3D2*GCD%28x/2%2Cy/2%29)
- 当 x 为偶数，y 为奇数时，![GCD(x,y)=GCD(x/2,y)](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3DGCD%28x/2%2Cy%29)
- 当 x 为奇数，x 为偶数时，![GCD(x,y)=GCD(x,y/2)](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3DGCD%28x%2Cy/2%29)

### 2）实现

```cpp
int GCD(int x,int y){
    if(x==0)
        return y;
    if(y==0)
        return x;

    int i,j;
    for(i=0;!(x&1);i++)//约去2
        x>>=1;
    for(j=0;!(y&1);j++)//约去2
        y>>=1;
    if(i>j)
        i=j;

    while(true){
        if(x<y){//若x<y，交换两数，保证大数在前
            x^=y;
            y^=x;
            x^=y;
        }
        if((x-=y)==0)//辗转减
            return y<<i;
        while(!(x&1))//约去2
            x>>=1;
    }
}
```

# 【扩展欧几里德算法】

扩展欧几里德算法是在已知 x、y 时，求解一组 a、b，使得 ![a*x+b*y=GCD(x,y)](https://private.codecogs.com/gif.latex?a*x&plus;b*y%3DGCD%28x%2Cy%29)

## 1.过程分析

设 ![x>y](https://private.codecogs.com/gif.latex?x%3Ey)

① 当 ![y=0](https://private.codecogs.com/gif.latex?y%3D0) 时，![GCD(x,y)=x](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3Dx)，此时 ![a=1,b=0](https://private.codecogs.com/gif.latex?a%3D1%2Cb%3D0)

② 当 x>y>0 时

     设 ![a_1*x+b_1*y=GCD(x,y)](https://private.codecogs.com/gif.latex?a_1*x&plus;b_1*y%3DGCD%28x%2Cy%29)，![a_2*y+b_2*(x \: \, mod\: \, y)=GCD(y,x \: \, mod\: \, y)](https://private.codecogs.com/gif.latex?a_2*y&plus;b_2*%28x%20%5C%3A%20%5C%2C%20mod%5C%3A%20%5C%2C%20y%29%3DGCD%28y%2Cx%20%5C%3A%20%5C%2C%20mod%5C%3A%20%5C%2C%20y%29)

     由于 ![GCD(x,y)=GCD(y,x \: \, mod\: \, y)](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%29%3DGCD%28y%2Cx%20%5C%3A%20%5C%2C%20mod%5C%3A%20%5C%2C%20y%29)

     故 ![a_1*x+b_1*y=a_2*y+b_2*(x \: \, mod\: \, y)](https://private.codecogs.com/gif.latex?a_1*x&plus;b_1*y%3Da_2*y&plus;b_2*%28x%20%5C%3A%20%5C%2C%20mod%5C%3A%20%5C%2C%20y%29)

     即 ![a_1*x+b_1*y=a_2*y+b_2*(x-[x/y]*y)=a_2*y+b_2*x- b_2*[x/y] *y](https://private.codecogs.com/gif.latex?a_1*x&plus;b_1*y%3Da_2*y&plus;b_2*%28x-%5Bx/y%5D*y%29%3Da_2*y&plus;b_2*x-%20b_2*%5Bx/y%5D%20*y)

     因此 ![a_1*x+b_1*y=b_2*x+(a_2- [x/y] * b_2)*y](https://private.codecogs.com/gif.latex?a_1*x&plus;b_1*y%3Db_2*x&plus;%28a_2-%20%5Bx/y%5D%20*%20b_2%29*y)

     易得  ![\left\{\begin{matrix}a1=b2 \\ b_1=a_2- [x/y] * b_2 \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Da1%3Db2%20%5C%5C%20b_1%3Da_2-%20%5Bx/y%5D%20*%20b_2%20%5Cend%7Bmatrix%7D%5Cright.)

这样就得到了求解 ![a_1](https://private.codecogs.com/gif.latex?a_1)、![b_1](https://private.codecogs.com/gif.latex?b_1) 的方法：![a_1](https://private.codecogs.com/gif.latex?a_1)、![b_1](https://private.codecogs.com/gif.latex?b_1) 的值基于 ![a_2](https://private.codecogs.com/gif.latex?a_2)、![b_2](https://private.codecogs.com/gif.latex?b_2)

由于 GCD 不断的递归求解，因此一定会在某时 ![b=0](https://private.codecogs.com/gif.latex?b%3D0)，结束递归，从而得出 a、b 的值。

**注： x-[x/y]*y 即为 mod 运算，[x/y] 代表取小于 x/y 的最大整数。**

## 2.实现

```cpp
int Extended_GCD(int x,int y,int &a,int &b){
    if(y==0){
        a=1;
        b=0;
        return x;
    }

    int temp;
    int gcd=Extended_GCD(y,x%y,a,b);
    temp=a;
    a=b;
    b=temp-x/y*b;
    return gcd;
}
int main(){
    //形如 ax+by=GCD(x,y)
    int x,y,a,b;
    cin>>x>>y;
    int gcd=Extended_GCD(x,y,a,b);
    cout<<"GCD="<<gcd<<endl;
    cout<<"a="<<a<<",b="<<b<<endl;
    return 0;
}
```

# 【最小公倍数】

定理：a、b 两个数的最小公倍数乘以它们的最大公约数等于 a 和 b 本身的乘积。

即：![LCM(a,b) * GCD(a,b) = a*b](https://private.codecogs.com/gif.latex?LCM%28a%2Cb%29%20*%20GCD%28a%2Cb%29%20%3D%20a*b)

```cpp
int GCD(int x,int y){
    return !y?x:GCD(y,x%y);
}
int LCM(int x,int y){
    return x*y/GCD(x,y);
}
```

# 【例题】
- 取石子游戏（信息学奥赛一本通-T1218）**(扩展欧几里得)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80282633)
- 青蛙的约会（POJ-1061）**(扩展欧几里得)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88423181)

	同题：青蛙的约会（洛谷-P1516）：[点击这里](https://blog.csdn.net/u011815404/article/details/81291164)
- 最大公约数和最小公倍数问题（洛谷-P1029）**(LCM)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81746831)
- LCM Walk（HDU-5584）**(LCM+逆推)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86526123)
- Happy 2006（POJ-2773）**(扩展欧几里得求互素的数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81583521)



