# 石子合并（洛谷-P1880） - Alex_McAvoy的博客 - CSDN博客





2018年08月17日 10:22:19[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：84








## 题目描述

在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.

## 输入输出格式

**输入格式：**

数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.

**输出格式：**

输出共2行,第1行为最小得分,第2行为最大得分.

## 输入输出样例

**输入样例#1：**

```
4
4 5 9 4
```

**输出样例#1：**

```
43
54
```

———————————————————————————————————————————————————————

思路：区间 DP 经典题目

用 dp_min[i][j] 来表示合并第 i 堆到第 j 堆石子的最小代价，用 dp_max[i][j] 来表示合并第 i 堆到第 j 堆石子的最大代价。

那么状态转移方程为：

dp_min[j][i] = min(dp_min[j][i],dp_min[j][k]+dp_min[(j+k+1)%n][i-k-1]+judge(j,i));

dp_max[j][i] = max(dp_max[j][i],dp_max[j][k]+dp_max[(j+k+1)%n][i-k-1]+judge(j,i));

其中 judge(j,i) 表示把两部分合并起来的代价，用 sum[i] 表示从第 1 堆到第 i 堆的石子个数和

## 源代码

```cpp
#include <iostream>  
using namespace std;

int max(int x,int y)//求最大值
{
    if(x>y)
        return x;
    else
        return y;
}
int min(int x,int y)//求最小值
{
    if(x>y)
        return y;
    else
        return x;
}

int n,sum[300];
int judge(int i,int j)  
{  
    if(i+j>=n)//若大于堆数
        return judge(i,n-i-1)+judge(0,(i+j)%n);//进行循环判断
    else//若小于堆数
        return sum[i+j]-(i>0?sum[i-1]:0);//判断进行合并的值
}

int main()  
{
    int stone[300];
    int dp_min[300][300]={0},dp_max[300][300]={0};  
    int i,j,k;
    int min_score,max_score;

    cin>>n;//输入石头堆数
    for(i=0;i<n;i++)	cin>>stone[i];//输入每堆个数
    
    sum[0]=stone[0];//第一堆个数
    for(i=1;i<n;i++)	sum[i]=sum[i-1]+stone[i];//计算当前堆数及其前面所有堆数的和

    for(i=1;i<n;i++)//合并n-1次
    {
        for(j=0;j<n;j++)//判断每堆是否合并
        {
            dp_min[j][i]=999999;
            dp_max[j][i]=0;
            for(k=0;k<i;k++)//依次判断到当前合并次数
            {  
                dp_min[j][i] = min(dp_min[j][i],dp_min[j][k]+dp_min[(j+k+1)%n][i-k-1]+judge(j,i));//最小值
                dp_max[j][i] = max(dp_max[j][i],dp_max[j][k]+dp_max[(j+k+1)%n][i-k-1]+judge(j,i));//最大值
            }
        }
    }

    for(i=0;i<n;i++)
    {  
        min_score=min(min_score,dp_min[i][n-1]);//寻找最小值
        max_score=max(max_score,dp_max[i][n-1]);//寻找最大值
    }

    cout<<min_score<<endl;//最小值
    cout<<max_score<<endl;//最大值

    return 0;  
}
```





