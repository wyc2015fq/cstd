# T1375 骑马修栅栏（#Ⅲ- 4 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年06月18日 02:53:37[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：344








> 
# 【题目描述】

农民John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。

John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(≥1)个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。

你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一个数较小的，如果还有多组解，输出第二个数较小的，等等)。 输入数据保证至少有一个解。

# 【输入】

第1行:一个整数F(1≤F≤1024)，表示栅栏的数目;

第2到F+1行:每行两个整数i,j(1≤=i,j≤500)表示这条栅栏连接i与j号顶点。

# 【输出】

输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。

# 【输入样例】

**91 22 33 44 24 52 55 65 74 6**

# 【输出样例】

**1234254657**


# 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#include<set>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 501
#define MOD 123
#define E 1e-6
using namespace std;
int n,m;
int g[N][N];
int dis[N],path[2*N];
int beginn=INF;
int cnt;
void dfs(int i)
{
    for(int j=beginn;j<=n;j++)
        if(g[i][j])
        {
            g[i][j]--;
            g[j][i]--;
            dfs(j);
        }
    path[cnt++]=i;
}
int main()
{
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        g[x][y]++;
        g[y][x]++;
        dis[x]++;
        dis[y]++;
        n=max(n,max(x,y));
        beginn=min(beginn,min(x,y));
    }
    int start=beginn;
    int sum=0;
    for(int i=beginn;i<=n;i++)
        if(dis[i]%2)
        {
            sum++;
            if(sum==1)
                start=i;
        }
    dfs(start);
    for(int i=cnt-1;i>=0;i--)
        cout<<path[i]<<endl;
    return 0;
}
```





