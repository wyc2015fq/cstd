# 过山车（HDU-2063） - Alex_McAvoy的博客 - CSDN博客





2018年11月27日 00:11:54[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：32








> 
# Problem Description

RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？

# **Input**

输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0<K<=1000

1<=N 和M<=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。

# Output

对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。

# Sample Input

**6 3 31 11 21 32 12 33 10**

# Sample Output

**3**


思路：n 个女孩 m 个男孩配对坐过山车，左边放女孩右边放男孩，由于每个女孩有多种选择可能，且男女只能配对一个，要求的最多配对个数即为二分图的最大匹配数

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define MOD 16007
#define INF 0x3f3f3f3f
#define N 10001
#define LL long long
using namespace std;
bool vis[N];
int link[N];
vector<int> G[N];
bool dfs(int x){
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i];
        if(!vis[y]){
            vis[y]=true;
            if(link[y]==-1 || dfs(link[y])){
                link[y]=x;
                return true;
            }
        }
    }
    return false;
}
int hungarian(int n)
{
    int ans=0;
    for(int i=1;i<=n;i++){
        memset(vis,false,sizeof(vis));
        if(dfs(i))
            ans++;
    }
    return ans;
}
int main(){
    int k,n,m;
    while(scanf("%d",&k)!=EOF&&k){
        memset(link,-1,sizeof(link));
        for(int i=0;i<N;i++)
            G[i].clear();

        scanf("%d%d",&n,&m);
        while(k--){
            int x,y;
            scanf("%d%d",&x,&y);
            G[x].push_back(y);
        }

        printf("%d\n",hungarian(n));

    }
    return 0;
}
```





