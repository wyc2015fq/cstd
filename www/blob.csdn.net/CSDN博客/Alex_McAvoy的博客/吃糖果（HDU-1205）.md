# 吃糖果（HDU-1205） - Alex_McAvoy的博客 - CSDN博客





2018年08月12日 21:33:29[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：77








> 
# Problem Description

HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。

# **Input**

第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0<N<=1000000)，第二行是N个数，表示N种糖果的数目Mi(0<Mi<=1000000)。

# Output

对于每组数据，输出一行，包含一个"Yes"或者"No"。

# Sample Input

**234 1 155 4 3 2 1**

# Sample Output

**NoYes**


思路：找出个数最多的种类记为 n，然后模拟为有 n 个抽屉，把其他 n-1 种的糖果往这 n 个抽屉中放，由于 n 是最大的，因此同一个抽屉中不会出现同一种类的糖果，所以只要保证这 n 个抽屉里最多有一个为空即可。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 10001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        LL n;
        scanf("%lld",&n);

        LL sum=0;
        LL maxx=-INF;
        for(LL i=1;i<=n;i++)
        {
            LL a;
            scanf("%lld",&a);
            if(a>maxx)
                maxx=a;
            sum+=a;
        }

        sum-=maxx;

        if(sum+1>=maxx)
            printf("Yes\n");
        else
            printf("No\n");

    }
    return 0;
}
```





