# 数论 —— 毕达哥拉斯三元组 - Alex_McAvoy的博客 - CSDN博客





2019年03月20日 20:02:12[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：35
个人分类：[数论——方程](https://blog.csdn.net/u011815404/article/category/8796916)









# 【定义】

满足 ![x^2+y^2=z^2](https://private.codecogs.com/gif.latex?x%5E2&plus;y%5E2%3Dz%5E2) 的 ![(x,y,z)](https://private.codecogs.com/gif.latex?%28x%2Cy%2Cz%29) 三元组称为毕达哥拉斯三元组，当 ![GCD(x,y,z)=1](https://private.codecogs.com/gif.latex?GCD%28x%2Cy%2Cz%29%3D1) 时，称其为本原的。

毕达哥拉斯三元组，也称为勾股数。

# 【性质】

由 x、y、z 构成的三元组 (x,y,z) ，其中 y 为偶数，那么由他们构成的**本原的毕达哥拉斯三元组**

等价于**：**

存在互素的一奇一偶的正整数 m、n，且 m>n，有：![\left\{\begin{matrix}x=m^2-n^2 \\ y=2mn \\ z=m^2+n^2 \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dx%3Dm%5E2-n%5E2%20%5C%5C%20y%3D2mn%20%5C%5C%20z%3Dm%5E2&plus;n%5E2%20%5Cend%7Bmatrix%7D%5Cright.)，并且可以看出，本原的毕达哥拉斯三元组中，最大的数一定是奇数。

特别地，由 ![f_nf_{n+3},\:\:2f_{n+1}f_{n+2},\:\:f^2_{n+1}+f^2_{n+2}](https://private.codecogs.com/gif.latex?f_nf_%7Bn&plus;3%7D%2C%5C%3A%5C%3A2f_%7Bn&plus;1%7Df_%7Bn&plus;2%7D%2C%5C%3A%5C%3Af%5E2_%7Bn&plus;1%7D&plus;f%5E2_%7Bn&plus;2%7D) 构成毕达哥拉斯三元组，将 ![f_n=f_{n+2}-f_{n+1},\:\:f_{n+3}+f_{n+1}](https://private.codecogs.com/gif.latex?f_n%3Df_%7Bn&plus;2%7D-f_%7Bn&plus;1%7D%2C%5C%3A%5C%3Af_%7Bn&plus;3%7D&plus;f_%7Bn&plus;1%7D) 即得

# 【实现】

**求解 n 以内本原的毕达哥拉斯三元组个数**

根据 ![\left\{\begin{matrix}x=m^2-n^2 \\ y=2mn \\ z=m^2+n^2 \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dx%3Dm%5E2-n%5E2%20%5C%5C%20y%3D2mn%20%5C%5C%20z%3Dm%5E2&plus;n%5E2%20%5Cend%7Bmatrix%7D%5Cright.)，只要枚举一下 m、n（m,n<=sqrt(n)），然后将三元组乘以 i （保证 i*z 在范围内），即可求出所有的毕达哥拉斯三元组。

```cpp
int x[N],y[N],z[N];
int pythagoras(int n){
    int num=0;//数组游标
    int res=0;//本原三元组的个数

    int m=sqrt(n*1.0);
    for(int i=1;i<=m;i+=2){//从1开始，每次+2，保证为奇数
        for(int j=2;j<=m;j+=2){//从2开始，每次+2，保证为偶数
            a=max(i,j);//大的为m
            b=min(i,j);//小的为n

            if(gcd(i,j)!=1)//要求m、n互质
                continue;

            x[num]=a*a-b*b;
            y[num]=2*a*b;
            z[num]=a*a+b*b;
            num++;

            if( (a*a+b*b)<=n )//保证在范围内
                res++;
        }
    }
    return res;
}
```





