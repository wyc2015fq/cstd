# 金明的预算方案（洛谷-P1064） - Alex_McAvoy的博客 - CSDN博客





2018年08月18日 13:40:27[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：104








## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 NN 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

主件 附件

电脑 打印机，扫描仪

书柜 图书

书桌 台灯，文具

工作椅 无

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 N 元。于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1−5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 NN 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 jj 件物品的价格为 v[​j] ，重要度为 w[​j] ，共选中了 k 件物品，编号依次为 j1​,j2​,…,jk​ ，则所求的总和为：

v[​j1​]×w[​j1​]+v[​j2​]×w[​j2​]+…+v[​jk​]×w[​jk​] 。

请你帮助金明设计一个满足要求的购物单。

## 输入输出格式

**输入格式：**

第 1 行，为两个正整数，用一个空格隔开：

Nm （其中 N(<32000) 表示总钱数， m(<60) 为希望购买物品的个数。） 从第 2 行到第 m+1行，第 j 行给出了编号为 j−1 的物品的基本数据，每行有 3 个非负整数

v p q （其中 v 表示该物品的价格（ v<10000 ），p表示该物品的重要度（ 1−5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）

**输出格式：**

一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。

## 输入输出样例

**输入样例#1：**

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

**输出样例#1：**
`2200`
———————————————————————————————————————————————————————

思路：有依赖的背包问题模板题，关于有依赖的背包问题：[点击这里](https://blog.csdn.net/u011815404/article/details/80560932)

## 源代码

```cpp
#include<iostream>
using namespace std;
int dp[10000000];
struct main_goods{//主件结构体
    int price;
    int weigh;
}master[1000];
struct attachment_goods{//附件结构体
    int price;
    int weigh;
}attachment[1000][3];
int max(int x,int y)//比较函数
{
    if(x>y)	return x;
    else return y;
}
int main()
{
    int money,num;
    int v,p,q;    
    int i,j;
    
    cin>>money>>num;//最大钱数与数量
    
    for(i=1;i<=num;i++)
    {
        cin>>v>>p>>q;//每件物品的价格、重要度、判断主、附件
        if(q==0)//主件
        {
            master[i].price=v;//价格
            master[i].weigh=v*p;//乘积
        }
        else//附件
        {
            attachment[q][0].price++;//第二维用于记录所属主件的编号:0,1,2
            attachment[q][ attachment[q][0].price ].price=v;//价格
            attachment[q][ attachment[q][0].price ].weigh=v*p;//乘积
        }
    }
    
    for(i=1;i<=num;i++)//比较每件物品
    {
        for( j=money ; j>=master[i].price && j>0 ; j-- )//从当前钱数开始比较，直至剩余钱数大于等于当前物品价格即可
        {
            /*只买主件*/
            dp[j]=max(dp[j],dp[j-master[i].price]+master[i].weigh);
/*买主件与第一个附件*/
            if (j>=master[i].price+attachment[i][1].price)
                dp[j]=max(dp[j],dp[j-master[i].price-attachment[i][1].price]+master[i].weigh+attachment[i][1].weigh);
/*买主件与第二个附件*/
           if (j>=master[i].price+attachment[i][2].price)
                dp[j]=max(dp[j],dp[j-master[i].price-attachment[i][2].price]+master[i].weigh+attachment[i][2].weigh);
/*买主件与第一、第二个附件*/
            if (j>=master[i].price+attachment[i][1].price+attachment[i][2].price)
              dp[j]=max(dp[j],dp[j-master[i].price-attachment[i][1].price-attachment[i][2].price]+master[i].weigh+attachment[i][1].weigh+attachment[i][2].weigh);
        }
    }
    cout<<dp[money]<<endl;
    return 0;
}
```





