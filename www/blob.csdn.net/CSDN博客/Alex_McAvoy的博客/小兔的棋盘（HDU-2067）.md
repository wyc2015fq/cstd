# 小兔的棋盘（HDU-2067） - Alex_McAvoy的博客 - CSDN博客





2018年08月12日 21:17:56[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：49








> 
# Problem Description

小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧!

# **Input**

每次输入一个数n(1<=n<=35)，当n等于－1时结束输入。

# Output

对于每个输入数据输出路径数，具体格式看Sample Output。

# Sample Input

**1312-1**

# Sample Output

**1 1 22 3 103 12 416024**


思路：满足卡特兰数列递推公式，打表即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
LL Catalan[N];
int main()
{
    Catalan[0]=1;
    Catalan[1]=1;
    for(int i=2;i<=36;i++)
    {
        Catalan[i]=0;
        for(int j=0;j<i;j++)
            Catalan[i]+=(Catalan[j]*Catalan[i-1-j]);
    }

    int n;
    int cnt=1;
    while(scanf("%d",&n)!=EOF&&n!=-1)
    {
        printf("%d %d %lld\n",cnt++,n,Catalan[n]*2);
    }

    return 0;
}
```





