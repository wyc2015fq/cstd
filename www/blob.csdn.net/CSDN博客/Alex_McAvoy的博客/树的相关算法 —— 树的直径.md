# 树的相关算法 —— 树的直径 - Alex_McAvoy的博客 - CSDN博客





2019年01月16日 16:01:03[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：43
个人分类：[树的相关算法——树的直径																[————树的相关算法————](https://blog.csdn.net/u011815404/article/category/8793797)](https://blog.csdn.net/u011815404/article/category/8616282)








# 【定义】

给定一棵树，树中的每条边都有一个权值。
- 树中两点的距离：连接两点的路径边权之和
- 树的直径：树中最远的两个节点之间的距离
- 树的最长链：连接树中最远的两个结点的路径

# 【实现】

树的直径通常有两种求法，时间复杂度均为O(n)。

假设树以 n 个点 n-1 条边的无向图形式给出，存储在邻接表中。

## 1.两次 BFS(DFS)求树的直径

通过两次 bfs 或 dfs 可以求树的直径，且更容易计算出直径上的具体结点
- 从任意结点出发，通过 bfs 或 dfs 对树进行一次遍历，求出于出发点距离最远的结点，记为 p
- 从结点 p 出发，通过 bfs 或 dfs 对树再进行一次遍历，求出于 p 距离最远的结点，记为 p

则：p 到 q 的路径就是树的直径

在第 2 步的遍历中，可以记录下来每个点第一次被访问的前驱节点，最后从 q 递归到 p，即可得到直径的具体方案

### 1）bfs 实现

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define INF 0x3f3f3f3f
#define N 1001
using namespace std;
struct Edge{
    int w;
    int from,to;
    int next;
}edge[N];
int head[N],edgeNum=0;
int n,m;
int dis[N];
bool vis[N];
int start,endd;
void addEdge(int from,int to,int w) {
    edge[++edgeNum].to=to;
    edge[edgeNum].w=w;
    edge[edgeNum].next=head[from];
    edge[edgeNum].from=from;
    head[from]=edgeNum;
}
void bfs(int s) {

    vis[s]=true;

    queue<int> Q;
    Q.push(s);

    while(!Q.empty()){
        int x=Q.front();
        Q.pop();

        for(int i=head[x];i!=-1;i=edge[i].next){
            int to=edge[i].to;
            if(!vis[to]){
                dis[to]=dis[x]+edge[i].w;
                vis[to]=true;
                Q.push(to);
            }
        }
    }
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF){
        memset(head,-1,sizeof(head));
        edgeNum=0;

        for(int i=1;i<=m;i++){
            int x,y,w;
            scanf("%d%d%d",&x,&y,&w);
            addEdge(x,y,w);
            addEdge(y,x,w);
        }

        memset(vis,false,sizeof(vis));
        memset(dis,INF,sizeof(dis));
        dis[1]=0;
        bfs(1);//从1号点开始找最远的点

        int maxx=-INF;
        for(int i=1;i<=n;i++){
            if(dis[i]>maxx&&dis[i]!=INF) {
                maxx=dis[i];
                start=i;//树的直径的起点
            }
        }

        memset(vis,false,sizeof(vis));
        memset(dis,INF,sizeof(dis));
        dis[start]=0;
        bfs(start);

        maxx=-INF;
        for(int i=1;i<=n;i++){
            if(dis[i]>maxx&&dis[i]!=INF) {
                maxx=dis[i];
                endd=i;//树的直径的终点
            }
        }

        printf("start:%d,end:%d\n",start,endd);
        printf("Max diameter=%d\n",maxx);

    }
    return 0;
}
```

### 2）dfs 实现

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define INF 0x3f3f3f3f
#define N 1001
using namespace std;
struct Edge{
    int w;
    int from,to;
    int next;
}edge[N];
int head[N],edgeNum=0;
int n,m;
int dis[N];
bool vis[N];
int start,endd;
void addEdge(int from,int to,int w) {
    edge[++edgeNum].to=to;
    edge[edgeNum].w=w;
    edge[edgeNum].next=head[from];
    edge[edgeNum].from=from;
    head[from]=edgeNum;
}
void dfs(int x) {
    vis[x]=true;
    for(int i=head[x];i!=-1;i=edge[i].next){
        int to=edge[i].to;
        if(!vis[to]) {
            dis[to]=dis[x]+edge[i].w;
            dfs(to);
        }
    }
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF){
        memset(head,-1,sizeof(head));
        edgeNum=0;

        for(int i=1;i<=m;i++){
            int x,y,w;
            scanf("%d%d%d",&x,&y,&w);
            addEdge(x,y,w);
            addEdge(y,x,w);
        }

        memset(vis,false,sizeof(vis));
        memset(dis,INF,sizeof(dis));
        dis[1]=0;
        dfs(1);//从1号点开始找最远的点
        
        int maxx=-INF;
        for(int i=1;i<=n;i++){
            if(dis[i]>maxx&&dis[i]!=INF) {
                maxx=dis[i];
                start=i;//树的直径的起点
            }
        }
        
        memset(vis,false,sizeof(vis));
        memset(dis,INF,sizeof(dis));
        dis[start]=0;
        dfs(start);
        
        maxx=-INF;
        for(int i=1;i<=n;i++){
            if(dis[i]>maxx&&dis[i]!=INF) {
                maxx=dis[i];
                endd=i;//树的直径的终点
            }
        }
            
        printf("start:%d,end:%d\n",start,endd);
        printf("Max diameter=%d\n",maxx);

    }
    return 0;
}
```

## 2.树形DP求树的直径

设 1 号节点为根，n 个点 n-1 条边的无向图就可以看做有根树

设 dis[x] 表示从点 x 出发走向以 x 为根的子树，能够到达的最远节点的距离，x 的子节点为 y1,y2, y3, ..., yt，edge(x, y) 表示边权，则：dis[x] = max{dis[yi] + edge(x, yi)}(1 <= i <= t)

接下来，可以考虑对每个节点 x 求出经过点 x 的最长链的长度 dp[x]，则整棵树的直径就是 max{dp[x]}(1 <= x <= n)

对于 x 的任意两个节点 yi 和 yj，经过节点 x 的最长链长度可以通过四个部分构成：从 yi 到 yi 子树中的最远距离、边 (x, yi)、从 yj 到 yj 子树中的最远距离、边(x, yj)。则：dp[x] = max{dis[yi] + dis[yj] + edge(x, yi) + edge(x, yj)}(1 <= j < i <= t)

由于在计算 dis [x] 的过程中，子节点的循环将要枚举到 i 时 dis[x] 恰好就保存了从点 x 出发走向以 yj(j<i) 为根的子树，能够到达的最远节点的距离，这个距离就是 max{dis[yi] +edge(x, yi)}(1 <= j < i)

因此可用 dis[x]+dis[yi]+edge(x,yi) 更新 dp[x]，再用 dis[yi]+edge(x,yi) 更新 dis[x] 即可

```cpp
#include<iostream>
#include<cstrig>
#define INF 0x3f3f3f3f
#define N 1001
using namespace std;
int ver[N];//边的终点
int edge[N];//从x到y边权
int head[N],next[N];
bool vis[N];
int dis[N];//以n为根节点在其子树的最长路
int edgeNum;
int diameter;//结果
void addEdge(int x,int y,int w)
{
    ver[++edgeNum]=y;
    edge[edgeNum]=w;
    next[edgeNum]=head[x];
    head[x]=edgeNum;
}
void dp(int x)//根节点
{
    vis[x]=true;
    for(int i=head[x];i;i=next[i])
    {
        int y=ver[i];//点i的终点
        if(vis[y])
            continue;
        dp(y);
        if(dis[x]+dis[y]+edge[i]>diameter)
            diameter=dis[x]+dis[y]+edge[i];
        if(dis[y]+edge[i]>dis[x])
            dis[x]=dis[y]+edge[i];
    }
}
int main()
{
    int n,m;//边数
    while(cin>>n>>m)
    {
        diameter=-INF;
        edgeNum=0;
        for(int i=1;i<=m;++i){
            int x,y,z;
            cin>>x>>y>>z;
            addEdge(x,y,z);
            addEdge(y,x,z);
        }
        dp(1);
        cout<<diameter<<endl;
    }
}
```

# 【例题】
- Farthest Nodes in a Tree（LightOJ-1094）**(模版题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86509930)
- 




