# 花生采摘（洛谷-P1086） - Alex_McAvoy的博客 - CSDN博客





2018年04月08日 14:33:17[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：102








> 
## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://img-blog.csdn.net/20180818124908254?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；

2) 从一棵植株跳到前后左右与之相邻的另一棵植株；

3) 采摘一棵植株下的花生；

4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为13, 7, 15, 9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。

## 输入输出格式

**输入格式：**

输入的第一行包括三个整数，M, N和K，用空格隔开；表示花生田的大小为M * N（1 <= M, N <= 20），多多采花生的限定时间为K（0 <= K <= 1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i + 1行的第j个整数Pij（0 <= Pij <= 500）表示花生田里植株(i, j)下花生的数目，0表示该植株下没有花生。

**输出格式：**

一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。

## 输入输出样例

**输入样例#1：**

6 7 21

0 0 0 0 0 0 0

0 0 0 0 13 0 0

0 0 0 0 0 0 7

0 15 0 0 0 0 0

0 0 0 9 0 0 0

0 0 0 0 0 0 0

**输出样例#1：**

37

**输入样例#2：**

6 7 20

0 0 0 0 0 0 0

0 0 0 0 13 0 0

0 0 0 0 0 0 7

0 15 0 0 0 0 0

0 0 0 9 0 0 0

0 0 0 0 0 0 0

**输出样例#2:**

28


思路：

找出最大的花生点，从这个地方找第二大的花生点，以此类推。

边界条件是此处没有花生或采此处花生的时间不够用。

## 源代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int m,n,k,sum=0;
int a[25][25];

void dfs(int x0,int y0,int time0)
{
    int x,y,time;
    int maxx=-99999999;
    int i,j;

    for(i=1;i<=m;i++)
        for(j=1;j<=n;j++)
            if(a[i][j]>maxx)
            {
                maxx=a[i][j];//记录花生最多的个数
                x=i;//x坐标
                y=j;//y坐标
            }

    if(y0==0)//边界条件
        y0=y;
    time=fabs(x-x0)+abs(y-y0)+x+1;//采当前花生花费的时间

    if(time0<time||a[x][y]==0)//返回条件
        return;
    else
    {
        sum+=a[x][y];//统计所采摘的花生个数
        a[x][y]=0;//采摘归零
        dfs(x,y,time0-abs(x-x0)-abs(y-y0)-1);//向下搜索
    }
}

int main()
{
    int i,j;

    cin>>m>>n>>k;
    for(i=1;i<=m;i++)
        for(j=1;j<=n;j++)
            cin>>a[i][j];

    dfs(0,0,k);

    cout<<sum<<endl;
    return 0;
}
```





