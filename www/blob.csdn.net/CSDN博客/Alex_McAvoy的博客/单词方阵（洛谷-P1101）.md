# 单词方阵（洛谷-P1101） - Alex_McAvoy的博客 - CSDN博客





2018年04月18日 22:50:08[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：115








## 题目描述

给一nXn的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着8个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间[color=red]可以[/color]交叉,因此有可能共用字母。输出时，将不是单词的字母用“*”代替，以突出显示单词。例如：

```cpp
输入：
    8                     输出：
    qyizhong              *yizhong
    gydthkjy              gy******
    nwidghji              n*i*****
    orbzsfgz              o**z****
    hhgrhwth              h***h***
    zzzzzozo              z****o**
    iwdfrgng              i*****n*
    yyyygggg              y******g
```

## 输入输出格式

**输入格式：**

第一行输入一个数n。(7<=n<=100)。

第二行开始输入nXn的字母矩阵。

**输出格式：**

突出显示单词的nXn矩阵。

## 输入输出样例

**输入样例#1：**

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

**输出样例#1：**

```
*******
*******
*******
*******
*******
*******
*******
```

## 源代码

```cpp
#include<iostream>
using namespace std;

char str[101][101];
char judge[101][101]={0};
int direction_x[8]={-1,-1,-1,0,0,1,1,1},direction_y[8]={-1,0,1,-1,1,-1,0,1};//记录方向
void dfs(int x,int y,int direction);

int main()
{
    int n;
    int i,j,k;
    int flag;
    
    cin>>n;//输入矩阵大小n
    for(i=0;i<n;i++)//输入字母矩阵
        for(j=0;j<n;j++)
        	cin>>str[i][j];
    
    for(i=0;i<n;i++)//寻找yizhong
        for(j=0;j<n;j++)
            if(str[i][j]=='y')//判断是否有y
                for(k=0;k<8;k++)//如果有y，在周围寻找是否有i
                    if( str[i+direction_x[k]][j+direction_y[k]] == 'i')//如果周围方向有i
                    {
                        flag=k;//记录有i的方向
                        dfs(i,j,flag);//调用函数向方向k搜索
                    }

    for(i=0;i<n;i++)//如果坐标标记点为1，则输出该坐标的字母，否则输出*
    {
        for(j=0;j<n;j++)
            if(judge[i][j]==1)	cout<<str[i][j];
    		else	cout<<"*";
        cout<<endl;       
    }
    
    return 0;
}

void dfs(int x,int y,int direction)
{
    char ch[7]={'y','i','z','h','o','n','g'};
    int sum=0;
    int i;
    int x1,y1;

    x1=x,y1=y;
    
    for(i=0;i<7;i++)//从当前左边开始向direction方向寻找yizhong
    {
        if(str[x1][y1]==ch[i])//判断是否有要找的字
            sum++;//如果有，计数器+1
        else//如果没有
            break;//终止循环
        x1+=direction_x[direction];//改变坐标x，以移动到下一点
        y1+=direction_y[direction];//改变坐标y，以移动到下一点
    }
    
    if(sum==7)//如果sum=7，说明找到了yizhong
    {
        for(i=0;i<7;i++)
        {
            judge[x][y]=1;//将yizhong的坐标标记为1
            x+=direction_x[direction];//改变坐标x，以移动到下一点
            y+=direction_y[direction];//改变左边y，以移动到下一点
        }
    }
}
```





