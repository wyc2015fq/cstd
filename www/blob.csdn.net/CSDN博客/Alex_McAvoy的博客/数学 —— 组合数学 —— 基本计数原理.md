# 数学 —— 组合数学 —— 基本计数原理 - Alex_McAvoy的博客 - CSDN博客





2018年08月02日 17:31:11[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：182








# 【概述】

计数，即计算数量，是数学中最重要的研究对象之一。

在日常生活中，我们常用于计算完成某件事情所存在的方法的数量，这个数量虽然很基础且理想化，但这个数量往往会被作为计算某个方法发生的可能性的基础数值。

# 【抽屉原理】

## 1.内容

把 n+1 件东西放入 n 个抽屉，则至少有一个抽屉里放两件或两件以上的东西。

从令一角度说，把 n-1 件东西放入 n  个抽屉，则至少一个抽屉是空的。

## 2.经典应用

给出一个含有 n 个数字的序列，要找一个连续的子序列，使他们的和一定是 c 的倍数

假设 sum[i] 存储整数序列中的前 i 项和

根据抽屉原理，以 sum 数组构造抽屉 drawer 数组，其保存的是最先出现的 sum[i] 的下标，当 sum 的一个元素第二次放入重复的抽屉时，输出结果。

若 sum[i] 是 c 的倍数，直接输出前 i 项即可，若 sum[i] 不是 c 的倍数，则需要计算 sum[i]%c，此时，sum[i]%c = sum[j]%c，i!=j 肯定存在，即第 j 到第 i 项数的和为 c 的倍数。

```cpp
#include<cstdio>
#include<cstring>
#define N 1000001
#define LL long long
LL a[N],drawer[N];
LL sum[N];
int main()
{
    LL c,n;
    while(scanf("%lld%lld",&c,&n)!=EOF&&c&&n)
    {
        memset(drawer,-1,sizeof(drawer));
        drawer[0]=0;
        sum[0]=0;
        
        for(LL i=1;i<=n;i++)
        {
            scanf("%lld",&a[i]);
            sum[i]=sum[i-1]+a[i];
        }
        
        for(LL i=1;i<=n;i++)
        {
            if(drawer[sum[i]%c]!=-1)
            {
                for(LL j=drawer[sum[i]%c]+1;j<i;j++)
                    printf("%lld ",j);
                printf("%lld\n",i);
                break;
            }
            drawer[sum[i]%c]=i;
        }
    }
    return 0;
}
```

# **【分类加法原理】**

如果事件 A 有 p 种产生方式，事件 B 有 q 种产生方式，则事件 A或B 有 p+q 种产生方式

要注意的是，事件 A 与事件 B 产生方式不能重叠，即一种方式只能属于其中的一个事件，不能同时属于两个事件。

 推广：若事件 ![A_1](https://private.codecogs.com/gif.latex?A_1) 有 ![p_1](https://private.codecogs.com/gif.latex?p_1) 种产生方式，事件 ![A_2](https://private.codecogs.com/gif.latex?A_2) 有 ![p_2](https://private.codecogs.com/gif.latex?p_2) 种产生方式，...，事件 ![A_n](https://private.codecogs.com/gif.latex?A_n)  有 ![p_n](https://private.codecogs.com/gif.latex?p_n) 种产生方式，则事件 ![A_1](https://private.codecogs.com/gif.latex?A_1) 或 ![A_2](https://private.codecogs.com/gif.latex?A_2) ... ![A_n](https://private.codecogs.com/gif.latex?A_n)，有 ![p_1+p_2+...+p_n](https://private.codecogs.com/gif.latex?p_1&plus;p_2&plus;...&plus;p_n) 种方式。

# 【分步乘法原理】

如果事件 A 有 p 种产生方式，事件 B 有 q 种产生方式，则事件 A与B 有 p*q 种产生方式

要注意的是，事件 A 与事件 B 产生方式必须互相独立，即它们的产生方式彼此无关。

 推广：若事件 ![A_1](https://private.codecogs.com/gif.latex?A_1) 有 ![p_1](https://private.codecogs.com/gif.latex?p_1) 种产生方式，事件 ![A_2](https://private.codecogs.com/gif.latex?A_2) 有 ![p_2](https://private.codecogs.com/gif.latex?p_2) 种产生方式，...，事件 ![A_n](https://private.codecogs.com/gif.latex?A_n)  有 ![p_n](https://private.codecogs.com/gif.latex?p_n) 种产生方式，则事件 ![A_1](https://private.codecogs.com/gif.latex?A_1) 与 ![A_2](https://private.codecogs.com/gif.latex?A_2) ... ![A_n](https://private.codecogs.com/gif.latex?A_n)，有 ![p_1*p_2*...*p_n](https://private.codecogs.com/gif.latex?p_1*p_2*...*p_n) 种方式。

# 【德摩根定律】

设 A、B 为全集 U 的任意两个子集，则：![\overline{A\bigcap B}=\overline{A}\bigcup\overline{B}, \overline{A\bigcup B}=\overline{A}\bigcap\overline{B}](https://private.codecogs.com/gif.latex?%5Coverline%7BA%5Cbigcap%20B%7D%3D%5Coverline%7BA%7D%5Cbigcup%5Coverline%7BB%7D%2C%20%5Coverline%7BA%5Cbigcup%20B%7D%3D%5Coverline%7BA%7D%5Cbigcap%5Coverline%7BB%7D)

其可推广到 n 个子集，设 ![A_1,A_2,...,A_n](https://private.codecogs.com/gif.latex?A_1%2CA_2%2C...%2CA_n) 为全集 U 的任意 n 个子集，则：![\overline{A_1\bigcap A_2\bigcap ... \bigcap A_n}=\overline{A_1}\bigcup\overline{A_2}\bigcup...\bigcup \overline{A_n}](https://private.codecogs.com/gif.latex?%5Coverline%7BA_1%5Cbigcap%20A_2%5Cbigcap%20...%20%5Cbigcap%20A_n%7D%3D%5Coverline%7BA_1%7D%5Cbigcup%5Coverline%7BA_2%7D%5Cbigcup...%5Cbigcup%20%5Coverline%7BA_n%7D)，![\overline{A_1\bigcup A_2\bigcup ... \bigcup A_n}=\overline{A_1}\bigcap\overline{A_2}\bigcap...\bigcap \overline{A_n}](https://private.codecogs.com/gif.latex?%5Coverline%7BA_1%5Cbigcup%20A_2%5Cbigcup%20...%20%5Cbigcup%20A_n%7D%3D%5Coverline%7BA_1%7D%5Cbigcap%5Coverline%7BA_2%7D%5Cbigcap...%5Cbigcap%20%5Coverline%7BA_n%7D)

![](https://img-blog.csdn.net/20180802140942983?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 【应用】

根据研究对象的有无，一般将组合数学分为排列问题和组合问题。

其根本不同是排列问题与元素顺序有关，组合问题与元素顺序无关。

在排列与组合问题中，经常会出现计数问题，解决计数问题的思路一般有以下三种：

1）只取需要的。将各种符合条件的情形枚举出来，再利用加法原理求和。

2）先全部取，再减去不要的。将各种符合条件的情形枚举出来，再减去不符合条件的。

3）先取后排。将各步符合条件的排列或组合计算出来，再根据乘法原理求积。



