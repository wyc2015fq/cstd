# T1237 求排列的逆序数（#Ⅱ- 7） - Alex_McAvoy的博客 - CSDN博客





2018年05月17日 21:50:25[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：670








### 【题目描述】



在Internet上的搜索引擎经常需要对信息进行比较，比如可以通过某个人对一些事物的排名来估计他（或她）对各种不同信息的兴趣，从而实现个性化的服务。

对于不同的排名结果可以用逆序来评价它们之间的差异。考虑1,2,…,n的排列i1，i2，…，in，如果其中存在j,k，满足j<k,且ij>ik，那么就称(ij,ik)是这个排列的一个逆序。

一个排列含有逆序的个数称为这个排列的逆序数。例如排列 263451 含有8个逆序(2,1),(6,3),(6,4),(6,5),(6,1),(3,1),(4,1),(5,1)，因此该排列的逆序数就是8。显然，由1,2,…,n 构成的所有n!个排列中，最小的逆序数是0，对应的排列就是1,2,…,n；最大的逆序数是n(n-1)/2，对应的排列就是n,(n-1),…,2,1。逆序数越大的排列与原始排列的差异度就越大。

现给定1,2,…,n的一个排列，求它的逆序数。



### 【输入】



第一行是一个整数n，表示该排列有n个数（n ≤ 100000)。

第二行是n个不同的正整数，之间以空格隔开，表示该排列。

### 【输出】

输出该排列的逆序数。

### 【输入样例】

```
6
2 6 3 4 5 1
```

### 【输出样例】
`8`
### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<string>
#define INF 999999999
#define N 1000001
#define MOD 1000000007
using namespace std;
int n;
int a[N],b[N];
long long ans=0;
void msort(int left,int right)
{
    int mid=(left+right)/2;
    if(left>=right)
        return ;
    msort(left,mid);
    msort(mid+1,right);

    int i=left,j=mid+1,n=mid,m=right,k=0;
    while(i<=n&&j<=m)
        if(a[i]>a[j])
        {
            ans+=n-i+1;
            b[k++]=a[j++];
        }
        else
            b[k++]=a[i++];
    while(i<=n)
        b[k++]=a[i++];
    while(j<=m)
        b[k++]=a[j++];
    for(i=0;i<k;i++)
        a[left+i]=b[i];
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    msort(1,n);
    cout<<ans<<endl;
    return 0;
}
```





