# T1378 最短路径（#Ⅲ- 4 - 2） - Alex_McAvoy的博客 - CSDN博客





2018年06月25日 00:23:10[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：598








> 
# 【题目描述】

给出一个有向图G=(V, E)，和一个源点v0∈V，请写一个程序输出v0和图G中其它顶点的最短路径。只要所有的有向环权值和都是正的，我们就允许图的边有负值。顶点的标号从1到n（n为图G的顶点数）。

# 【输入】

第1行：一个正数n（2≤n≤80），表示图G的顶点总数。

第2行：一个整数，表示源点v0（v0∈V，v0可以是图G中任意一个顶点）。

第3至第n+2行，用一个邻接矩阵W给出了这个图。

# 【输出】

共包含n-1行，按照顶点编号从小到大的顺序，每行输出源点v0到一个顶点的最短距离。每行的具体格式参照样例。

# 【输入样例】

**510 2 - - 10- 0 3 - 7- - 0 4 -- - - 0 5- - 6 - 0**

# 【输出样例】

**(1 -> 2) = 2(1 -> 3) = 5(1 -> 4) = 9(1 -> 5) = 9**


# 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 101
#define MOD 123
#define E 1e-6
using namespace std;
int a[N][N];
int main()
{
    int n,s;
    cin>>n>>s;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            int b;
            if(scanf("%d",&b)==1)//如果b是整数
                a[i][j]=b;
            else
                a[i][j]=INF;
        }
    }

    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(a[i][j]>a[i][k]+a[k][j])
                    a[i][j]=a[i][k]+a[k][j];

    for(int i=1;i<=n;i++)
        if(i!=s)
            printf("(%d -> %d) = %d\n",s,i,a[s][i]);

    return 0;
}
```





