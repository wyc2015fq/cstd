# 有线电视网（洛谷-P1273） - Alex_McAvoy的博客 - CSDN博客





2018年10月06日 19:19:51[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：92








## 题目描述

某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。

从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。

现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。

写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。

## 输入输出格式

**输入格式：**

输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。

第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。

接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下：

K A1 C1 A2 C2 … Ak Ck

K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。

**输出格式：**

输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。

## 输入输出样例

**输入样例#1：**

```
5 3
2 2 2 5 3
2 3 2 4 3
3 4 2
```

**输出样例#1：**
`2`
————————————————————————————————————————————————————

思路：树形dp的分组背包问题

边可以重复利用但是只付一次的费用，状态不可能表示哪些边选，既然每条边不用重复计算，那就先算每个点在他的后代中选几个点的费用，再计算父亲的时候利用儿子的费用再加上它与儿子的边权，用 dp[i][j] 表示在以 i 为根的子树中，满足 j 个客户的需求所能获得的最大收益，更新时将每个儿子扫一遍，并用当前搜到的儿子选的用户数更新状态，在最终求最多客户时，只要求最大的 dp[1][i]>=0 的 i 即可

## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 3001
#define MOD 10007
#define E 1e-6
#define LL long long
using namespace std;
struct Edge{
    int to;
    int next;
    int w;
}edge[N*N];
int n,m;
int a[N];
int dp[N][N];
int value[N],t[N];
int cnt;
void addEdge(int x,int y,int w){
    cnt++;
    edge[cnt].to=y;
    edge[cnt].next=a[x];
    edge[cnt].w=w;
    a[x]=cnt;
}
int treeDP(int x){
    if (x>n-m){
        dp[x][1]=value[x];
        return 1;
    }
    int sum=0;
    for (int i=a[x];i;i=edge[i].next){
        int v=edge[i].to;
        int temp=treeDP(v);
        for(int j=0;j<=sum;j++)
            t[j]=dp[x][j];
        for(int j=0;j<=sum;j++)
            for(int k=0;k<=temp;k++)
                dp[x][j+k]=max(dp[x][j+k],t[j]+dp[v][k]-edge[i].w);
        sum+=temp;
    }
    return sum;
}
int main()
{
    cin>>n>>m;
    memset(dp,~0x3f,sizeof(dp));
    for(int x=1;x<=n-m;x++){
        int len;
        cin>>len;
        for(int j=1;j<=len;j++){
            int y,w;
            cin>>y>>w;
            addEdge(x,y,w);
        }
    }
    for(int i=n-m+1;i<=n;i++)
        cin>>value[i];
    for(int i=1;i<=n;i++)
        dp[i][0]=0;
    treeDP(1);
    for(int i=m;i>0;i--){
        if(dp[1][i]>=0){
            printf("%d",i);
            break;
        }
    }

	return 0;
}
```





