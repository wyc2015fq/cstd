# Java —— 面向对象常见关键字 - Alex_McAvoy的博客 - CSDN博客





2018年10月05日 17:14:27[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：62
个人分类：[Java学习笔记](https://blog.csdn.net/u011815404/article/category/8863016)

所属专栏：[Java 学习笔记](https://blog.csdn.net/column/details/34317.html)









# 【权限修饰符】

1.对 class 的权限修饰只可以使用 public 和 default(缺省)，public 类可以在任何地方被访问，default 类仅可呗同一个包内部的类访问

2.对类的成员的权限修饰有 public/protected/private 三种，用于限定对象对该类成员的权限访问
|修饰符|类内部|同一个包|子类|任何地方|
|----|----|----|----|----|
|private|Yes||||
|default|Yes|Yes|||
|protected|Yes|Yes|Yes||
|public|Yes|Yes|Yes|Yes|

# 【this】

1）当成员变量与局部变量名字相同时，成员变量会被隐藏，此时若想在成员方法中使用成员变量，需要使用关键字 this，this 可视为当前对象或当前正在创建的对象

```java
class A{
    int a;
    private void setNum(int a){
        this.a=a;
    }
}
```

2）可以使用 this 关键字做返回值

```java
public A getA(){
    return this;
}
```

3）可以通过 this() 来显式的调用当前类重载的指定的构造器

```java
class A(){
    private int a;
    private String b;
    public A(){
        a=1;
        b="abc";
    }
    public A(int a){
        this();
        this.a=2;
    }
    public A(int a,String b){
        this(a);
        this.b=b;
    }
}
```

4）在由 static 修饰的静态方法中，不能出现 this

# 【import】

import 关键字用于加载已定义好的类或包，被加载的类可供本类调用其方法与属性。

```java
import 包名1.[包名2. ...].类名|*;
```

当存在多个包名时，各个包名间用 . 来间隔，同时包名与类名间也用 . 来间隔，也可用 * 来表示包中所有的类

# 【static】

由 static 修饰的属性、方法、初始化块、内部类统称静态结构，均存放在静态域中，一经定义其内存地址不会改变，是可被整个类所共享的。

静态结构的生命周期早于非静态结构，同时被回收也晚于非静态结构。

1）static 变量

① 随着类的加载而被加载，早于对象，且仅被加载一次

② 由类创建的所有对象均共享这一属性

③ 当其中一个对象对此属性进行修改后，其他对象对此属性的调用值为被修改后的值

④ 可以通过 类.属性 的形式调用，也可通过 对象.属性 的形式调用

2）static 方法

① 随着类的加载而被加载，早于对象，且仅被加载一次

② 由类创建的所有对象均共享这一方法

③ 内部可以调用静态属性和静态方法，而不能调用非静态属性和非静态方法（非静态方法内部可以调用静态属性和静态方法）

④ 可以通过 类.方法 的形式调用

# 【final】

1）final 变量

final 修饰变量时，一旦获得初值就不可再被改变。在其修饰成员变量时，若未在定义成员变量时指定初始值，则成员变量的值会一直是各类型的初始值(0/false/null)；在其修饰局部变量时，若未在定义成员变量时指定初始值，可在后面代码中对该局部变量赋值，但只能赋值一次，若在定义成员变量时指定初始值，则不可再赋值

2）final 类

用 final 修饰的类称为 final 类，该类不能被继承，不可拥有子类，一些重要的类常声明为 final 类（Java 提供的 System类、String 类等）

3）final 方法

用 final 修饰的方法称为 final 方法，其不可被重写，若想不允许子类重写父类的某个方法，可将该方法作为 final 方法

4）一般使用 static final 来修饰全局常量

# 【extends】

当类需要继承时，通过 extends 来显式地指明其父类

```java
[public/abstract/final] class 子类名 extends 父类名{
    类体
}
```

# 【super】

1）调用父类的构造方法

当子类需要显式调用父类的构造方法时，需通过 super 来调用

```java
super([参数列表]);
```

要注意的是，在构造器内部，super([参数列表]); 与 this([参数列表]); 只可出现一个，若不显示的调用此两者，默认调用父类空参的构造器

2）操作被隐藏的成员变量与被覆盖的成员方法

若想在子类中操作父类被隐藏的成员变量和被覆盖的成员方法，需要使用 super 来操作

```java
super.成员变量;
super.成员方法([参数列表]);
```

注：若子类声明了一个与父类成员变量同名的成员变量，此时称子类成员变量隐藏了父类成员变量；若子类声明了一个与父类成员方法同名的成员方法，此时称子类成员方法覆盖了父类成员方法。

3）在由 static 修饰的静态方法中，不能出现 super

# 【abstract】

当需要声明抽象类时，需要使用 abstract 来声明，抽象类不能被实例化，可以没有抽象方法。

```java
abstract class 类名 {
    类体
}
```

抽象方法亦需用 abstract 修饰，有抽象方法的类一定是抽象类，抽象方法没有方法体，只保留了方法的功能，其具体实现交给继承抽象类的子类，在子类中重写此抽象方法。

若子类继承抽象类，当重写了全部的抽象方法时，则此类是一个实体类，可以实例化；当没有重写全部的抽象方法时，则此类中仍有抽象方法，意味着该子类必须声明为抽象类。

```java
abstract <方法返回值类型> 方法名 (参数列表);
```

不能用 abstract 来修饰属性、构造器、private 方法、static 方法、final 方法



