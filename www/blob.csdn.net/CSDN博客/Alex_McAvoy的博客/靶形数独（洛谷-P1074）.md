# 靶形数独（洛谷-P1074） - Alex_McAvoy的博客 - CSDN博客





2018年07月03日 20:42:29[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：215








## 题目描述

小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。

靶形数独的方格同普通数独一样，在 9 格宽× 9 格高的大九宫格中有 9 个 3 格宽× 3 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 1 到 9 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）

![](https://img-blog.csdn.net/20180818132834245?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上图具体的分值分布是：最里面一格（黄色区域）为 10 分，黄色区域外面的一圈（红色区域）每个格子为 9 分，再外面一圈（蓝色区域）每个格子为 8 分，蓝色区域外面一圈（棕色区域）每个格子为 7 分，最外面一圈（白色区域）每个格子为 6 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和

总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。

![](https://img-blog.csdn.net/20180818132906913?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。

## 输入输出格式

**输入格式：**

一共 9 行。每行 9 个整数（每个数都在 0−9 的范围内），表示一个尚未填满的数独方格，未填的空格用“ 0 ”表示。每两个数字之间用一个空格隔开。

**输出格式：**

输出共 1 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数 -1 。

## 输入输出样例

**输入样例#1：**

```
7 0 0 9 0 0 0 0 1 
1 0 0 0 0 5 9 0 0 
0 0 0 2 0 0 0 8 0 
0 0 5 0 2 0 0 0 3 
0 0 0 0 0 0 6 4 8 
4 1 3 0 0 0 0 0 0 
0 0 7 0 0 2 0 9 0 
2 0 1 0 6 0 8 0 4 
0 8 0 5 0 4 0 1 2
```

**输出样例#1：**
`2829`
**输入样例#2：**

```
0 0 0 7 0 2 4 5 3 
9 0 0 0 0 8 0 0 0 
7 4 0 0 0 5 0 1 0 
1 9 5 0 8 0 0 0 0 
0 7 0 0 0 0 0 2 5 
0 3 0 5 7 9 1 0 8 
0 0 0 6 0 1 0 0 0 
0 6 0 9 0 0 0 0 1 
0 0 0 0 0 0 0 0 6
```

**输出样例#2：**
`2852`
## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 11
#define MOD 123
#define E 1e-6
using namespace std;
int g[N][N];
int grade[10][10]{
{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6},
};
int area[10][10]{
{0,0,0,0,0,0,0,0,0,0},
{0,1,1,1,2,2,2,3,3,3},
{0,1,1,1,2,2,2,3,3,3},
{0,1,1,1,2,2,2,3,3,3},
{0,4,4,4,5,5,5,6,6,6},
{0,4,4,4,5,5,5,6,6,6},
{0,4,4,4,5,5,5,6,6,6},
{0,7,7,7,8,8,8,9,9,9},
{0,7,7,7,8,8,8,9,9,9},
{0,7,7,7,8,8,8,9,9,9},
};
struct Node{
    int x;
    int y;
}point[N*10];
int vis_x[N][N],vis_y[N][N],vis_g[N][N];
int vis[N*10];
int n,sum;
void dfs(int k)
{
    if(k>n)//当确定的数字个数大于未填入的数字总数时
    {
        int cnt=0;

        for(int i=1;i<=9;i++)//记录分值
            for(int j=1;j<=9;j++)
                cnt+=g[i][j]*grade[i][j];

        sum=max(sum,cnt);//取最大分值

        return;

    }

    int w=INF,temp;
    for(int i=1;i<=n;i++)//确定搜索的起点
        if(!vis[i])
        {
            int ww=0;
            for(int j=1;j<=9;j++)
                if( !vis_x[point[i].x][j] && !vis_y[point[i].y][j] && !vis_g[area[point[i].x][point[i].y]][j] )
                    if(++ww==w)
                        break;
            if(ww<w)
            {
                w=ww;
                temp=i;
            }
        }


    vis[temp]=1;
    int x=point[temp].x;
    int y=point[temp].y;

    for(int i=1;i<=9;i++)//枚举每一层可能的状态
        if( !vis_x[x][i] && !vis_y[y][i] && !vis_g[area[x][y]][i] )//如果当前数字在整个图的横向纵向小区域内未出现过
        {
            g[x][y]=i;
            vis_x[x][i]=1;
            vis_y[y][i]=1;
            vis_g[area[x][y]][i]=1;

            dfs(k+1);

            vis_x[x][i]=0;
            vis_y[y][i]=0;
            vis_g[area[x][y]][i]=0;
        }

    vis[temp]=0;
}
int main()
{
    n=0;
    for(int i=1;i<=9;i++)
        for(int j=1;j<=9;j++)
        {
            cin>>g[i][j];
            if(g[i][j])//如果当前点填入数字
            {
                vis_x[i][g[i][j]]=1;//标记该行
                vis_y[j][g[i][j]]=1;//标记该列
                vis_g[area[i][j]][g[i][j]]=1;//标记整张图
            }
            else//如果当前点未填入数字
            {
                /*记录未填入数字*/
                n++;
                point[n].x=i;
                point[n].y=j;
            }
        }

    sum=-1;
    dfs(1);
    cout<<sum<<endl;
    return 0;
}
```





