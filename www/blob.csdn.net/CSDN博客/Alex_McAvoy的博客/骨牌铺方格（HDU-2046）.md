# 骨牌铺方格（HDU-2046） - Alex_McAvoy的博客 - CSDN博客





2018年03月29日 19:50:52[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：162








> 
# Problem Description

    在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.

    例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：

![](https://img-blog.csdn.net/20180329194932105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# Input

    输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0<n<=50)。

# Output

    对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。

# Sample Input

**1 3 2**

# Sample Output

**1 3 2**


思路：

设：用a[i]表示2*i的方格的方法数

已知：

    a[1]=1;

    a[2]=2;

    a[3]=3;

则：

    a[i]实质是在2*（i-1）的格子后加上一格2*1的方格，骨牌在这一格上横放或竖放。

    如果前面i-1块已经铺好，则第i块只有竖着放；

    如果前面i-1块已经铺好，则第i块只有横着放。

![](https://img-blog.csdn.net/2018032920232136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

                                                                                         （图源网络 侵删致歉）

简单验证：

      规格为1时： 1种

      规格为2时： 2种

      规格为3时： 3种

      规格为4时： 5种

      规格为5时： 8种

               ……

可推：第 n 个的可能路径为  f(n)=f(n-1)+f(n-2)（斐波那契数列）

# Source Program

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long a[50];//注意用long long
    int n;
    int i;

    /*预处理，先求出斐波那契数列*/
    a[0]=1;
    a[1]=1;
    a[2]=2;
    for(i=3;i<=50;i++)
        a[i]=a[i-1]+a[i-2];

    while(cin>>n)
        cout<<a[n]<<endl;

    return 0;
}
```





