# 数据结构 —— 单调栈与单调队列 - Alex_McAvoy的博客 - CSDN博客





2019年02月10日 12:17:31[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：103








# 【单调栈】

## 1.原理

单调栈，就是栈内元素保持一定单调性（单调递增或单调递减）的栈，即从栈底到栈顶单调递增或递减。

对于**单调递增**的栈，如果栈为空或入栈元素值**大于等于**栈顶元素值，则入栈；否则，若入栈会破坏栈的单调性，因此需要将比入栈元素**大**的元素全部出栈。

对于**单调递减**的栈，如果栈为空或入栈元素值**小****于等于**栈顶元素值，则入栈；否则，若入栈会破坏栈的单调性，因此需要将比入栈元素**小**的元素全部出栈。

以下图单调递减的栈为例，从栈顶到栈底初始元素为：6、4、2、1

![](https://img-blog.csdnimg.cn/2019021012410269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

当插入的元素小于等于栈顶元素时，满足单调递减的条件，可直接加入栈，例如：插入元素 0，可直接加到栈顶

![](https://img-blog.csdnimg.cn/20190210124818176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

当插入的元素大于等于栈顶元素时，为满足单调递减的性质，需要从栈顶开始，将比入栈元素小的值全部弹出再入栈，例如：插入元素 3，需要先将 1、2 弹出

![](https://img-blog.csdnimg.cn/2019021012483659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

## 2.应用

单调栈常用的应用有：
- 给定一组数，对于某个数，找到从左/右遍历第一个比它小/大的元素的位置
- 给定一组数，针对每个数，寻找其与其左/右第一个比它小/大的数之间有多少个数
- 给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列的长度最大
- 给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列所有元素和最大

## 3.实现

### 1）单调递增栈

```cpp
stack<int> S;
 for(int i=1;i<=n;i++){
     while(!S.empty()&&a[S.top()]>a[i]){//栈不为空且栈顶元素大于入栈元素时
        S.pop();//将栈顶大于入栈元素的元素出栈
        ...//更新结果
     }
     S.push(i);//元素入栈
}
```

### 2）单调递减栈

```cpp
stack<int> S;
 for(int i=1;i<=n;i++){
     while(!S.empty()&&a[S.top()]<a[i]){//栈不为空且栈顶元素小于入栈元素时
        S.pop();//将栈顶小于入栈元素的元素出栈
        ...//更新结果
     }
     S.push(i);//元素入栈
}
```

# 【单调队列】

## 1.原理

单调队列就是从队首到队尾满足单调性的队列，与单调栈极其相似，其基本原理与单调栈相同，只需将单调栈先进后出的性质改为先进先出的性质即可。 

对于**单调递增**的队列，若队列为空或入队元素 x **大****于等于**队尾元素，则入队；否则，入队会破坏队列的单调性，因此需要将队尾中比入队元素 x **大**的元素全部出队。

对于**单调递减**的队列，若队列为空或入队元素 x **小****于等于**队尾元素，则入队；否则，入队会破坏队列的单调性，因此需要将队尾中比入队元素 x **小**的元素全部出队。

## 2.应用

单调队列的常用应用有：
- 给出一组数，求这组数中第一个大/小于等于一个数 x 的数
- 维护单调性，从而解决区间内最小/大的问题
- 解决滑动窗口问题
- 优化多重背包 DP、斜率优化 DP

## 3.实现

单调队列一般使用 STL 的 deque(双端队列) 实现即可，由于双端队列即可再队首操作又可在队尾操作，那么这样的性质就弥补了单调栈只可在尾端操作的不足，使得首段也有了一定的限制。

### 1）单调递增队列

```cpp
deque<int> Q://双端队列
for(int i=1;i<=n;i++){
    while((!Q.empty())&&Q.back()>A[i]){//队列不为空且队尾元素大于入队元素时
       Q.pop_back();//将队列尾端大于入队元素的元素出队
       ...//更新结果
    }
    q.push_back(A[i]);//元素入队
    ...//更新结果
}
```

### 2）单调递减队列 

```cpp
deque<int> Q://双端队列
for(int i=1;i<=n;i++){
    while((!Q.empty())&&Q.back()<A[i]){//队列不为空且队尾元素小于入队元素时
       Q.pop_back();//将队列尾端小于入队元素的元素出队
       ...//更新结果
    }
    q.push_back(A[i]);//元素入队
    ...//更新结果
}
```

# 【例题】
- City Skyline（POJ-3044）**(单调递增栈)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81212722)
- Bad Hair Day（POJ-3250）**(单调递增栈)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80859166)
- Largest Rectangle in a Histogram（HDU-1506）**(左右两次单调递增栈)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86916520)
- Passing the Message（HDU-3410）**(左右两次单调递减栈)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86914532)
- Non-negative Partial Sums（HDU-4193）**(单调递减队列)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86900714)
- Second My Problem First（HDU-3706）**(单调递增队列)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86903281)



