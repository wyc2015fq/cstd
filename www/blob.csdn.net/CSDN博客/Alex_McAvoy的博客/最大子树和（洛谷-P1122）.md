# 最大子树和（洛谷-P1122） - Alex_McAvoy的博客 - CSDN博客





2018年10月06日 19:21:09[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：88








## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有N朵花，共有N−1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 输入输出格式

**输入格式：**

第一行一个整数N(1 ≤ N ≤ 16000)。表示原始的那株花卉上共N朵花。

第二行有N个整数，第II个整数表示第II朵花的美丽指数。

接下来N-1行每行两个整数a,b，表示存在一条连接第a朵花和第b朵花的枝条。

**输出格式：**

一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过2147483647。

## 输入输出样例

**输入样例#1：**

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

**输出样例#1：**
`3`
————————————————————————————————————————————————————

思路：树形dp

实质是给一棵 n 个点的树，以 1 号点为根，求以每个点为根的子树大小，用 f[x] 表示以 x 为根且包含 x 的最大权联通块，则有状态转移方程：f[x]+=max(0,f[y])，其中 y 为 x 的儿子，由于儿子结点的美丽值可能小于 0，因此要与 0 逐个比较来判断是否选择

## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 100000
#define MOD 16007
#define E 1e-6
#define LL long long
using namespace std;
struct Edge{
    int to;
    int next;
}edge[N];
int n;
int a[N];
int head[N],f[N];
int cnt,res;
void addEdge(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].next=head[x];
    head[x]=cnt;
}
void treeDP(int x,int father){
    f[x]=a[x];
    for(int i=head[x];i;i=edge[i].next){
        int y=edge[i].to;
        if(y!=father){
            treeDP(y,x);
            f[x]+=max(0,f[y]);
        }
    }
    res=max(res,f[x]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        addEdge(x,y);
        addEdge(y,x);
    }
    treeDP(1,0);
    printf("%d",res);

	return 0;
}
```





