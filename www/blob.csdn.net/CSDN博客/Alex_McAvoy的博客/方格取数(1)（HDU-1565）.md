# 方格取数(1)（HDU-1565） - Alex_McAvoy的博客 - CSDN博客





2018年10月03日 23:13:27[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：56








# Problem Description

给你一个n*n的格子的棋盘，每个格子里面有一个非负数。

从中取出若干个数，使得任意的两个数所在的格子没有公共边，就是说所取的数所在的2个格子不能相邻，并且取出的数的和最大。

# **Input**

包括多个测试实例，每个测试实例包括一个整数n 和n*n个非负数(n<=20)

# Output

对于每个测试实例，输出可能取得的最大的和

# Sample Input

**375 15 21 75 15 28 34 70 5 **

# Sample Output

**188**

————————————————————————————————————————————————————

思路：状压DP

题目中 n<=20，但仅需枚举每一行中满足条件的状态，当实际上当 n=20 时，合法状态为 16，因此实际上 n<=16

用 dp[i][j] 表示前 i 行的第 i 行取 j 种状态时的最大和，用 sum[i][j] 表示第 i 行取第 j 个状态的取值总和，则有 dp[i][j] = max(dp[i][j], dp[i-1][k] + sum[i][j]) ，当两行状态相与为 0 即可进行状态转移

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 16
#define MOD 10007
#define E 1e-6
#define LL long long
using namespace std;
int n;
int a[21][21];
int dp[21][1<<N],sum[21][1<<N];
int sta[1<<N];
int calculate(int k,int state){//求第i行状态为state时的取值总和
    int res=0;
    for(int i=0;i<n;i++)
        if((state>>i)&1)
            res+=a[k][n-1-i];
    return res;
}
int main()
{
	while(scanf("%d",&n)!=EOF)
    {
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                scanf("%d",&a[i][j]);

        memset(sum,0,sizeof(sum));
        memset(dp,0,sizeof(dp));

        /*数据处理，求出所有取值和*/
        int len=0;
        for(int i=0;i<(1<<n);i++)//枚举所有状态
            if(!(i&(i>>1)))//判断本行状态
                sta[len++]=i;

        for(int i=0;i<n;i++)//求第i行取第j个状态的取值总和
            for(int j=0;j<len;j++)
                sum[i][j]+=calculate(i,sta[j]);

        /*状态转移，求最大和*/
        for(int i=0;i<len;i++)
            dp[0][i]=sum[0][i];
        for(int i=1;i<n;i++)//行数
            for(int j=0;j<len;j++)//本行状态
                for(int k=0;k<len;k++)//上一行状态
                    if(!(sta[j]&sta[k]))
                        dp[i][j]=max(dp[i][j],dp[i-1][k]+sum[i][j]);

        /*寻找最大和*/
        int res=dp[n-1][0];
        for(int i=1;i<len;i++)
            if(res<dp[n-1][i])
                res=dp[n-1][i];
        printf("%d\n",res);
    }
	return 0;
}
```





