# 多米诺骨牌（洛谷-P1282） - Alex_McAvoy的博客 - CSDN博客





2018年08月20日 16:24:06[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：98








## 题目描述

多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的

上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。例如在图8-1中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。

![](https://img-blog.csdn.net/2018082016225260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。

## 输入输出格式

**输入格式：**

输入文件的第一行是一个正整数n(1≤n≤1000)，表示多米诺骨牌数。接下来的n行表示n个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数a和b，且1≤a，b≤6。

**输出格式：**

输出文件仅一行，包含一个整数。表示求得的最小旋转次数。

## 输入输出样例

**输入样例#1：**

```
4
6 1
1 5
1 3
1 2
```

**输出样例#1：**
`1`
## 源代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int min(int x,int y)//比较函数
{
    if(x>y)
        return y;
    else
        return x;
} 
int dp[1010][12010];
int main()
{
    int n,top[1001],under[1001];
    int sum[1001],result;
    int i,j;
    
    cin>>n;//输入牌数
    for(i=1;i<=n;i++)	
    {
        cin>>top[i]>>under[i];//输入上方、下方点数
    	sum[i]=top[i]-under[i];//每一组牌的上下差值
    }
    memset(dp,1,sizeof(dp));//将dp数组全部赋1值
    dp[0][5000]=0;
    for(i=1;i<=n;i++)//从第一组牌开始比较
        for(j=-5000;j<=5000;j++)//最小情况为上方1000张全为1，下方1000全为6；最大情况为上方1000张全为6，下方1000全为1
            dp[i][j+5000]=min(dp[i-1][j+5000-sum[i]] , dp[i-1][j+5000+sum[i]]+1);//比较每一次是翻转还是不翻转得到的值最小

    for(i=0;i<=5000;i++)
    {
        result=min(dp[n][i+5000],dp[n][-i+5000]);//比较每次是翻转或不翻转小
        if(result<=1000)//因为最多有1000张牌，因此最多移动1000次
        {
            cout<<result<<endl;
            break;
        }
    }
    return 0;
}
```





