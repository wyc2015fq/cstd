# 虫食算（洛谷-P1092） - Alex_McAvoy的博客 - CSDN博客





2018年04月18日 22:59:02[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：71








## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N-1)。输入数据保证N个字母分别至少出现一次。

上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解

## 输入输出格式

**输入格式：**

包含四行。第一行有一个正整数N(N<=26)，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。

**输出格式：**

包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。

## 输入输出样例

**输入样例#1：**

```
5
ABCED
BDACE
EBBAA
```

**输出样例#1：**
`1 0 3 4 2`
## 源代码

```cpp
#include<string>
#include<iostream>
#include<cstring>
using namespace std;
int n;
int res[26];//保存A.B..Z代表的数字
int used[26];//保存这个对应数字是否被用
string a,b,c;//保存加数1，加数2，和
int flag=0;
char pos[26];
int used_letter[26];//保存用过的字母

int Check()
{
    int i;

    for (i=n-1;i>=0;i--)//判断是否满足a+b=c
    {
        char a1=a[i]-'A',b1=b[i]-'A',c1=c[i]-'A';//取三个数第i位置值
        if(res[a1]!=-1 && res[b1]!=-1 && res[c1]!=-1)//3个数都知道
        {
            if( (res[a1]+res[b1])%n!=res[c1] && (res[a1]+res[b1]+1)%n!=res[c1])//无进位与有进位
                return 0;
        }

        if(res[a1]!=-1 && res[b1]!=-1 && res[c1]==-1)//知道2个数
        {
            int sum1,sum2;//sum1无进位，sum2有进位
            sum1=(res[a1]+res[b1])%n;
            sum2=(res[a1]+res[b1]+1)%n;
            if(used[sum1] && used[sum2])
                return 0;
        }
        if(res[a1]!=-1 && res[b1]==-1 && res[c1]!=-1)//知道和与一个加数
        {
            int js1,js2;//js1无进位，js2有进位
            js1=(res[c1]-res[a1]+n)%n;
            js2=(res[c1]-res[a1]-1+n)%n;
            if (used[js1] && used[js2])
                return 0;
        }
        if(res[a1]==-1 && res[b1]!=-1 && res[c1]!=-1)//知道和与另一个加数
        {
            int js1,js2;//js1无进位，js2有进位
            js1 = (res[c1]-res[b1]+n)%n;
            js2 = (res[c1]-res[b1]-1+n)%n;
            if (used[js1] && used[js2])
                return 0;
        }

    }
    return 1;
}

int OK()
{
    int i;
    int carry=0;//进位
    int sum;//和
    for (i=n-1; i>=0; i--)
    {
        char a1=a[i]-'A',b1=b[i]-'A',c1=c[i]-'A';

        sum = (res[a1]+res[b1]+carry)%n;//计算和
        carry =( res[a1]+res[b1]+carry)/n;//计算进位
        if (sum!=res[c1])
            return 0;
    }
    if (carry>0)
        return 0;
    return 1;
}
void dfs(int k)//深搜
{

    int i;
    if (flag)
        return;

    if (!Check())
        return;
    if(k==n)
    {
        if (OK())//如果当前所有字母填数满足等式则输出
        {
            for(i=0; i<=n-2; i++)
                cout<<res[i]<<' ';
            cout<<res[n-1]<<endl;
            flag=1;
        }
        return ;
    }

    for (i=n-1; i>=0; i--)
    {

        if (!used[i])//如果i还没被占用，且满足剪枝条件，则进行下层遍历
        {
            used[i]=1;
            res[pos[k]]=i;
            dfs(k+1);
            used[i]=0;
            res[pos[k]]=-1;
        }
    }
    return ;
}

int main()
{
    int k=0,i;

    cin>>n;
    cin>>a>>b>>c;

    memset(res,-1,sizeof(res));
    memset(pos,-1,sizeof(pos));

    for (i=n-1; i>=0; i--)//从右向左
    {
        char a1=a[i]-'A',b1=b[i]-'A',c1=c[i]-'A';//全部转成对应数字下标
        if (!used_letter[a1])//从上往下
        {
            used_letter[a1]=1;
            pos[k++] = a1;
        }
        if (!used_letter[b1])
        {
            used_letter[b1]=1;
            pos[k++] = b1;
        }
        if (!used_letter[c1])
        {
            used_letter[c1]=1;
            pos[k++] = c1;
        }
    }
    dfs(0);
    return 0;
}
```





