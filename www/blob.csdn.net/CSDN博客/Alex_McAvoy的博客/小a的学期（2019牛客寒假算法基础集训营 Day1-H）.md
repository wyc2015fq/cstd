# 小a的学期（2019牛客寒假算法基础集训营 Day1-H） - Alex_McAvoy的博客 - CSDN博客





2019年03月10日 18:40:52[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：24
个人分类：[牛客																[—————组合数学—————](https://blog.csdn.net/u011815404/article/category/7900800)](https://blog.csdn.net/u011815404/article/category/8639591)








> 
# 【题目描述】

小a是一个健忘的人，由于他经常忘记做作业，因此老师对他很恼火。

小a马上就要开学了，他学期一共2n天，对于第i天，他有可能写了作业，也可能没写作业，不过他自己心里还有点B数，因此他会写恰好n天的作业

现在，小a需要安排他的学期计划，如果小a的学期中存在一天x，在这之前的x天中，他没写作业的天数 - 写作业的天数⩾k，那么老师就会把它开除，我们称这是一种不合法的方案

小a想知道他有多少种合法的方案

# 【输入描述】

第一行三个整数n,k,p，p表示对p取模

# 【输出描述】

一个整数表示答案

# 【样例】

示例1

输入

2 1 100007

输出

2

说明

总共有2n=4天

合法的方案有

写了 没写 写了 没写

写了 写了 没写 没写

注意：没写 写了 没写 写了 是一种不合法的方案，因为在第一天时没写的天数-写了的天数⩾1

示例2

输入

10 5 10000007

输出

169252


思路：

将不写作业看做 +1，写作业看做 -1，那么问题实质就是，对于一个长度为 2n 的序列，有 n 个 +1 以及 n 个 -1，求不存在前缀>= k 的方案数，当 k=1 时，那么问题就是经典的卡特兰数

若数列不合法，则一定存在一个位置，在这之前有 m+k 个 +1，m 个 -1，然后将 +1、-1 相互交换，那么序列就有 n+k 个 +1，n-k 个 -1，于是一个不合法的方案就变为了一个唯一对应长度为 2n 且含有 n+k 个 +1 的序列，那么转换后的方案数为 C(n+k,2n)，那么结果就是用总的方案数减去转换的方案数，即：C(n,2n)-C(n+k,2n)

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1E9+7;
const int N=5000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

int cnt;
int prime[N];
bool isprime[N];
void getPrimes(){
    memset(isprime,false,sizeof(isprime));
    for(int i=2;i<N;i++){
        if(!isprime[i]){
            prime[cnt++]=i;
            for(int j=i+i;j<N;j+=i)
                isprime[j]=true;
        }
    }
}

LL dividePrime(LL n,LL p){
    LL res=0;
    while(n){
        res+=n/p;
        n/=p;
    }
    return res;
}

LL quickMod(LL a,LL b,LL m){
    LL res=1;
    a%=m;
    while(b){
        if(b&1)
            res=res*a%m;
        b>>=1;
        a=a*a%m;
    }
    return res;
}
LL getC(LL n,LL m,LL p){//C(n,m)%p
    LL res=1;
    for(int i=0;i<cnt&&prime[i]<=n;i++){
        LL x=dividePrime(n,prime[i]);
        LL y=dividePrime(n-m,prime[i]);
        LL z=dividePrime(m,prime[i]);

        x -= (y+z);

        res=res*quickMod(prime[i],x,p)%p;
    }
    return res;
}
int main(){
    LL n,m,p;
    scanf("%lld%lld%lld",&n,&m,&p);
    getPrimes();

    LL res1=getC(2*n,n,p);
    LL res2=0;
    if(m<=n)
        res2=getC(2*n,n+m,p);

    LL res=(((res1-res2)%p)+p)%p;
    printf("%lld\n",res);

    return 0;
}
```






