# 基础算法 —— 排序 —— 基数排序 - Alex_McAvoy的博客 - CSDN博客





2018年04月17日 22:09:01[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：81
个人分类：[基础算法——排序](https://blog.csdn.net/u011815404/article/category/7439201)









# 【分类】

 非比较类排序

# 【基本思想】

将阵列分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。

简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。

# 【特点】

 数据结构：数组

 稳定性：稳定

# 【过程】

例如要对大小为[1..1000]范围内的n个整数A[1..n]排序

首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储   (10..20]的整数，……集合B[i]存储(   (i-1)*10,   i*10]的整数，i   =   1,2,..100。总共有  100个桶。

然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。  再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任  何排序法都可以。

最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。

# 【源程序】

```cpp
/******************************************************** 
*函数名称：GetDigitInPos 
*参数说明：num 一个整形数据 
*        pos 表示要获得的整形的第pos位数据 
*说明：   找到num的从低到高的第pos位的数据 
*********************************************************/  
inline int GetDigitInPos(int num,int pos)  
{  
    int temp = 1;  
    for (int i = 0; i < pos - 1; i++)  
        temp *= 10;  
    return (num / temp) % 10;  
}

/******************************************************** 
*函数名称：RadixSort 
*参数说明：unorderArray无序数组； 
*        dataNum无序数据个数 
*说明：   基数排序 
*时间复杂度：O(dn),d无序数最大位数，n无序数个数
*********************************************************/  
#define RADIX 10    //整形排序,基数为10,需要十个桶  
#define KEYNUM 10   //关键字位数，这里为整形位数  
inline void RadixSort(int* unorderArray, int dataNum)  
{  
    int *radixArrays[RADIX];    //分别为0~9基数的存放空间  
    for (int i=0; i<10; i++)  
    {  
        radixArrays[i] = (int *)malloc(sizeof(int)*(dataNum + 1));  
        radixArrays[i][0] = 0;    //index为0处记录这组数据的个数  
    }  
    for (int pos=1; pos<=KEYNUM; pos++)   //从个位开始入桶并出桶
    {   
        for (int i=0; i<dataNum; i++)    //分配过程  
        {  
            int num = GetDigitInPos(unorderArray[i],pos);  
            int index = ++radixArrays[num][0];  
            radixArrays[num][index] = unorderArray[i];  
        }  
        for (int i=0, j=0; i<RADIX; i++)//收集  
        {  
            for (int k = 1; k <= radixArrays[i][0]; k++)  
                unorderArray[j++] = radixArrays[i][k];  
            radixArrays[i][0] = 0;    //出桶完毕，复位  
        }  
    }  
}
```





