# 基础算法 —— 高精度计算 —— 高精度除法 - Alex_McAvoy的博客 - CSDN博客





2018年04月14日 12:53:46[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：120








## 【高精除以低精】

**【算法分析】**

做除法时，每一次的商的值都在0~9，每次求得的余数连接以后的若干位得到新的被除数，继续做除法。因此在做高精度除法时，要涉及到乘法运算和减法运算以及移位处理。

为程序简洁，可以避免高精度乘法，用0~9次循环减法取代得到商的值，对于高精度数除以低精度数，我们采用按位相除法。

**【模版】**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
    char str[100];
    int a[100],b,c[100];
    int lena,lenc;
    int x=0;
    int i;

    memset(a,0,sizeof(a));
    memset(c,0,sizeof(c));

    cin>>str;
    cin>>b;
    
    lena=strlen(str);
    for(i=0;i<lena;i++)
        a[i+1]=str[i]-'0';

    for(i=1;i<=lena;i++)//按位相除
    {
        c[i]=(x*10+a[i])/b;
        x=(x*10+a[i])%b;
    }
    
    lenc=1;
    while(c[lenc]==0&&lenc<lena)//删除前导0
        lenc++;
        
    for(i=lenc;i<=lena;i++)//倒序输出
        cout<<c[i];
    cout<<endl;
    
    return 0;
}
```



## 【高精除以高精】





**【算法分析】**

高精除以低精是对被除数的每一位（包含前面的余数）都除以除数，而高精除以高精则是用减法模拟除法，对被除数的每一位都减去除数，一直减到当前位置的数字（包含前面的余数）小于除数，由于每一位数字小于10，所以对于每一位最多进行10次计算。

**【模版】**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[100],b[100],c[100];
int compare(int a[],int b[])//比较a、b，若a>b为1；若a<b为-1；若a=b为0
{
    int i;
    if(a[0]>b[0])
        return 1;
    if(a[0]<b[0])
        return -1;
    for(i=a[0];i>0;i--)//从高位到低位比较
    {
        if(a[i]>b[i])
            return 1;
        if(a[i]<b[i])
            return -1;
    }
    return 0;
}

void subduction(int a[],int b[])//计算a=a-b
{
    int flag;
    int i;

    flag=compare(a,b);
    if(flag==0)//相等
    {
        a[0]=0;
        return;
    }
    if(flag==1)//大于
    {
        for(i=1;i<=a[0];i++)
        {
            if(a[i]<b[i])//若不够向上借位
            {
                a[i+1]--;
                a[i]+=10;
            }
            a[i]-=b[i];
        }
        while(a[0]>0&&a[a[0]]==0)//删除前导0
            a[0]--;
        return;
    }
}
int main()
{
    char str1[100],str2[100];
    int i,j;

    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));

    cin>>str1>>str2;
    a[0]=strlen(str1);//a[0]存储串1的位数
    b[0]=strlen(str2);//b[0]存储串2的位数
    for(i=1;i<=a[0];i++)
        a[i]=str1[a[0]-i]-'0';
    for(i=1;i<=b[0];i++)
        b[i]=str2[b[0]-i]-'0';


    int temp[100];
    c[0]=a[0]-b[0]+1;
    for(i=c[0];i>0;i--)
    {
        memset(temp,0,sizeof(temp));

        for(j=1;j<=b[0];j++)//从i开始的地方，复制数组b到数组temp
            temp[j+i-1]=b[j];
        temp[0]=b[0]+i-1;

        while(compare(a,temp)>=0)//用减法模拟
        {
            c[i]++;
            subduction(a,temp);
        }
    }

    while(c[0]>0&&c[c[0]]==0)//删除前导0
        c[0]--;

    cout<<"商为：";
    if(c[0]==0)//输出结果
        cout<<0<<endl;
    else
    {
        for(i=c[0];i>0;i--)
            cout<<c[i];
        cout<<endl;
    }

    cout<<"余数为：";
    if(a[0]==0)//输出余数
        cout<<0<<endl;
    else
    {
        for(i=a[0];i>0;i--)
            cout<<a[i];
        cout<<endl;
    }

    return 0;
}
```





