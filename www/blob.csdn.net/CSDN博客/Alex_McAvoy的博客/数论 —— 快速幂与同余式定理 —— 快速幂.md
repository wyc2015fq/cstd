# 数论 —— 快速幂与同余式定理 —— 快速幂 - Alex_McAvoy的博客 - CSDN博客





2018年07月05日 01:33:28[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：186
个人分类：[数论——快速幂与同余式定理](https://blog.csdn.net/u011815404/article/category/8796909)









# 【概述】

快速幂就是快速算底数的n次幂。

时间复杂度为 O(log₂N)， 与朴素的 O(N) 相比效率有了极大的提高。

# 【原理】

以下以求 a 的 b 次方为例

将 b 转换成二进制数，该二进制数第 i 位的权为： ![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D26/sign=6044c668f703738dda4a0b24b21ba471/faf2b2119313b07e13c5e9c00dd7912396dd8cfa.jpg)

例如：![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D103/sign=885b42e39c16fdfadc6cc2ee878d8cea/d0c8a786c9177f3e48bd45c571cf3bc79e3d5668.jpg)

11 的二进制是 1011，即：11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1

因此，我们将计算 a¹¹ 转化为计算 ![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D95/sign=257afe75a8773912c0268964f919a226/e850352ac65c1038803a760ab3119313b17e89b6.jpg)

递归公式：

![x^y=\left\{\begin{matrix}1,y=0 \\ x*x^{y-1},y=2*n+1 \\ (x^2)^{y/2},y=2*n \end{matrix}\right.](https://private.codecogs.com/gif.latex?x%5Ey%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D1%2Cy%3D0%20%5C%5C%20x*x%5E%7By-1%7D%2Cy%3D2*n&plus;1%20%5C%5C%20%28x%5E2%29%5E%7By/2%7D%2Cy%3D2*n%20%5Cend%7Bmatrix%7D%5Cright.)

# 【实现】

快速幂可用位运算来实现，C++ 的实现为：

1）b & 1//取b二进制的最低位，判断和1是否相同，相同返回1，否则返回0，可用于判断奇偶

2）b>>1//把b的二进制右移一位，即去掉其二进制位的最低位

# 【求位数公式】

有时仅要求求 2 的 n 次幂的位数，这里有一个神奇的求位数公式：floor(log(2)/log(10)*n+1)

```cpp
double res=p*log10(2)+1;
cout<<int(res)<<endl;
```

# 【源代码】

1.常规求幂

```cpp
int pow(int a,int b)
{
   int r=1;
   while(b--) 
       r*=a;
   return r;
}
```

2.快速求幂（一般）

```cpp
int pow(int a,int b)
{
    int r=1,base=a;
    while(b!=0)
    {
        if(b%2)
            r*=base;
   	base*=base;
  	b/=2;
    }
    return r;
}
```

3.快速求幂（递归）

```cpp
int pow(int m,int n)
{
    if(n==1) 
        return m;
    int temp=f(m,n/2);
    return (n%2==0 ? 1 : m)*temp*temp;
}
```

4.快速求幂（一般位运算）

```cpp
int pow(int x,int n)
{
    if(n==0) 
        return 1;
    else
    {
    	while((n&1)==0)
        {
      	    n>>=1;
      	    x*=x;
    	}
     }
     int result=x;
     n>>=1;
     while(n!=0)
     {
    	x*=x;
    	if(n&1) 
            result*=x;
   	n>>=1;
     }
     return result;
}
```

5.快速求幂（更简洁的位运算）

```cpp
int pow(int a,int b)
{
    int r=1,base=a;
    while(b)
    {
    	if(b&1) 
            r*=base;
    	base*=base;
    	b>>=1;
    }
    return r;
}
```





