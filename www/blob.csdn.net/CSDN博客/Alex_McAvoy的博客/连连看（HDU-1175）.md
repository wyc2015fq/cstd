# 连连看（HDU-1175） - Alex_McAvoy的博客 - CSDN博客





2018年03月15日 21:45:03[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：99








# Problem Description

    “连连看”相信很多人都玩过。没玩过也没关系，下面我给大家介绍一下游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。不好意思，由于我以前没有玩过连连看，咨询了同学的意见，连线不能从外面绕过去的，但事实上这是错的。现在已经酿成大祸，就只能将错就错了，连线不能从外围绕过。

    玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。

# Input

    输入数据有多组。每组数据的第一行有两个正整数n,m(0<n<=1000,0<m<1000)，分别表示棋盘的行数与列数。在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0<q<50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。

    注意：询问之间无先后关系，都是针对当前状态的！

# Output

     每一组输入数据对应一行输出。如果能消去则输出"YES",不能则输出"NO"。

# Sample Input

**3 4**

**    1 2 3 4    0 0 0 0    4 3 2 1    4    1 1 3 4    1 1 2 4    1 1 3 3    2 1 2 4    3 4    0 1 4 3    0 2 4 1    0 0 0 0    2    1 1 2 4    1 3 2 3    0 0**

# Sample Output

**    YES    NO    NO    NO    NO    YES**

————————————————————————————————————————————

思路：

    一条路径最多只能转向2次，有一些情况可能得到了从起点到终点的路径，但是它的转向次数已经超过的2次，这样这条路径就不符合要求，得重新找一条。

    一个一般的结论：如果某一点记录的转向次数大于当前路径在该点的转向次数，那么还能从该点再发出一条路径来查找。

# Source Program

```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;

int n,m;
int map[1001][1001];
int v[1001][1001];
int x1,y1,x2,y2;
bool flag;
int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//方向数组
struct node
{
	int x;
	int y;
	int trun;
}start,endd;
 queue<node> q;

bool judge(int x0,int y0)
{
	if(x0<0||x0>=n||y0<0||y0>=m)
		return true;
	if(x0==x2-1&&y0==y2-1)
		return false;
	if(map[x0][y0]!=0)
		return true;
	return false;
}

void bfs(int x0,int y0)
{
	int i;

	while(!q.empty())//队列清零
        q.pop();

	start.x=x0;
	start.y=y0;
	start.trun=-1;
	v[x0][y0]=1;


	q.push(start);//元素入列

	while(!q.empty())
	{
		start=q.front();
		q.pop();//元素出列
		if(start.trun>=2)	continue;
		for(i=0;i<4;i++)
		{
			endd.x=start.x+dir[i][0];
			endd.y=start.y+dir[i][1];
			endd.trun=start.trun+1;

			if(judge(endd.x,endd.y))	continue;//越界判断

			while(judge(endd.x,endd.y)==0)
			{
				if(endd.x==x2-1&&endd.y==y2-1)
				{
					flag=true;
					return;
				}
				if(v[endd.x][endd.y]==0)
				{
					q.push(endd);//元素入列
					v[endd.x][endd.y]=1;
				}
				endd.x+=dir[i][0];
				endd.y+=dir[i][1];
			}
		}
	}
}

int main()
{
	int t;
	int i,j;

	while(scanf("%d%d",&n,&m)!=EOF)
	{
		if(n==0&&m==0)	break;

		for(i=0;i<n;i++)
            for(j=0;j<m;j++)
			    scanf("%d",&map[i][j]);

        scanf("%d",&t);

		for(i=0;i<t;i++)
        {
            flag=false;
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            if(x1==x2&&y1==y2)//起点终点相同，不行
            {
                printf("NO\n");
                continue;
            }
            if(map[x1-1][y1-1]!=map[x2-1][y2-1]||map[x1-1][y1-1]==0||map[x2-1][y2-1]==0)//起点或者终点为0，起点终点不同，不行
            {
                printf("NO\n");
                continue;
            }
			memset(v,0,sizeof(v));
			bfs(x1-1,y1-1);
			if(flag)
				printf("YES\n");
            else
				printf("NO\n");
		}
	}
	return 0;
}
```





