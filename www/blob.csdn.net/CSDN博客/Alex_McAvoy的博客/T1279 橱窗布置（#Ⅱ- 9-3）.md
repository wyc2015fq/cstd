# T1279 橱窗布置（#Ⅱ- 9 - 3） - Alex_McAvoy的博客 - CSDN博客





2018年06月05日 23:24:39[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：254








### 【题目描述】

假设以最美观的方式布置花店的橱窗，有F束花，每束花的品种都不一样，同时，至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，并从左到右，从1到V顺序编号，V是花瓶的数目，编号为1的花瓶在最左边，编号为V的花瓶在最右边，花束可以移动，并且每束花用1到F的整数惟一标识，标识花束的整数决定了花束在花瓶中列的顺序即如果i<j，则花束i必须放在花束j左边的花瓶中。

例如，假设杜鹃花的标识数为1，秋海棠的标识数为2，康乃馨的标识数为3，所有的花束在放人花瓶时必须保持其标识数的顺序，即：杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶中只能放一束花。



每一个花瓶的形状和颜色也不相同，因此，当各个花瓶中放人不同的花束时会产生不同的美学效果，并以美学值(一个整数)来表示，空置花瓶的美学值为0。在上述例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下表格表示。

    花瓶1    花瓶2    花瓶3    花瓶4    花瓶5

杜鹃花    7     23 -5     -24 16

秋海棠    5     21 -4     10 23

康乃馨    -21     5     -4         -20 20

根据表格，杜鹃花放在花瓶2中，会显得非常好看，但若放在花瓶4中则显得很难看。

假设条件:

    1≤F≤100，其中 F 为花束的数量，花束编号从 1 至 F 。

    F≤V≤100，其中 V 是花瓶的数量。

    −50≤Aij≤50，其中 Aij 是花束 i 在花瓶 j 中的美学值。

输入整数F，V和矩阵(Aij)，输出最大美学值和每束花摆放在各个花瓶中的花瓶编号。

### 【输入】

第一行包含两个数：F，V。

随后的F行中，每行包含V个整数，Aij 即为输入文件中第（i+1）行中的第j个数。

### 【输出】

第一行是程序所产生摆放方式的美学值。

第二行必须用F个数表示摆放方式，即该行的第K个数表示花束K所在的花瓶的编号。

### 【输入样例】

```
3 5 
7 23 –5 –24 16
5 21 -4 10 23
-21 5 -4 -20 20
```

### 【输出样例】

```
53 
2 4 5
```

### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 101
#define MOD 2520
#define E 1e-12
using namespace std;
int a[N][N],b[N][N],c[N][N],d[N];
int main()
{
    int f,v;
    cin>>f>>v;
    for(int i=1;i<=f;i++)
        for(int j=1;j<=v;j++)
            cin>>a[i][j];

    memset(b,128,sizeof(b));
    for(int i=1;i<=v-(f-1);i++)
        b[1][i]=a[1][i];
    for(int i=1;i<=f;i++)
        for(int j=i;j<=v-(f-i);j++)
            for(int k=i-1;k<=j-1;k++)
                if(b[i][j]<b[i-1][k]+a[i][j])
                {
                    b[i][j]=b[i-1][k]+a[i][j];
                    c[i][j]=k;
                }

    int maxx=-INF;
    int temp;
    for(int i=f;i<=v;i++)
        if(b[f][i]>maxx)
        {
            maxx=b[f][i];
            temp=i;
        }
    cout<<maxx<<endl;

    for(int i=f;i>=1;i--)
    {
        d[f-(i-1)]=temp;
        temp=c[i][temp];
    }

    for(int i=f;i>=1;i--)
        cout<<d[i]<<" ";
    return 0;
}
```





