# 基础算法 —— 排序 —— 冒泡排序 - Alex_McAvoy的博客 - CSDN博客





2018年02月07日 00:04:02[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：210








# 【分类】

 交换类排序

# 【基本思想】

 从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。

# 【特点】

 数据结构：数组

 稳定性：稳定

# 【过程】

初始关键字：  『 6，5，3，1，8，7，2，4 』

第一趟排序：  『**6**，**5**，3，1，8，7，2，4 』

5，『 **6**，**3**，1，8，7，2，4 』

5，3，『 **6**，**1**，8，7，2，4 』

5，3，1，『 **6**，**8**，7，2，4 』

5，3，1，6，『 **8**，**7**，2，4 』

5，3，1，6，7，『 **8**，**2**，4 』

5，3，1，6，7，2，『 **8**，**4**』

5，3，1，6，7，2，4，『 **8**』

第二趟排序：  『 **5**，**3**，1，6，7，2，4 』**，****8**

3，『**5**，**1**，6，7，2，4』**，****8**

3，1，**『****5**，**6**，7，2，4**』，8**

3，1，5，**『6**，**7**，2，4』**，****8**

3，1，5，6，**『****7**，**2，**4**』，8**

3，1，5，6，2，**『7**，**4』，8**

3，1，5，6，2，4，**『****7』，8**

第三趟排序：  『 **3**，**1**，5，6，2，4 』**，7**，**8**

1，**『3，5**，6，2，4』**，****7，8**

1，3，『**5**，**6**，2，4』**，****7，8**

1，3，5，『**6**，**2**，4』**，****7，8**

1，3，5，2，『**6**，**4**』**，****7，8**

1，3，5，2，4，『**6**』**，****7，8**

第四趟排序：  **『 1**，**3**，5，2，4 』**，****6，7，8**

1，『**3，5**，2，4**』，6，7，8**

1，3，**『****5，2，**4**』，6，7，8**

1，3，2，**『****5，4』，6，7，8**

1，3，2，4，**『****5』，6，7，8**

第五趟排序：  『 **1，3，**2，4 』**，****5，6，7，8**

1，『**3，2，**4**』，5，6，7，8**

1，2，**『****3，4』，5，6，7，8**

1，2，3，『**4』，5，6，7，8**

第六趟排序：  『 **1**，**2**，3 』**，4，5，6，7，8**

1，『**2，3』，4，5，6，7，8**

1，2，『**3』，4，5，6，7，8**

第七趟排序：  『 **1**，**2 **』**，3，4，5，6，7，8**

**『 1 』，2，3，4，5，6，7，8**

 结果：        **『  1，2，3，4，5，6，7，8  』**





![](https://img-blog.csdn.net/20180206185019099?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTgxNTQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20180206185046801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTgxNTQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   排序过程                                                       宏观过程

# 【复杂度与辅助空间】

 最差时间复杂度：O(n^2)

 最优时间复杂度：O(n)

 平均时间复杂度：O(n^2)

 所需辅助空间：O(1)

# 【实现方法】

 双重循环，外层i控制每轮进行多少次比较，内层循环j控制每轮i次比较相邻两元素是否逆序，若逆序，则进行交换。

 注：设有n个元素，则共进行n-1趟交换，设每趟趟数为i，则每趟比较n-i次。

# 【源程序】

```cpp
void bubble_sort()
{
    int i,j;
    bool flag;
    for (i = 0; i < n - 1; i++)//循环的次数为数组长度减一
    {
        flag = true;//判断是否有交换
        for (j = 0; j < n – 1 - i; j++)//循环次数为待排序数第一位数冒泡至最高位的比较次数
            if (a[j] > a[j + 1])//找出未排序序列中的最小值
            {
                swap(a[j],a[j + 1]);
                flag = false;//有交换说明仍需排序
            }
        if (flag)	break;//若无交换，终止循环
    }
}
```



