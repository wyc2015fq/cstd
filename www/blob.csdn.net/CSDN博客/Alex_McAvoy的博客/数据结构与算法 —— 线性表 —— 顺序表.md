# 数据结构与算法 —— 线性表 —— 顺序表 - Alex_McAvoy的博客 - CSDN博客





2019年03月09日 10:41:14[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：34
所属专栏：[数据结构与算法学习笔记](https://blog.csdn.net/column/details/34684.html)









# 【数据类型】

```cpp
const int maxSize=100;//存储空间初始分配量
template <class T>
class SeqList{
private:
    T data[maxSize];//存放数据元素的数组
    int length;//顺序表的长度
public:
    SeqList();//无参构造函数
    SeqList(T a[],int n);//有参构造函数
    ~SeqList(){};//析构函数空
    int getLength();//获取顺序表的长度
    T getElement(int i);//获取顺序表的第i个元素
    int getPosition(T x);//获取顺序表中值为x的元素序号
    void insertElement(int i,T x);//在顺序表中第i个位置插入值为x的元素
    T deleteElement(int i);//删除顺序表的第i的元素
    void print();//按序号依次输出顺序表各元素
};
```

# 【构造函数与析构函数】

## 1.无参构造函数与析构函数

无参构造函数创建一个空的顺序表，将表长置为 0，析构函数使用默认析构函数即可。

```cpp
template<class T> 
SeqList<T>::SeqList(){
    length=0;//长度为0
}
```

## 2.有参构造函数

有参构造函数将给定数组元素作为顺序表的数据元素，传入元素个数 n 作为顺序表长度。

```cpp
template<class T> 
SeqList<T>::SeqList(T a[], int n){
    if(n>maxSize) 
        throw "参数非法";
    for(int i=0;i<n;i++)//给定元素作为顺序表数据元素
        data[i]=a[i];
    length=n;//传入元素个数作为顺序表长度
}
```

# 【获取顺序表长度】

求顺序表的长度只需返回成员变量 length 的值

```cpp
template<class T>
SeqList<T>::getLength(){
    return length;
}
```

# 【查找元素】

## 1.按位查找

按位查找时，顺序表中第 i 个元素存储在数组中下标为 i-1 的位置，时间复杂度为 O(1)

```cpp
template<class T>
T SeqList<T>::getElement(int i){
    if(i<1&&i>length)
        throw "查找位置非法";
    else
        return data[i-1];
}
```

## 2.按值查找

按值查找时，需要对顺序表中元素依次进行比较，查找成功则返回元素的序号，查找失败则返回 0，时间复杂度为 O(n)

```cpp
template<class T>
int SeqList<T>::getPosition(T x){
    for(int i=0;i<length;i++)
        if(data[i]==x)
            return i+1;//返回元素序号
    return 0;//查找失败
}
```

# 【插入操作】

在顺序表中的第 i 个位置插入值元素，需要先将第 n 个元素到第 i 个元素后移 1 位，再将元素插入位置 i，使长度为 n 的顺序表变为 n+1，其时间复杂度为 O(n)

需要注意的是，在插入之前需要进行异常判断，如果表满，则引发上溢异常；如果插入位置不合理，则引发位置异常。

```cpp
template<class T>
void SeqList<T>::insertElement(int i,T x){
    if(length>=maxSize)
        throw "上溢";
    if(i<1||i>length+1)
        throw "位置异常";
    
    for(int j=length;j>=i;j--)//第n个到第i个元素依次后移
        data[j]=data[j-1];
    data[i-1]=x;//位置i插入元素
    length++;//长度+1
}
```

# 【删除操作】

在顺序表中的第 i 个元素删除，需要先取出被删除的元素，然后将第 i+1 个元素到第 n 个元素前移 1 位，最后将顺序表的长度变为 n-1，其时间复杂度为 O(n)

需要注意的是，在删除之前需要进行异常判断，如果表空，则引发下溢异常；如果删除位置不合理，则引发位置异常。

```cpp
T SeqList<T>::deleteElement(int i){
    if(length==maxSize)
        throw "下溢";
    if(i<1||i>length)
        throw "位置异常";

    T x=data[i-1];//取出删除元素
    for(int j=i;j<=length-1;j++)//第i个到第n个元素依次前移
        data[j]=data[j+1];
    length--;//长度-1
    return x;
}
```

# 7.遍历输出

遍历输出即按照下标依次输出各元素

```cpp
template<class T>
void SeqList<T>::print(){
    for(int i=0;i<length;i++)
        cout<<data[i]<<endl;
}
```



