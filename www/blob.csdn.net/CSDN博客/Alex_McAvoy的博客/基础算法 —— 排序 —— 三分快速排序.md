# 基础算法 —— 排序 —— 三分快速排序 - Alex_McAvoy的博客 - CSDN博客





2018年04月29日 14:34:30[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：387








# 【分类】

    交换类排序

# 【特点】

 数据结构：数组

 稳定性：不稳定

# 【算法原理】

    使用分治策略，用i，j，k将一个序列分为四个子序列。

    a[L, i-1]表示小于pivot的部分，a[i, k-1]表示等于pivot的部分，a[j+1]表示大于pivot的部分，而a[k, j]表示未判定的元素（即不知道比pivot大，还是比中轴元素小）。我们要注意a[i]始终位于等于pivot部分的第一个元素，a[i]的左边是小于pivot的部分。

![](https://img-blog.csdn.net/20180428205938229)

    我们选取最左边的元素作为中轴元素，初始化时，i = L，k = L+1，j=R（L表示最左边元素的索引，R表示最右边元素的索引）

![](https://img-blog.csdn.net/20180428210006495)

    通过上一段的表述可知，初始化时<pivot部分的元素个数为0，等于pivot部分元素的个数为1，大于pivot部分的元素个数为0，这显然符合目前我们对所掌握的情况。k自左向右扫描直到k与j错过为止（k > j）。我们扫描的目的就是逐个减少未知元素，并将每个元素按照和pivot的大小关系放到不同的区间上去。


    在k的扫描过程中我们可以对a[k]分为三种情况讨论
- a[k] < pivot 交换a[i]和a[k]，然后i和k都自增1，k继续扫描
- a[k] = pivot k自增1，k接着继续扫描
- a[k] > pivot 这个时候显然a[k]应该放到最右端，大于pivot的部分。但是我们不能直接将a[k]与a[j]交换，因为目前a[j]和pivot的关系未知，所以我们这个时候应该从j的位置自右向左扫描。而a[j]与pivot的关系可以继续分为三种情况讨论

       （1）a[j] > pivot j自减1，j接着继续扫描

       （2）a[j] == pivot 交换a[k]和a[j]，k自增1，j自减1，k继续扫描（注意此时j的扫描就结束了）

       （3）a[j] < pivot: 此时我们注意到a[j] < pivot, a[k] > pivot, a[i] == pivot，那么我们只需要将a[j]放到a[i]上，a[k]放到a[j]上，而a[i]放到a[k]上。然后i和k自增1，j自减1，k继续扫描（注意此时j的扫描就结束了）
![](https://img-blog.csdn.net/20180428210128567)

注意，当扫描结束时，i和j的表示了=等于pivot部分的起始位置和结束位置。我们只需要对小于pivot的部分以及大于pivot的部分重复上述操作即可。

# 【源程序】

```cpp
void QuickSort3Way(int[] A, int L, int R)
{
    if(L >= R)//递归终止条件，少于等于一个元素的数组已有序
        return;
     
    int i,j,k,pivot;
    pivot = A[L]; //首元素作为中轴
    i = L;
    k = L+1;
    j = R;
     
    OUT_LOOP:
    while(k <= j)
    {
        if(A[k] < pivot)
        {
            Swap(A, i, k);
            i++;
            k++;
        }
        else if(A[k] == pivot)
       		k++;
        else// 遇到A[k]>pivot的情况，j从右向左扫描
        {
            while(A[j] > pivot)//A[j]>pivot的情况,j继续向左扫描
            {
                j--;
                if(j < k)
                    break OUT_LOOP;
            }
            if(A[j] == pivot)//A[j]==pivot的情况
            {
                Swap(A, k, j);
                k++;
                j--;
            }
            else//A[j]<pivot的情况
            {
                Swap(A, i, j);
                Swap(A, j, k);
                i++;
                k++;
                j--;
            }
        }
    }
    //A[i, j] 等于 pivot 且位置固定，不需要参与排序
    QuickSort3Way(A, L, i-1); // 对小于pivot的部分进行递归
    QuickSort3Way(A, j+1, R); // 对大于pivot的部分进行递归
}
```





