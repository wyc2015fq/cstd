# 数字0-9的数量（51Nod-1042） - Alex_McAvoy的博客 - CSDN博客





2019年04月15日 21:27:23[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：10
个人分类：[51Nod																[动态规划——数位 DP](https://blog.csdn.net/u011815404/article/category/8008418)](https://blog.csdn.net/u011815404/article/category/8862267)








> 
# 题目

给出一段区间a-b，统计这个区间内0-9出现的次数。

比如 10-19，1出现11次（10,11,12,13,14,15,16,17,18,19,其中11包括2个1)，其余数字各出现1次。

# 输入

两个数a,b（1 <= a <= b <= 10^18)

# 输出

输出共10行，分别是0-9出现的次数

# 输入样例

**10 19**

# 输出样例

**11111111111**


思路：数位DP模版题，注意前导零的处理

# 源程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-12
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1000000007;
const int N=100000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

int a[30];
LL dp[30][30][30];
LL dfs(int pos,int sta,int lead,int limit,int number) {
    if(pos==-1)
        return sta;

    if(!limit&&!lead&&dp[pos][number][sta]!=-1)
        return dp[pos][number][sta];

    LL ans=0;
    int up=limit?a[pos]:9;
    for(int i=0; i<=up; i++) {
        if(lead==1&&i==0)
            ans+=dfs(pos-1,sta,lead,limit&&i==up,number);
        else
            ans+=dfs(pos-1,sta+(number==i),lead && i==0,limit&&i==up,number);
    }
    if(!limit&&!lead)
        dp[pos][number][sta]=ans;
    return ans;
}

LL solve(LL x,int number) {
    int pos=0;
    while(x) {
        a[pos++]=x%10;
        x/=10;
    }
    return dfs(pos-1,0,true,true,number);
}
int main(){

    LL n,m;
    scanf("%lld%lld",&n,&m);
    memset(dp,-1,sizeof(dp));
    for(int i=0; i<10; i++)
        printf("%lld\n",solve(m,i)-solve(n-1,i));

    return 0;
}
```






