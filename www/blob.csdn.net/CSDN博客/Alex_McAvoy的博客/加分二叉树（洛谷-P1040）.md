# 加分二叉树（洛谷-P1040） - Alex_McAvoy的博客 - CSDN博客





2018年04月18日 22:52:35[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：85








## 题目描述

设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：

subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。

若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；

（1）tree的最高加分

（2）tree的前序遍历

## 输入输出格式

**输入格式：**

第1行：一个整数n（n＜30），为节点个数。

第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。

**输出格式：**

第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。

第2行：n个用空格隔开的整数，为该树的前序遍历。

## 输入输出样例

**输入样例#1：**

```
5
5 7 1 2 10
```

**输出样例#1：**

```
145
3 1 2 4 5
```

## 源代码

```cpp
#include<iostream>
using namespace std;

int dp[35][35],pre[35][35];
void print(int l,int r);

int main()
{
    int n;
    int score[31];
    int len,i,j,k;
    int x;
    
    cin>>n;//输入节点数
    for(i=1;i<=n;i++)//输入节点分数
        cin>>score[i];
    
    for(i=1;i<=n;i++)
    {
        dp[i][i]=score[i];//存储子树的最大加分
        pre[i][i]=i;//存储根节点
    }
    
    for(len=1;len<=n;len++)//len:子树结点数
    {
        for(i=1;i+len<=n;i++)//子树最左端的结点 
        {
            j=len+i;//子树最右端的结点 
            x=score[j]+dp[i][j-1];//j加仅一棵子树的情况 
            dp[i][j]=score[i]+dp[i+1][j];//i加仅一棵子树的情况 
            pre[i][j]=i;
            if(dp[i][j]<x)
            {
                dp[i][j]=x;
                pre[i][j]=j;
            }
            for(k=i+1;k<j;k++)//两棵子树的情况,k:根节点 
            {
                x=score[k]+dp[i][k-1]*dp[k+1][j];
                if(dp[i][j]<x)
                {
                    dp[i][j]=x;
                	pre[i][j]=k;
                }
            } 
        }
    }
    
    cout<<dp[1][n]<<endl;//输出最高加分
    print(1,n);//输出前序
    return 0;
}

void print(int l,int r)
{
    if(l>r)
        return;
    cout<<pre[l][r]<<" ";//根结点输出
    if(l==r) 
        return;
    print(l,pre[l][r]-1);
    print(pre[l][r]+1,r);
}
```





