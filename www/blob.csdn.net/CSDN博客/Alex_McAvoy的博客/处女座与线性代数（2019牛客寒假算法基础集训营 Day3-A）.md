# 处女座与线性代数（2019牛客寒假算法基础集训营 Day3-A） - Alex_McAvoy的博客 - CSDN博客





2019年01月27日 15:44:27[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：65








> 
# 【题目描述】

众所周知，处女座是数学大师。他定义了k维空间里的处女座点。

对于给出的k维度空间上N个点，处女座点满足：对于这个点P和空间里任意其他两个点 P1、P2，有 dot(PP1,PP2)<0。

现在给你一个k维空间和这N个点，请求出这里面所有的处女座点。

Hint: 

dot(A,B)表示两个向量的点乘（内积）。两个向量 A={a1,a2,⋯,an}和B={b1,b2,⋯,bn}的点乘（内积）定义为：dot(A,B)=a1∗b1+a2∗b2+⋯+an∗bn。

# 【输入描述】

输入数据第一行包含一个整数T，表示用例组数。

对于每组用例，第一行两个整数 N,k。

接下来 N 行，每行k个整数，表示每个点的坐标。

# 【输出描述】

对于每一组数据，先输出一个整数ans，表示处女座点的个数。

接下来ans行，每行k个数，表示每个处女座点的坐标。

如果有多个点满足条件，则按照输入数据中出现的顺序进行输出。

# 【样例】

示例1

输入

1

3 2

0 0

1 1

-1 -1

输出

1

0 0


思路：

给定的点为 P1、P2、...、Pn，那么设处女座点存在并且 P1 为处女座点，那么对于其他点中的任意两点 Pi、Pj，根据题目要求有 ![dot(\overrightarrow{P_0P_i},\overrightarrow{P_0P_j})<0](https://private.codecogs.com/gif.latex?dot%28%5Coverrightarrow%7BP_0P_i%7D%2C%5Coverrightarrow%7BP_0P_j%7D%29%3C0)

因此有：![dot(\overrightarrow{P_0P_i},\overrightarrow{P_0P_j})=-dot(\overrightarrow{P_0P_i},\overrightarrow{P_iP_0}+\overrightarrow{P_0P_j})=-dot(\overrightarrow{P_0P_i},\overrightarrow{P_0P_j}-\overrightarrow{P_0P_i})=](https://private.codecogs.com/gif.latex?dot%28%5Coverrightarrow%7BP_0P_i%7D%2C%5Coverrightarrow%7BP_0P_j%7D%29%3D-dot%28%5Coverrightarrow%7BP_0P_i%7D%2C%5Coverrightarrow%7BP_iP_0%7D&plus;%5Coverrightarrow%7BP_0P_j%7D%29%3D-dot%28%5Coverrightarrow%7BP_0P_i%7D%2C%5Coverrightarrow%7BP_0P_j%7D-%5Coverrightarrow%7BP_0P_i%7D%29%3D)![|\overrightarrow{P_0P_i}|^2-dot(\overrightarrow{P_0P_i},\overrightarrow{P_0P_j})>0](https://private.codecogs.com/gif.latex?%7C%5Coverrightarrow%7BP_0P_i%7D%7C%5E2-dot%28%5Coverrightarrow%7BP_0P_i%7D%2C%5Coverrightarrow%7BP_0P_j%7D%29%3E0)

即 Pi 不是处女座点，Pj 也不是处女座点，由此可知，P2、P3、...、Pn 都不是处女座点，因此容易知道，处女座点最多有一个

根据处女座点的定义，可以用线性代数的方法来将其弱化为向量夹角为钝角或直角，容易证明 n<= 2k+1，即有：![n<=k+2<=2k+1](https://private.codecogs.com/gif.latex?n%3C%3Dk&plus;2%3C%3D2k&plus;1)

因此，若 n>k+2，则直接输出 0，否则进行暴力枚举进行判断即可

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define MOD 1000000007
#define INF 0x3f3f3f3f
#define N 10001
#define LL long long
using namespace std;
int n,k;
int a[N][11];
int dot(int p,int p1,int p2){
    int ans=0;
    for (int i=1;i<=k; ++i)
        ans+=(a[p1][i]-a[p][i]) * (a[p2][i]-a[p][i]);
    return ans;
}
int main()
{
    int T;
    scanf("%d", &T);
    while(T--){
        scanf("%d%d",&n,&k);

        for(int i=1;i<=n;i++)
            for (int j=1;j<=k;j++)
                scanf("%d",&a[i][j]);

        int res=-1;
        if( (k>1&&n<=2*k) || (k==1&&n<=3) ){
            for(int i=1;i<=n;i++){
                bool flag=true;
                for(int j=1;j<=n;j++){
                    for(int l=1;l<=n;l++){
                        if(i==j||i==l||j==l)
                            continue;
                        if(dot(i,j,l)>=0){
                            flag=false;
                            break;
                        }
                    }

                    if(!flag)
                        break;
                }

                if(flag){
                    res=i;
                    break;
                }
            }
        }

        if(res==-1)
            printf("0\n");
        else{
            printf("1\n");
            for(int i=1;i<=k;i++)
                printf("%d ",a[res][i]);
            printf("\n");
        }
    }
    return 0;
}
```





