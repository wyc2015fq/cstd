# Linux 进程概念 - Alex_McAvoy的博客 - CSDN博客





2018年07月15日 17:38:00[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：116








# 【基本概念】



1.程序（procedure）：是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。

2.进程（process）：是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。

3.线程（thread）：是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。



随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。

简而言之，程序是为了完成某种任务而设计的软件，而进程就是运行中的程序，一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

# 【并行性与并发性】



1.并行性（parallelism）：指在同一时刻或是同一时间间隔内完成两种或两种以上性质相同或不相同的工作，严格来讲，只要时间上互相重叠，就存在并行性。

2.同时性（smultaneity）：指两个或多个事件在同一时刻发生的并行性。

3.并发性（concurrency）：两个或多个事件在同一时间间隔内发生的并行性。

并行性是并发性的一个特例，并行的事件或活动一定是并发的，反之并发的事件或者活动未必就是并行的。

# 【进程的特性】

程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：

1.动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。

2.并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。

3.独立性：进程可以独立分配资源，独立接受调度，独立地运行。

4.异步性：进程以不可预知的速度向前推进。

5.结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。

# 【进程的分类】



进程可以从两个角度来分：以进程的功能与服务的对象来分；以应用程序的服务类型来分；

1）以进程的功能与服务的对象来分

① 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。

② 系统进程：通过执行系统内核程序而产生的进程，该类进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行，例如：可执行内存资源分配和进程切换等相对底层的工作。



2）以应用程序的服务类型来分

① 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。

② 批处理进程：是一个进程集合，负责按顺序启动其他的进程。

③ 守护进程：是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如：httpd 进程，一直处于运行状态，等待用户的访问；cron 进程，为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。

# 【进程的衍生】



## 1.概述



启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的。

我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程。

## 2.子进程的由来

关于父进程与子进程便会提及 fork() 与 exec() 这两个系统调用（system call）。

1）fork() 的作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如：进程的执行代码段，内存信息，文件描述，寄存器状态等。

2）exec() 的作用是切换子进程中的执行程序，也就是替换其从父进程复制过来的代码段与数据段。

子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，只有在执行 exec() 之后才会不同。

注：

① 早先的 fork() 比较消耗资源，后来进化成 vfork()，效率提高不少。



② 子进程产生的简单的实现逻辑

```
pid_t p;
p = fork();
if (p == (pid_t) -1)
        /* ERROR */
else if (p == 0)
        /* CHILD */
else
        /* PARENT */
```

3）子进程的退出与资源的回收

子进程是通过父进程而衍生出来的，当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n) 或 return n，这里的返回值 n 是一个信号，系统会把这个信号传给其父进程。

## 3.僵尸进程与孤儿进程

正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB。

由于 PCB 是进程存在的唯一标志，里面存储着进程的 PID 等消息，因此如若父进程没有释放子进程的 PCB ，那么子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。

简单来说，僵尸进程与孤儿进程就是：

1）僵尸进程：进程的进程控制块（PCB）仍驻留在内存中，进程还存在，没有消亡。



2）孤儿进程：父进程非正常的结束，未能及时收回子进程，子进程仍在运行。

僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。

但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。

在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。

## 4.init 进程

进程 0 是系统引导时创建（内核初始化）的一个特殊进程，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件，该子进程就是 PID=1 的进程 1（init 进程），而进程 0 就转为交换进程（空闲进程）。

进程 1 是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程，同时它是一个守护程序，直到计算机关机才会停止。

通过命令 **pstree** 可以看到如下结构

![](https://img-blog.csdn.net/20180715161759206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

通过上图，我们可以看出 init 进程为所有进程的祖先进程，跟容易看出所有进程的父子关系。

# 【进程组与会话】

## 1.进程组（process group）

每一个进程都是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者，也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

## 2.会话（Session）



会话是一到多个进程组的集合，其主要是针对一个虚拟控制台（tty）建立的，与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在会话中的一员，每一个进程组都会在一个会话中，并且这个会话是唯一存在的。

会话中的每个进程都称为一个工作（job），每个会话可以连接一个终端(control terminal)，当控制终端有输入输出时，都会传递给该会话的前台进程组。

会话意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号，而其他的工作在后台运行。

通过下图，可以更加直观的看出进程组与会话的联系

![](https://img-blog.csdn.net/20180715162856682?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**注：**

**1）前台（foreground）：在终端中运行，能与用户有交互的进程。**

**2）后台（background）：就是在终端中运行，但是用户并不能与其任何的交互，也不会显示其执行的过程。**

# 【工作管理】



1.说明：bash（Bourne-Again shell）支持工作控制（job control），而 sh（Bourne shell）并不支持，并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。

2.通过符号 & ，可以让命令在后台中运行

![](https://img-blog.csdn.net/20180715165748112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上图中所显示的 [1] 4813分别是该工作的工作号与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。

3.通过 ctrl + z 使当前工作停止放到后台

![](https://img-blog.csdn.net/20180715170927978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4.通过 jobs 命令可以查看放置在后台的工作

![](https://img-blog.csdn.net/20180715171027119?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



其中第一列显示的是被放置后台工作的编号；第二列的 ＋ 表示最近最后被放置后台的工作，同时也表示预设的工作（若是针对后台工作的操作，首先会针对预设的工作）， - 表示倒数第二被放置后台的工作，倒数第三个及以后都不会有这样的符号修饰；第三列表示它们的状态；最后一列表示该进程执行的命令。

5.通过 fg 命令将后台的工作拿到前台

1）命令格式：fg [%工作编号]



2）说明：fg后不加参数提取预设工作，加参数提取指定工作的编号。

3）实例：

![](https://img-blog.csdn.net/20180715171523880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180715171727958?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



6.通过命令 bg，让后台已停止的工作在后台中运行

1）命令格式：bg [%工作编号]

2）说明：bg 后不加参数提取预设工作，加参数提取指定工作的编号。

3）实例：

![](https://img-blog.csdn.net/20180715172735849?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

7.使用 kill 命令删除或重启后台工作

1）命令格式：**kill [-信号值] %工作号**

**注：**

**① 不加信号值时，默认为终止。**

**② 若是使用 kill＋信号值 + pid，将会对 pid 对应的进程进行操作；若是使用 kill + 信号值 + ％工作号，将会对后台工作队应的工作号进行操作。**

**③ kill 命令的信号值从 1-64，具体作用可以通过 kill -l 查看**

**![](https://img-blog.csdn.net/20180715173133151?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)**

2）常用信号值


|-1|重新读取参数运行|
|----|----|
|-2|如同 ctrl+c 的操作退出|
|-9|强制终止任务|
|-15|正常的方式终止任务|

3）实例

![](https://img-blog.csdn.net/20180715173502342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



