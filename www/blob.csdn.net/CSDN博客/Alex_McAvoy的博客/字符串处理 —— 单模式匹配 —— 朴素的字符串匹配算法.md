# 字符串处理 —— 单模式匹配 —— 朴素的字符串匹配算法 - Alex_McAvoy的博客 - CSDN博客





2019年02月25日 20:28:49[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：39
个人分类：[字符串处理——单模式匹配(KMP)](https://blog.csdn.net/u011815404/article/category/8698890)









# 【算法流程】

朴素的字符串匹配算法（Naive String Matching Algorithm）又称为暴力匹配算法，其本质是暴力枚举，主要特点有：
- 没有预处理阶段；
- 滑动窗口总是后移 1 位；
- 对模式中的字符的比较顺序不限定，可以从前到后，也可以从后到前；
- 匹配阶段需要 O((n - m + 1)m) 的时间复杂度；
- 需要 2n 次的字符比较；

很显然，朴素的字符串匹配算法是最原始的算法，它通过循环来检查在范围 n-m+1 中是否存在满足条件 P[1..m] = T [s + 1..s + m] 的有效位移 s。

![](https://img-blog.csdnimg.cn/20190225203128196.png)

在上图中，对于文本 T=acaabc 和模式 P=aab，将模式 P 沿着 T 从左到右滑动，逐个比较字符以判断模式 P 在文本 T 中是否存在，可以看出，该算法没有对模式 P 进行预处理，所以预处理的时间为 0，而匹配的时间复杂度在最坏情况下为 O((n-m+1)m)，如果 m=n/2，则时间复杂度为 O(n^2)。

# 【实现】

```cpp
char t[N];//文本
char p[N];//模式
int naiveStringMatcher() {
    int tLen=strlen(t);//文本串的长度
    int pLen=strlen(p);//模式串的长度
    int i=0;//主串的位置
    int j=0;//模式串的位置
    
    while(i<tLen&&j<pLen){
        if(t[i]==p[i]){//当两字符相同时，比较下一个
            i++;
            j++;
        }
        else{//当两字符串不同时
            i=i-j+1;//i从上一个开始匹配点向后一位
            j=0;//j归零
        }
    }
    if(j==pLen)//最终当模式串的位置与模式串的长度相同时，说明匹配成功
       return i-j;//返回匹配位置
    else//匹配失败
       return -1;//返回-1
}
```





