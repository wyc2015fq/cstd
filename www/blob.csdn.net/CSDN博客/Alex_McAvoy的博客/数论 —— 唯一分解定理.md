# 数论 —— 唯一分解定理 - Alex_McAvoy的博客 - CSDN博客





2019年03月20日 18:58:39[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：23








# 【内容】

任意正整数都有且只有一种方式写出其素因子的乘积表达式。

即：![A=(p_1^{k_1})*(p_2^{k_2})*...*(p_n^{k_n}),k_i \in Z](https://private.codecogs.com/gif.latex?A%3D%28p_1%5E%7Bk_1%7D%29*%28p_2%5E%7Bk_2%7D%29*...*%28p_n%5E%7Bk_n%7D%29%2Ck_i%20%5Cin%20Z)，其中，![P_i](https://private.codecogs.com/gif.latex?P_i) 均为素数

推论：约数和公式

对于已经分解的整数 ![A=(p_1^{k_1})*(p_2^{k_2})*...*(p_n^{k_n}),k_i \in Z](https://private.codecogs.com/gif.latex?A%3D%28p_1%5E%7Bk_1%7D%29*%28p_2%5E%7Bk_2%7D%29*...*%28p_n%5E%7Bk_n%7D%29%2Ck_i%20%5Cin%20Z)，其所有因子之和为：

![S=(1+p_1+p_1^{2}+p_1^{3}+...+p_n^{k_1})*](https://private.codecogs.com/gif.latex?S%3D%281&plus;p_1&plus;p_1%5E%7B2%7D&plus;p_1%5E%7B3%7D&plus;...&plus;p_n%5E%7Bk_1%7D%29*)![(1+p_2+p_2^{2}+p_2^{3}+...+p_n^{k_2})*...*](https://private.codecogs.com/gif.latex?%281&plus;p_2&plus;p_2%5E%7B2%7D&plus;p_2%5E%7B3%7D&plus;...&plus;p_n%5E%7Bk_2%7D%29*...*)![(1+p_n+p_n^{2}+p_n^{3}+...+p_n^{k_n}),k_i \in Z](https://private.codecogs.com/gif.latex?%281&plus;p_n&plus;p_n%5E%7B2%7D&plus;p_n%5E%7B3%7D&plus;...&plus;p_n%5E%7Bk_n%7D%29%2Ck_i%20%5Cin%20Z)

扩展：大整数分解：[点击这里](https://blog.csdn.net/u011815404/article/details/81335633)

实现：对于一个正整数 x，输出其素数乘积表达式，式中的素数从小到大排列，两个素数之间用 * 表示乘法

```cpp
int prime[N],cnt;
bool bprime[N];
void make_prime()
{
    memset(bprime,false,sizeof(bprime));

    for(int i=2;i<=N;i++)
    {
        if(!bprime[i])
        {
            prime[cnt++]=i;
            for(LL j=i*2;j<=N;j+=i)
                bprime[j]=true;
        }
    }
}
int calculate(int n)
{
    int res=1;
    for(int i=0;i<cnt&&prime[i]<=sqrt(n);i++)
    {
        int num=0;
        while(n%prime[i]==0){
            num++;
            n/=prime[i];
        }
        res*=num+1;
    }

    if(n!=1)//不为1时，考虑有序元组
        res=res*2;
    return res;//返回素因子个数
}
```

# 【推论】

对于一个正整数 n，若要求满足 n=a^p 这个式子最大的 p，其中 n 可能是负数，a、p 是整数

则可知：p = GCD(k1,k2,k3,...,kn)

比如：24 = 2^3*3^1，p 应该是 GCD(3, 1) = 1，即：24 = 24^1

          324 = 3^4*2^2，p应该是 GCD(4, 2) = 2，即：324 = 18^2

```cpp
int prime[N],cnt;
bool bprime[N];
void make_prime(){
    memset(bprime,false,sizeof(bprime));

    for(int i=2;i<=N;i++){
        if(!bprime[i]){
            prime[cnt++]=i;
            for(LL j=i*2;j<=N;j+=i)
                bprime[j]=true;
        }
    }
}
int GCD(int a, int b){
    return a % b == 0 ? b : GCD(b, a % b);
}

int main(){
    makePrime();
    int n;
    scanf("%d",&n);

    bool flag=false;
    if(n<0){//负数的情况
        n=-;
        flag=true;
    }

    int res=0;
    for(int i=0;i<cnt&&prime[i]<=n;i++){
        if(n%prime[i]==0){//枚举每一组的prime^k
            int k=0;
            while(n%prime[i]==0){
                k++;
                n/=prime[i];
            }
            //求p=GCD(k1,k2,...,kn)
            if(res==0)
                res=k;
            else
                res=GCD(res,k);
        }
    }
    
    if(n>1)//若质数除不尽
        res=GCD(res,1);
    
    if(flag){//负数时，幂不可能为偶数
        while(res%2==0)
            res/=2;
    }

    printf("%d\n",res);
    return 0;
}
```

# 【例题】
- Mysterious Bacteria（LightOJ-1220）**(唯一分解定理)：**[点击这里](https://blog.csdn.net/u011815404/article/details/86585438)
- Aladdin and the Flying Carpet（LightOJ-1341）**(唯一分解定理+枚举因子)：**[点击这里](https://blog.csdn.net/u011815404/article/details/88649866)
- 炫酷数字（2019牛客寒假算法基础集训营 Day5-G）**(唯一分解定理+构造)：**[点击这里](https://blog.csdn.net/u011815404/article/details/86775503)
- Sigma Function（LightOJ-1336）**(唯一分解定理+公式推导)：**[点击这里](https://blog.csdn.net/u011815404/article/details/88668179)
- Prime Test（POJ-1811）**(Pollard Rho 与 Miller Rabin 求大整数分解)：**[点击这里](https://blog.csdn.net/u011815404/article/details/81589714)



