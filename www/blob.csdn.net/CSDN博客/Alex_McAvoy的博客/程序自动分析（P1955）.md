# 程序自动分析（P1955） - Alex_McAvoy的博客 - CSDN博客





2019年03月06日 12:23:11[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：25








> 
## 题目描述

在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设x1,x2,x3...代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

## 输入输出格式

**输入格式：**

输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。

对于每个问题，包含若干行：

第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若�e=0，则该约束条件为xi≠xj；

**输出格式：**

输出文件包括t行。

输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。

## 输入输出样例

**输入样例#1：**

**221 2 11 2 021 2 12 1 1**

**输出样例#1：**

**NOYES**

**输入样例#2：**

**231 2 12 3 13 1 141 2 12 3 13 4 11 4 0**

**输出样例#2：**

**YESNO**


思路：

首先将所有的 e=1 的操作放在前面，当进行 e=1 的操作时，只要将他约束的两个变量放在同一个集合中即可，然后再进行 e=0 的操作，当 e=0 时，对于他约束的两个变量，如果在同一个集合中，就不可能满足，输出 NO，若不在同一个集合中，输出 YES

由于数据范围达到 1E9，直接开 1E9 的 father 数组是不现实的，因此需要进行离散化

## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=10007;
const int N=1000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
struct Node{
    int a,b;
    int op;//操作符
    bool operator < (const Node &rhs)const{//按操作排序
        return op>rhs.op;
    }
}a[N];
int father[N];
int Rank[N*2];
int Find(int x){
    if(x==father[x])
        return x;
    return father[x]=Find(father[x]);
}
void Union(int x,int y){
    x=Find(x);
    y=Find(y);
    if(x!=y)
        father[x]=y;
}
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        memset(Rank,0,sizeof(Rank));

        int n;
        scanf("%d",&n);

        int cnt=1;
        for(int i=1;i<=n;i++){
            scanf("%d%d%d",&a[i].a,&a[i].b,&a[i].op);
            Rank[cnt++]=a[i].a;
            Rank[cnt++]=a[i].b;
        }
        cnt--;

        //离散化
        sort(Rank+1,Rank+cnt+1);
        int len=unique(Rank+1,Rank+cnt+1)-Rank;
        for(int i=1;i<=n;i++){
            a[i].a=lower_bound(Rank,Rank+len,a[i].a)-Rank;
            a[i].b=lower_bound(Rank,Rank+len,a[i].b)-Rank;
        }

        for(int i=1;i<=len;i++)//初始化
            father[i]=i;
        sort(a+1,a+n+1);//按op排序

        bool flag=true;
        for(int i=1;i<=n;i++){
            int x=Find(a[i].a);
            int y=Find(a[i].b);
            if(a[i].op==1){//合并
                Union(x,y);
            }
            else{//查询
                if(x==y){
                    flag=false;
                    printf("NO\n");
                    break;
                }
            }
        }
        if(flag)
            printf("YES\n");
    }
    return 0;
}
```





