# 小a的排列（2019牛客寒假算法基础集训营 Day1-G） - Alex_McAvoy的博客 - CSDN博客





2019年03月10日 18:12:06[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：23
个人分类：[牛客																[基础算法——模拟](https://blog.csdn.net/u011815404/article/category/7812141)](https://blog.csdn.net/u011815404/article/category/8639591)








> 
# 【题目描述】

小a有一个长度为n的排列。定义一段区间是"萌"的，当且仅当把区间中各个数排序后相邻元素的差为1现在他想知道包含数x,y的长度最小的"萌"区间的左右端点

也就是说，我们需要找到长度最小的区间[l,r]，满足区间[l,r]是"萌"的，且同时包含数x和数y

如果有多个合法的区间，输出左端点最靠左的方案。

# 【输入描述】

第一行三个整数N,x,y，分别表示序列长度，询问的两个数

第二行有n个整数表示序列内的元素，保证输入为一个排列

# 【输出描述】

输出两个整数，表示长度最小"萌"区间的左右端点

# 【样例】

示例1

输入

5 2 3

5 2 1 3 4

输出

2 4

说明

区间[2,4]={2,1,3}包含了2,3且为“萌”区间，可以证明没有比这更优的方案

示例2

输入

8 3 5

6 7 1 8 5 2 4 3

输出

5 8


思路：

根据题意，选择排序后相邻的数相差为 1，那么可能的方案只有一种，且区间的长度为在区间内的** 最大值-最小值+1**

可以先找到含有 x、y 的区间，这个区间就是 x、y 的下标，此时找到的这个区间排序后不一定相邻差值为 1，因此当这个区间的长度与 最大值-最小值+1 不相等时，就找到这个区间的最值，然后根据最值去扩展区间，再重复判断长度与大小，直到满足条件为止

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1E9+7;
const int N=100000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
int a[N];
int pos[N];
int main(){
    int n,x,y;
    scanf("%d%d%d",&n,&x,&y);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        pos[a[i]]=i;//每个值的下标
    }

    int l=min(pos[x],pos[y]);//区间左端点
    int r=max(pos[x],pos[y]);//区间右端点

    int maxx=-INF,minn=INF;
    while(r-l!=maxx-minn){
        for(int i=l;i<=r;i++){//寻找区间最值
            maxx=max(maxx,a[i]);
            minn=min(minn,a[i]);
        }
        for(int i=minn;i<=maxx;i++){//扩展区间
            l=min(l,pos[i]);
            r=max(r,pos[i]);
        }
    }
    printf("%d %d\n",l,r);
    return 0;
}
```






