# T1261 城市交通路网（#Ⅱ- 9 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年05月31日 21:02:53[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：552








### 【题目描述】



下图表示城市之间的交通路网，线段上的数字表示费用，单向通行由A->E。试用动态规划的最优化原理求出A->E的最省费用。

![](http://ybt.ssoier.cn:8088/pic/1287.gif)

如图：求v1到v10的最短路径长度及最短路径。

### 【输入】



第一行为城市的数量N;

后面是N*N的表示两个城市间费用组成的矩阵。

### 【输出】

A->E的最省费用。

### 【输入样例】

```
10
0  2  5  1  0  0  0  0  0  0
0  0  0  0 12 14  0  0  0  0
0  0  0  0  6 10  4  0  0  0
0  0  0  0 13 12 11  0  0  0
0  0  0  0  0  0  0  3  9  0
0  0  0  0  0  0  0  6  5  0
0  0  0  0  0  0  0  0 10  0
0  0  0  0  0  0  0  0  0  5
0  0  0  0  0  0  0  0  0  2
0  0  0  0  0  0  0  0  0  0
```

### 【输出样例】

```
minlong=19
1 3 5 8 10
```

### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 101
#define MOD 2520
#define E 1e-12
using namespace std;
int a[N][N],f[N],c[N];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>a[i][j];

    memset(f,INF,sizeof(f));
    f[n]=0;

    for(int i=n-1;i>=1;i--)
        for(int j=i+1;j<=n;j++)
        if( a[i][j]>0 && f[j]!=INF && (f[i]>a[i][j]+f[j]) )
        {
            f[i]=a[i][j]+f[j];
            c[i]=j;
        }

    printf("minlong=%d\n",f[1]);
    int i=1;
    while(i!=0)
    {
        cout<<i<<" ";
        i=c[i];
    }
    cout<<endl;

    return 0;
}
```







