# 麦森数（洛谷-P1045） - Alex_McAvoy的博客 - CSDN博客





2018年08月16日 17:12:26[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：89








> 
## 题目描述

形如 2^{P}-1 的素数称为麦森数，这时 P 一定也是个素数。但反过来不一定，即如果 P 是个素数， 2^{P}-1 不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是 P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 P （ 1000<P<3100000 ），计算 2^{P}-1 的位数和最后500位数字（用十进制高精度数表示）

## 输入输出格式

**输入格式：**

文件中只包含一个整数 P （ 1000<P<3100000 ）

**输出格式：**

第一行：十进制高精度数 2^{P}-1 的位数。

第2-11行：十进制高精度数 2^{P}-1 的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）

不必验证 2^{P}-1 与 P 是否为素数。

## 输入输出样例

**输入样例#1：**

**1279**

**输出样例#1：**

**​38600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010407932194664399081925240327364085538615262247266704805319112350403608059673360298012239441732324184842421613954281007791383566248323464908139906605677320762924129509389220345773183349661583550472959420547689811211693677147548478866962501384438260291732348885311160828538416585028255604666224831890918801847068222203140521026698435488732958028878050869736186900714720710555703168729087**


思路：

一个快速幂+高精度的结合而已

唯一要了解的知识点就是求位数的公式：floor(log(2)/log(10)*n+1)

## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 50001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
int a[N],b[N];
int ans[N],base[N];
void muilt(int a1[],int b1[],int c[])
{
    for(int i=1;i<=5001;i++)
    {
        a[i]=a1[i];
        b[i]=b1[i];
    }
    for(int i=1;i<=5001;i++)
        c[i]=0;
    for(int i=1;i<=5001;i++)
    {
        for(int j=1;j<=500;j++)
        {
            c[i+j-1]+=a[i]*b[j];
            if(c[i+j-1]>9)
            {
                c[i+j]+=c[i+j-1]/10;
                c[i+j-1]%=10;
            }
        }
    }
}
void Quick_Pow(int p)
{
    ans[1]=1;
    base[1]=2;
    while(p!=0)
    {
        if(p&1!=0)
            muilt(ans,base,ans);
        muilt(base,base,base);
        p>>=1;
    }
}
int main()
{
    int p;
    cin>>p;

    /*求位数*/
    double digit=p*log10(2)+1;
    cout<<int(digit)<<endl;

    Quick_Pow(p);//求2的p次幂

    ans[1]--;
    for(int i=500;i>=1;i--)
    {
        if(i%50==0&&i!=500)
            cout<<endl;
        cout<<ans[i];
    }

    return 0;
}
```





