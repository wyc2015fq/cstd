# 畅通工程（HDU-1232） - Alex_McAvoy的博客 - CSDN博客





2018年05月18日 23:02:19[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：241








> 
# Problem Description

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？

# Input

测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。

注意:两个城市之间可以有多条道路相通,也就是说

    3 3

    1 2

    1 2

    2 1 

这种输入也是合法的

当N为0时，输入结束，该用例不被处理。

# Output

对每个测试用例，在1行里输出最少还需要建设的道路数目。

# Sample Input

**4 2**

**1 34 33 31 21 32 35 21 23 5999 00**

# Sample Output

**1**

**02998**


—————————————————————————————————————————

思路：并查集经典例题，套用模版即可。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define INF 999999999
#define N 1001
#define MOD 1000000007
#define E 1e-12
using namespace std;
int father[N];
int Find(int x)
{
    while(father[x]!=x)
        x=father[x];
    return x;
}
void Union(int x,int y)
{
    x=Find(x);
    y=Find(y);
    if(x!=y)
        father[x]=y;
}
int main()
{
    int n,m;
    int x,y;
    while(cin>>n>>m&&n)
    {
        for(int i=1;i<=n;i++)//结点初始化
            father[i]=i;
        while(m--)//合并每一条道路
        {
            cin>>x>>y;
            Union(x,y);
        }
        int cnt=-1;
        for(int i=1;i<=n;i++)//统计未连接的道路
            if(father[i]==i)
                cnt++;
        cout<<cnt<<endl;
    }
    return 0;
}
```



