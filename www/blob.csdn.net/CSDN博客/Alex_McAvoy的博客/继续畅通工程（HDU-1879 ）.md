# 继续畅通工程（HDU-1879 ） - Alex_McAvoy的博客 - CSDN博客





2018年05月19日 19:32:18[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：74








> 
# Problem Description

省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。

# Input

测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1< N < 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。

当N为0时输入结束。

# Output

每个测试用例的输出占一行，输出全省畅通需要的最低成本。

# Sample Input

**3**

**1 2 1 01 3 2 02 3 4 031 2 1 01 3 2 02 3 4 131 2 1 01 3 2 12 3 4 10 **

# Sample Output

**3**

**10**


思路：最小生成树kruskal算法实现即可，可把已联通的村庄边权设为0再求。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#define INF 999999999
#define N 101
#define MOD 1000000007
#define E 1e-12
using namespace std;
int father[N];
struct node
{
    int x;
    int y;
    int w;
}a[5000];
int Find(int x)
{
    if(x!=father[x])
        return father[x]=Find(father[x]);
    return x;
}
int cmp(const void *x,const void *y)
{
    return (*(struct node *)x).w-(*(struct node *)y).w;
}
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF&&n)
    {
        int edge=n*(n-1)/2;
        int num=0;

        for(int i=1;i<=n;i++)//初始化
            father[i]=i;

        int k=0;
        for(int i=1;i<=edge;i++)
        {
            int x,y,w,p;
            scanf("%d%d%d%d",&x,&y,&w,&p);
            if(p==1)
            {
                x=Find(x);
                y=Find(y);
                if(x!=y)
                {
                    father[x]=y;
                    k++;
                }
            }
            else
            {
                a[num].x=x;
                a[num].y=y;
                a[num].w=w;
                num++;
            }
        }
        qsort(a,num,sizeof(a[0]),cmp);

        int MST=0;
        for(int i=0;i<num;i++)
        {
            int x=Find(a[i].x);
            int y=Find(a[i].y);
            if(x!=y)
            {
                father[x]=y;
                MST+=a[i].w;
                k++;
            }
            if(k==n-1)
                break;
        }
        printf("%d\n",MST);
    }
    return 0;
}
```



