# 青蛙的约会（洛谷-P1516） - Alex_McAvoy的博客 - CSDN博客





2018年07月30日 20:13:03[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：95








> 
## 题目描述

两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 

我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 

## 输入输出格式

**输入格式：**

输入只包括一行5个整数x，y，m，n，L

其中0<x≠y < =2000000000，0 < m、n < =2000000000，0 < L < =2100000000。

**输出格式：**

输出碰面所需要的天数，如果永远不可能碰面则输出一行"Impossible"。

## 输入输出样例

**输入样例#1：**

**1 2 3 4 5**

**输出样例#1：**

**4**


思路：

根据题意，两只青蛙在一环形的路径跳跃，当两只青蛙跳到同一个点上才算遇到，即当两只青蛙的路程差等于环路周长的整数倍时才算相遇。

设：青蛙跳的次数是 t，A 青蛙与 B 青蛙的所跳的圈数差是 p

由题意：![(x+m*t)-(y+n*t)=p*L](https://private.codecogs.com/gif.latex?%28x&plus;m*t%29-%28y&plus;n*t%29%3Dp*L)

由于 x、y、m、n、L 均是已知量，因此方程可转为 ：![(n-m)*t+L*p=x-y](https://private.codecogs.com/gif.latex?%28n-m%29*t&plus;L*p%3Dx-y) 的形式

令：![a=n-m,b=L,d=x-y](https://private.codecogs.com/gif.latex?a%3Dn-m%2Cb%3DL%2Cd%3Dx-y)

则原方程有线性同余方程的形式：![a*t+b*p=d](https://private.codecogs.com/gif.latex?a*t&plus;b*p%3Dd) ①

根据线性同余方程定理1，要想使方程有整数解，需要满足：![d\:\, mod \:\,GCD(a,b)=0](https://private.codecogs.com/gif.latex?d%5C%3A%5C%2C%20mod%20%5C%3A%5C%2CGCD%28a%2Cb%29%3D0)

根据拓展欧几里德算法，求出一组解 ![(t_0,p_0)](https://private.codecogs.com/gif.latex?%28t_0%2Cp_0%29)，并令 ![c=GCD(a,b)](https://private.codecogs.com/gif.latex?c%3DGCD%28a%2Cb%29)

故有：![a*t_0+b*p_0=c](https://private.codecogs.com/gif.latex?a*t_0&plus;b*p_0%3Dc)  ②

方程 ② 两边同时乘以 ![d/c](https://private.codecogs.com/gif.latex?d/c) 得：![a*t_0*(d/c)+b*p_0*(d/c)=d](https://private.codecogs.com/gif.latex?a*t_0*%28d/c%29&plus;b*p_0*%28d/c%29%3Dd)

与 ① 式比较系数得 ![(t_0*d/c,p_0*d/c)](https://private.codecogs.com/gif.latex?%28t_0*d/c%2Cp_0*d/c%29) 是一组解

由于所得的一组解中的 ![t_0*d/c](https://private.codecogs.com/gif.latex?t_0*d/c) 不一定是最小正整数解，根据线性同余方程定理2

可得：![a*(t_0*(d/c)+(b*k))+b*(p_0*(d/c)-(a*k))=d,k\in Z](https://private.codecogs.com/gif.latex?a*%28t_0*%28d/c%29&plus;%28b*k%29%29&plus;b*%28p_0*%28d/c%29-%28a*k%29%29%3Dd%2Ck%5Cin%20Z)

故：![t_0*(d/c)+(b*k),k\in Z](https://private.codecogs.com/gif.latex?t_0*%28d/c%29&plus;%28b*k%29%2Ck%5Cin%20Z) 是 x 的所有解

为使 x 尽可能的小，对 b 进行处理，即令：![b'=b/c](https://private.codecogs.com/gif.latex?b%27%3Db/c)

因此，方程的最小正整数解为： ![x=(t_0*(d/c)\: mod\: b'+b') \: mod\: b'](https://private.codecogs.com/gif.latex?x%3D%28t_0*%28d/c%29%5C%3A%20mod%5C%3A%20b%27&plus;b%27%29%20%5C%3A%20mod%5C%3A%20b%27)

## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 100001
#define MOD 123
#define E 1e-6
using namespace std;
int Extended_GCD(long long a,long long b,long long &x,long long &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }

    int temp;
    int gcd=Extended_GCD(b,a%b,x,y);
    temp=x;
    x=y;
    y=temp-a/b*y;
    return gcd;
}
int main()
{
    long long x,y,m,n,l;
    cin>>x>>y>>m>>n>>l;

    long long t,p;
    long long a=x-y,b=n-m;
    if(b<0)
    {
        b=-b;
        a=-a;
    }
    int gcd=Extended_GCD(b,l,t,p);
    if(a%gcd)
        cout<<"Impossible"<<endl;
    else
    {
        cout<<((t*a/gcd)%(l/gcd)+(l/gcd))%(l/gcd)<<endl;
    }
	return 0;
}
```





