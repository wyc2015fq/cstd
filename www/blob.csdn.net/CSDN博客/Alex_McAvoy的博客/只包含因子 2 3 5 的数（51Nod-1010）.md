# 只包含因子 2 3 5 的数（51Nod-1010） - Alex_McAvoy的博客 - CSDN博客





2019年04月16日 22:17:03[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：5








> 
# 题目

K的因子中只包含2 3 5。满足条件的前10个数是：2,3,4,5,6,8,9,10,12,15。

所有这样的K组成了一个序列S，现在给出一个数n，求S中 >= 给定数的最小的数。

例如：n = 13，S中 >= 13的最小的数是15，所以输出15。

# 输入

第1行：一个数T，表示后面用作输入测试的数的数量。（1 <= T <= 10000)

第2 - T + 1行：每行1个数N(1 <= N <= 10^18)

# 输出

共T行，每行1个数，输出>= n的最小的只包含因子2 3 5的数。

# 输入样例

**518133577**

# 输出样例

**28153680**


思路：由于要求因子包含 2、3、5 的数，那么先将包含 2、3、5 因子的数打表，然后排序，最后二分查找满足条件的值即可

# 源程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define E 1e-9
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=7;
const int N=1000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
LL a[N];
int cnt;
void init(){
    cnt=0;
    for(LL i=1;i<1E18+N;i*=2)
        for(LL j=1;j*i<1E18+N;j*=3)
            for(LL k=1;i*j*k<1E18+N;k*=5)
                a[cnt++]=i*j*k;
    sort(a,a+cnt);
}
int main(){
    init();
    int t;
    scanf("%d",&t);
    while(t--){
        LL n;
        scanf("%lld",&n);
        int left=1,right=cnt;
        while(left<right){
            int mid=(left+right)>>1;
            if(a[mid]>=n)
                right=mid;
            else
                left=mid+1;
        }
        printf("%lld\n",a[left]);
    }
    return 0;
}
```





