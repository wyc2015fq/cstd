# 开关问题（POJ-1830） - Alex_McAvoy的博客 - CSDN博客





2019年03月29日 17:37:39[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：19
个人分类：[矩阵——高斯消元法																[POJ](https://blog.csdn.net/u011815404/article/category/7504500)](https://blog.csdn.net/u011815404/article/category/8807958)








> 
# Problem Description

有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）

# **Input**

输入第一行有一个数K，表示以下有K组测试数据。 

每组测试数据的格式如下： 

第一行 一个数N（0 < N < 29） 

第二行 N个0或者1的数，表示开始时N个开关状态。 

第三行 N个0或者1的数，表示操作结束后N个开关的状态。 

接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。 

# Output

如果有可行方法，输出总数，否则输出“Oh,it's impossible~!!” 不包括引号

# Sample Input

**230 0 01 1 11 21 32 12 33 13 20 030 0 01 0 11 22 10 0**

# Sample Output

**4Oh,it's impossible~!!**


思路：

根据题目可知是一个高斯消元求异或方程组的题，要求总共的方案数，那么也是要先求出自由元的个数 freeNum，由于每个自由元有 1、0 两种状态，那么最后结果就是 **1<<freeNum**

n 个灯泡，构造 n 个方程，根据给出的开始状态与结束状态可知，如果一个灯开始状态与结束状态不同，那么这个灯肯定是被按过，反之则没有被按过，那么每个方程的解 **a[i][n] 就是每个灯开始状态与结束状态的异或**

接着看左边的系数矩阵部分，对于每个开关来说，每次按开关，开关自身会发生变换，那么 **a[i][i]=1，即第 i 个开关受第 i 个开关影响**，然后再看给出两个关联的开关 t1、t2，由于关联的两个开关相互影响，按下 t1 之后 t2 随之改变，那么就有** a[t2][t1]=1，即第 t2 个开关受第 t1 个开关影响**

最后进行高斯消元，寻找自由元的个数然后计算 1<<freeNum 即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define E 1e-9
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=6;
const int N=1000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

int a[N][N];//增广矩阵
int x[N];//解集
int freeX[N];//自由变元
int Gauss(int equ,int var){//返回自由变元个数
    /*初始化*/
    for(int i=0;i<=var;i++){
        x[i]=0;
        freeX[i]=0;
    }

    /*转换为阶梯阵*/
    int col=0;//当前处理的列
    int num=0;//自由变元的序号
    int k;//当前处理的行
    for(k=0;k<equ&&col<var;k++,col++){//枚举当前处理的行
        int maxRow=k;//当前列绝对值最大的行
        for(int i=k+1;i<equ;i++){//寻找当前列绝对值最大的行
            if(abs(a[i][col])>abs(a[maxRow][col]))
                maxRow=i;
        }
        if(maxRow!=k){//与第k行交换
            for(int j=k;j<var+1;j++)
                swap(a[k][j],a[maxRow][j]);
        }
        if(a[k][col]==0){//col列第k行以下全是0，处理当前行的下一列
            freeX[num++]=col;//记录自由变元
            k--;
            continue;
        }

        for(int i=k+1;i<equ;i++){
            if(a[i][col]!=0){
                for(int j=col;j<var+1;j++){//对于下面出现该列中有1的行，需要把1消掉
                    a[i][j]^=a[k][j];
                }
            }
        }
    }

    /*求解*/
    //无解：化简的增广阵中存在(0,0,...,a)这样的行，且a!=0
    for(int i=k;i<equ;i++)
        if(a[i][col]!=0)
            return -1;
    return var-k;//自由变元有var-k个
}
int start[N];//开始状态
int endd[N];//结束状态
int main(){
    int t;
    scanf("%d",&t);

    while(t--){
        int n;
        scanf("%d",&n);

        for(int i=0;i<n;i++)//开始状态
            scanf("%d",&start[i]);
        for(int i=0;i<n;i++)//最终状态
            scanf("%d",&endd[i]);
            
        memset(a,0,sizeof(a));
        for(int i=0;i<n;i++)//每个方程的解
            a[i][n]=start[i]^endd[i];
        for(int i=0;i<n;i++)//第i个开关受第i个开关影响
            a[i][i]=1;

        int t1,t2;
        while(scanf("%d%d",&t1,&t2)!=EOF&&(t1+t2)){
            //a[t1-1][t2-1]=1;
            a[t2-1][t1-1]=1;
        }

        int freeNum=Gauss(n,n);
        if(freeNum==-1)
            printf("Oh,it's impossible~!!\n");
        else
            printf("%d\n",1<<freeNum);
    }
    return 0;
}
```






