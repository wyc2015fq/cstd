# 炫酷数字（2019牛客寒假算法基础集训营 Day5-G） - Alex_McAvoy的博客 - CSDN博客





2019年03月14日 19:38:25[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：72








> 
# 【题目描述】

小希希望你构造一个最小的正整数，使得其有n个因子。

# 【输入描述】

第一行一个整数T表示数据组数

每组数据第一行输入一个正整数n，表示其因子数。

n≤1,000,000

T≤1,000,000

# 【输出描述】

输出一行一个整数，表示你构造出的这个数。注意：你需要保证你构造的数≤1,000,000，如果在这个范围里面无法构造出一个正整数满足条件，请输出-1。

# 【样例】

示例1

输入

2

4

5

输出

6

16


思路：

根据唯一分解定理，一个数 n 可以写成 ![n=p_1^{a_1}p_2^{a_2}...*p_k^{a_k}](https://private.codecogs.com/gif.latex?n%3Dp_1%5E%7Ba_1%7Dp_2%5E%7Ba_2%7D...*p_k%5E%7Ba_k%7D)

则 n 的因子数为：![(a_1+1)(a_2+1)...(a_k+1)](https://private.codecogs.com/gif.latex?%28a_1&plus;1%29%28a_2&plus;1%29...%28a_k&plus;1%29)

因此直接打表因子数然后构造即可

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define INF 0x3f3f3f3f
#define N 1000001
#define LL long long
const int MOD=998244353;
const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1};
using namespace std;
int fact[N];
int minn[N];
int main(){
    memset(minn,0x3f,sizeof(minn));
    for(int i=1;i<=1000000;i++){
        for(int j=i;j<=1000000;j+=i){
            fact[j]++;
        }
        minn[fact[i]]=min(minn[fact[i]],i);
    }

    int t;
    scanf("%d",&t);
    while(t--){
        int n;
        scanf("%d",&n);
        if(minn[n]==INF)
            printf("-1\n");
        else
            printf("%d\n",minn[n]);
    }
    return 0;
}
```





