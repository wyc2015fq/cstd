# 数学 —— 组合数学 —— 排列 - Alex_McAvoy的博客 - CSDN博客





2018年08月02日 21:33:22[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：746








# 【概念】

从 n 个元素的集合 S 中，有序的选出 r 个元素，叫做 S 的一个 r 排列，不同的排列总数记作：![P_n^r](https://private.codecogs.com/gif.latex?P_n%5Er) 或 ![P(n,r)](https://private.codecogs.com/gif.latex?P%28n%2Cr%29)

如果两个排列所含元素不全相同，或所含元素相同但顺序不同，就会被认为是不同的排列。

# 【选排列与全排列】

## 1.选排列

从 n 个不同元素取出 r 个元素，按照一定顺序排成一列，当 r<n 时，叫做从 n 个不同元素取出 r 个不同元素的一种选排列。

使用乘法原理，可以推出选排列 ![P_n^r](https://private.codecogs.com/gif.latex?P_n%5Er) 的方案数：![P_n^r=n*(n-1)*(n-2)*...*(n-r+1)=n!/(n-r)!](https://private.codecogs.com/gif.latex?P_n%5Er%3Dn*%28n-1%29*%28n-2%29*...*%28n-r&plus;1%29%3Dn%21/%28n-r%29%21)

## 2.全排列

从 n 个不同元素取出 r 个元素，按照一定顺序排成一列，当 r=n 时，叫做 n 个不同元素的全排列。

全排列 ![P_n^n](https://private.codecogs.com/gif.latex?P_n%5En) 的方案数：![P_n^n=n!](https://private.codecogs.com/gif.latex?P_n%5En%3Dn%21)

C++ 中，头文件<algorithm> 里的 next_permutation() 函数，可产生字典序的全排列。

如下，给出从一组全排列的情况，使用 next_permutation() 函数可以生成下一种的全排列的情况，因此一般先使用 sort() 进行排序，即可生成所有全排列的情况。

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    while(scanf("%d",&n)&&n)
    {
        int a[1000];
        for(int i=0;i<n;i++)
            scanf("%d",&a[i]);
        
        sort(a,a+n);
        do{
            for(int i=0;i<n;i++)
                printf("%d ",a[i]);
            printf("\n");
        }while(next_permutation(a,a+n));
    }
    return 0;
}
```

## 3.例题

输入两个整数 n、r，输出 P(n,r) 的所有方案

```cpp
#include<cstdio>
#include<cstring>
#define N 21
int n,r;
int data[N];
int vis[N];
void Done(int i)
{
    if(i==r)//若相等，说明已经生成一个排列
    {
        for(int j=0;j<r-1;j++)//输出排列
            printf("%d",data[j]+1);
        printf("%d\n",data[r-1]+1);
        
        return;//回溯寻找下一种排列
    }

    for(int j=0;j<n;j++)
    {
        if(!vis[j])//若没有在该排列前面出现过
        {
            vis[j]=true;
            data[i]=j;//该位置上就选择j

            Done(i+1);

            vis[j]=false;
        }
    }
}
int main()
{
    memset(vis,false,sizeof(vis));
    scanf("%d%d",&n,&r);
    Done(0);
    return 0;
}
```

# 【相异元素的排列】

## 1.相异元素可重复排列

从 n 个不同元素可重复的取出 m 个元素，按照一定顺序排成一列，叫做相异元素可重复排列。

相异元素可重复排列的方案数为：![n^m](https://private.codecogs.com/gif.latex?n%5Em)

例如：从1、2、3、4、5 中任取三个出来组成一个三位数，有 P(5,3)=60 种情况，如果每个数字可以重复使用，则有：5^3=125 种情况

## 2.不全相异元素的选排列

若在 n 个元素中，有 ![n_1](https://private.codecogs.com/gif.latex?n_1) 个元素彼此相同，![n_2](https://private.codecogs.com/gif.latex?n_2) 个元素彼此相同，...，![n_m](https://private.codecogs.com/gif.latex?n_m) 个元素彼此相同，且 ![n_1+n_2+...+n_m=r](https://private.codecogs.com/gif.latex?n_1&plus;n_2&plus;...&plus;n_m%3Dr)，则这 n 个元素选出 r 个的选排列叫做不全相异元素的选排列。

其排列数计算公式为：![P(n,r)/(n_1!*n_2!*...*n_m!)](https://private.codecogs.com/gif.latex?P%28n%2Cr%29/%28n_1%21*n_2%21*...*n_m%21%29)

## 3.不全相异元素的全排列

若在 n 个元素中，有 ![n_1](https://private.codecogs.com/gif.latex?n_1) 个元素彼此相同，![n_2](https://private.codecogs.com/gif.latex?n_2) 个元素彼此相同，...，![n_m](https://private.codecogs.com/gif.latex?n_m) 个元素彼此相同，且 ![n_1+n_2+...+n_m=n](https://private.codecogs.com/gif.latex?n_1&plus;n_2&plus;...&plus;n_m%3Dn)，则这 n 个元素的全排列叫做不全相异元素的全排列。

其排列数计算公式为：![n!/(n_1!*n_2!*...*n_m!)](https://private.codecogs.com/gif.latex?n%21/%28n_1%21*n_2%21*...*n_m%21%29)

# 【错位排列】

设 ![(a_1,a_2,...,a_n)](https://private.codecogs.com/gif.latex?%28a_1%2Ca_2%2C...%2Ca_n%29)是 ![\{1,2,...,n\}](https://private.codecogs.com/gif.latex?%5C%7B1%2C2%2C...%2Cn%5C%7D) 的一个全排列，若对任意的 ![i \in \{1,2,...,n\}](https://private.codecogs.com/gif.latex?i%20%5Cin%20%5C%7B1%2C2%2C...%2Cn%5C%7D) 都有 ![a_i\neq i](https://private.codecogs.com/gif.latex?a_i%5Cneq%20i) ，则称 ![(a_1,a_2,...,a_n)](https://private.codecogs.com/gif.latex?%28a_1%2Ca_2%2C...%2Ca_n%29) 是 ![\{1,2,...,n\}](https://private.codecogs.com/gif.latex?%5C%7B1%2C2%2C...%2Cn%5C%7D) 的错位排列。

用 ![D_n](https://private.codecogs.com/gif.latex?D_n) 表示 ![\{1,2,...,n\}](https://private.codecogs.com/gif.latex?%5C%7B1%2C2%2C...%2Cn%5C%7D) 的错位排列的个数，有：![D_n=n!*(1-1/1!+1/2!-1/3!+...+(-1^n)/n!)](https://private.codecogs.com/gif.latex?D_n%3Dn%21*%281-1/1%21&plus;1/2%21-1/3%21&plus;...&plus;%28-1%5En%29/n%21%29)

**例题：**书架上有 6 本书，编号为 1-6 ，取出来再放回去，要求每本书都不在原来的位置上，有多少种放法？

**分析：**本题是要求 1-6 的错位排列，使用容斥原理有：

![D_6=6!*(1-1/1!+1/2!-1/3!+1/4!-1/5!+1/ 6!)=265](https://private.codecogs.com/gif.latex?D_6%3D6%21*%281-1/1%21&plus;1/2%21-1/3%21&plus;1/4%21-1/5%21&plus;1/%206%21%29%3D265)

# 【圆排列】

从 n  个不同元素中选取 r 个元素，不分首尾地围成一个圆圈的排列叫做圆排列，其排列方案数为：![P(n,r)/r](https://private.codecogs.com/gif.latex?P%28n%2Cr%29/r)

当 r=n 时，则为圆排列的全排列，其排列方案数为：![n!/n=(n-1)!](https://private.codecogs.com/gif.latex?n%21/n%3D%28n-1%29%21)

**例题：**有男女各 5 人，其中有 3 对夫妇，沿 10 个位置的圆桌就座，若每对夫妇都要坐在相邻的位置上，有多少中坐法？

**分析：**先让 3 对夫妇中的妻子和其他 4 人就坐，根据圆排列公式，共有 7!/7=6！种坐法，然后每位丈夫都可以做到自己的妻子左右两边，因此共有 6!*2*2*2=5760 种坐法。



