# 设计模式 —— 工厂方法（Factory Method） - Alex_McAvoy的博客 - CSDN博客





2019年04月13日 17:26:43[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：35
所属专栏：[设计模式学习笔记](https://blog.csdn.net/column/details/35125.html)









# 【概述】

工厂方法（Factory Method）是类的创建模式，其定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中，让子类决定实例化哪一个类，其本质是：**延迟到子类来选择实现**

在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做，核心类仅负责给出具体工厂必须实现的接口，而不接触哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。而工厂类与产品类往往具有平行的等级结构，它们之间一一对应。

# 【UML】

![](https://img-blog.csdnimg.cn/20190413212230721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

抽象工厂角色：Creator，工厂方法模式的核心，与应用程序无关，任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂角色：Concrete Creator，是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。

抽象产品角色：Product，工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品角色：Concrete Product，实现了抽象产品角色所定义的接口，某具体产品有专门的具体工厂创建，它们之间往往一一对应。 

工厂方法模式很好的体现了 “ 依赖倒置原则 ”，Concrete Creator 来说，它不关心具体的实现方式，只是 “ 面向接口编程 ” ，而对于具体的实现来说，它只关心自己 “ 如何实现接口 ” 所要求的功能。

# 【工厂方法与简单工厂模式的对比】

工厂方法模式是简单工厂模式的进一步抽象和推广，由于使用多态，工厂方法模式保持了简单工厂模式的优点，而且部分克服了它的缺点。

简单工厂模式把核心放在一个具体类上，在添加新产品对象后不得不修改工厂方法，扩展性不好。

工厂方法类的核心是一个抽象工厂类，其是具体工厂类共同的接口，在添加新产品对象后，原有工厂对象不需要进行任何修改，具有良好的扩展性，较好的符合了“开放－封闭”原则。 

但工厂方法是要创建产品对象的，也即需要选择具体的产品对象，并创建他们的实例，因此具体产品对象与工厂方法之间是耦合的。

# 【实例】

如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类中实现。或者一个类本身就希望由他的子类来创建所需的对象的时候，也应该使用工厂方法模式。

![](https://img-blog.csdnimg.cn/20190413213439242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

以上图为例，抽象工厂为 Creator 对应的抽象产品为 Light，抽象工厂下属的具体工厂有两个：BulbCreator、TubeCreator，对应的具体产品也有两个：BulbLight、TubeLight



