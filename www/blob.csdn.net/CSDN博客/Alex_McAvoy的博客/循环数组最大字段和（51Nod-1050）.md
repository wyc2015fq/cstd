# 循环数组最大字段和（51Nod-1050） - Alex_McAvoy的博客 - CSDN博客





2019年04月15日 21:48:14[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：28
个人分类：[51Nod																[STL 的使用——容器与迭代器](https://blog.csdn.net/u011815404/article/category/8793969)](https://blog.csdn.net/u011815404/article/category/8862267)








> 
# 题目

N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。

例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。

# 输入

第1行：整数序列的长度N（2 <= N <= 50000)

第2 - N+1行：N个整数 (-10^9 <= S[i] <= 10^9)

# 输出

输出循环数组的最大子段和。

# 输入样例

**6-211-413-5-2**

# 输出样例

**20**


思路：求前缀和后使用双端队列模拟即可

# 源程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-12
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1000000007;
const int N=100000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

deque<int> Q;
LL sum[N];
LL v[N];
int main() {
    int n;
    scanf("%d",&n);

    Q.clear();
    sum[0]=0;
    LL ans=-INF;
    Q.push_back(0);
    for(int i=1; i<=n; i++) {
        scanf("%lld",&v[i]);
        sum[i]=sum[i-1]+v[i];
    }
    for(int i=n+1; i<=2*n; i++) {
        sum[i]=sum[i-1]+v[i-n];
    }
    for(int i=1; i<=2*n; i++) {
        while(!Q.empty() && Q.front()<i-n)
            Q.pop_front();
        ans=max(ans,sum[i]-sum[Q.front()]);
        while(!Q.empty() && sum[Q.back()]>=sum[i])
            Q.pop_back();
        Q.push_back(i);
    }
    printf("%lld\n",ans);

    return 0;
}
```






