# 数据结构 —— 树状数组 - Alex_McAvoy的博客 - CSDN博客





2019年02月14日 15:45:21[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：51
个人分类：[—————数据结构—————																[数据结构——树状数组](https://blog.csdn.net/u011815404/article/category/8669172)](https://blog.csdn.net/u011815404/article/category/7605501)








# 【概述】

树状数组又称二叉索引树，常用于高效计算数列的前缀和、区间和，其查询、修改的时间复杂度为 log(n)，空间复杂度为 O(n)

树状数组通过将线性结构转化成树状结构，从而进行跳跃式扫描。

优点：
- 代码短小，实现简单
- 容易扩展到高纬度的数据

缺点：
- 只能用于求和，不能求最值
- 不能动态插入
- 数据多时，空间压力大

# 【原理】

1.对于一个普通的二叉树，叶子结点代表 A 数组的 A[1]~A[8]

![](https://img-blog.csdnimg.cn/20190214150630182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

2.将其进行简单的变形

![](https://img-blog.csdnimg.cn/20190214150717502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

3.然后定义每一列的顶端结点 C[] 数组，令 C[i] 代表**子树的叶结点的权值之和**

**![](https://img-blog.csdnimg.cn/20190214150828673.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)**

如上图，可知：
- C[1]=A[1]
- C[2]=A[1]+A[2]
- C[3]=A[3]
- C[4]=A[1]+A[2]+A[3]+A[4]
- C[5]=A[5]
- C[6]=A[5]+A[6]
- C[7]=A[7]
- C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]

4.将 C[] 数组的结点序号转化为二进制

![](https://img-blog.csdnimg.cn/20190214150949813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

如上图，有：
- 1=(001)，C[1]=A[1]
- 2=(010)，C[2]=A[1]+A[2]
- 3=(011)，C[3]=A[3]
- 4=(100)，C[4]=A[1]+A[2]+A[3]+A[4]
- 5=(101)，C[5]=A[5]
- 6=(110)，C[6]=A[5]+A[6]
- 7=(111)，C[7]=A[7]
- 8=(1000)，C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]

可以发现 ** C[i]=A[i-2^k+1]+A[i-2^k+2]+......A[i]**，其中，k 为 i 的二进制中从最低位到高位连续零的长度，例如：i=8 时，k=3

要注意的是，树状数组只能计算 A[1] 开始的和，A[0] 这个元素是不能用的

# 【具体实现】

## 1.lowbit(x)

lowbit(x) 就是取出 x 的最低位 1，换言之 lowbit(x)=2^k，k 为 i 的二进制中从最低位到高位连续零的长度

那么有：**C[i] = A[i-2^k+1]+A[i-2^k+2]+......A[i] = A[i-lowbit(i)+1]+A[i-lowbit(i)+2]+......A[i]**

对于一个数 x，想求其 lowbit，可借助 x 的负数 -x，进行与运算

例如：

t = 6(0110)，此时 k=1

-t = -6 = (1001+1) = (1010)

t&(-t) = (0010) = 2=2^1

```cpp
//返回i的二进制最右边1的值
int lowbit(int t){
    return t&(-t);
}
```

## 2.区间查询

利用 C[] 数组，求 A 数组中前 i 项的和 sum[i]
- 以 i=7 为例：sum[7] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]

	其中：C[4] = A[1]+A[2]+A[3]+A[4]，C[6] = A[5]+A[6]，C[7]=A[7]

	那么：sum[7] = C[4]+C[6]+C[7]

	改写为二进制：sum[(111)] = C[(100)]+C[(110)]+C[(111)]
- 以 i=5 为例：sum[5] = A[1]+A[2]+A[3]+A[4]+A[5]

	其中：C[4] = A[1]+A[2]+A[3]+A[4]，C[5]=A[5]

	那么：sum[5] = C[4]+C[5]

	改写为二进制：sum[(101)] = C[(100)]+C[(101)];

仔细观察最后改写为二进制的数组，可以发现，树状数组根本上来说就是二进制的应用。

对于要求的前 x 项的和，每次加上 C[x]，然后令 x=x-lowbit(x)，如此循环往复，直到 x-lowbit(x)=0 为止
- 以 i=7 进行演示

	7(111)，ans+=C[7]

	7-lowbit(7) = 7-lowbit(111) = 7-1 = 6(110)，ans+=C[6]

	6-lowbit(6) = 6-lowbit(110) = 6-2 = 4(100)，ans+=C[4]

	4-lowbit(4) = 4-lowbit(100) = 4-4 = 0(000) 

	故有：sum[7] = C[4]+C[6]+C[7]
- 以 i=5 进行演示

	5(101)，ans+=C[5]

	5-lowbit(5) = 5-lowbit(101) = 5-1 = 4(100)，ans+=C[4]

	4-lowbit(4) = 4-lowbit(100) = 4-4 = 0(000) 

	故有：sum[5]=C[5]+C[4]

```cpp
//返回A[1]+...A[i]的和
int getSum(int i){
    int res=0;
    while(i>0){
        res+=C[i];
        i-=lowbit(i);
    }
    return res;
}
```

## 3.单点更新

当修改 A[] 数组中的某一个值时，需要对 C[] 数组进行更新

![](https://img-blog.csdnimg.cn/20190214152627475.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

如图：

当更新 A[1] 时，需要向上更新 C[1]、C[2]、C[4]、C[8]， 将 C[1]、C[2]、C[4]、C[8] 改写为二进制：C[(001)]、C[(010)]、C[(100)]、C[(1000)]

则：

1(001)，C[1]+=A[1]

1+lowbit(1) = 1+lowbit(1) = 1+1 = 2(010)，C[2]+=A[1]

2+lowbit(2) = 2+lowbit(010) = 2+2 = 4(100)，C[4]+=A[1]

4+lowbit(4) = 4+lowbit(100) = 4+4 = 8(1000)，C[8]+=A[1]

可以发现：**更新过程是查询过程的逆过程。**

```cpp
//令A[i]+=val
void add(int i,int val){
    while(i<=n){
        C[i]+=val;
        i+=lowbit(i);
    }
}
```

# 【模版】

```cpp
const int N=10000+5;//最大元素个数
int n;//元素个数
int c[N];//c[i]==A[i]+A[i-1]+...+A[i-lowbit(i)+1]
 
//返回i的二进制最右边1的值
int lowbit(int i){
    return i&(-i);
}
 
//返回A[1]+...A[i]的和
int getSum(int i){
    int res=0;
    while(i>0){
        res+=c[i];
        i-=lowbit(i);
    }
    return res;
}
 
//令A[i]+=val
void add(int i,int val){
    while(i<=n){
        c[i]+=val;
        i+=lowbit(i);
    }
}
```

# 【例题】
- 




