# T1297 公共子序列（#Ⅱ- 9 - 3） - Alex_McAvoy的博客 - CSDN博客





2018年06月05日 23:25:57[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：290








### 【题目描述】

我们称序列Z=<z1,z2,...,zk>是序列X=<x1,x2,...,xm>的子序列当且仅当存在严格上升的序列<i1,i2,...,ik>，使得对j=1,2,...,k,有xij=zj。比如Z=<a,b,f,c> 是X=<a,b,c,f,b,c>的子序列。

现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。

### 【输入】

输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。

### 【输出】

对每组输入数据，输出一行，给出两个序列的最大公共子序列的长度。

### 【输入样例】

```
abcfbc abfcab
programming contest 
abcd mnp
```

### 【输出样例】

```
4
2
0
```

### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 501
#define MOD 2520
#define E 1e-12
using namespace std;
char a[N],b[N];
int f[N][N];
int main()
{
    while(scanf("%s%s",a+1,b+1)!=EOF)
    {
        int len_a=strlen(a+1);
        int len_b=strlen(b+1);

        for(int i=1;i<=len_a;i++)
            f[i][0]=0;
        for(int j=1;j<=len_b;j++)
            f[0][j]=0;

        for(int i=1;i<=len_a;i++)
            for(int j=1;j<=len_b;j++)
            {
                if(a[i]==b[j])
                    f[i][j]=f[i-1][j-1]+1;
                else
                    f[i][j]=max(f[i-1][j],f[i][j-1]);
            }

        cout<<f[len_a][len_b]<<endl;
    }
    return 0;
}
```





