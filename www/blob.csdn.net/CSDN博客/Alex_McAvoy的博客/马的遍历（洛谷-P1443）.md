# 马的遍历（洛谷-P1443） - Alex_McAvoy的博客 - CSDN博客





2018年05月14日 19:19:56[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：121








## 题目描述

有一个n*m的棋盘(1<n,m<=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步

## 输入输出格式

**输入格式：**

一行四个数据，棋盘的大小和马的坐标

**输出格式：**

一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）

## 输入输出样例

**输入样例#1：**
`3 3 1 1`
**输出样例#1：**

```
0    3    2    
3    -1   1    
2    1    4
```

## 源代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[401][401],judge[160801][2];
int main()
{
    int n,m,x,y;
    int direction_x[8]={2,-2,2,-2,-1,1,-1,1},direction_y[8]={1,1,-1,-1,2,2,-2,-2};//方向坐标
    int result_x,result_y;
    int p,q=2;
    int i,j;
    
    cin>>n>>m;//输入棋盘大小
    cin>>x>>y;//输入马的坐标
    
    for(i=1;i<=n;i++)//让初始值为-1 
        for(j=1;j<=m;j++)
            a[i][j]=-1;

    judge[1][0]=x;//设置判断数组的初始坐标x
    judge[1][1]=y;//设置判断数组的初始坐标y
    a[x][y]=0;
    
    while(p++<q-1)//头端加1并判断 
    for(i=0;i<8;i++)//判断坐标
    {
        result_x=judge[p][0]+direction_x[i];//求到达坐标x
        result_y=judge[p][1]+direction_y[i];//求到达坐标y 
        if(result_x>0&&result_x<=n&&result_y>0&&result_y<=m&&a[result_x][result_y]==-1)//判断到达坐标是否在范围内
        {
            judge[q][0]=result_x;
            judge[q++][1]=result_y;
            a[result_x][result_y]=a[judge[p][0]][judge[p][1]]+1;//添加到bfs数组尾端 
        }
    }
    
    for(i=1;i<=n;i++)//输出到达步数
    {
        for(j=1;j<=m;j++)
        	printf("%-5d",a[i][j]); 
        cout<<endl;
    }    
    return 0;
}
```





