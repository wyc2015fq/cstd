# 数学 —— 组合数学 —— 容斥原理 - Alex_McAvoy的博客 - CSDN博客





2018年08月13日 17:31:34[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：275








# 【概念】

在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。

**实质：求(a,b) 区间于 n 互质的数的个数**

# 【定义】

设 S 为有穷集，![p_1,p_2,..,p_n](https://private.codecogs.com/gif.latex?p_1%2Cp_2%2C..%2Cp_n) 是 n 条性质，S 中的任一元素 x 对这 n 条性质可能符合其中的 1 到 n 种，也可能都不符合。

设 ![A_i](https://private.codecogs.com/gif.latex?A_i) 表示 S 中具有 ![P_i](https://private.codecogs.com/gif.latex?P_i) 性质的元素构成的子集，有限集合 A 中的元素个数记为 |A|

则：

1）S 中不具有性质 ![p_1,p_2,..,p_n](https://private.codecogs.com/gif.latex?p_1%2Cp_2%2C..%2Cp_n) 的元素个数有：![|\overline{A_1}\bigcap\overline{A_2}\bigcap...\bigcap \overline{A_n}|](https://private.codecogs.com/gif.latex?%7C%5Coverline%7BA_1%7D%5Cbigcap%5Coverline%7BA_2%7D%5Cbigcap...%5Cbigcap%20%5Coverline%7BA_n%7D%7C) 个

即有：![S-\Sigma_i |A_i|+\Sigma_{i<j}|A_i\bigcap A_j|-\Sigma_{i<j<k}|A_i\bigcap A_j \bigcap A_k|+...+(-1)^n |\overline{A_1}\bigcap\overline{A_2}\bigcap...\bigcap \overline{A_n}|](https://private.codecogs.com/gif.latex?S-%5CSigma_i%20%7CA_i%7C&plus;%5CSigma_%7Bi%3Cj%7D%7CA_i%5Cbigcap%20A_j%7C-%5CSigma_%7Bi%3Cj%3Ck%7D%7CA_i%5Cbigcap%20A_j%20%5Cbigcap%20A_k%7C&plus;...&plus;%28-1%29%5En%20%7C%5Coverline%7BA_1%7D%5Cbigcap%5Coverline%7BA_2%7D%5Cbigcap...%5Cbigcap%20%5Coverline%7BA_n%7D%7C) 个

2）S 中具有性质 ![p_1,p_2,..,p_n](https://private.codecogs.com/gif.latex?p_1%2Cp_2%2C..%2Cp_n) 的元素个数有：![|A_1|+|A_2|+...|A_n|](https://private.codecogs.com/gif.latex?%7CA_1%7C&plus;%7CA_2%7C&plus;...%7CA_n%7C) 个

即有：![\Sigma_i |A_i|-\Sigma_{i<j}|A_i\bigcap A_j|+\Sigma_{i<j<k}|A_i\bigcap A_j \bigcap A_k|-...+(-1)^{n+1} |\overline{A_1}\bigcap\overline{A_2}\bigcap...\bigcap \overline{A_n}|](https://private.codecogs.com/gif.latex?%5CSigma_i%20%7CA_i%7C-%5CSigma_%7Bi%3Cj%7D%7CA_i%5Cbigcap%20A_j%7C&plus;%5CSigma_%7Bi%3Cj%3Ck%7D%7CA_i%5Cbigcap%20A_j%20%5Cbigcap%20A_k%7C-...&plus;%28-1%29%5E%7Bn&plus;1%7D%20%7C%5Coverline%7BA_1%7D%5Cbigcap%5Coverline%7BA_2%7D%5Cbigcap...%5Cbigcap%20%5Coverline%7BA_n%7D%7C)

# 【实例】

一个班级有50名学生，进行一次语数英考试，有9人语文满分，12人数学满分，14人英语满分，又知有6人语文、数学同时满分，3人语文、英语同时满分、8人英语、数学同时满分，还有2人三门课全部满分，求：没有一门课满分的有几人？至少一门课满分的有几人？

由题意知：![|S|=50,|A|=9,|B|=12,|C|=14](https://private.codecogs.com/gif.latex?%7CS%7C%3D50%2C%7CA%7C%3D9%2C%7CB%7C%3D12%2C%7CC%7C%3D14)，且：![|A\bigcap B|=6,|A\bigcap C|=3,|B\bigcap C|=8,|A\bigcap B \bigcap C|=2](https://private.codecogs.com/gif.latex?%7CA%5Cbigcap%20B%7C%3D6%2C%7CA%5Cbigcap%20C%7C%3D3%2C%7CB%5Cbigcap%20C%7C%3D8%2C%7CA%5Cbigcap%20B%20%5Cbigcap%20C%7C%3D2)

没有一门课满分的学生集合为：![\overline A \bigcap \overline B \bigcap \overline C](https://private.codecogs.com/gif.latex?%5Coverline%20A%20%5Cbigcap%20%5Coverline%20B%20%5Cbigcap%20%5Coverline%20C)，至少有一门课满分的学生集合为：![A \bigcup B \bigcup C](https://private.codecogs.com/gif.latex?A%20%5Cbigcup%20B%20%5Cbigcup%20C)

使用容斥原理：

![\overline A \bigcap \overline B \bigcap \overline C=](https://private.codecogs.com/gif.latex?%5Coverline%20A%20%5Cbigcap%20%5Coverline%20B%20%5Cbigcap%20%5Coverline%20C%3D)![|S|-(|A|+|B|+|C|)+](https://private.codecogs.com/gif.latex?%7CS%7C-%28%7CA%7C&plus;%7CB%7C&plus;%7CC%7C%29&plus;)![(|A \bigcap B|+|A \bigcap C|+|B \bigcap C|)](https://private.codecogs.com/gif.latex?%28%7CA%20%5Cbigcap%20B%7C&plus;%7CA%20%5Cbigcap%20C%7C&plus;%7CB%20%5Cbigcap%20C%7C%29)![-(|A \bigcap B \bigcap C|)](https://private.codecogs.com/gif.latex?-%28%7CA%20%5Cbigcap%20B%20%5Cbigcap%20C%7C%29)

![A \bigcup B \bigcup C=](https://private.codecogs.com/gif.latex?A%20%5Cbigcup%20B%20%5Cbigcup%20C%3D)![(|A|+|B|+|C|)-](https://private.codecogs.com/gif.latex?%28%7CA%7C&plus;%7CB%7C&plus;%7CC%7C%29-)![(|A \bigcap B|+|A \bigcap C|+|B \bigcap C|)](https://private.codecogs.com/gif.latex?%28%7CA%20%5Cbigcap%20B%7C&plus;%7CA%20%5Cbigcap%20C%7C&plus;%7CB%20%5Cbigcap%20C%7C%29)![+(|A \bigcap B \bigcap C|)](https://private.codecogs.com/gif.latex?&plus;%28%7CA%20%5Cbigcap%20B%20%5Cbigcap%20C%7C%29)

即：![\overline A \bigcap \overline B \bigcap \overline C=50-(9+12+14)+(6+3+8)-2=30](https://private.codecogs.com/gif.latex?%5Coverline%20A%20%5Cbigcap%20%5Coverline%20B%20%5Cbigcap%20%5Coverline%20C%3D50-%289&plus;12&plus;14%29&plus;%286&plus;3&plus;8%29-2%3D30)

![A \bigcup B \bigcup C=(9+12+14)-(6+3+8)+2=20](https://private.codecogs.com/gif.latex?A%20%5Cbigcup%20B%20%5Cbigcup%20C%3D%289&plus;12&plus;14%29-%286&plus;3&plus;8%29&plus;2%3D20)

# 【模板】

## 1.dfs 实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1000001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
int n;
double a[N];
double cnt;
void dfs(int x,int tot,double sum)
{
    if(x==n+1)
    {
        if(sum==0.0)
            return;
        if(tot&1)
            cnt+=1/sum;
        else
            cnt-=1/sum;
        return;
    }
    dfs(x+1,tot,sum);
    dfs(x+1,tot+1,sum+a[x]);
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=1;i<=n;i++)
            cin>>a[i];
 
        cnt=0;
        dfs(1,0,0.0);
 
        printf("%.4f\n",cnt);
    }
    return 0;
}
```

## 2.二进制实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1000001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
int prime[N];//存放素数
bool bprime[N];//标记素数
int num;//记录素数个数
vector<int> factor;//存放质因数
void Get_Prime(int n)//筛1到n的所有素数
{
    for(int i=2;i<=n;i++)
    {
        if(!bprime[i])
        {
            prime[num++]=i;
            for(int j=i*i;j<=n;j+=i)
                bprime[j]=true;
        }
    }
}
void Get_Factor(int n)//对n分解质因数
{
    factor.clear();
    for(int i=0;i<num;i++)
    {
        if(prime[i]*prime[i]>n)
            break;
 
        if(n%prime[i]==0)
        {
            factor.push_back(prime[i]);
            n/=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        factor.push_back(n);
}
int calculate(int r)//二进制实现容斥原理，求区间[1,r]内与n互素的数的个数
{
    int sum=0;
    for(int i=1;i<(i<<factor.size());i++)
    {
        int mult=1,bits=0;
        for(int j=0;j<factor.size();j++)
        {
            if(i&(1<<j))
            {
                bits++;//计算质因数个数
                mult*=factor[j];
            }
        }
 
        int cnt=r/mult;
        if(bits&1)//奇加偶减
            sum+=cnt;
        else
            sum-=cnt;
    }
}
 
int main()
{
    Get_Prime(N);
    int n,r;
    while(cin>>n>>r)
    {
        Get_Factor(n);
        cout<<calculate(r)<<endl;
    }
    return 0;
}
```

## 3.队列数组实现

```cpp
//求(a,b)区间于n互质的数的个数

#include<iostream>
#include<cstdio>
using namespace std;
int factor[N];
int q[N];
int num;
void Get_Factor(int n)//求一个数的质因子
{
    num=0;
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0)
        {
            factor[num++]=i;
            while(n%i==0)
                n=n/i;
        }
    }
    if(n>1)
        factor[num++]=n;
}
int Calculate(int m)//用队列数组实现容斥原理
{
    int cnt=0;
    int sum=0;

    q[cnt++]=-1;
    for(int i=0;i<num;i++)
    {
        int k=cnt;
        for(int j=0;j<k;j++)
           q[cnt++]=q[j]*factor[i]*(-1);
    }

    for(int i=1;i<cnt;i++)
        sum=sum+m/q[i];

    return sum;
}

int main()
{
    int t;
    while(scanf("%d",&t)!=EOF)
    {
        for(int i=1;i<=t;i++)
        {
            int a,b,n;
            cin>>a>>b>>n;

            Get_Factor(n);
            int sum=b-Calculate(b)-(a-1-Calculate(a-1));

            printf("Case #%d: %d\n",i,sum);
        }
    }
    return 0;
}
```





