# 正整数分组（51Nod-1007） - Alex_McAvoy的博客 - CSDN博客





2019年04月16日 22:26:21[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：3








> 
# 题目

将一堆正整数分为2组，要求2组的和相差最小。

例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。

# 输入

第1行：一个数N，N为正整数的数量。

第2 - N+1行，N个正整数。

(N <= 100, 所有正整数的和 <= 10000)

# 输出

输出这个最小差

# 输入样例

**512345**

# 输出样例

**1**


思路：

由于要分为两组使得两组和的差最小，那么首先可以求出所有数的和的一半，然后在这个基础上去做 01 背包

以和的一半为容量，每个数去选择或不选择，最后 dp[sumHalf] 就是一组的总和

那么另一组的和就是 sum-dp[sumHalf]，结果就是 (sum-dp[sumHalf])-dp[sumHalf]

# 源程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define E 1e-9
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=7;
const int N=1000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
int a[N];
int dp[N];
int main(){
    int n;
    scanf("%d",&n);
    int sum=0;
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
        sum+=a[i];
    }
    int sumHalf=sum/2;
    for(int i=0;i<n;i++)
        for(int j=sumHalf;j>=a[i];j--)
            dp[j]=max(dp[j],dp[j-a[i]]+a[i]);
    printf("%d\n",sum-dp[sumHalf]-dp[sumHalf]);

    return 0;
}
```





