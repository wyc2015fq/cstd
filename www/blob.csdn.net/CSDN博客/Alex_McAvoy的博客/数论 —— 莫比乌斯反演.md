# 数论 —— 莫比乌斯反演 - Alex_McAvoy的博客 - CSDN博客





2019年04月03日 16:17:53[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：144








# 【反演】

假设我们手头有个数列 F，通过某种变换 H，可以得到函数 G。，即：![F \diamond H->G](https://private.codecogs.com/gif.latex?F%20%5Cdiamond%20H-%3EG)

但现在只有函数 G，需要求 F，那么我们就需要寻找一种变换 ![H^{-1}](https://private.codecogs.com/gif.latex?H%5E%7B-1%7D)，使得 G 在经过这种变换后能够获得 F，这个过程即为反演，即：![G \diamond H^{-1}->F](https://private.codecogs.com/gif.latex?G%20%5Cdiamond%20H%5E%7B-1%7D-%3EF)

# 【整除分块】

对于式子：![\sum_{i=1}^n[\frac{n}{i}]](https://private.codecogs.com/gif.latex?%5Csum_%7Bi%3D1%7D%5En%5B%5Cfrac%7Bn%7D%7Bi%7D%5D)，其时间复杂度为 O(n)，当有多组数据时，O(n) 并非正确的时间复杂度，此时有一种时间复杂度为 O(√n) 的算法：整除分块

对于每一个 ![[\frac{n}{i}]](https://private.codecogs.com/gif.latex?%5B%5Cfrac%7Bn%7D%7Bi%7D%5D) 通过打表发现，很多 ![[\frac{n}{i}]](https://private.codecogs.com/gif.latex?%5B%5Cfrac%7Bn%7D%7Bi%7D%5D) 的值是相同的，它们呈一个块状分布，对每一个值相同的块，它的最后一个数是：![\begin{bmatrix}n \\- \\ [\frac{n}{i}] \end{bmatrix}](https://private.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7Dn%20%5C%5C-%20%5C%5C%20%5B%5Cfrac%7Bn%7D%7Bi%7D%5D%20%5Cend%7Bbmatrix%7D)

实现

```cpp
int left,right;
for(left=1;left<=n;left=right+1)
{
    right=n/(n/left);
    ans+=(righr-left+1)*(n/left);
}
```

# 【莫比乌斯函数】

## 1.定义

![\mu (d)\left\{\begin{matrix}1,\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:d=1\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\: \\ (-1)^k,d=\prod ^k_{i=1}p_i^{a_i},\prod_{i=1}^ka_i=1 \\ 0,\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:otherwise \:\:\:\:\:\:\:\:\:\:\:\: \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cmu%20%28d%29%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D1%2C%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3Ad%3D1%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%20%5C%5C%20%28-1%29%5Ek%2Cd%3D%5Cprod%20%5Ek_%7Bi%3D1%7Dp_i%5E%7Ba_i%7D%2C%5Cprod_%7Bi%3D1%7D%5Eka_i%3D1%20%5C%5C%200%2C%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3Aotherwise%20%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%5C%3A%20%5Cend%7Bmatrix%7D%5Cright.)

其中对于 ![\mu(d)=(-1)^k](https://private.codecogs.com/gif.latex?%5Cmu%28d%29%3D%28-1%29%5Ek) 的情况，![d=p_1*p_2*...*p_k](https://private.codecogs.com/gif.latex?d%3Dp_1*p_2*...*p_k)，且 ![p_1,p_2,...,p_k](https://private.codecogs.com/gif.latex?p_1%2Cp_2%2C...%2Cp_k) 均为互质素数

简单来说，其满足以下几点：
- 定义域：N
- 当 d 为 1 时：μ(1)=1
- 当 d 是偶数个不同素数之积时：μ(d)=1
- 当 d 是奇数个不同素数之积时：μ(d)=-1
- 当 d 是素数时：μ(d)=-1
- 当 d 存在平方因子时：μ(d)=0

## 2.性质
- 莫比乌斯函数 μ(d) 为积性函数：μ(d) 可以线性筛
- 对于任意正整数 n，有：![\sum_{d|n}\mu(d)=\left\{\begin{matrix}1,n=1 \\ 0,n>1 \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Csum_%7Bd%7Cn%7D%5Cmu%28d%29%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D1%2Cn%3D1%20%5C%5C%200%2Cn%3E1%20%5Cend%7Bmatrix%7D%5Cright.)，当且仅当 n=1 时计数的函数，可用于求 (i,j)=1 的问题
- 对于任意正整数 n，有：![\sum_{d|n}\frac{\mu(d)}{d}=\frac{\phi (n)}{n}](https://private.codecogs.com/gif.latex?%5Csum_%7Bd%7Cn%7D%5Cfrac%7B%5Cmu%28d%29%7D%7Bd%7D%3D%5Cfrac%7B%5Cphi%20%28n%29%7D%7Bn%7D)，其中 ![\phi (n)](https://private.codecogs.com/gif.latex?%5Cphi%20%28n%29) 为欧拉函数

## 3.实现

### 1）普通筛

```cpp
int mu[N];
void getMu(){
	for(int i=1;i<N;++i){
		int target=(i==1?1:0);
		int delta=target-mu[i];
		mu[i]=delta;
		for(int j=2*i;j<N;j+=i)
			mu[j]+=delta;
	}
}
```

### 2）线性筛

```cpp
int mu[N];
int prime[N];
bool bprime[N];
void getMu(int n){//线性筛求莫比乌斯函数

    mu[1]=1;//根据定义，μ(1)=1

    int cnt=0;
    memset(bprime,false,sizeof(bprime));
    for(int i=2;i<=n;i++){//求2~n的莫比乌斯函数
        if(!bprime[i]){
            prime[cnt++]=i;//存储质数
            mu[i]=-1;//i为质数时，μ(1)=-1
        }
        for(int j=0;j<cnt;j++){//枚举i之前的素数个数
            int k=i*prime[j];//素数的乘积
            if(k>n)//剪枝
                break;
            bprime[k]=true;//不是质数
            if(i%prime[j])//i不是primes[j]的整数倍时，i*primes[j]就不会包含相同质因子
                mu[k]=-mu[i];//mu[k]=mu[i]*mu[primes[j]]，因为primes[j]是质数，mu值为-1
            else{
                mu[k]=0;
                break;//留到后面再筛
            }
        }
    }
}
```

# 【莫比乌斯反演】

对于一些函数f(n)，很难直接求出其值，但容易求出约数和或倍数和g(n)，那么可以通过莫比乌斯反演来求得f(n)

莫比乌斯反演的题目通常能转化为(x,y)=1的计数问题，即用f(n)表示某一范围(x,y)=n的数对数量,g(n)表示某一范围内n|(x,y)的数对数量。

## 1.形式1

![f(n)](https://private.codecogs.com/gif.latex?f%28n%29) 和 ![g(n)](https://private.codecogs.com/gif.latex?g%28n%29) 是定义在非负整数集合上的两个函数，且满足条件：![f(n)=\sum_{d|n}g(d)](https://private.codecogs.com/gif.latex?f%28n%29%3D%5Csum_%7Bd%7Cn%7Dg%28d%29)

那么：![g(n)=\sum_{d|n}\mu(d) f(\frac{n}{d})=\sum_{n|d}\mu(\frac{d}{n}) f(d)](https://private.codecogs.com/gif.latex?g%28n%29%3D%5Csum_%7Bd%7Cn%7D%5Cmu%28d%29%20f%28%5Cfrac%7Bn%7D%7Bd%7D%29%3D%5Csum_%7Bn%7Cd%7D%5Cmu%28%5Cfrac%7Bd%7D%7Bn%7D%29%20f%28d%29)

## 2.形式2

![f(n)](https://private.codecogs.com/gif.latex?f%28n%29) 和 ![g(n)](https://private.codecogs.com/gif.latex?g%28n%29) 是定义在非负整数集合上的两个函数，且满足条件：![f(n)=\sum_{d=1}^{[\frac{n}{i}]}g(i*d)](https://private.codecogs.com/gif.latex?f%28n%29%3D%5Csum_%7Bd%3D1%7D%5E%7B%5B%5Cfrac%7Bn%7D%7Bi%7D%5D%7Dg%28i*d%29)

那么：![g(i)=\sum_{d=1}^{[\frac{n}{i}]}f(i*d)\mu (d)](https://private.codecogs.com/gif.latex?g%28i%29%3D%5Csum_%7Bd%3D1%7D%5E%7B%5B%5Cfrac%7Bn%7D%7Bi%7D%5D%7Df%28i*d%29%5Cmu%20%28d%29)

# 【例题】
- 约数研究（洛谷P1403）**(整除分块)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81745814)
- GCD（HDU-1695）**(约数和个数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81610973)
- Problem b（BZOJ-2301/HAOI-2011）**(约数和个数+容斥)**：[点击这里](https://blog.csdn.net/u011815404/article/details/89002186)
- YY的GCD（洛谷-P2257）**(质数的二维GCD计数前缀和)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81432265)



