# 动态规划 —— 背包问题 —— 背包问题模版 - Alex_McAvoy的博客 - CSDN博客





2018年06月03日 00:20:52[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：120








### 【0-1背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N;
int w[MAX],c[MAX],f[MAX];
void ZeroOnePack(int cost,int weight)
{
    for(int v=V;v>=weight;v--)
        f[v]=max(f[v],f[v-weight]+cost);
}

int main()
{
    cin>>V>>N;
    for(int i=1;i<=N;i++)
        cin>>w[i]>>c[i];
    for(int i=1;i<=N;i++)
        ZeroOnePack(c[i],w[i]);
    cout<<f[V]<<endl;
    return 0;
}
```

### 【完全背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N;
int w[MAX],c[MAX],f[MAX];
void CompletePack(int cost,int weight)
{
    for(int v=weight;v<=V;v++)
        f[v]=max(f[v],f[v-weight]+cost);
}

int main()
{
    cin>>V>>N;
    for(int i=1;i<=N;i++)
        cin>>w[i]>>c[i];
    for(int i=1;i<=N;i++)
        CompletePack(c[i],w[i]);
    cout<<f[V]<<endl;
    return 0;
}
```

### 【多重背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N;
int w[MAX],c[MAX],num[MAX],f[MAX];
void MultiplePack(int cost,int weight,int num)
{
    for(int j=V;j>=0;j--)
        for(int k=0;k<=num;k++)
            if(j-k*weight>=0)
                f[j]=max(f[j],f[j-k*weight]+k*cost);
}
int main()
{
    cin>>N>>V;
    for(int i=1;i<=N;i++)
        cin>>w[i]>>c[i]>>num[i];
    for(int i=1;i<=N;i++)
        MultiplePack(c[i],w[i],num[i]);
    cout<<f[V]<<endl;
    return 0;
}
```

### 【混合背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N;
int w[MAX],c[MAX],num[MAX],f[MAX];
void ZeroOnePack(int cost,int weight)
{
    for(int v=V;v>=weight;v--)
        f[v]=max(f[v],f[v-weight]+cost);
}
void CompletePack(int cost,int weight)
{
    for(int v=weight;v<=V;v++)
        f[v]=max(f[v],f[v-weight]+cost);
}
void MultiplePack(int cost,int weight,int num)
{
    for(int j=V;j>=0;j--)
        for(int k=0;k<=num;k++)
            if(j-k*weight>=0)
                f[j]=max(f[j],f[j-k*weight]+k*cost);
}
int main()
{
    cin>>V>>N;
    for(int i=1;i<=N;i++)//num[i]是物品个数，为0时代表可取无限次
        cin>>w[i]>>c[i]>>num[i];

    for(int i=1;i<=N;i++)
    {
        if(num[i]==1)//0-1背包
            ZeroOnePack(c[i],w[i]);
        else if(num[i]==0)//完全背包
            CompletePack(c[i],w[i]);
        else//多重背包
            MultiplePack(c[i],w[i],num[i]);
    }
    cout<<f[V]<<endl;
    return 0;
}
```

### 【二维背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,U,N;
int v[MAX],u[MAX],c[MAX],f[MAX][MAX];
void TwoDimensionPack(int weight_1,int weight_2,int cost)
{
    for(int j=V;j>=weight_1;j--)  
            for(int k=U;k>=weight_2;k--)   
                f[j][k]=max(f[j][k],f[j-weight_1][k-weight_2]+cost); 
}
int main()
{
    cin>>V>>U>>N;
    for(int i=1;i<=N;i++)
        cin>>v[i]>>u[i]>>c[i];

    for(int i=0;i<=V;i++)//边界设定
      for(int j=0;j<=U;j++)  
          f[i][j]=0;   

    for(int i=1;i<=N;i++)
        TwoDimensionPack(v[i],u[i],c[i]);
        
    cout<<f[V][U]<<endl;
    return 0;
}
```

### 【分组背包】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N,T;
int group[MAX][MAX],w[MAX],c[MAX],f[MAX];
void GroupPack(int group_number,int num)
{
    for(int j=v;j>=0;j--)
        for(int k=1;k<=group_number;k++)
        {
            int q=group[num][k];//物品序号
            if(j>=w[q])
                f[j]=max(f[j],f[j-w[q]]+c[q]);
        }
}
int main()
{
    cin>>V>>N>>T;//T代表物品组数
    for(int i=1;i<=n;i++)
    {
        int p;
        cin>>w[i]>>c[i]>>p;//p代表物品属于哪一组
        group[p][++group[p][0]]=i;//group[p][0]代表第p组可存储的元素个数
    }

    for(int i=1;i<=t;i++)
        GroupPack(group[i][0],i);//第i组存储的元素个数与组号
    cout<<f[V]<<endl;
    return 0;
}
```

### 【求背包问题方案总数】

```cpp
#include<iostream>
#define MAX 101
using namespace std;
int V,N;
int w[MAX];
long long f[MAX];
int main()
{
    cin>>N>>V;
    f[0]=1;
    for(int i=1;i<=N;i++)
        cin>>w[i];
    for(int i=1;i<=N;i++)
        for(int j=w[i];j<=V;j++)
            f[j]+=f[j-w[i]];
    cout<<f[V]<<endl;
    return 0;
}
```





