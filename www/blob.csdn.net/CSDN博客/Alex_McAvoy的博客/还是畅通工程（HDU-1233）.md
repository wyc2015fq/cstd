# 还是畅通工程（HDU-1233） - Alex_McAvoy的博客 - CSDN博客





2018年05月19日 14:22:00[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：67








> 
# Problem Description

某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。

# Input

测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( < 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。

当N为0时，输入结束，该用例不被处理。

# Output

对每个测试用例，在1行里输出最小的公路总长度。

# Sample Input

**3**

**1 2 11 3 22 3 441 2 11 3 41 4 12 3 32 4 23 4 50**

# Sample Output

**3**

**5**


思路：最小生成树Prim算法经典例题，套用模版即可。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#define INF 999999999
#define N 101
#define MOD 1000000007
#define E 1e-12
using namespace std;
int g[N][N];
bool vis[N];
int minn[N];
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF&&n)
    {
        int edge=n*(n-1)/2;
        for(int i=1;i<=edge;i++)
        {
            int x,y,dis;
            scanf("%d%d%d",&x,&y,&dis);
            g[x][y]=dis;
            g[y][x]=dis;
        }
        memset(minn,0x7f,sizeof(minn));
        memset(vis,0,sizeof(vis));
        minn[1]=0;

        for(int i=1;i<=n;i++)
        {
            int k=0;
            for(int j=1;j<=n;j++)//寻找与白点相连的权值最小的蓝点k
                if(vis[j]==0&&minn[j]<minn[k])
                    k=j;
            vis[k]=1;//蓝点k加入生成树，标记为白点
            for(int j=1;j<=n;j++)//修改所有与k相连的蓝点
                if(vis[j]==0&&g[k][j]<minn[j])
                    minn[j]=g[k][j];
        }

        int MST=0;
        for(int i=1;i<=n;i++)//计算权值和
            MST+=minn[i];
        cout<<MST<<endl;
    }
    return 0;
}
```





