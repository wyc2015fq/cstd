# 炮兵阵地（POJ-1185） - Alex_McAvoy的博客 - CSDN博客





2018年08月21日 14:04:37[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：52








# Problem Description

司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用"H" 表示），也可能是平原（用"P"表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 

![](https://img-blog.csdn.net/20180821140349658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。 

# **Input**

第一行包含两个由空格分割开的正整数，分别表示N和M； 

接下来的N行，每一行含有连续的M个字符('P'或者'H')，中间没有空格。按顺序表示地图中每一行的数据。N <= 100；M <= 10。

# Output

仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。

# Sample Input

**5 4PHPPPPHHPPPPPHPPPHHP**

# Sample Output

**6**

————————————————————————————————————————————————————

思路：状压DP

思路来源：[点击这里](https://blog.csdn.net/ZWZ530/article/details/52591166)

用一个三维数组按层数来进行状态的转移，依次枚举每一层(i)、当前层状态(j)、上一层状态(k)、上上层状态(l)，即可进行转移

关于枚举状态，理论上每一行都有 1<<m 种可能，如果依次枚举一定会 TLE，但实际上，因为 m 最大为10，且每3个不相邻，因此每一行的最多状态数只有60种可能。

因此对于状态 x，只需右移一位后与原数进行与运算判断是否为零，即可快速的判断其是否存在互相攻击的情况。

原理：如果二进制位的每一个 1 都是被大于等于 1 个零隔开的，那么错位之后绝对不会出现两个 1 位于同一个位置上，所以 & 起来之后一定是为 0，反之如果不为 0，则说明至少有一个地方是出现了两个 1 相连的。

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1001
#define MOD 10007
#define E 1e-6
#define LL long long
using namespace std;
int n,m;
int len;
int dp[110][70][70];
int num[110],sta[110];
int Map[110];
bool check(int x){//判断状态是否合法
    if((x&(x<<1))||(x&(x<<2)))
        return false;
    return true;
}
int Get_Num(int x)//取x状态共有多少个1
{
    int cnt=0;
    while(x){
        cnt++;
        x&=(x-1);
    }
    return cnt;
}
bool judge(int x,int a){//判断是否与上一层状态合法
    if(x&a)
        return false;
    return true;
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF&&(n+m))
    {
        len=0;
        memset(Map,0,sizeof(Map));
        memset(dp,-1,sizeof(dp));
        memset(num,0,sizeof(num));
        memset(sta,0,sizeof(sta));
        for(int i=0;i<(1<<m);i++)
        {
            if(check(i))
            {
                sta[len]=i;
                num[len++]=Get_Num(i);
            }
        }


        char str[201];
        for(int i=0;i<n;i++)
        {
            scanf("%s",str);
            for(int j=0;j<m;j++)
                if(str[j]=='H')//存图,将‘H’认为会冲突的点,将一个字符串状态压缩成一个数
                    Map[i]+=(1<<j);
        }

        int res=0;
        for(int i=0;i<len;i++){
            if(judge(sta[i],Map[0])){
                dp[0][0][i]=num[i];
                res=max(num[i],res);
            }
        }

        for(int i=1;i<n;i++)//枚举层数
            for(int j=0;j<len;j++)//枚举当前状态
                if(judge(sta[j],Map[i]))
                    for(int k=0;k<len;k++)//枚举上一层状态
                        if(judge(sta[j],sta[k]))
                            for(int l=0;l<len;l++)//枚举上上层状态
                                if(judge(sta[j],sta[l])&&dp[i-1][k][l]!=-1){
                                        dp[i][l][j]=max(dp[i-1][k][l]+num[j],dp[i][l][j]);
                                        res=max(dp[i][l][j],res);
                                    }

        cout<<res<<endl;
    }

	return 0;
}
```





