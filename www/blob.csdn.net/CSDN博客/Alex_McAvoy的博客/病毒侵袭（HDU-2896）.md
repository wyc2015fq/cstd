# 病毒侵袭（HDU-2896） - Alex_McAvoy的博客 - CSDN博客





2019年03月06日 19:07:49[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：30








> 
# Problem Description

当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~ 

但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。 

万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~ 

# **Input**

第一行，一个整数N（1<=N<=500），表示病毒特征码的个数。 

接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。 

每个病毒都有一个编号，依此为1—N。 

不同编号的病毒特征码不会相同。 

在这之后一行，有一个整数M（1<=M<=1000），表示网站数。 

接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。 

每个网站都有一个编号，依此为1—M。 

以上字符串中字符都是ASCII码可见字符（不包括回车）。 

# Output

依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。 

web 网站编号: 病毒编号 病毒编号 … 

冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。 

最后一行输出统计信息，如下格式 

total: 带病毒网站数 

冒号后有一个空格。 

# Sample Input

**3aaabbbccc2aaabbbcccbbaacc**

# Sample Output

**web 1: 1 2 3total: 1**


思路：字符串多模版匹配，要求输出每一个单词在每一个文本中的出现次数，使用 set 记录已匹配到的模式串编号，然后递归输出即可，此外由于字符为 ASCII 码，因此字典树的第二维要开到 128

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=10007;
const int N=100000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

struct AC_Automata{
    int tire[N][128];//字典树
    int val[N];//字符串结尾标记
    int fail[N];//失配指针
    int last[N];//last[i]=j表j节点表示的单词是i节点单词的后缀，且j节点是单词节点
    int tot;//编号

    void init(){//初始化0号点
        tot=1;
        val[0]=fail[0]=last[0]=0;
        memset(tire[0],0,sizeof(tire[0]));
    }

    void insert(char *s,int v){//构造trie与val数组，v需非0，表示一个单词节点
        int len=strlen(s);
        int root=0;
        for(int i=0;i<len;i++){
            int id=s[i];
            if(tire[root][id]==0){
                tire[root][id]=tot;
                memset(tire[tot],0,sizeof(tire[tot]));
                val[tot++]=0;
            }
            root=tire[root][id];
        }
        val[root]=v;
    }

    void build(){//构造fail与last
        queue<int> q;
        last[0]=fail[0]=0;
        for(int i=0;i<128;i++){
            int root=tire[0][i];
            if(root!=0){
                fail[root]=0;
                last[root]=0;
                q.push(root);
            }
        }

        while(!q.empty()){//bfs求fail
            int k=q.front();
            q.pop();
            for(int i=0;i<128;i++){
                int u=tire[k][i];
                if(u==0)
                    continue;
                q.push(u);

                int v=fail[k];
                while(v && tire[v][i]==0)
                    v=fail[v];
                fail[u]=tire[v][i];
                last[u]=val[fail[u]]?fail[u]:last[fail[u]];
            }
        }
    }

    void print(int i,set<int> &st){//递归打印与结点i后缀相同的前缀节点编号
        if(val[i]){
            if( st.find(i)==st.end() )
                st.insert(val[i]);
            print(last[i],st);
        }
    }

    void query(char *s,set<int> &st){//匹配
        int len=strlen(s);
        int j=0;
        for(int i=0;i<len;i++){
            int id=s[i];
            while(j && tire[j][id]==0)
                j=fail[j];
            j=tire[j][id];
            if(val[j])
                print(j,st);
            else if(last[j])
                print(last[j],st);
        }
    }
}ac;
char P[N];
char T[N];
set<int>::iterator it;
int main(){
    int n;
    scanf("%d",&n);
    ac.init();
    for(int i=1;i<=n;i++){
        scanf("%s",P);
        ac.insert(P,i);
    }
    ac.build();

    int m;
    scanf("%d",&m);

    int total=0;
    for(int i=1;i<=m;i++){
        scanf("%s",&T);
        set<int> st;//保存文本串已经匹配到的模式串编号
        ac.query(T,st);
        if(!st.empty()){
            total++;

            printf("web %d:",i);
            for(set<int>::iterator it=st.begin();it!=st.end();it++)
                printf(" %d",(*it));
            printf("%\n");
        }
    }
    printf("total: %d\n",total);
    return 0;
}
```





