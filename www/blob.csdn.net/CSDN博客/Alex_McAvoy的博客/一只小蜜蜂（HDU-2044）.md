# 一只小蜜蜂（HDU-2044） - Alex_McAvoy的博客 - CSDN博客





2018年03月27日 23:36:41[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：143








> 
# Problem Description

    有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。

    其中，蜂房的结构如下所示。

![](http://acm.hdu.edu.cn/data/images/C40-1001-1.jpg)

# Input

    输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0<a<b<50)。

# Output

    对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。

# Sample Input

**21 23 6**

# Sample Output

**13**


思路：

由题意：

      从1到2： 1→2；    1种

      从1到3： 1→2→3，1→3；    2种

      从1到4： 1→2→3→4，1→3→4，1→2→4；    3种

      从1到5： 1→2→3→4→5，1→2→4→5，1→3-→4→5，1→2→3→5，1→3→5；    5种

      从1到6：1→2→3→4→5→6，1→2→3→4→6，1→2→3→5→6，1→2→4→5→6，1→3→4→5→6，1→2→4→6，1→3→4→6，1→3→5→6；    8种；

                            ……

可推：第 n 个的可能路径为  f(n)=f(n-1)+f(n-2)（斐波那契数列）

# Source Program

```cpp
#include<iostream>
#include<cstring>
#define N 101
using namespace std;

long long dp[N];//注意用long long型

int main()
{
    int n,m;
    int a,b;
    int i;

    cin>>n;
    while(n--)
    {
        cin>>a>>b;

        memset(dp,0,sizeof(dp));//初始化

        /*边界条件*/
        dp[0]=1;
        dp[1]=1;

        m=b-a+1;
        for(i=2;i<=m;i++)
            dp[i]=dp[i-1]+dp[i-2];

        cout<<dp[m-1]<<endl;
    }
    return 0;
}
```



