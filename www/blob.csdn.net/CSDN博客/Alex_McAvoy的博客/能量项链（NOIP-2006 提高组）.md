# 能量项链（NOIP-2006 提高组） - Alex_McAvoy的博客 - CSDN博客





2018年09月03日 00:01:36[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：263








# Problem Description

在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。

需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：

(4⊕1)=10*2*3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为

((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。

# **Input**

有多组测试数据。

对于每组测试数据，输入的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i<N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

处理到文件结束。

# Output

对于每组测试数据，输出只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。

# Sample Input

**42 3 5 10**

# Sample Output

**710**

————————————————————————————————————————————————————

思路：环形 DP，考虑将珠子剪开，将原有的序列变为两倍，例如：1，2，3，4 可以展成 1，2，3，4，3，2，1，用 dp[i][j] 表示合并区间 i 到 j 的最大能量，第一重循环表示珠子分组的终点，第二重循环的表示从珠子分组的起点 ，第三重循环表示截断的点

注意，有多组数据

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 201
#define MOD 10007
#define E 1e-6
#define LL long long
using namespace std;
LL a[N];
LL dp[N][N];
int main()
{
    int n;
    while(cin>>n)
    {
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            a[i+n]=a[i];
        }

        memset(dp,0,sizeof(dp));
        for(int len=2;len<=n;len++)
        {
            for(int i=1;i+len-1<=2*n;i++)
            {
                int j=len+i-1;
                for(int k=i;k<j;k++)
                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+a[i]*a[k+1]*a[j+1]);
            }
        }

        LL maxx=0;
        for(int i=1;i<=n;i++)
            maxx=max(maxx,dp[i][i+n-1]);

        cout<<maxx<<endl;
    }
    return 0;
}
```





