# 图论 —— 最小树形图 - Alex_McAvoy的博客 - CSDN博客





2019年01月05日 16:48:21[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：120








# 【概述】

最小树形图，就是给出一个带权有向图，从中指定一个特殊的结点 root，求一棵以 root 为根的有向生成树 T，且使得 T 中所有边权值最小。

简单来说，最小树形图就是有向图的最小生成树。

# 【朱刘算法】

## 1.过程

在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图

1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。

2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。

3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。

4）更新其他点到环上的距离。

5）重复 3、4 直到 **图中不存在环 **为止，此时图是最小树形图。

![](https://img-blog.csdnimg.cn/20190105164804125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=,size_16,color_FFFFFF,t_70)

## 2.实现

```cpp
#include<cstdio>
#include<cstring>
#define INF 0x3f3f3f3f
#define N 1001
struct Edge{
    int x,y;
    int w;
}edge[N];
int vis[N];
int id[N];//结点所属环编号
int in[N],pre[N];//in[]为最小入边权,pre[]为其对应的起点
int zhuLiu(int root,int n,int m){//root结点、点数、边数
    int res=0;//最小树形图总权值
    while(true){
        for(int i=0;i<n;i++)//初始化为无穷大
            in[i]=INF;

        //寻找每个点的最小入边
        for(int i=0;i<m;i++){//遍历每条边
            int x=edge[i].x;
            int y=edge[i].y;
            if(edge[i].w<in[y] && x!=y){//更新最小入边
                pre[y]=x;//记录前驱
                in[y]=edge[i].w;//更新
            }
        }

        //判断是否存在最小树形图
        for(int i=0;i<n;i++){
            if(i==root)
                continue;
            if(in[i]==INF)//除根节点外的点存在孤立点
                return -1;
        }

        //寻找所有的环
        int cnt=0;//记录环数
        in[root]=0;
        memset(id,-1,sizeof(id));
        memset(vis,-1,sizeof(vis));
        for(int i=0;i<n;i++){//标记每个环
            res+=in[i];//记录权值

            int y=i;
            while(vis[y]!=i&&id[y]==-1&&y!=root){//寻找图中有向环
                //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根
                vis[y]=i;//标记
                y=pre[y];//向上找
            }

            if(y!=root&&id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环
                for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环
                    id[x]=cnt;//记录结点所属环号
                id[y]=cnt++;//记录结点所属环号并累加
            }
        }
        if(cnt==0)//无环
                break;
        for(int i=0;i<n;i++)//可能存在独立点
            if(id[i]==-1)//环数累加
                id[i]=cnt++;

        //建立新图,缩点重新标记
        for(int i=0;i<m;i++){
            int x=edge[i].x;
            int y=edge[i].y;
            edge[i].x=id[x];
            edge[i].y=id[y];

            if(id[x]!=id[y])//两点不在同一环内,更新边权值
                edge[i].w-=in[y];//x到y的距离为边权-in[y]
        }

        V=cnt;//以环数为下次操作的点数,继续上述操作,直到无环
        root=id[root];
    }
    return res;
}
int main(){
    int n,m;//n个点m条有向边
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++){//建图
        scanf("%d%d%d",&edge[i].x,&edge[i].y,&edge[i].w);
        if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF
            edge[i].w=INF;
    }
    int res=zhuLiu(0,n,m);
    if(res==-1)
        printf("No\n");
    else
        printf("%d\n",res);
    return 0;
}
```

# 【例题】
- Command NetWork（POJ-3164）**(定根的最小树形图)**：[点击这里](https://blog.csdn.net/u011815404/article/details/85864978)
- Ice_cream’s world II（HDU-2121）**(超级源点的使用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/85861270)



