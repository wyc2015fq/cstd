# 基础算法 —— 排序 —— 堆排序 - Alex_McAvoy的博客 - CSDN博客





2018年03月18日 14:53:01[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：112








# 【分类】

    选择类排序

# 【基本思想】    

    利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

# 【堆的性质】    

    1.实质：完全二叉树或近似完全二叉树

    2.分类：大顶堆：父节点不小于子节点键值；小顶堆：父节点不大于子节点键值

![这里写图片描述](https://img-blog.csdn.net/20160304164626537)

最小堆

    3.左右子节点：没有大小的顺序

    4.堆的存储：一般都用数组来存储堆，i结点的父结点下标为（i-1）/2，其左右子结点下标分别为：2∗i+1、2*i+2

       例：第0个结点左右子结点下标分别为1和2。 

![这里写图片描述](https://img-blog.csdn.net/20160304160816781)

    5.堆的操作

      1）建立：以最小堆为例，如果以数组存储元素时，一个数组具有对应的树表示形式，但树并不满足堆的条件，需要重新排列元素，可以建立“堆化”的树。

![这里写图片描述](https://img-blog.csdn.net/20160304170559093)

      2）插入：将一个新元素插入到表尾，即数组末尾时，如果新构成的二叉树不满足堆的性质，需要重新排列元素。

![这里写图片描述](https://img-blog.csdn.net/20160304170919536)

    3）删除：堆排序中，删除一个元素总是发生在堆顶，因为堆顶的元素是最小的（小顶堆中）。表中最后一个元素用来填补空缺位置，结果树被更新以满足堆条件。

![这里写图片描述](https://img-blog.csdn.net/20160304171754671)



# 【基本思想】

    步骤：
- 创建一个堆H[0..n-1]
- 把堆首（最大值）和堆尾互换
- 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
- 重复步骤2，直到堆的尺寸为1

# 【特点】

     数据结构：数组

     稳定性：不稳定

# 【过程】

![](http://img-blog.csdn.net/20180318145212985)

            宏观排序

# 【复杂度与辅助空间】

 最差时间复杂度： O(nlgn)

 最优时间复杂度：O(n)

 平均时间复杂度：O(nlgn)

 所需辅助空间：O(1) 

# 【源程序】

```cpp
void Heapify(int A[], int i, int size)  // 从A[i]向下进行堆调整
{
    int left_child=2*i +1;// 左子节点索引
    int right_child=2*i+2;// 右子节点索引
    int max = i;// 选出当前结点与其左右孩子三者之中的最大值
    
    if (left_child < size && A[left_child] > A[max])
        max = left_child;
    if (right_child < size && A[right_child] > A[max])
        max = right_child;
    if (max != i)
    {
        Swap(A, i, max);//把当前结点和它的最大(直接)子节点进行交换
        Heapify(A, max, size);//递归调用，继续从当前结点向下进行堆调整
    }
}

int Build_heap(int A[], int n)//建堆
{
    int heap_size = n;
    for (int i = heap_size / 2 - 1; i >= 0; i--) // 从每一个非叶结点开始向下进行堆调整
        Heapify(A, i, heap_size);
    return heap_size;
}

void Heap_sort(int A[], int n)
{
    int heap_size = BuildHeap(A, n);// 建立一个最大堆
    while (heap_size > 1) // 堆（无序区）元素个数大于1，未完成排序
    {
        /*
        	将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素
         	此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法
        */
        swap(A, 0, --heap_size);
        Heapify(A, 0, heap_size);//从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)
    }
}
```

注：堆排序在数据较少时不提倡，但数据量很大时，效率会很高，因为其运算时间主要消耗在建立初始堆和调整过程中。



