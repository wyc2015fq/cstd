# 凌乱的yyy（洛谷-P1803） - Alex_McAvoy的博客 - CSDN博客





2018年04月14日 23:29:44[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：237








## 题目描述

现在各大oj上有n个比赛，每个比赛的开始、结束的时间点是知道的。

yyy认为，参加越多的比赛，noip就能考的越好（假的）

所以，他想知道他最多能参加几个比赛。

由于yyy是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加2个及以上的比赛。

## 输入输出格式

**输入格式：**

第一行是一个整数n ，接下来n行每行是2个正整数ai,bi(ai<bi)，表示比赛开始、结束的时间。

**输出格式：**

一个整数最多参加的比赛数目。

## 输入输出样例

**输入样例#1：**

```
3
0 2
2 4
1 3
```

**输出样例#1：**

```
2
```

———————————————————————————————————————————————

思路：将每一场比赛以结束时间排一次序，得到一个顺序的结构体数组，存储最前面一节课的下课时间，然后以结束时间为准，在这相同结束时间比赛中下，如果有比赛的开始时间小于等于记录的结束时间，直接参加比赛，然后计数，最后输出总次数。

## 源代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct game{//结构体
    int begin;
    int end;
}arr[100000];
bool cmp(game a,game b){//排序因子
    return a.end<b.end;//按比赛结束时间升序
}
int main()
{
    int n,total=0;
    int temp;
    int i;
    
    cin>>n;
    for(i=1;i<=n;i++)	cin>>arr[i].begin>>arr[i].end;//输入每场比赛开始、结束时间
    
    sort(arr+1,arr+1+n,cmp);//升序排序
    
    temp=0;//令temp为上一场比赛的结束时间
    for(i=1;i<=n;i++)//对所有比赛进行遍历
    {
        if(temp<=arr[i].begin)//当结束时间小于下一场比赛的开始时间时，进行下一场比赛
        {
            temp=arr[i].end;//记录新一场的结束时间
            total++;//参加场数+1
        }
    }    
    cout<<total<<endl;
    return 0;
}
```



