# 魔法照片（洛谷-P1583） - Alex_McAvoy的博客 - CSDN博客





2018年04月10日 23:28:06[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：88








## 题目描述

一共有n（n≤20000）个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。

## 输入输出格式

**输入格式：**

第一行输入用空格隔开的两个整数，分别是n和k。

第二行给出了10个正整数，分别是E[1]到E[10]。

第三行给出了n个正整数，第i个数表示编号为i的人的权值W[i]。

**输出格式：**

只需输出一行用空格隔开的k个整数，分别表示最终的W[i]从高到低的人的编号。

## 输入输出样例

**输入样例#1：**

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

**输出样例#1：**

```
10 9 8 7 6 5 4 3 2 1
```

———————————————————————————————————————————————

思路：输入→排号→排序→权值处理→排序→输出

## 源代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int extra[11],initial[20001],order[20001];
bool cmp(int a,int b)
{   
    if(initial[a]==initial[b])	return a<b;//从大到小排序 
    else	return initial[a]>initial[b];//序号小优先
}

int main()
{
    
    int n,k;
    int i;
    
    cin>>n>>k;
    for(i=1;i<=10;i++)	cin>>extra[i];
    for(i=1;i<=n;i++)	
    {
        cin>>initial[i];
        order[i]=i;
    }

    sort(order+1,order+n+1,cmp);//第一次排序
    for(i=1;i<=n;i++)//分类处理
        	initial[order[i]]+=extra[(i-1)%10+1];
    sort(order+1,order+n+1,cmp);//第二次排序
    
    for(i=1;i<=k;i++)
    	cout<<order[i]<<" ";
    cout<<endl;
    	
    return 0;
}
```





