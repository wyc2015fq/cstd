# 统计难题（HDU-1251） - Alex_McAvoy的博客 - CSDN博客





2019年02月20日 15:58:30[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：28








> 
# Problem Description

Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). 

# Input

输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. 

注意:本题只有一组测试数据,处理到文件结束. 

# Output

对于每个提问,给出以该字符串为前缀的单词的数量. 

# **Sample Input**

**bananabandbeeabsoluteacm**

**babbandabc**

# Sample Output

**2310**


思路：字典树入门题

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define N 500001
#define LL long long
const int MOD=20091226;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
int trie[N][26];
int tot;
int sum[N];
void insert(char *s){
    int root=0;
    int len=strlen(s);
    for(int i=0;i<len;i++){
        int id=s[i]-'a';
        if(!trie[root][id])
            trie[root][id]=++tot;
        sum[trie[root][id]]++;
        root=trie[root][id];
    }
}
int search(char *s){
    int root=0;
    int len=strlen(s);
    for(int i=0;i<len;i++){
        int id=s[i]-'a';
        if(!trie[root][id])
            return 0;
        root=trie[root][id];
    }
    return sum[root];
}
int main(){
    char str[20];

    while(gets(str)){
        if(strlen(str)==0)
            break;
        insert(str);
    }
    while(gets(str)){
        printf("%d\n",search(str));
    }

    return 0;
}
```





