# 查找 —— 哈希查找 - Alex_McAvoy的博客 - CSDN博客





2018年05月14日 19:20:23[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：70








# 【哈希表】

使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素"分类"，然后将这个元素存储在相应"类"所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了"冲突"，换句话说，就是把不同的元素分在了相同的"类"之中。后面我们将看到一种解决"冲突"的简便做法。

# 【哈希函数】

通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。

# 【基本思想】

哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

# 【算法流程】
- 用给定的哈希函数构造哈希表；
- 根据选择的冲突处理方法解决地址冲突（常见的解决冲突的方法：拉链法和线性探测法）；
- 在哈希表的基础上执行哈希查找。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

# 【六种哈希函数构造方法】

1.直接定址法：

    函数公式：f(key)=a*key+b (a,b为常数)

    优点是：简单，均匀，不会产生冲突。但是需要事先知道关键字的分布情况，适合查找表较小并且连续的情况。

2.数字分析法：

    比如我们的11位手机号码“136XXXX7887”，其中前三位是接入号，一般对应不同运营公司的子品牌，如130是联通如意通，136是移动神州行，153是电信等。中间四们是HLR识别号，表示用户归属地。最后四们才是真正的用户号。

    若我们现在要存储某家公司员工登记表，如果用手机号码作为关键字，那么极有可能前7位都是相同的，所以我们选择后面的四们作为哈希地址就是不错的选择。

3.平方取中法：

    故名思义，比如关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227作为哈希地址。

4.折叠法：

    折叠法是将关键字从左到右分割成位数相等的几个部分(最后一部分位数不够可以短些)，然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。

    比如我们的关键字是9876543210，哈希表表长三位，我们将它分为四组，987|654|321|0 ，然后将它们叠加求和987+654+321+0=1962，再求后3位即得到哈希地址为962。

5.除留余数法：

    函数公式：f(key)=key mod p (p<=m)，m为哈希表表长。

    这种方法是最常用的哈希函数构造方法。

6.随机数法：

    函数公式：f(key)= random(key)。

    这里random是随机函数，当关键字的长度不等是，采用这种方法比较合适。

# 【处理冲突的方法】

1. 开放寻址法；Hi=(H(key) + di) MOD m, i=1,2,…, k(k<=m-1)。其中，H(key)为散列函数，m为散列表长，di为增量序列，可有下列三种取法：

　　1). di=1,2,3,…, m-1，称：线性探测再散列

       2). di=1^2, (-1)^2, 2^2,(-2)^2, (3)^2, …, ±(k)^2,(k<=m/2)，称：二次探测再散列;

　　3). di=伪随机数序列，称：伪随机探测再散列。 

2. 再散列法：Hi=RHi(key), i=1,2,…,k，RHi均是不同的散列函数，即：在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。

# 【实现代码】

```cpp
#include<stdio.h>
#include<stdlib.h>

#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12
#define NULLKEY -32768

int m=0;

typedef struct
{
    int *elem;      //元素存储基址，是个动态分配数组
    int count;      //当前元素个数
}HashTable;

//初始化
int InitHashTable(HashTable *H)
{
    int i;
    m=HASHSIZE;
    H->count=m;
    H->elem=(int*)malloc(m*sizeof(int));        //动态分配
    for(i=0;i<m;i++)
        H->elem[i]=NULLKEY;
    return SUCCESS;
}

//散列函数
int Hash(int key)
{
    return key%m;
}

//插入
void InsertHash(HashTable *H,int key)
{
    int addr=Hash(key);
    while(H->elem[addr]!=NULLKEY)       //若该地址非空，则冲突
        addr=(addr+1)%m;        //冲突处理：开放地址法的线性探测
    H->elem[addr]=key;
}

//查找
int SearchHash(HashTable H,int key,int *addr)
{
    *addr=Hash(key);        //求其散列地址
    while(H.elem[*addr]!=key)       //该地址不为空，则冲突
    {
        *addr=(*addr+1)%m;      //线性探测
        if(H.elem[*addr]==NULLKEY || *addr==Hash(key))      //若循环回到原点，说明该元素不存在
            return UNSUCCESS;
    }
    return SUCCESS;
}

void main()
{
    HashTable H;
    int i,key;
    int addr;
    InitHashTable(&H);
    int a[12]={12,67,56,16,25,37,22,29,15,47,48,34};
    for(i=0;i<12;i++)
    {
        InsertHash(&H,a[i]);
    }
    printf("请输入你要查找的元素：");
    scanf("%d",&key);
    if(SearchHash(H,key,&addr))
        printf("有");
    else
        printf("没有");
}
```





