# 欧拉回路（HDU-1878） - Alex_McAvoy的博客 - CSDN博客





2018年11月02日 20:46:32[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：60








> 
# Problem Description

欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？

# **Input**

测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 < N < 1000 )和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结

束。

# Output

每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。

# Sample Input

**3 31 21 32 33 21 22 30**

# Sample Output

**10**


思路：使用并查集统计各节点度数即可，若图连通且所有点的度数为偶数，则说明该无向图存在欧拉回路

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1001
#define MOD 16007
#define E 1e-6
#define LL long long
using namespace std;
int n,m;
int degree[N];
int father[N];
int Find(int x){
    if(father[x]==-1)
        return x;
    return father[x]=Find(father[x]);
}
void Union(int x,int y){
    x=Find(x);
    y=Find(y);
    if(x!=y)
        father[x]=y;
}
int main(){

    while(scanf("%d%d",&n,&m)!=EOF){
        memset(degree,0,sizeof(degree));
        memset(father,-1,sizeof(father));

        for(int i=1;i<=m;i++){
            int x,y;
            scanf("%d%d",&x,&y);
            degree[x]++;
            degree[y]++;
            Union(x,y);
        }

        int cnt=0;//记录连通分量
        for(int i=1;i<=n;i++)
            if(Find(i)==i)
                cnt++;
        if(cnt!=1)//若cnt大于1，说明图不连通
            printf("0\n");
        else{
            int num=0;//统计度数为奇数的点
            for(int i=1;i<=n;i++)
                if(degree[i]&1)
                    num++;
            if(num==0)
                printf("1\n");
            else
                printf("0\n");
        }

    }
    return 0;
}
```





