# 数学 —— 组合数学 —— 卢卡斯定理 - Alex_McAvoy的博客 - CSDN博客





2019年03月23日 16:31:51[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：20








# 【卢卡斯定理】

1.要求：p 是素数，m、n 很大但 p 很小 或者 n、m不大但大于 p

2.定理结论

1）![Lucas(n,m,p)=cm(n\:mod\:p,m\:mod\:p)*Lucas(n/p,m/p,p)](https://private.codecogs.com/gif.latex?Lucas%28n%2Cm%2Cp%29%3Dcm%28n%5C%3Amod%5C%3Ap%2Cm%5C%3Amod%5C%3Ap%29*Lucas%28n/p%2Cm/p%2Cp%29)![,Lucas(x,0,p)=1](https://private.codecogs.com/gif.latex?%2CLucas%28x%2C0%2Cp%29%3D1)

其中，![cm(a,b)=a!*(b!*(a-b)!)^{(p-2)}\:mod\:p=(a!/(a-b)!)*(b!)^{(p-2)}\:mod\:p](https://private.codecogs.com/gif.latex?cm%28a%2Cb%29%3Da%21*%28b%21*%28a-b%29%21%29%5E%7B%28p-2%29%7D%5C%3Amod%5C%3Ap%3D%28a%21/%28a-b%29%21%29*%28b%21%29%5E%7B%28p-2%29%7D%5C%3Amod%5C%3Ap)

2）将 n 写成 p 进制：![n=a[n]a[n-1]...a[0]](https://private.codecogs.com/gif.latex?n%3Da%5Bn%5Da%5Bn-1%5D...a%5B0%5D)，将 m 写成 p 进制：![m=b[n]b[n-1]...b[0]](https://private.codecogs.com/gif.latex?m%3Db%5Bn%5Db%5Bn-1%5D...b%5B0%5D)，则有：

![C(a[n],b[n])*C(a[n-1],b[n-1])*...*C(a[0],b[0])](https://private.codecogs.com/gif.latex?C%28a%5Bn%5D%2Cb%5Bn%5D%29*C%28a%5Bn-1%5D%2Cb%5Bn-1%5D%29*...*C%28a%5B0%5D%2Cb%5B0%5D%29) 模 p 同余。

3）代码实现可以简单理解为：![C^n_m=C^{n/p}_{m/p}*C^{n \:mod\:p}_{m\:mod\:p}(mod\:p)。](https://private.codecogs.com/gif.latex?C%5En_m%3DC%5E%7Bn/p%7D_%7Bm/p%7D*C%5E%7Bn%20%5C%3Amod%5C%3Ap%7D_%7Bm%5C%3Amod%5C%3Ap%7D%28mod%5C%3Ap%29%25u3002)

3.实现

```cpp
LL fac[N];
void getFac(){//构造阶乘
    fac[0]=1;
    for(int i=1;i<1000000;i++){
        fac[i]=fac[i-1]*i%MOD;
    }
}
LL quickPowMod(LL a,LL b,LL mod){//快速幂
    LL res=1;
    while(b){
        if(b&1)
            res=res*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return res;
}
LL getC(LL n,LL m,LL mod){//获取C(n,m)%mod
    if(m>n)
        return 0;
    return fac[n]*(quickPowMod(fac[m]*fac[n-m]%mod,mod-2,mod))%mod;
}
LL Lucas(LL n,LL m,LL mod){//卢卡斯定理
    if(m==0)
        return 1;
    return getc(n%mod,m%mod,mod)*Lucas(n/mod,m/mod,mod)%mod;
}
int main(){
    getFac();
    LL n,m;
    scanf("%lld%lld",&n,&m);
    printf("%lld\n",Lucas(n,k,MOD));
    return 0;
}
```

# 【扩展卢卡斯】

卢卡斯定理适用于 p 是素数的情况，但当 p 不是素数时，可以将其分解质因数，将组合数按照卢卡斯定理的方法求 p 的质因数的模，然后用中国剩余定理合并即可

例如： 

当需要计算 ![C^n_m\:mod\:p,p=p^{q1}_1*p^{q2}_2*...*p^{qk}_k](https://private.codecogs.com/gif.latex?C%5En_m%5C%3Amod%5C%3Ap%2Cp%3Dp%5E%7Bq1%7D_1*p%5E%7Bq2%7D_2*...*p%5E%7Bqk%7D_k) 时，可以求出：![C^n_m\equiv ai(mod\:p^{qi}_i)(1<i<k)](https://private.codecogs.com/gif.latex?C%5En_m%5Cequiv%20ai%28mod%5C%3Ap%5E%7Bqi%7D_i%29%281%3Ci%3Ck%29)

然后对于方程组：![x\equiv ai(mod\:p^{qi}_i)(1<i<k)](https://private.codecogs.com/gif.latex?x%5Cequiv%20ai%28mod%5C%3Ap%5E%7Bqi%7D_i%29%281%3Ci%3Ck%29)，可以求出满足条件的最小的 x，记为：![x_0](https://private.codecogs.com/gif.latex?x_0)

那么有：![C^n_m\equiv x_0(mod\:p)](https://private.codecogs.com/gif.latex?C%5En_m%5Cequiv%20x_0%28mod%5C%3Ap%29)

但是，![p^{qi}_i](https://private.codecogs.com/gif.latex?p%5E%7Bqi%7D_i) 并不是一个素数，而是某个素数的某次方，那么就需要计算  ![C^n_m\:mod\:p^t,t\geqslant 2](https://private.codecogs.com/gif.latex?C%5En_m%5C%3Amod%5C%3Ap%5Et%2Ct%5Cgeqslant%202)

对于 ![C^n_m\:mod\:p^t,t\geqslant 2](https://private.codecogs.com/gif.latex?C%5En_m%5C%3Amod%5C%3Ap%5Et%2Ct%5Cgeqslant%202)，我们知道 ![C^m_n=\frac{n!}{m!(n-m)!}](https://private.codecogs.com/gif.latex?C%5Em_n%3D%5Cfrac%7Bn%21%7D%7Bm%21%28n-m%29%21%7D)，因此若能计算出 ![n! \:mod \:p^t](https://private.codecogs.com/gif.latex?n%21%20%5C%3Amod%20%5C%3Ap%5Et)，就能计算出![m! \:mod \:p^t](https://private.codecogs.com/gif.latex?m%21%20%5C%3Amod%20%5C%3Ap%5Et) 和 ![(n-m!) \:mod \:p^t](https://private.codecogs.com/gif.latex?%28n-m%21%29%20%5C%3Amod%20%5C%3Ap%5Et)

设 ![x=n!\: mod \;p^t,y=m!\: mod\: p^t,z=(n-m)!\: mod\: p^t](https://private.codecogs.com/gif.latex?x%3Dn%21%5C%3A%20mod%20%5C%3Bp%5Et%2Cy%3Dm%21%5C%3A%20mod%5C%3A%20p%5Et%2Cz%3D%28n-m%29%21%5C%3A%20mod%5C%3A%20p%5Et)，那么答案就是 ![x*reverse(y,p^t)*reverse(z,p^t)](https://private.codecogs.com/gif.latex?x*reverse%28y%2Cp%5Et%29*reverse%28z%2Cp%5Et%29)，其中 ![reverse(a,b)](https://private.codecogs.com/gif.latex?reverse%28a%2Cb%29) 代表计算 a 对 b 的乘法逆元

于是，问题就转换为如何计算 ![n! \:mod \:p^t](https://private.codecogs.com/gif.latex?n%21%20%5C%3Amod%20%5C%3Ap%5Et)

例如：p=3，t=2，n=19，有：

n! = 1×2×3×4×5×6×7×8×…×19

    = (1×2×4×5×7×8×…×16×17×19) × (3×6×9×12×15×18)

    = (1×2×4×5×7×8×…×16×17×19) × 36 × (1×2×3×4×5×6) 

后半部分是 ![(\frac{n}{p})!](https://private.codecogs.com/gif.latex?%28%5Cfrac%7Bn%7D%7Bp%7D%29%21)，递归即可。前半部分是以 ![p^t](https://private.codecogs.com/gif.latex?p%5Et) 为周期的 ![(1*2*4*5*7*8)\equiv (10*11*13*14*16*17)(mod \:9)](https://private.codecogs.com/gif.latex?%281*2*4*5*7*8%29%5Cequiv%20%2810*11*13*14*16*17%29%28mod%20%5C%3A9%29)

下面是孤立的 19，可以知道孤立出来的长度不超过 ![p^t](https://private.codecogs.com/gif.latex?p%5Et)，直接计算即可。

对于最后剩下的 36，只要计算出 n!、m!、(n−m)! 里含有多少个 p ，设他们分别有 x、y、z 个 p，那么 x−y−z 就是 ![C^n_m](https://private.codecogs.com/gif.latex?C%5En_m)  中 p 的个数，直接计算即可

```cpp
LL CRT(int n,LL* a,LL* m){
    LL M=1,p=0;
    for(int i=1;i<=n;i++) 
        M=M*m[i];
    for(int i=1;i<=n;i++){
        LL w=M/m[i],x,y;
        exgcd(w,m[i],x,y);
        p=(p+a[i]*w*x%mod)%mod;
    }
    return (p%mod+mod)%mod;
}
LL calc(LL n,LL x,LL P){
    if(!n) 
        return 1;
    LL s=1;
    for(int i=1;i<=P;i++)
        if(i%x) 
            s=s*i%P;
    s=Pow(s,n/P,P);
    for(int i=n/P*P+1;i<=n;i++)
        if(i%x) 
            s=s*i%P;
    return s*calc(n/x,x,P)%P;
}
LL multilucas(LL m,LL n,LL x,LL P){
    int cnt=0;
    for(int i=m;i;i/=x) 
        cnt+=i/x;
    for(int i=n;i;i/=x) 
        cnt-=i/x;
    for(int i=m-n;i;i/=x) 
        cnt-=i/x;
    return Pow(x,cnt,P)%P*calc(m,x,P)%P*inverse(calc(n,x,P),P)%P*inverse(calc(m-n,x,P),P)%P;
}
LL exlucas(LL m,LL n,LL P){
    int cnt=0;
    LL p[20],a[20];
    for(LL i=2;i*i<=P;i++){
        if(P%i==0){
            p[++cnt]=1;
            while(P%i==0){
                p[cnt]=p[cnt]*i;
                P/=i;
            }
            a[cnt]=multilucas(m,n,i,p[cnt]);
        }
    }
    if(P>1)
        p[++cnt]=P,a[cnt]=multilucas(m,n,P,P);
    return CRT(cnt,a,p);
}
```



