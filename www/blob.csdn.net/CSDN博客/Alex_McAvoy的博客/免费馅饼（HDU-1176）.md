# 免费馅饼（HDU-1176） - Alex_McAvoy的博客 - CSDN博客





2018年03月27日 23:28:20[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：84








> 
# Problem Description

    都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：



![](http://acm.hdu.edu.cn/data/images/1176_1.jpg)

为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）

# Input

    输入数据有多组。每组数据的第一行为以正整数n(0<n<100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0<T<100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。

# Output

    每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。

    提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。

# Sample Input

**65 14 16 17 27 28 30**

# Sample Output

**4**


思路：与数塔问题相同的思维。

构造一个矩阵dp[t][x]，表示第t秒第x个位置上有馅饼掉落，那么我把所有馅饼都填入表，这样从底向上走，走到最上面一层，找到所走过的位置中馅饼之数最大的数即可。

# Source Program

```cpp
#include<iostream>
#include<cstring>
#define N 100001
using namespace std;
int dp[N][12];

int max(int a,int b,int c)
{
    int temp=a>b?a:b;
    return temp>c?temp:c;
}
int main()
{
    int c,n;
    int x,t;
    int i,j;
    int maxx;

    while(cin>>n && n)
    {
        memset(dp,0,sizeof(dp));
        maxx=0;

        for(i=0;i<n;i++)
        {
            cin>>x>>t;
            dp[t][x]++;//第几分钟第几位置加上一个馅饼
            if(maxx<t)//记录最大的行
                maxx=t;
        }
        for(i=maxx-1;i>=0;i--)//枚举时间
            for(j=0;j<=10;j++)//枚举坐标
                dp[i][j]=max(dp[i+1][j+1],dp[i+1][j],dp[i+1][j-1])+dp[i][j];

        cout<<dp[0][5]<<endl;
    }
    return 0;
}
```







