# 吃奶酪（洛谷-P1433） - Alex_McAvoy的博客 - CSDN博客





2018年07月03日 20:40:19[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：140








## 题目描述

房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在(0,0)点处。

## 输入输出格式

**输入格式：**

第一行一个数n (n<=15)

接下来每行2个实数，表示第i块奶酪的坐标。

两点之间的距离公式=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))

**输出格式：**

一个数，表示要跑的最少距离，保留2位小数。

## 输入输出样例

**输入样例#1：**

```
4
1 1
1 -1
-1 1
-1 -1
```

**输出样例#1：**
`7.41`
## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1001
#define MOD 123
#define E 1e-6
using namespace std;
int n;
int vis[N];
double dis[N][N];
double sum;
struct Node{
    double x;
    double y;
}point[N];
double calculate(int i,int j)//计算两点距离
{
    return sqrt( (point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y) );
}
void dfs(int past,int now,double len)//已经走过的点，上一个走的点，已经走过的长度
{
    if(len>sum)//剪枝
        return;
    if(past==n)
    {
        sum=min(sum,len);
        return;
    }

    for(int i=1;i<=n;i++)//枚举所有点
        if(!vis[i])//没有走过
        {
            vis[i]=1;
            dfs(past+1,i,len+dis[now][i]);
            vis[i]=0;
        }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>point[i].x>>point[i].y;

    point[0].x=0;
    point[0].y=0;
    for(int i=0;i<=n;i++)//预处理两点距离
        for(int j=0;j<=n;j++)
            dis[i][j]=calculate(i,j);
    sum=INF;
    dfs(0,0,0);
    printf("%.2lf\n",sum);
    return 0;
}
```





