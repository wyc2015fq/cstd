# 填涂颜色（洛谷-P1162） - Alex_McAvoy的博客 - CSDN博客





2018年05月14日 19:19:45[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：107








> 
## 题目描述

由数字0 组成的方阵中，有一任意形状闭合圈，闭合圈由数字1构成，围圈时只走上下左右4个方向。现要求把闭合圈内的所有空间都填写成2.例如：6X6的方阵（n=6），涂色前和涂色后的方阵如下：

涂色前：

0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 0 0 1

1 1 0 0 0 1

1 0 0 0 0 1

1 1 1 1 1 1

涂色后：

0 0 0 0 0 0

0 0 1 1 1 1

0 1 1 2 2 1

1 1 2 2 2 1

1 2 2 2 2 1

1 1 1 1 1 1

## 输入输出格式

**输入格式：**

每组测试数据第一行一个整数：n。其中n(1<=n<=30)

接下来n行，由0和1组成的nXn的方阵。

方阵内只有一个闭合圈，圈内至少有一个0。

**输出格式：**

已经填好数字2的完整方阵。

## 输入输出样例

**输入样例#1：**

**60 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1**

**输出样例#1：**

**0 0 0 0 0 00 0 1 1 1 10 1 1 2 2 11 1 2 2 2 11 2 2 2 2 11 1 1 1 1 1**


## 源代码

```cpp
#include<iostream>
using namespace std;

int a[100][100],b[100][100]={0};
int n,x,y;

void dfs(int x,int y)
{
    if(x>n||x<1||y>n||y<1||a[x][y]!=0)//搜索终止条件
        return;
    
    a[x][y]=1;//标记
    
    dfs(x-1,y);//上方
    dfs(x+1,y);//下方
    dfs(x,y-1);//左方
    dfs(x,y+1);//右方 
}

int main()
{
    int i,j;
    int flag=0;
    
    cin>>n;//输入矩阵大小n
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            cin>>a[i][j];//输入矩阵元素
            if(a[i][j]==1)
                b[i][j]=-1;//存原来的位置 
        }
    
    for(i=1;i<=n;i++)
    {
        if(a[i][1]!=1) dfs(i,1);//搜索第i行的第一列
        if(a[i][n]!=1) dfs(i,n);//搜第i行的第n列 
    }
    for(i=1;i<=n;i++)
    {
    	if(a[1][i]!=1) dfs(1,i);//搜索第i列的第一行
    	if(a[n][i]!=1) dfs(n,i);//搜第i列的第n行 
    }
    
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(b[i][j]==-1) cout<<"1 ";
            else if(a[i][j]==0) cout<<"2 ";
            else cout<<"0 ";
        }
        cout<<endl;
    } 
    return 0;
}
```





