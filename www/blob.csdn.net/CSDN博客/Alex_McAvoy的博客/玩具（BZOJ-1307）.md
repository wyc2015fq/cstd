# 玩具（BZOJ-1307） - Alex_McAvoy的博客 - CSDN博客





2019年02月10日 19:16:49[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：61
个人分类：[STL 的使用——容器与迭代器																[其它 OJ](https://blog.csdn.net/u011815404/article/category/8820652)](https://blog.csdn.net/u011815404/article/category/8793969)








> 
# Problem Description

小球球是个可爱的孩子，他喜欢玩具，另外小球球有个大大的柜子，里面放满了玩具，由于柜子太高了，每天小球球都会让妈妈从柜子上拿一些玩具放在地板上让小球球玩。 这天，小球球把所有的N辆玩具摆成一排放在地上，对于每辆玩具i，小球球都会给它涂上一个正整数value[i]，以表示小球球对该玩具的喜爱程度，value[i]越小则表示他越喜爱。当然对于两辆不同的玩具u,v(u<>v)，亦有可能value[i]=value[j]，也就是说小球球对u,v两车的喜爱程度是一样的。 小球球很贪玩，他希望能从中间某个位置，连续的取出k辆玩具，使得这k辆车里喜爱程度最大的一辆车的喜爱程度正好等于k，且这k辆车中没有两辆车的喜爱程度是相同的。小球球希望知道k的最大值为多少。

# **Input**

第一行一个整数N，表示小球球拥有的玩具数量。 接下来N行，每行一个整数，表示value[i]。

# Output

一个整数k，即答案。

# Sample Input

**6241321**

# Sample Output

**4**


思路：

题目实质就是给出一个 n 个数的序列，要求从某一位置开始取 k 个，要求这 k 个数的大小满足从 1~k，问 k 的最大值

首先，k 最小一定为 1，其次，这 k 个数是连续的，也即当一个数满足 1，2，...，k 时，才能更新 k 的最大值，因此可以先找到所有 1 的位置，在每个 1 到左右两个 1 的区间里扫描，然后进行判重统计即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<deque>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define INF 0x3f3f3f3f
#define N 2000001
#define LL long long
const int MOD=998244353;
const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1};
using namespace std;
int a[N];
int pos[N];//记录1的位置
int bucket[N];//用于判重的桶
int main(){
    int n;
    scanf("%d",&n);

    int numOne=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]==1){
            numOne++;
            pos[numOne]=i;
        }
    }

    //两端点最外也视为1
    pos[0]=0;
    pos[numOne+1]=n+1;

    int maxx=0;
    int cnt=0;//选择的个数
    int k;
    queue<int> order;//已选择的玩具，按顺序选择
    priority_queue<int> increasing;//已选择的玩具，保证是单调递增的
    for(int i=1;i<=numOne;i++){
        if(pos[i+1]-1-pos[i-1]>maxx){//两个1之间数的个数
            for(int j=pos[i+1]-1;j>pos[i-1];j--){//遍历两个1之间的数
                if(bucket[a[j]]==0){//没有被选择
                    bucket[a[j]]=1;//选择
                    cnt++;//选择的个数

                    increasing.push(a[j]);//加入单调递增的队列
                    order.push(a[j]);//加入顺序选择的队列
                }
                else{//已被选择
                    while(order.front()!=a[j]){//从已被选择的玩具重新开始选择

                        while(bucket[increasing.top()]==0)//清空没有被选择的
                            increasing.pop();

                        int temp=increasing.top();//按顺序选取的元素
                        if(temp==cnt)//选择的个数与顺序数相对应
                            maxx=max(maxx,temp);

                        //清除已被选择的玩具
                        k=order.front();
                        order.pop();
                        bucket[k]=0;
                        cnt--;
                    }
                }
            }

            if(cnt!=0){

                if(bucket[1]==1)//1一定会被选择，只有当其被选择时，找最大值才有意义
                    if(increasing.top()==cnt)
                        maxx=max(maxx,increasing.top());

                while(!order.empty()){//清空队列
                    k=order.front();
                    bucket[k]=0;
                    cnt--;
                    order.pop();
                }

                while(!increasing.empty())//清空队列
                    increasing.pop();
            }
        }
    }
    printf("%d\n",maxx);

    return 0;
}
```






