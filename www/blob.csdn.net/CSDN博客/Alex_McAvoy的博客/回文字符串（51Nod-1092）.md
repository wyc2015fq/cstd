# 回文字符串（51Nod-1092） - Alex_McAvoy的博客 - CSDN博客





2019年04月15日 21:41:14[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：13
个人分类：[动态规划——线性 DP																[51Nod](https://blog.csdn.net/u011815404/article/category/8862267)](https://blog.csdn.net/u011815404/article/category/7813170)








> 
# 题目

回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。每个字符串都可以通过向中间添加一些字符，使之变为回文字符串。

例如：abbc 添加2个字符可以变为 acbbca，也可以添加3个变为 abbcbba。方案1只需要添加2个字符，是所有方案中添加字符数量最少的。

# 输入

输入一个字符串Str，Str的长度 <= 1000。

# 输出

输出最少添加多少个字符可以使之变为回文字串。

# 输入样例

**abbc**

# 输出样例

**2**


思路：由于要找最少添加的字符使得原字符串变为回文串，那么先将给出的字符串反转，将两字符串做 LCS，得到的是最大的公共子串的长度，那么用字符串长度减去最大公共子串长度就是最少添加字符的个数

# 源程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-12
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1000000007;
const int N=1000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
char str[N];
char reStr[N];
int dp[N][N];
int main() {
    scanf("%s",str+1);
    int len=strlen(str+1);
    for(int i=1,j=len; i<=len+1; i++,j--) {
        reStr[j]=str[i];
    }

    for(int i=1; i<=len; i++) {
        for(int j=1; j<=len; j++) {
            if(str[i]==reStr[j]) {
                dp[i][j]=dp[i-1][j-1]+1;
            } else {
                dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
    }

    int res=len-dp[len][len];

    printf("%d\n",res);
    return 0;
}
```






