# 数论 —— 线性同余方程 - Alex_McAvoy的博客 - CSDN博客





2018年07月31日 14:39:18[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：364








# 【概念】

1.不定方程：未知数的个数多于方程个数，且未知数受到某些限制（如要求是整数）的方程。

2.同余方程

设函数 ![f(x)=a_nx^n+a_{n-1}x^{n-1}+...+a_1x+a_0](https://private.codecogs.com/gif.latex?f%28x%29%3Da_nx%5En&plus;a_%7Bn-1%7Dx%5E%7Bn-1%7D&plus;...&plus;a_1x&plus;a_0)，则称：![f(x)\equiv0(mod\:m)](https://private.codecogs.com/gif.latex?f%28x%29%5Cequiv0%28mod%5C%3Am%29)是关于模 m 的同余方程

3.线性：方程的未知数次数是一次

4.线性同余方程

线性同余方程是最基本的同余方程，形如 ![ax \equiv b (mod\: m)](https://private.codecogs.com/gif.latex?ax%20%5Cequiv%20b%20%28mod%5C%3A%20m%29) 的未知数是 x 的同余式，其中，a、b 是整数，且 ![a\neq 0 (mod\: m)](https://private.codecogs.com/gif.latex?a%5Cneq%200%20%28mod%5C%3A%20m%29)

# 【与线性同余方程有关的定理】

1.定理1：对于二元一次方程 ![a*x+b*y=c](https://private.codecogs.com/gif.latex?a*x&plus;b*y%3Dc) ，其等价为 **![a*x\equiv c(mod \:\,b)](https://private.codecogs.com/gif.latex?a*x%5Cequiv%20c%28mod%20%5C%3A%5C%2Cb%29)**，该方程有整数解的充分条件是 ![c \: \, mod \: \, GCD(a,b)=0](https://private.codecogs.com/gif.latex?c%20%5C%3A%20%5C%2C%20mod%20%5C%3A%20%5C%2C%20GCD%28a%2Cb%29%3D0)，若方程有整数解，则共有 ![GCD(a, b)](https://private.codecogs.com/gif.latex?GCD%28a%2C%20b%29) 个解。

2.定理2：若  ![x_0](https://private.codecogs.com/gif.latex?x_0)、![y_0](https://private.codecogs.com/gif.latex?y_0) 为 ![a*x+b*y=c](https://private.codecogs.com/gif.latex?a*x&plus;b*y%3Dc) 的一组解，则该方程的任一解可表示为：![\left\{\begin{matrix}x=x_0+b*t/GCD(a,b) \\ y=y_0-a*t/GCD(a,b) \end{matrix}\right.,t\in Z](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dx%3Dx_0&plus;b*t/GCD%28a%2Cb%29%20%5C%5C%20y%3Dy_0-a*t/GCD%28a%2Cb%29%20%5Cend%7Bmatrix%7D%5Cright.%2Ct%5Cin%20Z)

注意，上面两个通解公式只能选择其中一个，另一个再根据原方程推出。

3.定理3：若 ![GCD(a,b)=d](https://private.codecogs.com/gif.latex?GCD%28a%2Cb%29%3Dd)，则方程 ![a*x \equiv c (mod \:\,b)](https://private.codecogs.com/gif.latex?a*x%20%5Cequiv%20c%20%28mod%20%5C%3A%5C%2Cb%29) 在 ![[0, b/d - 1]](https://private.codecogs.com/gif.latex?%5B0%2C%20b/d%20-%201%5D) 上有唯一解。

# 【线性同余方程的解的求法】

## 1.使用扩展欧几里德算法求方程的一组解

根据定理1，对于方程 ![a*x+b*y=c](https://private.codecogs.com/gif.latex?a*x&plus;b*y%3Dc) ，用扩展欧几里德算法求出一组 ![x_0](https://private.codecogs.com/gif.latex?x_0)、![y_0](https://private.codecogs.com/gif.latex?y_0)，即令 ![a*x_0+b*y_0=GCD(a,b)](https://private.codecogs.com/gif.latex?a*x_0&plus;b*y_0%3DGCD%28a%2Cb%29)，然后两边同除 ![GCD(a,b)](https://private.codecogs.com/gif.latex?GCD%28a%2Cb%29) ，再乘以 c ，即得方程 ![a*x_0*c/GCD(a,b)+b*y_0*c/GCD(a,b)=c](https://private.codecogs.com/gif.latex?a*x_0*c/GCD%28a%2Cb%29&plus;b*y_0*c/GCD%28a%2Cb%29%3Dc) ，因此可知方程的一组解 ![\left\{\begin{matrix}x=x_0*c/GCD(a,b) \\ y=y_0*c/GCD(a,b) \end{matrix}\right.](https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dx%3Dx_0*c/GCD%28a%2Cb%29%20%5C%5C%20y%3Dy_0*c/GCD%28a%2Cb%29%20%5Cend%7Bmatrix%7D%5Cright.)

## 2.实际应用

实际中，常常被要求去求最小的正整数的解，先通过扩展欧几里德算法求出方程的一组 ![x_0](https://private.codecogs.com/gif.latex?x_0)、![y_0](https://private.codecogs.com/gif.latex?y_0)，再设 ![t=b/GCD(a,b)](https://private.codecogs.com/gif.latex?t%3Db/GCD%28a%2Cb%29) ，通过定理2来拓展方程的解，来调整x的范围，将 ![a*x_0+b*y_0=c](https://private.codecogs.com/gif.latex?a*x_0&plus;b*y_0%3Dc) 拓展为 ![a*(x_0+t*k)+b*(y_0-t*k)=c,k \in Z](https://private.codecogs.com/gif.latex?a*%28x_0&plus;t*k%29&plus;b*%28y_0-t*k%29%3Dc%2Ck%20%5Cin%20Z) ，从而使得所得到的 x 尽可能的小，通过式子 ![x=(x\:\, mod\:\, t+t)\:\,mod\:\,t](https://private.codecogs.com/gif.latex?x%3D%28x%5C%3A%5C%2C%20mod%5C%3A%5C%2C%20t&plus;t%29%5C%3A%5C%2Cmod%5C%3A%5C%2Ct) 来约束结果一定是一个正数，最后所得到的 x 即是一个最小的正整数解。 

# 【模版】

```cpp
#include<iostream>
using namespace std;
int Extended_GCD(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
 
    int temp;
    int gcd=Extended_GCD(b,a%b,x,y);
    temp=x;
    x=y;
    y=temp-a/b*y;
    return gcd;
}
int main()
{
    //形如 ax+by=c
    int a,b,c,x,y;
    cin>>a>>b>>c;
 
    int gcd=Extended_GCD(a,b,x,y);
    if(c%gcd!=0)
        cout<<"无整数解"<<endl;
    else
        cout<<"该方程的一组整数解为：x="<<x*c/gcd<<",y="<<y*c/gcd<<endl;
 
	return 0;
}
```





