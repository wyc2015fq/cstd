# 数论 —— 快速幂与同余式定理 —— 整除与同余 - Alex_McAvoy的博客 - CSDN博客





2018年07月30日 13:38:22[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：151








# 【整除】

## 1.定义

若 ![\exists](https://private.codecogs.com/gif.latex?%5Cexists) q ![\in](https://private.codecogs.com/gif.latex?%5Cin) Z , s.t. b=a*q ，则称 b 被 a 整除，记作 a|b，其中，b 是 a 的倍数，a 是b 的约数。

## 2.性质

1）若 a|b 且 b|c，则：a|c

2）若 a|b 且 a|c，对于 ![\forall](https://private.codecogs.com/gif.latex?%5Cforall) x,y ![\in](https://private.codecogs.com/gif.latex?%5Cin) Z，有：a|(b*x+c*y)

3）若 a|b 且 ![\exists](https://private.codecogs.com/gif.latex?%5Cexists) m![\neq](https://private.codecogs.com/gif.latex?%5Cneq) 0，则：(m*a)|(m*b)

4）若 a|n 且 b|n，当 ![\exists](https://private.codecogs.com/gif.latex?%5Cexists) x,y ![\in](https://private.codecogs.com/gif.latex?%5Cin) Z，满足：a*x+b*y=1 时，有：(a*b)|n

## 3.能被整除的整数的特征

1）0 与 1 的特性：对于任何整数a，总有：1|a；若 a≠0，则：a|0

2）能被 2 整除的数：整数的个位能被 2 整除

3）能被 4 整除的数：整数末尾的两位数能被 4 整除

4）能被 8 整除的数：整数末尾的三位数能被 8 整除

5）能被 3 整除的数：整数各位数字之和能被 3 整除

6）能被 6 整除的数：整数能被 2、3 同时整除

7）能被 9 整除的数：整数各位数字之和能被 9 整除

8）能被 5 整除的数：整数的末位是 0 或 5

9）能被 7 整除的数：截去整数的个位，再减去个位数的 2 倍，若差是 7 的倍数，则原数能被7整除。

**注：若所得新数差太大或扔不易看出是否为 7 的倍数，需要继续上述「截尾、倍大、相减、验差」的过程，直到能判断为止**

10） 能被 11 整除的数：整数的奇位和与偶位和的差能被 11 整除

# 【同余】

## 1.定义

若  ![\exists](https://private.codecogs.com/gif.latex?%5Cexists) a,b ![\in](https://private.codecogs.com/gif.latex?%5Cin) Z，且 m|(a-b)，则称 a 与 b 关于模 m 同余，记为：a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)

同余意味着 a-b=m*k,k ![\in](https://private.codecogs.com/gif.latex?%5Cin) Z，例如：32 ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) 2（mod 5），此时 k=6

## 2.性质

1）基础性质

① 传递性：若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，b ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) c(mod m)，则：a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) c(mod m)

② 对称性：若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，则：b ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) a(mod m)

③ 自反性： a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) a(mod m)

2）运算性质

① 同加性：若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，则：a+c ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b+c(mod m)

② 同幂性：若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，则：![a^{^{n}}](https://private.codecogs.com/gif.latex?a%5E%7B%5E%7Bn%7D%7D)![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv)![b^{^{n}}](https://private.codecogs.com/gif.latex?b%5E%7B%5E%7Bn%7D%7D)(mod m)

③ 同乘性：

     若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，则：a*c ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b*c(mod m)

     若 a ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b(mod m)，c ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) d(mod m)，则：a*c ![\equiv](https://private.codecogs.com/gif.latex?%5Cequiv) b*d(mod m)

3）推论

① 若 a mod p=x，a mod q=x，且 p、q 互质，则 a mod p*q =x

② a*b mod k=(a mod k) *(b mod k) mod k

## 3.大数幂运算快速算法

所谓大数幂运算快速算法，就是计算给出 a，b，m 三个数，快速计算 ![a^{b} mod\: m](https://private.codecogs.com/gif.latex?a%5E%7Bb%7D%20mod%5C%3A%20m) 的值

分析：以求 ![3^{89} mod\; 7](https://private.codecogs.com/gif.latex?3%5E%7B89%7D%20mod%5C%3B%207) 为例

![3^{1}\equiv 3(mod\: \, 7)](https://private.codecogs.com/gif.latex?3%5E%7B1%7D%5Cequiv%203%28mod%5C%3A%20%5C%2C%207%29)

![3^{2}\equiv 3^{2}(mod\: \, 7)\equiv 2(mod\: \, 7)](https://private.codecogs.com/gif.latex?3%5E%7B2%7D%5Cequiv%203%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%202%28mod%5C%3A%20%5C%2C%207%29)

![3^{4}\equiv (3^{2})^{2}(mod\: \, 7)\equiv 4^{2}(mod\: \, 7)\equiv 2](https://private.codecogs.com/gif.latex?3%5E%7B4%7D%5Cequiv%20%283%5E%7B2%7D%29%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%204%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%202)

![3^{8}\equiv (3^{8})^{2}(mod\: \, 7)\equiv 2^{2}(mod\: \, 7)\equiv 4](https://private.codecogs.com/gif.latex?3%5E%7B8%7D%5Cequiv%20%283%5E%7B8%7D%29%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%202%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%204)

![3^{32}\equiv (3^{16})^{2}(mod\: \, 7)\equiv 4^{2}(mod\: \, 7)\equiv 2](https://private.codecogs.com/gif.latex?3%5E%7B32%7D%5Cequiv%20%283%5E%7B16%7D%29%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%204%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%202)

![3^{64}\equiv (3^{32})^{2}(mod\: \, 7)\equiv 2^{2}(mod\: \, 7)\equiv 4](https://private.codecogs.com/gif.latex?3%5E%7B64%7D%5Cequiv%20%283%5E%7B32%7D%29%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%202%5E%7B2%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%204)

![3^{89}\equiv 3^{64}*3^{16}*3^{8}*3^{1}(mod\: \, 7)\equiv 4*4*2*3(mod\: \, 7)\equiv 96(mod\: \, 7)\equiv 5(mod\: \, 7)](https://private.codecogs.com/gif.latex?3%5E%7B89%7D%5Cequiv%203%5E%7B64%7D*3%5E%7B16%7D*3%5E%7B8%7D*3%5E%7B1%7D%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%204*4*2*3%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%2096%28mod%5C%3A%20%5C%2C%207%29%5Cequiv%205%28mod%5C%3A%20%5C%2C%207%29)

因此，可递归的对 n 进行二进制分解，在进行快速幂运算的同时进行求模。

快速幂：[点击这里](https://blog.csdn.net/u011815404/article/details/80920908)

```cpp
int Pow_Mod(int a, int b, int m)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=(res*a)%m;
        a=(a*a)%m;
        b>>=1;
    }
    return res;
}
```

当数非常大时，计算 (a*b)%m 使用 long long 也有可能爆精度，此时需要转乘法为加法，在模拟的同时不断求模

```cpp
LL Mult_Mod(LL a,LL b,LL m)//res=(a*b)%m
{
    a%=m;
    b%=m;
    LL res=0;
    while(b)
    {
        if(b&1)
            res=(res+a)%m;
        a=(a<<=1)%m;
        b>>=1;
    }
    return res%m;
}
LL Pow_Mod(LL a, LL b, LL m)//res=(a^b)%m
{
    LL res=1;
    LL k=a;
    while(b)
    {
        if((b&1))
            res=Mult_Mod(res,k,m)%m;

        k=Mult_Mod(k,k,m)%m;
        b>>=1;
    }
    return res%m;
}
```





