# 滑雪（洛谷-P1434） - Alex_McAvoy的博客 - CSDN博客





2018年07月03日 20:38:58[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：77








## 题目描述

Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：

1 2 3 4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23―┅―3―2―1更长。事实上，这是最长的一条。

## 输入输出格式

**输入格式：**

输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。

**输出格式：**

输出区域中最长滑坡的长度。

## 输入输出样例

**输入样例#1：**

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出样例#1：**
`25`
## 源代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 101
#define MOD 123
#define E 1e-6
using namespace std;
int r,c;
int g[N][N],h[N][N];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
bool judge(int x,int y)
{
    if (x<1||x>r||y<1||y>c)
		return false;
	return true;

}
int dfs(int x,int y)
{
    if(h[x][y])//点的最长步数已知
        return h[x][y];
    else//点的最长步数未知
        h[x][y]=1;

    for(int i=0;i<4;i++)
    {
        int xx=x+dir[i][0];
        int yy=y+dir[i][1];
        if(judge(xx,yy))//当前高度未出界
            if(g[xx][yy]<g[x][y])//如果下一步的高度比当前高度低
                h[x][y]=max(h[x][y],1+dfs(xx,yy));
    }
    return h[x][y];
}
int main()
{
    cin>>r>>c;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin>>g[i][j];

    int maxx=-INF;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            maxx=max(maxx,dfs(i,j));

    cout<<maxx<<endl;
    return 0;
}
```





