# 八皇后（洛谷-P1219） - Alex_McAvoy的博客 - CSDN博客





2018年04月18日 22:47:40[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：112








## 题目描述

检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。

![](https://img-blog.csdn.net/20180418224637109?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


上面的布局可以用序列2 4 6 1 3 5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下：


行号 1 2 3 4 5 6

列号 2 4 6 1 3 5


这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。最后一行是解的总个数。

## 输入输出格式

**输入格式：**

一个数字N (6 <= N <= 13) 表示棋盘是N x N大小的。

**输出格式：**

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 输入输出样例

**输入样例#1：**
`6`
**输出样例#1：**

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

## 源代码

```cpp
#include<iostream>
using namespace std;
int n;
int row[101]={0},column[101]={0},l_diagonal[101]={0},r_diagonal[101]={0};//定义行、列、两条对角线，并初始化为均未封路
int a[101];//用于记录是否可以放置皇后
int sum=0;//用于记录方案数
void dfs(int x);

int main()
{
    cin>>n;//输入棋盘大小
    dfs(1);//开始回溯
    cout<<sum<<endl;//输出方案数
    return 0;
}
 /*
    ①思路：要判断行、列、左对角线、右对角线均未被封，才可以放置一皇后
    ②实现：已知行数x，设置列数y，按列进行循环判断是否被封，如果可以放置，记录到新数组中，封闭四条路，向下进行回溯
    ③其中，行数x，列数，左对角线：x-y+n，右对角线：x+y
    */
void dfs(int x)
{
    int y;
    int i;
    
    if(x==n+1)//如果到达终点，说明方案成功
    {
        sum++;//方案数+1
        if(sum<=3)//输出前三个解的皇后放置的情况
        {
            for(i=1;i<=n;i++)
                cout<<a[i]<<" ";
            cout<<endl;
        }
    }
    
    for(y=1;y<=n;y++)
    {
        if(!row[x]&&!column[y]&&!l_diagonal[x-y+n]&&!r_diagonal[x+y])//如果行、列、左对角线、右对角线均可以下
        {
            a[x]=y;//说明该点可以放置一皇后，记录
            
            row[x]=1;//封闭行
            column[y]=1;//封闭列
            l_diagonal[x-y+n]=1;//封闭左对角线
            r_diagonal[x+y]=1;//封闭右对角线
            
            dfs(x+1);//进行下一层回溯
            
            row[x]=0;//还原行
            column[y]=0;//还原列
            l_diagonal[x-y+n]=0;//还原左对角线
            r_diagonal[x+y]=0;//还原右对角线
        }
    }
}
```





