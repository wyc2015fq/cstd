# 动态规划 —— 背包问题 P01 —— 0-1背包 - Alex_McAvoy的博客 - CSDN博客





2018年03月31日 10:27:22[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：152
个人分类：[动态规划——背包问题](https://blog.csdn.net/u011815404/article/category/7813163)









# 【概述】

    0-1背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成0-1背包问题求解。

    特点：每种物品仅有一件，可以选择放或不放。

# 【题目】

    有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使价值总和最大。

# 【基本思路】

子问题：将前i件物品放入容量为v的背包中。

    若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。
- 如果不放第i件物品，那么子问题就转化为“前i-1件物品放入容量为v的背包中”，价值为：**f[i-1][v]**；
- 如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-w[i]的背包中”，此时能获得的最大价值就是f[i-1][v-w[i]]再加上通过放入第i件物品获得的价值w[i]，即：**f[i-1][v-w[i]]+c[i]**。

用子问题定义状态：f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。

则其状态转移方程：**f[i][v]=max{ f[i-1][v] , f[i-1][v-w[i]]+c[i] }**

# 【初始化的细节问题】

我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。

有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满，而是只希望价格尽量大。一种区别这两种问法的实现方法是在初始化的时候有所不同。
- 如果要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞
- 如果要求价格尽量最大，初始化时应该将f[0..V]全部设为0

原因：**初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。**
- 如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。
- 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。

注：此种方法可推广至各种背包问题，后续不再讲解

# 【优化空间复杂度】

以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。

先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。

那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-w[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-w[i]]的值呢？

事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-w[i]]保存的是状态f[i-1][v-w[i]]的值。

伪代码

```cpp
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-w[i]]+c[i]};
```

    其中，f[v]=max{f[v],f[v-w[i]]}相当于转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]}，因为现在的f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

    事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一件01背包中的物品过程，以后的代码中直接调用不加说明。

伪代码

```cpp
/*
    过程ZeroOnePack，表示处理一件01背包中的物品
    两个参数cost、weight分别表明这件物品的价值和体积
*/
procedure ZeroOnePack(cost,weight)
    for v=V..weight
        f[v]=max{f[v],f[v-weight]+cost}
```

注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f[0..cost-1]，这是显然的。

有了这个过程以后，01背包问题的伪代码就可以这样写：

```cpp
for i=1..N
    ZeroOnePack(c[i],w[i]);
```





