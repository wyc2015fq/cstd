# 迷宫（洛谷-P1605） - Alex_McAvoy的博客 - CSDN博客





2018年04月18日 22:51:38[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：108








> 
## 题目描述

给定一个N*M（1≤N,M≤5）方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

## 输入输出格式

**输入格式：**

第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。

**输出格式：**

给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。

## 输入输出样例

**输入样例#1：**

2 2 1

1 1 2 2

1 2

**输出样例#1：**

1


## 源代码

```cpp
#include<iostream>
using namespace std;

int start_x,start_y,end_x,end_y;
int map[101][101]={0};
int sum=0;
void dfs(int a,int b);

int main()
{
    int n,m,t;
    int i,j;
    int x,y;
    
    cin>>n>>m>>t;//输入行、列、障碍数
    cin>>start_x>>start_y>>end_x>>end_y;//输入起点坐标、终点坐标
    
    for(i=1;i<=n;i++)//地图初始化，为1时表示可以通过
        for(j=1;j<=m;j++)
            map[i][j]=1;

    for(i=1;i<=t;i++)
    {
        cin>>x>>y;//输入障碍物坐标
        map[x][y]=0;//将障碍物坐标记录在地图上
    }
    
    dfs(start_x,start_y);//从起点处开始搜索

    cout<<sum<<endl;//输出方案数

    return 0;
}

void dfs(int x,int y)
{
    if(x==end_x&&y==end_y)//搜索终止条件
    {
        sum++;
        return;
    }
    else//进行回溯
    {
        map[x][y]=0;//保存当前坐标
        
        if(map[x][y-1]!=0)//左方
        {
            dfs(x,y-1);//左方搜索
            map[x][y-1]=1;//还原坐标
        }
        if(map[x][y+1]!=0)//右方
        {
            dfs(x,y+1);//右方搜索
            map[x][y+1]=1;//还原坐标
        }
        if(map[x-1][y]!=0)//上方
        {
            dfs(x-1,y);//上方搜索
         	map[x-1][y]=1;//还原坐标
        }
        if(map[x+1][y]!=0)//下方
        {
            dfs(x+1,y);//下方搜索
            map[x+1][y]=1;//还原坐标
        }
    }
}
```





