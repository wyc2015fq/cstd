# 不要62（HDU-2089） - Alex_McAvoy的博客 - CSDN博客





2018年09月04日 20:13:29[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：62
个人分类：[HDU																[动态规划——数位 DP](https://blog.csdn.net/u011815404/article/category/8008418)](https://blog.csdn.net/u011815404/article/category/7923257)








# Problem Description

杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。

杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。

不吉利的数字为所有含有4或62的号码。例如：

62315 73418 88914

都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。

你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。

# **Input**

输入的都是整数对n、m（0<n≤m<1000000），如果遇到都是0的整数对，则输入结束。

# Output

对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。

# Sample Input

**1 1000 0**

# Sample Output

**80**

————————————————————————————————————————————————————

思路：数位DP入门题。

该题实质是求数位上不能有4也不能有连续的62，在枚举的时候判断是否有4，对于62的话，涉及到两位，当前一位是6或者不是6的两种不同情况计数是不同的，因此要用状态来记录不同的方案数。

用 dp[pos][sta] 表示第 pos 位，前一位是否是 6 的状态，这里的 sta 只需要 0、1 两种状态即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 201
#define MOD 10007
#define E 1e-6
typedef long long LL;
using namespace std;
int a[20];
int dp[20][2];
int dfs(int pos,int pre,int sta,bool limit)
{
    if(pos==-1)
        return 1;
    if(!limit && dp[pos][sta]!=-1)
        return dp[pos][sta];

    int up=limit?a[pos]:9;
    int temp=0;
    for(int i=0;i<=up;i++)
    {
        if(pre==6&&i==2)
            continue;
        if(i==4)
            continue;
        temp+=dfs(pos-1,i,i==6,limit&&i==a[pos]);
    }

    if(!limit)
        dp[pos][sta]=temp;
    return temp;
}
int solve(int x)
{
    int pos=0;
    while(x)
    {
        a[pos++]=x%10;
        x/=10;
    }
    return dfs(pos-1,-1,0,true);
}
int main()
{
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF&&(n+m))
    {
        memset(dp,-1,sizeof(dp));
        printf("%d\n",solve(m)-solve(n-1));
    }
    return 0;
}
```






