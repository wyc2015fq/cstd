# 非常可乐（HDU-1495） - Alex_McAvoy的博客 - CSDN博客





2018年03月19日 19:17:37[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：68
个人分类：[HDU																[搜索——更具技巧的 BFS](https://blog.csdn.net/u011815404/article/category/8228516)](https://blog.csdn.net/u011815404/article/category/7923257)








# Problem Description

    大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N毫升和M毫升 可乐的体积为S毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出"NO"。

# Input

    三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以"0 0 0"结束。

# Output

     如果能平分的话请输出最少要倒的次数，否则输出"NO"。

# Sample Input

**7 4 3    4 1 3    0 0 0**

# Sample Output

**   NO****3**

————————————————————————————————————————————

思路：

    bfs，已知初始状态（s=s，a=0，b=0）和终止状态(s=s/2，a=s/2，b=0)，每一步都有六个可选择的方向（s→a，s→b，a→s，a→b，b→s，b→a），要得到最小的次数。

# Source Program

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <cstdio>
using namespace std;

int s,n,m;
int s_half;
bool vis[101][101][101];

struct node
{
    int s;
    int n;
    int m;
    int step;
}start,v;

int bfs()
{
    queue<node> q;
    memset(vis,true, sizeof(vis));

    if(s%2==1)//无法平分,返回
        return -1;

    s_half=s/2;//记录平分时的容量

    /*初始元素入队*/
    start.s=s;
    start.n=0;
    start.m=0;
    start.step=0;
    q.push(start);

    vis[start.s][start.n][start.m]=false;//进行标记

    while(!q.empty())
    {
        start=q.front();//读取队首元素值
        q.pop();//元素出列

        if((start.s==start.n&&start.s==s_half) || (start.s==start.m&&start.s==s_half) || (start.m==start.n&&start.m ==s_half))//饮料可以平分时，输出最小次数
            return start.step;

        /*s→n*/
        if(start.s&&n-start.n>0)
        {
            if(start.s>n-start.n)//s>n的剩余容量
            {
                v.s=start.s-(n-start.n);
                v.n=n;
                v.m=start.m;
            }
            else//s<=n的剩余容量
            {
                v.s=0;
                v.n=start.n+start.s;
                v.m=start.m;
            }
            if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
        /*s→m*/
        if(start.s&&m-start.m>0)
        {
            if(start.s>m-start.m)//s>m的剩余容量
            {
                v.s=start.s-(m-start.m);
                v.n=start.n;
                v.m=m;
            }
            else//s<=m的剩余容量
            {
                v.s=0;
                v.n=start.n;
                v.m=start.m+start.s;
            }
            if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
        /*n→s*/
        if(start.n&&s-start.s>0)
        {
            if(start.n>s-start.s)//n>s的剩余容量
            {
                v.s=s;
                v.n=start.n-(s-start.s);
                v.m=start.m;
            }
            else//n<=s的剩余容量
            {
                v.s=start.s+start.n;
                v.n=0;
                v.m=start.m;
            }
            if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
        /*n→m*/
        if(start.n&&m-start.m>0)
        {
            if(start.n>m-start.m)//n>m的剩余容量
            {
                v.s=start.s;
                v.n=start.n-(m-start.m);
                v.m=m;
            }
            else//n<=m的剩余容量
            {
                v.s=start.s;
                v.n=0;
                v.m=start.m+start.n;
            }
            if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
        /*m→s*/
        if(start.m&&s-start.s>0)
        {
            if(start.m>s-start.s)//m>s的剩余容量
            {
                v.s=s;
                v.n=start.n;
                v.m=start.m-(s-start.s);
            }
            else//m<=s的剩余容量
            {
                v.s=start.s+start.m;
                v.n=start.n;
                v.m=0;
            }
            if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
        /*m→n*/
        if(start.m&&n-start.n>0)
        {
            if(start.m>n-start.n)//m>n的剩余容量
            {
                v.s=start.s;
                v.n=n;
                v.m=start.m-(n-start.n);
            }
            else//m<=n的剩余容量
            {
                v.s=start.s;
                v.n=start.n+start.m;
                v.m=0;
            }
           if(vis[v.s][v.n][v.m])//若未进行标记过
            {
                vis[v.s][v.n][v.m]=false;//标记
                v.step=start.step+1;//步数+1
                q.push(v);//元素入队
            }
        }
    }

    return -1;
}



int main()
{
    int total;

    while(scanf("%d%d%d",&s,&n,&m)!=EOF)
    {
        if(s==0&&n==0&&m==0)  break;

        total=bfs();
        if(total<0)
            printf("NO\n");
        else
            printf("%d\n",total);
    }

    return 0;
}
```






