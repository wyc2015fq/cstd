# 处女座的砝码（2019牛客寒假算法基础集训营 Day2-C） - Alex_McAvoy的博客 - CSDN博客





2019年03月14日 19:46:44[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：255








> 
# 【题目描述】

处女座热爱做物理实验，为了实验，处女座必须要精确的知道物品的质量。处女座准备自己设计一套砝码，每一个砝码都是正整数，这套砝码必须能够精确测量出n以内所有正整数的质量，处女座想要知道至少需要多少个砝码。你可以在天平的任意一边放置砝码。

# 【输入描述】

一行，一个正整数n

1<=n<=10^1000

# 【输出描述】

一个整数，表示最少的砝码数。

# 【样例】

示例1

输入

20

输出

4

说明

你可以选择1，2，6，11

1=1

2=2

3=1+2

4=6-2

5=6-1

6=6

7=6+1

8=6+2

9=6+2+1

10=11-1

11=11

12=11+1

13=11+2

14=11+2+1

15=11+6-2

16=11+6-1

17=11+6

18=11+6+1

19=11+6+2

20=11+6+2+1


思路：

对于每个砝码，其可以选择放左边、不放、放右边，所以可按照三进制进行排列，即使用 n+1 个砝码，有：

![1,3,3^2,3^3,...,3^n](https://private.codecogs.com/gif.latex?1%2C3%2C3%5E2%2C3%5E3%2C...%2C3%5En)，对于每个 n ，可以称出的范围在 ![[\frac{3^n+1}{2},\frac{3^{n+1}-1}{2}]](https://private.codecogs.com/gif.latex?%5B%5Cfrac%7B3%5En&plus;1%7D%7B2%7D%2C%5Cfrac%7B3%5E%7Bn&plus;1%7D-1%7D%7B2%7D%5D)

因此，假设有 k 个砝码，可以称出不大于 ![\frac{3^{k+1}-1}{2}](https://private.codecogs.com/gif.latex?%5Cfrac%7B3%5E%7Bk&plus;1%7D-1%7D%7B2%7D) 的所有组合

那么对于加入的第 k+1 个砝码 ![3^k](https://private.codecogs.com/gif.latex?3%5Ek) ，有：![\frac{3^k+1}{2}+\frac{3^{k+1}-1}{2}=2*3^k](https://private.codecogs.com/gif.latex?%5Cfrac%7B3%5Ek&plus;1%7D%7B2%7D&plus;%5Cfrac%7B3%5E%7Bk&plus;1%7D-1%7D%7B2%7D%3D2*3%5Ek)

即 ![3^k](https://private.codecogs.com/gif.latex?3%5Ek) 恰好为 ![[\frac{3^k+1}{2},\frac{3^{k+1}-1}{2}]](https://private.codecogs.com/gif.latex?%5B%5Cfrac%7B3%5Ek&plus;1%7D%7B2%7D%2C%5Cfrac%7B3%5E%7Bk&plus;1%7D-1%7D%7B2%7D%5D) 的中值，离两个端点的距离均为 ![\frac{3^{k}-1}{2}](https://private.codecogs.com/gif.latex?%5Cfrac%7B3%5E%7Bk%7D-1%7D%7B2%7D)，这个值正好是 k 个砝码可以覆盖的范围

由于给出的 n 明显超出 long long 的范围，因此需使用大数来结合公式做，![10^{1000}=3^k](https://private.codecogs.com/gif.latex?10%5E%7B1000%7D%3D3%5Ek)，容易解出 k 最大约等于 3000，利用枚举或二分均可以很快的解出 n 的值

# 【源代码】

```java
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input=new Scanner(System.in);
        String str=input.nextLine();
        BigInteger n = new BigInteger(str);
		
        n=n.multiply(new BigInteger("2"));
        n=n.add(n.ONE);

        int left=1,right=3000;
        BigInteger three=new BigInteger("3");
		
        int res=0;
        while(left<=right) {
            int mid=(left+right)/2;
            if(three.pow(mid).compareTo(n)<0) {
                left=mid+1;
            }
            else {
                right=mid-1;
                res=mid;
            }
        }
        System.out.println(res);
    }
}
```





