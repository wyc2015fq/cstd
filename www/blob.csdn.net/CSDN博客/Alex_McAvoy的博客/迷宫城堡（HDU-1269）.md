# 迷宫城堡（HDU-1269） - Alex_McAvoy的博客 - CSDN博客





2018年10月24日 20:26:14[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：58
个人分类：[HDU																[图论——图的连通性](https://blog.csdn.net/u011815404/article/category/8236848)](https://blog.csdn.net/u011815404/article/category/7923257)








> 
# Problem Description

为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。

# Input

输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。

# Output

对于输入的每组数据，如果任意两个房间都是相互连接的，输出"Yes"，否则输出"No"。

# Sample Input

3 3

1 2

2 3

3 1

3 3

1 2

2 3

3 2

0 0

# Sample Output

Yes

No


思路：实质是要判断图是否为一强连通图，Tarjan 算法求强连通分量，判断是否为1即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 20001
#define MOD 16007
#define E 1e-6
#define LL long long
using namespace std;
int n,m;
vector<int> G[N];
stack<int> S;
int dfn[N],low[N];
bool vis[N];
int sccno[N];
int block_cnt;
int sig;
void Tarjan(int x){
    vis[x]=true;
    dfn[x]=low[x]=++block_cnt;
    S.push(x);

    for(int i=0;i<G[x].size();i++){
        int y=G[x][i];
        if(vis[y]==false){
            Tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(!sccno[y])
            low[x]=min(low[x],dfn[y]);
    }

    if(dfn[x]==low[x]){
        sig++;
        while(true){
            int temp=S.top();
            S.pop();
            sccno[temp]=sig;
            if(temp==x)
                break;
        }
    }
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF&&(m+n))
    {
        for(int i=1;i<=n;i++)
            G[i].clear();
        while(m--){
            int x,y;
            scanf("%d%d",&x,&y);
            G[x].push_back(y);
        }

        sig=0;
        block_cnt=0;
        memset(vis,0,sizeof(vis));
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        memset(sccno,0,sizeof(sccno));

        for(int i=1;i<=n;i++)
            if(vis[i]==false)
                Tarjan(i);

        if(sig==1)
            printf("Yes\n");
        else
            printf("No\n");
    }
}
```






