# T1363	小球（#Ⅲ- 3 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年06月09日 23:24:50[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：482








### 【题目描述】

许多的小球一个一个的从一棵满二叉树上掉下来组成FBT（Full Binary Tree，满二叉树），每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。决定球运动方向的是每个节点的布尔值。最初，所有的节点都是false，当访问到一个节点时，如果这个节点是false，则这个球把它变成true，然后从左子树走，继续它的旅程。如果节点是true，则球也会改变它为false，而接下来从右子树走。满二叉树的标记方法如下图:



![](http://ybt.ssoier.cn:8088/pic/1363.gif)







因为所有的节点最初为false，所以第一个球将会访问节点1，节点2和节点4，转变节点的布尔值后在在节点8停止。第二个球将会访问节点1、3、6,在节点12停止。明显地，第三个球在它停止之前，会访问节点1、2、5，在节点10停止。

现在你的任务是，给定FBT的深度D，和I，表示第I个小球下落，你可以假定I不超过给定的FBT的叶子数，写一个程序求小球停止时的叶子序号。

**【输入】**

一行包含两个用空格隔开的整数D和I。其中2≤D≤20，1≤I≤524288。

### 【输出】

对应输出第I个小球下落停止时的叶子序号。

### 【输入样例】
`4 2`
### 【输出样例】
`12`
### 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 1000001
#define MOD 123
#define E 1e-6
using namespace std;
int D,I;
int b[N];
int ans;
void down(int k)
{
    if( pow(2,(D-1))<=k && k<pow(2,D) )
    {
        ans=k;
        return;
    }
    if(b[k])
    {
        b[k]=!b[k];
        down(2*k+1);
    }
    else
    {
        b[k]=!b[k];
        down(2*k);
    }
}
int main()
{
    int i,a;

    cin>>D>>I;
    for(i=1;i<=I;i++)
        down(1);
    cout<<ans<<endl;
    return 0;
}
```





