# 数据结构 —— 并查集 - Alex_McAvoy的博客 - CSDN博客





2018年11月17日 13:56:13[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：98








# 【概述】

并查集（Union-Find Set）是一种用于分离集合操作的抽象数据类型，其处理的是集合（set）之间的关系，一般处理的是图的连通分量，当给出两个的元素的一个无序对 (a,b) 时，需要快速合并(union) a 和 b 所在的集合，这期间需要反复查找(find)某元素的集合。

当遇到有关物与物之间的关系，且这种关系是可传递的问题时，可以优先尝试用并查集解决。

# 【并查集支持的操作】

## 1.操作类型

设 x 表示一个对象，则有：
- Make(x)：建立一个新的集合，其仅有成员是 x(集合代表)，由于各集合是分离的，要求 x 没有在其他集合出现过。
- Union(x,y)：将包含 x、y 的动态集合(Sx、Sy)合并为一个新的集合S。新集合 S 的集合代表是 Sx U Sy 的某个成员。
- Find(x)：返回一个指向包含 x 的集合的代表。

## 2.具体实现

1）初始化

```cpp
for(int i=1;i<=n;i++)//因为每个元素属于单独的一个集合，所以每个元素以自己作为自己的根节点
    father[i]=i;
```

2）寻找根节点编号并压缩路径

```cpp
int Find(int x)//非递归实现
{
    while(father[x]!=x)
        x=father[x];
    return x;
}

int Find(int x)//递归实现—未优化版本
{
    if(father[x]!=x)
        return Find(father[x]);
    else
        return father[x];
}

int Find(int x)//递归实现—优化版本
{
    if(father[x]!=x)
        father[x]=Find(father[x]);//路径压缩，优化核心
    return father[x];
}
```

3）合并两集合

```cpp
void Union(int x,int y)
{
    x=Find(x);
    y=Find(y);
    if(x!=y)
        father[y]=x;
}
```

4）判断元素是否属于同一集合

```cpp
bool judge(int x,int y)
{
    x=Find(x);
    y=Find(y);
    if(x==y)
        return true;
    else 
        return false;
}
```

5）统计集合数目

```cpp
int count_sets(int n)
{
    int cnt=0;
    for(int i=1;i<=n;i++)
        if(father[i]==i)
            cnt++;
	return cnt;
}
```

6）统计每个集合中元素的个数

```cpp
void countElements(){
    for(int i=1;i<=n;i++){
        father[i]=Find(i);//寻找每个节点的父节点
        num[father[i]]++;//统计父节点下的节点个数
    }
    for(int i=1;i<=n;i++)//统计父节点外的点的个数
        num[i]=num[father[i]];
}
```

# 【并查集的删除操作】

对于删除操作，在完美的并查集中（所有节点都直接连接在根节点上），理论上只要把要删除的节点的上级重新指向自己就可以了。

但是实际情况中，并查集形成的树的形态都是不可预估的，如果直接将一个节点指向自己可能会将他的下级和他一起删除，这就与最初的想法违背了，所以在一个需要删除的并查集中初始化时就要处理一下：
- 首先可以将每一个点都设立一个虚拟父节点，这样根节点就是我们设立的虚拟节点，类似于将每个节点放到一个盒子中。
- 如果删除某点，那么可以修改当前节点的父节点来导致当前点的孤立，即删除时把这个节点从当前盒子拿出来，放到另一个盒子中。
- 由于节点之间都是通过盒子来确定关系的，所以盒子中元素是否存在并不影响节点之间的关系。

以下图为例：

![](https://img-blog.csdn.net/20180523211741146)![](https://img-blog.csdn.net/20180523211753109)

如果要删除 2 号节点，那么我们把 2 拿出来放到另一个盒子中就可以了，可以看到原来的那个树结构并没有发生变化。但是 2 已经不在这里面了

实现：

```cpp
//假设最多会有n个节点，就从n+1开始作为假节点

int index;//存放盒子节点使用到哪一个了
void init(int n)
{
    index = n;
    for(int i=0;i<n;i++)//普通节点指向他的盒子节点
        pre[i]=index++;
    for(int i=n;i<2*n;i++)//盒子节点指向自己就像一般的并查集一样
        pre[i]=i;
}

void del(int n)
{
    pre[n]=index;   //将要删除的节点重新指向一个新的盒子
    pre[index]=index++ ;   //盒子节点指向自己
}
```

# 【带权并查集】

## 1.概述

1）定义：带权并查集即是结点存有权值信息的并查集。

2）适用：当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系。

3）权值：带权并查集每个元素的权通常描述其与并查集中祖先的关系，这种关系如何合并，路径压缩时就如何压缩。

4）与并查集的区别：带权并查集可以推算集合内点的关系，而一般并查集只能判断属于某个集合。

## 2.实现

带权并查集只是在并查集中加入了一个 value[N] 数组，与之相应，在 Find 函数与 Union 函数中也有改变。

对于并查集中每一棵树，设树根距离为 0，以树根为参考，每个结点的权值代表与根节点的距离。

合并两个元素时，假设 A、B 属于不同的树，如果合并这两棵树，把 A 树合并到 B 树上，就需要给 A 树跟他的根结点赋值，假设于 A、B 的权值 Wa、Wb，由于两权值代表的都是与根结点的距离，分析可知，给根结点所赋的值=Wa-Wb+x。

此时，对于原来的结点 A，只更新了 A 与他的根结点的权值，因此其他结点的更新在查找中实现即可。

```cpp
int Find(int x)
{
    if(father[x]==x)
        return x;

    int temp=father[x];
    father[x]=Find(father[x]);
    value[x]+=value[temp];//结点a到根的距离

    return father[x];
}

int Union(int x,int y,int w)
{
    int a=Find(x);
    int b=Find(y);

    if(a==b)//如果当前两点与之前距离有冲突
        if(dis[y]!=dis[x]+w)
            return 1;

    father[b]=a;
    dis[b]=dis[x]-dis[y]+w;//计算两点距离

    return 0;
}
```

## 3.常见类型

1）种类问题

种类统计问题比普通并查集新增一属性，常用于表示它和 father[i] 的关系，例如：用 group[i] 表示和 father[i] 的关系，同类可以用 0 表示，其他两种分别用 1 表示该结点被父节点吃，2 表示该节点吃父节点。

2）统计问题

统计问题一般是对某种属性进行统计，新增一属性，在路径压缩时执行即可，例如：cnt[x] += cnt[fa]

3）区间问题

区间问题一般是记录某区间 [l,r] 的数据，此类问题需要对所有值统计设置相同的初值，但初值的大小一般没有影响，对区间 [l, r] 进行记录时，实际上是对 (l-1, r] 操作，即 l = l - 1（势差是在 l-1 和 r 之间） 

# **【例题】**

## 1.基础应用
- 畅通工程（HDU-1232）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80299890)
- A Bug's Life（HDU-1829）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424379)
- 亲戚（信息学奥赛一本通-T1346）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80822624)
- 家庭问题（信息学奥赛一本通-T1362）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80629143)
- 团伙（信息学奥赛一本通-T1385）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80822393)
- 亲戚（信息学奥赛一本通-T1389）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80860232)
- The Suspects（POJ-1611）**(并查集基础应用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/87809857)
- Tree（HDU-5060）**(统计连通块中元素个数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86484259)
- Junk-Mail Filter（HDU 2473）**(并查集删除操作)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80404674)
- 格子游戏（信息学奥赛一本通-T1347）**(块状并查集)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80822394)
- Haybale Guessing （POJ-3657）**(并查集+二分)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80501577)
- Mouse Hunt（CF-1027D）**(并查集判环)**：[点击这里](https://blog.csdn.net/u011815404/article/details/82016973)
- Segment set（HDU-1558）**(并查集+线段计算)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424403)
- Is It A Tree?（HDU-1325）**(并查集+树的构建)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424398)
- 家谱（信息学奥赛一本通-T1388）**(并查集+map的使用)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80860234)
- Wireless Network（POJ-2236）**(并查集判断连通性)**：[点击这里](https://blog.csdn.net/u011815404/article/details/87634177)

## 2.带权并查集
- 搭配购买（信息学奥赛一本通-T1387）**(带权并查集+01背包)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80860235)
- Dragon Balls（HDU-3635）**(带权并查集统计问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424402)
- Cube Stacking（POJ-1988）**(带权并查集统计问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/84189589)
- 打击犯罪（信息学奥赛一本通-T1386）**(带权并查集统计问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80822395)
- How Many Answers Are Wrong（HDU-3038）**(带权并查集区间问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424400)
- Parity game（POJ-1733）**(带权并查集区间问题+数据离散化)**：[点击这里](https://blog.csdn.net/u011815404/article/details/84190244)
- 食物链（POJ-1182）**(带权并查集种类问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/84189758)

	同题：食物链（信息学奥赛一本通-T1390）：[点击这里](https://blog.csdn.net/u011815404/article/details/80860230)
- Rochambeau（POJ-2912）**(带权并查集种类问题)**：[点击这里](https://blog.csdn.net/u011815404/article/details/84189841)
- Zjnu Stadium（HDU-3047）**(带权并查集种类问题+向量计算)**：[点击这里](https://blog.csdn.net/u011815404/article/details/80424401)



