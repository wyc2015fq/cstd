# 图论算法 —— 图论概述 - Alex_McAvoy的博客 - CSDN博客





2018年05月14日 19:21:37[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：806








# 【图】

   图，就是用边连起来的点。

   定义为：graph=（V，E）。V是一个非空有限集合，代表顶点（结点），E代表边的集合。

# 【图的定义与概念】
- 有向图：图的边有方向，只能按箭头方向从一点到另一点。
- 无向图：图的边没有方向，可以双向。
- 结点的度：无向图中与结点相连的边的数目。
- 结点的入度：在有向图中，以这个结点为终点的有向边的数目。
- 结点的出度：在有向图中，以这个结点为起点的有向边的数目。
- 权值：边的费用，可以形象的理解为边的长度。
- 连通：如果图中结点U、V之间存在一条从U通过若干边、点到达V的通路，则称U、V是连通的。
- 回路：起点和终点相同的路径，称为回路，或“环”。
- 无向完全图：一个有 n*(n-1)/2 条边的无向图。
- 有向完全图：一个有 n*(n-1) 条边的优先图。
- 稠密图：一个边数接近完全图的图。
- 稀疏图：一个边数远远少于完全图的图。



![](https://img-blog.csdn.net/20180514194608645)![](https://img-blog.csdn.net/20180514194612363)

                    有向图                                            无向图



# 【图的存储结构】

## 1.二维数组邻接矩阵存储

用 G[i][j] 的值表示从点 i 到点 j 的边的权值

即：G[i][j]=1/权值（Vi与Vj之间有边或弧时）

       G[i][j]=0/∞（Vi与Vj之间无边或无弧时）

![](https://img-blog.csdn.net/20180514195933938)

    参考程序段

```cpp
int g[N][N];
int n;
memset(g,0,sizeof(g));//图的初始化
cin>>n;//读入数据个数
while(n--)
{
    cin>>i>>j>>w;//读入两个顶点序号及权值
    g[i][j]=w;//对于不带权的图，可令g[i][j]=1
    g[j][i]=w;//无向图的对称性，若是有向图，毋需有此句
}
```

## 2.数组模拟邻接表存储

图的邻接表存储法，又称链式存储法，是用链表实现的，大多数情况使用数组模拟即可。

```cpp
struct Edge{
    int next;//下一条边的编号
    int to;//这条边到达的点
    int dis;//这条边的长度
}edge[N];
int head[N];//表头
int num_edge;//内存指针

void add(int from,int to,int dis)//加入一条从from到to距离为dis的单向边
{
    num_edge++;//栈首指针下移
    edge[num_edge].next=head[from];//始点
    edge[num_edge].to=to;//终点
    edge[num_edge].dis=dis;//距离
    head[from]=num_edge;//存储栈首指针
}

int main()
{
    int n,m;
    cin>>n>>m;//读入点数与边数

    num_edge=0;//栈首指针
    for(int i=1;i<=m;i++)
    {
        int u,v,d;
        cin>>u>>v>>d;//读入点u、v与u-v边的长度d
        add(u,v,d);//添加到链表
    }
    for(int i=head[1];i!=0;i=edge[i].next)//遍历从点1开始的所有边
    {
        ......
    }
    
    	......
        
    return 0;
}
```

# 【图的常见算法】
- 图的搜索：[点击这里](https://blog.csdn.net/u011815404/article/details/83188410)
- 图的遍历：[点击这里](https://blog.csdn.net/u011815404/article/details/83539163)
- AOV 网与拓扑排序：[点击这里](https://blog.csdn.net/u011815404/article/details/83715830)
- 图的连通性：[点击这里](https://blog.csdn.net/u011815404/article/details/83217012)
- Floyd 算法：[点击这里](https://blog.csdn.net/u011815404/article/details/83783303)
- Dijkstra 算法：[点击这里](https://blog.csdn.net/u011815404/article/details/83795155)
- Ford 算法与 SPFA：[点击这里](https://blog.csdn.net/u011815404/article/details/83904707)
- 差分约束问题：[点击这里](https://blog.csdn.net/u011815404/article/details/85080659)
- 最小生成树：[点击这里](https://blog.csdn.net/u011815404/article/details/84070642)
- 最小树形图：[点击这里](https://blog.csdn.net/u011815404/article/details/85858501)
- 2-SAT：[点击这里](https://blog.csdn.net/u011815404/article/details/84034034)
- 网络流：[点击这里](https://blog.csdn.net/u011815404/article/details/85260181)
- 二分图∶[点击这里](https://blog.csdn.net/u011815404/article/details/84260940)
- 最大团：[点击这里](https://blog.csdn.net/u011815404/article/details/86609798)
- 延迟认可算法：[点击这里](https://blog.csdn.net/u011815404/article/details/81393497)
- k 短路径问题∶点击这里



