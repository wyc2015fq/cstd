# 命运（HDU-2571） - Alex_McAvoy的博客 - CSDN博客





2018年03月27日 23:32:16[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：66
个人分类：[HDU																[动态规划——线性 DP](https://blog.csdn.net/u011815404/article/category/7813170)](https://blog.csdn.net/u011815404/article/category/7923257)








# Problem Description

    穿过幽谷意味着离大魔王lemon已经无限接近了！可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！

    命运大迷宫可以看成是一个两维的方格阵列，如下图所示：
![](http://acm.hdu.edu.cn/data/images/C164-1005-1.jpg)

    yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。

    现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k>1。 

    为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。

# Input

    输入数据首先是一个整数C，表示测试数据的组数。

    每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1<=n<=20,10<=m<=1000)；

    接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|<100 )。 

# Output

    对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。

# Sample Input

**13 89 10 10 10 10 -10 10 1010 -11 -1 0 2 11 10 -20-11 -11 10 11 2 10 -10 -10**

# Sample Output

**52**

————————————————————————————————————————————

思路：

设：dp[i][j]是第i行第j列的幸运值的和

则：

    状态方程：

        向下与向右走一格的情况：dp[i][j]=max(dp[i-1][j],dp[i][j-1]);

        走当前所在列数倍数格的情况：dp[i][j]=max(dp[i][j],dp[i][j/k]);

        最后记得加上当前格的值：dp[i][j]+=num[i][j];

    边界条件：dp[1][0]=0;

                    dp[0][1]=0;

注意：由于存在负数，需将dp初始化为一个极小的负数。

# Source Program

```cpp
#include<iostream>
#include<cstring>
#define N 1001
using namespace std;

int num[21][N];
int dp[21][N];

int main()
{
    int c,n,m;
    int i,j,k;

    cin>>c;
    while(c--)
    {
        cin>>n>>m;
        for(i=1;i<=n;i++)
            for(j=1;j<=m;j++)
                cin>>num[i][j];

        /*由于存在负数，需初始化为一很大的负数*/
        for(i=0;i<=n;i++)
            dp[i][0]=-999999;
        for(j=0;j<=m;j++)
            dp[0][j]=-999999;

        /*边界条件*/
        dp[1][0]=0;
        dp[0][1]=0;

        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);//向下与向右走一格的情况
                for(k=2;k<=m;k++)//走当前所在列数倍数格的情况
                    if(j%k==0)
                        dp[i][j]=max(dp[i][j],dp[i][j/k]);

                dp[i][j]+=num[i][j];//加上当前格的值
            }
        }
        cout<<dp[n][m]<<endl;
    }

}
```




