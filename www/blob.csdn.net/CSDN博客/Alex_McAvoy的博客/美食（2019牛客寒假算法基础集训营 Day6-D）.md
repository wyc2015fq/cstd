# 美食（2019牛客寒假算法基础集训营 Day6-D） - Alex_McAvoy的博客 - CSDN博客





2019年03月10日 19:35:32[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：16
个人分类：[牛客																[基础算法——贪心](https://blog.csdn.net/u011815404/article/category/7628972)](https://blog.csdn.net/u011815404/article/category/8639591)








> 
# 【题目描述】

小B喜欢美食。

现在有n个美食排成一排摆在小B的面前，依次编号为1..n，编号为i的食物大小为 a[i] ，即足够小B吃 a[i] 口。

小B每次会吃两口，这两口要么是编号相同的美食，要么是编号之差的绝对值为1的美食。

小B想知道，她最多能吃几次？

# 【输入描述】

第1行一个正整数n，表示美食个数

接下来n行，第i行一个整数a[i]，表示编号为i的美食的大小

# 【输出描述】

一个数表示小B最多吃几次。

# 【样例】

示例1

输入

4

1

5

7

8

输出

10

说明

用二元组(a,b)表示某一次吃的两个美食分别为第a个美食和第b个美食，则下面为一个吃10次的方案：

(1,2)(2,2)(2,2)(3,4)(3,4)(3,4)(3,4)(3,4)(3,4)(3,4)

注意不一定要吃完。


思路：贪心

在偶数和奇数相邻的情况下，各吃一口和奇数剩一口结果是一样的，因此遇到偶数全吃，遇到奇数当前吃一口，下一次吃一口，直到吃到剩下最后一个

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1E9+7;
const int N=5000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

LL a[N];
int main(){
    int n;
	scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);

    LL sum=0;
    for(int i=1;i<=n;i++){
        if(a[i]%2){//奇数
            if(a[i+1]!=0){//到最后一个为止
                a[i]--;
                a[i+1]--;
                sum++;
            }
            sum+=a[i]/2;
            a[i]=0;
        }
        else{//偶数
            sum+=a[i]/2;
            a[i]=0;
        }
    }
    printf("%lld\n",sum);

	return 0;
}
```






