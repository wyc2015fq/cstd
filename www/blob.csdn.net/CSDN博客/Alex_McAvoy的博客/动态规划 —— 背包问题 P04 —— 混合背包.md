# 动态规划 —— 背包问题 P04 —— 混合背包 - Alex_McAvoy的博客 - CSDN博客





2018年05月02日 21:04:52[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：60








# 【概述】

如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

# 【01背包与完全背包的混合】

考虑到在P01和P02中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。

伪代码：

```cpp
for i=1..N
    if 第i件物品是01背包(只取一次时)
        for v=V..0
            f[v]=max{f[v],f[v-w[i]]+c[i]};
    else if 第i件物品是完全背包(可以取无限多时)
        for v=0..V
            f[v]=max{f[v],f[v-w[i]]+c[i]};
```

# 【加上多重背包】

如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。

当然，更清晰的写法是调用我们前面给出的三个相关过程。

```cpp
for i=1..N
    if 第i件物品是01背包(只取一次时)
        ZeroOnePack(c[i],w[i])
    else if 第i件物品是完全背包(可以取无限多时)
        CompletePack(c[i],w[i])
    else if 第i件物品是多重背包(有固定取的次数时)
        MultiplePack(c[i],w[i],n[i])
```





