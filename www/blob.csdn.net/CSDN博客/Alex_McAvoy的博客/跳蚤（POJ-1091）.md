# 跳蚤（POJ-1091） - Alex_McAvoy的博客 - CSDN博客





2018年08月14日 17:20:54[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：155








> 
# Problem Description

Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。 

比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。 

当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 

# **Input**

两个整数N和M(N <= 15 , M <= 100000000)。

# Output

可以完成任务的卡片数。

# Sample Input

**2 4**

# Sample Output

**12**


思路：

实质是给出 m、n 两个数，求满足等式：a[1]*x1+a[2]*x2+...+a[n]*xn+a[n+1]*x(n+1)=1，一共有多少种情况

那么就要先求出m的所有质因子，然后求出总的排列组合的个数，即M^N，最后根据容斥原理求得最后答案。

即有公因数 d 的 n 组，每个位置上有 (m/d) 个选择，因此答案即为 (m/d)^n 种

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 10001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
LL n,m;
LL factor[N];
LL sum[N];
LL num,cnt;
void Get_Factor()//分解质因子
{
    num=0;
    LL temp=m;
    for(LL i=2;i*i<=temp;i++)
    {
        if(temp%i==0)
        {
            factor[num++]=i;
            while(temp%i==0)
                temp=temp/i;
        }
    }
    if(temp!=1)
        factor[num++]=temp;
}

LL quick_pow(LL a,LL b)
{
    LL r=1,base=a;
    while(b)
    {
    	if(b&1)
            r*=base;
    	base*=base;
    	b>>=1;
    }
    return r;
}

LL dfs(LL a,LL b,LL c)
{
    if(b==c)
    {
        LL temp=m;
        for(LL i=0;i<c;i++)
            temp/=sum[i];
        cnt+=quick_pow(temp,n);
    }
    else
    {
        for(LL i=a;i<num;i++)
        {
            sum[b]=factor[i];
            dfs(i+1,b+1,c);
        }
    }
}

int main()
{
    while(scanf("%lld%lld",&n,&m)!=EOF&&(n+m))
    {
        Get_Factor();
        LL ans=quick_pow(m,n);
        for(LL i=1;i<=num;i++)
        {
            cnt=0;
            dfs(0,0,i);
            if(i%2)
                ans-=cnt;
            else
                ans+=cnt;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```





