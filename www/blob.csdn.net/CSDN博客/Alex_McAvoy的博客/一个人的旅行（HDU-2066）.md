# 一个人的旅行（HDU-2066） - Alex_McAvoy的博客 - CSDN博客





2018年05月21日 23:42:45[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：50








> 
# Problem Description

虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。

# **Input**

输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；

接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=<(a,b)<=1000，a,b 之间可能有多条路)

接着的第T+1行有S个数，表示和草儿家相连的城市；

 接着的第T+2行有D个数，表示草儿想去地方。

# Output

输出草儿能去某个喜欢的城市的最短时间。

# Sample Input

**6 2 3**

**1 3 51 4 72 8 123 8 44 9 129 10 21 28 9 10**

# Sample Output

**1**


思路：最短路经典例题，套用Dijkstra算法即可

# Source Program

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#define INF 999999999
#define N 1001
#define MOD 1000000007
#define E 1e-12
using namespace std;
int g[N][N];
int vis[N],w[N];
int s[N],e[N];
int main()
{
    int T,S,D;

    int start,end;
    while(scanf("%d%d%d",&T,&S,&D)!=EOF)
    {
        int n=-INF;
        for(int i=0;i<N;i++)
        {
            for(int j=0;j<N;j++)
                g[i][j]=INF;
            g[i][i]=-INF;
        }
        memset(vis,0,sizeof(vis));


        while(T--)
        {
            int x,y,w;
            scanf("%d%d%d",&x,&y,&w);
            n=max(max(n,x),y);
            if(w<g[x][y])
                g[x][y]=g[y][x]=w;
        }

        int minn = INF;
        for(int i=0;i<S;i++)
        {
            scanf("%d",&s[i]);
            g[0][s[i]]=g[s[i]][0]=0;
        }
        for(int i=0;i<D;i++)
            scanf("%d",&e[i]);

        for(int i=0;i<=n;i++)
            w[i]=g[0][i];
        for(int i=1;i<=n;i++)
        {
            int k;
            minn=INF;
            for(int j=1;j<=n;j++)
            {
                if(w[j]<minn && !vis[j])
                {
                    k=j;
                    minn=w[j];
                }
            }
            vis[k]=1;
            for(int j=1;j<=n;j++)
                if( w[k]+g[k][j]<w[j] && !vis[j])
                    w[j]=w[k]+g[k][j];
        }

        for(int i=0;i<D;i++)
            minn=min(minn,w[e[i]]);
        printf("%d\n",minn);
    }
    return 0;
}
```





