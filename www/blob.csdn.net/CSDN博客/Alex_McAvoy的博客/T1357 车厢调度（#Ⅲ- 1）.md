# T1357 车厢调度（#Ⅲ- 1） - Alex_McAvoy的博客 - CSDN博客





2018年04月19日 22:42:35[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：734
个人分类：[信息学奥赛一本通																[STL 的使用——容器与迭代器](https://blog.csdn.net/u011815404/article/category/8793969)](https://blog.csdn.net/u011815404/article/category/7429967)








> 
# 【题目描述】

有一个火车站，铁路如图所示，每辆火车从A驶入，再从B方向驶出，同时它的车厢可以重新组合。假设从A方向驶来的火车有n节（n≤1000），分别按照顺序编号为1，2，3，…，n。假定在进入车站前，每节车厢之间都不是连着的，并且它们可以自行移动到B处的铁轨上。另外假定车站C可以停放任意多节车厢。但是一旦进入车站C，它就不能再回到A方向的铁轨上了，并且一旦当它进入B方向的铁轨，它就不能再回到车站C。
![](https://img-blog.csdn.net/20180419224223219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

负责车厢调度的工作人员需要知道能否使它以a1,a2,…,an的顺序从B方向驶出，请来判断能否得到指定的车厢顺序。

# 【输入】

第一行为一个整数n，其中n≤1000，表示有n节车厢，第二行为n个数字，表示指定的车厢顺序。

# **【输出】**

如果可以得到指定的车厢顺序，则输出一个字符串”YES”，否则输出”NO”（注意要大写，不包含引号）。

# 【输入样例】

**55 4 3 2 1**

# 【输出样例】

**YES**

# 【提示】

观察发现，整个调度过程其实是在模拟入栈出栈的过程，而这个过程中，我们可以分成三种状态：栈前、栈中、栈后。我们可以发现，当某个数字出栈了，说明比它小的数字要么已经出栈了，要么还在栈里，不能是入栈前状态，并且在栈中的顺序是从大到小的(从栈顶往栈底看)，比如出5，那么1，2，3，4要么已经在5之前出了，要么还在栈中（假如1，3，4在栈中，从栈顶往栈底看依次为4，3，1），不能是入栈前的状态。如果某个数字要出栈，那么当前在栈中的数字都必须小于它，否则就与栈的性质矛盾，不合法，于是我们可以这样解决：

从第一个数字开始扫描，a[i]表示当前出栈的数字，如果有比a[i]大的数字还在栈中，那么就产生矛盾，输出“NO”；否则，标记当前数字a[i]为栈后状态，那么[1, a[i]-1]这些数字如果还没出栈，标记为栈中状态。具体我们可以用0表示为确定状态，1表示栈中状态，2表示栈后状态。


# 【源程序】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=1000000007;
const int N=10000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;
int a[N];
stack<int> S;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)//a[i]为到达B站的车厢
        cin>>a[i];

    int cur=1;//cur为需要进栈的车厢
    for(int i=1;i<=n;i++)//进栈,到达A站；出栈,到达B站
    {
        while(cur<=a[i])//比a[i]小的车厢都要在栈中
            S.push(cur++);
        if(S.top()==a[i])//将a[i]弹出栈
            S.pop();
        else
        {
            cout<<"NO"<<endl;
            return 0;
        }
    }
    cout<<"YES"<<endl;
    return 0;
}
```






