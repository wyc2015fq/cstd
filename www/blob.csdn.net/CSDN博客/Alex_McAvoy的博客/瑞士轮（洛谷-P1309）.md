# 瑞士轮（洛谷-P1309） - Alex_McAvoy的博客 - CSDN博客





2018年04月10日 23:39:35[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：86








## 题目背景

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。

## 题目描述

2*N 名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K – 1 名和第 2K名、…… 、第2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

## 输入输出格式

**输入格式：**

输入的第一行是三个正整数N、R 、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。

第二行是2*N 个非负整数s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为i 的选手的初始分数。 第三行是2*N 个正整数w1 , w2 , …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。

**输出格式：**

输出只有一行，包含一个整数，即R 轮比赛结束后，排名第 Q 的选手的编号。

## 输入输出样例

**输入样例#1：**

```
2 4 2 
7 6 6 7 
10 5 20 15
```

**输出样例#1：**
`1`
## 说明

【样例解释】

![](https://img-blog.csdn.net/20180818125425239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



【数据范围】

对于30% 的数据，1 ≤ N ≤ 100；

对于50% 的数据，1 ≤ N ≤ 10,000 ；

对于100%的数据，1 ≤ N ≤ 100,000，1 ≤ R ≤ 50，1 ≤ Q ≤ 2N，0 ≤ s1, s2, …, s2N≤10^8，1 ≤w1, w2 , …, w2N≤ 10^8。

———————————————————————————————————————————————

思路：

暴力+归并

每一次两两比较，赢的放在一个数组，输的放在另一个数组，因为之前已经有序，可以保证两数组前面的排名在后面之前，所以只要比较从两数组开头开始比就可以。

## 源代码

```cpp
#include<iostream>
#include <algorithm>
using namespace std;
int N,R,Q;
int initial[200000]={0},strength[200000]={0},order[2000000]={0};
int a[100000],b[100000];

bool cmp(int x,int y)
{
    if(initial[x]!=initial[y]) return initial[x]>initial[y];
    return x<y;
}

void merge_sort(int order[])
{
    int i,j,k;
    
    for(i=0,j=0,k=0;i<N&&j<N;k++)//合并a，b
    {
        if(cmp(a[i],b[j]))
        {
            order[k]=a[i];
            i++;
        }
        else
        {
            order[k]=b[j];
            j++;
        }
    }
        
    for(;i<N;i++,k++)	order[k]=a[i];//复制左边子序列剩余
    for(;j<N;j++,k++)	order[k]=b[j];//复制右边子序列剩余

}


int main()
{
    int i;

    cin>>N>>R>>Q;
    for(i=1;i<=2*N;i++)	cin>>initial[i];
    for(i=1;i<=2*N;i++)	cin>>strength[i];
    for(i=0;i<2*N;i++)	order[i]=i+1;
    
    sort(order,order+2*N,cmp);//以成员序号order为i，对基础成绩进行降序排序
    
    for(;R>0;R--)//共进行进行R轮比赛
    {
        for(i=0;i<N;i++)//每轮进行N次
        {
            if( strength[order[2*i]] > strength[order[2*i+1]] )
            {
                initial[order[2*i]]++;
                a[i]=order[2*i];
                b[i]=order[2*i+1];
            }
            else
            {
                initial[order[2*i+1]]++;
                a[i]=order[2*i+1];
                b[i]=order[2*i];
            }
        }
        merge_sort(order);//合并结果到order
    }
    
    cout<<order[Q-1]<<endl;
    return 0;
}
```



