# 查找 —— 分块查找 - Alex_McAvoy的博客 - CSDN博客





2018年04月29日 14:45:30[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：90








# **【概述】**

有时候，可能会遇到这样的表：整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。我们称这种为分块有序。

# 【方法】

需要先建立一个索引表，索引表中为每一块都设置–索引项，每一个索引项都包含两个内容：该块的起始地址、该块中最大（或最小）的元素。

显然，索引表是按关键字递增或递减次序排列的。

如图 

![](https://img-blog.csdn.net/20180429143703336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

将n个数据元素"按块有序"划分为m块（m ≤ n），每一块中的结点不必有序，但块与块之间必须"按块有序"

即：第 1 块中任一元素的关键字都必须小于第 2 块中任一元素的关键字，而第 2 块中任一元素又都必须小于第 3 块中的任一元素，以此类推。

# 【过程】

在前面建立的索引表的基础上，查找一个关键字需要两个步骤：

step1 先选取各块中的最大关键字构成一个索引表

step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中

然后，在已确定的块中用顺序法进行查找。

# 【源程序】

```cpp
#include <stdio.h>
struct index //定义块的结构
{
    int key;
    int start;
	int end;
}index_table[4];
int block_search(int key, int a[]) //自定义实现分块查找
{
	int i, j;
	i = 1;
	while (i <= 3 && key > index_table[i].key) //确定在那个块中
		i++;
	if (i > 3) //大于分得的块数，则返回0
		return 0;
	j = index_table[i].start; //j等于块范围的起始值
	while (j <= index_table[i].end && a[j] != key) //在确定的块内进行查找
		j++;
	if (j > index_table[i].end) //如果大于块范围的结束值，则说明没有要查找的数,j置0
		j = 0;
	return j;
}
int main()
{
	int i, j = 0, k, key, a[16];
	printf("please input the number:\n");
	for (i = 1; i < 16; i++)
		scanf("%d", &a[i]); //输入由小到大的15个数
	for (i = 1; i <= 3; i++)
	{
		index_table[i].start = j + 1; //确定每个块范围的起始值
		j = j + 1;
		index_table[i].end = j + 4; //确定每个块范围的结束值
		j = j + 4;
		index_table[i].key = a[j]; //确定每个块范围中元素的最大值
	}
	printf("please input the number which do you want to search:\n");
	scanf("%d", &key); //输入要查询的数值
	k = block_search(key, a); //调用函数进行查找
	if (k != 0)
		printf("success.the position is :%d\n", k); //如果找到该数，则输出其位置
	else
		printf("no found!"); //若未找到则输出提示信息
}
```



