# T1413	确定进制（#Ⅰ- 6 - 1） - Alex_McAvoy的博客 - CSDN博客





2018年03月10日 22:27:36[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：1613








### 【题目描述】



6*9=42对于十进制来说是错误的，但是对于13进制来说是正确的。即6(13)*9(13)=42(13)，而 42(13)=4*131+2*130=54(10)。

    你的任务是写一段程序，读入三个整数p、q和 r，然后确定一个进制 B(2≤B≤40) 使得p*q=r。如果 B 有很多选择, 输出最小的一个。
  例如：p=11, q=11, r=121.则有11(3)*11(3)=121(3)因为 11(3)=1*31+1*30=4(10)和121(3)=1*32+2*31+1*30=16(10)。对于进制 10，同样有11(10)* 11(10)= 121(10)。这种情况下，应该输出 3。如果没有合适的进制，则输出 0。

### 【输入】

一行，包含三个整数p、q、r。 p、q、r的所有位都是数字，并且1 ≤ p、q、r ≤ 1,000,000。


### 【输出】

一个整数：即使得p*q=r成立的最小的B。如果没有合适的B，则输出0。


### 【输入样例】

6 9 42

### 【输出样例】

13

### 【源程序】

```cpp
#include<iostream>
using namespace std;
int judge(int x,int B);

int main()
{
	int a,b,c;
	int i;
	
	cin>>a>>b>>c;
	for(i=2;i<=40;i++)//枚举2-40进制
		if(judge(a,i)*judge(b,i)==judge(c,i))//找到使a*b=c成立的最小进制B
		{
			cout<<i<<endl;
			return 0;
		}
	cout<<0<<endl;
	return 0;
}

int judge(int x,int B)
{
	int value=1,num=0;
	while(x!=0)//将一个数化为B进制数
	{
		if((x%10)>=B)//B进制下不可能出现大于等于B的数位
			return 99999;
		num+=((x%10)*value);
		value*=B;
		x/=10;
	}
	return num;
}
```




