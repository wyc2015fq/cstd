# 动态规划 —— 背包问题 P05 —— 二维背包 - Alex_McAvoy的博客 - CSDN博客





2018年05月02日 21:08:06[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：113








# 【问题】

对于每件物品，具有两种不同的体积，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）。

问：怎样选择物品可以得到最大的价值？

设：这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为c[i]。

# 【算法】

费用加了一维，只需状态也加一维即可。

设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。

状态转移方程就是：**f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+c[i]}**

如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。

# 【物品总个数的限制】

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。

# 【实现】

设s[i][j][k]表示将前i件物品放入两种容量分别为j和k的背包时所能获得的最大价值，则状态转移方程为f[i][j][k]=max{f[i-1][j][k], f[i-1][j-v[i]][k-u[i]]+c[i]}，递推边界为当i=0时f[i][j][k]=0。和01背包类似，状态的维数可以轻易的从三维降低到二维，具体实现见下。

```cpp
for (int i=0; i<=V; i++) // 边界
      for (int j=0; j<=U; j++)
          s[i][j]=0; 
for (int i=1; i<=N; i++)
      for (int j=V; j>=v[i]; j--)
            for (int k=U; k>=u[i]; k--) 
                s[j][k]=max(s[j][k], s[j-v[i]][k-u[i]]+c[i]);
```





