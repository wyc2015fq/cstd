# 数论 —— 素性测试 - Alex_McAvoy的博客 - CSDN博客





2018年08月01日 10:45:03[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：328








# 【概述】

判断素数是一个较常涉及的内容，所谓素性测试是检测一个数是否为素数的测试。

# 【试除法】

当数据范围较小的情况下，判断素数可从判断 2 到 sqrt(n) 或者 n/2 ，看能不能整除 n，若能整除就不是素数。

```cpp
bool judge(int n)
{
    if(n==1)//为1时，不是
        return false;

    for(int i=2;i<sqrt(n);i++)//如果能被整除，不是
        if(n%i==0)
            retrun false;

    return true;
}
```

# 【埃拉托斯特尼筛法】

对于数据范围较大的情况下，可以使用打表的方法，求出素数表，是一般的线性筛法。

初始时，先假设所有数都是素数，从2开始枚举，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数，把这些合数都筛掉，继续向下枚举，直至所有数枚举完毕。

![](https://img-blog.csdn.net/2018080113592070?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```cpp
int prime[N],cnt;
bool bprime[N];
void make_prime()
{
    memset(bprime,false,sizeof(bprime));

    for(int i=2;i<=N;i++)
    {
        if(!bprime[i])
        {
            prime[cnt++]=i;
            for(LL j=i*2;j<=N;j+=i)
                bprime[j]=true;
        }
    }
}
```

# 【快速线性筛法】

仔细分析埃拉托斯特尼筛法可发现，这种方法会造成重复筛除合数，影响效率。

以 30 为例，在 i=2 的时候，k=2*15 筛了一次；在i=5，k=5*6 的时候又筛了一次。

未避免冗余，提高效率，也就有了快速线性筛法，其可保证不会重复删除一个数。

原理：

① 如果 i 是素数，那么一个大的素数 i 乘以一个不大于 i 的素数，这样筛出的数都是：![n=p_1*p_2](https://private.codecogs.com/gif.latex?n%3Dp_1*p_2) 形式的，是不会重复的。

② 如果 i 是合数，此时 i 可以表示为递增素数相乘，即：![i=p_1*p_2*...*p_n,2\leqslant i\leqslant n](https://private.codecogs.com/gif.latex?i%3Dp_1*p_2*...*p_n%2C2%5Cleqslant%20i%5Cleqslant%20n)，P1 是最小的系数。

③ 当执行到 p1=prime[j] 的时候，筛选就终止了，也即只能筛选出 不大于 p1 的素数 * i

```cpp
int prime[N],cnt;
bool bPrime[N];
void getPrimes(int n)
{
    memset(bPrime,false,sizeof(bPrime));
 
    for(int i=2;i<=n;i++)
    {
        if(!bPrime[i])
            primes[cnt++]=i;
 
        for(int j=0;j<cnt&&i*primes[j]<N;j++)
        {
            bPrime[i*primes[j]]=true;
            if(i%primes[j]==0)
                break;
        }
    }
}
```

# 【Miller-Rabin 算法】

Miller-Rabin 算法是一个随机算法，随机生成几个 a 利用费马小定理与二次探测定理来检测素数。

只需要多次寻找不超过 n-1 基并检验是否有 ![a^{p-1} \equiv 1(mod\:\, p)](https://private.codecogs.com/gif.latex?a%5E%7Bp-1%7D%20%5Cequiv%201%28mod%5C%3A%5C%2C%20p%29)， 如果一直有， 那么这个数大概率就是一个素数，否则可以立即判定这个数是个合数。

虽然看似没有问题，但却存在一些数，对于 a 的某些选择可以骗过该算法，这些数虽然不是素数，但却对所有与 p 互素的 0<a<p 满足 ![a^{p-1} \equiv 1(mod\:\, p)](https://private.codecogs.com/gif.latex?a%5E%7Bp-1%7D%20%5Cequiv%201%28mod%5C%3A%5C%2C%20p%29)，因此，还需要附加二次探测定理的测试来改进不出错的几率。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<set>
#include<map>
#include<stack>
#include<ctime>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 10001
#define MOD 123
#define E 1e-6
#define LL long long
using namespace std;
LL Mult_Mod(LL a,LL b,LL m)//res=(a*b)%m
{
    a%=m;
    b%=m;
    LL res=0;
    while(b)
    {
        if(b&1)
            res=(res+a)%m;
        a=(a<<=1)%m;
        b>>=1;
    }
    return res%m;
}
LL Pow_Mod(LL a, LL b, LL m)//res=(a^b)%m
{
    LL res=1;
    LL k=a;
    while(b)
    {
        if((b&1))
            res=Mult_Mod(res,k,m)%m;

        k=Mult_Mod(k,k,m)%m;
        b>>=1;
    }
    return res%m;
}
bool Witness(LL a,LL n,LL x,LL sum)
{
    LL judge=Pow_Mod(a,x,n);
    if(judge==n-1||judge==1)
        return 1;

    while(sum--)
    {
        judge=Mult_Mod(judge,judge,n);
        if(judge==n-1)
            return 1;
    }
    return 0;
}
bool Miller_Rabin(LL n)
{
    if(n<2)
        return 0;
    if(n==2)
        return 1;
    if((n&1)==0)
        return 0;

    LL x=n-1;
    LL sum=0;
    while(x%2==0)
    {
        x>>=1;
        sum++;
    }


    int times=20;
    for(LL i=1;i<=times;i++)
    {
        LL a=rand()%(n-1)+1;//取与p互质的整数a
        if(!Witness(a,n,x,sum))//费马小定理的随机数检验
            return 0;
    }
    return 1;
}
int main()
{
    int p;
    cin>>p;

    if(Miller_Rabin(p))
        cout<<p<<"可能是素数"<<endl;
    else
        cout<<p<<"是合数"<<endl;

    return 0;
}
```

# 【例题】
- 回文质数（洛谷-P1217）**(构造回文+判素数)**：[点击这里](http://blog.csdn.net/u011815404/article/details/79394708)
- Pseudoprime numbers（POJ-3641）**(快速幂取模+判素数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81565120)
- 哥德巴赫猜想（升级版）（洛谷-P1579）**(试除法判素数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/79402751)
- Goldbach's Conjecture（POJ-2262）**(试除法判素数)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81569095)
- Reversing Encryption（CF-999B）**(素数打表)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81485353)
- Bi-shoe and Phi-shoe（LightOJ-1370）**(素数打表)**：[点击这里](https://blog.csdn.net/u011815404/article/details/88648971)
- 处女座的测验（一）（2019牛客寒假算法基础集训营 Day2-H）**(素数打表+积性函数的推导)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86633960)
- 处女座的测验（二）（2019牛客寒假算法基础集训营 Day2-I）**(素数打表+素因子与最高次幂+剪枝)**：[点击这里](https://blog.csdn.net/u011815404/article/details/86634101)
- Sum of Consecutive Prime Numbers（POJ-2739）**(线性筛素数+打表+dfs)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81559930)
- Prime Gap（POJ-3518）**(快速线性筛素数+打表判断)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81585292)
- Prime Cuts（POJ-1595）**(快速线性筛素数+打表判断)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81585468)
- Goldbach's Conjecture（HDU-1397）**(快速线性筛素数+打表判断)**：[点击这里](https://blog.csdn.net/u011815404/article/details/81590618)



