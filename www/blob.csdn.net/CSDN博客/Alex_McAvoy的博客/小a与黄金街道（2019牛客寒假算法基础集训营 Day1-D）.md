# 小a与黄金街道（2019牛客寒假算法基础集训营 Day1-D） - Alex_McAvoy的博客 - CSDN博客





2019年02月11日 20:46:12[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：74








> 
# 【题目描述】

小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。

游戏规则是这样的：

假设道路长度为n米(左端点为0，右端点为n)，同时给出一个数k(下面会提到k的用法)

设小a初始时的黄金数量为A，小b初始时的黄金数量为B小a从1出发走向n−1，小b从n−1出发走向1，两人的速度均为1m/s

假设某一时刻(必须为整数)小a的位置为x，小b的位置为y，若gcd(n,x)=1且gcd(n,y)=1，那么小a的黄金数量A会变为A∗kx(kg)，小b的黄金数量B会变为B∗ky(kg)当小a到达n−1时游戏结束

小a想知道在游戏结束时A+B的值

答案对10^9+7取模

# 【输入描述】

一行四个整数n,k,A,B

# 【输出描述】

输出一个整数表示答案

# 【样例】

示例1

输入

4 2 1 1

输出

32

示例2

输入

5 1 1 1

输出

2


思路：

若 GCD(n,x)=1，那么 GCD(n,n-x)=1，同时，若在某个位置得到 ![k^x](https://private.codecogs.com/gif.latex?k%5Ex) 的贡献，那么一定存在一个位置会获得小于等于 ![k^{n-x}](https://private.codecogs.com/gif.latex?k%5E%7Bn-x%7D) 的贡献，且两人贡献相同

将贡献单独写出来：![A*k^a*k^{n-a}*k^b*k^{n-b}*...=A*k^{Rn}](https://private.codecogs.com/gif.latex?A*k%5Ea*k%5E%7Bn-a%7D*k%5Eb*k%5E%7Bn-b%7D*...%3DA*k%5E%7BRn%7D)

因此需要考虑如何得到 R 的值，通过题目可知，能产生答案的数一定是与 n 互质的数，也即是欧拉函数的值

由于前 n 个数的欧拉函数的和为 ![\frac{n}{2}\phi (n)](https://private.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B2%7D%5Cphi%20%28n%29)，因此最终答案为  ![(A+B)*K^{\frac{\phi(n)}{2}n}](https://private.codecogs.com/gif.latex?%28A&plus;B%29*K%5E%7B%5Cfrac%7B%5Cphi%28n%29%7D%7B2%7Dn%7D)

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<deque>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define INF 0x3f3f3f3f
#define N 10001
#define LL long long
const int MOD=1e9+7;
const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1};
using namespace std;
int getPhi(int x){//获取欧拉函数
    int res=x;
    for(int i=2;i<=sqrt(x+0.5);i++){
        if(x%i==0){
            res=res/i*(i-1);
            while(x%i==0)
                x/=i;
        }
    }
    if(x>1)
        res=res/x*(x-1);
    return res;
}
LL quickPow(LL x,LL a){//快速幂
    LL res=1;
    while(a){
        if(a&1)
            res=res*x%MOD;
        x=x*x%MOD;
        a>>=1;
    }
    return res;
}
int main(){
    int n;
    LL a,b,k;
    cin>>n>>k>>a>>b;

    int phi=getPhi(n);
    LL res=quickPow(k,phi/2*n);
    res=res*(a+b)%MOD;
    cout<<res<<endl;

    return 0;
}
```





