# 炫酷镜子（2019牛客寒假算法基础集训营 Day5-I） - Alex_McAvoy的博客 - CSDN博客





2019年02月08日 16:04:04[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：44








> 
# 【题目描述】

小希拿到了一个镜子块，镜子块可以视为一个N x M的方格图，里面每个格子仅可能安装`\`或者`/`的镜子,会反射90°光线，也可能没有安装镜子，使用`.`代替。

但她看不清楚里面的镜子构造是怎样的。

你是这块镜子块的主人，所以你想计算这块镜子块（从输入的上方往下射入光线）从左到右每一格射入依次分别会从最下面的哪一格子射出，如果无法射出，输出-1。

# 【输入描述】

第一行输入两个整数N,M。随后的N行，每行M个字符。

1≤N,M≤500

# 【输出描述】

输出M行整数，依次为从第i个格子从上往下射入时从下面的哪里射出，如果光线不会从下面射出，则输出-1。

# 【样例】

示例1

输入

3 3

...

...

\.\

输出

3

2

-1

说明

第一列遇到镜子两次反弹通过第三列射出。

第二列直接射出。

第三列因为镜子反弹后向右边射出。


思路：模拟即可，注意 \ 镜子需要在其前面再加一反斜杠

# 【源代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<utility>
#include<stack>
#include<queue>
#include<vector>
#include<set>
#include<map>
#define PI acos(-1.0)
#define E 1e-6
#define INF 0x3f3f3f3f
#define N 1001
#define LL long long
const int MOD=998244353;
const int dx[]={-1,1,0,0};//上下左右
const int dy[]={0,0,-1,1};
using namespace std;
char G[N][N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>G[i][j];

    for(int i=1;i<=m;i++){//枚举每一列
        int x=1,y=i;//每一列的第一个格子
        int next=1;//方向
        int res=-1;
        while(x>=1&&x<=n&&y>=1&&y<=m){
            if(G[x][y]=='\\')//向右
                next=(next+2)%4;
            if(G[x][y]=='/')//向左
                next=3-next;

            x+=dx[next];
            y+=dy[next];

            if(x==n+1)//最后一个格子
                res=y;
        }
        cout<<res<<endl;
    }
    return 0;
}
```





