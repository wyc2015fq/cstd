# 动态规划 —— 背包问题 P03 —— 多重背包 - Alex_McAvoy的博客 - CSDN博客





2018年04月01日 14:55:02[Alex_McAvoy](https://me.csdn.net/u011815404)阅读数：98
个人分类：[动态规划——背包问题](https://blog.csdn.net/u011815404/article/category/7813163)









# 【题目】

有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 num[i] 件可用，每件体积是 w[i]，价值是 c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

# 【基本思路】

和完全背包问题很类似，基本的方程只需将完全背包问题的方程略微一改即可。

对于第 i 种物品有 num[i]+1种策略：取 0 件，取 1 件……取 num[i] 件，令 f[i][v] 表示前 i 种物品恰放入一个容量为 V 的背包的最大权值。

其与完全背包的区别在于，完全背包中的物品是不限量的，而多重背包的第 i 种物品最多取 num[i] 个

则有状态转移方程：**f[i][v]=max{ f[i-1][v-k*w[i]]+k*c[i] }（0<=k<=num[i]）**，时间复杂度是O(V*Σn[i])

考虑对 f[i][j] 进行空间优化，与完全背包

模版

```cpp
for(i=1;i<=N;i++)//N种物品
    for(j=V;j>=0;j--)//容量为V
        for(k=0;k<=num[i];k++)//每种物品最多有num[i]个
            if(j-k*w[i]>=0)//当前容量-k个物品的重量>=0
                f[j]=max(f[j],f[j-k*w[i]]+k*c[i]);
```

# 【转化为01背包问题求解】

转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的0-1背包问题，直接求解，复杂度仍然是O(V*Σn[i])。

我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。

方法：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的体积和价值均是原来的体积和价值乘以这个系数。使这些系数分别为：**1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。**

例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出。

这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*Σlog n[i])的01背包问题，是很大的改进。

下面给出O(log amount)时间处理一件多重背包中物品的伪代码：

```cpp
/*amount表示物品的数量*/
procedure MultiplePack(cost,weight,amount)
    if weight*amount>=V
        CompletePack(cost,weight)
        return
    integer k=1
    while k<num
        ZeroOnePack(k*cost,k*weight)
        amount=amount-k
        k=k*2
    ZeroOnePack(amount*cost,amount*weight)
```





