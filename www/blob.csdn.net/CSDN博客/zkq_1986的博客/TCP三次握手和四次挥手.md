# TCP三次握手和四次挥手 - zkq_1986的博客 - CSDN博客





2017年10月18日 07:40:41[zkq_1986](https://me.csdn.net/zkq_1986)阅读数：125








TCP连接的建立和释放：三次握手和四次挥手





![](https://img-blog.csdn.net/20171018074104526)


       三次握手过程：

第一次，       假如主机A为客户进程，B为服务进程.两者都处于关闭状态（CLOSED). 首先主机B会主动创建TCB(传输控制块)，进入监听状态（LISTEN）.主机A要连接时，会创建TCB(传输控制块)，并向主机B发送建立连接请求，在报文的首部同部位SYN置1，选择一个初始的序号x，然后主机A就进入同步已发送状态（SYN-SENT）.

第二次，       主机B在收到主机A的连接建立请求后，如果答应连接，那么就会向主机A发送确认. 在确认报文中将确认位ACK和同步位SYN都置1，同时确认号设为x+1，同步号选择一个初始值y. 然后主机B就进入同步已接收状态(SYN-RCVD)

第三次，       主机A在收到主机B的确认之后，还要向主机B发送确认. 在确认报文中将确认位置为1，确认号设为y+1，序号设为自己上一次的序号加1，即x+1.然后主机A就进入连接已建立状态（ESTABLISED）.

主机B在收到主机A的确认报文后，也进入连接已建立状态（ESTABLISED）.

       采用三次握手而不是两次握手的原因是，防止已失效的连接建立请求突然又传到B，导致主机B的资源浪费. 具体来说是这样的一个过程：当已主机A发出的失效的连接建立请求传到B之后，主机B就马上为A建立连接，等待着A传送数据。但实际上，主机A根本不会传数据给主机B，同时主机B也不会主动关闭这个连接，从而就给主机B的端口资源造成极大浪费.


       实际上TCP连接是通过四元组（源地址，目的地址，源端口，目的端口）进行标识，只要元组中有一项不同就可以认为是一条不一样的链路通道.



例

TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为：（奇虎，2016）

1999，1000



4.1.3 TCP连接的释放

4次挥手，或者称为两个两次握手

TCP连接的释放分为两个阶段，第一阶段结束后，TCP连接处于半关闭状态，只有等到第二阶段结束后，TCP连接才完全关闭.

**第一阶段中**，首先通信双方都处于established状态（已建立连接），现假如主机A先提出要关闭TCP，则它会发出一条释放连接的报文，并在报文首部的FIN(finish)字段中置1，序号seq设为**最后一次传送数据的序号**加1，进入FIN-WAIT-1(结束等待1)状态.


主机B收到报文后就发出确认ACK=1，确认号设为u+1，序号设为v，即本机**最后一次传送数据的序号**加1，B进入CLOSE-WAIT（关闭等待）状态. 主机A在收到B的关闭确认之后，进入结束等待2（FIN-WAIT-2）.等待B发出的释放连接请求.此时A到B这个方向的链路就断开了,使得TCP连接处于半关闭状态.

**在第二阶段中**，当B发出需要结束TCP连接的时，B就会在释放连接的报文首部中将FIN置1，确认号还是上次的u+1，然后进入最后确认状态（LAST-ACK）.

当A收到B的释放连接报文后，就会发出确认，将确认号置为w+1，序号仍然是u+1,然后A就进入时间等待状态（TIME-WAIT）.当B收到A的确认之后，就进入完全关闭TCP连接状态(CLOSED).此时,对于主机B来说这个TCP连接就完全释放掉了.

对于主机A来说，还要最长报文寿命（Maximumsegment lifetime,2MSL）的等待时间(设为2倍的最长报文寿命，是为了能够接收到主机B超时重传的确认报文)，才会完全进入已关闭连接（CLOSED）的状态. 这样做的目的，一是为了能够保证A发送的最后一个确认(ACK)报文段到达B.二是防止新的连接请求报文段中出现旧的连接报文段.

![](https://img-blog.csdn.net/20171018074114998)







