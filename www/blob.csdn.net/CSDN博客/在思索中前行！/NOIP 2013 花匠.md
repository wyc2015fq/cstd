# NOIP 2013 花匠 - 在思索中前行！ - CSDN博客





2014年08月02日 16:59:13[_Tham](https://me.csdn.net/txl16211)阅读数：1037









## 题目描述 Description


> 
花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。

具体而言，栋栋的花的高度可以看成一列整数h_1, h_2, … , h_n。设当一部分花被移走后，剩下的花的高度依次为g_1, g_2, … , g_m，则栋栋希望下面两个条件中至少有一个满足：

条件 A：对于所有的1<i<m/2，g_2i > g_2i-1，且g_2i > g_2i+1； 

条件 B：对于所有的1<i<m/2，g_2i < g_2i-1，且g_2i < g_2i+1。

注意上面两个条件在m = 1时同时满足，当m > 1时最多有一个能满足。

请问，栋栋最多能将多少株花留在原地。



## 输入描述 Input Description


> 
输入的第一行包含一个整数 n，表示开始时花的株数。

第二行包含 n 个整数，依次为h_1, h_2,… , h_n，表示每株花的高度。



## 输出描述 Output Description


> 
输出一行，包含一个整数 m，表示最多能留在原地的花的株数。



## 样例输入 Sample Input


> 
5 

5 3 2 1 2



## 样例输出 Sample Output


> 
3



## 数据范围及提示 Data Size & Hint


> 
对于 20%的数据，n ≤ 10； 

对于 30%的数据，n ≤ 25； 

对于 70%的数据，n ≤ 1000，0 ≤ h_i ≤ 1000； 

对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ h_i ≤ 1,000,000，所有的h_i随机生成，所有随机数服从某区间内的均匀分布。




**解题报告**

看到此题首先想到可能是要使用动态规划算法来解，所以当我的学生还没有任何思路的时候，我就已经开始构造动态规划了，刚开始，我的思路是这样子的：

1、令S[i][1]表示以i为结尾，且降序到达a[i]的最长抖动序列长度；令S[i][0]表示以i为结尾，且升序到达a[i]的最长抖动序列长度。则有如下递推公式：

S[i+1][1]=max(S[j][0])+1,i>=j>=1,a[j]>a[i+1],

S[i+1][0]=max(S[j][1])+1,i>=j>=1,a[j]<a[i+1],

S[1][1]=S[1][0]=1。

则最终答案应该是max(S[n][1],S[n][0])。

一直不知道如何优化max(S[j][0/1])的值，因此这样的DP时间复杂度将是O（n^2)的，考虑到70%的数据n<=1000,我想骗骗分数的话，我还是可以搞70分的，于是我按照
 此思路写了一个代码：



![](https://img-blog.csdn.net/20141030102143577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHhsMTk5MTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


毫无疑问，这个程序超时了。不过幸运的得到了80分。此算法过不了此题，于是开始考虑优化算法。于是便有了第二种方法。

2、依然设数组S[i][0/1],但考虑如下递推公式：

（1）a[i+1]>a[i]:

     S[i+1][0]=max(S[i][1]+1，S[i][0]);

     S[i+1][1]=S[i][1];

（2）a[i+1]<a[i]:

     S[i+1][0]=S[i][0];

     S[i+1][1]=max(S[i][0]+1,S[i][1]);

（3）a[i+1]= =a[i]:

     S[i+1][0]=S[i][0];

     S[i+1][1]=S[i][1];

     S[1][0]=S[1][1]=1.

算法优化后，再一次编写程序，O(n)的时间复杂度，当然是顺利AC了，代码如下：


![](https://img-blog.csdn.net/20141030111452984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHhsMTk5MTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




3、听我的学生将他可以把此题也分段，然后O(n)时间内就可以做出来，当自己使用DP解决了此题后，仔细想一想，确实可以！对序列缩点，连续递减的点和连续递增的点是可以缩到一个代表性的点上的，比如说样例给的5 3 2 1 2，可以缩成5,1,2或3,1,2或2,1,2，即5 3 2这三个连续递减的点实际上可以由一个点代替，1是一个转折点，于是你也可以说是找转折点个数。一下是我的代码,也可以很快的A掉此题：

![](http://s2.sinaimg.cn/orignal/002KxI7Cgy6ERyKR1Idf1)








