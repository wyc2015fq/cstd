# C++ 构造函数和析构函数 - 在思索中前行！ - CSDN博客





2015年03月30日 21:19:58[_Tham](https://me.csdn.net/txl16211)阅读数：819








### 构造函数：

作用：

   1）分配空间：分配非静态数据成员的存储空间

   2）初始化成员：初始化非静态数据成员

分配空间：

   1）含有指针变量，需要程序员显式申请空间（使用new申请）

   2）非指针变量：由系统自动分配空间

初始化成员：

   1）使用赋值语句初始化：一般的变量

   2）使用表达式表初始化：一般的变量 +  Const成员,引用成员,对象成员

调用时机：在定义对象的时候，系统自动调用构造函数

1）对象被创建时，自动调用构造函数

          Coord p1(1);  

          Coord 
p2=1;  //此时也会调用构造函数，但是有前提：构造参数只能有一个参数

   2）如果对象是用new 创建时，自动调用构造函数。

语法:名字和类名相同、无返回类型、允许为内联函数、重载函数、带默认形参值的函数

代码：



```cpp
class A  
    {  
    private:  
        int x;  
        int& rx;   
        const float pi;  
    public:  
        A(int x1):rx(x),pi(3.14)//rx(x)等价于rx=x,pi(3.14)相当于pi=3.14  
        {  
            x=x1;//一般的变量  
        }                                       
    };  
    调用：A a(10);
```




成员初始化表的使用

语法：

类名::构造函数名(参数表):(数据成员名1(初始值1),数据成员名2(初始值2),…… )

{

         函数体

}

说明：

1、类成员的初始化：按照他们在类中声明的顺序进行初始化，与他们在成员初始化表中的顺序无关

2、数据成员含数组时，应在构造函数中通过赋值语句实现，不能使用成员初始化表

### 析构函数：处理善后工作

作用：释放空间：

  1）含有指针变量，需要程序员显式释放空间

  2）非指针变量：由系统自动释放空间

调用时机：

  1）对象被撤销时，如对象定义在函数内，当函数调用结束时，该对象被撤销。

  2）如果对象是用new 创建的，当delete它时，自动调用析构函数。

语法：没有返回类型，没有参数，函数名是类名前加 "~"

代码：

```cpp
class X  
    {  
    public:  
        X()  { }  
        ~X() { }  
    };
```

说明：

1、为什么要把析构函数定义为虚函数？

因为：虚函数是为了支持多态，。。。之后补充

遇到的问题

```cpp
#include <iostream>  
    using namespace std;  
    class AAA  
    {  
    public:  
        AAA(void);  
        ~AAA(void);  
    };  
      
    AAA::AAA()  
    {  
      
    };  
      
    int main()  
    {  
        AAA t;  //报错  
        AAA *p = new AAA(); //不报错  
        system("pause");  
        return 1;  
    }
```



问题分析：因为**编译器为每一个类都会声明一个默认的构造函数和析构函数，拷贝构造函数、赋值运算符**。当用户自己定义时，系统就不在为类自动生成。这里类中已经自己定义了构造函数和析构函数，系统就没有自己生成。

AAA t;//报错

原因：在堆上定义对象是，系统会自动调用构造函数和析构函数。在链接时，系统会发现找不到析构函数的实现，这时就会报错，说找不到析构函数。要用你但是找不着你就会报错

AAA *p = new AAA(); //不报错

原因：new的时候会调用构造函数，但是由于释放的时候需要用户自己手动释放，这里由于没有delete，所以，不会用到析构函数。在程序链接时，由于没有用到析构函数，就没有去找其实现，就不会报错

```cpp
int main()  
    {  
        //AAA t;  //报错  
        AAA *p = new AAA();   
        delete p; //报错  
        system("pause");  
        return 1;  
    }
```

如上的例子，如果写delete

AAA *p = new AAA(); //不报错

delete p;

这时程序执行delete时，需要用到析构函数。链接时，系统就会找其实现。当发现没实现时，而报错。

所以，我们在**声明了函数就要记得实现，尤其是构造函数和析构函数，拷贝构造函数、赋值运算符。**




