# 深入理解C语言 - 在思索中前行！ - CSDN博客





2014年11月18日 17:06:39[_Tham](https://me.csdn.net/txl16211)阅读数：642标签：[C语言																[深入理解C语言](https://so.csdn.net/so/search/s.do?q=深入理解C语言&t=blog)](https://so.csdn.net/so/search/s.do?q=C语言&t=blog)
个人分类：[C/C++](https://blog.csdn.net/txl16211/article/category/2284665)








转自：http://coolshell.cn/articles/5761.html

Dennis Ritchie  过世了，他发明了C语言，一个影响深远并彻底改变世界的计算机语言。一门经历40多年的到今天还长盛不衰的语言，今天很多语言都受到C的影响，C++，Java，C#，Perl， PHP， Javascript， 等等。但是，你对C了解吗？相信你看过本站的《[C语言的谜题](http://coolshell.cn/articles/945.html)》还有《[谁说C语言很简单？](http://coolshell.cn/articles/873.html)》，这里，我再写一篇关于深入理解C语言的文章，一方面是缅怀Dennis，另一方面是告诉大家应该如何学好一门语言。（顺便注明一下，下面的一些例子来源于[这个slides](http://www.slideshare.net/olvemaudal/deep-c)）

首先，我们先来看下面这个经典的代码：




```cpp
int main()
{
    int a = 42;
    printf(“%d\n”, a);
}
```

从这段代码里你看到了什么问题？我们都知道，这段程序里少了一个#include <stdio.h> 还少了一个return 0;的返回语句。



不过，让我们来深入的学习一下，
- 这段代码在C++下无法编译，因为C++需要明确声明函数
- 这段代码在C的编译器下会编译通过，因为在编译期，编译器会生成一个printf的函数定义，并生成.o文件，链接时，会找到标准的链接库，所以能编译通过。
-  但是，你知道这段程序的退出码吗？在ANSI-C下，退出码是一些未定义的垃圾数。但在C89下，退出码是3，因为其取了printf的返回值。为什么printf函数返回3呢？因为其输出了’4′, ‘2’,’\n’ 三个字符。而在C99下，其会返回0，也就是成功地运行了这段程序。你可以使用gcc的
 -std=c89或是-std=c99来编译上面的程序看结果。
- 另外，我们还要注意main()，在C标准下，如果一个函数不要参数，应该声明成main(void)，而main()其实相当于main(…)，也就是说其可以有任意多的参数。

我们再来看一段代码：




```cpp
#include <stdio.h>
voidf(void)
{
   static int a = 3;
   static int b;
   int c;
   ++a; ++b; ++c;
   printf("a=%d\n", a);
   printf("b=%d\n", b);
   printf("c=%d\n", c);
}
int main(void)
{
   f();
   f();
   f();
}
```

这个程序会输出什么？
- 我相信你对a的输出相当有把握，就分别是4，5，6，因为那个静态变量。
- 对于c呢，你应该也比较肯定，那是一堆乱数。
- 但是你可能不知道b的输出会是什么？答案是1，2，3。为什么和c不一样呢？因为，如果要初始化，每次调用函数里，编译器都要初始化函数栈空间，这太费性能了。但是c的编译器会初始化静态变量为0，因为这只是在启动程序时的动作。
- 全局变量同样会被初始化。

说到全局变量，你知道 静态全局变量和一般全局变量的差别吗？是的，对于static 的全局变量，其对链接器不可以见，也就是说，这个变量只能在当前文件中使用。

我们再来看一个例子：




```cpp
#include <stdio.h>
void foo(void)
{
    int a;
    printf("%d\n", a);
}
void bar(void)
{
    int a = 42;
}
int main(void)
{
    bar();
    foo();
}
```


你知道这段代码会输出什么吗？A) 一个随机值，B) 42。A 和 B都对（在“[在函数外存取局部变量的一个比喻](http://coolshell.cn/articles/4907.html)”文中的最后给过这个例子），不过，你知道为什么吗？
- 如果你使用一般的编译，会输出42，因为我们的编译器优化了函数的调用栈（重用了之前的栈），为的是更快，这没有什么副作用。反正你不初始化，他就是随机值，既然是随机值，什么都无所谓。
- 但是，如果你的编译打开了代码优化的开关，-O，这意味着，foo()函数的代码会被优化成main()里的一个inline函数，也就是说没有函数调用，就像宏定义一样。于是你会看到一个随机的垃圾数。

下面，我们再来看一个示例：




```cpp
#include <stdio.h>
int b(void) {printf(“3”);return 3; }
int c(void) {printf(“4”);return 4; }
int main(void)
{
   int a = b() + c();
   printf(“%d\n”, a);
}
```

这段程序会输出什么？，你会说是，3，4，7。但是我想告诉你，这也有可能输出，4，3，7。为什么呢？ 这是因为，在C/C++中，表达的评估次序是没有标准定义的。编译器可以正着来，也可以反着来，所以，不同的编译器会有不同的输出。你知道这个特性以后，你就知道这样的程序是没有可移植性的。



我们再来看看下面的这堆代码，他们分别输出什么呢？



```cpp
1、int a=41; a++; printf("%d\n", a);
2、int a=41; a++ & printf("%d\n", a);
3、int a=41; a++ && printf("%d\n", a);
4、int a=41; if(a++ < 42) printf("%d\n", a);
5、int a=41; a = a++; printf("%d\n", a);
```

只有示例一，示例三，示例四输出42，而示例二和五的行为则是未定义的。关于这种未定义的东西是因为Sequence Points的影响（Sequence Points是一种规则，也就是程序执行的序列点，在两点之间的表达式只能对变量有一次修改），因为这会让编译器不知道在一个表达式顺列上如何存取变量的值。比如a
 = a++，a + a++，不过，在C中，这样的情况很少。


下面，再看一段代码：（假设int为4字节，char为1字节）




```cpp
struct X { int a; char b; int c; };
printf("%d,",sizeof(struct X));
struct Y { int a; char b; int c; char d};
printf("%d\n",sizeof(struct Y));
```

这个代码会输出什么?

a) 9，10

b)12, 12

c)12, 16

答案是C，我想，你一定知道字节对齐，是向4的倍数对齐。
- 但是，你知道为什么要字节对齐吗？还是因为性能。因为这些东西都在内存里，如果不对齐的话，我们的编译器就要向内存一个字节一个字节的取，这样一来，struct X，就需要取9次，太浪费性能了，而如果我一次取4个字节，那么我三次就搞定了。所以，这是为了性能的原因。
- 但是，为什么struct Y不向12 对齐，却要向16对齐，因为char d; 被加在了最后，当编译器计算一个结构体的尺寸时，是边计算，边对齐的。也就是说，编译器先看到了int，很好，4字节，然后是 char，一个字节，而后面的int又不能填上还剩的3个字节，不爽，把char
 b对齐成4，于是计算到d时，就是13 个字节，于是就是16啦。但是如果换一下d和c的声明位置，就是12了。

另外，再提一下，上述程序的printf中的%d并不好，因为，在64位下，sizeof的size_t是unsigned long，而32位下是 unsigned int，所以，C99引入了一个专门给size_t用的%zu。这点需要注意。在64位平台下，C/C++ 的编译需要注意很多事。你可以参看《[64位平台C/C++开发注意事项](http://coolshell.cn/articles/3512.html)》。

下面，我们再说说编译器的Warning，请看代码：





```cpp
#include <stdio.h>
int main(void)
{
    int a;
    printf("%d\n", a);
}
```

考虑下面两种编译代码的方式 ：
- cc -Wall a.c
- cc -Wall -O a.c

前一种是不会编译出a未初化的警告信息的，而只有在-O的情况下，才会有未初始化的警告信息。这点就是为什么我们在makefile里的CFLAGS上总是需要-Wall和 -O。

最后，我们再来看一个指针问题，你看下面的代码：





```cpp
#include <stdio.h>
int main(void)
{
    int a[5];
    printf("%x\n", a);
    printf("%x\n", a+1);
    printf("%x\n", &a);
    printf("%x\n", &a+1);
}
```

假如我们的a的地址是：0Xbfe2e100, 而且是32位机，那么这个程序会输出什么？
- 第一条printf语句应该没有问题，就是 bfe2e100
- 第二条printf语句你可能会以为是bfe2e101。那就错了，a+1，编译器会编译成 a+ 1*sizeof(int)，int在32位下是4字节，所以是加4，也就是bfe2e104
- 第三条printf语句可能是你最头疼的，我们怎么知道a的地址？我不知道吗？可不就是bfe2e100。那岂不成了a==&a啦？这怎么可能？自己存自己的？也许很多人会觉得指针和数组是一回事，那么你就错了。如果是 int *a，那么没有问题，因为a是指针，所以
 &a 是指针的地址，a 和 &a不一样。但是这是数组啊a[]，所以&a其实是被编译成了 &a[0]。
- 第四条printf语句就很自然了，就是bfe2e104。还是不对，因为是&a是数组，被看成int(*)[5]，所以sizeof(a)是5，也就是5*sizeof(int)，也就是bfe2e114。

看过这么多，你可能会觉得C语言设计得真扯淡啊。不过我要告诉下面几点Dennis当初设计C语言的初衷：

**1）相信程序员，不阻止程序员做他们想做的事。**

**2）保持语言的简洁，以及概念上的简单。**

**3）保证性能，就算牺牲移植性。**

今天很多语言进化得很高级了，语法也越来越复杂和强大，但是C语言依然光芒四射，Dennis离世了，但是C语言的这些设计思路将永远不朽。




