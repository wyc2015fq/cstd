# 图论，匈牙利算法 - 在思索中前行！ - CSDN博客





2014年08月10日 18:46:13[_Tham](https://me.csdn.net/txl16211)阅读数：601标签：[匈牙利算法](https://so.csdn.net/so/search/s.do?q=匈牙利算法&t=blog)
个人分类：[C/C++																[NOIP 图论](https://blog.csdn.net/txl16211/article/category/2451417)](https://blog.csdn.net/txl16211/article/category/2284665)








匈牙利算法
USACO 4.2.2 The Perfect Stall 完美的牛栏



这是一种用增广路求二分图最大匹配的算法。它由匈牙利数学家Edmonds于1965年提出，因而得名。 定义 未盖点：设Vi是图G的一个顶点，如果Vi 不与任意一条属于匹配M的边相关联，就称Vi 是一个未盖点。

![](https://www.byvoid.com/upload/wp/2008/04/wgd.gif)

交错路：设P是图G的一条路，如果P的任意两条相邻的边一定是一条属于M而另一条不属于M，就称P是一条交错路。

可增广路：两个端点都是未盖点的交错路叫做可增广路。 ![](https://www.byvoid.com/upload/wp/2008/04/jcl.gif)

![](https://www.byvoid.com/upload/wp/2008/04/kzgl.gif)

流程图

![](https://www.byvoid.com/upload/wp/2008/04/lct.gif)

伪代码：

```cpp
bool 寻找从k出发的对应项出的可增广路
{
    while (从邻接表中列举k能关联到顶点j)
    {
        if (j不在增广路上)
        {
            把j加入增广路;
            if (j是未盖点 或者 从j的对应项出发有可增广路)
            {
                修改j的对应项为k;
                则从k的对应项出有可增广路,返回true;
            }
        }
    }
    则从k的对应项出没有可增广路,返回false;
}

void 匈牙利hungary()
{
    for i->1 to n
    {
        if (则从i的对应项出有可增广路)
            匹配数++;
    }
    输出 匹配数;
}
```

演示

![](https://www.byvoid.com/upload/wp/2008/04/01.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/02.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/03.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/04.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/05.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/06.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/07.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/08.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/09.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/10.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/11.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/12.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/13.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/14.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/15.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/16.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/17.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/18.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/19.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/20.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/21.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/22.jpg)

![](https://www.byvoid.com/upload/wp/2008/04/23.jpg)

C实现

```cpp
#include <stdio.h>
#include <string.h>
#define MAX 102

long n,n1,match;
long adjl[MAX][MAX];
long mat[MAX];
bool used[MAX];

FILE *fi,*fo;

void readfile()
{
    fi=fopen("flyer.in","r");
    fo=fopen("flyer.out","w");
    fscanf(fi,"%ld%ld",&n,&n1);
    long a,b;
    while (fscanf(fi,"%ld%ld",&a,&b)!=EOF)
        adjl[a][ ++adjl[a][0] ]=b;
    match=0;
}

bool crosspath(long k)
{
    for (long i=1;i<=adjl[k][0];i++)
    {
        long j=adjl[k][i];
        if (!used[j])
        {
            used[j]=true;
            if (mat[j]==0 || crosspath(mat[j]))
            {
                mat[j]=k;
                return true;
            }
        }
    }
    return false;
}

void hungary()
{
    for (long i=1;i<=n1;i++)
    {
        if (crosspath(i))
            match++;
        memset(used,0,sizeof(used));
    }
}

void print()
{
    fprintf(fo,"%ld",match);
    fclose(fi);
    fclose(fo);
}

int main()
{
    readfile();
    hungary();
    print();
    return 0;
}
```




