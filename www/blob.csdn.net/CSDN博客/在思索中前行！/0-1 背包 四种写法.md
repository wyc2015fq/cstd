# 0-1 背包 四种写法 - 在思索中前行！ - CSDN博客





2014年09月09日 15:15:02[_Tham](https://me.csdn.net/txl16211)阅读数：660








#  [NOIP2005] 采药



辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？



    输入文件的第一行有两个整数 T （ 1 <= T <= 1000 ）和 M （ 1 <= M <= 100 ），用一个空格隔开， T 代表总共能够用来采药的时间， M 代表山洞里的草药的数目。接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。


输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。




解题报告：




## 1、递推阶段


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1000 + 10;
int n, c, v[N], w[N], f[N][N];
int main() {
    freopen("medic.in", "r", stdin);
    freopen("medic.out", "w", stdout);
    scanf("%d %d", &c, &n);
    for(int i=1; i<=n; i++)
        scanf("%d %d", v+i, w+i);
    for(int i=n; i>=1; i--)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == n) ? 0 : f[i+1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i+1][j - v[i]] + w[i]);
        } printf("%d\n", f[1][c]);
    return 0;
}
```

## 2、规划方向



```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1000 + 10;
int n, c, v[N], w[N], f[N][N];
int main() {
    freopen("medic.in", "r", stdin);
    freopen("medic.out", "w", stdout);
    scanf("%d %d", &c, &n);
    for(int i=1; i<=n; i++)
        scanf("%d %d", v+i, w+i);
    /*
    for(int i=n; i>=1; i--)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == n) ? 0 : f[i+1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i+1][j - v[i]] + w[i]);
        } printf("%d\n", f[1][c]);
    */
    for(int i=1; i<=n; i++)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == 1) ? 0 : f[i-1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
        } printf("%d\n", f[n][c]);
    return 0;
}
```

## 3、在线算法



```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1000 + 10;
int n, c, v[N], w[N], f[N][N];
int main() {
    freopen("medic.in", "r", stdin);
    freopen("medic.out", "w", stdout);
    scanf("%d %d", &c, &n);
    /*
    for(int i=1; i<=n; i++)
        scanf("%d %d", v+i, w+i);
    */ /*
    for(int i=n; i>=1; i--)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == n) ? 0 : f[i+1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i+1][j - v[i]] + w[i]);
        } printf("%d\n", f[1][c]);
    */ /*
    for(int i=1; i<=n; i++)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == 1) ? 0 : f[i-1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
        } printf("%d\n", f[n][c]);
    */
    int a, b;
    for(int i=1; i<=n; i++) {
        scanf("%d %d", &a, &b);
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == 1) ? 0 : f[i-1][j];
            if(j >= a)
                f[i][j] = max(f[i][j], f[i-1][j - a] + b);
        }
    } printf("%d\n", f[n][c]);
    return 0;
}
```

## 4、滚动数组



```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1000 + 10;
int n, c, v[N], w[N], f[N][N];
int main() {
    freopen("medic.in", "r", stdin);
    freopen("medic.out", "w", stdout);
    scanf("%d %d", &c, &n);
    /*
    for(int i=1; i<=n; i++)
        scanf("%d %d", v+i, w+i);
    */ /*
    for(int i=n; i>=1; i--)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == n) ? 0 : f[i+1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i+1][j - v[i]] + w[i]);
        } printf("%d\n", f[1][c]);
    */ /*
    for(int i=1; i<=n; i++)
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == 1) ? 0 : f[i-1][j];
            if(j >= v[i])
                f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
        } printf("%d\n", f[n][c]);
    */ /*
    int a, b;
    for(int i=1; i<=n; i++) {
        scanf("%d %d", &a, &b);
        for(int j=0; j<=c; j++) {
            f[i][j] = (i == 1) ? 0 : f[i-1][j];
            if(j >= a)
                f[i][j] = max(f[i][j], f[i-1][j - a] + b);
        }
    } printf("%d\n", f[n][c]);
    */
    int a, b, d[N] = {0};
    for(int i=1; i<=n; i++) {
        scanf("%d %d", &a, &b);
        for(int j=c; j>=0; j--)
            if(j >= a)
                d[j] = max(d[j], d[j - a] + b);
    } printf("%d\n", d[c]);
    return 0;
}
```















