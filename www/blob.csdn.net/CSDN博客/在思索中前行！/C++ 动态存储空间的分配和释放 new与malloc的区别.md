# C++  动态存储空间的分配和释放 new与malloc的区别 - 在思索中前行！ - CSDN博客





2015年03月30日 20:59:58[_Tham](https://me.csdn.net/txl16211)阅读数：2433









使用new申请空间:

特点：

        1、没有名字，只能通过指针间接访问它们。

        2、从堆中申请空间

分类：

变量：

语法：指针变量 = new 类型名;


                      Delete 指针变量

举例：int *p;


                      p=new int;

                      delete p;

  初始化：

                       *p=90;

                       p=new int（99）;

一维数组：

           语法：指针变量 = new 类型名[下标表达式];
下标表达式是整型常量或整型表达式

                       Delete 
[ ]指针变量;---[ ]表明是个数组，但不需要指出其大小

举例：Int *p;

                       P= new type[s];

                       Delete [ ]p;

多维数组(二维数组):  必须指出所有维的长度

语法：指针变量 = new 类型名[下标表达式] [下标表达式];

                       Delete [ ]变量名

举例：定义一个3×4的数组

                       Int （*p）[4]; p是个指针，它指向一个n维数组（4定义的时候必须已知，即后几维必须已知）

                       p=new int[3][4];// 第一维可以是常量或表达式，其他维必须全部为常量

                       Delete [ ]p;

对象：可以在创建对象的时候同时进行初始化

语法： 类名 *指针变量 = new 类名(实参表);

对象数组：

 语法：类名 数组名[元素个数]；

                       或: 类名* 指针名；指针名=new 类名[数组长度];

举例：Point A[2];

                       Point* p;

                      *p=new Point[5];

                       delete [ ]p;

初始化：每个对象都要调用一次构造函数和一次析构函数。

1)对象数组确定且长度有限：可以使用参数列表初始化

                    Point A[2]={Point(1,2),Point(3,4)};

2)对象数组长度比较大或不确定：只能调用无参或者使用缺省参数的函数

                  Point A[2];

            原因：在建立对象数组的时候，C++不允许整体对对象进行初始化（即[ ]和( )不能一起使用），这时不能给对象 使用有参数的构造函数

            所以：创建一个类的对象数组，就对给类的构造函数有要求：对象数组只能调用一个不需要参数的构造函数

**常见问题：**

1）：有了malloc/free 为什么还要new/delete？

malloc/free 只能满足内部数据类型的变量，它们只需要申请空间，无法对空间进行操作

而对于非内部数据类型的对象来说，对象在创建的同时要自动执行构造函数，在消亡之前要自动执行析构函数。

由于malloc/free 
是库函数而不是运算符，不在编译器控制权限之内，不能够自动地调用构造函数和析构函数。即用无法满足动态对象的要求。

因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。

注意new/delete 不是库函数，而是运算符。malloc/free 是标准库函数。

2）：malloc/free  和 new/delete 的相同点和不同点

        相同点：它们都可以申请和释放空间。

         不同点：

                      一、new ：分配内存 + 调用类的构造函数 + 初始化  delete：释放内存 + 调用类的析构函数

                              malloc：只分配内存，不会进行初始化类成员的工作   free只释放内存，不会调用析构函数

                      二、new delete 是运算符，可以进行重载 

                              malloc,free是函数，不可以进行重载

                      三、new delete 更加安全，简单：

                              不用计算类型大小：自动计算要分配存储区的字节数

                              不用强制类型转换：自动返回正确的指针类型

                     四、new可以分配一个对象或对象数组的存储空间，malloc不可以

                     五、可以超载与类相关的new和delete

                     六、malloc/free 是标准库函数，new/delete是C++运算符

2）：new和delete搭配使用，malloc和free搭配使用：混搭可能出现不可预料的错误

**3）：new后执行的三个操作：（某面试题目）**

**         1、****new的类分配内存空间。         2、 调用类的构造方法。         3 、返回该实例（对象）的内存地址**




