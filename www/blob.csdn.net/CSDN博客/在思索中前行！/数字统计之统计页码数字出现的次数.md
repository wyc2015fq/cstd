# 数字统计之统计页码数字出现的次数 - 在思索中前行！ - CSDN博客





2015年10月11日 22:35:59[_Tham](https://me.csdn.net/txl16211)阅读数：1199







给定一个十进制整数N，求出从1到N的所有整数中出现"1"的个数。

例如：N=2，1,2出现了1个"1"。

N=12，1,2,3,4,5,6,7,8,9,10,11,12。出现了5个"1"。

最直接的方法就是从1开始遍历到N，将其中每一个数中含有"1"的个数加起来，就得到了问题的解。



```cpp
long CountOne3(long n)
{
	long i = 0,j = 1;
	long count = 0;
	for (i = 0; i <= n; i++)
	{
		j = i;
		while (j != 0)
		{
			if (j % 10 == 1)
				count++;
			j = j / 10;
		}
	}
	return count;
}
```

此方法简单，容易理解，但它的问题是效率，时间复杂度为O（N * lgN），N比较大的时候，需要耗费很长的时间。



我们重新分析下这个问题，对于任意一个个位数n，只要n>=1,它就包含一个"1"；n<1，即n=0时，则包含的"1"的个数为0。于是我们考虑用分治的思想将任意一个n位数不断缩小规模分解成许多个个位数，这样求解就很方便。



但是，我们该如何降低规模？仔细分析，我们会发现，任意一个n位数中"1"的个位可以分解为两个n-1位数中"1"的个数的和加上一个与最高位数相关的常数C。例如，f(12) = f(10 - 1) + f(12 - 10) + 3,其中3是表示最高位为1的数字个数，这里就是10,11,12；f(132)=f(100 -1) + f(132 - 100) + 33，33代表最高位为1的数字的个数，这里就是100~132；f(232) = 2*f(100 - 1) + f(32) + 100，因为232大于199，所以它包括了所有最高位为1的数字即100~199，共100个。


综上，我们分析得出，最后加的常数C只跟最高位n1是否为1有关，当最高位为1时，常数C为原数字N去掉最高位后剩下的数字+1，当最高位为1时，常数C为10bit，其中bit为N的位数-1，如N=12时，bit=1，N=232时，bit=2。

于是，我们可以列出递归方程如下：


if(n1 == 1) 

f(n) = f(10^bit-1) + f(n - 10^bit) + n - 10^bit+ 1; 

else 

f(n) = n1*f(10^bit-1) + f(n – n1*10^bit) + 10^bit; 

递归的出口条件为：



if(1<n<10)  return 1;
else if (n == 0) return 0;




```cpp
long CountOne(long n)
{ 
	long count = 0;
	if (n == 0)
		count = 0;
	else if (n > 1 && n < 10)
		count =  1;
	else
	{
		long highest = n;//表示最高位的数字
		int bit = 0;
		while (highest >= 10)
		{
			highest = highest / 10;
			bit++;
		}
		int weight = (int)Math.Pow(10, bit);//代表最高位的权重，即最高位一个1代表的大小
		if (highest == 1)
		{
			count = CountOne(weight - 1)
			+ CountOne(n - weight)
			+ n - weight + 1;
		}
		else
		{
      		count = highest * CountOne(weight - 1)
    		+ CountOne(n - highest * weight)
        	+ weight;
		}
	}
	return count;
}
```


此算法的优点是不用遍历1~N就可以得到f(N)。经过我测试，此算法的运算速度比解法一快了许多许多，数字在1010内时，算法都可以在毫秒级内结束，而解法一在计算109时，时间超过了5分钟。但此算法有一个显著的缺点就是当数字超过1010时会导致堆栈溢出，无法计算。


还有就是，我尝试了许久也没有计算出此算法的时间复杂度到底是多少，似乎是O（lg2N），我并不确定，希望知道的高手能给予解答。


解法二告诉我们1~ N中"1"的个数跟最高位有关，那我们换个角度思考，给定一个N，我们分析1~N中的数在每一位上出现1的次数的和，看看每一位上"1"出现的个数的和由什么决定。

1位数的情况：在解法二中已经分析过，大于等于1的时候，有1个，小于1就没有。

2位数的情况：N=13,个位数出现的1的次数为2，分别为1和11，十位数出现1的次数为4，分别为10,11,12,13，所以f(N) = 2+4。N=23,个位数出现的1的次数为3，分别为1，11，21，十位数出现1的次数为10，分别为10~19，f(N)=3+10。


由此我们发现，个位数出现1的次数不仅和个位数有关，和十位数也有关，如果个位数大于等于1，则个位数出现1的次数为十位数的数字加1；如果个位数为0，个位数出现1的次数等于十位数数字。而十位数上出现1的次数也不仅和十位数相关，也和个位数相关：如果十位数字等于1，则十位数上出现1的次数为个位数的数字加1，假如十位数大于1，则十位数上出现1的次数为10。


3位数的情况：


N=123，个位出现1的个数为13:1,11,21，…，91,101,111,121。十位出现1的个数为20:10~19,110~119。百位出现1的个数为24:100~123。


我们可以继续分析4位数，5位数，推导出下面一般情况： 假设N，我们要计算百位上出现1的次数，将由三部分决定：百位上的数字，百位以上的数字，百位一下的数字。


如果百位上的数字为0，则百位上出现1的次数仅由更高位决定，比如12013，百位出现1的情况为100~199,1100~1199,2100~2199，…，11100~11199，共1200个。等于更高位数字乘以当前位数，即12 * 100。


如果百位上的数字大于1，则百位上出现1的次数仅由更高位决定，比如12213，百位出现1的情况为100~199,1100~1199,2100~2199，…，11100~11199，12100~12199共1300个。等于更高位数字加1乘以当前位数，即（12 + 1）*100。


如果百位上的数字为1，则百位上出现1的次数不仅受更高位影响，还受低位影响。例如12113，受高位影响出现1的情况：100~199,1100~1199,2100~2199，…，11100~11199，共1200个，但它还受低位影响，出现1的情况是12100~12113，共114个，等于低位数字13+1。
此方法的缺点是，如果统计的是数字0出现的次数，并不能正确计算，因此只适用于1~9的统计。0需要单独归纳

综合以上分析，写出如下代码：



```cpp
long CountOne2(long n)
{
	long count = 0;
	long i = 1;
	long current = 0,after = 0,before = 0;
	while((n / i) != 0)
	{           
		current = (n / i) % 10;
		before = n / (i * 10);
		after = n - (n / i) * i;
		if (current > 1)
			count = count + (before + 1) * i;
		else if (current == 0)
			count = count + before * i;
		else if(current == 1)
			count = count + before * i + after + 1;
		i = i * 10;
	}
	return count;
}
```








## 基于归纳总结，设范围是1～N，统计数字1出现的次数，介绍如下：
i)当N的中间某位为0，则某位出现1的个数CNT = 其高位数字×当前的位数

   如N=12013，百位为0，则百位出现1的CNT = 12 × 100（百位），分别为100～199，1100～1199，2100～2199，...，11100～11199


ii)当N的中间某位为1，则某位出现1的个数CNT = 其高位数字×当前的位数 + （低位数字+1）

  如N=12113，百位为1，则百位出现1的个数CNT = 12×100 + （113+1），分别为100～199，1100～1199，2100～2199，...，11100～11199，还有12100～12113


iii)当N的中间某位>1，则某位出现1的个数CNT = （高位+1）×当前位数

  如12213，CNT = （12+1）×100，分别为100～199，1100～1199，2100～2199，...，11100～11199，12100～12199



**此方法的缺点是，如果统计的是数字0出现的次数，并不能正确计算，因此只适用于1~9的统计。0需要单独归纳**



```cpp
ULONGLONG Sumls(ULONGLONG N)
{
    ULONGLONG iCount = 0;
    ULONGLONG iFactor = 1;
 
    ULONGLONG iLowerNum = 0;
    ULONGLONG iCurrNum = 0;
    ULONGLONG iHigherNum = 0;
 
    while (N/iFactor != 0)
    {
        iLowerNum = N - (N/iFactor)*iFactor;
        iCurrNum = (N/iFactor) % 10;
        iHigherNum = N / (iFactor*10);
 
        switch (iCurrNum)
        {
        case 0:
            iCount += iHigherNum*iFactor;
            break;
        case 1:
            iCount += iHigherNum*iFactor + (iLowerNum+1);
            break;
        default:
            iCount += (iHigherNum+1) * iFactor;
            break;
        }
        iFactor *= 10;
    }
 
    return iCount;
}
```

## **字统计之统计页码**



问题描述：

一本书的页码从自然数1开始计数，直到自然数n。书的页码按照通常的习惯编排，每个页码都不包含多余的前导数字0。例如，第6页用数字6表示，而不是06或006等。数字计数问题要求对给定书的总页码n，计算出书的全部页码中分别用到多少次数字0，1，2，...，9。

参考代码：

方法一 

暴力求解。无论页码是多少都是从1...n，所以我们可以从1到n进行遍历并对每个数进行分解即可得到结果




```cpp
#include<stdio.h>
int main()
{
	int n,i,temp;

	//声明并且初始化数组
	int count[10]= {0};
	printf("请输入页码：");
	scanf("%d",&n);

	//从1到n遍历数字，并分解将对应数字加1
	for(i=1; i<=n; i++)
		{
			for(temp=i; temp>0; temp/=10)
				{
					count[temp%10]++;
				}
		}

	//遍历输出
	for(i=0; i<10; i++)
		printf("%d\n",count[i]);
	return 1;
}
```


方法二

      考虑一个数字12345，在个数上，数字出现的频率是1次，即0到9不断循环出现；而在10位数字上（如果十位上没有数字就补0,要求从0到12345这些数字的位数都和最大的数相同，这里就都是5位），每个数字是连续出现10次后再出现另一个数字；百位数字上依此类推……

      基于这个思路，如果我们能计算出0到9这10个数字在每一位上出现的次数，对它们进行求和，即可计算出这10个数字出现的次数。

      考虑**X**，在第3位上统计相关数字出现的次数。一般地，数字出现的次数与X的大小有直接的有关系。

    （1）如果数字比X大，则它在这一位上出现的次数与前面的数字和该数字所在的位置有关。例如，12345中，数字4在第3位出现的次数为：

12*100=1200

    （2）如果数字等于X，则它在这一位上出现的次数与前面的数字、后面的数字和该数字所在的位置有关。例如，12345中，数字3在第3位上出现的次数为：

12*100+45+1=1246

    （3）如果数字小于X，则它在这一位上出现的次数与前面的数字和该数字所在的位置有关。例如，12345中，数字2在百位上出现的次数为

（12+1）*100=1300



```cpp
#include<stdio.h>
#include<math.h>
int main()
{
	int n,i,j,highter,lower,temp;
	int ws;
	//声明并且初始化数组
	int count[10]= {0};
	printf("请输入页码：");
	scanf("%d",&n);

	//计算n的位数
	ws=log10((double)n)+1;

	//依次计算第i（i小于ws）位0到9出现的次数
	for(i=1; i<=ws; i++)
		{

			//记录第i位之上的高位
			highter=n/(int)pow((double)10,i);

			//记录第i位之下的低位
			lower=n%(int)pow((double)10,i-1);

			//记录第i位
			temp=(n/(int)pow((double)10,i-1))%10;

			//记录小于第i位的数字在i位出现的次数
			for(j=0; j<temp; j++)
				{
					count[j]+=(highter+1)*pow((double)10,i-1);
				}

			//记录第i位上的数字在第i位出现的次数
			count[temp]+=highter*pow((double)10,i-1)+lower+1;

			//记录大于第i位的数字在第i位出现的次数
			for(j=temp+1; j<10; j++)
				{
					count[j]+=highter*pow((double)10,i-1);
				}
		}
	//剔除多余的0
	for(i=0; i<ws; i++)
		count[0]-=(int)pow((double)10,i);
	//遍历输出
	for(i=0; i<10; i++)
		printf("%d\n",count[i]);
	return 0;
}
```


方法三

      给定一个n位数字number，我们首先看一下从0到最大的n位数字，如果位数不够，在前面填0，这样一共有10^n个数字，其中包含数字的个数是n*10^n，其中包含这10个数字是相同的，都为n*10^{n-1}位。

     能否根据这一思路，从高位到低位依次处理？得到最终的位数？可以首先把最高位的数字单独处理，然后再处理其他的n-1位，最后把那些多余的0全部去掉就可以了。



```cpp
#include<stdio.h>
#include<math.h>
int main()
{
	int n,i,j,k,highter,lower,temp;
	int ws;
	//声明并且初始化数组
	int count[10]= {0};
	printf("请输入页码：");
	scanf("%d",&n);

	//计算n的位数-1
	ws=log10((double)n);

	//将n分解，依次记录最高位数字
	temp=n;
	for(i=0; i<=ws; i++)
		{
			//取得最高位数字
			highter=temp/pow((double)10,ws-i);
			//取得低位数字
			lower=temp%(int)pow((double)10,ws-i);

			//记录最高位数字在最高位出现的次数
			count[highter]+=lower+1;

			//依次记录从0到最高位数字highter的数字在最高位出现的次数以及从0到ws-i位最大数0到9出现的次数
			for(j=0; j<highter; j++)
				{
					count[j]+=pow((double)10,ws-i);

					//0到ws-i位最大数0到9出现的次数
					for(k=0; k<10; k++)
						{
							count[k]+=(ws-i)*pow((double)10,ws-i-1);
						}
				}
			temp=lower;
		}

	//剔除多余的0
	for(i=0; i<=ws; i++)
		count[0]-=(int)pow((double)10,i);
	//遍历输出
	for(i=0; i<10; i++)
		printf("%d-->%d\n\n1",i,count[i]);
	return 0;
}
```





