# 深入理解指针—>指针函数与函数指针的区别 - 在思索中前行！ - CSDN博客





2014年11月16日 20:13:46[_Tham](https://me.csdn.net/txl16211)阅读数：948








一、

在学习过程中发现这“指针函数”与“函数指针”容易搞错，所以今天，我自己想一次把它搞清楚，找了一些资料，首先它们之间的定义：

1、指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针

类型标识符    *函数名(参数表)

   int *f(x，y);

**首先它是一个函数，只不过这个函数的返回值是一个地址值**。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。

表示：

float *fun();

float *p;

p = fun(a);

注意指针函数与函数指针表示方法的不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

来讲详细一些吧！请看下面



# 指针函数：
    当一个函数声明其返回值为一个指针时，实际上就是返回一个地址给调用函数，以用于需要指针或地址的表达式中。
格式：
类型说明符  * 函数名(参数)
    当然了，由于返回的是一个地址，所以类型说明符一般都是int。
例如：int *GetDate();

          int *aaa(int,int);
函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。

        int *GetDate(int wk,int dy);

        main()

        {

            int wk,dy;

            do

            {

                printf(Enter week(1-5)day(1-7)\n);

                scanf(%d%d,&wk,&dy);

            }

            while(wk<1||wk>5||dy<1||dy>7);

            printf(%d\n,*GetDate(wk,dy));


//GetDate(int ,int )函数返回的是一个地址（指针），因此使用*取地址里的值)
        }

        int * GetDate(int wk,int dy)
        {
            static int calendar[5][7]=
            {
               {1,2,3,4,5,6,7},
               {8,9,10,11,12,13,14},
               {15,16,17,18,19,20,21},
               {22,23,24,25,26,27,28},
               {29,30,31,-1}
            };
            return &calendar[wk-1][dy-1];
        }
    程序应该是很好理解的，**子函数返回的是数组某元素的地址。输出的是这个地址里的值**。




#  函数指针

2、函数指针是指向函数的指针变量，即本质是一个**指针变量**。

int (*f) (int x); /* 声明一个函数指针 */

　  f=func; /* 将func函数的首地址赋给指针f */



     指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：
  类型说明符  (*函数名) (参数)  // * 包含在圆括号内
     其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。指针的声明笔削和它指向函数的声明保持一致。
     指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。
    例如：
            void (*fptr) ();
    把函数的地址赋值给函数指针，可以采用下面两种形式：
           fptr=&Function;
           fptr=Function;
取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
    可以采用如下两种方式来通过指针调用函数：
           x=(*fptr)();
           x=fptr();
    第二种格式看上去和函数调用无异。但是有些程序员倾向于使用第一种格式，因为它明确指出是通过指针而非函数名来调用函数的。下面举一个例子：

        void (*funcp)();
        void FileFunc(),EditFunc();

        main()
        {
            funcp=FileFunc;  //将函数FileFunc()地址赋给funcp
            (*funcp)();           //通过函数指针（*funcp）()执行所指向的函数FileFunc()，执行操作
            funcp=EditFunc;
            (*funcp)();
        }

        void FileFunc()
        {
            printf(FileFunc\n);
        }

        void EditFunc()
        {
            printf(EditFunc\n);
        }

        程序输出为：
            FileFunc
            EditFunc



主要的区别是一个是指针变量，一个是函数。在使用是必要要搞清楚才能正确使用






# 二、指针的指针
       指针的指针看上去有些令人费解。它们的声明有两个星号。例如：
       char  ** cp;
       如果有三个星号，那就是指针的指针的指针，四个星号就是指针的指针的指针的指针，依次类推。当你熟悉了简单的例子以后，就可以应付复杂的情况了。当然，实际程序中，一般也只用到  二级指针，三个星号不常见，更别说四个星号了。
指针的指针需要用到指针的地址。
        char c='A';
        char *p=&c;
        char **cp=&p;
        通过**指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据**。下面就是几个这样的例子：
        char *p1=*cp;
        char c1=**cp;
        你可能想知道这样的结构有什么用。利用指针的指针可以允许被调用函数修改局部指针变量和处理指针数组。

        void FindCredit(int **);

        main()
        {
            int vals[]={7,6,5,-4,3,2,1,0};
            int *fp=vals;
            FindCredit(&fp);
            printf(%d\n,*fp);
        }

        void FindCredit(int ** fpp) //因为fpp参数传过来是地址的地址（二重指针），所以用**调用数据
        {
            while(**fpp!=0)
            if(**fpp<0) break;
            else (*fpp)++;                //*fpp 访问表示数组的地址
        }

       首先用一个数组的地址初始化指针fp，然后把该指针的地址作为实参传递给函数FindCredit()。FindCredit()函数通过表达式**fpp间接地得到数组中的数据。为遍历数组以找到一个负值，FindCredit()函数进行自增运算的对象是调用者的指向数组的指针，而不是它自己的指向调用者指针的指针。语句(*fpp)++就是对形参指针指向的指针进行自增运算的（相当于应用数组的地址上）。但是因为*运算符高于++运算符，所以圆括号在这里是必须的，如果没有圆括号，那么++运算符将作用于二重指针fpp上。


# 三、指向指针数组的指针
       指针的指针另一用法旧处理指针数组。有些程序员喜欢用指针数组来代替多维数组，一个常见的用法就是处理字符串。

        char *Names[]=
        {
             Bill,
             Sam,
             Jim,
             Paul,
             Charles,
             0
        };

        main()
        {
            char **nm=Names;
            while(*nm!=0) printf(%s\n,*nm++);
        }

       先用字符型指针数组Names的地址来初始化指针nm。每次printf()的调用都首先传递指针nm指向的字符型指针，然后对nm进行自增运算使其指向数组的下一个元素(还是指针)。注意完成上述认为的语法为*nm++，它首先取得指针指向的内容，然后使指针自增。
       注意数组中的最后一个元素被初始化为0，while循环以次来判断是否到了数组末尾。具有零值的指针常常被用做循环数组的终止符。程序员称零值指针为空指针(NULL)。采用空指针作为终止符，在树种增删元素时，就不必改动遍历数组的代码，因为此时数组仍然以空指针作为结束。






