# 程序员的数学：汉诺塔递归与非递归求解 - 在思索中前行！ - CSDN博客





2014年09月18日 17:31:03[_Tham](https://me.csdn.net/txl16211)阅读数：945标签：[汉诺塔](https://so.csdn.net/so/search/s.do?q=汉诺塔&t=blog)
个人分类：[NOIP 分治与递归](https://blog.csdn.net/txl16211/article/category/2126049)









如果对汉诺塔算法的理解有困难，建议查看《程序员的数学》：第6章 递归——自己定义自己

这一章作者详细用图形介绍了汉诺塔递归算法，便于理解，茅塞顿开！

现对该算法从递归和非递归两个方面做如下总结：

**1.递归算法分析**如下，

设A上有n个盘子。

如果n=1，则将圆盘从A直接移动到C。

如果n=2，则：

（1）将A上的n-1（等于1）个圆盘移到B上；

（2）再将A上的一个圆盘移到C上；

（3）最后将B上的n-1（等于1）个圆盘移到C上。

如果n=3，则：

A）将A上的n-1（等于2，令其为n`）个圆盘移到B（借助于C），步骤如下：

（1）将A上的n`-1（等于1）个圆盘移到C上。

（2）将A上的一个圆盘移到B。

（3）将C上的n`-1（等于1）个圆盘移到B。

B）将A上的一个圆盘移到C。

C）将B上的n-1（等于2，令其为n`）个圆盘移到C（借助A），步骤如下：

（1）将B上的n`-1（等于1）个圆盘移到A。

（2）将B上的一个盘子移到C。

（3）将A上的n`-1（等于1）个圆盘移到C。到此，完成了三个圆盘的移动过程。


从上面分析可以看出，当n大于等于2时， 移动的过程可分解为三个步骤：

第一步 把A上的n-1个圆盘移到B上；

第二步 把A上的一个圆盘移到C上；

第三步 把B上的n-1个圆盘移到C上；

其中第一步和第三步是类同的。 当n=3时，第一步和第三步又分解为类同的三步，即把n`-1个圆盘从一个针移到另一个针上，这里的n`=n-1。


Hanoi塔问题中函数调用时系统所做工作

一个函数在运行期调用另一个函数时，在运行被调用函数之前，系统先完成3件事：

①将所有的实参、返回地址等信息传递给被调用函数保存。

②为被调用函数的局部变量分配存储区；

③将控制转移到被调用函数的入口。



从被调用函数返回调用函数前，系统也应完成3件事：

①保存被调用函数的结果；

②释放被调用函数的数据区；

③依照被调用函数保存的返回地址将控制转移到调用函数。


当有多个函数构成嵌套调用时，按照“后调用先返回”的原则（LIFO），上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为其在栈顶分配一个存储区，每当从一个函数退出时，就释放其存储区，因此当前运行函数的数据区必在栈顶。堆栈特点：LIFO，除非转移或中断，堆栈内容的存或取表现出线性表列的性质。正是如此，程序不要求跟踪当前进入堆栈的真实单元，而只要用一个具有自动递增或自动递减功能的堆栈计数器，便可正确指出最后一次信息在堆栈中存放的地址。


一个递归函数的运行过程类型于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数。因此，和每次调用相关的一个重要的概念是递归函数运行的“层次”。假设调用该递归函数的主函数为第0层，则从主函数调用递归函数为进入第1层；从第i层递归调用本函数为进入下一层，即i＋1层。反之，退出第i层递归应返回至上一层，即i－1层。为了保证递归函数正确执行，系统需设立一个“递归工作栈”，作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括所有实参、所有局部变量以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”，并称指示活动记录的栈顶指针为“当前环境指针”。递归源码如下：


```cpp
#include<stdio.h> 
/*主程序*/
int hanoi(int,char,char,char);
int main()
{
char a='A',b='B',c='C';
int dishes;

while(1)
{
printf("输入盘子个数： ");
scanf("%d",&dishes);
hanoi(dishes,a,b,c);
}
return 0;
}

int hanoi(int dishs,char ap,char bp,char cp)
{
if ( dishs == 1 )
printf("盘子从%c 移动到 %c \n",ap,cp);
else
{
hanoi(dishs - 1,ap,cp,bp );
printf("盘子从%c 移动到 %c\n",ap,cp);
hanoi(dishs - 1,bp,ap,cp);
}
return 0;
}
```

2.非递归算法概述
/*《数学营养菜》（谈祥柏 著）提供的一种方法，编了一个程序来实现。
*/
/*
算法介绍：
首先容易证明，当盘子的个数为n时，移动的次数应等于2^n - 1。
一位美国学者发现一种出人意料的方法，只要轮流进行两步操作就可以了。
首先把三根柱子按顺序排成品字型，把所有的圆盘按从大到小的顺序放在柱子A上。
根据圆盘的数量确定柱子的排放顺序：若n为偶数，按顺时针方向依次摆放 A B C；
若n为奇数，按顺时针方向依次摆放 A C B。
（1）按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，即当n为偶数时，若圆盘1在柱子A，则把它移动到B；
若圆盘1在柱子B，则把它移动到C；若圆盘1在柱子C，则把它移动到A。
（2）接着，把另外两根柱子上可以移动的圆盘移动到新的柱子上。
即把非空柱子上的圆盘移动到空柱子上，当两根柱子都非空时，移动较小的圆盘
这一步没有明确规定移动哪个圆盘，你可能以为会有多种可能性，其实不然，可实施的行动是唯一的。
（3）反复进行（1）（2）操作，最后就能按规定完成汉诺塔的移动。
*/



```cpp
#include <iostream>
using namespace std; 
const int MAX = 64; //圆盘的个数最多为64
struct st{ //用来表示每根柱子的信息
int s[MAX]; //柱子上的圆盘存储情况
int top; //栈顶，用来最上面的圆盘
char name; //柱子的名字，可以是A，B，C中的一个

int Top()//取栈顶元素
{
return s[top];
}
int Pop()//出栈
{
return s[top--];
}
void Push(int x)//入栈
{
s[++top] = x;
}
} ;

long Pow(int x, int y); //计算x^y
void Creat(st ta[], int n); //给结构数组设置初值
void Hannuota(st ta[], long max); //移动汉诺塔的主要函数
int main(void)
{
int n;
cin >> n; //输入圆盘的个数
st ta[3]; //三根柱子的信息用结构数组存储
Creat(ta, n); //给结构数组设置初值
long max = Pow(2, n) - 1;//动的次数应等于2^n - 1
Hannuota(ta, max);//移动汉诺塔的主要函数
system("pause");
return 0;
}

void Creat(st ta[], int n)
{
ta[0].name = 'A';
ta[0].top = n-1;
for (int i=0; i<n; i++) //把所有的圆盘按从大到小的顺序放在柱子A上
ta[0].s[i] = n - i;
ta[1].top = ta[2].top = 0;//柱子B，C上开始没有没有圆盘
for (int i=0; i<n; i++)
ta[1].s[i] = ta[2].s[i] = 0;
if (n%2 == 0) //若n为偶数，按顺时针方向依次摆放 A B C
{
ta[1].name = 'B';
ta[2].name = 'C';
}
else //若n为奇数，按顺时针方向依次摆放 A C B
{
ta[1].name = 'C';
ta[2].name = 'B';
}
}

long Pow(int x, int y)
{
long sum = 1;
for (int i=0; i<y; i++)
sum *= x;
return sum;
}

void Hannuota(st ta[], long max)
{
int k = 0; //累计移动的次数
int i = 0;
int ch;
while (k < max)
{
//按顺时针方向把圆盘1从现在的柱子移动到下一根柱子
ch = ta[i%3].Pop();
ta[(i+1)%3].Push(ch);
cout << ++k << ": " << "Move disk " << ch << " from " << ta[i%3].name << " to " << ta[(i+1)%3].name << endl;
i++;
//把另外两根柱子上可以移动的圆盘移动到新的柱子上

if (k < max)
{ //把非空柱子上的圆盘移动到空柱子上，当两根柱子都为空时，移动较小的圆盘
if (ta[(i+1)%3].Top() == 0 || ta[(i-1)%3].Top() > 0 && ta[(i+1)%3].Top() > ta[(i-1)%3].Top())
{
ch = ta[(i-1)%3].Pop();
ta[(i+1)%3].Push(ch);
cout << ++k << ": " << "Move disk " << ch << " from " << ta[(i-1)%3].name << " to " << ta[(i+1)%3].name << endl;
}
else
{
ch = ta[(i+1)%3].Pop();
ta[(i-1)%3].Push(ch);
cout << ++k << ": " << "Move disk " << ch << " from " << ta[(i+1)%3].name << " to " << ta[(i-1)%3].name << endl;
}
}
}
}
```






