# 线性动态规划——解最长公共子序列问题 - 在思索中前行！ - CSDN博客





2014年10月28日 17:41:45[_Tham](https://me.csdn.net/txl16211)阅读数：1005








## **动态规划法**

经常会遇到复杂问题不能简单地分解成几个子问题，而会分解出一系列的子问题。简单地采用把大问题分解成子问题，并综合子问题的解导出大问题的解的方法，问题求解耗时会按问题规模呈幂级数增加（分治思想，递归方法。往往会由于数据大导致递归层次过多而超时或爆栈，即使采用记忆化等优化策略，仍然可能解决不了问题）。

   为了节约重复求相同子问题的时间，引入一个数组，不管它们是否对最终解有用，把所有子问题的解存于该数组中，找出数组中相关元素之间存在的关系(动态转移方程)，这就是动态规划法所采用的基本方法。



【问题】 求两字符序列的最长公共字符子序列

 问题描述：字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=“x0，x1，…，xm-1”，序列Y=“y0，y1，…，yk-1”是X的子序列，存在X的一个严格递增下标序列<i0，i1，…，ik-1>，使得对所有的j=0，1，…，k-1，有xij=yj。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。

    考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难**证明有以下性质**：

   （1） 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；

   （2） 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；

   （3） 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。

    这样，在找A和B的公共子序列时，如有am-1=bn-1，则进一步解决一个子问题，找“a0，a1，…，am-2”和“b0，b1，…，bm-2”的一个最长公共子序列；如果am-1!=bn-1，则要解决两个子问题，找出“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列和找出“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列，再取两者中较长者作为A和B的最长公共子序列。



## **求解：**



引进一个二维数组c[][]，用c[i][j]记录X[i]与Y[j] 的LCS 的长度，b[i][j]记录c[i][j]是通过哪一个子问题的值求得的，以决定搜索的方向。

我们是自底向上进行递推计算，那么在计算c[i,j]之前，c[i-1][j-1]，c[i-1][j]与c[i][j-1]均已计算出来。此时我们根据X[i] = Y[j]还是X[i] != Y[j]，就可以计算出c[i][j]。

问题的递归式写成：






![recursive formula](https://p-blog.csdn.net/images/p_blog_csdn_net/hhygcy/EntryImages/20090302/lcs_1.PNG)


回溯输出最长公共子序列过程：

![flow](https://p-blog.csdn.net/images/p_blog_csdn_net/hhygcy/EntryImages/20090302/lcs_2.PNG)




算法分析：

由于每次调用至少向上或向左（或向上向左同时）移动一步，故最多调用(m + n)次就会遇到i = 0或j = 0的情况，此时开始返回。返回时与递归调用时方向相反，步数相同，故算法时间复杂度为Θ(m + n)。





代码1：



```cpp
#include <stdio.h>
#include <string.h>
#define MAXLEN 100
// 求序列 X 和 Y 的最长公共子序列 
void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])
{
    int i, j;

    for(i = 0; i <= m; i++) //初始化 
        c[i][0] = 0;
    for(j = 1; j <= n; j++) //初始化 
        c[0][j] = 0;
    //注意，数组是由0开始，但是本题中将数组中第一个元素用i表示为1了，因此x[i-1]==y[j-1]这样比较 
    //实际上 b[i][j]记录的信息是字符序列中第i个和第j个的关系信息，并非x[i] , y[j] 关系 
    for(i = 1; i<= m; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(x[i-1] == y[j-1])  //利用动态转移方程，递推求解 
            {
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = 0;      //记录当前位置字符在最长公共子序列中 
            }
            else if(c[i-1][j] >= c[i][j-1])
            {
                c[i][j] = c[i-1][j];
                b[i][j] = 1;     //记录最长公共子序列在[i-1][j]这部分 
            }
            else
            {
                c[i][j] = c[i][j-1];
                b[i][j] = -1;    //记录最长公共子序列 在[i][j-1]部分内 
            }
        }
    }
}

void PrintLCS(int b[][MAXLEN], char *x, int i, int j) //根据b[][]的记录，输出最长公共子序列 
{
    if(i == 0 || j == 0)
        return;
//  printf("i=%d j=%d b[i][j]=%d\n",i,j,b[i][j]); 
    if(b[i][j] == 0) //当前位置的字符在最长公共子序列中 
    {
        PrintLCS(b, x, i-1, j-1); //继续往后查找余下的最长公共子序列 
        printf("%c ", x[i-1]);    //查找完前面的子序列后，再输出后面的当前公共子序列末尾字符 
//        printf("i=%d j=%d\n",i,j); 
    }
    else if(b[i][j] == 1)
        PrintLCS(b, x, i-1, j);
    else
        PrintLCS(b, x, i, j-1);
}

int main(int argc, char **argv)
{
    char x[MAXLEN];
    char y[MAXLEN];
    int b[MAXLEN][MAXLEN];
    int c[MAXLEN][MAXLEN];
    int m, n;
    scanf("%s%s",x,y); 
    m = strlen(x);
    n = strlen(y);
    
    LCSLength(x, y, m, n, c, b);
    PrintLCS(b, x, m, n);
    
    return 0;
}
```

代码2：




```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
const int SIZEN=5001;
int s1[SIZEN]={0},s2[SIZEN]={0};
int l1,l2;
int f[SIZEN][SIZEN]={{0}}; //初始化 F[i][j] 表示长度为i的序列和长度为j的序列最长公共子序列长度

int max(int a,int b)
{
	return a>b?a:b;
} 

void read(void){   //读入数据处理，将输入的字幕全部转化为A-Z字母相应的数字存储 
    char str[SIZEN];
	int i;
	scanf("%s",str);
	i=0;
	while(str[i]!='.') s1[i+1]=str[i]-'A',i++;
	l1=i;
	scanf("%s",str);
	i=0;
	while(str[i]!='.') s2[i+1]=str[i]-'A',i++;
	l2=i;
}
void dp(void){  //根据动态转移方程求DP[i][j] 表示长度为i的序列和长度为j的序列最长公共子序列长度 
	int i,j;
	for(i=1;i<=l1;i++){
		for(j=1;j<=l2;j++){
			if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1]+1;
			else f[i][j]=max(f[i][j-1],f[i-1][j]);
		}
	}
}
int main(){

	read();
	dp();
	printf("%d\n",f[l1][l2]);
	return 0;
}
```


## 动态规划算法实现



```cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <math.h>  
using namespace std;  
  
#define MAXSTRLEN 20  
  
int Lcs(char x[], char y[], int path[][MAXSTRLEN])//求序列x和y的最长公共子序列，path保存路径指向，以方便打印公共子序列  
{  
    int i, j;  
    int len1=strlen(x)-1;  
    int len2=strlen(y)-1;  
      
    int **c=new int*[len1+1];  
    for(i=0; i<=len1; i++)  
        c[i]=new int[len2+1];  
      
    for(i=0; i<=len1; i++)  
        c[i][0]=0;  
    for(i=0; i<=len2; i++)  
        c[0][i]=0;  
    for(i=1; i<=len1; i++)  
        for(j=1; j<=len2; j++)//从x[1]，y[1]开始  
        {  
            if(x[i]==y[j])  
            {  
                c[i][j]=c[i-1][j-1]+1;  
                path[i][j]=1;  
            }  
            else if(c[i-1][j]>=c[i][j-1])  
            {  
                c[i][j]=c[i-1][j];  
                path[i][j]=2;  
            }  
            else  
            {  
                c[i][j]=c[i][j-1];    
                path[i][j]=3;  
            }         
        }  
          
        return c[len1][len2];  
}  
  
void PrintLcs(int i, int j, char x[], int path[][MAXSTRLEN])//打印最长公共子序列  
{  
    if(i==0 || j==0)  
        return;  
      
    if(path[i][j]==1)  
    {  
        PrintLcs(i-1, j-1, x, path);  
        cout<<x[i];  
    }  
    else if(path[i][j]==2)  
        PrintLcs(i-1, j, x, path);  
    else  
        PrintLcs(i, j-1, x, path);  
          
}  
void main()  
{  
    char a[MAXSTRLEN];  
    char b[MAXSTRLEN];  
    int path[MAXSTRLEN][MAXSTRLEN];  
    gets(a+1);//a[0]不算，从a[1]开始  
    gets(b+1);//b[0]不算，从b[1]开始  
      
    cout<<Lcs(a, b, path)<<endl;  
    cout<<"最长公共子序列：";  
    PrintLcs(strlen(a)-1, strlen(b)-1, a, path);  
    cout<<endl;  
      
}
```

## 递归算法

```cpp
#include <iostream>  
using namespace std;  
  
#define MAXSTRLEN 20  
  
//递归算法  
int Lcs(char *str1, char *str2)  
{  
    if(*str1=='\0' || *str2=='\0')  
        return 0;  
    if(*str1==*str2)  
        return Lcs(str1+1, str2+1)+1;  
    else if(Lcs(str1+1, str2)>Lcs(str1, str2+1))  
        return Lcs(str1+1, str2);  
    else  
        return Lcs(str1, str2+1);  
      
}  
  
void main()  
{  
    char a[MAXSTRLEN];  
    char b[MAXSTRLEN];  
      
    gets(a);  
    gets(b);  
    cout<<Lcs(a, b)<<endl;  
      
}
```






