# 操作系统启动过程——启动引导+硬件自检+系统引导+系统加载+系统登录 - 在思索中前行！ - CSDN博客





2016年03月07日 14:54:31[_Tham](https://me.csdn.net/txl16211)阅读数：1384








**电脑及操作系统的启动过程**
从按下机箱电源键开始，直到用户进入操作系统，操作系统正常启动，整个过程可分为以下几个部分。
　　1. 预引导(Pre-Boot)阶段

　　2. 引导阶段 

　　3. 加载内核阶段 

　　4. 初始化内核阶段 

　　5. 用户登录阶段

**一、预引导阶段**

　　首先让我们来了解一些基本概念。第一个是大家非常熟悉的BIOS（基本输入输出系统），BIOS是直接与硬件打交道的底层代码，它为操作系统提供了控制硬件设备的基本功能。BIOS包括有系统BIOS（即常说的主板BIOS）、显卡BIOS和其它设备（例如IDE控制器、SCSI卡或网卡等）的BIOS，其中系统BIOS是本文要讨论的主角，因为计算机的启动过程正是在它的控制下进行的。BIOS一般被存放在ROM(只读存储芯片)之中，即使在关机或掉电以后，这些代码也不会消失。 

　　第二个基本概念是内存的地址，我们的机器中现在一般安装有128MB或256MB甚至更大容量的内存，这些内存的每一个字节都被赋予了一个地址，以便CPU访问内存。32MB的地址范围用十六进制数表示就是0～1FFFFFFH，其中0～FFFFFH的低端1MB内存非常特殊，因为最初的8086处理器能够访问的内存最大只有1MB，这1MB的低端640KB被称为基本内存，而A0000H～BFFFFH要保留给显示卡的显存使用，C0000H～FFFFFH则被保留给BIOS使用，其中系统BIOS一般占用了最后的64KB或更多一点的空间，显卡BIOS一般在C0000H～C7FFFH处，IDE控制器的BIOS在C8000H～CBFFFH处。

　　第一步： 当我们按下电源开关时，电源就开始向主板和其它设备供电，此时电压还不太稳定，主板上的控制芯片组会向CPU发出并保持一个RESET（重置）信号，让CPU内部自动恢复到初始状态，但CPU在此刻不会马上执行指令。当芯片组检测到电源已经开始稳定供电了（当然从不稳定到稳定的过程只是一瞬间的事情），它便撤去RESET信号（如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号），CPU马上就从地址FFFF0H处开始执行指令，从前面的介绍可知，这个地址实际上在系统BIOS的地址范围内，无论是Award
 BIOS还是AMI BIOS，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。 

　　第二步： **系统BIOS的启动代码首先要做的事情就是进行POST（Power－On Self Test，加电后自检）**，**POST的主要任务是检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备**。由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题（此时只会检查640K常规内存），那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型。在正常情况下，POST过程进行得非常快，我们几乎无法感觉到它的存在，POST结束之后就会调用其它代码来进行更完整的硬件检测。 
　　第三步： 接下来系统BIOS将查找显卡的BIOS，前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡，此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。 
　　第四步： 查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。 
　　第五步： 接着系统BIOS将检测和显示CPU的类型和工作频率，然后开始测试所有的RAM，并同时在屏幕上显示内存测试的进度，我们可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。 
　　第六步： 内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD－ROM、串口、并口、软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。 
　　第七步： 标准设备检测完毕后，系统BIOS内部的支持即插即用的代码将开始检测和配置系统中安装的即插即用设备，每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。 
　　第八步： 到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。 
　　第九步： 接下来系统BIOS将更新ESCD（Extended System Configuration Data，扩展系统配置数据）。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS（一小块特殊的RAM，由主板上的电池来供电）之中。
　　通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时我们都能够看到“Update ESCD… Success”这样的信息，不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows系统不相同的数据格式，于是Windows在它自己的启动过程中会把ESCD数据修改成自己的格式，但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来，如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。 
　　第十步： ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作，即根据用户指定的启动顺序从软盘、硬盘或光驱启动。
　　第十一步：以从硬盘盘启动为例，
　　1、系统BIOS将磁盘第一个物理扇区加载到内存，读取并执行位于硬盘第一个物理扇区的MBR
　　2、接着将系统控制权交给MBR来进行
　　3、MBR运行后，搜索MBR中的分区表，查找活动分区（Active Partition）的起始位置
　　4、MBR将活动分区的第一个扇区中的引导扇区——分区引导记录载入到内存。
　　5、MBR检测当前使用的文件系统是否可用。 
　　第十二步：主引导记录加载系统启动器（windows loader）
　　1、MBR查找ntldr文件，找到之后初始化NTLDR文件启动它——NT内核操作系统的启动器（windows loader）。[I]　　　　注：win98引导 在这个环节，如果硬盘中安装的只有win98系统，已经被加载的win98的分区引导记录（和win2k这样基于NT内核的操作系统不同，DOS和win9x的系统启动器——windows loader就是分区引导记录）将负责读取并执行IO.SYS，这是DOS和Windows 9x最基本的系统文件。Windows
 9x的IO.SYS首先要初始化一些重要的系统数据，然后就显示出我们熟悉的蓝天白云，在这幅画面之下，Windows将继续进行DOS部分和GUI（图形用户界面）部分的引导和初始化工作。[/I]
　　2、MBR将控制权转交给ntldr，由ntldr继续完成操作系统的启动。
　　MBR(Master Boot Record)——主引导记录，位于启动磁盘的第一个扇区，其中主要包含引导代码（Boot Code）和分区表（Partition Table）数据。引导代码主要用于引导系统。而分区表则主要用于标识基本分区和扩展分区。
　　这整个过程便是计算机在打开电源开关（或按Reset键）进行冷启动时所要完成的各种初始化工作，如果我们在DOS下按Ctrl＋Alt＋Del组合键（或从Windows中选择重新启动计算机）来进行热启动，那么POST过程将被跳过去，直接从第三步开始，另外第五步的检测CPU和内存测试也不会再进行。我们可以看到，无论是冷启动还是热启动，系统BIOS都一次又一次地重复进行着这些我们平时并不太注意的事情，然而正是这些单调的硬件检测步骤为我们能够正常使用电脑提供了基础。

**二、引导阶段 （以XP系统为例，2000和2003大致相同）**

　　在引导阶段中，Windows XP将会依次经历初始引导加载器阶段、操作系统选择阶段、硬件检测阶段以及配置选择阶段这四个小的阶段。
**     初始引导加载器阶段**

　　1、设置内存使用模式：初始引导加载器阶段中，NTLDR将为Windows NT系统把计算机的微处理器从实模式转换为32位平面内存模式。

　　对基于X86CPU的计算机来说，第一次启动的时候总是进入所谓的实模式（RealMode）。在实模式下CPU的某些特性不能完全发挥，这是因为它要保证同8位或16位的CPU（如8086、8088）相兼容。这时系统会为MS－DOS或win 9x这样的16位系统预留640KB大小的内存空间，其余的内存都被看做是扩展内存。

　　而实模式下由于系统规格的限制，无法对大容量内存进行直接存取，而必须通过分段的方式完成。对于32位的Windows NT系统来说，8位或16位的CPU显然是无用的。对于32位的Windows NT系统来说，ntldr首先会将CPU切换到32位的模式，从而确保Windows XP的正常，然后设置CPU的运行使用32位的平面内存模式。

　　在CPU的32位模式下，可以对大容量内存进行直接存取，可以将所有内存都视为可用内存，而彻底抛弃了原先在8位或16位下分段存取内存的不便。这也是为什么32位模式称作平面（Flat）内存模式的原因。

　　2、启动文件系统：NTLDR执行适当的小型文件系统驱动程序（ntldr 中包含相应的代码，能够帮助Windows XP完成对NTFS或FAT格式的磁盘进行读写。从而能够读取、访问和复制文件。），这时NTLDR可以识别每一个用NTFS或FAT格式的文件系统分区，至此初始引导加载器阶段结束。
**    操作系统选择阶段**

　　当初始引导加载器阶段结束后将会进入操作系统选择阶段，NTLDR在活动分区根目录寻找并加载Boot.ini文件。（呵呵，这里贴的是我的机子上的boot.ini，搜集的资料中的boot.ini只有XP一项，所以贴上我的，丰富一点 o0_0o注）

在我的boot.ini中，包含以下内容：

[boot loader]

timeout=5

default=multi(0)disk(0)rdisk(0)partition(4)/WINDOWS

[operating systems]

multi(0)disk(0)rdisk(0)partition(4)/WINDOWS="Windows XP Media Center Edition" /noexecute=optin /fastdetect

multi(0)disk(0)rdisk(0)partition(3)/WINNT="Microsoft Windows 2000 Advanced Server" /fastdetect

C:/BOOTSECT.DOS="WINDOWS 98 SE"

C:/CHAIN0="MAC OS X 86PC"

C:/GHLDR="一键GHOST v2006.03.12"

        其中，multi(0)表示磁盘控制器，disk(0)rdisk(0)表示磁盘，partition(x)表示分区。NTLDR就是从这里查找Windows XP Professional的系统文件的位置的。（*本文不会更详细地讲解boot.ini的组成结构，因为其与本主题关系不大，如果想了解，可以到一些专门的网站处查询相关信息。）

　    如果计算机上安装了不止一个操作系统（也就是多系统），而且正确设置了boot.ini ，BOOT.INI 文件里面将含有两个或两个以上的启动选项，如果只有一个操作系统，Boot.ini文件中将只有一个操作系统的启动选项。在Boot.ini中只有一个启动选项或其中的超时值为0时，将不会出现选择操作系统的菜单画面。否则NTLDR将把Boot.ini中的所有启动项显示在屏幕上——这就是要求选择操作系统的多操作系统启动菜单，这时NTLDR 暂停系统引导，并且按照Boot.ini文件中的超时值开始读秒，等待用户选择一个启动选项直至超时。超时值由BOOT.INI 里面的TimeOut 值设定。

　　读秒超时以后，NTLDR 读取BOOT.INI里面DEFAULT 后面的信息，获取默认启动项对应的Windows 目录的路径以便执行后面的启动流程。

　　选择要启动的操作系统后，NTLDR 读取BOOT.INI里面相应启动项的位置信息，获取启动项对应的Windows 目录的路径以便执行后面的启动流程。

　　如果选择的启动选项是一个NT内核系统， NTLDR将会加载运行同目录下的NTDETECT.COM文件。

　　如果选择启动旧式的微软操作系统，如MS－DOS、Windows 9x／ME，NTLDR将按照Boot.ini中该启动项的信息加载BOOTSECT.DOS，然后ntldr会从bootsect.dos文件中读取MBR代码，然后将控制权交给bootsect.dos中的MBR（BOOTSECT.DOS由NT内核操作系统的安装程序在安装操作系统时读取活动分区中已经存在的DOS或win9x系统的分区引导记录来转换生成）。

　　如果选择了其它类别的操作系统，NTLDR将按照该启动项在Boot.ini中的启动配置进行加载（如我的Boot.ini中的C:/CHAIN0）

　　如果Boot.ini文件非法或不存在，那么NTLDR将会尝试从默认系统卷启动系统。

　　这里解释一下我的boot.ini。C:/BOOTSECT.DOS="WINDOWS 98 SE"，大家都知道啦！C:/CHAIN0="MAC OS X 86PC"，是我机子上安装的苹果的Tiger 10.4.5操作系统，CHAIN0像上边说的bootsect.dos一样，也是一个引导启动的转储文件。C:/GHLDR="一键GHOST v2006.03.12"，安装的DOS之家的"一键恢复GHOST "，同上边一样，GHLDR也是这个工具的一个引导启动的转储文件。看到这里，你应该比较明白一点了吧？

　　比如你装了Linux，使用工具把Linux的引导扇区记录做成转储文件，然后放到NTLDR所在的分区根目录，然后再在boot.ini里添加相应的启动项，在开机的多启动菜单里选择这个启动选项，NTLDR一样可以成功启动Linux。

　　我的第一个分区是活动分区（主分区），装的是98；第二个分区是一个MAC系统格式的主分区，安装的是MAC Tiger 10.4.5； 2000 Advanced Server装在扩展分区中的第一个逻辑分区；XP Media Center Edition装在扩展分区中的第二个逻辑分区。

　　其实引导启动的程序有很多，不过我们常用的是windows的Loader罢了。Linux下常用的启动器是Grub，其它常见的第三方工具有System Commander、Bootmanager BootStar等等。

　　　　注：

　　　　1、NTLDR启动后，如果在系统根目录下发现有Hiberfil.sys文件且该文件有效，那么NTLDR将读取Hiberfil.sys文件里的信息并让系统恢复到休眠以前的状态，这时并不处理Boot.ini文件。Hiberfil.sys文件是在XP系统启用休眠时生成的内存转储文件。

　　　　2、BOOTSECT.DOS：OS或Windows 9x系统启动扇区的转储文件。文件由Windows NT 安装程序创建，一般为512 字节。

　　　　3、Windows NT 架构操作系统：指在Windows NT 操作系统上发展起来的操作系统，目前主流的有:Windows 2000、WindowsXP 和Windows Server 2003 等。

　　　　4、NTLDR 的兼容性：NTLDR 具有向下兼容性。高版本的NTLDR 能够启动低版本的Windows NT 操作系统。目前最新版本的NTLDR 是在Windows Server 2003附带的版本。所以安装多系统时要按照从低到高的版本顺序。比如装了XP之后再装2000，2000会用自己的NTLDR来覆盖原有的XP的NTLDR，这时XP就不能启动了——2000的NTLDR不能引导XP以及比XP更高版本的系统。

　　　　5、从Windows XP with Service Pack 2 开始，操作系统安装程序在安装的时候将检测硬盘上活动分区中NTLDR和NTDETECT.COM的版本，如果发现现有的版本比安装源上的版本新的话，将使用现有版本而不使用安装源上的版本。
**     检测硬件阶段**

　　如果选择启动NT内核系统操作系统，在加载NTDETECT.COM文件后，硬件检测阶段开始。

　　在处理完boot.ini文件之后，ntldr会启动ntdetect.com程序。在基于X86的系统中，ntdetect.com会通过调用系统固件程序收集安装的硬件信息，然后由ntdetect.com将收集的计算机硬件信息列表并将列表返回到ntldr。这样做的目的是便于以后将这些硬件信息加入到注册表HKEY_LOCAL_MACHINE下的hardware中。

　　　　Ntdetect.com 会收集如下类型的硬件信息： 

　　　　　　& 系统固件信息，例如时间和日期等 

　　　　　　& 总线适配器的类型 

　　　　　　& 显卡适配器的类型 

　　　　　　& 键盘 

　　　　　　& 通信端口 

　　　　　　& 磁盘 

　　　　　　& 软盘 

　　　　　　& 输入设备，例如鼠标 

　　　　　　& 并口 

　　　　    　& 安装在ISA槽中的ISA设备 
**     配置选择阶段**

　　硬件检测完成后，进入配置选择阶段。Ntldr获取系统内的硬件配置文件，如果计算机含有多个硬件配置文件列表，可以通过按上下按钮来选择。如果只有一个硬件配置文件，计算机不显示此屏幕而直接使用默认的配置文件加载ntoskrnl.exe 程序——Windows XP内核。检测硬件和配置硬件阶段结束

　　至此，整个引导阶段结束

　　在引导阶段，系统要用到的文件一共有：NTLDR，Boot.ini，ntdetect.com，ntokrnl.exe，Ntbootdd.sys，bootsect.dos（可选的，如果已经有的情况下），这些文件默认的位置都在活动分区的根目录下。

　　注：如果在启动的时候按F8键，那么我们将会在启动菜单中看到多种选择启动模式，这时NTLDR将根据用户的选择来使用启动参数加载NT内核，用户也可以在Boot.ini文件里设置启动参数。

**     三、加载内核阶段**

　　Ntldr获取从ntdetect.com发来的信息后，将这些信息组织成为内部结构形式，然后由ntldr 启动ntoskrnl.exe程序,并将这些信息和boot.ini文件中的信息，以及注册表中的硬件和软件信息传递给ntoskrnl.exe 程序——Windows XP内核。

　　1、将内核（ntoskrnl.exe）和硬件抽象层（hal.dll）载入到内存

　　在加载内核阶段，ntldr加载称为内核的ntokrnl.exe，但是没有将它初始化。 接着ntldr加载硬件抽象层（HAL，hal.dll）。

　　2、加载控制集信息 

　　在这一过程中，ntldr从注册表中HKEY_LOCAL_MACHINE/SYSTEM的位置读取select键来决定哪一个控制集（Control Set）信息将被加载，并确定在启动过程中要加载的设备驱动。控制集中包含设备的驱动程序以及需要加载的服务。

　　3、加载设备驱动程序和服务 

　　在这一步中，系统会在BIOS的帮助下开始加载设备驱动程序，以及服务。

　　设备驱动程序，NTLDR将加载HKEY_LOCAL_MACHINE/system/service/...下start键值为0的最底层设备驱动。

　　当作为Control Set的镜像的Current Control Set被加载时，NTLDR将把控制权传递给Windows XP内核NTOSKRNL.EXE。

　　至内核加载阶段结束，接下来是初始化内核阶段。

**    四、初始化内核阶段**

　　在初始化内核阶段开始的时候，彩色的Windows XP的logo以及进度条显示在屏幕中央，在这个阶段，系统完成了启动的4项任务： 

　　1、内核使用在硬件检测时收集到的数据来创建了HKEY_LOCAL_MACHINE/HARDWARE键。

　　2、内核通过引用HKEY_LOCAL_MACHINE/system/Current的默认值复制Control Set来创建了Clone Control Set。Clone Control Set配置是计算机数据的备份，不包括启动中的改变，也不会被修改。 

　　3、系统完成初始化以及加载设备驱动程序

　　内核初始化那些在加载内核阶段被加载的底层驱动程序，然后内核扫描HKEY_LOCAL_MACHINE/system/CurrentControlSet/service/...下start键值为1的设备驱动程序。这些设备驱动程序在加载的时候便完成初始化，如果有错误发生，内核使用ErrorControl键值来决定如何处理。

　　start键值为3时，错误标志为危机/关键，系统初次遇到错误会以LastKnownGood Control Set重新启动，如果使用LastKnownGood Control Set启动仍然产生错误，系统报告启动失败，错误信息将被显示，系统停止启动；

　　值为2时错误情况为严重，系统启动失败并且以LastKnownGood Control Set重新启动，如果系统启动已经在使用LastKnownGood值，它会忽略错误并且继续启动；

　　当值是1的时候错误为普通，系统会产生一个错误信息，但是仍然会忽略这个错误并且继续启动；当值是0的时候忽略，系统不会显示任何错误信息而继续运行 。

　　4、启动会话管理器Session Manager

　　内核会启动会话管理器（Session Manager）,这是一个名为smss.exe 的程序，其作用表现如下： 

　　　　（1）创建系统环境变量 

　　　　（2）创建虚拟内存页面文件

　　　　（3）启动了Windows XP高级子系统以及服务

　　　　（4）启动了控制所有输入、输出设备以及访问显示器屏幕Win32子系统

      初始化内核完毕。

**     五、用户登录阶段**

**A      **在这一过程中，Windows 子系统会启动winlogon.exe，这是一个系统服务，用于提供对Windows 用户的登录和注销的支持。Winlogon.exe 可以完成如下一些工作： 

　　　　1、启动服务子系统（services.exe），也称服务控制管理器（Service Control Manager, SCM）。 

　　　　2、启动本地安全授权（Local Security Authority , LSA）过程（lsass.exe），同时Windows XP Professional欢迎屏幕或者登陆对话框显示，这时候，系统还可能在后台继续初始化刚才没有完成的驱动程序。 

　　　　3、在开始登录提示的时候，对Crtl+Alt+Del组合键进行分析处理。 

　　　　4、调用一个图形化的识别和认证组件提示输入有效的用户名或密码，收集用户的帐号和密码，然后将这些信息安全地传送给LSA以进行认证处理。如果用户提供的信息是正确的，能够通过认证，就允许用户对系统进行访问。 这时用户成功登录操作系统。

　　　要注意的是，如果您的计算机中，只有Administrator这一个用户，那么在欢迎屏幕中就会显示Administrator 用户项。如果您的计算机中不仅有Administrator用户，还有别的可以交互登录的用户，那么欢迎屏幕中就只显示出Administrator之外的用户，而不显示Administrator用户。 

　　　如果用户希望以Administrator用户登录，该怎么办呢？实际很简单，直接在欢迎屏幕中按下两次Crtl+Alt+Del组合键，即可打开标准的登录窗口，可以再输入Administrator 的用户名和密码，以便用最高管理员的身份登录。

**B**　  Service Controller最后执行以及扫描HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Servives来检查是否还有服务需要加载，Service Controller查找start键值为2或更高的服务，服务按照start的值以及DependOnGroup和DepandOnService的值来加载。

　　　即插即用设备的检测过程 

　　　对即插即用设备的检测，实际上是和登录过程异步进行的。由系统固件、硬件、设备驱动和系统特性决定了Windows XP如何对新设备进行检测和枚举。当即插即用组件正常工作后，Windows XP会对新设备进行检测，为它们分配系统资源，并在尽量不要用户提供选择的情况下，为新设备安装一个合适版本的驱动程序。


启动完成

　　　只有用户成功登陆到计算机后，Windows XP的启动才被认为是完成，在成功登陆后，系统拷贝Clone Control Set到LastKnownGood Control Set，完成这一步骤后，系统才意味着已经成功引导了。



