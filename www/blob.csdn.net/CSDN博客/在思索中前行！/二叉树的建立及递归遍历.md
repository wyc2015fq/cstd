# 二叉树的建立及递归遍历 - 在思索中前行！ - CSDN博客





2014年09月02日 17:08:17[_Tham](https://me.csdn.net/txl16211)阅读数：552标签：[树																[树的遍历](https://so.csdn.net/so/search/s.do?q=树的遍历&t=blog)](https://so.csdn.net/so/search/s.do?q=树&t=blog)
个人分类：[数据结构](https://blog.csdn.net/txl16211/article/category/2409063)








```cpp
#include<stdio.h>
#include<malloc.h>
#include<iostream>
 
//定义节点 
typedef struct BiNode{
        char data;
        struct BiNode *lch;
        struct BiNode *rch;
}BiNode,*BiTree;
 
//先序拓展序列建立二叉树 
void Create(BiTree &T)
{
        T =(BiNode*) malloc (sizeof(BiNode));
         
        printf("Enter the data \n");
        scanf(" %c",&T->data);
        if(T->data=='#') T = NULL;
        if(T){
                printf("");
                Create(T->lch);
                Create(T->rch);
        }
}
 
//先序遍历 (递归)
void Preorder (BiTree T)
{                    
   if (T) {
      printf(" %c",T->data);             // 访问根结点
       
      Preorder(T->lch); // 遍历左子树
      Preorder(T->rch);// 遍历右子树
   }
}
 
//中序遍历 （递归）
void Inorder (BiTree T)
{
     if(T) {
       Inorder(T->lch);
        
       printf(" %c",T->data);
        
       Inorder(T->rch);    
       }
} 
 
//后序遍历 （递归）
void Postorder (BiTree T)
{
     if(T) {
       Postorder(T->lch);
       Postorder(T->rch);
        
       printf(" %c",T->data); 
     }
} 
 
int main()
{
    //建树 
    printf("The fuction Create() is called.\n");
    BiTree T;
    Create(T);
     
    //三种遍历递归算法 
    printf("\n");    
    printf("The fuction Preorder() is called.\n");
    Preorder(T);
     
    printf("\n");
    printf("The fuction Inorder() is called.\n");
    Inorder(T);
     
    printf("\n");
    printf("The fuction Postorder() is called.\n");
    Postorder(T);
     
     
    printf("\n");
    system("pause");
     
}</span>
```

**二叉树建立的及递归遍历**



```cpp
#include <iostream>
#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>
typedef struct node
{
    char data;
    struct node *lchild;
    struct node *rchild;
}*BiTree;
 
void creatBT(BiTree &T)//建立一个二叉树的函数
{
    char ch;
    scanf("%c",&ch);
    if(ch=='.')
    {
        T=NULL;//   . 代表空子树；
    }
    else
    {
        T=(node *)malloc(sizeof(node));//分配一个node的空间
        if(!T)exit(0);
        T->data = ch;//给T赋值
        creatBT(T->lchild);//给左子树赋值
        creatBT(T->rchild);//给右子树赋值
    }
}
 
void pre_order(node *T)//前序遍历二叉树
{
    if(T)
    {
        printf("%c ",T->data);
        pre_order(T->lchild);
        pre_order(T->rchild);
    }
 
}
 
void mid_order(node *T)//中序遍历二叉树
{
    if(T)
    {
        mid_order(T->lchild);
        printf("%c ",T->data);
        mid_order(T->rchild);
    }
}
 
void behind_order(node *T)//后序遍历二叉树
{
    if(T)
    {
        behind_order(T->lchild);
        behind_order(T->rchild);
        printf("%c ",T->data);
    }
}
 
int main()
{
    node *T;
    printf("请输按先序序列输入一串字符,当子树为空时,用.来代替\n");
    creatBT(T);//建树
    printf("建树成功,T指向二叉树的根!\n");
 
    printf("\n前序遍历二叉树的结果是:");
    pre_order(T);
 
    printf("\n中序遍历二叉树的结果是:");
    mid_order(T);
 
    printf("\n后序遍历二叉树的结果是:");
    behind_order(T);printf("\n");
     
     
    system("pause");
     
    return 0;
}</span>
```
**二叉树的层次遍历**




```cpp
#include <stdio.h>
#include<stdlib.h>
typedef struct Bitree
{
    int data;
    struct Bitree *Lchild,*Rchild;
}BitreeNode,*LinkBitree;
 
typedef struct QueueList
{
    LinkBitree data[20];
    int front,rear;
}QueueList,*LinkQueue;
 
LinkBitree CreatBitree();
 
void LevelOrderTraverse(LinkBitree);
 
void InitQueue(LinkQueue);
 
int main()
{
    LinkBitree BitreeHead;
    printf("请输入根结点的值e：");
    BitreeHead=CreatBitree();
    LevelOrderTraverse(BitreeHead);
    return 0;
}
 
LinkBitree CreatBitree()
{
    int e_data;
    LinkBitree BitreeHead;
    scanf("%d",&e_data);
    if(e_data!=0)
    {
        BitreeHead=(LinkBitree)malloc(sizeof(BitreeNode));
        if(BitreeHead==NULL)
        {
            printf("Error!!");
        }
        else
        {
            BitreeHead->data=e_data;
            printf("请输入结点%d的左孩子结点的值：e= ",BitreeHead->data);
            BitreeHead->Lchild=CreatBitree();
            printf("请输入结点%d的右孩子结点的值：e= ",BitreeHead->data);
            BitreeHead->Rchild=CreatBitree();
        }
    }
    else
    {
        BitreeHead=NULL;
    }
    return BitreeHead;
}
void LevelOrderTraverse(LinkBitree BitreeHead)
{
    LinkQueue Q;
    Q=(LinkQueue)malloc(sizeof(sizeof(QueueList)));
    InitQueue(Q);
    if(BitreeHead!=NULL)
    {
        Q->data[Q->rear]=BitreeHead;
        Q->rear=Q->rear+1;
    }
    while(Q->front!=Q->rear)
    {
        printf("%d  ",Q->data[Q->front]->data);
        if(Q->data[Q->front]->Lchild!=NULL)
        {
            Q->data[Q->rear]=Q->data[Q->front]->Lchild;
            Q->rear=Q->rear+1;
        }
        if(Q->data[Q->front]->Rchild!=NULL)
        {
            Q->data[Q->rear]=Q->data[Q->front]->Rchild;
            Q->rear=Q->rear+1;
        }
        Q->front=Q->front+1;
    }
}
void InitQueue(LinkQueue Q)
{
    Q->front=Q->rear=0;
}
```











