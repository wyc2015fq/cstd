# 数据结构和算法系列 - 单链表 - 自娱自乐的代码人，专注Java、c、php - CSDN博客





2014年09月14日 22:03:42[initphp](https://me.csdn.net/initphp)阅读数：1081
个人分类：[数据结构和算法系列](https://blog.csdn.net/initphp/article/category/1161961)









### 单链表定义

单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。

单向链表的每一个元素Item中，有一个元素会存放下一个Item的内存地址。当找到第一个元素，就能通过这个元素中存放的第二个元素的地址值找到第三个元素，继而找到第四个，第五个，第六个元素。

图1，单向链表的结构图。图中Item1元素中存放着Item2的元素地址值，Item2中存放着Item3的元素内存地址值。所以整个单链表看起来像一个链条一样串联起来。

![](https://img-blog.csdn.net/20140914213940154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)




### 单链表的基本操作

如何来操作单链表？我们这边只进行比较基本的操作。

**1. 添加元素。**添加元素有两种方法：头插法和尾插法。

**头插法**：将链表的左边称为链表头部，右边称为链表尾部。头插法将右边固定，每次新增的元素都在左边头部增加。

![](https://img-blog.csdn.net/20140914215229470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


**尾插法：**将链表的左边称为链表头部，右边称为链表尾部。尾插法是将左边固定，每次新增都在链表的右边最尾部。

![](https://img-blog.csdn.net/20140914215240951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)





**2. 查询元素。**通过元素信息来查询相关的ITEM，需要从头部遍历到尾部。




**3. 删除元素。**删除一个元素后，需要将元素左边Item存储的next元素的值指向到该删除元素右边的值。

![](https://img-blog.csdn.net/20140914215626013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)




### 单链表结构体定义

我们定义了一个结构体，结构体中username和age分别用来存储用户名和年龄，而next则用来存储下一个Item元素的内存地址。



```cpp
/**
 * 定义一个单链表的数据结构
 */
typedef struct single_linked_list_s {
	char * username;
	unsigned int age;
	struct single_linked_list_s * next;
} single_linked_list;
```


并且定义一个list指针用来存放单链表。





```cpp
/**
 * 一定一个指针，存放单链表
 */
single_linked_list *list;
```


然后定义三个方法：





```cpp
/**
 * 插入一条记录
 */
void insert(char *username, unsigned int age);

/**
 * 获取一条记录
 */
single_linked_list *get(char *username);

/**
 * 通过username去删除一个元素
 */
void delete(char *username);
```




### 具体实现

1. 添加操作，我们使用了尾插入法。



```cpp
void insert(char *username, unsigned int age) {
	single_linked_list *temp = (single_linked_list *) malloc(
			sizeof(single_linked_list));
	if (temp != NULL ) {
		temp->username = username;
		temp->age = age;
		temp->next = NULL;
		if (list == NULL ) {
			list = temp;
		} else {
			single_linked_list *temp_list = list;
			while (temp_list->next != NULL ) {
				temp_list = temp_list->next;
			}
			temp_list->next = temp;
		}
	}
}
```


2. 查询操作。





```cpp
single_linked_list *get(char *username) {
	if (list == NULL ) {
		return NULL ;
	}
	single_linked_list *temp = NULL;
	single_linked_list *temp_list = list;
	while (temp_list->next != NULL ) {
		if (strcmp(temp_list->username, username) == 0) {
			temp = temp_list;
			break;
		} else {
			temp_list = temp_list->next;
		}
	}
    if (temp_list->next == NULL ) {
        if (strcmp(temp_list->username, username) == 0) {
            temp = temp_list;
        }
    }
        return temp;
}
```


3. 删除操作。



```cpp
void delete(char *username) {
	if (list == NULL ) {
		return;
	}
	single_linked_list *temp_pre = NULL; //前一个元素
	single_linked_list *temp_next = NULL; //下一个元素
	single_linked_list *temp_current = list; //当前元素
	while (temp_current->next != NULL ) {
		if (strcmp(temp_current->username, username) == 0) {
			if (temp_pre != NULL ) {
				temp_pre->next = temp_next;
			}
			break;
		}
		temp_pre = temp_current;
		temp_current = temp_current->next;
		if (temp_current->next != NULL ) {
			temp_next = temp_current->next;
		}
	}
	if (list == temp_current) {
		if (list->next != NULL ) {
			list = list->next;
		} else {
			list = NULL;
		}
	}
	free(temp_current);
}
```









### 完整例子

single_linked_list.h




```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>

/**
 * 定义一个单链表的数据结构
 */
typedef struct single_linked_list_s {
	char * username;
	unsigned int age;
	struct single_linked_list_s * next;
} single_linked_list;

/**
 * 一定一个指针，存放单链表
 */
single_linked_list *list;

/**
 * 插入一条记录
 */
void insert(char *username, unsigned int age);

/**
 * 获取一条记录
 */
single_linked_list *get(char *username);

/**
 * 通过username去删除一个元素
 */
void delete(char *username);
```


single_linked_list.c



```cpp
#include "single_linked_list.h"

void insert(char *username, unsigned int age) {
	single_linked_list *temp = (single_linked_list *) malloc(
			sizeof(single_linked_list));
	if (temp != NULL ) {
		temp->username = username;
		temp->age = age;
		temp->next = NULL;
		if (list == NULL ) {
			list = temp;
		} else {
			single_linked_list *temp_list = list;
			while (temp_list->next != NULL ) {
				temp_list = temp_list->next;
			}
			temp_list->next = temp;
		}
	}
}

single_linked_list *get(char *username) {
	if (list == NULL ) {
		return NULL ;
	}
	single_linked_list *temp = NULL;
	single_linked_list *temp_list = list;
	while (temp_list->next != NULL ) {
		if (strcmp(temp_list->username, username) == 0) {
			temp = temp_list;
			break;
		} else {
			temp_list = temp_list->next;
		}
	}
	if (temp_list->next == NULL ) {
		if (strcmp(temp_list->username, username) == 0) {
			temp = temp_list;
		}
	}
	return temp;
}

void delete(char *username) {
	if (list == NULL ) {
		return;
	}
	single_linked_list *temp_pre = NULL; //前一个元素
	single_linked_list *temp_next = NULL; //下一个元素
	single_linked_list *temp_current = list; //当前元素
	while (temp_current->next != NULL ) {
		if (strcmp(temp_current->username, username) == 0) {
			if (temp_pre != NULL ) {
				temp_pre->next = temp_next;
			}
			break;
		}
		temp_pre = temp_current;
		temp_current = temp_current->next;
		if (temp_current->next != NULL ) {
			temp_next = temp_current->next;
		}
	}
	if (list == temp_current) {
		if (list->next != NULL ) {
			list = list->next;
		} else {
			list = NULL;
		}
	}
	free(temp_current);
}
```







