# PHP相关系列 - 使用 PHP 直接在共享内存中存储数据集 - 自娱自乐的代码人，专注Java、c、php - CSDN博客





2012年06月28日 11:32:26[initphp](https://me.csdn.net/initphp)阅读数：968








来源：[http://www.ibm.com/developerworks/cn/opensource/os-php-shared-memory/](http://www.ibm.com/developerworks/cn/opensource/os-php-shared-memory/)



**概述**

共享内存是一种在相同机器中的应用程序之间交换数据的有效方式。一个进程可创建一个可供其他进程访问的内存段，只要它分配了正确的权限。每个内存段拥有一个惟一的 ID（称为 *shmid*），这个 ID 指向一个物理内存区域，其他进程可在该区域操作它。创建并提供了合适的权限之后，同一台机器中的其他进程就可以操作这些内存段：读取、写入和删除。

这表明使用 C 语言编写的应用程序可与使用其他语言（比如 Java™ 或 PHP）编写的应用程序共享信息。它们都可以共享信息，只要它们可访问和理解该信息。共享内存在针对大部分语言的实现中得到了广泛使用，所以访问应该不是问题。要理解信息，我们可以使用一种标准格式，比如 XML 或 JSON。

共享内存的使用是一种在进程之间交换数据的快速方法，主要因为在创建内存段之后传递数据，不会涉及内核。这种方法常常称为进程间通信 (IPC)。其他 IPC 方法包括管道、消息队列、RPC 和套接字。当使用需要彼此通信的应用程序的生态系统时，这种在应用程序之间快速、可靠地交换数据的能力非常有用。取决于生态系统的大小，使用数据库在应用程序之间交换信息的常用方法常常会导致查询缓慢，甚至 I/O 阻塞。使用共享内存，没有 I/O 会减缓开发人员的进度。

本文的提议非常简单，学习如何使用 PHP 创建和操作共享内存段，使用它们存储可供其他应用程序使用的数据集。即使没有使用共享内存交换数据的计划，它本身也在许多好处，因为它使应用程序能够远离 I/O 问题。将数据集直接存储在内存中具有诸多优势，从 Web 服务数据缓存到会话共享。它是一个非常有用的概念，每个 PHP 开发人员都应该知道。



**共享内存和PHP**

PHP 拥有丰富的可用扩展，共享内存也一样。使用一些共享的函数，无需安装任何扩展，开发人员就能够轻松操作内存段。




**创建内存段**

共享内存函数类似于文件操作函数，但无需处理一个流，您将处理一个共享内存访问 ID。第一个示例就是 `shmop_open` 函数，它允许您打开一个现有的内存段或创建一个新内存段。此函数非常类似于经典的 `fopen` 函数，后者打开用于文件操作的流，返回一个资源供其他希望读取或写入该打开的流的函数使用。让我们看看清单
 1 中的 `shmop_open`。

```php
<?php

$systemid = 864; // System ID for the shared memory segment
$mode = "c"; // Access mode
$permissions = 0755; // Permissions for the shared memory segment
$size = 1024; // Size, in bytes, of the segment

$shmid = shmop_open($systemid, $mode, $permissions, $size);

?>
```


该函数中出现的第一个事物是系统 ID 参数。这是标识系统中的共享内存段的数字。第二个参数是访问模式，它非常类似于 `fopen` 函数的访问模式。您可以在 4 种不同的模式下访问一个内存段：
- 模式 “a”，它允许您访问只读内存段
- 模式 “w”，它允许您访问可读写的内存段
- 模式 “c”，它创建一个新内存段，或者如果该内存段已存在，尝试打开它进行读写
- 模式 “n”，它创建一个新内存段，如果该内存段已存在，则会失败

第三个参数是内存段的权限。您必须在这里提供一个八进制值。

第四个参数提供内存段大小，以字节为单位。在写入一个内存段之前，您必须在它之上分配适当的字节数。

请注意，此函数返回一个 ID 编号，其他函数可使用该 ID 编号操作该共享内存段。这个 ID 是共享内存访问 ID，与系统 ID 不同，它以参数的形式传递。请注意不要混淆这两者。如果失败，`shmop_open` 将返回 FALSE。



**向内存段写入数据**

使用 `shmop_write` 函数向共享内存块写入数据。此函数的使用很简单，它仅接受 3 个参数，如清单 2 所示。

```php
<?php

$shmid = shmop_open(864, 'c', 0755, 1024);
shmop_write($shmid, "Hello World!", 0);

?>
```

这个函数类似于 `fwrite` 函数，后者有两个参数：打开的流资源（由 `fopen` 返回）和您希望写入的数据。`shmop_write` 函数也执行此任务。

第一个参数是 `shmop_open` 返回的 ID，它识别您操作的共享内存块。第二个参数是您希望存储的数据，最后的第三个参数是您希望开始写入的位置。默认情况下，我们始终使用 0 来表示开始写入的位置。请注意，此函数在失败时会返回 FALSE，在成功时会返回写入的字节数。



**向内存段读取数据**

从共享内存段读取数据很简单。您只需要一个打开的内存段和 `shmop_read` 函数。此函数接受一些参数，工作原理类似于 `fread`。参见清单
 3，读取一个 PHP 文件的内容。

```php
<?php

$stream = fopen('file.txt', 'r+');
fwrite($stream, "Hello World!");
echo fread($stream, 11);

?>
```

读取共享内存段的内容的过程与此类似，如清单 4 所示：

```php
<?php

$shmid = shmop_open(864, 'c', 0755, 1024);
shmop_write($shmid, "Hello World!", 0);
echo shmop_read($shmid, 0, 11);

?>
```

请留意这里的参数。`shmop_read` 函数将接受 `shmop_open` 返回的
 ID，我们已知道它，不过它还接受另外两个参数。第二个参数是您希望从内存段读取的位置，而第三个是您希望读取的字节数。第二个参数可以始终为 0，表示数据的开头，但第三个参数可能存在问题，因为我们不知道我们希望读取多少字节。

这非常类似于我们在 `fread` 函数中的行为，该函数接受两个参数：打开的流资源（由 `fopen` 返回）和您希望从该流读取的字节数。使用 `filesize` 函数（它返回一个文件中的字节数）来完整地读取它。

幸运的是，当使用共享内存段时，`shmop_size` 函数返回一个内存段的大小（以字节为单位），类似于 `filesize` 函数。参见清单
 5。

```php
<?php

$shmid = shmop_open(864, 'c', 0755, 1024);
shmop_write($shmid, "Hello World!", 0);

$size = shmop_size($shmid);
echo shmop_read($shmid, 0, $size);

?>
```




**删除内存段**

我们学习了如何打开、写入和读取共享内存段。要完成我们的 CRUD 类，我们还需要学习如何删除内存段。该任务可使用`shmop_delete` 函数轻松完成，该函数仅接受一个参数：我们希望删除的共享内存 ID。

```php
<?php

$shmid = shmop_open(864, 'c', 0755, 1024);
shmop_write($shmid, "Hello World!", 0);
shmop_delete($shmid);

?>
```

这不会实际删除该内存段。它将该内存段标记为删除，因为共享内存段在有其他进程正在使用它时无法被删除。`shmop_delete` 函数将该内存段标记为删除，阻止任何其他进程打开它。要删除它，我们需要关闭该内存段。



**关闭内存段**

打开一个共享内存段会 “附加” 到它。附加该内存段之后，我们可在其中进行读取和写入，但完成操作后，我们必须从它解除。这使用清单 7 中的 `shmop_close` 函数来完成。

这非常类似于处理文件时的 `fclose` 函数。打开包含一个文件的流并在其中读取或写入数据后，我们必须关闭它，否则将发生锁定。

```php
<?php

$shmid = shmop_open(864, 'c', 0755, 1024);
shmop_write($shmid, "Hello World!", 0);
shmop_delete($shmid);
shmop_close($shmid);

?>
```



**使用共享内存段**

有了共享内存和共享内存段上基本 CRUD 操作的基本知识，是时候应用此知识了。我们可以使用共享内存作为一种独特的存储选项，提供快速读/写操作和进程互操作性等优势。对于 Web 应用程序，这意味着：
- 缓存存储（数据库查询、Web 服务数据、外部数据）
- 会话存储
- 应用程序之间的数据交换

在继续之前，我想介绍一个名为 SimpleSHM 小型库。SimpleSHM 是一个较小的抽象层，用于使用 PHP 操作共享内存，支持以一种面向对象的方式轻松操作内存段。在编写使用共享内存进行存储的小型应用程序时，这个库可帮助创建非常简洁的代码。要了解 SimpleSHM，请访问 [GitHub
 页面](https://github.com/klaussilveira/SimpleSHM)。

您可以使用 3 个方法进行处理：读、写和删除。从该类中简单地实例化一个对象，可以控制打开的共享内存段。清单 8 展示了基本用途。


```php
<?php

$memory = new SimpleSHM;
$memory->write('Sample');
echo $memory->read();

?>
```

请注意，这里没有为该类传递一个 ID。如果没有传递 ID，它将随机选择一个编号并打开该编号的新内存段。我们可以以参数的形式传递一个编号，供构造函数打开现有的内存段，或者创建一个具有特定 ID 的内存段，如清单 9 所示。


```php
<?php

$new = new SimpleSHM(897);
$new->write('Sample');
echo $new->read();

?>
```

神奇的方法 `__destructor` 负责在该内存段上调用 `shmop_close` 来取消设置对象，以与该内存段分离。我们将这称为
 “SimpleSHM 101”。现在让我们将此方法用于更高级的用途：使用共享内存作为存储。存储数据集需要序列化，因为数组或对象无法存储在内存中。尽管这里使用了 JSON 来序列化，但任何其他方法（比如 XML 或内置的 PHP 序列化功能）也已足够。清单 10 给出了一个示例。

```php
<?php

require('SimpleSHM.class.php');

$results = array(
	'user' => 'John',
	'password' => '123456',
	'posts' => array('My name is John', 'My name is not John')
);

$data = json_encode($results);

$memory = new SimpleSHM;
$memory->write($data);
$storedarray = json_decode($memory->read());

print_r($storedarray);

?>
```

我们成功地将一个数组序列化为一个 JSON 字符串，将它存储在共享内存块中，从中读取数据，去序列化 JSON 字符串，并显示存储的数组。这看起来很简单，但请想象一下这个代码片段带来的可能性。您可以使用它存储 Web 服务请求、数据库查询或者甚至模板引擎缓存的结果。在内存中读取和写入将带来比在磁盘中读取和写入更高的性能。

使用此存储技术不仅对缓存有用，也对应用程序之间的数据交换也有用，只要数据以两端都可读的格式存储。不要低估共享内存在 Web 应用程序中的力量。可采用许多不同的方式来巧妙地实现这种存储，惟一的限制是开发人员的创造力和技能。


















