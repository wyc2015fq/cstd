# 安卓开发22：广播机制 - 自娱自乐的代码人，专注Java、c、php - CSDN博客





2013年07月15日 10:31:39[initphp](https://me.csdn.net/initphp)阅读数：2557
所属专栏：[安卓开发](https://blog.csdn.net/column/details/androidgo.html)









### 安卓的广播机制：

说明：广播广播，其实就是一个地方将信息传播出去，只要有广播接收器的地方都能同时接收到信息。安卓的广播机制一般可以针对应用内的广播，也可以针对跨应用广播。例如电池的事件，电池快没电的时候，会发送一个广播，如果你的应用中有接收这个广播，则就会调用广播接收的程序。

广播和Service都是在UI线程中处理的，所以使用广播的时候，不能处理延迟很长的操作，否则会阻碍UI线程的更新。通过广播，可以监听外部APP发送过来的广播消息，通过这些广播消息，可以做出相应的处理。


看一个图：

![](https://img-blog.csdn.net/20130715102918453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)




一些观点：
- 在Android 中如果要发送一个广播必须使用sendBroadCast 向系统发送对其感兴趣的广播接收器中。
- 使用广播必须要有一个intent 对象必设置其action动作对象。
- 使用广播必须在配置文件中显式的指明该广播对象
- 每次接收广播都会重新生成一个接收广播的对象
- 在BroadCast 中尽量不要处理太多逻辑问题，建议复杂的逻辑交给Activity 或者 Service 去处理




### 广播例子，常驻型广播

**常驻型广播**，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行注册。


首先需要配置AndroidMainfest.xml



```
<!--
             android:name就是限定了只能在 TestReceiver 
        	广播接收器中接收 android.intent.action.EDIT类型的广播
        -->
        <receiver android:name=".TestReceiver" >
            <intent-filter>
                <action android:name="android.intent.action.EDIT" />
            </intent-filter>
        </receiver>
        <receiver android:name=".Test2Receiver" >
            <intent-filter>
                <action android:name="android.intent.action.EDIT" />
            </intent-filter>
        </receiver>
```




发送一个广播 MainActivity.java：



```java
package com.example.test.com;


import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;

@SuppressLint("HandlerLeak")
public class MainActivity extends Activity {

    private Button btn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_main);

        btn = (Button) findViewById(R.id.button1);
        //图片点击的时候
        btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent intent = new Intent();//采用intent发送数据
                intent.setAction(Intent.ACTION_EDIT);//只发送给action为ACTION_EDIT的对象
                Bundle bundle = new Bundle();
                bundle.putString("val", "Hello World");
                intent.putExtras(bundle);
                //通过广播方式发送该intent，只有特定action的接收者才能收到该广播信息
                MainActivity.this.sendBroadcast(intent);
            }
        });
    }

}
```


接收广播，需要继承BroadcastReceiver类，并且实现onReceive方法：

TestReceiver:



```java
package com.example.test.com;


import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

public class TestReceiver extends BroadcastReceiver {

    public TestReceiver() {
        System.out.println("TestReceiver");

    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        //这边可以获取Action的名称
        if (action.equals(Intent.ACTION_EDIT)) {
            Bundle bundle = intent.getExtras();
            System.out.println("OnReceiver" + bundle.getString("val"));
        }
    }
}
```






Test2Receiver:



```java
package com.example.test.com;


import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

public class Test2Receiver extends BroadcastReceiver {

    public Test2Receiver() {
        System.out.println("Test2Receiver");

    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(Intent.ACTION_EDIT)) {
            Bundle bundle = intent.getExtras();
            System.out.println("OnReceiver2" + bundle.getString("val"));
        }
    }
}
```


点击按钮后，控制台效果：

![](https://img-blog.csdn.net/20130715104825078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)




接收器的生命周期：

![](https://img-blog.csdn.net/20130715104915500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW5pdHBocA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



### 广播例子，非常驻型广播

当应用程序结束了，广播自然就没有了，比如你在activity中的onCreate或者onResume中注册广播接收器在onDestory中卸载广播接收器。这样你的广播接收器就一个非常驻型的了。这种也叫动态注册。




```java
package com.example.test.com;


import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;

@SuppressLint("HandlerLeak")
public class MainActivity extends Activity {

    private Button       btn;
    private TestReceiver testReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_main);

        //初始化的时候注册
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_EDIT);
        testReceiver = new TestReceiver();
        registerReceiver(testReceiver, filter);

        btn = (Button) findViewById(R.id.button1); 
        btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent intent = new Intent();//采用intent发送数据  
                intent.setAction(Intent.ACTION_EDIT);//只发送给action为ACTION_EDIT的对象  
                Bundle bundle = new Bundle();  
                bundle.putString("val", "Hello World");  
                intent.putExtras(bundle);  
                //通过广播方式发送该intent，只有特定action的接收者才能收到该广播信息  
                MainActivity.this.sendBroadcast(intent);  

            }

        });
    }

    @Override
    protected void onDestroy() {
        unregisterReceiver(testReceiver);
    }

}
```


```java
package com.example.test.com;


import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

public class TestReceiver extends BroadcastReceiver {

    public TestReceiver() {
        System.out.println("TestReceiver");

    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        //这边可以获取Action的名称  
        if (action.equals(Intent.ACTION_EDIT)) {
            Bundle bundle = intent.getExtras();
            System.out.println("OnReceiver" + bundle.getString("val"));
        }
    }
}
```


下面是一个内部类实现广播接收的例子，通过内部类实现，可以动态监听广播消息，并且对广播进行UI界面上的处理



```java
package com.example.test.com;


import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends Activity {

    private ButtonOnClickListener btnListener;

    private Button btn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.main);
        btn = (Button) findViewById(R.id.button1);
        btnListener = new ButtonOnClickListener();
        btn.setOnClickListener(btnListener);

    }

    class ButtonOnClickListener implements OnClickListener {

        @Override
        public void onClick(View v) {
            Toast.makeText(getBaseContext(), "YES!", Toast.LENGTH_SHORT).show();
            
            TestBroadcast testBroadCast = new TestBroadcast();
            IntentFilter filter = new IntentFilter();
            filter.addAction(Intent.ACTION_EDIT);    //只有持有相同的action的接受者才能接收此广播
            registerReceiver(testBroadCast, filter); //注册
            
            Intent intent = new Intent();//采用intent发送数据    
            Bundle bundle = new Bundle();
            bundle.putString("hello", "world");
            intent.putExtras(bundle);
            intent.setAction(Intent.ACTION_EDIT);//只发送给action为ACTION_EDIT的对象    
            MainActivity.this.sendBroadcast(intent);  
        }
    }

    //通过内部类，可以实现UI修改
    class TestBroadcast extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            Toast.makeText(context, "YES2!", Toast.LENGTH_SHORT).show();
            String action = intent.getAction();
            if (action.equals(Intent.ACTION_EDIT)) {
                Bundle bundle = intent.getExtras();
                btn.setText(bundle.getString("hello")); //更改btn的文字
            }
        }
    }



}
```





### 安卓系统广播



```java
String ADD_SHORTCUT_ACTION 动作：在系统中添加一个快捷方式。
    String ALL_APPS_ACTION 动作：列举所有可用的应用。输入：无。
    String ALTERNATIVE_CATEGORY 类别：说明 activity 是用户正在浏览的数据的一个可选操作。
    String ANSWER_ACTION 动作：处理拨入的电话。
    String BATTERY_CHANGED_ACTION 广播：充电状态，或者电池的电量发生变化。
    String BOOT_COMPLETED_ACTION 广播：在系统启动后，这个动作被广播一次（只有一次）。
    String BROWSABLE_CATEGORY 类别：能够被浏览器安全使用的 activities 必须支持这个类别。
    String BUG_REPORT_ACTION 动作：显示 activity 报告错误。
    String CALL_ACTION 动作：拨打电话，被呼叫的联系人在数据中指定。
    String CALL_FORWARDING_STATE_CHANGED_ACTION 广播：语音电话的呼叫转移状态已经改变。
    String CLEAR_CREDENTIALS_ACTION 动作：清除登陆凭证 (credential)。
    String CONFIGURATION_CHANGED_ACTION 广播：设备的配置信息已经改变，参见 Resources.Configuration.
    Creator CREATOR 无 无
    String DATA_ACTIVITY_STATE_CHANGED_ACTION 广播：电话的数据活动(data activity)状态（即收发数据的状态）已经改变。
    String DATA_CONNECTION_STATE_CHANGED_ACTION 广播：电话的数据连接状态已经改变。
    String DATE_CHANGED_ACTION 广播：日期被改变。
    String DEFAULT_ACTION 动作：和 VIEW_ACTION 相同，是在数据上执行的标准动作。
    String DEFAULT_CATEGORY 类别：如果 activity 是对数据执行确省动作（点击, center press）的一个选项，需要设置这个类别。
    String DELETE_ACTION 动作：从容器中删除给定的数据。
    String DEVELOPMENT_PREFERENCE_CATEGORY 类别：说明 activity 是一个设置面板 (development preference panel).
    String DIAL_ACTION 动作：拨打数据中指定的电话号码。
    String EDIT_ACTION 动作：为制定的数据显示可编辑界面。
    String EMBED_CATEGORY 类别：能够在上级（父）activity 中运行。
    String EMERGENCY_DIAL_ACTION 动作：拨打紧急电话号码。
    int FORWARD_RESULT_LAUNCH 启动标记：如果这个标记被设置，而且被一个已经存在的 activity 用来启动新的 activity，已有 activity 的回复目标 (reply target) 会被转移给新的 activity。
    String FOTA_CANCEL_ACTION 广播：取消所有被挂起的 (pending) 更新下载。
    String FOTA_INSTALL_ACTION 广播：更新已经被确认，马上就要开始安装。
    String FOTA_READY_ACTION 广播：更新已经被下载，可以开始安装。
    String FOTA_RESTART_ACTION 广播：恢复已经停止的更新下载。
    String FOTA_UPDATE_ACTION 广播：通过 OTA 下载并安装操作系统更新。
    String FRAMEWORK_INSTRUMENTATION_TEST_CATEGORY 类别：To be used as code under test for framework instrumentation tests.
    String GADGET_CATEGORY 类别：这个 activity 可以被嵌入宿主 activity (activity that is hosting gadgets)。
    String GET_CONTENT_ACTION 动作：让用户选择数据并返回。
    String HOME_CATEGORY 类别：主屏幕 (activity)，设备启动后显示的第一个 activity。
    String INSERT_ACTION 动作：在容器中插入一个空项 (item)。
    String INTENT_EXTRA 附加数据：和 PICK_ACTIVITY_ACTION 一起使用时，说明用户选择的用来显示的 activity；和 ADD_SHORTCUT_ACTION 一起使用的时候，描述要添加的快捷方式。
    String LABEL_EXTRA 附加数据：大写字母开头的字符标签，和 ADD_SHORTCUT_ACTION 一起使用。
    String LAUNCHER_CATEGORY 类别：Activity 应该被显示在顶级的 launcher 中。
    String LOGIN_ACTION 动作：获取登录凭证。
    String MAIN_ACTION 动作：作为主入口点启动，不需要数据。
    String MEDIABUTTON_ACTION 广播：用户按下了“Media Button”。
    String MEDIA_BAD_REMOVAL_ACTION 广播：扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)。
    String MEDIA_EJECT_ACTION 广播：用户想要移除扩展介质（拔掉扩展卡）。
    String MEDIA_MOUNTED_ACTION 广播：扩展介质被插入，而且已经被挂载。
    String MEDIA_REMOVED_ACTION 广播：扩展介质被移除。
    String MEDIA_SCANNER_FINISHED_ACTION 广播：已经扫描完介质的一个目录。
    String MEDIA_SCANNER_STARTED_ACTION 广播：开始扫描介质的一个目录。
    String MEDIA_SHARED_ACTION 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。
    String MEDIA_UNMOUNTED_ACTION 广播：扩展介质存在，但是还没有被挂载 (mount)。
    String MESSAGE_WAITING_STATE_CHANGED_ACTION 广播：电话的消息等待（语音邮件）状态已经改变。
    int MULTIPLE_TASK_LAUNCH 启动标记：和 NEW_TASK_LAUNCH 联合使用，禁止将已有的任务改变为前景任务 (foreground)。
    String NETWORK_TICKLE_RECEIVED_ACTION 广播：设备收到了新的网络 "tickle" 通知。
    int NEW_TASK_LAUNCH 启动标记：设置以后，activity 将成为历史堆栈中的第一个新任务（栈顶）。
    int NO_HISTORY_LAUNCH 启动标记：设置以后，新的 activity 不会被保存在历史堆栈中。
    String PACKAGE_ADDED_ACTION 广播：设备上新安装了一个应用程序包。
    String PACKAGE_REMOVED_ACTION 广播：设备上删除了一个应用程序包。
    String PHONE_STATE_CHANGED_ACTION 广播：电话状态已经改变。
    String PICK_ACTION 动作：从数据中选择一个项目 (item)，将被选中的项目返回。
    String PICK_ACTIVITY_ACTION 动作：选择一个 activity，返回被选择的 activity 的类（名）。
    String PREFERENCE_CATEGORY 类别：activity是一个设置面板 (preference panel)。
    String PROVIDER_CHANGED_ACTION 广播：更新将要（真正）被安装。
    String PROVISIONING_CHECK_ACTION 广播：要求 polling of provisioning service 下载最新的设置。
    String RUN_ACTION 动作：运行数据（指定的应用），无论它（应用）是什么。
    String SAMPLE_CODE_CATEGORY 类别：To be used as an sample code example (not part of the normal user experience).
    String SCREEN_OFF_ACTION 广播：屏幕被关闭。
    String SCREEN_ON_ACTION 广播：屏幕已经被打开。
    String SELECTED_ALTERNATIVE_CATEGORY 类别：对于被用户选中的数据，activity 是它的一个可选操作。
    String SENDTO_ACTION 动作：向 data 指定的接收者发送一个消息。
    String SERVICE_STATE_CHANGED_ACTION 广播：电话服务的状态已经改变。
    String SETTINGS_ACTION 动作：显示系统设置。输入：无。
    String SIGNAL_STRENGTH_CHANGED_ACTION 广播：电话的信号强度已经改变。
    int SINGLE_TOP_LAUNCH 启动标记：设置以后，如果 activity 已经启动，而且位于历史堆栈的顶端，将不再启动（不重新启动） activity。
    String STATISTICS_REPORT_ACTION 广播：要求 receivers 报告自己的统计信息。
    String STATISTICS_STATE_CHANGED_ACTION 广播：统计信息服务的状态已经改变。
    String SYNC_ACTION 动作：执行数据同步。
    String TAB_CATEGORY 类别：这个 activity 应该在 TabActivity 中作为一个 tab 使用。
    String TEMPLATE_EXTRA 附加数据：新记录的初始化模板。
    String TEST_CATEGORY 类别：作为测试目的使用，不是正常的用户体验的一部分。
    String TIMEZONE_CHANGED_ACTION 广播：时区已经改变。
    String TIME_CHANGED_ACTION 广播：时间已经改变（重新设置）。
    String TIME_TICK_ACTION 广播：当前时间已经变化（正常的时间流逝）。
    String UMS_CONNECTED_ACTION 广播：设备进入 USB 大容量存储模式。
    String UMS_DISCONNECTED_ACTION 广播：设备从 USB 大容量存储模式退出。
    String UNIT_TEST_CATEGORY 类别：应该被用作单元测试（通过 test harness 运行）。
    String VIEW_ACTION 动作：向用户显示数据。
    String WALLPAPER_CATEGORY 类别：这个 activity 能过为设备设置墙纸。
    String WALLPAPER_CHANGED_ACTION 广播：系统的墙纸已经改变。
    String WALLPAPER_SETTINGS_ACTION 动作：显示选择墙纸的设置界面。输入：无。
    String WEB_SEARCH_ACTION 动作：执行 web 搜索。
    String XMPP_CONNECTED_ACTION 广播：XMPP 连接已经被建立。
    String XMPP_DISCONNECTED_ACTION 广播：XMPP 连接已经被断开。
```









