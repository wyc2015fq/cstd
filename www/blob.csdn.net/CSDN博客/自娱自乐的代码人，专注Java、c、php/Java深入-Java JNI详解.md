# Java深入 - Java JNI详解 - 自娱自乐的代码人，专注Java、c、php - CSDN博客





2014年07月03日 10:05:14[initphp](https://me.csdn.net/initphp)阅读数：1891
所属专栏：[Java深入](https://blog.csdn.net/column/details/myjava.html)








java以其跨平台的特性深受人们喜爱，而又正由于它的跨平台的目的，使得它和本地机器的各种内部联系变得很少，约束了它的功能。解决JAVA对本地操作的一种方法就是JNI。

　　JAVA通过JNI调用本地方法，而本地方法是以库文件的形式存放的（在WINDOWS平台上是DLL文件形式，在UNIX机器上是SO文件形式）。通过调用本地的库文件的内部方法，使JAVA可以实现和本地机器的紧密联系，调用系统级的各接口方法。


　　简单介绍及应用如下：

### **一、JAVA中所需要做的工作**

　在JAVA程序中，首先需要在类中声明所调用的库名称，如下：

```java
static {
　　System.loadLibrary(“goodlUCk”);
}
```



在这里，库的扩展名字可以不用写出来，究竟是DLL还是SO，由系统自己判定。

对于已生成的.h头文件，C/C++所需要做的，就是把它的各个方法具体的实现。然后编译连接成库文件即可。再把库文件拷贝到JAVA程序的路径下面，就可以用JAVA调用C/C++所实现的功能了。

　　接上例子。我们先看一下testdll.h文件的内容：


```java
public class testdll
　　{
　　static
　　{
　　System.loadLibrary("goodluck");
　　}
　　public native static int get();
　　public native static void set(int i);
　　public static void main(String[] args)
　　{
　　testdll test = new testdll();
　　test.set(10);
　　System.out.PRintln(test.get());
　　}
　　}
```


用javac testdll.java编译它，会生成testdll.class。


再用javah testdll，则会在当前目录下生成testdll.h文件，这个文件需要被C/C++程序调用来生成所需的库文件
### **二、C/C++中所需要做的工作**

对于已生成的.h头文件，C/C++所需要做的，就是把它的各个方法具体的实现。然后编译连接成库文件即可。再把库文件拷贝到JAVA程序的路径下面，就可以用JAVA调用C/C++所实现的功能了。

接上例子。我们先看一下testdll.h文件的内容：



```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
　　#include
　　/* Header for class testdll */
　　#ifndef _Included_testdll
　　#define _Included_testdll
　　#ifdef __cplusplus
　　extern "C" {
　　#endif
　　/*
　　* Class: testdll
　　* Method: get
　　* Signature: ()I
　　*/
　　JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass);
　　/*
　　* Class: testdll
　　* Method: set
　　* Signature: (I)V
　　*/
　　JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint);
　　#ifdef __cplusplus
　　}
　　#endif
　　#endif
```

在具体实现的时候，我们只关心两个函数原型

　　JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass); 和

　　JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint);


　　这里JNIEXPORT和JNICALL都是JNI的要害字，表示此函数是要被JNI调用的。而jint是以JNI为中介使JAVA的int类型与本地的int沟通的一种类型，我们可以视而不见，就当做int使用。函数的名称是JAVA_再加上[java](http://cpro.baidu.com/cpro/ui/uijs.php?rs=1&u=http%3A%2F%2Fwww.knowsky.com%2F367493.html&p=baidu&c=news&n=10&t=tpclicked3_hc&q=sayyescpr&k=java&k0=java&k1=c%2B%2B&sid=5db6cc0ab23bb411&ch=0&tu=u1366390&jk=e3d9e67e79f52b2a&cf=1&fv=13&stid=9&urlid=0&luki=1&seller_id=1&di=1)程序的package路径再加函数名组成的。参数中，我们也只需要关心在JAVA程序中存在的参数，至于JNIEnv*和jclass我们一般没有必要去碰它。


　　好，下面我们用testdll.cpp文件具体实现这两个函数：




```cpp
#include "testdll.h"
　　int i = 0;
　　JNIEXPORT jint JNICALL Java_testdll_get (JNIEnv *, jclass)
　　{
　　return i;
　　}
　　JNIEXPORT void JNICALL Java_testdll_set (JNIEnv *, jclass, jint j)
　　{
　　i = j;
　　}
```

编译连接成库文件，本例是在WINDOWS下做的，生成的是DLL文件。并且名称要与JAVA中需要调用的一致，这里就是goodluck.dll 。把goodluck.dll拷贝到testdll.class的目录下，java testdll运行它，就可以观察到结果了。


　　我的项目比较复杂，需要调用动态链接库，这样在JNI传送参数到C程序时，需要对参数进行处理转换。才可以被C程序识别。


　　大体程序如下：




```java
public class SendSMS {
　　static
　　{
　　System.out.println(System.getProperty("java.library.path"));
　　System.loadLibrary("sms");
　　}
　　public native static int SmsInit();
　　public native static int SmsSend(byte[] mobileNo, byte[] smContent);
　　}
```

在这里要注重的是，path里一定要包含类库的路径，否则在程序运行时会抛出异常：

　　java.lang.UnsatisfiedLinkError: no sms in java.library.path

　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1491)

　　at java.lang.Runtime.loadLibrary0(Runtime.java:788)

　　at java.lang.System.loadLibrary(System.[java](http://cpro.baidu.com/cpro/ui/uijs.php?rs=1&u=http%3A%2F%2Fwww.knowsky.com%2F367493.html&p=baidu&c=news&n=10&t=tpclicked3_hc&q=sayyescpr&k=java&k0=java&k1=c%2B%2B&sid=5db6cc0ab23bb411&ch=0&tu=u1366390&jk=e3d9e67e79f52b2a&cf=1&fv=13&stid=9&urlid=0&luki=1&seller_id=1&di=1):834)

　　at com.mobilesoft.sms.mobilesoftinfo.SendSMS.(SendSMS.java:14)

　　at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18)

　　Exception in thread "main"


　　指引的路径应该到.dll文件的上一级，假如指到.dll，则会报：

　　java.lang.UnsatisfiedLinkError: C:\sms.dll: Can't find dependent libraries

　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)

　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1560)

　　at [java](http://cpro.baidu.com/cpro/ui/uijs.php?rs=1&u=http%3A%2F%2Fwww.knowsky.com%2F367493.html&p=baidu&c=news&n=10&t=tpclicked3_hc&q=sayyescpr&k=java&k0=java&k1=c%2B%2B&sid=5db6cc0ab23bb411&ch=0&tu=u1366390&jk=e3d9e67e79f52b2a&cf=1&fv=13&stid=9&urlid=0&luki=1&seller_id=1&di=1).lang.ClassLoader.loadLibrary(ClassLoader.java:1485)

　　at java.lang.Runtime.loadLibrary0(Runtime.java:788)

　　at java.lang.System.loadLibrary(System.java:834)

　　at com.mobilesoft.sms.mobilesoftinfo.test.main(test.java:18)

　　Exception in thread "main"


　　通过编译，生成com_mobilesoft_sms_mobilesoftinfo_SendSMS.h头文件。（建议使用Jbuilder进行编译，操作比较简单！）这个头文件就是Java和C之间的纽带。要非凡注重的是方法中传递的参数jbyteArray，这在接下来的过程中会重点介绍。




```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
　　#include
　　/* Header for class com_mobilesoft_sms_mobilesoftinfo_SendSMS */
　　#ifndef _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS
　　#define _Included_com_mobilesoft_sms_mobilesoftinfo_SendSMS
　　#ifdef __cplusplus
　　extern "C" {
　　#endif
　　/*
　　* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS
　　* Method: SmsInit
　　* Signature: ()I
　　*/
　　JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsInit
　　(JNIEnv *, jclass);
　　/*
　　* Class: com_mobilesoft_sms_mobilesoftinfo_SendSMS
　　* Method: SmsSend
　　* Signature: ([B[B)I
　　*/
　　JNIEXPORT jint JNICALL Java_com_mobilesoft_sms_mobilesoftinfo_SendSMS_SmsSend
　　(JNIEnv *, jclass, jbyteArray, jbyteArray);
　　#ifdef __cplusplus
　　}
　　#endif
　　#endif
```

对于我要调用的C程序的动态链接库，C程序也要提供一个头文件，sms.h。这个文件将要调用的方法罗列了出来。




```cpp
/*
　　* SMS API
　　* Author: yippit
　　* Date: 2004.6.8
　　*/
　　#ifndef MCS_SMS_H
　　#define MCS_SMS_H
　　#define DLLEXPORT __declspec(dllexport)
　　/*sms storage*/
　　#define SMS_SIM 0
　　#define SMS_MT 1
　　/*sms states*/
　　#define SMS_UNREAD 0
　　#define SMS_READ 1
　　/*sms type*/
　　#define SMS_NOPARSE -1
　　#define SMS_NORMAL 0
　　#define SMS_Flash 1
　　#define SMS_MMSNOTI 2
　　typedef struct tagSmsEntry {
　　int index; /*index, start from 1*/
　　int status; /*read, unread*/
　　int type; /*-1-can't parser 0-normal, 1-flash, 2-mms*/
　　int storage; /*SMS_SIM, SMS_MT*/
　　char date[24];
　　char number[32];
　　char text[144];
　　} SmsEntry;
　　DLLEXPORT int SmsInit(void);
　　DLLEXPORT int SmsSend(char *phonenum, char *content);
　　DLLEXPORT int SmsSetSCA(char *sca);
　　DLLEXPORT int SmsGetSCA(char *sca);
　　DLLEXPORT int SmsSetInd(int ind);
　　DLLEXPORT int SmsGetInd(void);
　　DLLEXPORT int SmsGetInfo(int storage, int *max, int *used);
　　DLLEXPORT int SmsSaveFlash(int flag);
　　DLLEXPORT int SmsRead(SmsEntry *entry, int storage, int index);
　　DLLEXPORT int SmsDelete(int storage, int index);
　　DLLEXPORT int SmsModifyStatus(int storage, int index); /*unread -> read*/
　　#endif
```

　在有了这两个头文件之后，就可以进行C程序的编写了。也就是实现对JNI调用的两个方法。在网上的资料中，由于调用的方法实现的都比较简单，（大多是打印字符串等）所以避开了JNI中最麻烦的部分，也是最要害的部分，参数的传递。由于Java和C的编码是不同的，所以传递的参数是要进行再处理，否则C程序是会对参数在编译过程中提出警告，





