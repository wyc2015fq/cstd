# 转载和积累系列 - API权限设计总结 - 自娱自乐的代码人，专注Java、c、php - CSDN博客





2013年03月05日 10:08:47[initphp](https://me.csdn.net/initphp)阅读数：4932








**API权限设计总结：**

最近在做API的权限设计这一块，做一次权限设计的总结。

1. 假设我们需要访问的API接口是这样的：http://xxxx.com/openapi/v1/get/user/?key=xxxxx&sign=sadasdas&timestamp=2013-03-05 10:14:00&c=c&a=a&d=d




2. 接口调用的控制器：openapi/v1/get/user/




3. 步骤一：作为服务端，首先要检查参数是否正确：key (用户的key) ;sign(加密的签名串) ;timestamp (请求的时间，服务端对请求有时间生效)，这些参数如果有一个参数没传递，肯定返回参数不正确的结果。




4. 步骤二：参数如果都传递正确，这个时候需要检查API的白名单权限，API也就是（openapi/v1/get/user/）是否存在在我们的数据库中，一般会有一张API的数据表，如果调用的API不在我们的数据库白名单中或者这个API已经关闭访问了，那么要返回禁止访问的结果。




5. 步骤三： 如果API在白名单中，那么现在就要检查用户的KEY是否正确了，服务端会有一张用户权限表，这个数据表主要用来记录用户的key secret(密钥) 以及API权限列表，检查这个用户对访问的API（openapi/v1/get/user/）是否有权限，如果有权限则通过，没权限则关闭。




6. 步骤四： 如果用户权限通过，这个时候就到了最重要的一步，SIGN签名的验证。

签名算法：

加密方式 md5(POST参数（升序排序，除key sign参数除外） + 用户密钥) 

PHP加密算法代码：



```php
foreach ($p as $v) {
			$temp = explode("=", $v);
			$pArr[$temp[0]] = $temp[1];
		}
ksort($pArr);
		foreach ($pArr as $k => $v) {	
			$pStr2 .= $k . $v ;
		}
md5($pStr2 . $secret)
```

**注意：加密的时候，需要将timestamp带上，防止客户端篡改。**

客户端，将自己需要传递的参数进行升序排序，然后加上自己key对应的密钥（密钥在服务端数据库中有一份保存，这个是不能对外公开的）进行MD5加密，通过参数sign传递到服务端。

服务端拿到sign值后，对传递过来的参数也进行同样的算法排序，并经过用户的key查询得到密钥，然后进行一次加密算法，得到的服务端的sign和客户端传递过来的sign进行比较，如果相同则表示是可以通过的，如果中途有人篡改数据等，那么最终加密出来的sign就是不一致的，这样保证了用户传递数据的可靠性和安全性。




7. 步骤五：检查时间戳时间，比较客户端时间和服务端时间是否在10分钟之内，如果10分钟之外了，那么返回超时的提示，这样能保证调用过的接口数据能在一定时间内销毁掉。




8. 步骤六：调用相应逻辑










