# 51nod  1073 约瑟夫环（递推） - HJ - CSDN博客
2017年04月10日 22:40:58[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：302
N个人坐成一个圆环（编号为1 - N），从第1个人开始报数，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。 
例如：N = 3，K = 2。2号先出列，然后是1号，最后剩下的是3号。 
Input
2个数N和K，表示N个人，数到K出列。(2 <= N, K <= 10^6)
Output
最后剩下的人的编号
Input示例
3 2
Output示例
3
先模拟一下简单数据，帮助理解。
假设n=10，k=4
开始的时候排列顺序：（0是虚构的）
```
0 1 2 3 4 5 6 7 8 9 10
```
第一次报数之后，序号4出列（4变成0号位）
```
0（4） 5 6 7 8 9 10 1 2 3
```
第二次报数之后，序号8出列（8变成0号位）
```
0（8） 9 10 1 2 3 5 6 7
```
第三次报数之后，序号2出列（2变成0号位）
```
0（2）3 5 6 7 9 10 1
```
第四次报数之后，序号7出列（7变成0号位）
```
0（7）9 10 1 3 5 6
```
第五次报数之后，序号3出列（3变成0号位）
```
0（3） 5 6 9 10 1
```
第六次报数之后，序号10出列（10变成0号位）
```
0（10） 1 5 6 9
```
第七次报数之后，序号9出列（9变成0号位）
```
0（9） 1 5 6
```
第八次报数之后，序号1出列（1变成0号位）
```
0（1） 5 6
```
第九次报数之后，序号6出列 
所以可以得出最后剩下序号5。
实际上就是一个递推的过程，可以用一个变量来表示当前递推的序号数，注意外面用一个循环，每出列一个数，总数就要少一个。
代码如下：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,k;
    while(cin>>n>>k)
    {
        int cnt=0;
        for(int i=2;i<=n;i++)
          cnt=(cnt+k)%i;
        cout<<cnt+1<<endl;
    }
    return 0;
}
```
