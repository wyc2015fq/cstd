# 2018年湘潭大学校赛 G题  又见斐波拉契（矩阵快速幂） - HJ - CSDN博客
2018年05月08日 09:26:09[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：136
[https://www.nowcoder.com/acm/contest/105/G](https://www.nowcoder.com/acm/contest/105/G)
根据递推公式  
```
f[i+1] = f[i] + f[i-1] + i^3 + i^2 + i + 1
  f[i] = f[i]
  (i+1)^3 = i^3 + 3*i^2 + 3*i + 1 
  (i+1)^2 = i^2 + 2*i + 1
  (i+1) = i + 1
  1 = 1
```
因为构造矩阵就为
```
1,1,1,1,1,1,  
 1,0,0,0,0,0,
 0,0,1,3,3,1,
 0,0,0,1,2,1,
 0,0,0,0,1,1,
 0,0,0,0,0,1，
```
因此可以用矩阵快速幂，代码如下
```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<stack>
#include<queue>
#include<list>
#include<map>
#include<set>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
#define mod 1000000007
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
const int maxn=1e5+10;
const double eps=1e-6;
ll make[6][6]={      //构造矩阵 
1,1,1,1,1,1,  
1,0,0,0,0,0,
0,0,1,3,3,1,
0,0,0,1,2,1,
0,0,0,0,1,1,
0,0,0,0,0,1
};
struct Matrix{
    ll m[10][10];
    void init(){           //矩阵初始化 
        memset(m,0,sizeof(m)); 
    }
};
Matrix Mult(Matrix a,Matrix b)    //矩阵乘法 
{ 
    Matrix ans;
    ans.init();
    for(int i=0;i<6;i++)
      for(int j=0;j<6;j++)
        for(int k=0;k<6;k++)
          ans.m[i][j]=(ans.m[i][j]+(a.m[i][k]*b.m[k][j]+mod)%mod)%mod;
    return ans;
}
ll quick_mod(ll n)         //矩阵快速幂 
{
    Matrix ans,b,base;
    ans.init();
    for(int i=0;i<6;i++)
      ans.m[i][i]=1;
    for(int i=0;i<6;i++)
      for(int j=0;j<6;j++)
        b.m[i][j]=make[i][j];
    base.m[0][0]=1,base.m[1][0]=0,base.m[2][0]=8;
    base.m[3][0]=4,base.m[4][0]=2,base.m[5][0]=1;
    while(n)
    {
        if(n&1)
          ans=Mult(ans,b);
        b=Mult(b,b);
        n>>=1;
    }
    ans=Mult(ans,base);
    return ans.m[1][0];
}
int main()
{
    ll n,t;
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<quick_mod(n)<<endl;
    }
    return 0;
}
```
