# hdu  5969  最大的位或（二进制规律运算） - HJ - CSDN博客
2017年01月31日 03:11:14[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：300
Problem Description 
B君和G君聊天的时候想到了如下的问题。 
给定自然数l和r ,选取2个整数x,y满足l <= x <= y <= r ,使得x|y最大。 
其中|表示按位或，即C、 C++、 Java中的|运算。
Input 
包含至多10001组测试数据。 
第一行有一个正整数，表示数据的组数。 
接下来每一行表示一组数据，包含两个整数l,r。 
保证 0 <= l <= r <= 1018。
Output 
对于每组数据输出一行，表示最大的位或。
Sample Input
5 
1 10 
0 1 
1023 1024 
233 322 
1000000000000000000 1000000000000000000
Sample Output
15 
1 
2047 
511 
1000000000000000000
Source 
2016年中国大学生程序设计竞赛（合肥）-重现赛（感谢安徽大学） 
解题思路： 
先把l和r都转换为二进制，然后开始遍历，遇到不同后面全部补1即可。
需要注意long long的问题。
```cpp
#include<iostream>  
#include<cstring>  
#include<cmath>   
using namespace std;  
int s1[100],s2[100];  
int main(){  
    int t;  
    cin>>t;  
    while(t--)
    {  
        long long a,b;  
        cin>>a>>b;   
        if(a==b)  
          cout<<a<<endl;    
        else
        {  
            memset(s1,0,sizeof(s1));  
            memset(s2,0,sizeof(s2));  
            int i=0,j=0;  
            while(a!=0)     //化成二进制运算 
            {  
                int t=a%2;  
                s1[i++]=t;  
                a/=2;  
            }  
            while(b!=0)
            {  
                int t=b%2;  
                s2[j++]=t;  
                b/=2;  
            }  
            long long sum=0;  
            int maxlen=max(i,j);  
            for(int k=maxlen-1;k>=0;k--)    //进行规律查找 
            {   
                if(s1[k]==s2[k])
                {  
                    if(s1[k]==1)  
                        sum+=(long long)pow(2,k);     //注意long long 问题 
                }  
                else
                {  
                    sum+=(long long)pow(2,k+1)-1;    //同上 
                    break;  
                }  
            }  
            cout<<sum<<endl;  
        }  
    }  
    return 0;  
}
```
