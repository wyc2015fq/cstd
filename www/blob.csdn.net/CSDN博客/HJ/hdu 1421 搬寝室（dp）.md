# hdu  1421  搬寝室（dp） - HJ - CSDN博客
2016年08月11日 13:31:03[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：215
Problem Description 
搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2*k件过去就行了.但还是会很累,因为2*k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.
Input 
每组输入数据有两行,第一行有两个数n,k(2<=2*k<=n<2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).
Output 
对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.
Sample Input 
2 1 
1 3
Sample Output 
4
解析：每次拿两件物品，疲劳度是两件物品重量差值的平方，要求最小的疲劳度，即要两件物品差值最小。最好的思路即是用sort排序，如果选择第i件物品（那么另一件物品一定是i-1），因为要求的是拿完k*2件物品后疲劳度之和的最小值，为减少重复计算，考虑用dp求解。
其中
```
d[i][j]表示前i个物品中选中j对的最小疲劳度
```
状态转移方程为
```
d[i][j]=min(d[i-1][j],d[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]));
```
代码如下：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define INF 1000000000
int d[2005][1005];      //d[i][j]表示前i个物品中选中j对的最小疲劳度 
int main()
{
    int n,k;
    int a[2005]={0};
    while(cin>>n>>k)
    {
        a[0]=0;           //给a[0]赋值为0 
        for(int i=1;i<=n;i++)
          cin>>a[i];
        sort(a+1,a+n+1);      //给数组排序，方便配对 
        d[0][0]=0;
        for(int i=0;i<=n;i++)
          for(int j=1;j<=k;j++)
            d[i][j]=INF;          //定义初值，INF尽可能大 
        for(int i=2;i<=n;i++)
          for(int j=1;j*2<=i;j++)
            d[i][j]=min(d[i-1][j],d[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]));     //当前两种决策，注意，若选中第i种物品，则第i种物品一定是和第i-1个物品配对 
        cout<<d[n][k]<<endl;
    }
    return 0;
}
```
