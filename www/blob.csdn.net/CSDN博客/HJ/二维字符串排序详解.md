# 二维字符串排序详解 - HJ - CSDN博客
2017年01月23日 20:58:23[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：410
所属专栏：[算法细讲（ACM）](https://blog.csdn.net/column/details/14379.html)
如何处理二维字符串？
第一种，使用qsort
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int cmp(const void* a, const void* b)
{
    return (strcmp((char* )a,(char* )b));
}
int main()
{
    int n, m, i, count, num[20005];
    char dna[20005][30];
    while(scanf("%d%d", &n, &m) != EOF)
    {
        if(!n && !m)
            return 0;
        for(i=0; i<=n; i++)
            num[i] = 0;
        for(i=0; i<n; i++)
            scanf("%s", dna[i]);
        qsort(dna, n, sizeof(dna[0]), cmp);
        count = 1;
        for(i=1; i<=n; i++)
            if(strcmp(dna[i-1], dna[i]) == 0)
                count++;
            else
            {
                num[count]++;
                count = 1;
            }
        for(i=1; i<=n; i++)
            printf("%d\n", num[i]);
    }
    return 0;
}
```
第二种，使用结构体+sort
这里又可以根据sort功能不同分成两种
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct Array
{
  char data[30];
}dna[20005];
bool operator < (Array const& arr1, Array const& arr2)
{
  return strcmp(arr1.data, arr2.data) < 0;
}
int main()
{
    int n, m, i, count, num[20005];
    while(scanf("%d%d", &n, &m) != EOF)
    {
        if(!n && !m)
            return 0;
        for(i=0; i<=n; i++)
            num[i] = 0;
        for(i=0; i<n; i++)
            scanf("%s", dna[i].data);
        sort(dna, dna+n);
        count = 1;
        for(i=1; i<=n; i++)
            if(strcmp(dna[i-1].data, dna[i].data) == 0)
                count++;
            else
            {
                num[count]++;
                count = 1;
            }
        for(i=1; i<=n; i++)
            printf("%d\n", num[i]);
    }
    return 0;
}
```
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct Array
{
  char date[30];
}dna[20005];
bool cmp(Array  arr1, Array  arr2)
{
  return strcmp(arr1.date, arr2.date) < 0;
}
int main()
{
    int n, m, i, count, num[20005];
    while(scanf("%d%d", &n, &m) != EOF)
    {
        if(!n && !m)
            return 0;
        for(i=0; i<=n; i++)
            num[i] = 0;
        for(i=0; i<n; i++)
            scanf("%s", dna[i].date);
        sort(dna, dna+n, cmp);
        count = 1;
        for(i=1; i<=n; i++)
            if(strcmp(dna[i-1].date, dna[i].date) == 0)
                count++;
            else
            {
                num[count]++;
                count = 1;
            }
        for(i=1; i<=n; i++)
            printf("%d\n", num[i]);
    }
    return 0;
}
```
第三种，定义一个指向一维字符串的字符串指针，进行sort排序
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
char s1[105];
char *s[100005][105];
bool cmp(char *a, char *b)
{
  return (strcmp(a,b) < 0);
}
int main()
{
    int n, m, i, count, num[20005];
    while(scanf("%d%d", &n, &m) != EOF)
    {
        if(!n && !m)
            return 0;
        for(i=0; i<=n; i++)
            num[i] = 0;
        for(i=0; i<n; i++)
        {
            scanf("%s", s1[i]);
            s[i]=s;
        }
        sort(s, s+n, cmp);
        count = 1;
        for(i=1; i<=n; i++)
            if(strcmp(s[i-1], s[i]) == 0)
                count++;
            else
            {
                num[count]++;
                count = 1;
            }
        for(i=1; i<=n; i++)
            printf("%d\n", num[i]);
    }
    return 0;
}
```
以上四种可随意使用
