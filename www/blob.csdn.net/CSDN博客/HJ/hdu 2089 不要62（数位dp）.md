# hdu  2089  不要62（数位dp） - HJ - CSDN博客
2017年01月13日 17:15:11[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：260
不要62
Problem Description 
杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 
杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 
不吉利的数字为所有含有4或62的号码。例如： 
62315 73418 88914 
都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 
你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。
Input 
输入的都是整数对n、m（0小于n≤m<1000000），如果遇到都是0的整数对，则输入结束。
Output 
对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。
Sample Input
1 100 
0 0
Sample Output
80
数位dp，求一个数n从0~n满足要求的个数。
这里首先要考虑的是62和4两点，一般来说，dp[i][j]表示第i位开头数字为j的数满足条件的有多少个。
状态反应方程为
```
dp[i][j] += dp[i-1][k] k=0,1，。。。，9 (k!=2||j!=6)
```
```
for(int i=1;i<=7;i++)  
        {  
            for(int j=0;j<10;j++)//枚举第i位可能出现的数  
            {  
                for(int k=0;k<10;k++)//枚举第i-1位可能出现的数  
                {  
                    if(j!=4&&!(j==6&&k==2))  
                        dp[i][j]  += dp[i-1][k];  
                }  
            }  
        }
```
因此代码如下：
```cpp
#include<iostream>
using namespace std;
int dp[10][10],d[10];
void init()
{
    dp[0][0]=1;
    for(int i=1;i<=7;i++)
      for(int j=0;j<10;j++)
        for(int k=0;k<10;k++)      //k表示第i-1位可能出现的数 
          if(j!=4&&!(j==6&&k==2))    //不能出现数字‘4’同时也不能出现‘62’ 
            dp[i][j]+=dp[i-1][k];
}
int solve(int n)
{
    int ans=0,len=0;
    while(n)
    {
        d[++len]=n%10;
        n/=10;
    }
    d[++len]=0;               //这里需要虚拟构造出len+1位，数字为0(利于下面判断) 
    for(int i=len-1;i>=1;i--)
    {
        for(int j=0;j<d[i];j++)
          if(d[i+1]!=6||j!=2)
            ans+=dp[i][j];
        if(d[i]==4||d[i+1]==6&&d[i]==2)    //当前数字为‘4’或者当前位与上一位构成‘62’ ，则后面就不必计数了 
          break;
    }
    return ans;
}
int main()
{
    int l,r;
    init();
    while(cin>>l>>r)
    {
        if(l==0&&r==0)
          break;
        cout<<solve(r+1)-solve(l)<<endl;
    }
    return 0;
}
```
