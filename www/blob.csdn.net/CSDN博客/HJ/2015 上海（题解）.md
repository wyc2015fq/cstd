# 2015 上海（题解） - HJ - CSDN博客
2016年12月19日 13:27:22[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：315
个人分类：[====ACM====																[---------OJ---------](https://blog.csdn.net/feizaoSYUACM/article/category/6308067)](https://blog.csdn.net/feizaoSYUACM/article/category/6308070)
A（概率dp+贪心） 
建立状态dp[i]， 表示敲出i个字符的期望次数，  
那么有 dp[i] = dp[i-1] + p*(1 + dp[i]) + (1-p); 
解释一下： 敲出i个字符， 首先得敲出i-1个字符， 所以有第一部分的dp[i-1]； 然后敲下一个字符时， 有两种可能， p概率会丢失， （1-p)概率不会丢失, 对于丢失的情况就还得重新敲dp[i]次了（期望次数）， 不丢失的情况就只有一次就成功了， 所以是(1-p) * 1。 
解出 dp[i] = （dp[i-1] + 1) / ( 1- p), dp部分就搞定了; 
接下来是贪心部分； 我们能够看出来dp[i]的导数是递增的， 也就是说dp[i]随i的增大， dp[i]增大的越快。 所以如果对于i个字符分两部分来完成的话， 两个部分尽量均匀才是最优的(高中数学， 画个图像也很容易理解)；  
所以我们可以枚举保存的次数k, 保存k次就相当于把n个字符分成k部分来完成， 由上面结论可知， 这k部分尽量均匀。
```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<queue>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3fconst int maxn = 110010;
int n, x;
double p, dp[maxn];
double cal(int k) {
    int len = n/k;
    double ans = 0;
    if(n%k) {
        ans = (dp[len + 1] + x) * (n%k) + (dp[len] + x) * (k - n%k);
    }
    else {
        ans = (dp[len] + x) * k;
    }
    return ans;
}
int main() {
    int t; scanf("%d", &t);
    for(int cas=1; cas<=t; cas++) {
        printf("Case #%d: ", cas);
        scanf("%d%lf%d", &n, &p, &x);
        for(int i=1; i<=n+x; i++) dp[i] = (dp[i-1] + 1) / (1-p);
        double ans = dp[n] + x;
        for(int i=2; i<=n; i++) ans = min(ans, cal(i));
        printf("%.6f\n", ans);
    }
    return 0;
}
```
B 
只需要实现将原字符串每三字节24位重新切分为4个6位，然后从表里转换为对应的BASE64码即可，不足三字节的用0补满至下一个6位（即剩一个字节补4个0补成12位，剩下两个字节补2个0补成18位），然后用’=’补齐剩下的空位即可。
```
#include<iostream>
#include<cstring>
using namespace std;
Char  Std[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";  
char s[1005],q[1005];
void m(int x)
{
    q[strlen(q)]=Std[x];
}
int main()
{
    int t;
    cin>>t;
    for(int j=1;j<=t;j++)
    {
        int k,n;
        cin>>n>>s;
        while(n--)
        {
            memset(q,0,sizeof(q));
            int l=strlen(s);
            for(int i=0;i<l;i++)
            {
                if(i%3==0)
                  m(s[i]/4);
                if(i%3==1)
                  m((s[i-1]%4)*16+s[i]/16);
                if(i%3==2)
                {
                    m((s[i-1]%16)*4+s[i]/64);
                    m(s[i]%64);
                }
            }
            if(l%3)
            {
                int key=(s[l-1]%4)*16;
                if(l%3==2)
                  key=(s[l-1]%16)*4;
                m(key);
                strcat(q,"=");
                if(l%3==1)
                  strcat(q,"=");
            }
            q[strlen(q)]='\0';
            strcpy(s,q);
        }
        cout<<"Case #"<<j<<": ";
        cout<<s<<endl;
    }
    return 0;
}
```
C（线段树+中国剩余定理） 
题意：给出一个计算的序列，包含{+,*,^}三种运算。给出两种操作，1是给出初始值，求按照序列计算的答案; 
2是修改序列中某个位置的数和运算符。 
29393可以分解成7*13*17*19,那么就可以维护模这几个素数的答案，然后用中国剩余定理合并出答案
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std ;
typedef long long LL ;
#define clr( a , x ) memset ( a , x , sizeof a )
#define ls ( o << 1 )
#define rs ( o << 1 | 1 )
#define lson ls , l , m
#define rson rs , m + 1 , r
#define mid ( ( l + r ) >> 1 )
#define root 1 , 1 , n
const int MAXN = 50005 ;
const int MOD = 29393 ;
int mod[4] = { 7 , 13 , 17 , 19 } ;
int p[4][20][MOD] ;
int f[MAXN << 2][4][20] ;
int n , m ;
void preprocess () {
    for ( int i = 0 ; i < 4 ; ++ i ) {
        for ( int j = 0 , m = mod[i] ; j < m ; ++ j ) {
            p[i][j][0] = 1 ;
            for ( int k = 1 ; k < MOD ; ++ k ) {
                p[i][j][k] = p[i][j][k - 1] * j % m ;
            }
        }
    }
}
void upd ( int o , char op , int x ) {
    for ( int i = 0 ; i < 4 ; ++ i ) {
        for ( int j = 0 , m = mod[i] ; j < m ; ++ j ) {
            if ( op == '+' ) f[o][i][j] = ( j + x ) % m ;
            else if ( op == '*' ) f[o][i][j] = ( j * x ) % m ;
            else f[o][i][j] = p[i][j][x] ;
        }
    }
}
void push_up ( int o ) {
    for ( int i = 0 ; i < 4 ; ++ i ) {
        for ( int j = 0 , m = mod[i] ; j < m ; ++ j ) {
            f[o][i][j] = f[rs][i][f[ls][i][j]] ;
        }
    }
}
void build ( int o , int l , int r ) {
    if ( l == r ) {
        char c ;
        int x ;
        scanf ( " %c%d" , &c , &x ) ;
        upd ( o , c , x ) ;
        return ;
    }
    int m = mid ;
    build ( lson ) ;
    build ( rson ) ;
    push_up ( o ) ;
}
void update ( int x , char c , int v , int o , int l , int r ) {
    if ( l == r ) {
        upd ( o , c , v ) ;
        return ;
    }
    int m = mid ;
    if ( x <= m ) update ( x , c , v , lson ) ;
    else update ( x , c , v , rson ) ;
    push_up ( o ) ;
}
int exgcd ( int a , int b , int &x , int &y ) {
    if ( !b ) {
        x = 1 ;
        y = 0 ;
        return a ;
    }
    int ans = exgcd ( b , a % b , y , x ) ;
    y -= a / b * x ;
    return ans ;
}
int crt ( int v ) {
    int ans = 0 ;
    for ( int i = 0 ; i < 4 ; ++ i ) {
        int t = MOD / mod[i] , x , y ;
        exgcd ( t , mod[i] , x , y ) ;
        ans = ( ans + f[1][i][v % mod[i]] * t * ( x % mod[i] ) ) % MOD ;
    }
    return ( ans + MOD ) % MOD ;
}
void solve () {
    int op , x , v ;
    char c ;
    scanf ( "%d%d" , &n , &m ) ;
    build ( root ) ;
    while ( m -- ) {
        scanf ( "%d%d" , &op , &x ) ;
        if ( op == 1 ) {
            printf ( "%d\n" , crt ( x ) ) ;
        } else {
            scanf ( " %c%d" , &c , &v ) ;
            update ( x , c , v , root ) ;
        }
    }
}
int main () {
    int T ;
    preprocess () ;
    scanf ( "%d" , &T ) ;
    for ( int i = 1 ; i <= T ; ++ i ) {
        printf ( "Case #%d:\n" , i ) ;
        solve () ;
    }
    return 0 ;
}
```
D（线段树+数论） 
这个mod是一个特殊的数，任何数平方几次后对他取余就不会再变了，然后就是线段树区间更新了，可以收先处理处搜有的结果，也可以暴力更新，因为只要更新30次。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define LL unsigned long long 
using namespace std;
const LL p=9223372034707292160uLL;
const int N=100050;
int n;
LL seg[N<<2],s;
bool flag[N<<2];
void build(int rt,int l,int r){
    flag[rt]=false;
    if(l==r){
        scanf("%llu",&seg[rt]);
        return ;
    }
    int m=(l+r)>>1;
    build(rt<<1,l,m);
    build(rt<<1|1,m+1,r);
    seg[rt]=(seg[rt<<1]+seg[rt<<1|1])%p;
}
LL mul(LL a,LL b){
    LL res=0;
    while(b){
        if(b&1) res=(res+a)%p;
        b>>=1;
        a=(a+a)%p;
    }
    return res;
}
void update(int rt,int l,int r,int L,int R){
    if(flag[rt]&&l<=L&&R<=r){
        s=(s+seg[rt])%p;
        return ;
    }
    if(L==R){
        s=(s+seg[rt])%p;
        LL tmp=mul(seg[rt],seg[rt]);
        if(seg[rt]==tmp){
            flag[rt]=true;
        }
        seg[rt]=tmp;
        return ;
    }
    int m=(L+R)>>1;
    if(r<=m){
        update(rt<<1,l,r,L,m);
    }
    else if(l>=m+1) update(rt<<1|1,l,r,m+1,R);
    else{
        update(rt<<1,l,r,L,m);
        update(rt<<1|1,l,r,m+1,R);
    }
    flag[rt]=flag[rt<<1]&flag[rt<<1|1];
    seg[rt]=(seg[rt<<1]+seg[rt<<1|1])%p;
}
int main(){
    int T,icase=0,k,l,r;
    scanf("%d",&T);
    while(T--){
        s=0;
        scanf("%d%d",&n,&k);
        build(1,1,n);
        printf("Case #%d:\n",++icase);
        for(int i=1;i<=k;i++){
            scanf("%d%d",&l,&r);
            update(1,l,r,1,n);
            printf("%llu\n",s);
        }
    }
    return 0;
}
```
E（贪心） 
给出若干门课的通过需要复习的时间，考试开始时间和考试持续时间，求这个人能否参加和通过所有考试，贪心排序，看是否有重合的区间…….
```
#include<stdio.h>  
    #include<algorithm>     
    using namespace std;  
    int n;  
    struct work  
    {  
        int r,e,l;  
    }x[100005];  
    int cmp(work a,work b)  
    {  
        if(a.e==b.e)  
        {  
            return a.r<b.r;  
        }  
        return a.e<b.e;  
    }  
    int judge()  
    {  
        int time=0;  
        for(int i=0;i<n;++i)  
        {  
            if(x[i].r+time<=x[i].e)   //可以通过              
            {  
                 time=x[i].e+x[i].l;//考完试了              
             }  
            else  
            {  
                return 0;  
            }  
        }  
        return 1;  
    }  
    int main()  
    {  
        int t;  
        //freopen("shuju.txt","r",stdin);          scanf("%d",&t);  
        for(int k=1;k<=t;++k)  
        {  
            scanf("%d",&n);  
            for(int i=0;i<n;++i)  
            {  
                scanf("%d%d%d",&x[i].r,&x[i].e,&x[i].l);  
            }  
            sort(x,x+n,cmp);  
            if(judge())  
            {  
                printf("Case #%d: YES\n",k);  
            }  
            else  
            {  
                printf("Case #%d: NO\n",k);  
            }  
        }  
        return 0;  
    }
```
F（大数次方） 
对于每一种语言来说，这种语言谁会谁不会是的方案数一定，而且语言之间相互独立的，互相之间通过乘法原理来计算方案数，这样就一定是某一个数的n次方  
通过样例看出是32的n次方
```
import java.util.*;
import java.math.*;
public class Main
{
    static public void main(String[]args)
    {
        Scanner cin = new Scanner(System.in);
        int T = cin.nextInt();
        for (int i = 1; i <= T; i++)
        {
            int n = cin.nextInt();
            System.out.printf("Case #%d: ", i);
            System.out.println(BigInteger.valueOf(32).pow(n));
        }
    }
}
```
G（树链剖分） 
题意： 
给定一颗以1号节点为根节点的有向树，每个节点有一个权值，问从1号节点出发k次，能到达的所有节点的和的最大值。 
思路： 
贪心的把树的链按照权值和从大到小剖分成若干条链（过程可以根据上交书上的熟练剖分模版做细小改动），然后根据每条链的权值排序取最大的k个就是答案。
```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn =100000+5;
const int maxm=maxn+maxn;
int v[maxm],info[maxn],Prev[maxm],Q[maxn],dep[maxn];
int belong[maxn],head[maxn];
long long size[maxn];
bool vis[maxn];
int cnt=0,N,nedge=0;
int weight[maxn];
inline void insert(int x,int y){
    ++nedge;
    v[nedge]=y;Prev[nedge]=info[x];info[x]=nedge;
}
void split(){
    int l,r;
    memset(dep,-1,sizeof(dep));
    l=0;
    dep[Q[r=1]=1]=0;
    while(l<r){
        int x=Q[++l];
        vis[x]=false;
        for(int y=info[x];y!=-1;y=Prev[y]){
            if(dep[v[y]]==-1){
                dep[Q[++r]=v[y]]=dep[x]+1;
            }
        }
    }
    for(int i=N;i;i--){
        int x=Q[i],p=-1;
        size[x]=weight[x];
        for(int y=info[x];y!=-1;y=Prev[y]){
            if(vis[v[y]]){
                if(p==-1||size[v[y]]>size[p])
                    p=v[y];
            }
        }
        if(p==-1){
            ++cnt;
            belong[head[cnt]=x]=cnt;
        }
        else {
            size[x]+=size[p];
            belong[x]=belong[p];
            head[belong[x]]=x;
        }
        vis[x]=true;
    }
}
bool cmp(int a,int b){
    return size[head[a]]>size[head[b]];
}
int ans[maxn];
long long get_ans(int k){
    long long ret=0;
    for(int i=1;i<=cnt;i++) ans[i]=i;
    sort(ans+1,ans+cnt+1,cmp);
    for(int i=1;i<=min(cnt,k);i++){
        ret+=size[head[ans[i]]];
    }
    return ret;
}
int main(){
    int k,a,b,T,cas=0;
    scanf("%d",&T);
    while(T--){
        printf("Case #%d: ",++cas);
        scanf("%d%d",&N,&k);
        memset(info,-1,sizeof(info));
        cnt=0;nedge=0;
        for(int i=1;i<=N;i++){
            scanf("%d",weight+i);
        }
        for(int i=1;i<N;i++){
            scanf("%d%d",&a,&b);
            insert(a,b);
        }
        split();
        cout<<get_ans(k)<<endl;
    }
    return 0;
}
```
G（暂无）
I（找规律+FFT） 
将f(i,j)看成矩阵X，A为ai数组，B为bi数组，则有：XA=B，推出A=X−1B 
首先根据题意打一个X−1，然后就可以发现规律……然后就可以用FFT的思想去做这道题了……
```cpp
#include <stdio.h>
#include <algorithm>
using namespace std ;
typedef long long LL ;
const int MAXN = 1 << 20 ;
LL a[MAXN] ;
int n ;
void solve () {
    scanf ( "%d" , &n ) ;
    n = 1 << n ;
    for ( int i = 0 ; i < n ; ++ i ) scanf ( "%lld" , &a[i] ) ;
    if ( n == 1 ) printf ( " %lld\n" , a[0] ) ;
    else {
        LL tmp = a[n - 1] ;
        for ( int s = 2 , ds = 1 ; s <= n ; ds = s , s <<= 1 ) {
            for ( int k = 0 ; k < n ; k += s ) {
                for ( int i = k ; i < k + ds ; ++ i ) {
                    LL t = a[i + ds] ;
                    a[i + ds] -= a[i] ;
                    a[i] += t ;
                }
            }
        }
        a[0] -= n / 2 * tmp ;
        int m = n >> 1 ;
        for ( int i = 0 ; i < n ; ++ i ) 
           printf ( " %lld" , a[i] / m ) ;
        printf ( "\n" ) ;
    }
}
int main () {
    int T ;
    scanf ( "%d" , &T ) ;
    for ( int i = 1 ; i <= T ; ++ i ) {
        printf ( "Case #%d:" , i ) ;
        solve () ;
    }
    return 0 ;
}
```
J（概率期望） 
进行K次染色，每次染色会随机选取一个以(x1,y1),(x2,y2)为一组对角的子矩阵进行染色，求K次染色后染色面积的期望值(四舍五入)。 
P.S.:本题因为计算过程中会出现n^2*m^2大小的计算，因此需要注意int溢出的问题
```cpp
#include<iostream>  
    #include<cstdio>  
    #include<cmath>      
    using namespace std;  
    int main()  
    {  
        int t,tm,k;  
        double n,m;  
        scanf("%d",&t);tm=t;  
        while(t--)  
        {  
            scanf("%lf%lf%d",&n,&m,&k);  
            double ans=0;  
            for(double i=1;i<=n;i++)  
                for(double j=1;j<=m;j++)  
                {  
                    double p=m*n;  
                    p+=(i-1)*(j-1)*(n-i+1)*(m-j+1);  
                    p+=(i-1)*(m-j)*(n-i+1)*j;  
                    p+=(j-1)*(n-i)*(m-j+1)*i;  
                    p+=(n-i)*(m-j)*i*j;  
                    p+=(i-1)*m*(n-i+1);  
                    p+=(m-j)*n*j;  
                    p+=(n-i)*m*i;  
                    p+=(j-1)*n*(m-j+1);  
                    p=p/n/n/m/m;  
                    ans+=1-(pow(1-p,k));  
                }  
                printf("Case #%d: %d\n",tm-t,int(ans+0.5));  
        }  
        return 0;  
    }
```
