# CSU 1115 最短的名字（字典树） - HJ - CSDN博客
2017年01月16日 00:44:41[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：241
个人分类：[====ACM====																[---------OJ---------																[杂题																[--------字符串---------																[字典树](https://blog.csdn.net/feizaoSYUACM/article/category/7238010)](https://blog.csdn.net/feizaoSYUACM/article/category/7238090)](https://blog.csdn.net/feizaoSYUACM/article/category/6684121)](https://blog.csdn.net/feizaoSYUACM/article/category/6308067)](https://blog.csdn.net/feizaoSYUACM/article/category/6308070)
Description 
在一个奇怪的村子中，很多人的名字都很长，比如aaaaa, bbb and abababab。 
名字这么长，叫全名显然起来很不方便。所以村民之间一般只叫名字的前缀。比如叫’aaaaa’的时候可以只叫’aaa’，因为没有第二个人名字的前三个字母是’aaa’。不过你不能叫’a’，因为有两个人的名字都以’a’开头。村里的人都很聪明，他们总是用最短的称呼叫人。输入保证村里不会有一个人的名字是另外一个人名字的前缀（作为推论，任意两个人的名字都不会相同）。 
如果村里的某个人要叫所有人的名字（包括他自己），他一共会说多少个字母？ 
Input 
输入第一行为数据组数T (T<=10)。每组数据第一行为一个整数n(1<=n<=1000)，即村里的人数。以下n行每行为一个人的名字（仅有小写字母组成）。输入保证一个村里所有人名字的长度之和不超过1,000,000。 
Output
对于每组数据，输出所有人名字的字母总数。 
Sample Input
1 
3 
aaaaa 
bbb 
abababab
Sample Output
5
HINT
Source
湖南省第八届大学生计算机程序设计竞赛
解法：字典树入门题
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring> 
#include<cstdlib> 
using namespace std;
typedef struct node{
    node *next[27];    //存放当前字符后面那一个字符的存放的地址
    int count;          //记录此字符在这一层的个数 
}node;
node *T;
char s[1000005];
void build(node* T)             //建树 
{
    node *q,*p=T;
    int l=strlen(s);
    for(int i=0;i<l;i++)
    {
        int k=s[i]-'a';       //把字母换成数字序号 
        if(p->next[k]==NULL)
        {
            node *t;
            t=(node*)malloc(sizeof(node));
            t->count=1;
            for(int i=0;i<26;i++)
              t->next[i]=NULL;
            p->next[k]=t;
            p=t;
        } 
        else
        {
            p=p->next[k];
            p->count++;
        }
    } 
}
void release(node *T)           //释放结点 
{
    for(int i=0;i<26;i++)
      if(T->next[i]!=NULL)
        release(T->next[i]);
    free(T);
} 
int search(node *T)         //查询 
{
    node *q=T;
    int sum=0;
    for(int i=0;i<26;i++)
      if(T->next[i]!=NULL)
      {
          q=T->next[i];
          sum+=q->count;
          if(q->count>1)
            sum+=search(q);   //计数 
      }
    return sum;
} 
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        T=(node*)malloc(sizeof(node));
        T->count=0;
        for(int i=0;i<26;i++)
          T->next[i]=NULL;
        for(int i=1;i<=n;i++)
        {
            scanf("%s",s);
            build(T);
        }
        printf("%d\n",search(T));
        release(T);
    }
    return 0;
}
```
