# hdu 1458  汉诺塔III（递推） - HJ - CSDN博客
2017年04月28日 12:53:36[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：412
Problem Description 
约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。 
现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。 
Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？
Input 
包含多组数据，每次输入一个N值(1<=N=35)。
Output 
对于每组数据，输出移动最小的次数。
Sample Input
1 
3 
12
Sample Output
2 
26 
531440
解题思路：
因为不能直接从最左边的移动到最右边或者从最右边移动到最左边，因此需要分作以下几步：
（1）将n-1个盘子移动到C杆
（2）将第n个盘子移动到B杆
（3）将n-1个盘子移动到A杆
（4）将第n个盘子移动到C杆
（5）最后将n-1个盘子移动到C杆
因此得到递推公式：
```
F（n） = 3*F(n-1) + 2
```
```
#include<stdio.h>
int main()
{
    int n,i;
    __int64 s[40];
    s[1]=2;
    for(i=2;i<=35;i++)
    s[i]=3*s[i-1]+2;
    while(scanf("%d",&n)!=EOF)
        printf("%I64d\n",s[n]);
    return 0;
}
```
