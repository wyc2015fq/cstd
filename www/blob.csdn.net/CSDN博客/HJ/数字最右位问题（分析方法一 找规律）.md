# 数字最右位问题（分析方法一  找规律） - HJ - CSDN博客
2016年03月11日 20:24:29[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：1205
大家可能会问，什么是数字最右位问题？长话短说，直接上题目
杭电acm(1061) 
Given a positive integer N, you should output the most right digit of N^N.
Input 
The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow. 
Each test case contains a single positive integer N(1<=N<=1,000,000,000).
Output 
For each test case, you should output the rightmost digit of N^N.
Sample Input 
2 
3 
4
Sample Output 
7 
6
Hint
In the first case, 3 * 3 * 3 = 27, so the rightmost digit is 7. 
In the second case, 4 * 4 * 4 * 4 = 256, so the rightmost digit is 6.
这个题目的大概意思就是给你一个大于零小于十亿的数，要你算出这个数的数次方的最后一位数字是什么。
那么，首先看，双长整型能支持多大。很显然，输入的这个数别说一百万了，就是一百估计也挂了。所以，全部算出来肯定是行不通。有人说了，那就开一个变量，取出这个数的最右位。然后你会聪明地用一个循环，最右位乘以最右位，得到的结果再取最右位，以此往复。。。
且不说这种方法是否最简，我们深入分析试试看。
那么究竟循环多少次呢？10次？8次？还是4次？这是个问题！！！（循环10次很容易想到，不过能想到4次就需要点时间找找规律了）
究竟是什么规律呢？我们分析分析这十个数：0、1、2、3、4、5、6、7、8、9 
0*0==0； 
1*1==1； 
2*2==4、2*4==8、2*8==6、2*6==2（请注意，这里只显示最右位的数的结果） 
3*3==9、3*9==7、3*7==1、3*1==3 
4*4==6、4*6==4 
5*5==5 
6**6==6 
7*7==9、7*9==3、7*3==1、7*1==7 
8*8==4、8*4==2、8*2==6、8*6==8 
9*9==1、9*1==9 
通过以上数据你会惊奇地发现，最多只需要循环四次，就会恢复原数。那么可不可以再减少循环次数呢？答案是可以的！并且被要求必须这么做！！！
我们接着分析，这次我们减轻点负担，只分析循环四次恢复原数的那几个数：2、3、7、8
我们先来用2举个例子，用2作尾数的有：2、12、22等等，于是我们就发现求得的结果是循环的偶数次，也就是能被2整除，于是就不可能出现结果8和2。同理，用3作尾数的有：3、13、23等等，于是就不可能出现结果9和1。所以用7作尾数的也不可能出现9和1，用8作尾数的不可能出现2和8。
那么问题来了，我们应该如何判断这些数字尾数出现的到底是这个结果还是那个结果呢？譬如，尾数如果是3，那该怎么判断结果是3还是7呢？
别急，我们再分析分析。
我们举两个例子，一个偶数2。大家请仔细观察，当输入2的时候输出的结果是2*2==4，当输入的是12的时候 
2*2*2*2*2*2*2*2*2*2*2*2（不用数也知道12个）==2^12==2.。
同时，还可以跟大家说的是，当输入的是22的时候，输出的结果肯定是4。大家发现了吧，我们给输入的数字取最右边的两位数，对这两个数进行模4运算，如果被4整除输出的结果就是2，否则结果为4。
而对于奇数3来说，我们再来看看，当输入3的时候输出的结果是3*3*3==3*3^2==7，当输入的是13的时候 
3*3*3*3*3*3*3*3*3*3*3*3*3==3*3^12==3。2不能被4整除，而12能被4整除。大家终于发现所有判断规律了吧！！！好开心，那么就开始写代码吧！
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,k;
    cin>>k;
    while(k--)
    {
      cin>>n;
      int p=n%100,q=n%10;   //注意，p和q待会都有用
      if(q==5||q==6||q==0||q==1)    //简单的发现，不要急！
        cout<<q;
      if(q==4)              //很显然循环偶数次
        cout<<6;
      if(q==9)             //同上
        cout<<9;
      if(q==8||q==2)           
      {
        if(p%4==0) cout<<6;     //这个时候就需要用到p了
        else cout<<4;
      }
      if(q==3)
      {
        if((p-1)%4==0) cout<<3;
        else cout<<7;
      }
      if(q==7)
      {
        if((p-1)%4==0) cout<<7;  //读者可以多列举几个数试试
        else cout<<3;
      }
      cout<<endl;
    }
    return 0;
}
```
