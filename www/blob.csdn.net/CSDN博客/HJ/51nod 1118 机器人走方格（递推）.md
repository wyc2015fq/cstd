# 51nod  1118 机器人走方格（递推） - HJ - CSDN博客
2017年04月11日 00:04:18[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：283
M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。 
Input
第1行，2个数M,N，中间用空格隔开。（2 <= m,n <= 1000)
Output
输出走法的数量。
Input示例
2 3
Output示例
3
简单递推，每次到达的地点（i,j）源自于(i-1,j)或者(i,j-1)，由于数据量不大，可以先预处理一下。
```cpp
#include<iostream>
using namespace std;
#define mod 1000000007
long long d[1005][1005],n,m;
int main()
{
    for(int i=2;i<=1000;i++)
      d[i][1]=d[1][i]=1;
    for(int i=2;i<=1000;i++)
      for(int j=2;j<=1000;j++)
        d[i][j]=(d[i-1][j]%mod+d[i][j-1]%mod)%mod;
    while(cin>>n>>m)
      cout<<d[n][m]<<endl;
    return 0;
}
```
