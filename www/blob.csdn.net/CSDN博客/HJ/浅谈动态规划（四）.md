# 浅谈动态规划（四） - HJ - CSDN博客
2017年03月17日 18:43:17[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：403
所属专栏：[算法细讲（ACM）](https://blog.csdn.net/column/details/14379.html)
这一次，我们来谈谈区间dp和概率dp。
**区间dp**
首先，状态表示很容易想到，就是[i,j]之间的达到题目条件的要求个数值。但是初学起来，区间dp需要理解一个问题：
**区间长度是从1慢慢循环到n-1的，一定是等到所有区间长度为1的值都赋好之后，才会开始区间长度为2的赋值。而赋值过程，实际上就是递推过程。每次的赋值，进行一次状态的决策。这就是区间dp**
不妨先来看看几个题目。
题目描述：
```
现在有n堆石子，第i堆有ai个石子。现在要把这些石子合并成一堆，每次只能合并相邻两个，每次合并的代价是两堆石子的总石子数。求合并所有石子的最小代价。
```
Sample Input 
2 
4 
1 2 3 4 
5 
3 5 2 1 4
Sample Output 
19 
33
设d[i][j]为：
**合并第i-j堆石子所需要的最小花费**
可以得到状态转移方程：
```
dp[i][j]=max(dp[i][k]+dp[k+1][j]+sum[i][j])    (i<=k<=j)
```
然后进行初始化操作，用一个变量len来表示区间长度，放在最外面循环。
```
for (int i=1; i<=n; i++){
            dp[i][i]=0;//初始化为0
            sum[i][i]=a[i];//将每堆石子的个数赋值进来
        }
        for (int len=1; len<n; len++)            //按长度从小到大枚举
            for (int i=1; i<=n&&i+len<=n; i++){         //i表示开始位置
                int j=len+i;                    //j表示长度为len的一段区间的结束位置
                for (int k=i; k<j; k++){          //用k来表示分割区间 
                    sum[i][j]=sum[i][k]+sum[k+1][j];
                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[i][j]);
                }
            }
```
上面一种是比较好理解的，但是颇为复杂，另外还有一种写法：
设d[i][j]为：
**以 i 为起点合并长度为 j 的石子所需的最小花费**
```
for(int i=1;i<=n;i++)  
     sum[i]=sum[i-1]+a[i];  
 for(int i=1;i<=n;i++) 
     for(int j=1;j<=n;j++) 
        dp[i][j]=INF;//初始化  
 for(int i=1;i<=n;i++) 
     dp[i][0]=0;//初始化
 for(int j=1;j<n;j++) 
     for(int i=1;i+j<=n;i++)    //先枚举长度j  
         for(int k=0;k<j;k++)  
             dp[i][j]=min(dp[i][j],dp[i][k]+dp[i+k+1][j-k-1]+sum[i+j]-sum[i-1]);
```
题目描述：
```
求出满足括号匹配的最长个数。
```
Sample Input 
((())) 
()()() 
([]]) 
)[)( 
([][][) 
end
Sample Output 
6 
6 
4 
0 
6
设d[i][j]为：
**在[i,j]内满足括号匹配的最长个数**
则分成两种情况来考虑：
(1)当s[i]与s[j]匹配：
**d[i][j]=d[i-1][j-1]+2;**
(2)当s[i]与s[j]不匹配：
**d[i][j]=max(d[i][k]+d[k+1][j];     (k在i+1与j之间）**
```cpp
memset(d,0,sizeof(d));
        int len=strlen(s);
        for(int k=1;k<len;k++)
            for(int i=0,j=k;j<len;i++,j++){
                if(s[i]=='('&&s[j]==')'||s[i]=='['&&s[j]==']')
                   d[i][j]=d[i+1][j-1]+2;
                for(int x=i;x<j;x++)
                  d[i][j]=max(d[i][j],d[i][x]+d[x+1][j]);
            }
```
题目描述： 
       给出n个数，除了第一个和第n个不能取出之外，你可以自由选择先后全部取出中间的n-1个数，但是每去一个数，需要a[i-1]*a[i]*a[i+1]的代价，如果旁边的数字已经被先取出，则再往旁边挪一位，求取出n-2个数之后，所需要花的最少的代价。
Sample Input 
6 
10 1 50 50 20 5
Sample Output 
3650
设d[i][j]为
**取出[i,j]之间的数需要的最少代价**
则状态转移方程可以表示为
```
d[i][j]=min(d[i][k],d[k+1][j]+a[i]*a[k]*a[j]）   其中k表示最后一次取出的数
```
```
memset(d,0,sizeof(d));
        for(int len=2;len<n;len++)      //区间（i,j）之间的长度 
            for(int i=2;i+len-1<=n;i++)            {
                  int j=i+len-1;
                  d[i][j]=INF;         //赋初值要足够大 
                  for(int k=i;k<j;k++)              //类似于矩阵链乘 k表示从(i,j)中最后抽取k 
                      d[i][j]=min(d[i][j],d[i][k]+d[k+1][j]+a[i-1]*a[k]*a[j]);
            }
```
**概率dp**
概率的运算 
Ø 两个互斥事件，发生任一个的概率等于两个事件的概率和 
Ø 对于不相关的事件或者分步进行的事件，可以使用乘法原则。 
Ø 对于一般情况p(A+B)=p(A)+p(B)-p(AB) 
期望的运算 
Ø E(φ)= ΣφiPi，这是期望的定义，其中φi是一个取值，而Pi是取这个值的概率 
Ø 期望有“线性”，也就是说对于不相关的两个随机变量φ和ξ，E(φ±ξ)=E(φ)±E(ξ)；E(φξ)=E(φ)E(ξ)；E(φ/ξ)=E(φ)/E(ξ) 
Ø 在某些情况下，期望可以表示成一个无穷的等比数列，然后利用极限的思想来求。
当然，这些只是最基础的知识，要解决好概率和期望的问题，还需要掌握一些组合数学的知识。
除了需要懂得一些基础的概率知识外，还需要理解概率在dp中的灵活使用。明白状态转移是如何进行的。
题目描述： 
       在一个图中，现在需要从点（1，1）到（R，C），每次有三种选择，待在原地，往左走一步，往下走一步，现在分别给出每一个位置三种选择的概率，并且要求，每次移动都需要消耗2点能量，求最后到达终点的平均期望值。
Sample Input 
2 2 
0.00  0.50  0.50    0.50  0.00  0.50 
0.50  0.50  0.00    1.00  0.00  0.00
Sample Output 
6.000
设d[i][j]为 
**从（i，j）到（R，C）所需要的平均期望（能量）**
则当前有三种决策
用状态转移方程可以表示为  
**d[i][j] = d[i][j] * p[i][j][0] + d[i][j+1] * p[i][j][1] + d[i+1][j] * p[i][j][2] + 2**
将d[i][j]项合并，系数归一，化简得到 
**dp[i][j] = ( p[i][j][1] * dp[i][j+1] + p[i][j][2] * dp[i+1][j] + 2) / ( 1 - p[i][j][0] )**
因此逆推写法为
```cpp
memset(dp,0,sizeof(dp));
for(int i=n;i>0;i--)
      for(int j=m;j>0;j--) {
            if(i==n&&j==m)   //如果不需要移动，期望也为0 
    continue;
            if(p[i][j][0]==1.0)     //留在原地的概率为1，无路可走，因此期望为0 
    continue;
           dp[i][j]+=(p[i][j][1]*dp[i][j+1]+p[i][j][2]*dp[i+1][j]+2)/(1-p[i][j][0]);
       }
```
题目大意： 
有2^n支球队，每次剩下的相邻的两支队伍比一次，一共会进行n场比赛。求最后胜出概率最大的球队。
Sample Input 
2 
0.0 0.1 0.2 0.3 
0.9 0.0 0.4 0.5 
0.8 0.6 0.0 0.6 
0.7 0.5 0.4 0.0 
-1
Sample Output 
2
设d[i][j]为
**第 i 场 第 j 支球队胜出**
那么前提条件必须是
**（1）第 j 支球队和对手第 k 支球队都获胜了前 i-1 场**
**（2）在这一场 j 胜出了**
如何寻找 j 的对手 k ?
还记得异或运算吗？（a^b）
（1）当j为奇数的时候，令j=(2n+1)   那么j的对手必定是（2n）  
        而 (2n+1)^1==2n 
（2）当j为偶数的时候，令j=2n       此时j的对手必定为(2n+1)  
        而(2n)^1=2n+1
```
for(int i=1;i<=n;i++)                           //2的n次方支队伍两两淘汰需要打n场 
      for(int j=0;j<m;j++)
          for(int k=0;k<m;k++)
              if(((j>>(i-1))^1)==(k>>(i-1)))                 //(2n)^1=2n+1   (2n+1)^1=2n 
                dp[i][j]+=dp[i-1][j]*dp[i-1][k]*p[j][k];
```
因为博主这两个方面的题目做的比较少，所以在最后推荐就不写了，汗！还是自己太菜，过一段时间，等博主有能力了，再来补上吧！
