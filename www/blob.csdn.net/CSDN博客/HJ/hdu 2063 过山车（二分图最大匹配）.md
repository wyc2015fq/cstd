# hdu  2063  过山车（二分图最大匹配） - HJ - CSDN博客
2017年01月16日 00:54:07[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：283
Problem Description 
RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？
Input 
输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0 < K<=1000，1<=N 和M<=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。
Output 
对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。
Sample Input
6 3 3 
1 1 
1 2 
1 3 
2 1 
2 3 
3 1 
0
Sample Output
3
Author 
PrincessSnow
Source 
RPG专场练习赛
分析：很明显的二分图，求最大匹配。
解法：匈牙利算法。
```cpp
#include<iostream>
using namespace std;
const int maxn=502;
int un,vn,g[maxn][maxn],linked[maxn],vis[maxn];
bool dfs(int u)
{
    for(int v=1;v<=vn;v++)
    {
        if(g[u][v]&&!vis[v])
        {
            vis[v]=1;
            if(!linked[v]||dfs(linked[v]))
            {
                linked=u;
                return true;
            }
        }
    }
    return false;
}
int hungary()
{
    int ans=0;
    memset(linked,0,sizeof(linked));
    for(int u=1;u<=un;u++)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(u))
          ans++;
    }
    return ans;
}
int main()
{
    int k,m,n;
    while(cin>>k)
    {
        if(k==0)
          break;
        cin>>n>>m;
        un=m;
        vn=n;
        memset(g,0,sizeof(g));
        int u,v;
        for(int i=1;i<=k;i++)
        {
            cin>>u>>v;
            g[u][v]=1;
        }
        cout<<hungary()<<endl;
    }
    return 0;
}
```
