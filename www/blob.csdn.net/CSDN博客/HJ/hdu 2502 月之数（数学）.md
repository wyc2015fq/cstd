# hdu  2502 月之数（数学） - HJ - CSDN博客
2017年02月25日 20:33:42[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：388
Problem Description 
当寒月还在读大一的时候，他在一本武林秘籍中（据后来考证，估计是计算机基础，狂汗-ing），发现了神奇的二进制数。 
如果一个正整数m表示成二进制，它的位数为n（不包含前导0），寒月称它为一个n二进制数。所有的n二进制数中，1的总个数被称为n对应的月之数。 
例如，3二进制数总共有4个，分别是4（100）、5（101）、6（110）、7（111），他们中1的个数一共是1＋2＋2＋3=8，所以3对应的月之数就是8。
Input 
给你一个整数T，表示输入数据的组数，接下来有T行，每行包含一个正整数 n（1<=n<=20）。
Output 
对于每个n ，在一行内输出n对应的月之数。
Sample Input
3 
1 
2 
3
Sample Output
1 
3 
8
这个题可以用四种方法来解决，首先从最简单的下手（思路）
解法一：**考虑组合**，求一个n二进制数除去第一个固定‘1’，还剩下n-1位，假设是一个3二进制数，那么就是从100到111，也就是把后面的两位作全排列。如此可以得出如下公式：
```
d[i]=C（0，i-1）*1+C(1,i-1)*2+C(2,i-1)*3+...+C(i-1,i-1)*i;
```
如此易得AC代码：
```cpp
#include<iostream>
#include<cstring> 
using namespace std;
long long C(int x,int y)     //计算C（x,y）
{
    long long ans=1;
    for(int i=1,j=y;i<=x;i++,j--)
      ans=ans*j/i;
    return ans; 
}
int main()
{
    long long d[25];
    memset(d,0,sizeof(d));
    d[1]=1;
    for(int i=2;i<=20;i++)
      for(int j=0;j<i;j++)
        d[i]+=(j+1)*C(j,i-1);
    long long t,n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<d[n]<<endl;
    }
    return 0;
}
```
解法二：**找规律**，数据如下：
（1）1二进制：1 
（2）2二进制：10 11 
（3）3二进制：100 101 110 111 
（4）4二进制：1000 1001 1010 1011 1100 1101 1110  1111
我们发现：n二进制数是在前面n-1所有的二进制数基础上，左边补”0”，补到1位（即”0”），最左边再加上”1”，就是n二进制数。
例如： 
在2二进制中：
```
11==>'1'+'1'；
```
在3二进制中：
```
101==>'1'+'0'+'1';
110==>'1'+'10';
111==>'1'+'11';
```
在4二进制中：
```
1001==>'1'+'0'+'0'+'1';
1010==>'1'+'0'+'10';
1011==>'1'+'0'+'11';
1100==>'1'+'100';
1101==>'1'+'101';
1110==>'1'+'110';
1111==>'1'+'111';
```
……. 
于是就有公式：
```
d(i)=d(1)+d(2)+...+d(i-1)+p(i)；（p(i)表示i二进制所数的个数加1）
```
因此得到代码如下：
```cpp
#include<iostream>
using namespace std;
long long a[30],d[30],sum,i,j,t,x;
int main()
{
    a[1]=1,d[1]=1,sum=1;
    for(i=2;i<=20;i++)
    {
        a[i]=a[i-1]*2;
        d[i]=a[i]+sum;
        sum+=d[i];
    }
    cin>>t;
    while(t--)
    {
        cin>>x;
        cout<<d[x]<<endl;
    }
    return 0;
}
```
解法三：**推理**，同解法一，我们知道n二进制数除去第一个固定的数位‘1’，剩下n-1位全排列，并且只有‘0’和‘1’组成，而且两者个数各占一半。详细例子可看解法二演示。 
那么接下来我们就只要算出这n-1位全排列需要多少次即可（2的n-1次方）因为每个位只有‘0’和‘1’两个选择。 
因此总共有‘0’和‘1’个数（n-1）*pow（2，n-1） 
然后再除以二，就得到‘1’的个数，再加上每个排列第一个固定为的‘1’，总数也为2的n-1次方，所以得到通解：
```
d[n]=pow(2,n-1)+(n-1)*pow(2,n-1)/2;
```
因此得到代码：
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long t,n,a=1,b=1,ans;
    cin>>t;
    while(t--)
    {
        cin>>n;
        ans=(a<<n-1)+(n-1)*(b<<(n-2));  //用位运算代替pow实现次方功能，有优化代码之效
        cout<<ans<<endl;
    }
    return 0;
}
```
解法四：**找规律**，这个说实在话我也不是太懂，不过还是先写下来，以后再看到的话再仔细琢磨琢磨吧。（同解法二有点类似）
原文如下： 
约定一个二进制数数字从右到左序号依次增大。我们发现一个由n个数字组成的数可以分成两个由n-1个数字组成数（先假设第一位可以为0）组成。所有（假设有m个）满足条件的由n-1个数字组成的数共含有f（n-1）个”1”，那么f[n]=f[n-1]+m+f[n-1]+m-m=2*f[n-1]+m;其中第n位数出现过2*m次。
```
d[i]=2*d[i-1]+p[i];    （p(i)表示i二进制所数的个数加1）
```
代码：
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long a[25],d[25],t,n;
    a[1]=1,d[1]=1;
    for(int i=2;i<=20;i++)
    {
        d[i]=2*d[i-1]+a[i-1]; 
        a[i]=a[i-1]*2; 
    }
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<d[n]<<endl;
    }
    return 0;
}
```
