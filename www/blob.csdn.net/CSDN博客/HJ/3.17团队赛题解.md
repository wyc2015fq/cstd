# 3.17团队赛题解 - HJ - CSDN博客
2018年03月18日 12:02:04[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：106
A题  小C的倍数问题
[http://acm.hdu.edu.cn/showproblem.php?pid=6108](http://acm.hdu.edu.cn/showproblem.php?pid=6108)
思路：
在 p 进制下，每个正整数都可以都可以表示为：在 p 进制下，每个正整数都可以都可以表示为：
p = a0 + a1*p + a2*p^2 + … + an*p^n
而由（a0 + a1*p + a2*p^2 + … + an*p^n） % B = 0
得到（a0 % B + a1 % B * p %B  + … + an % B * p^n % B） % B = 0   ①
又得到各位数之和（a0 + a1 + a2+ … + an） % B =0
得到 （a0 % B +  … + an % B） % B = 0      ②
①和②等价当且仅当p%B=1，而p%(p-1)=1所以问题相当于是求 p - 1 的因子个数。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    long long n;
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        n--;
        int ans=2;
        for(int i=2;i<=sqrt(n+0.5);i++)
        {
            if(n%i==0)
            {
                ans+=2;
                if(i*i==n)
                  ans--;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
B题  Easy Number Game   
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4004](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4004)
思路：简单排个序，取数组前2*m个数，两边各取一个凑成一组，取m组；
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int s[100005];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,m;
        long long ans=0;
        cin>>n>>m;
        for(int i=0;i<n;i++)
          cin>>s[i];
        sort(s,s+n);
        for(int i=0;i<m;i++)
          ans+=s[i]*s[2*m-i-1];
        cout<<ans<<endl;
    }
    return 0;
}
```
C题 One-Dimensional Maze
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3992](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3992)
思路：从m点开始，左右遍历到边界，取最小值即可；
```cpp
#include<iostream>
using namespace std;
char s[100005];
int main()
{
    int t,n,m;
    cin>>t;
    while(t--)
    {
        cin>>n>>m>>s;
        m--;
        int a=0,b=0,i=m,j=m;
        while(i>0)
          if(s[i--]=='R')
            a++;
        while(j<n-1)
          if(s[j++]=='L')
            b++;
        int ans=min(a,b);
        cout<<ans<<endl;
    }
    return 0;
}
```
D题 今夕何夕
[http://acm.hdu.edu.cn/showproblem.php?pid=6112](http://acm.hdu.edu.cn/showproblem.php?pid=6112)
思路：按照三种情况分类讨论： 
（1）闰年2月29日 
（2）2月以后 
（3）3月以前
```
#include<iostream>
#include<cstdio>
using namespace std;
bool Leap(int year)
{
    if(year%4==0&&year%100!=0||year%400==0)
      return true;
    return false;
} 
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int year,month,day,ans=0;
        scanf("%d-%d-%d",&year,&month,&day);
        if(month==2&&day==29)
        {
            while(true)
            {
                while(true)
                {
                    ans+=365;
                    year++;
                    if(Leap(year))
                      break;
                }
                ans++;
                if(ans%7==0)
                  break;
            }
        }
        else if(month>2)
        {
            while(true)
            {
                year++;
                ans+=365;
                if(Leap(year))
                  ans++;
                if(ans%7==0)
                  break;
            }
        }
        else if(month<=2)
        {
            while(true)
            {
                ans+=365;
                if(Leap(year))
                  ans++;
                year++;
                if(ans%7==0)
                  break;
            }
        }
        cout<<year<<endl;
    }
    return 0;
}
```
E题 Happy Sequence
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4011](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4011)
思路：我们可以把题目逆向思考，假设要求前一个数必须为后一个数的倍数，那么可以设d[i][j]表示长度为i，最后一个数为j的区间个数，状态转移方程为
```
d[i][j] = d[i-1][k] (其中k为j的倍数)
```
```cpp
#include<iostream>
#include<cstdio> 
#include<cstring>
using namespace std;
const int mod=1e9+7;
typedef long long LL;
LL d[2005][2005];
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        LL n,m,ans=0;
        scanf("%lld%lld",&n,&m);
        memset(d,0,sizeof(d));
        for(int i=1;i<=n;i++)
          d[0][i]=1;
        for(int i=1;i<m;i++)
          for(int j=1;j<=n;j++)
            for(int k=j;k<=n;k+=j)
              d[i][j]=(d[i][j]+d[i-1][k])%mod;
        for(int i=1;i<=n;i++)
          ans=(ans+d[m-1][i])%mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```
F题 Safest Buildings
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3993](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3993)
待补…
G题 Lucky Man
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4005](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4005)
待补…
H题 Super Brain
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4013](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4013)
思路：因为数的大小不超过10^6，因此可以把输入数据存到数组下标，数组值标为1进行查找，最后输出之后按照第一次输入清零；
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int s[1000005],a[100005];
int main()
{
    int t,n,x,ans;
    scanf("%d",&t);
    memset(s,0,sizeof(s));
    while(t--)
    {
        scanf("%d",&n);
        for(int i=0;i<n;i++)
        {
            scanf("%d",&a[i]);
            s[a[i]]=1;
        } 
        for(int i=0;i<n;i++)
        {
            cin>>x;
            if(s[x])
              ans=x;
        }
        printf("%d\n",ans);
        for(int i=0;i<n;i++)
          s[a[i]]=0;
    }
    return 0;
}
```
