# hdu  5698  瞬间移动（杨辉三角+逆元+快速幂） - HJ - CSDN博客
2016年08月20日 09:31:51[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：454
个人分类：[====ACM====																[----------数学----------																[排列组合																[---------OJ---------																[HDU](https://blog.csdn.net/feizaoSYUACM/article/category/6308041)](https://blog.csdn.net/feizaoSYUACM/article/category/6308067)](https://blog.csdn.net/feizaoSYUACM/article/category/6308090)](https://blog.csdn.net/feizaoSYUACM/article/category/6130298)](https://blog.csdn.net/feizaoSYUACM/article/category/6308070)
Problem Description 
有一个无限大的矩形，初始时你在左上角（即第一行第一列），每次你都可以选择一个右下方格子，并瞬移过去（如从下图中的红色格子能直接瞬移到蓝色格子），求到第n行第m列的格子有几种方案，答案对1000000007取模。 
![这里写图片描述](http://acm.split.hdu.edu.cn/data/images/C702-1003-1.jpg)
Input 
多组测试数据。 
两个整数n,m(2≤n,m≤100000)
Output 
一个整数表示答案
Sample Input 
4 5
Sample Output 
10
解析：首先要找规律，发现如下：
```
0 /  /  /  /  /  /  /
/ 1  1  1  1  1  1  1
/ 1  2  3  4  5  6  
/ 1  3  6  10 15 
/ 1  4  10 20 
/ 1  5  15 
/ 1  6
/ 1
```
实际上是一个斜着放的杨辉三角，因此，当n,m都大于等于2的时候，每个坐标的计算公式可以表示为：
```
N(n,m)=C(m+n-4,n-2)%mod
```
因为计算的是组合数，因此可以先打好表，但是由于数据太大，需要快速幂+求逆元，代码如下：
```
#include<iostream>
using namespace std;
long long mod=1000000007;
long long d[200002];
long long quickmod(long long x,long long y)    //快速幂
{
    long long ans=1;
    while(y)
    {
        if(y&1)
          ans=ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}
int main()
{
    d[0]=1;
    for(int i=1;i<=200000;i++)
      d[i]=d[i-1]*i%mod;         //组合计数打表取模
    long long n,m;
    while(cin>>n>>m) 
    {
        long long sum=d[n+m-4]*quickmod(d[m-2],mod-2)%mod*quickmod(d[n-2],mod-2)%mod;  //快速幂+取逆元
        cout<<sum<<endl;
    }
    return 0;
}
```
