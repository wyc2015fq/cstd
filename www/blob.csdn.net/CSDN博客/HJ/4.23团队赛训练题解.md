# 4.23团队赛训练题解 - HJ - CSDN博客
2018年04月24日 23:27:42[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：90
ZOJ 4014 Pretty Matrix 
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4014](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4014)
水题，判断一个矩阵中有多少个数不满足A<=x<=B。
```cpp
#include<iostream>
using namespace std;
int main() 
{
    int n,m,a,b,t;
    cin>>t;
    while(t--)
    {
        cin>>n>>m>>a>>b;
        int ans=0,x,blag=a>b?1:0;
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
          {
              cin>>x;
              if(x>=a&&x<=b)
                continue;
              ans++;
          }
        if(!blag)
          cout<<ans<<endl;
        else
          cout<<"No Solution"<<endl;
    }
    return 0;
}
```
CSU 2079 觉醒！MACROSS！  
[http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2079](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2079)
水题，遍历找出三维空间点距离最大的点的值
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        double x,y,z,sum=0;
        while(n--)
        {
            scanf("%lf%lf%lf",&x,&y,&z);
            x=abs(x),y=abs(y),z=abs(z);
            double ans=x*x+y*y+z*z;
            sum=max(ans,sum);
        }
        sum=sqrt(sum*1.0);
        printf("%.2lf\n",sum);
    }
    return 0;
}
```
ZOJ 4016 Mergeable Stack 
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4016](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4016)
模拟栈的三个操作：
```
（1）输出第i个栈顶元素；
（2）将元素x压入第i个栈中；
（3）将第j个栈元素一个一个压入第i个栈中；
```
注意：用栈、队列模拟都会爆内存和超时，需要使用到list
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<list>
#include<cstdio>
#include<cstdlib>
using namespace std;
list<int> li[300005];
int main()
{
    int t,n,q;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++)
          li[i].clear();
        while(q--)
        {
            int op,s,x;
            scanf("%d%d",&op,&s); 
            if(op==2)
            {
                if(li[s].empty())
                  printf("EMPTY\n");
                else
                {
                    printf("%d\n",li[s].back());
                    li[s].pop_back();
                }
            } 
            else if(op==1)
            {
                scanf("%d",&x);
                li[s].push_back(x);
            }
            else
            {
                scanf("%d",&x);
                li[s].splice(li[s].end(),li[x]);
            }
        }
    }
    return 0;
}
```
CSU 2080 航行日志的修复  
[http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2080](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2080)
水题，简单模拟一下即可。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
char s[1005];
int main()
{
    while(gets(s))
    {
        for(int i=0;s[i]!='\0';i++)
        {
            if(s[i]>='a'&&s[i]<='z')
              s[i]=(s[i]-'a'+15)%26+'a';
            else if(s[i]>='A'&&s[i]<='Z')
              s[i]=(s[i]-'A'+15)%26+'A';
            else
            {
                if(s[i]=='`')
                  s[i]=' ';
                else if(s[i]=='(')
                  s[i]=',';
                else
                  s[i]='.';
            }
        }
        cout<<s<<endl;
    }
    return 0;
}
```
CSU 2084 Lunch War with the Donkey  
[http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2084](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2084)
题目大意：从n份牛奶和m份面包中取出min（n,m）份搭配，每份牛奶和面包都一个营养值，如果一份牛奶和一份面包搭配起来营养就是他们的乘积，问营养最大值和最小值是多少？
解题思路：首先对两个数组排序，最大值直接从后面取即可。最小值需要比较牛奶逆序面包顺序和牛奶顺序面包逆序哪个更小。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long a[100005],b[100005];
int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        for(int i=0;i<n;i++)
          cin>>a[i];
        for(int j=0;j<m;j++)
          cin>>b[j];
        sort(a,a+n);
        sort(b,b+m);
        long long Max=0,Min=0,res1=0,res2=0;
        int k=min(n,m);
        for(int i=0,j=k-1;i<n&&i<m;i++,j--)
        {
            res1+=a[i]*b[j];
            res2+=a[j]*b[i];
        }
        Min=min(res1,res2);
        for(int i=n-1,j=m-1;j>=0&&i>=0;j--,i--)
          Max+=a[i]*b[j];
        cout<<Max<<" "<<Min<<endl;
    } 
    return 0;
}
```
ZOJ 4020 Traffic Light 
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4020](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4020)
题解链接 
[https://blog.csdn.net/feizaosyuacm/article/details/80070225](https://blog.csdn.net/feizaosyuacm/article/details/80070225)
```cpp
#include<iostream>
#include<cstdio> 
#include<queue>
#include<vector>
#include<cstring> 
using namespace std;
typedef long long ll;
const int maxn=3e5+10;
#define INF 0x3f3f3f3f
struct node{
    int x,y;
    node(int x,int y):x(x),y(y) {};
};
queue<node> q;
vector<int> g[maxn];
int vis[maxn],ans[maxn];
int n,m,sx,sy,ex,ey;
int px[]={1,-1,0,0},py[]={0,0,1,-1};
bool check(int dx,int dy,int x,int y)
{
    if(!vis[dx*m+dy]&&dx>=0&&dy>=0&&dx<n&&dy<m)
    {
        ans[dx*m+dy]=ans[x*m+y]+1;
        vis[dx*m+dy]=1;
        q.push(node(dx,dy));
    }
}
void change(int i,int j,int x,int y)
{
    for(int k=i;k<j;k++)  
    {
        int dx=x+px[k];
        int dy=y+py[k];
        check(dx,dy,x,y);
    }
}
void bfs()
{
    memset(vis,0,sizeof(vis));
    memset(ans,-1,sizeof(ans)); 
    q.push(node(sx,sy));
    vis[sx*m+sy]=1;
    ans[sx*m+sy]=0;
    while(!q.empty())
    {
        node u=q.front();
        q.pop();
        int x=u.x,y=u.y;
        int blag=ans[x*m+y]%2?!g[x][y]:g[x][y];  //判断从起点到当前点的步数的奇偶性 
        blag?change(2,4,x,y):change(0,2,x,y); //按照规定bfs压入队列 
    }
}
int main()
{
    int t,x;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        for(int i=0;i<n;i++)
        {
            g[i].clear();
            for(int j=0;j<m;j++)
            {
                scanf("%d",&x);
                g[i].push_back(x);
            }
        }
        cin>>sx>>sy>>ex>>ey;
        sx--,sy--,ex--,ey--;
        bfs();
        cout<<ans[ex*m+ey]<<endl;
    }
    return 0;
}
```
ZOJ 4023 PPAP 
[http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4023](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4023)
水题
```cpp
#include<iostream>
using namespace std;
char a[50],b[50];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>a>>b;
        b[0]-=32;
        cout<<b<<a<<endl; 
    }
}
```
CSU 2085 手游大佬  
[http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2085](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2085)
计算日期，模拟即可
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int k[]={31,28,31,30,31,30,31,31,30,31,30,31};
bool Leap(int x)
{
    return (x%100!=0&&x%4==0)||(x%400==0);
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int year,month,day,a,b,ans=1,res=31+28+31+22;
        scanf("%d-%d-%d %d %d",&year,&month,&day,&a,&b);
        for(int i=year;i<2018;i++)
        {
            if(Leap(i))
              ans++;
            ans+=365;
        }
        for(int j=0;j<=month-2;j++)
        {
            if(j==1&&Leap(year))
              ans--;
            ans-=k[j];
        }
        ans+=res-day;
        int p=a/ans,q=b/ans;
        if(p>=100&&q>=12*60)
          cout<<"GH";
        else if(p>=100)
          cout<<"H";
        else if(q>=12*60)
          cout<<"G";
        else
          cout<<"O";
        cout<<endl;
    } 
    return 0;
}
```
CSU 2088 Pigs can’t take a sudden turn  
[http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2088](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=2088)
设t秒的时候A和B距离最小，且最小值为L，那么就可以得到计算公式
L = sqrt( (x1 - x2) + (u1 - u2) * t )^2 + ( (y1-y2) + (v1 - v2) * t )^2 )
展开变形 最后化成一个关于t的一元二次方程 L = sqrt( a*t*t + b*t +c )
当t = -b/(2*a)的时候距离最小
注意需要判断t>0才有效
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
int main()
{
    int t,tt=1;
    cin>>t;
    while(t--)
    {
        double x1,y1,x2,y2,u1,v1,u2,v2;
        cin>>x1>>y1>>x2>>y2>>u1>>v1>>u2>>v2;
        double u=u1-u2,v=v1-v2,x=x1-x2,y=y1-y2;
        double a=u*u+v*v,b=2*x*u+2*y*v,c=x*x+y*y;
        double res=max((double)0,-b/(a*2.0));
        double ans=sqrt(a*res*res+b*res+c);
        printf("Case %d: %.6lf\n",tt++,ans);
    }
    return 0;
}
```
