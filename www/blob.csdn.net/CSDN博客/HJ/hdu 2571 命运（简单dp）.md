# hdu  2571  命运（简单dp） - HJ - CSDN博客
2017年02月02日 19:33:43[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：353
Problem Description 
穿过幽谷意味着离大魔王lemon已经无限接近了！ 
可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！ 
可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！ 
命运大迷宫可以看成是一个两维的方格阵列，如下图所示：
yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。 
现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k>1。 
为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。
Input 
输入数据首先是一个整数C，表示测试数据的组数。 
每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1<=n<=20,10<=m<=1000)； 
接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|<100 )。
Output 
请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。
Sample Input
1 
3 8 
9 10 10 10 10 -10 10 10 
10 -11 -1 0 2 11 10 -20 
-11 -11 10 11 2 10 -10 -10
Sample Output
52
解题思路：
d[i][j]表示第i行第j列的位置最大幸运值
状态转移方程为:
```
d[i][j]=max(d[i-1][j],d[i][j-1],d[i][a[j]])+s[i][j]  其中a[j]表示序号j的因子
```
然后仔细处理一下边界就好了
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][1005],d[1005][1005],s[1005][1005];
void find(int x)               
{
    int l=0;
    for(int i=1;i<x;i++)
      if(x%i==0)
        a[x][l++]=i;
    a[x][l]='\0';
}
int main()
{
    int t,n,m;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)
            cin>>s[i][j];
        d[1][1]=s[1][1];                                  //从左上开始走 
        memset(a,0,sizeof(a));
        for(int i=1;i<=m;i++)                             //给数1-m每个数求出所有的因子 
          find(i);
        for(int i=2;i<=m;i++)
        {
            for(int j=0;a[i][j]!='\0';j++) 
              d[1][i]=max(d[1][i-1],d[1][a[i][j]]);       //第一行只能向右走一步或者向右翻倍跳 
            d[1][i]+=s[1][i];
        }
        for(int i=2;i<=n;i++)
        {
            d[i][1]=d[i-1][1]+s[i][1];
            for(int j=2;j<=m;j++)
            {
                d[i][j]=max(d[i-1][j],d[i][j-1]);       //可以向下走一步，向右走一步 
                for(int k=0;a[j][k]!='\0';k++)
                  d[i][j]=max(d[i][j],d[i][a[j][k]]);   //或者还可以向右翻倍跳 
                d[i][j]+=s[i][j];                       //求出当前决策最大值然后还需要加上当前点的s值 
            } 
        }
        cout<<d[n][m]<<endl;                           //到右下结束 
    }
    return 0;
}
```
