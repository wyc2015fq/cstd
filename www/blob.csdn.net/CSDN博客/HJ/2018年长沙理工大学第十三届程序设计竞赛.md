# 2018年长沙理工大学第十三届程序设计竞赛 - HJ - CSDN博客
2018年04月18日 16:19:54[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：91
个人分类：[====ACM====																[---------总结---------																[团队/个人套题训练题解](https://blog.csdn.net/feizaoSYUACM/article/category/7516342)](https://blog.csdn.net/feizaoSYUACM/article/category/6625811)](https://blog.csdn.net/feizaoSYUACM/article/category/6308070)
A题  LL
水题。。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<map>
#include<string>
using namespace std;
map<string,int> s;
int main()
{
    s["lovelive"]=1;
    char a[1005];
    while(gets(a))
    {
        int len=strlen(a);
        for(int i=0;i<len;i++)
          if(a[i]>='A'&&a[i]<='Z')
            a[i]+=32;
        if(s[a]==1)
          cout<<"yes"<<endl;
        else
          cout<<"no"<<endl;
    }
    return 0;
}
```
B题  奇怪的加法
注意考虑多个0的时候要变成只有一个0
```cpp
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int main()
{
    string a,b;
    while(cin>>a>>b)
    {
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        string c;
        int i=0;
        for(;i<a.length()&&i<b.length();i++)
        {
            char ch=(a[i]-'0'+b[i]-'0')%10+'0';
            c+=ch;
        }
        while(i<a.length())
          c+=a[i++];
        while(i<b.length())
          c+=b[i++];
        c.resize(i);
        reverse(c.begin(),c.end());
        int len=c.length(),j=0;
        while(j<len&&c[j]=='0')
          j++;
        if(j==len)
          cout<<0<<endl;
        else
        {
            while(j<len)
              cout<<c[j++];
            cout<<endl;
        }
    }
    return 0;
}
```
C题  取手机
结论题：不管k为多少，概率始终是b/(a+b)
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        long long a,b,k;
        cin>>a>>b>>k;
        double p=b/((a+b)*1.0);
        printf("%.3lf\n",p);
    } 
    return 0;
}
```
D题 zzq的离散数学教室1
解题思路：根据题意，其实就是求在区间[l,r]中素数倍数的个数和。
```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
const int maxn=1e6+10;
int l,r,p[maxn];
vector<int> v;
void init()
{
    memset(p,1,sizeof(p));
    p[0]=p[1]=0;
    for(int i=2;i*i<=maxn;i++)
      for(int j=i*i;j<maxn;j+=i)
        p[j]=0;
    for(int i=2;i<maxn;i++)
      if(p[i])
        v.push_back(i);
}
int main()
{
    init();
    while(cin>>l>>r)
    {
        int ans=0;
        for(int i=0;i<v.size()&&l*v[i]<=r;i++)
          ans+=r/v[i]-l+1;
        cout<<ans<<endl;
    }
    return 0;
}
```
E题  小木乃伊到我家
优先队列优化的Dijkstra，板子题。
```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
typedef long long ll;
const int maxn=200010;
struct node{
    ll v,len;
    bool operator < (const node&a)const{
        return len>a.len;
    }
}; 
ll n,m,vis[maxn],dis[maxn];
vector<node>G[maxn];
void Dijkstra()       //Dijkstra优先队列优化 
{
    memset(vis,0,sizeof(vis));
    for(int i=0;i<=n;i++)
      dis[i]=INF;
    dis[1]=0;
    priority_queue<node>Q;
    Q.push(node{1,0});
    while(!Q.empty())
    {
        node now=Q.top();
        Q.pop();
        ll v=now.v;
        if(vis[v])
          continue;
        vis[v]=1;
        for(int i=0;i<G[v].size();i++)
        {
            ll u=G[v][i].v,len=G[v][i].len;
            if(!vis[u]&&dis[u]>dis[v]+len)
            {
                dis[u]=dis[v]+len;
                Q.push(node{u,dis[u]});
            }
        }
    }
}
int main()
{
    while(cin>>n>>m)
    {
        ll u,v,w;
        for(int i=1;i<=n;i++)
          G[i].clear();
        for(int i=0;i<m;i++)
        {
            cin>>u>>v>>w;
            G[u].push_back(node{v,w});
            G[v].push_back(node{u,w});
        }
        ll ans=0;
        Dijkstra();
        if(dis[n]!=INF)
          cout<<dis[n]<<endl;
        else
          cout<<"qwb baka"<<endl;
    }
    return 0;
}
```
G题  逃离迷宫
解题思路：bfs走两遍，第一次从起点到各个钥匙，第二次从终点到各个钥匙，最后更新最小路径和。
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
const int N=505;
struct node{
    int x,y,step;
};
int px[]={0,0,1,-1},py[]={1,-1,0,0};
int ans,n,m;
int vis[N][N],sum[N][N],k[N][N];
char g[N][N];
void bfs(int x,int y)
{
    memset(vis,0,sizeof(vis));
    queue<node> q;
    q.push({x,y,0});
    vis[x][y]=1;
    while(!q.empty())
    {
        node t=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int dx=t.x+px[i];
            int dy=t.y+py[i];
            if(!vis[dx][dy]&&dx>=0&&dx<n&&dy>=0&&dy<m&&g[dx][dy]!='#'&&g[dx][dy]!='E')
            {
                vis[dx][dy]=1;
                if(g[dx][dy]=='K')
                {
                    k[dx][dy]+=t.step+1;
                    sum[dx][dy]++;
                }               
                if(sum[dx][dy]==2)
                  ans=min(ans,k[dx][dy]);
                q.push({dx,dy,t.step+1});
            }
        }
    }
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        memset(sum,0,sizeof(sum));
        memset(k,0,sizeof(k));
        int sx,sy,ex,ey;
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
          {
              cin>>g[i][j];
              if(g[i][j]=='P')
                sx=i,sy=j;
              if(g[i][j]=='E')
                ex=i,ey=j;
          }
        ans=INF;
        bfs(sx,sy);
        bfs(ex,ey);
        if(ans==INF)
          cout<<"No solution"<<endl;
        else
          cout<<ans<<endl;
    }
    return 0;
}
```
H题  数学考试
dp[i]表示从最后一位到第i个区间的最大值，注意dp[i]是从后面往前扫的，然后再从前往后面扫一遍就能得到答案了。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define INF (ll)0x3f3f3f3f3f3f3f3f
const int N=200005;
typedef long long ll;
ll a[N],sum[N],dp[N];
int main()
{
    int t,n,k;
    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            sum[i]=sum[i-1]+a[i];
        }
        memset(dp,-INF,sizeof(dp));
        for(int i=n-k+1;i>0;i--)
          dp[i]=max(dp[i+1],sum[i+k-1]-sum[i-1]);
        ll ans=-INF;
        for(int i=1;i+k-1<=n;i++)
          ans=max(ans,dp[i+k]+sum[i+k-1]-sum[i-1]);
        cout<<ans<<endl;
    }
    return 0;
}
```
L题  仓鼠养殖计划
贪心做法：尽量将同一个人带来的仓鼠放到大笼子里中，剩下的再放到小笼子里。
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int main()
{
    int t,a,b,n,x;
    cin>>t;
    while(t--)
    {
        int num=0,cnt=0;
        cin>>a>>b>>n;
        for(int i=0;i<n;i++)
        {
            cin>>x;
            num+=x/2,cnt+=x%2;
        }
        a=(b>=num)?a+b-num:a-2*(num-b);
        printf("%s\n",(a-cnt)<0?"No":"Yes");
    }
    return 0;
}
```
