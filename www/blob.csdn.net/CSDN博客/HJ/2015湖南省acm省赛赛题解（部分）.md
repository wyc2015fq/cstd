# 2015湖南省acm省赛赛题解（部分） - HJ - CSDN博客
2016年08月19日 20:51:50[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：521
A题（ Aerial Tramway） 
[https://ac.2333.moe/Contest/view/id/88/problem/A.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/A.xhtml)
神题。。。师兄说是树形dp，我连题目都没看懂。。
B题（大还是小?） 
[https://ac.2333.moe/Contest/view/id/88/problem/B.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/B.xhtml)
此题颇有争论，有的人用字符串处理过了，比如我，代码有点复杂：
```cpp
#include<stdio.h>
#include<string.h>
char a[100005],b[100005];
int main()
{
    int i,j,tt=0;
    while(scanf("%s%s",a,b)!=EOF)
    {
        tt++;
        int p,q,flag=0;
        p=strlen(a),q=strlen(b);
        for(i=0;i<p;i++)         //标记小数点的位置
          if(a[i]=='.')
             flag=i;
        if(flag)           //如果有小数点，则处理是否有后置0，有则删去
          for(j=p-1;a[j]=='0';j--)
            a[j]='\0';
        flag=0;
        for(i=0;i<q;i++)        //对字符串b的操作同a
          if(b[i]=='.')
             flag=i;
        if(flag)
           for(j=q-1;b[j]=='0';j--)   
               b[j]='\0';
        p=strlen(a),q=strlen(b);
        if(a[p-1]=='.')       //如果字符串最后一位是小数点，则小数点删去
          a[p-1]='\0';
        if(b[q-1]=='.')       //操作同上
          b[q-1]='\0';
        if(!strcmp(a,b))       //以下就是判断大小了
          printf("Case %d: Same\n",tt);
        else if(strcmp(a,b)>0)
          printf("Case %d: Bigger\n",tt);
        else
          printf("Case %d: Smaller\n",tt);
    }
    return 0;
}
```
可是居然有人这样的代码也过了！！！不能理解，代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    double a,b;
    int tt=1;
    while(cin>>a>>b)
    {
        if(a==b)
          printf("Case %d: Same\n",tt);
        else if(a>b)
          printf("Case %d: Bigger\n",tt);
        else
          printf("Case %d: Smaller\n",tt);
        tt++;
    }
    return 0;
}
```
我还是选择狗带吧。。。
C题（多边形的公共部分） 
[https://ac.2333.moe/Contest/view/id/88/problem/C.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/C.xhtml)
个人水准有限，对于计算几何的题目只能算渣渣
D题（错误的算法） 
[https://ac.2333.moe/Contest/view/id/88/problem/D.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/D.xhtml)
题目意思很容易理解，正确算法的答案至少有一个，甚至会有很多个，而错误算法的答案只有一个，用错误算法的答案在正确算法的答案里面匹配一次，看能不能匹配相同横纵坐标，然后根据匹配结果输出判断即可，代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
int s[505][505],a[505],b[505],c[505][505];
int main()
{
    int n,m,tt=0;
    while(cin>>n>>m)
    {
        tt++;
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        int maxr=0,maxc=0,max=0,x,y,p=0;
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
          {
              cin>>s[i][j];
              a[i]+=s[i][j];     //计算每一行的值的和
              b[j]+=s[i][j];     //计算每一列的值的和
          }
        for(int i=0;i<n;i++)    //查找和是最大值的行，记录错误计算的答案的行数
          if(maxr<a[i])
          {
              maxr=a[i];
              x=i;
          }
        for(int j=0;j<m;j++)    //查找和是最大值的列，记录错误计算的答案的列数
          if(maxc<b[j])
          {
              maxc=b[j];
              y=j;
          }
        max=0;
        for(int i=0;i<n;i++)
        {
          for(int j=0;j<m;j++)
          {
              c[i][j]=a[i]+b[j]-s[i][j];  //计算正确计算的答案，行数和加列数和减去重复计算的行列交点的数值
              if(max<c[i][j])
                max=c[i][j];      //计算出正确计算的答案的值
          }
      }
      int blag=0;
      for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
          if(c[i][j]==max)     //正确计算的答案可能有多个，只要符合即开始查找
          {
              if(x==i&&y==j)    //查找如果正确计算的答案的横纵坐标与错误计算的答案的横纵坐标完全相同，则匹配成功，做上标记并从循环中跳出
              {
                  blag=1;
                  break;
              }
          }
        if(blag==1)
          printf("Case %d: Weak\n",tt);
        else
          printf("Case %d: Strong\n",tt);
    }
}
```
E题（简单的图论问题?） 
[https://ac.2333.moe/Contest/view/id/88/problem/E.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/E.xhtml)
BFS题，处理起来比较麻烦，队友做的，我不是很会，代码如下：
```
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
int mp[505][505];
int n, m, r1,r2,l1,l2;
struct node
{
    int x, y, num,bj;
    friend bool operator<(node a, node b) {return a.num>b.num;}
};
int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
int mark1[505][505][4];
bool bfs()                                    //第二种
{
    int i;
    priority_queue<node> q;
    node now,next;
    memset(mark1,0,sizeof(mark1));
    now.x=r1;now.y=l1;now.num=mp[r1][l1];now.bj=-1;
    q.push(now);
    while(!q.empty())
    {
        now = q.top();
        q.pop();
        for(i = 0; i < 4; i++)
        {    
            next.x=now.x+dir[i][0];
            next.y=now.y+dir[i][1];
            if(next.x>=0&&next.x<n&&next.y>=0&&next.y<m&&mp[next.x][next.y]!=-1&&now.bj!=i&&mark1[now.x][now.y][i]==0)
            {
                next.bj = i;
                mark1[now.x][now.y][i]=1;
                next.num=now.num+mp[next.x][next.y];
                if(next.x==r2&&next.y==l2)
                {
                    printf("%d\n",next.num);
                    return 1;
                }
                q.push(next);
            }
        }
    }
    return 0;
}
bool bfs2()
{
    int i;
    priority_queue<node> q;
    node now,next;
    int mark[505][505]={0};
    now.x=r1;now.y=l1;now.num=mp[r1][l1];
    mark[r1][l1]=1;
    q.push(now);
    while(!q.empty())
    {
        now = q.top();
        q.pop();
        for(i = 0; i < 4; i++)
        {    
            next.x=now.x+dir[i][0];
            next.y=now.y+dir[i][1];
            if(next.x>=0&&next.x<n&&next.y>=0&&next.y<m&&mp[next.x][next.y]!=-1&&mark[next.x][next.y]!=1)
            {
                mark[next.x][next.y]=1;
                next.num=now.num+mp[next.x][next.y];
                if(next.x==r2&&next.y==l2)
                {
                    printf("%d ",next.num);
                    return 1;
                }
                q.push(next);
            }
        }
    }
    return 0;
} 
int main()
{
    int num,i, j, l,len,kk=1;
    char ch[5000];
    while(~scanf("%d %d %d %d %d %d",&n,&m,&r1,&l1,&r2,&l2))
    {
        r1=r1-1;r2=r2-1;
        l1=l1-1;l2=l2-1;
        getchar();
        for(i = 0; i < n;i++)
        {
            l=0;
            gets(ch);
            len = strlen(ch);
            for(j = 0; j < len; j++)
            {
                if(ch[j]=='*')
                {
                    mp[i][l]=-1;
                    l++;
                }
                else if(ch[j]>='0'&&ch[j]<='9')
                {
                    num = ch[j]-'0';
                    if(ch[j+1]>='0'&&ch[j+1]<='9')
                    {
                        num = num*10+(ch[j+1]-'0');
                        j++;
                        if(ch[j+1]>='0'&&ch[j+1]<='9')
                        {
                            num = num*10+(ch[j+1]-'0');
                            j++;
                        }
                    }
                    mp[i][l]=num;
                    l++;
                }
            }
        }
        printf("Case %d: ",kk++);
        if(bfs2()==0)
          printf("-1 ");
    int aa=bfs();
        if(aa==0)
          printf("-1\n");
    }
    return 0 ;
}
```
F题（阶乘除法） 
[https://ac.2333.moe/Contest/view/id/88/problem/F.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/F.xhtml)
数学题，注意剪枝，首先是分奇偶性，再者是跑循环的时候注意边界是根号10的9次方，也就是跑10的5次方左右，代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    __int64 i,j,sum,n;
    int tt=0,blag=0;
    while(cin>>n)
    {
        tt++;
        blag=0; 
        if(n==1)          //很显然，1是无解的
          printf("Case %d: Impossible\n",tt);
        else
        {
            if(n%2==0)      //并且只有当为偶数的时候，才存在至少两个可行解
            {
                for(i=1;i*i<=n;i++)
                {
                    sum=i;
                    for(j=i+1;;j++)    //暴力寻找
                    {
                        sum=sum*j;
                        if(sum==n)  //恰好等于，则有解
                        {
                            if(i!=1)
                              i--;
                            printf("Case %d: %I64d %I64d\n",tt,j,i);
                            blag=1;    //做上标记，使外循环也直接跳出
                            break;
                        }
                        if(sum>n)   //否则无解，持戒跳出
                          break;
                    }
                    if(blag)
                      break;
                }
            }
            else                 //否则就只有一个解，直接输出即可
              printf("Case %d: %I64d %I64d\n",tt,n,n-1);
        }
    }
    return 0;
}
```
G题（Graph Guessing） 
[https://ac.2333.moe/Contest/view/id/88/problem/G.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/G.xhtml)
图论，偏复杂，意思理解，但是还无法实现。。。
H题（聊天止于呵呵） 
[https://ac.2333.moe/Contest/view/id/88/problem/H.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/H.xhtml)
意思超级好懂，但是实现超级蛋疼，字符串处理题目，代码如下：
```cpp
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include<stdlib.h>
int a[27][27];
char ch[103][1003];
bool pd(int k)
{
    int i, j, l,len,flag;
    len = strlen(ch[k]);
    for(i = 0; i < len; i++)                  //处理 
    {
        if(isalpha(ch[k][i])！=0)
          if(ch[k][i]>='A'&&ch[k][i]<='Z')
            ch[k][i]+=32;
    }
    for(i = 0 ;i < len;i++)             //判断
    {
        flag = 1;
        for(j = i; j < len; j++)        //找空格
          if(ch[k][j] == ' '||ch[k][j]=='\0')
            break;
        for(l = i; l < j; l+=2)           //比较是否是he组成 
          if(ch[k][l]!='h'&&ch[k][l+1]!='e')
            flag = 0;
        if((j-i)%2==1)
          flag = 0;
        if(flag == 1)
          return 1;
        i = j;
    }
    return 0;
}
int main()
{
    char ch1,ch2,t;
    int i = 0,j;
    memset(a,-1,sizeof(a));
    while(~scanf("%c",&ch1))         //接收加找出最后一句； 
    {
        scanf("->%c: ",&ch2);
        gets(ch[i]);
        if(ch1>ch2){
            t = ch1;
            ch1 = ch2;
            ch2 = t;
        }
        a[(ch1-65)][(ch2-65)] = i;
        i++;
    }
    int coun=0;
    int nn = 0;
    for(i = 0; i < 26; i++)
    {
        for(j = 0;j < 26; j++)
        {
            if(i!=j)
            {
                if(a[i][j]!=-1)
                {
                    nn++;
                    if(pd(a[i][j]))coun++;
                }
            }
        }
    }
    double p = (coun*100/nn);
    printf("%.0lf%%\n",p);
    return 0 ;
}
```
I题（Internet of Lights and Switches） 
[http://write.blog.csdn.net/mdeditor#!postId=52254148](http://write.blog.csdn.net/mdeditor#!postId=52254148)
开关问题，位运算+二分搜，个人水平有限，代码无法给出。。。
J题（又一道简单题） 
[https://ac.2333.moe/Contest/view/id/88/problem/J.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/J.xhtml)
题目说的不错，这的确又是一道简单题，只要处理各个位数的数值注意最高位不能变成0即可，代码如下：
```
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int t,kk=0;
    cin>>t;
    while(t--)
    {
        kk++;
        int n,sum1,sum,tt=0,a[4],b[4];   //用数组存各个位的数值
        cin>>n;
        for(int i=32;i<=100;i++)   //平方值是四位数的范围在32~100之间，因此直接遍历即可
        {
            int count=0,sum1=n;
            sum=i*i;
            a[0]=sum%10;
            sum/=10;
            a[1]=sum%10;
            sum/=10;
            a[2]=sum%10;
            sum/=10;
            a[3]=sum;
            b[0]=sum1%10;
            sum1/=10;
            b[1]=sum1%10;
            sum1/=10;
            b[2]=sum1%10;
            sum1/=10;
            b[3]=sum1;
            for(int i=0;i<4;i++)
              if(a[i]==b[i]&&b[3]!=0)   //如果存在两个数值相等并且最高位不为0的情况，计数变量加一
                count++;
            if(count==3)   //如果技术变量刚好等于3，则该情况要算进总数内
              tt++;
        }
        printf("Case %d: ",kk);
        cout<<tt<<endl;
    }
    return 0;
}
```
K题（Keep Fit!） 
[https://ac.2333.moe/Contest/view/id/88/problem/K.xhtml](https://ac.2333.moe/Contest/view/id/88/problem/K.xhtml)
题目不是太懂，师兄说是要用线段树做，防AK的题，到此为止。。。
