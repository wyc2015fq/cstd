# 2018 3.24 第13届景驰-埃森哲杯广东工业大学ACM程序设计大赛题解 - HJ - CSDN博客
2018年04月07日 11:05:07[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：87
A题 跳台阶
递推公式为d[i] = d[i-1] + d[i-2] + … d[1] 
 可参考hdu 的题目‘超级楼梯’
```cpp
#include<iostream>
#include<cstring>
using namespace std;
long long s[50];
int main()
{
    int t,n;
    for(int i=1;i<=30;i++)
      s[i]=1;
    for(int i=2;i<=30;i++)
      for(int j=i-1;j>=1;j--)
        s[i]+=s[j];
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<s[n]<<endl;
    }
    return 0;
}
```
B 题 跳一跳，很简单的
待补….
C题 平分游戏
待补….
D题 psd面试
最长公共子串的变种
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int dp[1500][1500];
int main()
{
    string s;
    while(cin>>s)
    {
        int ans=0,len=s.length();
        for(int i=0;i<len;i++)
          if(s[i]>='A'&&s[i]<='Z')
            s[i]+=32;
        for(int j=0;j<=len;j++)
        {
            dp[j][j]=1;
            for(int i=j-1;i>=0;i--)
            {
                if(s[i]==s[j])
                  dp[i][j]=dp[i+1][j-1]+2;
                else
                  dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
            }
        }
        cout<<len-dp[0][len-1]<<endl;
    }
    return 0;
}
```
E题 回旋星空 
待补….
F题 等式
对 1/x + 1/y = 1/n 可做如下变化
==> x*y / (x+y ) = n  
   ==> x*y - n*(x+y)  = 0  此时两边同时加上 n^2 
   ==> n^2  - (x+y) * n + x*y = n^2  然后分解因式 
   ==>(n-x) * (n-y)  = n^2  
此时题目就转化成求n^2的因子个数 ，又唯一分解定理得到， 
n = p1^(a1) * p1^(a2) * … * pk^(ak)  
n^2 = p1^[2 * (a1)] * p2^[2 * (a2)] * … * pk^[2 * (ak)]
则 n的因子个数为 [(a1) + 1] * [(a2) + 1] * … * [(ak) + 1] 
 同理n^2的因子个数为[2 * (a1) + 1] * [2 * (a2) + 1] * … * [2 * (ak) + 1 ] 
 因此只要对n素因子分解，将得到的指数*2+1，再进行累乘就行了。
```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,res=1;
        cin>>n;
        for(int i=2;i*i<=n;i++)
        {
            if(n%i==0)
            {
                int cnt=0;
                while(n%i==0)
                {
                    n/=i;
                    cnt++;
                }
                res*=(cnt*2+1);
            }
        }
        if(n>1)
          res*=3;
        cout<<(res+1)/2<<endl;
    }
    return 0;
}
```
G题  旋转矩阵 
简单模拟
```cpp
#include<iostream>
using namespace std;
struct node{
    char s[35][35];
}a[5];
char b[1005];
void change(int k,int n,int m)
{
    for(int i=0;i<n;i++)
      for(int j=0;j<m;j++)
      {
          a[k].s[m-j-1][i]=a[k-1].s[i][j];
          if(a[k].s[m-j-1][i]=='-')
            a[k].s[m-j-1][i]='|';
          else if(a[k].s[m-j-1][i]=='|')
            a[k].s[m-j-1][i]='-';
      }
}
void get(int n,int m)
{
    for(int k=1;k<4;k++)
    {
        if(k%2)
          change(k,n,m);
        else
          change(k,m,n);
    }  
}
void Print(int k,int n,int m)
{
    cout<<n<<" "<<m<<endl;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
          cout<<a[k].s[i][j];
        cout<<endl;
    }
    cout<<endl;
}
int main()
{
    int t,n,m;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
            cin>>a[0].s[i][j];
        cin>>b;
        int ans=0;
        for(int i=0;b[i]!='\0';i++)
        {
            if(b[i]=='L')
              ans++;
            else
              ans--;
            if(ans<0)
              ans+=4;
        }
        get(n,m);
        ans%=4;
        if(ans%2==0)
          Print(ans,n,m);
        else
          Print(ans,m,n);
    }
    return 0;
}
```
H题 哲哲的疑惑 
待补
I题  填空题
最简单的题目，没有之一！
```cpp
#include<iostream>
using namespace std;
int main()
{
    cout<<"ac"<<endl;
}
```
J题 强迫症序列
每次操作只给这个数组的其中n-1个元素加1  == 每次只给数组的其中1个元素减1 
因此可以算出最小的操作步数ans = s[i] - min (0 <= i < n) 
因为每一次最小的min那个数都会操作一次，因此经过ans步之后，数组元素为ans + min
```cpp
#include<iostream>
#include<cmath> 
#include<cstring>
using namespace std;
int s[100005];
int main()
{
    int t,n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        int res=1001,ans=0;
        for(int i=0;i<n;i++)
        {
            cin>>s[i];
            res=min(res,s[i]);
        } 
        for(int i=0;i<n;i++)
          ans+=s[i]-res;
        cout<<ans<<" "<<ans+s[0]<<endl;
    }
    return 0;
}
```
K题 密码 
待补
L题 用来作弊的药水
最直接的方法就是用快速幂，判断x^a % mod 与 y^b % mod 的结果是否相同 （mod = 1e9+7 )
```cpp
#include<iostream>
using namespace std;
const int mod=1e9+7;
typedef long long LL;
LL quick_mod(LL a,LL n)
{
    LL sum=1;
    while(n)
    {
        if(n%2)
          sum=(sum*a)%mod;
        a=(a*a)%mod;
        n/=2;
    }
    return sum;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        LL a,b,x,y;
        cin>>x>>a>>y>>b;
        LL sum1=quick_mod(x,a),sum2=quick_mod(y,b);
        if(sum1==sum2)
          cout<<"Yes"<<endl;
        else
          cout<<"No"<<endl;
    }
    return 0;
}
```
当然还有更简单的方法 对两边取以10为底的对数 判断 a*lgx 与 b*lgy是否相等
```cpp
#include<iostream>
#include<cmath>
using namespace std;
typedef long long ll;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        ll x,y,a,b;
        cin>>x>>a>>y>>b;
        if((ll)(a*log10(x))==(ll)(b*log10(y)))
          cout<<"Yes"<<endl;
        else
          cout<<"No"<<endl;
    }
    return 0;
}
```
