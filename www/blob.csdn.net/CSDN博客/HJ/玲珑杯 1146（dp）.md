# 玲珑杯  1146（dp） - HJ - CSDN博客
2017年07月17日 14:11:14[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：217
今天HH在操场上跑步,HH作为一个爱运动的人,肯定会想方设法把跑步所消耗的能量减到最少.现在这个操场上有n个可以休息的点,他们的坐标分别是x1,x2…xn(xi≤xi+1),HH刚开始在x1 ,并且他只能在这些点休息,在中途不能停下来,否则会因为旁边的音浪太强而被晃到.如果H连续跑一段长度为l的距离,那么他将会消耗2l+a的能量(a为HH的可爱值)现在给你这些点的坐标,请帮HH计算他跑到xn点所需要消耗的能量最少是多少.
INPUT 
第一行是一个整数T(1≤T≤10),表示有T组数据 对于每组数据输入一行2个整数n,a (1≤n≤105,1≤a≤106) 表示总共有n个休息点,HH的可爱值为a. 接着一行n个数x1,x2…,xn(0≤xi≤3×106,0≤xi+1−xi≤30),表示点的位置.
OUTPUT 
每组数据输出一行,一个整数,表示最小需要花费的体力
SAMPLE INPUT 
2 
3 2 
3 5 7 
3 10 
3 5 7
SAMPLE OUTPUT 
12 
26
HINT 
对于第一组样例,最少的体力消耗是先从3跑到5,消耗6点体力,再从5跑到7,消耗6点体力,共12点  
对于第二组样例,最少的体力消耗是直接从3跑到7,消耗26点体力.
解题思路： 
先打表，用k[i]表示2的i次方的值，然后每次计算一个前缀和，用sum[i]表示前i个点的距离。 
设d[i]表示跑完前i个点需要消耗的最少体力。 
则状态转移方程是：
```
d[i]=min(d[i],d[i-j]+k[sum[i]-sum[i-j]]+a);
```
代码如下：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define maxn 100005
#define INF 0x3f3f3f3f
long long d[maxn],k[35];
int s[maxn],b[maxn],sum[maxn];
int main()
{
    int t,n,a;
    k[0]=1;
    for(int i=1;i<=31;i++)
      k[i]=2*k[i-1];
    cin>>t;
    while(t--)
    {
        memset(d,INF,sizeof(d));
        memset(sum,0,sizeof(sum));
        cin>>n>>a;
        for(int i=0;i<n;i++)
          cin>>b[i];
        for(int i=1;i<n;i++)
          s[i]=b[i]-b[i-1];
        for(int i=1;i<n;i++)
          sum[i]=sum[i-1]+s[i];
        d[0]=0;
        for(int i=1;i<n;i++)
          for(int j=1;j<=i&&sum[i]-sum[i-j]<32;j++)
            d[i]=min(d[i],d[i-j]+a+k[sum[i]-sum[i-j]]);
        cout<<d[n-1]<<endl;
    }
    return 0;
}
```
