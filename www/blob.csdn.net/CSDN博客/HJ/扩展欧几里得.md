# 扩展欧几里得 - HJ - CSDN博客
2017年01月17日 02:35:33[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：393
**欧几里得算法**
欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数。基本算法：设a=qb+r，其中a，b，q，r都是整数，则gcd(a,b)=gcd(b,r)，即gcd(a,b)=gcd(b,a%b)。 证明略去了。
基本代码实现：
```
int gcd(int a,int b)
    {
        if(b==0)
            return a;
        return
            gcd(b,a%b);
    }
```
**扩展欧几里得算法**
扩展欧几里德算法是欧几里得算法的扩展。
已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式ax + by = \gcd(a, b).。有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。
用类似辗转相除法，求二元一次不定方程47x+30y=1的整数解。
```
47=30*1+17
30=17*1+13
17=13*1+4
13=4*3+1
```
然后把它们改写成“余数等于”的形式
```
17=47*1+30*(-1) //式1
13=30*1+17*(-1) //式2
4=17*1+13*(-1) //式3
1=13*1+4*(-3)
```
然后把它们“倒回去”
```
1=13*1+4*(-3) //应用式3
1=13*1+[17*1+13*(-1)]*(-3)
1=13*4+17*(-3) //应用式2
1=[30*1+17*(-1)]*4+17*(-3)
1=30*4+17*(-7) //应用式1
1=30*4+[47*1+30*(-1)]*(-7)
1=30*11+47*(-7)
```
得解x=-7, y=11。
基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 
01 
    证明：设 a>b。 
    推理1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0；//推理1 
    推理2，ab!=0 时 
        设 ax1+by1=gcd(a,b); 
    　 bx2+(a mod b)y2=gcd(b,a mod b); 
        根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 
    则:ax1+by1=bx2+(a mod b)y2; 
    即:ax1+by1=bx2+(a-(a/b)*b)y2=ay2+bx2-(a/b)*by2; 
    根据恒等定理得：x1=y2; y1=x2-(a/b)*y2;//推理2 
     这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 
    上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。
扩展欧几里德的**递归代码**：
```cpp
#include <iostream>
    using namespace std;
    int exgcd(int a,int b,int & x,int & y){
        if(b == 0){
            //根据上面的推理1，基本情况
            x = 1;
            y = 0;
            return a;
        }
        int r = exgcd(b, a%b, x, y);
        //根据推理2
        int t = y;
        y = x - (a/b)*y;
        x = t;
        return r;
    }
    int main() {
        int x,y;
        exgcd(47,30,x,y);
        cout << "47x+30y=1 的一个整数解为: x=" << x << ", y=" << y << endl;
        return 0;
    }
```
**非递归实现**，比上面的看上去要复杂了不少，不熟悉的话直接用上面的就可以：
```
int exgcd(int m,int n,int &x,int &y)
    {
        int x1,y1,x0,y0;
        x0=1; y0=0;
        x1=0; y1=1;
        x=0; y=1;
        int r=m%n;
        int q=(m-r)/n;
        while(r)
        {
            x=x0-q*x1; y=y0-q*y1;
            x0=x1; y0=y1;
            x1=x; y1=y;
            m=n; n=r; r=m%n;
            q=(m-r)/n;
        }
        return n;
    }
```
扩展欧几里德算法的应用
（1）求解不定方程
用扩展欧几里得算法解不定方程ax+by=c;
这个应该比较好理解了，两个可以同乘以k
```
bool linear_equation(int a,int b,int c,int &x,int &y)
    {
        int d=exgcd(a,b,x,y);
        if(c%d)
            return false;
        int k=c/d;
        x*=k; y*=k;    //求得的只是其中一组解
        return true;
    }
```
（2）求解模线性方程（线性同余方程）
同余方程 ax≡b (mod n) (也就是 ax % n = b) 对于未知数 x 有解，当且仅当 gcd(a,n) | b (也就是 b % (gcd(a,n))==0 )。且方程有解时，方程有 gcd(a,n) 个解。
求解方程 ax≡b (mod n) 相当于求解方程 ax+ ny= b, (x, y为整数) 
    在方程  3x ≡ 2 (mod 6) 中， d = gcd(3,6) = 3 ，3 不整除 2，因此方程无解。 
    在方程 5x ≡ 2 (mod 6) 中， d = gcd(5,6) = 1，1 整除 2，因此方程在{0,1,2,3,4,5} 中恰有一个解: x=4。
证明略去，直接说算法：
首先看一个简单的例子：
5x=4(mod3)
解得x = 2,5,8,11,14…….
由此可以发现一个规律，就是解的间隔是3.
那么这个解的间隔是怎么决定的呢？
如果可以设法找到第一个解，并且求出解之间的间隔，那么就可以求出模的线性方程的解集了.
我们设解之间的间隔为dx.
那么有
a*x = b(mod n);
a*(x+dx) = b(mod n);
两式相减，得到:
a*dx(mod n)= 0;
也就是说a*dx就是a的倍数，同时也是n的倍数，即a*dx是a 和 n的公倍数.为了求出dx,我们应该求出a 和 n的最小公倍数,此时对应的dx是最小的.
设a 和 n的最大公约数为d,那么a 和 n 的最小公倍数为(a*n)/d.
即a*dx = a*n/d;
所以dx = n/d. (d = gcd(a,n) )
因此解之间的间隔就求出来了.
```
bool modular_linear_equation(int a,int b,int n)
    {
        int x,y,x0,i;
        int d=exgcd(a,n,x,y);
        if(b%d)
            return false;
        x0=x*(b/d)%n;   //特解
        for(i=1;i<d;i++)
            printf("%d\n",(x0+i*(n/d))%n);
        return true;
    }
```
（3）求解模的逆元；
同余方程ax≡b (mod n)，如果 gcd(a,n)== 1，则方程只有唯一解。
在这种情况下，如果 b== 1，同余方程就是 ax=1 (mod n ),gcd(a,n)= 1。
这时称求出的 x 为 a 的对模 n 乘法的逆元。
对于同余方程 ax= 1(mod n )， gcd(a,n)= 1 的求解就是求解方程
ax+ ny= 1，x, y 为整数。这个可用扩展欧几里德算法求出，原同余方程的唯一解就是用扩展欧几里德算法得出的 x 。
Description 
两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 
我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。
Input 
输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。
Output 
输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”
Sample Input
1 2 3 4 5
Sample Output
4
解法： 
    构建方程 (x+m*t) - (y+n*t) = p * ll;  (t是跳的次数，ll是a青蛙跳的圈数跟b青蛙的圈数之差。整个就是路程差等于纬度线周长的整数倍)，
转化一下： (n-m) * t + ll * p = x – y;
令 a = n-m,  b = ll,  c = gcd(a, b),  d = x-y;
有 a * t + b * p = d;   (1)
要求的是t的最小整数解。
用扩展的欧几里德求出其中一组解t0 ,p0, 并令c = gcd(a, b);
有 a * t0 + b * p0 = c;  (2)
因为c = gcd(a, b), 所以 a * t / c是整数，b * t / c 也是整数，所以 d / c 也需要是整数，否则无解。
(2)式两边都乘(d / c) 得 a * t0 *(d / c) + b * p0 * (d / c) = d;
所以t0 * (d / c)是最小的解，但有可能是负数。
因为a * ( t0 *(d / c) + b*n) + b * (p0 * (d / c) – a*n) = d; (n是自然数)
所以解为 (t0 * (d / c) % b + b) % b;
而求解方程ax+by=c如上讲解，代码如下：
```cpp
#include<iostream>
using namespace std;
long long gcd(long long a,long long b)    //欧几里得求gcd(a,b)
{
    return b?gcd(b,a%b):a;
}
void exgcd(long long a,long long b,long long &d,long long &x,long long &y)   //扩展欧几里得求解不定方程ax+by=d 
{
    if(!b)
    {
        d=a;x=1;y=0;
    }
    else
    {
        exgcd(b,a%b,d,y,x);
        y-=(a/b)*x;
    }
}
int getans(long long a,long long b,long long c,long long &ans)    // ax+by=c的最小整数解 
{
    long long r=gcd(a,b),y0;
    if(c%r)          //如果c不能整除gcd(a,b)，不定方程无解 
      return 0;
    a/=r,b/=r,c/=r;     //否则方程两边同时除以gcd(a,b)，得到新的不定方程a'x+b'y=c' ,此时gcd(a',b')=1 
    exgcd(a,b,r,ans,y0);
    long long t=c*ans/b;
    ans=ans*c-t*b;
    if(ans<0)       //整数解ans不能为负，在这里需要做一步修正 
      ans+=b;
    return 1;
}
int main()
{
    long long x,y,m,n,l;
    while(cin>>x>>y>>m>>n>>l)
    {
        long long a=n-m,b=l,c=x-y,ans;     //构建ax+by=c 判断是否存在整数解 
        int blag=getans(a,b,c,ans);
        if(!blag)
          cout<<"Impossible"<<endl;
        else
          cout<<ans<<endl;
    }
    return 0;
}
```
