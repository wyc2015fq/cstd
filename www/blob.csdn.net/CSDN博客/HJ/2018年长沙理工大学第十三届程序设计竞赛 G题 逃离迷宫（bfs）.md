# 2018年长沙理工大学第十三届程序设计竞赛  G题 逃离迷宫（bfs） - HJ - CSDN博客
2018年04月22日 15:03:59[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：76
[https://www.nowcoder.com/acm/contest/96/G](https://www.nowcoder.com/acm/contest/96/G)
解题思路：bfs走两遍，第一次从起点到各个钥匙，第二次从终点到各个钥匙，最后更新最小路径和。
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
const int N=505;
struct node{
    int x,y,step;
};
int px[]={0,0,1,-1},py[]={1,-1,0,0};
int ans,n,m;
int vis[N][N],sum[N][N],k[N][N];
char g[N][N];
void bfs(int x,int y)
{
    memset(vis,0,sizeof(vis));
    queue<node> q;
    q.push({x,y,0});
    vis[x][y]=1;
    while(!q.empty())
    {
        node t=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int dx=t.x+px[i];
            int dy=t.y+py[i];
            if(!vis[dx][dy]&&dx>=0&&dx<n&&dy>=0&&dy<m&&g[dx][dy]!='#'&&g[dx][dy]!='E')
            {
                vis[dx][dy]=1;
                if(g[dx][dy]=='K')
                {
                    k[dx][dy]+=t.step+1;
                    sum[dx][dy]++;
                }               
                if(sum[dx][dy]==2)
                  ans=min(ans,k[dx][dy]);
                q.push({dx,dy,t.step+1});
            }
        }
    }
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        memset(sum,0,sizeof(sum));
        memset(k,0,sizeof(k));
        int sx,sy,ex,ey;
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
          {
              cin>>g[i][j];
              if(g[i][j]=='P')
                sx=i,sy=j;
              if(g[i][j]=='E')
                ex=i,ey=j;
          }
        ans=INF;
        bfs(sx,sy);
        bfs(ex,ey);
        if(ans==INF)
          cout<<"No solution"<<endl;
        else
          cout<<ans<<endl;
    }
    return 0;
}
```
