# FZU 1036 四塔问题（规律） - HJ - CSDN博客
2017年03月13日 22:12:55[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：603
“汉诺塔”，是一个众所周知的古老游戏。现在我们把问题稍微改变一下：如果一共有4根柱子，而不是3根，那么至少需要移动盘子多少次，才能把所有的盘子从第1根柱子移动到第4根柱子上呢？
为了编程方便，您只需要输出这个结果mod 10000的值。
Input 
该题含有多组测试数据，每组一个正整数n。(0< n<=50000)
Output 
一个正整数，表示把n个盘子从第1根柱子移动到第4根柱子需要的最少移动次数mod 10000的值。
Sample Input 
15
Sample Output 
129
解题思路：
把前面几个算出来，得到如下规律：
f[1]  : 0  +2^0=1; 
f[2]  : 1  +2^1=3; 
f[3]  : 3  +2^1=5; 
f[4]  : 5  +2^2=9; 
f[5]  : 9  +2^2=13; 
f[6]  : 13+2^2=17; 
f[7]  : 17+2^3=25; 
f[8]  : 25+2^3=33; 
f[9]  : 33+2^3=41; 
f10] : 41+2^3=49; 
f[11]: 49+2^4=65;
即，f[i]-f[i-1]的值是有规律的，1个2^0,2个2^1,3个2^2,4个2^3，5个2^4以此类推。
```cpp
#include<cstdio>   
#include<algorithm>     
using namespace std;  
const int N=2e5+5;
int n,f[N];  
void init()  
{  
    int a=0,b=1;
    f[0]=0;  
    for(int i=1;i<N;)  
    {  
        for(int j=0;j<=a&&i<N;j++,i++)  
          f[i]=(f[i-1]+b)%10000;   
        a++; 
        (b<<=1)%=10000;  
    } 
}
int main()  
{  
    init();  
    while(~scanf("%d", &n)) 
      printf("%d\n", f[n]);  
    return 0;  
}
```
