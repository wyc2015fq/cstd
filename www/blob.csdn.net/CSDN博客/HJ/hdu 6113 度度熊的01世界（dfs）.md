# hdu  6113 度度熊的01世界（dfs） - HJ - CSDN博客
2017年08月13日 20:20:06[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：266
[http://acm.hdu.edu.cn/showproblem.php?pid=6113](http://acm.hdu.edu.cn/showproblem.php?pid=6113)
用dfs计算出’1’的联通块个数和不在外边一圈的’0’的联通块的个数
```cpp
#include<iostream>
#include<cstring>
using namespace std;
char s[1005][1005];
int vis[1005][1005],n,m;
int dx[]={1,0,-1,0},dy[]={0,1,0,-1}; 
bool dfs(int x,int y)
{
    vis[x][y]=1;
    int blag=true;
    for(int i=0;i<4;i++)
    {
        int sx=x+dx[i];
        int sy=y+dy[i];
        if(sx<0||sx>=n||sy<0||sy>=m)   //判断是否存在边界的点 
          blag=false;
        if(s[sx][sy]==s[x][y]&&!vis[sx][sy])
          blag&=dfs(sx,sy); 
    }
    return blag;
}
int main()
{
    while(cin>>n>>m)
    {
        for(int i=0;i<n;i++)
          cin>>s[i];        
        memset(vis,0,sizeof(vis));
        int one=0,zero=0;           //one 记录'1'联通块的个数  zero 表示不在外边一圈的'0'的联通块的个数 
        for(int i=0;i<n;i++)
          for(int j=0;j<m;j++)
          {
              if(!vis[i][j])
              {
                  if(s[i][j]=='1')
                  {
                      one++;
                      dfs(i,j);
                  }
                  else
                    zero+=dfs(i,j); 
              }
          }
        if(one!=1)
          cout<<-1<<endl;
        else if(zero==0)
          cout<<1<<endl;
        else if(zero==1)
          cout<<0<<endl;
        else
          cout<<-1<<endl;  
    }
    return 0;
}
```
