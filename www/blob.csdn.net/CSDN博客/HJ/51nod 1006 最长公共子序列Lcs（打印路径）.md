# 51nod  1006 最长公共子序列Lcs（打印路径） - HJ - CSDN博客
2017年04月10日 23:53:53[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：221
给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。 
比如两个串为：
abcicba 
abdkscab
ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 
Input
第1行：字符串A 
第2行：字符串B 
(A,B的长度 <= 1000)
Output
输出最长的子序列，如果有多个，随意输出1个。
Input示例
abcicba 
abdkscab
Output示例
abca
利用递归的思想，如果不太理解自己可以在纸上面模拟一遍！
```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[1005],b[1005],s[1005];
int d[1005][1005],c[1005][1005];      //d[i][j] 表示串a的前i个字符与串b的前j个字符最长公共子串的长度 
void print(int i,int j)
{
    if(i==0||j==0)
      return ;
    if(c[i][j]==0)         //表示当前字符为公共字母 
    {
        print(i-1,j-1);
        cout<<a[i-1];
    }
    else if(c[i][j]==1)    //表示往左回溯能得到最优解 
      print(i-1,j);
    else           //表示往上回溯能得到最优解 
      print(i,j-1);
} 
int main()
{
    while(cin>>a>>b)
    {
        int aa=strlen(a),bb=strlen(b);
        memset(d,0,sizeof(d));
        for(int i=1;i<=aa;i++)
          for(int j=1;j<=bb;j++)
          {
              if(a[i-1]==b[j-1])
              {
                  c[i][j]=0;             
                  d[i][j]=d[i-1][j-1]+1;
              }
              else
              {
                  if(d[i-1][j]>=d[i][j-1])
                  {
                      d[i][j]=d[i-1][j];
                      c[i][j]=1;           //记录下最优解的方向 
                  }
                  else
                  {
                      d[i][j]=d[i][j-1];
                      c[i][j]=-1;
                  }
              } 
          }
        print(aa,bb);         //递归输出结果 
        cout<<endl;
    }
    return 0;
}
```
