# hdu  1232  畅通工程（并查集） - HJ - CSDN博客
2016年08月07日 20:06:23[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：609
Problem Description 
某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 
Input 
测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。  
注意:两个城市之间可以有多条道路相通,也就是说 
3 3 
1 2 
1 2 
2 1 
这种输入也是合法的 
当N为0时，输入结束，该用例不被处理。 
Output 
对每个测试用例，在1行里输出最少还需要建设的道路数目。 
Sample Input 
4 2 
1 3 
4 3 
3 3 
1 2 
1 3 
2 3 
5 2 
1 2 
3 5 
999 0 
0
Sample Output 
1 
0 
2 
998
Hint 
Hint
Huge input, scanf is recommended.
并查集入门经典题！！！
解析：开一个大小n的数组，数组值跟数组下标保持一致，每次输入两个点之间表示连通的时候，调用合并函数，注意在合并两个点的时候需要分别找出两个点的祖先节点，并且赋值，最后找出不一样的值的个数，表示独立的个数（同时也是祖先节点的个数），如果这个个数减去一，就是题目所要求的还需要连通的个数。
代码解析如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int pa[1005];
int find(int v)
{
    int t1,t2=v;
    while(v!=pa[v])      //寻找祖先节点
      v=pa[v];
    while(t2!=pa[t2])     
    {
        t1=pa[t2];
        pa[t2]=v;
        t2=t1;
    }
    return v;
}
void  marget(int a,int b)
{
    int a1=find(a);
    int b1=find(b);
    if(a1!=b1)
     pa[a1]=b1;        //如果a、b连通，找到祖先节点后把祖先节点下标赋值给a、b下标的数组
}
int main()
{
    int n,m;
    while(~scanf("%d",&n))
    {
        if(n==0)
          break;
        scanf("%d",&m);
        int count=0,a,b;
        for(int i=1;i<=n;i++)
           pa[i]=i;
        for(int i=1;i<=m;i++)
        {
            scanf("%d %d",&a,&b);
            marget(a,b);           //每次输入都进行一次查找合并赋值
        }
        for(int i=1;i<=n;i++)
        {
            if(pa[i]==i)
              count++;
        }
        printf("%d\n",count-1);       //记得最后答案要减去一
    }
    return 0;
}
```
