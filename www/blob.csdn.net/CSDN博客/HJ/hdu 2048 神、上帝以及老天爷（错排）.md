# hdu 2048 神、上帝以及老天爷（错排） - HJ - CSDN博客
2016年04月25日 16:12:38[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：437
个人分类：[====ACM====																[----------数学----------																[排列组合																[---------OJ---------																[HDU](https://blog.csdn.net/feizaoSYUACM/article/category/6308041)](https://blog.csdn.net/feizaoSYUACM/article/category/6308067)](https://blog.csdn.net/feizaoSYUACM/article/category/6308090)](https://blog.csdn.net/feizaoSYUACM/article/category/6130298)](https://blog.csdn.net/feizaoSYUACM/article/category/6308070)
Problem Description
HDU 2006’10 ACM contest的颁奖晚会隆重开始了！ 
为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：
首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中； 
然后，待所有字条加入完毕，每人从箱中取一个字条； 
最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！
我的神、上帝以及老天爷呀，怎么会这样呢？
不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？
不会算？难道你也想以悲剧结尾？！
Input 
输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n,表示参加抽奖的人数。
Output 
对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。
Sample Input 
1 
2
Sample Output 
50.00%
由题目分析，再明显不过的错排！！！
别激动，首先让我解释一下什么是错排：
```
n个有序的元素应有n!个不同的排列,如若一个排列使得所有的元素都不在原来的位置上，则称这个排列为错排，有的叫重排.
```
错排递推分析：
```
以1 2 3 4四个数为例
 1 2的错排是唯一的,即2 1;
 1 2 3的错排
 3 1 2         2 3 1
 这二者可以看作是1 2的错排,3分别与1 2换位而得的.即：
 1 2 3 4的错排
 4 3 2 1      4 1 2 3       4 3 1 2
 3 4 1 2      3 4 2 1       2 4 1 3
 2 1 4 3      3 1 4 2       2 3 4 1
 第一列是由4分别与1,2,3互换位置,其余两个元素错排,由此生成的.
 第二列是由4和3 1 2(1 2 3的一个错排)的每一个数互换而得到的.
 第三列则是由4和另一个错排2 3 1换位而得到的.
```
上述分析的结果,实际上也是给出一种产生错排的方法.
设n个数1,2,3,…,n错排的数目为Dn,任取其中一个数i,数i分别与其它的n-1个数之一互换,其余n-2个数进行错排共得
```
(n-1)*D(n-2)个错排
```
另一部分为数i以外的n-1个数进行错排，然后i与其中每个数互换得
```
(n-1)*D(n-1)个错排
```
综合以上分析得递推关系：
```
Dn=(n-1)*(D(n-1)+D(n-2))    其中D1=0,D2=1    得到D0=1
```
化简Dn=(n-1)(D(n-1)+D(n-2))
Dn-n*D(n-1)=[(-1)^1]*[D(n-1)-(n-1)*D(n-2)] 
                   =[(-1)^2]*[D(n-2)-(n-2)*D(n-3)] 
                   =[(-1)^3]*[D(n-3)-(n-3)*D(n-4)] 
                   …… 
                   =[(-1)^(n-1)]*(D1-D0)
而D1=1,D0=0,因此有：
```
Dn-n*D(n-1)=(-1)^n
```
哎呀呀，公式一大堆，头都晕了。可怜的小编还是要告诉你，下面的内容更加复杂，因为递推虽然好，可是有一个致命的弱点：求解递推关系，得到封闭形式往往需要技巧，而这个技巧可以难得无以言及。。。小编也想哭。诸位如果一下内容能够看得懂那就值得小编膜拜，如果看不懂也没事，小编跟你一样，嘻嘻嘻，也是看不懂，不过最后的结论要记住就万事大吉了。
由母函数可以得到,令：
```
G(x)=D0+D1*x+(D2/2!)*x^2+...
```
又有D1=D0+(-1)^1 
       D2=D1+(-1)^2 
       D3=D2+(-1)^3 
       … 
可得           
```
G(x)-x*G(x)=e^(-x)
```
则      
```
G(x)=[e^(-x)]/(1-x)=[1-x+(x^2)/2!-...]/(1-x)
```
最后整理得到
```
Dn=(1-1+1/2!-...+[(-1)^n]*1/n!)*n!
```
记住，最后这条结论相当重要，是错排问题万变不离其宗的本质！！！
那么久了，大家也累了，就看看舒心的代码吧，保证，代码一定会让诸位看着舒心的，因为极其简短（相对来说）！！！
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int m;
        cin>>m; 
        double p=0,sign=1.0;   //注意用浮点型
        if(m==1)
          p=0;
        long long k=1;
        for(int i=2;i<=m;i++)
        {
              k=k*i;
              p=p+sign/(k*1.0);    //求阶乘的倒数
              sign=-sign;   //不断地更换正负号相加减
        }    
        p=p*100;    //小数转换为百分数
        printf("%.2f%%\n",p);
    }
    return 0;
}
```
