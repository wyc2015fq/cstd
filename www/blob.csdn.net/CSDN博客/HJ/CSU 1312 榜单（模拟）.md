# CSU  1312 榜单（模拟） - HJ - CSDN博客
2017年03月07日 23:49:54[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：221
ZZY很喜欢流行音乐，每周都要跟踪世界各地各种榜单，例如Oricon和Billboard，现在给出每周各个单曲的销量请给出每周的TOP5以及TOP5中各个单曲的浮动情况。
量的排名是按照本周销量排名，而不是总销量。
浮动情况则是较上周的排名变动，也就是说即使某单曲本周销量比上周的差，但排名比上周高,也是*UP*。反之若排名比上周低则为*DOWN*。若与上周的名次一样，则是*STAY*。
若是本周发行的新单(前面未有统计过销量)，则浮动的情况为*NEW*。所以第一周所有单的情况都为*NEW*。
Input
多组数据，每周第一行输入为一个正整数N(5<=N<=10)表示当周统计了销量的专辑数，当N=0时结束输入。(不超过10周)
每周的单曲名字都是不超过30位的字符串(不会有空格，连续的串)，名字后面跟的就是销量，单周最大销量不超过200万张。并且在不同周，相同的专辑名字一定是一模一样(相同的字符串)。
每周不会出现两个单曲销量相同。
本周没有统计前面某个已存在单曲的销量则说明本周其销量小得可以忽略，为0。
Output
第一组数据为第一周，第二组数据为第二周，以此类推。
每周数据第一行为WEEK k其中k为周数，WEEK k的左右两边各16个’-‘。
紧接着五行，依次为top1~top5。
先输出当前是第几名”rank.”，再接着当前名次单曲较上周的浮动情况。
*DOWN*与*STAY*后面空两格格输出单曲名，*NEW*后面空三格输出单曲名，*UP*后面空四格输出单曲名。
每行输出完单曲名后不要输出多余空格。
具体输出格式细节参考样例。
Sample Input
```
6
AKB48-Give_me_Five          1200000
Adele-Set_Fire_To_The_Rain   900000
Katy_Perry-Part_Of_Me        400000
KANA-Sakura,I_love_you       360000
Nicki_Minaj-Starships        300000
AAA-SAILING                  350000
5
KAT_TUN-CHAIN                550000
Adele-Set_Fire_To_The_Rain   850000
AKB48-Give_me_Five           500000
KANA-Sakura,I_love_you       300000
Nicki_Minaj-Starships        290000
0
```
Sample Output
```
----------------WEEK 1----------------
1.*NEW*   AKB48-Give_me_Five
2.*NEW*   Adele-Set_Fire_To_The_Rain
3.*NEW*   Katy_Perry-Part_Of_Me
4.*NEW*   KANA-Sakura,I_love_you
5.*NEW*   AAA-SAILING
----------------WEEK 2----------------
1.*UP*    Adele-Set_Fire_To_The_Rain
2.*NEW*   KAT_TUN-CHAIN
3.*DOWN*  AKB48-Give_me_Five
4.*STAY*  KANA-Sakura,I_love_you
5.*UP*    Nicki_Minaj-Starships
```
分析： 
开两个结构体数组，一个存放总共出现的唱片a[]，一个存放本周出现的唱片b[]。
因为要得到本周的唱片排名，所以有两步处理：
（1）如果本周的唱片前面出现过，只需要查找一下上周的排名，记录下载总共唱片的序号为多少即可； 
（2）如果本周的唱片前面未出现，更新到总共唱片库中，并且赋相应的值；
最后排序根据要求筛选是否为“new”、“up”、“down”还是“stay”即可。
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
struct node{
    char s[1005];
    long long x,y,e;   //x保存当前销量，y保存上周销量,e保存上周排名 
}a[1005];    //总共出现的唱片信息 
struct node1{
    char s[1005];
    long long num,sum;  //num当前唱片在a中的序号,sum表示当前唱片的本周销量 
}b[20];     //本周出现的唱片信息 
long long cmp(node1 x,node1 y)    
{
    return x.sum>y.sum;
}
int main()
{
    int n,tt=0,k=0,ans;
    while(cin>>n&&n)
    {   
        ans=k;                 //把本周以前的唱片种数统计出来 
        for(int i=0;i<n;i++)
          cin>>b[i].s>>b[i].sum;
        sort(b,b+n,cmp);          //给本周出现的唱片根据销量大到小进行排序 
        for(int i=0;i<n;i++)
        {
            int blag=0;
            for(int j=0;j<k;j++)
            {
                if(strcmp(b[i].s,a[j].s)==0)   //如果当前唱片曾经出现过 
                {
                    blag=1; 
                    b[i].num=j;       //记录本周唱片在总唱片库中序号 
                    a[j].y=a[j].x;       //更新上周销量 
                    a[j].x=b[i].sum;         //更新本周销量 
                    break;
                }
            }
            if(!blag)              //如果当前唱片为新唱片 
            {
                strcpy(a[k].s,b[i].s);
                b[i].num=k;     //更新在总唱片库的新序号 
                a[k].e=i+1;           //新唱片排名为i+1 
                a[k].y=0;           //上周销量为0 
                a[k].x=b[i].sum;         //更新本周销量 
                k++;
            }
        }
        printf("----------------WEEK %d----------------\n",++tt);
        for(int i=0;i<5;i++)
        {
            int t=b[i].num; 
            printf("%d.",i+1);
            if(t>=ans)      //如果排名在本周之前唱片种数的后面，说明为新唱片
            { 
                printf("*NEW*   ");
                a[t].e=i+1;     //更新唱片排名    
            }
            else
            {
                if(a[t].e>i+1)             //a[t].e表示上周排名 
                  printf("*UP*    ");
                else if(a[t].e==i+1)
                  printf("*STAY*  ");
                else 
                  printf("*DOWN*  ");
            }
            printf("%s\n",b[i].s);
        }
    }
    return 0;
}
```
