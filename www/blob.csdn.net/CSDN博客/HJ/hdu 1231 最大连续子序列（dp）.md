# hdu  1231  最大连续子序列（dp） - HJ - CSDN博客
2017年02月01日 19:31:01[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：182
Problem Description 
给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, 
Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个， 
例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和 
为20。 
在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该 
子序列的第一个和最后一个元素。
Input 
测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( < 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。
Output 
对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元 
素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。
Sample Input
6 
-2 11 -4 13 -5 -2 
10 
-10 1 2 3 4 -5 -23 3 7 -21 
6 
5 -8 3 2 5 0 
1 
10 
3 
-1 -5 -2 
3 
-1 0 -2 
0
Sample Output
20 11 13 
10 1 4 
10 3 5 
10 10 10 
0 -1 -2 
0 0 0
Hint 
Hint
Huge input, scanf is recommended.
Source 
浙大计算机研究生复试上机考试-2005年 
解题思路：
d[i]表示第i+1个数（下标从0开始）之前连续子序列和的最大值
则状态转移方程为
```
d[i]=max(d[i-1]+s[i]，s[i]）   s[i]为当前输入的数
```
然后遍历一遍找出第一个出现的最大值，赋值下标，分情况讨论，然后往前遍历，找出开始的下标点即可
```cpp
#include<iostream>
using namespace std;
int d[100005],s[100005];
int main()
{
    int n;
    while(cin>>n&&n)
    { 
        for(int i=0;i<n;i++)
          cin>>s[i];
        d[0]=s[0];
        for(int i=1;i<n;i++)
          d[i]=max(d[i-1]+s[i],s[i]);     //两种决策 
        int ans=d[0],q=0;
        for(int i=1;i<n;i++)
          if(ans<d[i])
            ans=d[q=i];                 //寻找最大值并把序号值赋给q 
        if(ans==-1)
          cout<<0<<" "<<s[0]<<" "<<s[n-1]<<endl;       //如果最大值为负数 
        else
        {
            if(s[q]==d[q])                   //如果只选择一个数的情况 
            {
                cout<<d[q]<<" "<<s[q]<<" "<<s[q]<<endl;
                continue;
            }
            int sum=ans,p=q;
            for(;sum!=0;p--)                 //否则求出p,也就是前面一个序号值 
              sum-=s[p];
            cout<<ans<<" "<<s[p+1]<<" "<<s[q]<<endl;
        }
    }
    return 0;
}
```
