# 51nod  1459 迷宫游戏（最短路） - HJ - CSDN博客
2017年04月29日 18:10:07[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：429
你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？ 
Input
第一行4个整数n (<=500), m, start, end。n表示房间的个数，房间编号从0到(n - 1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。 
第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。 
再接下来m行，每行3个空格分隔的整数x, y, z (0< z<=200)表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间, 你需要的时间为z。 
输入保证从start到end至少有一条路径。
Output
一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。
Input示例
3 2 0 2 
1 2 3 
0 1 10 
1 2 11
Output示例
21 6
最短路，我用的是Dijkstra，只要在耗费的时间相同的情况下更新一下钱的值即可。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define INF 0x3f3f3f3f
int vis[1005],a[1005],p[1005][1005],d[1005],ans[1005];
int n,m,sta,end,u,v,w;
void Dij()
{
    for(int i=0;i<n;i++)
      d[i]=p[sta][i];
    d[sta]=0;
    ans[sta]=a[sta];
    for(int i=0;i<n;i++)
    {
        int min=INF,k=sta;
        for(int j=0;j<n;j++)
          if(!vis[j]&&d[j]<min)      //查找最短路径 
            min=d[k=j];
        vis[k]=1;
        for(int j=0;j<n;j++)
        {
            if(d[j]>d[k]+p[k][j])
            {
                d[j]=d[k]+p[k][j];
                ans[j]=ans[k]+a[j];
            }
            else if(d[j]==d[k]+p[k][j])
              ans[j]=max(ans[j],ans[k]+a[j]);   //在耗费的时间相同的情况下，更新钱多的那一个值 
        }
    }
}
int main()
{
    while(cin>>n>>m>>sta>>end)
    {
        memset(p,INF,sizeof(p));
        memset(vis,0,sizeof(vis));
        memset(ans,0,sizeof(ans));
        for(int i=0;i<n;i++)
          cin>>a[i];
        for(int i=0;i<m;i++)
        {
            cin>>u>>v>>w;
            p[u][v]=p[v][u]=w;
        }
        Dij();
        cout<<d[end]<<" "<<ans[end]<<endl;
    }
    return 0;
}
```
