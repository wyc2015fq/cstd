# hdu  1271  整数对（找规律） - HJ - CSDN博客
2017年03月12日 11:07:21[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：322
Problem Description 
Gardon和小希玩了一个游戏，Gardon随便想了一个数A（首位不能为0），把它去掉一个数字以后得到另外一个数B，他把A和B的和N告诉了小希，让小希猜想他原来想的数字。不过为了公平起见，如果小希回答的数虽然不是A，但同样能达到那个条件（去掉其中的一个数字得到B，A和B之和是N），一样算小希胜利。而且小希如果能答出多个符合条件的数字，就可以得到额外的糖果。 
所以现在小希希望你编写一个程序，来帮助她找到尽可能多的解。 
例如，Gardon想的是A=31,B=3 告诉小希N=34， 
小希除了回答31以外还可以回答27（27+7=34）所以小希可以因此而得到一个额外的糖果。
Input 
输入包含多组数据，每组数据一行，包含一个数N(1<=N<=10^9)，文件以0结尾。
Output 
对于每个输入的N，输出所有符合要求的解（按照大小顺序排列）如果没有这样的解，输出”No solution.”
Sample Input
34 
152 
21 
0
Sample Output
27 31 32 
126 136 139 141 
No solution.
解析：
1、首先设X的第k位拿走，然后加上加上X的和正好等于N。 
2、这样可以把X 分解成：X= a+b * 10^k +c * 10^( k+1 ); 
a代表的是第k位后面的低位数子，可能是多位， 
b仅仅代表一个数值，即选择拿开的那位数， 
c代表的是比k位高的高位数字， 
例如：234567拿走4时有，这时候a=567,b=4,c=23。
3、然后拿走之后剩下的会组合成另一个数：Y=a + c * 10^k。
4、可以得出X+Y=2 * a + b * 10 ^k +11 * c * 10^k。因此如果N=X+Y；则必定满足这种结构。
5、综上得出3个式子：
A == a + b * 10^k + c * 10^(k+1) 
B == a         +         c * 10^k 
N == A + B == 2 * a + b * 10^k + c * 10^k * 11
6、因为b是一位数，则b * 10^k不会进位，用10^k除N取整就可以得到b + 11c，再除以11，商和余数就分别是c和b了。另外a是一个小于10^k的数没错， 
而2a可能产生进位，这样就使得b + 11c不符合要求。 
但是这可以解决，因为进位最多为1，即b可能实际上是b+1（因为在这种情况下，用10^k除N取整就可以得到1+b + 11c）， 
b本来最大是9，那现在是10，但不会影响到除11求得的c。 
然后根据2a进位和不进位两种情况，分别考虑b要不要-1（进位-1，不进位不减），再求a，验算，OK。
7、迭代k从最低位到最高位做一遍，就可以找出所有可能的A。
8、要保证b和c不能同时为0。
9、还有一点需要注意的就是重复问题：例如5002，那么可能会输入2次502.第一次去掉十位上的0，第二次去掉百位上的0，如果使用STL的set的话，就可以顺利解决这个问题，另外set会自动排序，默认升序。
```
#include<iostream>
#include<algorithm>
using namespace std;
int s[105];
int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
          break;
        int p=0,b,c,a;
        for(int k=1;k<=n;k*=10)
        {
            c=(n/k)/11;
            b=(n/k)%11;
            if(b+c&&b<10)       //不进位 
            {
                a=(n-b*k-11*c*k)/2;
                if(n==2*a+b*k+11*c*k)
                  s[p++]=a+b*k+10*c*k;
            }
            b--; 
            if(b+c&&b>=0)     //进位后 
            {
                a=(n-b*k-11*c*k)/2;
                if(n==2*a+b*k+11*c*k)
                  s[p++]=a+b*k+10*c*k;
            }
        }
        if(p)
        {
            sort(s,s+p);
            cout<<s[0];
            for(int i=1;i<p;i++)
              if(s[i]!=s[i-1]         //去重
                cout<<" "<<s[i];
            cout<<endl;
        }
        else
          cout<<"No solution."<<endl;
    }
    return 0;
}
```
