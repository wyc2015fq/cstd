# hdu 1269 迷宫城堡（强连通分量） - HJ - CSDN博客
2017年10月19日 21:33:38[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：144
Problem Description 
为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。
Input 
输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。
Output 
对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。
Sample Input 
3 3 1 2 2 3 3 1 3 3 1 2 2 3 3 2 0 0
Sample Output 
Yes No
计算有向图中强连通分量个数。Tarjan模板题。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<stack>
#define INF 0x3f3f3f3f
using namespace std;
const int N=10005;
stack<int> q;
vector<int> g[N];
int n,m,now,sum,dfn[N],low[N];
bool vis[N];
void Init()
{
    memset(dfn,0,sizeof(dfn));         //在dfs中该节点被搜索的次序（时间戳） 
    memset(low,0,sizeof(low));        //为i或者i的子树能够追溯到的最早的栈中节点的次序号 
    memset(vis,false,sizeof(vis));
    now=sum=0;
    for(int i=1;i<=n;i++)
      g[i].clear();
    while(!q.empty())
      q.pop();
} 
void tarjan(int s)
{
    vis[s]=true; 
    dfn[s]=low[s]=++now;   //标记点s的DFS遍历序号 
    q.push(s);
    for(int i=0;i<g[s].size();i++)
    {
        int u=g[s][i];
        if(!dfn[u])         //如果没有如果入过栈 
        {
            tarjan(u);
            low[s]=min(low[s],low[u]);
        }
        else if(vis[u])   
          low[s]=min(low[s],dfn[u]);
    }
    if(low[s]==dfn[s])
    {
        sum++;
        while(!q.empty())
        {
            int u=q.top();
            q.pop();
            vis[u]=true;
            if(u==s)
              break;
        }
    }
}
int main()
{
    while(~scanf("%d%d",&n,&m)&&(n||m))
    {
        int a,b;
        Init();
        while(m--)
        {
            scanf("%d%d",&a,&b);
            g[a].push_back(b);
        }
        for(int i=1;i<=n;i++)
          if(!dfn[i])
            tarjan(i);
        printf("%s\n",sum>1?"No":"Yes");
    }
    return 0;
}
```
