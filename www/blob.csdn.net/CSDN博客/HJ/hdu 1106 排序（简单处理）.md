# hdu  1106 排序（简单处理） - HJ - CSDN博客
2017年03月08日 00:05:19[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：666
Problem Description 
输入一行数字，如果我们把这行数字中的‘5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。
你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。
Input 
输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于1000。  
输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由‘5’组成。
Output 
对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。
Sample Input
0051231232050775
Sample Output
0 77 12312320
每次在两个5之间处理一下，把字符串变成一个数存在数组中，最后排序即可。
注意最后有可能不是以5结尾的，所以需要额外赋值存到数组中。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    char s[1005];
    while(cin>>s)
    {
        long long b[1005],k=0,i,j,sum=0,blag=1;
        for(i=0;s[i]!='\0';i++)
        {
            if(s[i]=='5'&&!blag)       //如果发现第一个5，就把前面转换的数存到数组中 
            {
                blag=1;
                b[k++]=sum;
                sum=0;
                continue;
            }
            if(s[i]!='5')        //在两个5之间把子串数字转换成十进制数 
            {
                blag=0;
                sum=sum*10+s[i]-'0';
            }
        }
        if(s[i-1]!='5')     //如果最后一位不是5，把最后一个5之后的数存到数组中 
          b[k++]=sum;
        sort(b,b+k);
        for(i=0;i<k;i++)
        {
            if(i!=k-1)
              cout<<b[i]<<" ";
            else
              cout<<b[i]<<endl;
        }
    }
    return 0;
}
```
