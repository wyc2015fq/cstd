# CSU  1588  合并果子（优先队列） - HJ - CSDN博客
2016年08月02日 17:51:02[FZH_SYU](https://me.csdn.net/feizaoSYUACM)阅读数：318
CSU   1588  合并果子
Description 
现在有n堆果子，第i堆有ai个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。
Input 
第一行包含一个整数T（T<=50），表示数据组数。 
每组数据第一行包含一个整数n（2<=n<=1000），表示果子的堆数。 
第二行包含n个正整数ai（ai<=100），表示每堆果子的果子数。
Output 
每组数据仅一行，表示最小合并代价。
Sample Input 
2 
4 
1 2 3 4 
5 
3 5 2 1 4 
Sample Output 
19 
33
方法一：优先队列
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<queue>
#include<set>
#include<stack>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--) 
    {
        priority_queue<int,vector<int>,greater<int> >q;    //最大值优先
        int n,sum,x,y,m,k;
        cin>>n;
        for(int i=0;i<n;i++)
        {
            int k;
            cin>>k;
            q.push(k);       //入队列
        } 
        sum=0;
        while(!q.empty())      //判断队列是否非空
        {
            x=q.top();       //取队列顶数字赋值
            q.pop();         //出队列
            if(q.empty())
              break;
            y=q.top();
            q.pop();
            m=x+y;
            sum=sum+m;     //合并
            q.push(m);     //继续入队列
        }
        cout<<sum<<endl;
    }
    return 0;
}
```
方法二：sort排序+插入排序
```cpp
#include<iostream>
#include<algorithm>
using namespace std; 
bool cmp(int x,int y)
{
    return x>y;
}
int main()
{
    int n,x,a[1005],sum,i,j;
    cin>>n; 
    while(n--)
    {   
        sum=0;
        cin>>x;
        for(i=1;i<=x;i++)
           cin>>a[i];
        sort(a+1,a+x+1,cmp);      //先按从大到小的顺序排序
        for(i=x;i>1;i--)          //从最后一位数开始，每合并一个数，就往前推一位
        {
           a[i]+=a[i-1];
           sum+=a[i];
           for(j=i-2;j>=1;j--)     //插入排序过程，所有数据按从大到小排好
           {
              if(a[i]<=a[j])
                break;
              else
                a[j+1]=a[j];
           }
           a[j+1]=a[i];
        }
        cout<<sum<<endl;
    }
    return 0;
}
```
