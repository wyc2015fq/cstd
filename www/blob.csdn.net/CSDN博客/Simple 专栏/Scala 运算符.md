# Scala  运算符 - Simple 专栏 - CSDN博客
2018年09月14日 17:04:26[Simple_Zz](https://me.csdn.net/love284969214)阅读数：161
所属专栏：[Scala 入门](https://blog.csdn.net/column/details/27500.html)
在Scala语言中，运算符是一个符号，告诉编译器执行特定的数学或逻辑函数。Scala语言提供丰富的内置运算符，并提供以下类型的运算符 -
- 算术运算符
- 关系运算符
- 逻辑运算符
- 按位运算符
- 赋值运算符
- 其它运算符
## 1.算术运算符
下表显示了Scala支持的所有算术运算符。假设变量`A`的值是`10`，变量`B`的值是`20`，那么 -
|运算符|描述|示例|
|----|----|----|
|`+`|将两个操作数相加|`A + B = 30`|
|`-`|从第一个操作数减去第二个操作数|`A − B = -10`|
|`*`|将两个操作数相乘|`A * B = 200`|
|`/`|将第一个操作数除以第二个操作数||
|`%`|模数运算符和整数除法后的余数。|`B % A = 0`|
|`++`|递增运算符将整数值增加`1`。|`A++ = 11`|
|`--`|递减运算符将整数值减1。|`A-- = 9`|
创建一个源代码文件：*Demo.scala*，如下代码 -
```
object Demo {
   def main(args: Array[String]) {
      var a = 10;
      var b = 20;
      var c = 25;
      var d = 25;
      println("a + b = " + (a + b) );
      println("a - b = " + (a - b) );
      println("a * b = " + (a * b) );
      println("b / a = " + (b / a) );
      println("b % a = " + (b % a) );
      println("c % a = " + (c % a) );
   }
}
```
执行上面示例代码，得到以下结果 -
```
a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
```
## 2.关系运算符
下表显示了Scala语言支持的关系运算符。假设变量`A=10`，变量`B=20`，则 -
|运算符|描述|示例|
|----|----|----|
|`==`|检查两个操作数的值是否相等。 如果相等，则条件成立。|`(A == B)`结果为`false`|
|`!=`|检查两个操作数的值是否相等。 如果值不相等，则条件成立。|`(A != B)` 结果为`true`|
|`>`|检查左操作数的值是否大于右操作数的值。 如果是，则条件成立。|`(A > B)` 结果为`false`|
|`<`|检查左操作数的值是否小于右操作数的值。 如果是，则条件成立。|`(A < B)`结果为`true`|
|`>=`|检查左操作数的值是否大于等于右操作数的值。 如果是，则条件成立。|`(A >= B)` 结果为`false`|
|`<=`|检查左操作数的值是否小于等于右操作数的值。 如果是，则条件成立。|`(A <= B)`结果为`true`|
创建一个源代码文件：*Demo.scala*，如下代码 -
```
object Demo {
   def main(args: Array[String]) {
      var a = 10;
      var b = 20;
      println("a == b = " + (a == b) );
      println("a != b = " + (a != b) );
      println("a > b = " + (a > b) );
      println("a < b = " + (a < b) );
      println("b >= a = " + (b >= a) );
      println("b <= a = " + (b <= a) );
   }
}
```
执行上面示例代码，得到以下结果 -
```
a == b = false
a != b = true
a > b = false
a < b = true
b >= a = true
b <= a = false
```
## 3.逻辑运算符
下表显示了Scala支持的所有逻辑运算符。 假设变量`A=1`，变量`B=0`，则 -
|运算符|描述|示例|
|----|----|----|
|`&&`|逻辑与运算符。 如果两个操作数都不为零，则条件成立。|`(A && B)`结果为`false`|
|![](http://www.yiibai.com/uploads/images/201708/1408/134080847_73961.png)|称为逻辑或运算符。如果两个操作数中的任何一个非零，则条件成立。|(A![](http://www.yiibai.com/uploads/images/201708/1408/134080847_73961.png)B)结果为`true`|
|`!`|称为逻辑非运算符，它用于反转其操作数的逻辑状态。如果条件为真，则逻辑`NOT`运算符将使其结果为`false`。| |
**示例：**创建一个源文件：`Demo.scala`，代码如下 -
```
object Demo {
   def main(args: Array[String]) {
      var a = true;
      var b = false;
      println("a && b = " + (a&&b) );
      println("a || b = " + (a||b) );
      println("!(a && b) = " + !(a && b) );
   }
}
```
执行上面代码，得到以下结果 -
```
a && b = false
a || b = true
!(a && b) = true
```
## 4.按位运算符
按位运算符对位进行操作，并执行逐位运算。 `＆`，`|`和`^`的真值表如下 -
|p|q|p & q|p/q|p ^ q|
|----|----|----|----|----|
|0|0|0|0|0|
|0|1|0|1|1|
|1|1|1|1|0|
|1|0|0|1|1|
假设`A = 60`，`B = 13`，二进制格式如下：
```
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011
```
下表列出了Scala支持的按位运算符。假设变量`A=60`，变量`B=13`，则 -
|运算符|描述|示例|
|----|----|----|
|`&`|如果二进制AND运算符存在于两个操作数中，则二进制AND运算符将对结果复制一位。|`(A&B)= 12`，即`0000 1100`|
|![](http://www.yiibai.com/uploads/images/201708/1408/441090814_80736.png)|二进制OR运算符如果存在于任一操作数中，则复制一位。|(A![](http://www.yiibai.com/uploads/images/201708/1408/441090814_80736.png)B) = 61, 即 `0011 1101`|
|`^`|二进制XOR操作符复制该位，如果它设置在一个操作数中，而不是两者。|`(A ^ B) = 49`, 即, `0011 0001`|
|`~`|二进制补码运算符是一元的，具有“翻转”位的作用。|`(~A)= -61`，即 `1100 0011`的补码形式。|
|`<<`|二进制左移操作符，左操作数值左移由右操作数指定的位数。|`A << 2 = 240` 即, `1111 0000`|
|`>>`|二进制右移操作符，左操作数值被右操作数指定的位移动。|`A >> 2 = 15` 即,`0000 1111`|
**示例：** 创建一个源代码文件：`Demo.scala`，代码如下所示 -
```
object Demo {
   def main(args: Array[String]) {
      var a = 60;           /* 60 = 0011 1100 */  
      var b = 13;           /* 13 = 0000 1101 */
      var c = 0;
      c = a & b;            /* 12 = 0000 1100 */ 
      println("a & b = " + c );
      c = a | b;            /* 61 = 0011 1101 */
      println("a | b = " + c );
      c = a ^ b;            /* 49 = 0011 0001 */
      println("a ^ b = " + c );
      c = ~a;               /* -61 = 1100 0011 */
      println("~a = " + c );
      c = a << 2;           /* 240 = 1111 0000 */
      println("a << 2 = " + c );
      c = a >> 2;           /* 215 = 1111 */
      println("a >> 2  = " + c );
      c = a >>> 2;          /* 215 = 0000 1111 */
      println("a >>> 2 = " + c );
   }
}
```
执行上面代码，得到以下结果 -
```
a & b = 12
a | b = 61
a ^ b = 49
~a = -61
a << 2 = 240
a >> 2 = 15
a >>> 2 = 15
```
## 5.赋值运算符
下表列出了Scala语言支持的赋值运算符 -
|运算符|描述|示例|
|----|----|----|
|`=`|简单赋值运算符，将右侧操作数的值分配给左侧操作数|`C = A + B`，将`A + B`的值分配给`C`|
|`+=`|相加与赋值运算符。它将右操作数添加到左操作数，并将结果分配给左操作数。|`C + = A`等价于`C = C + A`|
|`-=`|相减与赋值运算符。它从左操作数中减去右操作数，并将结果分配给左操作数。|`C -= A`等价于 `C = C - A`|
|`*=`|乘以与赋值运算符。它将右操作数与左操作数相乘，并将结果分配给左操作数。|`C * = A`等价于`C = C * A`|
|`/=`|除以与赋值运算符。它将左操作数与右操作数分开，并将结果分配给左操作数。|`C /= A`等价于`C = C / A`|
|`%=`|模数与赋值运算符。它需要使用两个操作数的模数，并将结果分配给左操作数。|`C %= A`等价于`C = C % A`|
|`<<=`|左移与赋值运算符|`C <<= 2`等价于`C = C << 2`|
|`>>=`|右移与赋值运算符|`C >> = 2`等价于`C = C >> 2`|
|`&=`|按位与赋值运算符|`C &= 2`等价于`C = C & 2`|
|`^=`|按位异或运算符和赋值运算符。|`C ^= 2`等价于`C = C ^ 2`|
|![](http://www.yiibai.com/uploads/images/201708/1408/812090837_38533.png)|按位包含OR和赋值运算符。|![](http://www.yiibai.com/uploads/images/201708/1408/330090851_37216.png)|
**示例：** 创建一个源文件：*Demo.scala* ，其代码如下 -
```
object Demo {
   def main(args: Array[String]) {
      var a = 10;    
      var b = 20;
      var c = 0;
      c = a + b;
      println("c = a + b  = " + c );
      c += a ;
      println("c += a  = " + c );
      c -= a ;
      println("c -= a = " + c );
      c *= a ;
      println("c *= a = " + c );
      a = 10;
      c = 15;
      c /= a ;
      println("c /= a  = " + c );
      a = 10;
      c = 15;
      c %= a ;
      println("c %= a  = " + c );
      c <<= 2 ;
      println("c <<= 2  = " + c );
      c >>= 2 ;
      println("c >>= 2  = " + c );
      c >>= 2 ;
      println("c >>= 2  = " + c );
      c &= a ;
      println("c &= a  = " + c );
      c ^= a ;
      println("c ^= a  = " + c );
      c |= a ;
      println("c |= a  = " + c );
   }
}
```
执行上面代码，得到以下结果 -
```
c = a + b  = 30
c += a  = 40
c -= a  = 30
c *= a  = 300
c /= a  = 1
c %= a  = 5
c <<= 2  = 20
c >>= 2  = 5
c >>= 2  = 1
c &= a  = 0
c ^= a  = 10
c |= a  = 10
```
## 6.运算符优先级
运算符优先级决定表达式中术语的分组，并决定如何评估计算表达式。 某些运算符的优先级高于其他运营商; 例如，乘法运算符的优先级高于加法运算符，则先要执行乘法运算符的运算。
让我们通过下面的例子了解优先级：
```
int value = 10 + 20 * 10;
```
`value`变量计算结果为：`210`，因为`*`(乘法运算符)的优先级比`+`(加法运算符)高，所以在`+`(加法运算符)之前进行求值。
C语言运算符的优先级和关联性如下：
|分类|运算符|关联性|
|----|----|----|
|后缀|`() [] -> . ++ - -`|左到右|
|一元|`+ - ! ~ ++ - - (type)* & sizeof`|右到左|
|乘法|`* / %`|左到右|
|加法|`+ -`|左到右|
|位移|`<< >>`|左到右|
|关系|`< <= > >=`|左到右|
|等于|`== !=`|左到右|
|按位与|`&`|左到右|
|位异或|`^`|左到右|
|按位或|`/`|左到右|
|逻辑与|`&&`|左到右|
|逻辑或|`//`|左到右|
|条件|`?:`|右到左|
|赋值|`= += -= *= /= %=>>= <<= &= ^= /=`|右到左|
|逗号|`,`|左到右|
