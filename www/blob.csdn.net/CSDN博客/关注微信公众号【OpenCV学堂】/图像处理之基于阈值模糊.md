# 图像处理之基于阈值模糊 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2012年09月26日 08:15:12[gloomyfish](https://me.csdn.net/jia20003)阅读数：3487
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









**图像处理之基于阈值模糊**

**算法思想：**

实现一个高斯卷积模糊但是只运用与周围的像素值与中心像素值差值小于阈值。两个

像素值之间的距离计算可以选用向量距离即曼哈顿距离或者欧几里德距离。高斯模糊

采用先XY方向一维高斯模糊完成目的是为了减小计算量。

**程序效果：**

**![](https://img-my.csdn.net/uploads/201209/26/1348618506_2710.png)**

**关键代码解释：**

**分别完成XY方向的一维高斯模糊**

****

```java
thresholdBlur( kernel, inPixels, outPixels, width, height, true );
thresholdBlur( kernel, outPixels, inPixels, height, width, true );
```
计算像素距离，完成像素高斯卷积代码如下：


****

```java
int d;
if(euclid) {
	d = (int)Math.sqrt(a1*a1-a2*a2);
} else {
	d = a1-a2;
}
if ( d >= -threshold && d <= threshold ) {
    a += f * a2;
    af += f;
}
if(euclid) {
	d = (int)Math.sqrt(r1*r1-r2*r2);
} else {
	d = r1-r2;
}
if ( d >= -threshold && d <= threshold ) {
    r += f * r2;
    rf += f;
}
if(euclid) {
	d = (int)Math.sqrt(g1*g1-g2*g2);
} else {
	d = g1-g2;
}
if ( d >= -threshold && d <= threshold ) {
    g += f * g2;
    gf += f;
}
if(euclid) {
	d = (int)Math.sqrt(b1*b1-b2*b2);
} else {
	d = b1-b2;
}
if ( d >= -threshold && d <= threshold ) {
    b += f * b2;
    bf += f;
}
```
滤镜完整代码如下：



****

```java
package com.gloomyfish.filter.study;

import java.awt.image.BufferedImage;

public class SmartBlurFilter extends AbstractBufferedImageOp {

	private int hRadius = 5;
	private int threshold = 50;
	private boolean euclid = false;
	
    public BufferedImage filter( BufferedImage src, BufferedImage dest ) {
        int width = src.getWidth();
        int height = src.getHeight();

        if ( dest == null )
            dest = createCompatibleDestImage( src, null );

        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        getRGB( src, 0, 0, width, height, inPixels );

        // generate the Gaussian kernel data
        float[] kernel = makeKernel(hRadius);
        
        // do Gaussian X and Y direction with kernel data.
        // this way will proceed quickly
		thresholdBlur( kernel, inPixels, outPixels, width, height, true );
		thresholdBlur( kernel, outPixels, inPixels, height, width, true );

		// set back result data to destination image
        setRGB( dest, 0, 0, width, height, inPixels );
        return dest;
    }
    
	/**
	 * Convolve with a Gaussian matrix consisting of one row float data
	 */
	public void thresholdBlur(float[] matrix, int[] inPixels, int[] outPixels, int width, int height, boolean alpha) {
		int cols = matrix.length;
		int cols2 = cols/2;

		for (int y = 0; y < height; y++) {
			int ioffset = y*width; // index to correct row here!!
            int outIndex = y;
			for (int x = 0; x < width; x++) {
				float r = 0, g = 0, b = 0, a = 0;
				int moffset = cols2;

                int rgb1 = inPixels[ioffset+x];
                int a1 = (rgb1 >> 24) & 0xff;
                int r1 = (rgb1 >> 16) & 0xff;
                int g1 = (rgb1 >> 8) & 0xff;
                int b1 = rgb1 & 0xff;
				float af = 0, rf = 0, gf = 0, bf = 0;
                for (int col = -cols2; col <= cols2; col++) {
					float f = matrix[moffset+col];

					if (f != 0) {
						int ix = x+col;
						if (!(0 <= ix && ix < width))
							ix = x;
						int rgb2 = inPixels[ioffset+ix];
                        int a2 = (rgb2 >> 24) & 0xff;
                        int r2 = (rgb2 >> 16) & 0xff;
                        int g2 = (rgb2 >> 8) & 0xff;
                        int b2 = rgb2 & 0xff;

						int d;
						if(euclid) {
							d = (int)Math.sqrt(a1*a1-a2*a2);
						} else {
							d = a1-a2;
						}
                        if ( d >= -threshold && d <= threshold ) {
                            a += f * a2;
                            af += f;
                        }
                        if(euclid) {
							d = (int)Math.sqrt(r1*r1-r2*r2);
						} else {
							d = r1-r2;
						}
                        if ( d >= -threshold && d <= threshold ) {
                            r += f * r2;
                            rf += f;
                        }
                        if(euclid) {
							d = (int)Math.sqrt(g1*g1-g2*g2);
						} else {
							d = g1-g2;
						}
                        if ( d >= -threshold && d <= threshold ) {
                            g += f * g2;
                            gf += f;
                        }
                        if(euclid) {
							d = (int)Math.sqrt(b1*b1-b2*b2);
						} else {
							d = b1-b2;
						}
                        if ( d >= -threshold && d <= threshold ) {
                            b += f * b2;
                            bf += f;
                        }
					}
				}
                // normalization process here
                a = af == 0 ? a1 : a/af; 
                r = rf == 0 ? r1 : r/rf;
                g = gf == 0 ? g1 : g/gf;
                b = bf == 0 ? b1 : b/bf;
                
                // return result pixel data
				int ia = alpha ? PixelUtils.clamp((int)(a+0.5)) : 0xff;
				int ir = PixelUtils.clamp((int)(r+0.5));
				int ig = PixelUtils.clamp((int)(g+0.5));
				int ib = PixelUtils.clamp((int)(b+0.5));
				outPixels[outIndex] = (ia << 24) | (ir << 16) | (ig << 8) | ib;
                outIndex += height;
			}
		}
	}

	public void setHRadius(int hRadius) {
		this.hRadius = hRadius;
	}
	
	public void setThreshold(int th) {
		this.threshold = th;
	}
	
    public void setEuclid(boolean apply) {
    	this.euclid = apply;
    }

}
```











