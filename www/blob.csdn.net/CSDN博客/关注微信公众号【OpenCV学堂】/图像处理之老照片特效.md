# 图像处理之老照片特效 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2013年06月21日 08:43:45[gloomyfish](https://me.csdn.net/jia20003)阅读数：7216
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









PS中有一种滤镜可以让图像看上去好像历经岁月，微微泛黄

英文中这种图像特效被称为Sepia Tone Effect 直译过来的意思

就是黄褐色特效。它的基本处理算法如下：

1. 首先对图像重新计算RGB值，计算公式如下：



```java
int fr= (int)(((double)tr * 0.393) + ((double)tg * 0.769) + ((double)tb * 0.189));
int fg = (int)(((double)tr * 0.349) + ((double)tg * 0.686) + ((double)tb * 0.168)); 
int fb= (int)(((double)tr * 0.272) + ((double)tg * 0.534) + ((double)tb * 0.131));
```
2. 对图像计算出来的新的RGB值根据随机权重与旧值混合。
计算随机权重的代码如下：



```java
private double noise() {
		return Math.random()*0.5 + 0.5;
	}
```
混合颜色的代码如下：


```java
private double colorBlend(double scale, double dest, double src) {
    return (scale * dest + (1.0 - scale) * src);
}
```
效果如下：
![](https://img-blog.csdn.net/20130621084247281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


滤镜完全源代码：



```java
package com.gloomyfish.filter.study;

import java.awt.image.BufferedImage;

public class SepiaToneFilter extends AbstractBufferedImageOp {

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
		int width = src.getWidth();
        int height = src.getHeight();

        if ( dest == null )
        	dest = createCompatibleDestImage( src, null );

        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        getRGB( src, 0, 0, width, height, inPixels );
        int index = 0;
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;

//int fr= (int)(((double)tr * 0.393) + ((double)tg * 0.769) + ((double)tb * 0.189));
//int fg = (int)(((double)tr * 0.349) + ((double)tg * 0.686) + ((double)tb * 0.168)); 
//int fb= (int)(((double)tr * 0.272) + ((double)tg * 0.534) + ((double)tb * 0.131));
                
                int fr = (int)colorBlend(noise(), (tr * 0.393) + (tg * 0.769) + (tb * 0.189), tr);
                int fg = (int)colorBlend(noise(), (tr * 0.349) + (tg * 0.686) + (tb * 0.168), tg);
                int fb = (int)colorBlend(noise(), (tr * 0.272) + (tg * 0.534) + (tb * 0.131), tb);
                
                outPixels[index] = (ta << 24) | (clamp(fr) << 16) | (clamp(fg) << 8) | clamp(fb);
                
        	}
        }
        setRGB( dest, 0, 0, width, height, outPixels );
        return dest;
	}
	
	private double noise() {
		return Math.random()*0.5 + 0.5;
	}
	
	private double colorBlend(double scale, double dest, double src) {
	    return (scale * dest + (1.0 - scale) * src);
	}
	
	public static int clamp(int c)
	{
		return c > 255 ? 255 :( (c < 0) ? 0: c);
	}
	
	public String toString()
	{
		return "Sepia Tone Effect - Effect from Photoshop App";
	}

}
```




