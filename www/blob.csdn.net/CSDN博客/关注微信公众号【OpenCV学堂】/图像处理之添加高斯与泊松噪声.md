# 图像处理之添加高斯与泊松噪声 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2012年12月04日 23:16:06[gloomyfish](https://me.csdn.net/jia20003)阅读数：18606








数学基础：

什么是泊松噪声，就是噪声分布符合泊松分布模型。泊松分布(Poisson Di)的公

式如下：

![](https://img-my.csdn.net/uploads/201212/04/1354634287_1117.png)




关于泊松分布的详细解释看这里：[http://zh.wikipedia.org/wiki/泊松分佈](http://zh.wikipedia.org/wiki/%E6%B3%8A%E6%9D%BE%E5%88%86%E4%BD%88)

关于高斯分布与高斯噪声看这里：

[http://blog.csdn.net/jia20003/article/details/7181463](http://blog.csdn.net/jia20003/article/details/7181463)

** 二:程序实现**

以前在图像加噪博文中现实的加高斯噪声，比较复杂。是自己完全实现了高斯随

机数的产生，这里主要是利用JAVA的随机数API提供的nextGaussion()方法来得

到高斯随机数。泊松噪声为了简化计算，Google到一位神人完成的C++代码于是

我翻译成Java的。

三：程序效果

![](https://img-my.csdn.net/uploads/201212/04/1354634378_7591.png)


滤镜源代码：



```java
package com.gloomyfish.filter.study;

import java.awt.image.BufferedImage;
import java.util.Random;

public class NoiseAdditionFilter extends AbstractBufferedImageOp {
	public final static double MEAN_FACTOR = 2.0;
	public final static int POISSON_NOISE_TYPE = 2;
	public final static int GAUSSION_NOISE_TYPE = 1;
	private double _mNoiseFactor = 25;
	private int _mNoiseType = POISSON_NOISE_TYPE;
	
	public NoiseAdditionFilter() {
		System.out.println("Adding Poisson/Gaussion Noise");
	}
	
	public void setNoise(double power) {
		this._mNoiseFactor = power;
	}
	
	public void setNoiseType(int type) {
		this._mNoiseType = type;
	}
	
	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
		int width = src.getWidth();
        int height = src.getHeight();
        Random random = new Random();
        if ( dest == null )
            dest = createCompatibleDestImage( src, null );

        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        getRGB( src, 0, 0, width, height, inPixels );
        int index = 0;
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;
                if(_mNoiseType == POISSON_NOISE_TYPE) {
	                tr = clamp(addPNoise(tr, random));
	                tg = clamp(addPNoise(tg, random));
	                tb = clamp(addPNoise(tb, random));
                } else if(_mNoiseType == GAUSSION_NOISE_TYPE) {
	                tr = clamp(addGNoise(tr, random));
	                tg = clamp(addGNoise(tg, random));
	                tb = clamp(addGNoise(tb, random));
                }
                outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        	}
        }

        setRGB( dest, 0, 0, width, height, outPixels );
        return dest;
	}
	
	private int addGNoise(int tr, Random random) {
		int v, ran;
		boolean inRange = false;
		do {
			ran = (int)Math.round(random.nextGaussian()*_mNoiseFactor);
			v = tr + ran;
			// check whether it is valid single channel value
			inRange = (v>=0 && v<=255); 
			if (inRange) tr = v;
		} while (!inRange);
		return tr; 
	}

	public static int clamp(int p) {
		return p > 255 ? 255 : (p < 0 ? 0 : p);
	}
	
	private int addPNoise(int pixel, Random random) {
		// init:
		double L = Math.exp(-_mNoiseFactor * MEAN_FACTOR);
		int k = 0;
		double p = 1;
		do {
			k++;
			// Generate uniform random number u in [0,1] and let p ← p × u.
			p *= random.nextDouble();
		} while (p >= L);
		double retValue = Math.max((pixel + (k - 1) / MEAN_FACTOR - _mNoiseFactor), 0);
		return (int)retValue;
	}

}
```
**转载文章请注明**




