# 图像处理之三角法图像二值化 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2016年12月31日 10:20:46[gloomyfish](https://me.csdn.net/jia20003)阅读数：3570
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









# 图像处理之三角法图像二值化

三角法求阈值最早见于Zack的论文《Automatic measurement of sister chromatid exchange frequency》主要是用于染色体的研究，该方法是使用直方图数据，基于纯几何方法来寻找最佳阈值，它的成立条件是假设直方图最大波峰在靠近最亮的一侧，然后通过三角形求得最大直线距离，根据最大直线距离对应的直方图灰度等级即为分割阈值，图示如下： 
![这里写图片描述](https://img-blog.csdn.net/20161231101049503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**对上图的详细解释：**

在直方图上从最高峰处bmx到最暗对应直方图bmin(p=0)%构造一条直线，从bmin处开始计算每个对应的直方图b到直线的垂直距离，知道bmax为止，其中最大距离对应的直方图位置即为图像二值化对应的阈值T。
**扩展情况：**
有时候最大波峰对应位置不在直方图最亮一侧，而在暗的一侧，这样就需要翻转直方图，翻转之后求得值，用255减去即得到为阈值T。扩展情况的直方图表示如下： 
![这里写图片描述](https://img-blog.csdn.net/20161231101218145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
二：算法步骤 

1. 图像转灰度 

2. 计算图像灰度直方图 

3. 寻找直方图中两侧边界 

4. 寻找直方图最大值 

5. 检测是否最大波峰在亮的一侧，否则翻转 

6. 计算阈值得到阈值T，如果翻转则255-T
三：代码实现

```
package com.gloomyfish.filter.study;

import java.awt.image.BufferedImage;

public class TriangleBinaryFilter extends AbstractBufferedImageOp{

    public TriangleBinaryFilter() {
        System.out.println("triangle binary filter");
    }

    @Override
    public BufferedImage filter(BufferedImage src, BufferedImage dest) {
        int width = src.getWidth();
        int height = src.getHeight();

        if ( dest == null )
            dest = createCompatibleDestImage( src, null );
        // 图像灰度化
        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        getRGB( src, 0, 0, width, height, inPixels );
        int index = 0;
        for(int row=0; row<height; row++) {
            int ta = 0, tr = 0, tg = 0, tb = 0;
            for(int col=0; col<width; col++) {
                index = row * width + col;
                ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;
                int gray= (int)(0.299 *tr + 0.587*tg + 0.114*tb);
                inPixels[index]  = (ta << 24) | (gray << 16) | (gray << 8) | gray;
            }
        }
        // 获取直方图
        int[] histogram = new int[256];
        for(int row=0; row<height; row++) {
            int tr = 0;
            for(int col=0; col<width; col++) {
                index = row * width + col;
                tr = (inPixels[index] >> 16) & 0xff;
                histogram[tr]++;
            }
        }


        int left_bound = 0, right_bound = 0, max_ind = 0, max = 0;
        int temp;
        boolean isflipped = false;
        int i=0, j=0;
        int N = 256;

        // 找到最左边零的位置
        for( i = 0; i < N; i++ )
        {
            if( histogram[i] > 0 )
            {
                left_bound = i;
                break;
            }
        }
     // 位置再移动一个步长，即为最左侧零位置 
        if( left_bound > 0 )
            left_bound--;

        // 找到最右边零点位置
        for( i = N-1; i > 0; i-- )
        {
            if( histogram[i] > 0 )
            {
                right_bound = i;
                break;
            }
        }
        // 位置再移动一个步长，即为最右侧零位置 
        if( right_bound < N-1 )
            right_bound++;

        // 在直方图上寻找最亮的点Hmax
        for( i = 0; i < N; i++ )
        {
            if( histogram[i] > max)
            {
                max = histogram[i];
                max_ind = i;
            }
        }

        // 如果最大值落在靠左侧这样就无法满足三角法求阈值，所以要检测是否最大值是否靠近左侧
        // 如果靠近左侧则通过翻转到右侧位置。
        if( max_ind-left_bound < right_bound-max_ind)
        {
            isflipped = true;
            i = 0;
            j = N-1;
            while( i < j )
            {
                // 左右交换
                temp = histogram[i]; histogram[i] = histogram[j]; histogram[j] = temp;
                i++; j--;
            }
            left_bound = N-1-right_bound;
            max_ind = N-1-max_ind;
        }

        // 计算求得阈值
        double thresh = left_bound;
        double a, b, dist = 0, tempdist;
        a = max; b = left_bound-max_ind;
        for( i = left_bound+1; i <= max_ind; i++ )
        {
            // 计算距离 - 不需要真正计算
            tempdist = a*i + b*histogram[i];
            if( tempdist > dist)
            {
                dist = tempdist;
                thresh = i;
            }
        }
        thresh--;

        // 对已经得到的阈值T,如果前面已经翻转了，则阈值要用255-T
        if( isflipped )
            thresh = N-1-thresh;

        // 二值化
        System.out.println("final threshold value : " + thresh);
        for(int row=0; row<height; row++) {
            for(int col=0; col<width; col++) {
                index = row * width + col;
                int gray = (inPixels[index] >> 8) & 0xff;
                if(gray > thresh)
                {
                    gray = 255;
                    outPixels[index]  = (0xff << 24) | (gray << 16) | (gray << 8) | gray;
                }
                else
                {
                    gray = 0;
                    outPixels[index]  = (0xff << 24) | (gray << 16) | (gray << 8) | gray;
                }

            }
        }


        // 返回二值图像
        setRGB(dest, 0, 0, width, height, outPixels );
        return dest;
    }

}
```

四：运行结果 
![这里写图片描述](https://img-blog.csdn.net/20161231101634572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
2016年最后一篇，这里祝大家元旦快乐，欢迎在2017继续关注本博客，分享有用实用的图像处理知识本人会一直坚持到永远！ 
[学习图像处理基础入门课程 - 点击这里](http://edu.51cto.com/course/course_id-6335.html)







