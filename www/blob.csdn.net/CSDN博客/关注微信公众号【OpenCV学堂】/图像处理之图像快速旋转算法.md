# 图像处理之图像快速旋转算法 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2012年11月25日 00:22:40[gloomyfish](https://me.csdn.net/jia20003)阅读数：18166
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









**基本思想：**

旋转矩阵在旋转角度较小的情况下可以通过两次错切变化得到旋转效果的图片，在旋

转角度较大的情况下可以通过三次错切得到等价旋转效果图像(较小角度小于15度，较

大角度在90度之内)，对于旋转角度超过90度，首先旋转特殊角度90，180，270，然后

在旋转剩下的角度数。90，180，270是特殊角度，可以通过简单的矩阵变换得到。旋

转矩阵到三次等价错切矩阵等式如下：

![](https://img-my.csdn.net/uploads/201211/25/1353773682_4508.png)




一个更好的分解图如下：

![](https://img-my.csdn.net/uploads/201211/25/1353773710_5309.png)




程序关键代码解释：

错切变换是基本的图像几何变换，首先在X方向进行顺时针的错切变换，然后在Y方向

进行顺时针的错切变换，最后再到X方向进行顺时针错切变换，最终得到旋转角度以后

的图像数据。

X方向的错切变换的代码如下：



```java
/**
	 * 水平方向错切变换
	 * 
	 * @param input - 输入像素数据
	 * @param shear - 错切角度
	 * @param width - 图像像素数据宽度
	 * @param height - 图像像素数据高度
	 * @return
	 */
	public int[] xshear(int[] input, float shear, int width, int height) {
		outw = (int)(Math.abs(shear) * height + width);
		outh = height;
		int[] output = new int[height * outw];
		
		// initialization - 初始化计算变量
		float skew = 0.0f;
		float skewi = 0.0f;
		float skewf = 0.0f;
		int index = 0;
		int outdex = 0;
		float leftred = 0.0f, leftgreen = 0.0f, leftblue = 0.0f;
		float oleftred = 0.0f, oleftgreen = 0.0f, oleftblue = 0.0f;
		int ta = 0, tr=0, tg = 0, tb = 0;
		
		// 执行对每个像素的错切变换
		for(int row=0; row<height; row++) {
			// skew = shear * (height-1-row + 0.5f); big issue!! very difficulty to find it
			skew = shear * (row + 0.5f);
			skewi = (float)Math.floor(skew);
			skewf = skew - skewi;
			for(int col=0; col<width; col++) {
				index = row * width + col;
        		ta = (input[index] >> 24) & 0xff;
                tr = (input[index] >> 16) & 0xff;
                tg = (input[index] >> 8) & 0xff;
                tb = input[index] & 0xff;
                if(tr == tg && tg == tb && tb == 0) {
                	continue;
                }
                // calculate interpolation pixel value
				leftred = (skewf * tr);
				leftgreen = (skewf * tg);
				leftblue = (skewf * tb);
				// calculate the new pixel RGB value
				tr = (int)(tr - leftred + oleftred);
				tg = (int)(tg - leftgreen + oleftgreen);
				tb = (int)(tb - leftblue + oleftblue);
				
				// fix issue, need to check boundary
				// computation the new pixel postion here!!
				outdex = (int)(row * outw + col + skewi);
				output[outdex] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
				
				// ready for next pixel.
				oleftred = leftred;
				oleftgreen = leftgreen;
				oleftblue = leftblue;
			}
		}
		return output;
	}
```



Y方向的错切变换的代码如下：



```java
public int[] yshear(int[] input, float shear, int width, int height)  {
		outh = (int)(shear * width + height);
		outw = width;
		int[] output = new int[outh * outw];
		
		// initialization - 初始化计算变量
		float skew = 0.0f;
		float skewi = 0.0f;
		float skewf = 0.0f;
		int index = 0;
		int outdex = 0;
		float leftred = 0.0f, leftgreen = 0.0f, leftblue = 0.0f;
		float oleftred = 0.0f, oleftgreen = 0.0f, oleftblue = 0.0f;
		int ta = 0, tr=0, tg = 0, tb = 0;
		
		for(int col = 0; col < width; col++) {
			// the trick is here!!, you can control the 
			// anti-clockwise or clockwise
			skew = shear * (width-1-col + 0.5f);
			// skew = shear * (col + 0.5f); 
			skewi = (float)Math.floor(skew);
			skewf = skew - skewi;
			for(int row = 0; row < height; row++) {
				index = row * width + col;
        		ta = (input[index] >> 24) & 0xff;
                tr = (input[index] >> 16) & 0xff;
                tg = (input[index] >> 8) & 0xff;
                tb = input[index] & 0xff;
                
                // calculate interpolation pixel value
				leftred = (skewf * tr);
				leftgreen = (skewf * tg);
				leftblue = (skewf * tb);
				// calculate the new pixel RGB value
				tr = (int)(tr - leftred + oleftred);
				tg = (int)(tg - leftgreen + oleftgreen);
				tb = (int)(tb - leftblue + oleftblue);
				
				// computation the new pixel postion here!!
				// outdex = (int)((height-row + skewi) * outw + col);
				outdex = (int)((row + skewi) * outw + col);
				output[outdex] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
				
				// ready for next pixel.
				oleftred = leftred;
				oleftgreen = leftgreen;
				oleftblue = leftblue;
			}
		}
		return output;
	}
```
原图如下：



![](https://img-my.csdn.net/uploads/201211/07/1352293914_3836.jpg)


第一次X shear与Y shear之后效果如下

![](https://img-my.csdn.net/uploads/201211/25/1353775027_6572.png)


第二次Xshear即图像旋转效果如下：


![](https://img-my.csdn.net/uploads/201211/25/1353774103_7533.png)


其他参数设置与线性插值旋转算法类似，角度，背景参数设置由用户

提供输入完成，关于线性插值旋转参见这里

[http://blog.csdn.net/jia20003/article/details/8159587](http://blog.csdn.net/jia20003/article/details/8159587)


说实话这个算法烦了我好久，今天我终于解脱了，想起一句电视剧台词，你应

该了解真相，真相让你自由好像是《X档案》

**转载请注明出处**



