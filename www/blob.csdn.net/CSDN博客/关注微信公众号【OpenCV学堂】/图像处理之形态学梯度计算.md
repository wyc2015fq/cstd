# 图像处理之形态学梯度计算 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2016年10月23日 18:06:48[gloomyfish](https://me.csdn.net/jia20003)阅读数：6931








**图像处理之形态学梯度计算**

**源代码基于OpenCV实现，原因是太懒了，不想再用Java从头写了！**



**一：概念介绍**

形态学操作膨胀与腐蚀图像形态学中最基本的两个形态学操作、常常被组合起来一起使用实现一些复杂的图像形态学操作，计算图像的形态学梯度是形态学重要操作之一是有膨胀和腐蚀基础操作适当的组合形成。可以计算的梯度常见如下四种：



**基本梯度**

基本梯度是用膨胀后的图像减去腐蚀后的图像得到差值图像，称为梯度图像也是OpenCV中支持的计算形态学梯度的方法，而此方法得到梯度有被称为基本梯度。

**内部梯度**

是用原图像减去腐蚀之后的图像得到差值图像，称为图像的内部梯度

**外部梯度**

图像膨胀之后再减去原来的图像得到的差值图像，称为图像的外部梯度。

**方向梯度**

方向梯度是使用X方向与Y方向的直线作为结构元素之后得到图像梯度，X的结构元素分布膨胀与腐蚀得到图像之后求差值得到称为X方向梯度，用Y方向直线做结构分别膨胀与腐蚀之后得到图像求差值之后称为Y方向梯度。



**二：主要API介绍**

OpenCV中腐蚀与膨胀操作的API分别为：

erode() // 腐蚀 第一个参数是输入图像、第二个参数是输出图像、第三个参数结构元素、第四个表示锚点位置,默认情况下Point(-1, -1)，膨胀跟腐蚀的输入参数一样。

dilate() // 膨胀

使用的结构元素通过如下的API创建：

getStructuringElement()创建结构元素，第一个参数是结构元素形状、第二个参数大小一定要是奇数。

第三个参数表示中心位置，默认Point(-1, -1)

两张图像相减的API如下：

subtract()第一个与第二个参数为输入图像Src1和Src2第三个参数是得到的计算后图像dst

计算公式是Dst = saturate(Src1 - Src2)

 三：运行效果

![](https://img-blog.csdn.net/20161023180149501)


XY方向

![](https://img-blog.csdn.net/20161023180250282)


演示代码如下：



```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <math.h>

using namespace std;
using namespace cv;

int main(int argc, char** argv) {
	Mat src, gray_src, dst;
	src = imread("D:/vcprojects/images/carlines.png");
	if (!src.data) {
		printf("could not load image...\n");
		return -1;
	}
	char input_title[] = "input image";
	char output_title[] = "Basic Gradient Image";
	namedWindow(input_title, CV_WINDOW_AUTOSIZE);
	namedWindow(output_title, CV_WINDOW_AUTOSIZE);
	imshow(input_title, src);

	cvtColor(src, gray_src, CV_BGR2GRAY);

	// calculate basic gradient same as morphologyEx() in opencv
	Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5), Point(-1, -1));
	Mat erode_ouput, dilate_output;
	erode(gray_src, erode_ouput, kernel, Point(-1, -1));
	dilate(gray_src, dilate_output, kernel, Point(-1, -1));

	// calculate basic gradient
	subtract(dilate_output, erode_ouput, dst, Mat());
	imshow(output_title, dst);

	// calculate internal gradient
	Mat internalGradientImg;
	subtract(gray_src, erode_ouput, internalGradientImg, Mat());
	imshow("Internal Gradient", internalGradientImg);

	// calculate external gradient
	Mat externalGradientImg;
	subtract(dilate_output, gray_src, externalGradientImg, Mat());
	imshow("External Gradient", externalGradientImg);
	
	// directional gradient
	Mat hse = getStructuringElement(MORPH_RECT, Size(src.cols/16, 1), Point(-1, -1));
	Mat vse = getStructuringElement(MORPH_RECT, Size(1, src.rows/16), Point(-1, -1));
	Mat erode_direct, dilate_direct;
	Mat binImg, xdirectImg, ydirectImg;

	// 二值化方法
	threshold(gray_src, binImg, 0, 255, CV_THRESH_OTSU | CV_THRESH_BINARY);

	// X direction
	erode(binImg, erode_direct, hse, Point(-1, -1));
	dilate(binImg, dilate_direct, hse, Point(-1, -1));
	subtract(dilate_direct, erode_direct, xdirectImg, Mat());
	imshow("X directional gradient", xdirectImg);

	// Y direction
	erode(binImg, erode_direct, vse, Point(-1, -1));
	dilate(binImg, dilate_direct, vse, Point(-1, -1));
	subtract(dilate_direct, erode_direct, ydirectImg, Mat());
	imshow("Y directional gradient", ydirectImg);

	waitKey(0);
	return 0;
}
```
**欢迎加入图像处理学习群，里面高手林立！**


