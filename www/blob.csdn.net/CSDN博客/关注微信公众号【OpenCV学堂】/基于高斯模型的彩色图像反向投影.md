# 基于高斯模型的彩色图像反向投影 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2017年06月14日 21:08:39[gloomyfish](https://me.csdn.net/jia20003)阅读数：3718








### **一：介绍**

图像反向投影的最终目的是获取ROI然后实现对ROI区域的标注、识别、测量等图像处理与分析，是计算机视觉与人工智能的常见方法之一。图像反向投影通常是彩色图像投影效果会比灰度图像效果要好，原因在于彩色图像带有更多对象细节信息，在反向投影的时候更加容易判断、而转为灰度图像会导致这些细节信息丢失、从而导致分割失败。最常见的是基于图像直方图特征的反向投影。我们这里介绍一种跟直方图反向投影不一样的彩色图像反向投影方法，通过基于高斯的概率分布公式（PDF）估算，反向投影得到对象区域，该方法也可以看做最简单的图像分割方法。缺点是对象颜色光照改变和尺度改变不具备不变性特征。所以需要在光照度稳定情况下成像采集图像数据。在这种情况下使用的高斯概率密度公式为： 
![这里写图片描述](https://img-blog.csdn.net/20170614205901822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


1.输入模型M，对M的每个像素点（R,G,B）计算I=R+G+B 

r=R/I, g=G/I, b=B/I 

2. 根据得到权重比例值，计算得到对应的均值 与标准方差  

3. 对输入图像的每个像素点计算根据高斯公式计算P(r)与P(g)的乘积 

4. 归一化之后输出结果，即为最终基于高斯PDF的反向投影图像
### **二：代码实现**

代码实现是基于OpenCV 3.2完成的C++代码，首先加载模型对象，计算出均值与标准方差以后，把均值与标准方差作为参数代入上述高斯概率分布公式，对每个像素点的每个通道值求取可能性值，然后求各个通道的可能性乘积作为该点的PDF，得到图像就是反向投影图像，以此为模板，可以得到分割图像。实现图像分割。完整的代码显示如下：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <math.h>

using namespace cv;
using namespace std;

int main(int argc, char** argv) {
    Mat src = imread("D:/gloomyfish/gc_test.png");
    Mat model = imread("D:/gloomyfish/gm.png");
    if (src.empty() || model.empty()) {
        printf("could not load image...\n");
        return -1;
    }
    imshow("input image", src);

    Mat R = Mat::zeros(model.size(), CV_32FC1);
    Mat G = Mat::zeros(model.size(), CV_32FC1);
    int r = 0, g = 0, b = 0;
    float sum = 0;
    for (int row = 0; row < model.rows; row++) {
        uchar* current = model.ptr<uchar>(row);
        for (int col = 0; col < model.cols; col++) {
            b = *current++;
            g = *current++;
            r = *current++;
            sum = b + g + r;
            R.at<float>(row, col) = r / sum;
            G.at<float>(row, col) = g / sum;
        }
    }

    Mat mean, stddev;
    double mr, devr;
    double mg, devg;
    meanStdDev(R, mean, stddev);
    mr = mean.at<double>(0, 0);
    devr = mean.at<double>(0, 0);

    meanStdDev(G, mean, stddev);
    mg = mean.at<double>(0, 0);
    devg = mean.at<double>(0, 0);

    int width = src.cols;
    int height = src.rows;

    float pr = 0, pg = 0;
    Mat result = Mat::zeros(src.size(), CV_32FC1);
    for (int row = 0; row < height; row++) {
        uchar* currentRow = src.ptr<uchar>(row);
        for (int col = 0; col < width; col++) {
            b = *currentRow++;
            g = *currentRow++;
            r = *currentRow++;
            sum = b + g + r;
            float red = r / sum;
            float green = g / sum;
            pr = (1 / (devr*sqrt(2 * CV_PI)))*exp(-(pow((red - mr), 2)) / (2 * pow(devr, 2)));
            pg = (1 / (devg*sqrt(2 * CV_PI)))*exp(-(pow((green - mg),2)) / (2 * pow(devg, 2)));
            sum = pr*pg;
            result.at<float>(row, col) = sum;
        }
    }

    Mat img(src.size(), CV_8UC1);
    normalize(result, result, 0, 255, NORM_MINMAX);
    result.convertTo(img, CV_8U);
    Mat segmentation;
    src.copyTo(segmentation, img);

    imshow("backprojection demo", img);
    imshow("segmentation demo", segmentation);

    waitKey(0);
    return 0;
}
```

**三：运行效果**
模型图 
![这里写图片描述](https://img-blog.csdn.net/20170614210333305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
原图 
![这里写图片描述](https://img-blog.csdn.net/20170614210349076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
反向投影图像 
![这里写图片描述](https://img-blog.csdn.net/20170614210436389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
最终得到分割出来的鲜花对象图像 
![这里写图片描述](https://img-blog.csdn.net/20170614210528542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
### **欢迎继续关注本博客，只分享干货，不止于代码！**





