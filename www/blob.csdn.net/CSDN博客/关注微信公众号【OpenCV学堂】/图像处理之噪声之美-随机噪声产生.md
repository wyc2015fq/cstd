# 图像处理之噪声之美 - 随机噪声产生 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2011年11月12日 20:35:47[gloomyfish](https://me.csdn.net/jia20003)阅读数：6591
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









**数学原理：**

首先看两张图片，大小均为256 * 256个像素, 第一张是纯蓝色

图一：![](http://hi.csdn.net/attachment/201111/12/0_1321101127DIER.gif)

第二张是加有随机噪声的蓝色

 图二：![](http://hi.csdn.net/attachment/201111/12/0_1321101136iu0X.gif)

产生随机噪声的算法简单的不能再简单了

假设RGB的R与G颜色分量均为零, 则 Blue = 255 * Math.Random() 随机数的取值范围在

[0, 1]之间, 程序的核心代码如下：

**for**(**int** row=0; row<256; row++) {

**for**(**int** col=0; col<256; col++) {

b = (**int**)(255.0d * Math.*random*());

                                     rgbData[index]= ((clamp(a) & 0xff) << 24) |

                                                                           ((clamp(r)& 0xff) << 16)  |

                                                                           ((clamp(g)& 0xff) << 8)   |

                                                                           ((clamp(b)& 0xff));

                                     index++;

                            }

}



上面显然不是我想要的结果，我想要的是下面两种：

 图三：

![](http://hi.csdn.net/attachment/201111/12/0_13211011488Rr7.gif)


图四：

![](http://hi.csdn.net/attachment/201111/12/0_132110115495pb.gif)


对的，只要我们对上面的算法稍加改进，就可以实现这样漂亮的噪声效果

实现第二张图效果的算法缺点在于，它每次都产生一个新的随机数,假设[0,1] = 255，接着第

二点随机可以能为[0, 2] = 0 第三个点可能随机值为[0, 3] = 125, 毫无规律可言，而我希望是

假设第一点随机[0, 1] = 255则间隔N个点以后再产生下个随机颜色值[0,N+1] =125, 在下一

个点则为[0, 2N +1] = 209…..于是问题产生了， 我们怎么计算[1, N]的之间的每个像素点的值

哇，这个问题不正是关于图像放缩的插值问题嘛，一个最简单的选择是双线性插值算法，

算法解释参考这里：[http://blog.csdn.net/jia20003/article/details/6915185](http://blog.csdn.net/jia20003/article/details/6915185)

有了算法选择，下面的问题就是我们怎么计算点值的问题，面临两个选择，一个值照搬双线

性插值中的计算方法，但是有点不自然，我们想要的是噪声，显然线性的计算结果不是最好

的最好的选择，cos(x)如何，在[0, PI]内是递减，在[PI,2PI]内是递增，而且值的范围在[-1, 1]

之间，而我们的随机数值要在[0, 1]之间于是综合上述考虑我们有cos(PI + (x-x0/x1-x0)* PI) + 1, 现

在计算出来的值是[0, 1]区间之内 根据插值公式最终有：

y= (y1-y0) * cos(PI + (x-x0/x1-x0) * PI) + 1 + y0



其中[x, y]代表要计算的点，周围四个采样点为：[x-N, y-N], [x+N,y-N], [x-N, y+N], [x+N, y+N ]

运用双线性插值原理即可计算出[1, N]个每个像素点的值。




**关键代码实现及解释：**



获取四个采样点，及其值，然后使用类似双线性算法计算出[x,y]的随机数值进而计算出像素值

的程序代码如下：



```java
// bi-line interpolation algorithm here!!!
    Double GetColor(int x, int y, int M, int colorType)
    {
       int x0 = x - (x % M);
       int x1 = x0 + M;
       int y0 = y - (y % M);
       int y1 = y0 + M;
 
        Double x0y0 = Noise(x0,y0, colorType);
        Double x1y0 = Noise(x1,y0, colorType);
        Double x0y1 = Noise(x0,y1, colorType);
        Double x1y1 = Noise(x1,y1, colorType);
 
        Double xx0 =Interpolate(x0, x0y0, x1, x1y0, x);
        Double xx1 = Interpolate(x0,x0y1, x1, x1y1, x);
 
        Double N =Interpolate(y0, xx0, y1, xx1, y);
        return N;
    }
```


根据两个点计算插入值的公式代码如下：



```java
return (1.0 + Math.cos(Math.PI +  (Math.PI / (x1-x0)) * (x-x0))) / 2.0 
* (xx1-xx0) + xx0;
```


对一张图像实现随机噪声值得出像素值计算的代码如下：

```java
for(int row=0; row<256; row++) {
			for(int col=0; col<256; col++) {
				// set random color value for each pixel
				r = (int)(255.0d * GetColor(row, col, intervalPixels, 1));
				g = (int)(255.0d * GetColor(row, col, intervalPixels, 2));
				b = (int)(255.0d * GetColor(row, col, intervalPixels, 4));
				
				rgbData[index] = ((clamp(a) & 0xff) << 24) |
								((clamp(r) & 0xff) << 16)  |
								((clamp(g) & 0xff) << 8)   |
								((clamp(b) & 0xff));
				index++;
			}
		}
```
**完全源代码如下：**


```java
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.util.Random;

import javax.swing.JComponent;
import javax.swing.JFrame;

public class RandomNoiseImage extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2236160343614397287L;
	private BufferedImage image = null;
	private double[] blue_random;
	private double[] red_random;
	private double[] green_random;
	private int intervalPixels = 40; // default
	
	public RandomNoiseImage() {
		super();
		this.setOpaque(false);
	}
	
	protected void paintComponent(Graphics g) {
		Graphics2D g2 = (Graphics2D)g;
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		g2.drawImage(getImage(), 5, 5, image.getWidth(), image.getHeight(), null);
	}
	
	private BufferedImage getImage() {
		if(image == null) {
			image = new BufferedImage(256, 256, BufferedImage.TYPE_INT_ARGB);
			int[] rgbData = new int[256*256];
			generateNoiseImage(rgbData);
			setRGB(image, 0, 0, 256, 256, rgbData);
		}
		return image;
	}
	
	private void generateNoiseImage(int[] rgbData) {
		int index = 0;
		int a = 255;
		int r = 0;
		int g = 0;
		int b = 0;
		int sum = 256 * 256;
		blue_random = new double[sum];
		red_random = new double[sum];
		green_random = new double[sum];
		Random random = new Random();
		for(int i=0; i< sum; i++) {
			blue_random[i] = random.nextDouble();
			red_random[i] = random.nextDouble();
			green_random[i] = random.nextDouble();
		}
		
		
		for(int row=0; row<256; row++) {
			for(int col=0; col<256; col++) {
				// set random color value for each pixel
				r = (int)(255.0d * GetColor(row, col, intervalPixels, 1));
				g = (int)(255.0d * GetColor(row, col, intervalPixels, 2));
				b = (int)(255.0d * GetColor(row, col, intervalPixels, 4));
				
				rgbData[index] = ((clamp(a) & 0xff) << 24) |
								((clamp(r) & 0xff) << 16)  |
								((clamp(g) & 0xff) << 8)   |
								((clamp(b) & 0xff));
				index++;
			}
		}
		
	}
	
	private int clamp(int rgb) {
		if(rgb > 255)
			return 255;
		if(rgb < 0)
			return 0;
		return rgb;
	}
	
	// bi-line interpolation algorithm here!!!
	Double GetColor(int x, int y, int M, int colorType)
	{
		int x0 = x - (x % M);
		int x1 = x0 + M;
		int y0 = y - (y % M);
		int y1 = y0 + M;

	    Double x0y0 = Noise(x0, y0, colorType);
	    Double x1y0 = Noise(x1, y0, colorType);
	    Double x0y1 = Noise(x0, y1, colorType);
	    Double x1y1 = Noise(x1, y1, colorType);

	    Double xx0 = Interpolate(x0, x0y0, x1, x1y0, x);
	    Double xx1 = Interpolate(x0, x0y1, x1, x1y1, x);

	    Double N = Interpolate(y0, xx0, y1, xx1, y);
	    return N;
	}

	// algorithm selection here !!!
	private Double Interpolate(double x0, double xx0, double x1, double xx1, double x) {
		
		return (1.0 + Math.cos(Math.PI + 
			      (Math.PI / (x1-x0)) * (x-x0))) / 2.0 * (xx1-xx0) + xx0;
	}

	Double Noise(int x, int y, int colorType)
	{
		if(colorType == 1) {
			if (x < 256 && y < 256)
		        return red_random[y * 256 + x];
		    else
		        return 0.0;
		} else if(colorType == 2) {
			if (x < 256 && y < 256)
		        return green_random[y * 256 + x];
		    else
		        return 0.0;
		} else {
			if (x < 256 && y < 256)
		        return blue_random[y * 256 + x];
		    else
		        return 0.0;
		}
	}

	public void setRGB( BufferedImage image, int x, int y, int width, int height, int[] pixels ) {
		int type = image.getType();
		if ( type == BufferedImage.TYPE_INT_ARGB || type == BufferedImage.TYPE_INT_RGB )
			image.getRaster().setDataElements( x, y, width, height, pixels );
		else
			image.setRGB( x, y, width, height, pixels, 0, width );
    }
	
	public static void main(String[] args) {
		JFrame frame = new JFrame("Noise Art Panel");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(new BorderLayout());
		
		// Display the window.
		frame.getContentPane().add(new RandomNoiseImage(), BorderLayout.CENTER);
		frame.setPreferredSize(new Dimension(280,305));
		frame.pack();
		frame.setVisible(true);
	}
}
```







