# 图像处理之开操作详解 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2012年07月01日 19:11:14[gloomyfish](https://me.csdn.net/jia20003)阅读数：11171
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









**开操作概述：**

图像处理中的开闭运算是两个非常重要的数学形态学操作，它们同时都继承自基本的腐蚀与

膨胀操作，这些操作一般都会应用在二值图像的分析与处理上。开操作有点像腐蚀操作，主

要是会remove前景像素边缘，但是不会像腐蚀操作remove那么多边缘像素。开操作主要

是用来保留某种结构操作，remove其他不符合结构元素的前景区域像素。



**开操作原理：**

一个开操作是一个腐蚀操作再接着一个膨胀操作使用相同的结构元素。开操作需要两个输入

数据一个是要开操作的像素数据，一个是开操作的结构元素，根据开操作的要求不同，结构

元素可以是圆形，正方形，矩形等。关于腐蚀与膨胀操作见博客文章：

二值图像膨胀操作 - [http://blog.csdn.net/jia20003/article/details/7574214](http://blog.csdn.net/jia20003/article/details/7574214)

二值图像腐蚀操作 - [http://blog.csdn.net/jia20003/article/details/7582666](http://blog.csdn.net/jia20003/article/details/7582666)




程序效果：- 原图

![](https://img-my.csdn.net/uploads/201207/01/1341141127_8419.png)


通过开操作，我们可以除去干扰线(竖线与斜线)，通过过开操作也可以只保留竖线

唯一的秘诀就在于输入开操作的结构元素的形状决定，效果如下图：

![](https://img-my.csdn.net/uploads/201207/01/1341141246_3547.png)


**开操作源代码：**



```java
package com.gloomyfish.morphology;

import java.awt.Color;
import java.awt.image.BufferedImage;

public class OpeningFilter extends BinaryFilter {
	private int[][] structure_element;
	private Color bgColor;
	private Color fgColor;
	
	public OpeningFilter() {
		structure_element = new int[3][10];
		// structure_element = new int[20][1];
		bgColor = Color.BLACK;
		fgColor = Color.WHITE;
	}
	
	public void setBackGroundColor(Color c) {
		this.bgColor = c;
	}
	
	public void setForeGroundColor(Color c) {
		this.fgColor = c;
	}
	
	public void setElement(int[][] element) {
		this.structure_element = element;
	}

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
		int width = src.getWidth();
        int height = src.getHeight();

        if ( dest == null )
        	dest = createCompatibleDestImage( src, null );

        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        src = super.filter(src, null);
        getRGB( src, 0, 0, width, height, inPixels );
        int index = 0;
        int subrow = structure_element.length/2;
        int subcol = structure_element[0].length/2;
        int rowoffset = 0, coloffset = 0;
        int index2 = 0;
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;
                int ta2 = 0, tr2 = 0, tg2= 0, tb2 = 0;
                boolean isfound = false;
                for(int i=-subrow; i<=subrow; i++) {
                	for(int j=-subcol; j<=subcol; j++) {
                		rowoffset = row + i;
                		coloffset = col + j;
                		if(rowoffset >=0 && rowoffset < height) {
                			rowoffset = row + i;
                		} else {
                			rowoffset = 0;
                		}
                		
                		if(coloffset >= 0 && coloffset < width) {
                			coloffset = col + j;
                		} else {
                			coloffset = 0;
                		}
                		index2 = rowoffset * width + coloffset;
                		ta2 = (inPixels[index2] >> 24) & 0xff;
                        tr2 = (inPixels[index2] >> 16) & 0xff;
                        tg2 = (inPixels[index2] >> 8) & 0xff;
                        tb2 = inPixels[index2] & 0xff;
                        if(tr2 == bgColor.getRed() && tg2 == bgColor.getGreen()) {
                        	isfound = true;
                        	break;
                        }
                	}
                	if(isfound) break;
                }
                rowoffset = 0;
                coloffset = 0;
                if(isfound) {
                	tr = bgColor.getRed();
                	tg = bgColor.getGreen();
                	tb = bgColor.getBlue();
                	outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
                } else {
                	outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
                }
                
        	}
        }
        
        // copy the Erosion result pixels to input pixels data 
        // and ready to Dilation operation
        System.arraycopy(outPixels, 0, inPixels, 0, width*height);
        
        // start to dilate the pixels data...
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;
                int ta2 = 0, tr2 = 0, tg2= 0, tb2 = 0;
                boolean isfound = false;
                for(int i=-subrow; i<=subrow; i++) {
                	for(int j=-subcol; j<=subcol; j++) {
                		rowoffset = row + i;
                		coloffset = col + j;
                		if(rowoffset >=0 && rowoffset < height) {
                			rowoffset = row + i;
                		} else {
                			rowoffset = 0;
                		}
                		
                		if(coloffset >= 0 && coloffset < width) {
                			coloffset = col + j;
                		} else {
                			coloffset = 0;
                		}
                		index2 = rowoffset * width + coloffset;
                		ta2 = (inPixels[index2] >> 24) & 0xff;
                        tr2 = (inPixels[index2] >> 16) & 0xff;
                        tg2 = (inPixels[index2] >> 8) & 0xff;
                        tb2 = inPixels[index2] & 0xff;
                        if(tr2 == fgColor.getRed() && tg2 == fgColor.getGreen()) {
                        	isfound = true;
                        	break;
                        }
                	}
                	if(isfound) break;
                }
                rowoffset = 0;
                coloffset = 0;
                if(isfound) {
                	tr = fgColor.getRed();
                	tg = fgColor.getGreen();
                	tb = fgColor.getBlue();
                	outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
                } else {
                	outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
                }
                
        	}
        }
        
        setRGB( dest, 0, 0, width, height, outPixels );
        return dest;
	}
}
```
**转载请注明出处**





