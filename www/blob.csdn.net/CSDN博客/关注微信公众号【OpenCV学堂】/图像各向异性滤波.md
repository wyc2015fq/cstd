# 图像各向异性滤波 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2017年11月01日 16:19:14[gloomyfish](https://me.csdn.net/jia20003)阅读数：4569








## 图像各向异性滤波

**各向异性概念**

各向异性（英文名称：anisotropy）是指材料在各方向的力学和物理性能呈现差异的特性。晶体的各向异性即沿晶格的不同方向，原子排列的周期性和疏密程度不尽相同，由此导致晶体在不同方向的物理化学特性也不同，这就是晶体的各向异性。亦称“非均质性”。物体的全部或部分物理、化学等性质随方向的不同而各自表现出一定的差异的特性。即在不同的方向所测得的性能数值不同。对图像来说各向异性就是在每个像素点周围四个方向上梯度变化都不一样，滤波的时候我们要考虑图像的各向异性对图像的影响，而各向同性显然是说各个方向的值都一致，常见的图像均值或者高斯均值滤波可以看成是各向同性滤波。

**各向异性滤波**

是将图像看成物理学的力场或者热流场，图像像素总是向跟他的值相异不是很大的地方流动或者运动，这样那些差异大的地方(边缘)就得以保留，所以本质上各向异性滤波是图像边缘保留滤波器(EPF)。它在各个方向的扩散可以表示如下如下公式： 
![这里写图片描述](https://img-blog.csdn.net/20171101160945965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](https://img-blog.csdn.net/20171101161013559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**代码实现**

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;
float k = 15;
float lambda = 0.25;
int N = 20;

void anisotropy_demo(Mat &image, Mat &result);
int main(int argc, char** argv) {
    Mat src = imread("D:/vcprojects/images/example.png");
    if (src.empty()) {
        printf("could not load image...\n");
        return -1;
    }
    namedWindow("input image", CV_WINDOW_AUTOSIZE);
    imshow("input image", src);
    vector<Mat> mv;
    vector<Mat> results;
    split(src, mv);
    for (int n = 0; n < mv.size(); n++) {
        Mat m = Mat::zeros(src.size(), CV_32FC1);
        mv[n].convertTo(m, CV_32FC1);
        results.push_back(m);
    }

    int w = src.cols;
    int h = src.rows;
    Mat copy = Mat::zeros(src.size(), CV_32FC1);
    for (int i = 0; i < N; i++) {
        anisotropy_demo(results[0], copy);
        copy.copyTo(results[0]);

        anisotropy_demo(results[1], copy);
        copy.copyTo(results[1]);

        anisotropy_demo(results[2], copy);
        copy.copyTo(results[2]);

    }
    Mat output;
    normalize(results[0], results[0], 0, 255, NORM_MINMAX);
    normalize(results[1], results[1], 0, 255, NORM_MINMAX);
    normalize(results[2], results[2], 0, 255, NORM_MINMAX);

    results[0].convertTo(mv[0], CV_8UC1);
    results[1].convertTo(mv[1], CV_8UC1);
    results[2].convertTo(mv[2], CV_8UC1);

    Mat dst;
    merge(mv, dst);

    imshow("result", dst);
    imwrite("D:/result.png", dst);
    waitKey(0);
    return 0;
}

void anisotropy_demo(Mat &image, Mat &result) {
    int width = image.cols;
    int height = image.rows;

    // 四邻域梯度
    float n = 0, s = 0, e = 0, w = 0; 
    // 四邻域系数
    float nc = 0, sc = 0, ec = 0, wc = 0; 
    float k2 = k*k;
    for (int row = 1; row < height -1; row++) {
        for (int col = 1; col < width -1; col++) {
            // gradient
            n = image.at<float>(row - 1, col) - image.at<float>(row, col);
            s = image.at<float>(row + 1, col) - image.at<float>(row, col);
            e = image.at<float>(row, col - 1) - image.at<float>(row, col);
            w = image.at<float>(row, col + 1) - image.at<float>(row, col);
            nc = exp(-n*n / k2);
            sc = exp(-s*s / k2);
            ec = exp(-e*e / k2);
            wc = exp(-w*w / k2);
            result.at<float>(row, col) = image.at<float>(row, col) + lambda*(n*nc + s*sc + e*ec + w*wc);
        }
    }
}
```

**运行效果**
![这里写图片描述](https://img-blog.csdn.net/20171101161337943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhMjAwMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**好久没发啦，最近比较忙，但我会一直坚持发！**





