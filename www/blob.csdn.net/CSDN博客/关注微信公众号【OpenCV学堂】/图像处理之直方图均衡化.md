# 图像处理之直方图均衡化 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2012年10月27日 22:29:33[gloomyfish](https://me.csdn.net/jia20003)阅读数：11335
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









图像处理之直方图均衡化

**基本思想**：

直方图图均衡化是图像处理中的常用图像增强手段，直方图均衡化的主要优点是

可以降低图像噪声，提升图像的局部显示。对于常见的RGB图像，直方图均衡化

可以分别在三个颜色通道上处理，基本的直方图均衡化的公式为：

![](https://img-my.csdn.net/uploads/201210/27/1351347399_1635.png)

其中nj表示灰度级为Rk的像素的个数，L为图像中灰度总数，对于RGB来说L的

取值范围为[0~255]总灰度级为256个。而R表示输入图像的直方图数据。根据输

出的灰度值Sk计算出输出像素的每个像素值，完成直方图均衡化之后的像素处理

**程序效果：**

**![](https://img-my.csdn.net/uploads/201210/27/1351348441_3627.png)**

**源代码：**



```java
package com.gloomyfish.filter.study;

import java.awt.image.BufferedImage;

public class HistogramEFilter extends AbstractBufferedImageOp{

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
		int width = src.getWidth();
        int height = src.getHeight();

        if ( dest == null )
            dest = createCompatibleDestImage( src, null );

        int[] inPixels = new int[width*height];
        int[] outPixels = new int[width*height];
        getRGB( src, 0, 0, width, height, inPixels );
        int[][] rgbhis = new int[3][256]; // RGB
        int[][] newrgbhis = new int[3][256]; // after HE
        for(int i=0; i<3; i++) {
        	for(int j=0; j<256; j++) {
        		rgbhis[i][j] = 0;
        		newrgbhis[i][j] = 0;
        	}
        }
        int index = 0;
        int totalPixelNumber = height * width;
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;

                // generate original source image RGB histogram
                rgbhis[0][tr]++;
                rgbhis[1][tg]++;
                rgbhis[2][tb]++;
        	}
        }
        
        // generate original source image RGB histogram
        generateHEData(newrgbhis, rgbhis, totalPixelNumber, 256);
        for(int row=0; row<height; row++) {
        	int ta = 0, tr = 0, tg = 0, tb = 0;
        	for(int col=0; col<width; col++) {
        		index = row * width + col;
        		ta = (inPixels[index] >> 24) & 0xff;
                tr = (inPixels[index] >> 16) & 0xff;
                tg = (inPixels[index] >> 8) & 0xff;
                tb = inPixels[index] & 0xff;

                // get output pixel now...
                tr = newrgbhis[0][tr];
                tg = newrgbhis[1][tg];
                tb = newrgbhis[2][tb];
                
                outPixels[index] = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        	}
        }
        setRGB( dest, 0, 0, width, height, outPixels );
        return dest;
	}
	/**
	 * 
	 * @param newrgbhis
	 * @param rgbhis
	 * @param totalPixelNumber
	 * @param grayLevel [0 ~ 255]
	 */
	private void generateHEData(int[][] newrgbhis, int[][] rgbhis, int totalPixelNumber, int grayLevel) {
		for(int i=0; i<grayLevel; i++) {
			newrgbhis[0][i] = getNewintensityRate(rgbhis[0], totalPixelNumber, i);
			newrgbhis[1][i] = getNewintensityRate(rgbhis[1], totalPixelNumber, i);
			newrgbhis[2][i] = getNewintensityRate(rgbhis[2], totalPixelNumber, i);
		}
	}
	
	private int getNewintensityRate(int[] grayHis, double totalPixelNumber, int index) {
		double sum = 0;
		for(int i=0; i<=index; i++) {
			sum += ((double)grayHis[i])/totalPixelNumber;
		}
		return (int)(sum * 255.0);
	}

}
```
**转载请务必注明**








