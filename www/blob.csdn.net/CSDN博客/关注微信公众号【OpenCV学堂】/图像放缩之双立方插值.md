# 图像放缩之双立方插值 - 关注微信公众号【OpenCV学堂】 - CSDN博客





2011年10月30日 22:57:41[gloomyfish](https://me.csdn.net/jia20003)阅读数：13972
所属专栏：[Java数字图像处理与特效](https://blog.csdn.net/column/details/image-process.html)









图像放缩之双立方插值

**一：数学原理**

如果已知一个函数f(x)以及它在x=0,x=1处的导数，那么函数可以在[0,1]之间插值，当函数

表达为三次多项式时我们称之谓立方插值。一个三次多项式及其导数：

        f(x) =ax^3 +bx^2 + cx + d

         f’(x)=3ax^2 + 2bx +c

多项式在x=0, x=1处值及其导数值为：

         f(0)= d;

         f(1)= a + b + c + d;

         f’(0)=c

         f’(1)=3a + 2b + c



上述的四个等式可以等价的变换为:

         a= 2f(0) – 2f(1) + f’(0) + f’(1)

         b= -3f(0) + 3f(1) – 2f’(0) – f’(1)

         c= f’(0)

         d= f’(1)

假设你有四个点值p0, p1, p2, p3分别在x=-1, x=0, x=1, x=2, 把值分别指定到f(0), f(1), f’(0), 

f’(1)中为:

         f(0)= p1

         f(1)= p2

         f’(0)= (p2 – p0)/2

         f’(1)= (p3-p1)/2



这个我们的立方插值公式变成:

f(p0,p1,p2,p3, x) = (-1/2p0 + 3/2p1 -3/2p2+ 1/2p3)x^3 + (p0-5/2p1 + 2p2 -1/2d)x^2 + (-1/2p0 +

1/2p2)x + p1



双立方插值是立方插值在二维空间的表达, 插值公式可以表述为:

G(x, y) = f (f (p00, p01, p02, p03, y), f(p10,p11, p12, p13, y), f(p20, p21, p22, p23, y), f(p30, p31, p32, p33, y), x)

解出其中的16个参数，即可得带G(x, y)目标插值点的值。



**二：双立方插值优缺点**

双立方插值在图像放大过程可以保留更多的图像细节，放大以后的图像带有反锯齿的功能，

同时图像和源图像相比效果更加真实, 缺点是计算量比较大，是常见的三种图像放大算法中

计算量最大的一种，据说Photoshop的图像放大就是基本双立方插值的优化算法




三：程序运行效果如下：

![](http://hi.csdn.net/attachment/201110/30/0_1319986408cDhQ.gif)


**四：关键代码解析**

不想解释太多，最重要的是代入计算的是浮点数坐标的小数部分，即 x, y的取值范围均在[0,1]之间




**五：基于Java的程序完全源代码**



```java
public class BiCubicInterpolationScale implements ImageScale {

	private double a00, a01, a02, a03;
	private double a10, a11, a12, a13;
	private double a20, a21, a22, a23;
	private double a30, a31, a32, a33;
	private int srcWidth;
	private int srcHeight;
	
	@Override
	public int[] imgScale(int[] inPixelsData, int srcW, int srcH, int destW, int destH) {
		double[][][] input3DData = processOneToThreeDeminsion(inPixelsData, srcH, srcW);
		int[][][] outputThreeDeminsionData = new int[destH][destW][4];
		double[][] tempPixels = new double[4][4];
		float rowRatio = ((float)srcH)/((float)destH);
		float colRatio = ((float)srcW)/((float)destW);
		this.srcWidth = srcW;
		this.srcHeight = srcH;
		for(int row=0; row<destH; row++) {
			// convert to three dimension data
			double srcRow = ((float)row)*rowRatio;
			double j = Math.floor(srcRow);
			double t = srcRow - j;
			for(int col=0; col<destW; col++) {
				double srcCol = ((float)col)*colRatio;
				double k = Math.floor(srcCol);
				double u = srcCol - k;
				for(int i=0; i<4; i++) {
					tempPixels[0][0] = getRGBValue(input3DData,j-1, k-1,i);
					tempPixels[0][1] = getRGBValue(input3DData,j-1, k, i);
					tempPixels[0][2] = getRGBValue(input3DData, j-1,k+1, i);
					tempPixels[0][3] = getRGBValue(input3DData, j-1, k+2,i);
					
					tempPixels[1][0] = getRGBValue(input3DData, j, k-1, i);
					tempPixels[1][1] = getRGBValue(input3DData, j, k, i);
					tempPixels[1][2] = getRGBValue(input3DData, j, k+1, i);
					tempPixels[1][3] = getRGBValue(input3DData, j, k+2, i);
					
					tempPixels[2][0] = getRGBValue(input3DData, j+1,k-1,i);
					tempPixels[2][1] = getRGBValue(input3DData, j+1, k, i);
					tempPixels[2][2] = getRGBValue(input3DData, j+1, k+1, i);
					tempPixels[2][3] = getRGBValue(input3DData, j+1, k+2, i);
					
					tempPixels[3][0] = getRGBValue(input3DData, j+2, k-1, i);
					tempPixels[3][1] = getRGBValue(input3DData, j+2, k, i);
					tempPixels[3][2] = getRGBValue(input3DData, j+2, k+1, i);
					tempPixels[3][3] = getRGBValue(input3DData, j+2, k+2, i);
					
					// update coefficients
					updateCoefficients(tempPixels);
					outputThreeDeminsionData[row][col][i] = getPixelValue(getValue(t, u));
				}

			}
		}
		
		return convertToOneDim(outputThreeDeminsionData, destW, destH);
	}
	
	public double getRGBValue(double[][][] input3DData, double row, double col, int index) {
		if(col >= srcWidth) {
			col = srcWidth - 1;
		}
		
		if(col < 0) {
			col = 0;
		}
		
		if(row >= srcHeight) {
			row = srcHeight - 1;
		}
		
		if(row < 0) {
			row = 0;
		}
		return input3DData[(int)row][(int)col][index];
	}
	
	public int getPixelValue(double pixelValue) {
		return pixelValue < 0 ? 0: pixelValue >255.0d ?255:(int)pixelValue;
	}
	
	public void updateCoefficients (double[][] p) {
		a00 = p[1][1];
		a01 = -.5*p[1][0] + .5*p[1][2];
		a02 = p[1][0] - 2.5*p[1][1] + 2*p[1][2] - .5*p[1][3];
		a03 = -.5*p[1][0] + 1.5*p[1][1] - 1.5*p[1][2] + .5*p[1][3];
		a10 = -.5*p[0][1] + .5*p[2][1];
		a11 = .25*p[0][0] - .25*p[0][2] - .25*p[2][0] + .25*p[2][2];
		a12 = -.5*p[0][0] + 1.25*p[0][1] - p[0][2] + .25*p[0][3] + .5*p[2][0] - 1.25*p[2][1] + p[2][2] - .25*p[2][3];
		a13 = .25*p[0][0] - .75*p[0][1] + .75*p[0][2] - .25*p[0][3] - .25*p[2][0] + .75*p[2][1] - .75*p[2][2] + .25*p[2][3];
		a20 = p[0][1] - 2.5*p[1][1] + 2*p[2][1] - .5*p[3][1];
		a21 = -.5*p[0][0] + .5*p[0][2] + 1.25*p[1][0] - 1.25*p[1][2] - p[2][0] + p[2][2] + .25*p[3][0] - .25*p[3][2];
		a22 = p[0][0] - 2.5*p[0][1] + 2*p[0][2] - .5*p[0][3] - 2.5*p[1][0] + 6.25*p[1][1] - 5*p[1][2] + 1.25*p[1][3] + 2*p[2][0] - 5*p[2][1] + 4*p[2][2] - p[2][3] - .5*p[3][0] + 1.25*p[3][1] - p[3][2] + .25*p[3][3];
		a23 = -.5*p[0][0] + 1.5*p[0][1] - 1.5*p[0][2] + .5*p[0][3] + 1.25*p[1][0] - 3.75*p[1][1] + 3.75*p[1][2] - 1.25*p[1][3] - p[2][0] + 3*p[2][1] - 3*p[2][2] + p[2][3] + .25*p[3][0] - .75*p[3][1] + .75*p[3][2] - .25*p[3][3];
		a30 = -.5*p[0][1] + 1.5*p[1][1] - 1.5*p[2][1] + .5*p[3][1];
		a31 = .25*p[0][0] - .25*p[0][2] - .75*p[1][0] + .75*p[1][2] + .75*p[2][0] - .75*p[2][2] - .25*p[3][0] + .25*p[3][2];
		a32 = -.5*p[0][0] + 1.25*p[0][1] - p[0][2] + .25*p[0][3] + 1.5*p[1][0] - 3.75*p[1][1] + 3*p[1][2] - .75*p[1][3] - 1.5*p[2][0] + 3.75*p[2][1] - 3*p[2][2] + .75*p[2][3] + .5*p[3][0] - 1.25*p[3][1] + p[3][2] - .25*p[3][3];
		a33 = .25*p[0][0] - .75*p[0][1] + .75*p[0][2] - .25*p[0][3] - .75*p[1][0] + 2.25*p[1][1] - 2.25*p[1][2] + .75*p[1][3] + .75*p[2][0] - 2.25*p[2][1] + 2.25*p[2][2] - .75*p[2][3] - .25*p[3][0] + .75*p[3][1] - .75*p[3][2] + .25*p[3][3];
	}
	
	public double getValue (double x, double y) {
		double x2 = x * x;
		double x3 = x2 * x;
		double y2 = y * y;
		double y3 = y2 * y;

		return (a00 + a01 * y + a02 * y2 + a03 * y3) +
		       (a10 + a11 * y + a12 * y2 + a13 * y3) * x +
		       (a20 + a21 * y + a22 * y2 + a23 * y3) * x2 +
		       (a30 + a31 * y + a32 * y2 + a33 * y3) * x3;
	}

	/* <p> The purpose of this method is to convert the data in the 3D array of ints back into </p>
	 * <p> the 1d array of type int. </p>
	 * 
	 */
	public int[] convertToOneDim(int[][][] data, int imgCols, int imgRows) {
		// Create the 1D array of type int to be populated with pixel data
		int[] oneDPix = new int[imgCols * imgRows * 4];

		// Move the data into the 1D array. Note the
		// use of the bitwise OR operator and the
		// bitwise left-shift operators to put the
		// four 8-bit bytes into each int.
		for (int row = 0, cnt = 0; row < imgRows; row++) {
			for (int col = 0; col < imgCols; col++) {
				oneDPix[cnt] = ((data[row][col][0] << 24) & 0xFF000000)
						| ((data[row][col][1] << 16) & 0x00FF0000)
						| ((data[row][col][2] << 8) & 0x0000FF00)
						| ((data[row][col][3]) & 0x000000FF);
				cnt++;
			}// end for loop on col

		}// end for loop on row

		return oneDPix;
	}// end convertToOneDim
	
	private double [][][] processOneToThreeDeminsion(int[] oneDPix2, int imgRows, int imgCols) {
		double[][][] tempData = new double[imgRows][imgCols][4];
		for(int row=0; row<imgRows; row++) {
			
			// per row processing
			int[] aRow = new int[imgCols];
			for (int col = 0; col < imgCols; col++) {
				int element = row * imgCols + col;
				aRow[col] = oneDPix2[element];
			}
			
			// convert to three dimension data
			for(int col=0; col<imgCols; col++) {
				tempData[row][col][0] = (aRow[col] >> 24) & 0xFF; // alpha
				tempData[row][col][1] = (aRow[col] >> 16) & 0xFF; // red
				tempData[row][col][2] = (aRow[col] >> 8) & 0xFF;  // green
				tempData[row][col][3] = (aRow[col]) & 0xFF;       // blue
			}
		}
		return tempData;
	}
}
```

**六：尾声**


这三篇文章，是讨论关于图像放缩的基本原理，方法，及实现，如果想要得到全部的源代码

可以联系我。如果文章有任何错误，欢迎指出。



