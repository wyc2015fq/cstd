# 对数步计算斐波那契数列 - Arthur的随笔 - CSDN博客
2012年05月10日 10:18:42[largetalk](https://me.csdn.net/largetalk)阅读数：2399
先上代码：
```python
def fib_iter(a, b, p, q, n):
    if n==0:
        return b
    if n%2 == 0:
        return fib_iter(a,b,
                p*p+q*q,
                2*p*q+q*q,
                n/2)
    return fib_iter(a*p+a*q+b*q,
            b*p + a*q,
            p,
            q,
            n-1)
def fib(n):
    return fib_iter(1, 0, 0, 1, n)
```
a <- a+b, b <- a被称为T变换， Tpq 变换 a <- a*p + a* q + b*q, b <- b*p + a*q, 所以T变换是Tpq 变换 q=1 p=0的特例，
Tpq 变换有个特性是 Tpq 的二次方等于Tp‘q’， p‘ = p*p + q*q ,
 q' = 2*p*q + q*q
虽然我知道了这个变换，但怎么证明还是不会，数学差的人伤不起 
#########################################################################################
费马小定理证明素数性， 不知道为什么，性能竟然比连续求模差
```python
from random import randint
import time
def expmod(a , n, m):
    if n == 0:
        return 1
    if n%2 == 0:
        return pow(expmod(a, n/2, m), 2)%m
    else:
        return (expmod(a, n-1, m) * a )%m
def judgeprime(m, time):
    for x in range(time):
        a = randint(2, m-1)
        if expmod(a, m, m) != a:
            return False
    return True
t1 = time.time()
x1 = [ x for x in xrange(1000000, 10000001) if judgeprime(x, 5)]
print time.time()-t1
def isPrime(num):  
    i = 2  
    isPrime = True  
    while(i*i <= num):  
        if(num % i == 0):  
            isPrime = False  
            break  
        else:  
            i += 1  
    return isPrime  
t3 = time.time()
x2 = [ i for i in xrange(1000000, 10000001) if isPrime(i)] 
print time.time() -t3
```
