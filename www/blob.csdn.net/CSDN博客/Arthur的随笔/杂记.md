# 杂记 - Arthur的随笔 - CSDN博客
2012年06月23日 19:14:19[largetalk](https://me.csdn.net/largetalk)阅读数：2523
最近事情比较多，都没时间来写点东西了。这段时间除了项目压力比较大之外，也翻看了不少代码和博客等等， 虽然感觉接触了很大得知识量，但一下子还消化不了。看得一些东西虽有所得也没形成系统得知识储备，趁着端午稍有空闲记录一下。
python：
weakref : 
```python
python weakref模块允许程序员创建弱引用的对象
弱引用对象是指一个比较弱得引用不足以让对象一直存在，垃圾回收器可以自由销毁和回收对象。其主要用途是实现缓存或映射大得对象，因为在缓存中或映射中，大对象不需要一直保持
并不是所有对象都能被弱引用, 这些对象包括类实例, python 写的函数(不能是c 写的), 方法(包括绑定和非绑定的), sets, frozensets, 文件对象, 生成器, type 对象, bsddb模块的DBcursor 对象, sockets 数组, deques, 
ps. deque   list-like container with fast appends and pops on either end #与list 区别是快速append 和pop, 使用起来应该差不多,不同应该在内存布局上, c++ stl 中vector 空间不够时会重新分配内存然后将数据复制过去, 而deque 则只是分配一块新的内存存储数据,所以在添加删除元素时有速度优势
主要几个方法如下：
weakref.ref(object, callback)  返回object 对象的弱引用
weakref.proxy(object, callback) 返回object 对象的proxy
weakref.getweakrefcount(object)  object 对象的ref 次数
weakref.getweakrefs(object)    返回object weakref list
class weakref.WeakKeyDictionary([dict])  这个dict 里面存key的都是weakref 的
class weakref.WeakValueDictionary([dict]) 同上,只不过value 是weakref 的
```
inspect:
inspect.getmembers
inspect.ismodule isclass ismethod isfunction
method vs function
function 就是一段简单得代码对象。在python中什么都是对象，function也是对象
method 也是一段代码对象，但它与function区别在于 1.需要显示或隐示将一个对象传入method 2.method可以操作这个对象内元素
了解python中im_class, im_self, im_func, 理解这三者可以更好得理解method和function, 见下面例子
```python
class A(object):
    @classmethod
    def class_method_pa(cls, name):
        print cls, name
    def instance_method_pa(self, name):
        print self, name
a = A()
func1 = A.class_method_pa
func2 = A.instance_method_pa
print func1.im_class, func1.im_func, func1.im_self, func1
print a.class_method_pa.im_class, a.class_method_pa.im_func, a.class_method_pa.im_self, a.class_method_pa
print '##########'
print func2.im_class, func2.im_func, func2.im_self, func2
print a.instance_method_pa.im_class, a.instance_method_pa.im_func, a.instance_method_pa.im_self, a.instance_method_pa
b = A()
a.instance_method_pa('xxxxxx')
func2(b, 'xxxxxx')
输出：
<type 'type'> <function class_method_pa at 0xb734bca4> <class '__main__.A'> <bound method type.class_method_pa of <class '__main__.A'>>
<type 'type'> <function class_method_pa at 0xb734bca4> <class '__main__.A'> <bound method type.class_method_pa of <class '__main__.A'>>
##########
<class '__main__.A'> <function instance_method_pa at 0xb734bc6c> None <unbound method A.instance_method_pa>
<class '__main__.A'> <function instance_method_pa at 0xb734bc6c> <__main__.A object at 0xb73571cc> <bound method A.instance_method_pa of <__main__.A object at 0xb73571cc>>
<__main__.A object at 0xb73571cc> xxxxxx
<__main__.A object at 0xb73571ec> xxxxxx
```
这里可能更多得展示了bound和unbound得区别，但明显可以看到method.im_func就是function对象。
python gearman:
gearman得python客户端，这个module还是花了不少时间去看它得源代码，CommandHandler --> ConnectionManager --> connection 结构结合得紧密严实，看代码时还记录了一下函数目的和调用顺序表，抽空整理成独立得一篇文章出来。
stdnet: 基于redis得django orm
rq: task queue based redis, very simple
clonedigger:用来发现重复代码的工具 [http://clonedigger.sourceforge.net/download.html](http://clonedigger.sourceforge.net/download.html)  , clonedigger source_dir
一些关于测试得python包 [http://wiki.python.org/moin/PythonTestingToolsTaxonomy](http://wiki.python.org/moin/PythonTestingToolsTaxonomy) ， 只能说python包太多了
others:
lambda 算子： 计算机逻辑系统最基础定义，一个简洁得公理系统，这个系统得三条公理是：
expr := identifier
expr := lambda identifier-list . expr
expr := (expr, expr)
Y-combinator: 使lambda 算子支持递归函数得推导演绎结果， Y(F) = F(Y(F)), 其中 F是伪递归函数， Y得构造如下：
```
let Y = lambda F.
  let f_gen = lambda self. F(self(self))
  return f_gen(f_gen)
```
f_gen(f_gen) 就是 不动点算子， 不动点算子性质是能使此式成立 ： F(p) = p, p是F的不动点
lambda和Y-combinator咋看无实际用途，但却是理解函数式语言关键所在，再复杂得函数也可以curry(curry就是partial)成一串lambda， 一般说函数式语言没有变量意思是指函数式语言是一个公理推导系统，程序推导到最后都是一串匿名lambda函数，这样绝对就不会有函数重入问题。对于程序即数据这个概念，通过函数式也更能说得通些。
不过以上都是一点个人理解， 谨慎相信。
