# 状态模式 - Arthur的随笔 - CSDN博客
2011年07月07日 00:48:52[largetalk](https://me.csdn.net/largetalk)阅读数：497标签：[accessor																[设计模式																[ruby																[class																[扩展](https://so.csdn.net/so/search/s.do?q=扩展&t=blog)](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=ruby&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)](https://so.csdn.net/so/search/s.do?q=accessor&t=blog)
个人分类：[design pattern																[ruby](https://blog.csdn.net/largetalk/article/category/831411)](https://blog.csdn.net/largetalk/article/category/842272)
目的：在一个对象内部状态改变时改变它的行为， 一般做法是在方法里用大量if else， 在状态特别多的时候不可取，而且添加或删除一个状态的时候变的困难
状态模式属于行为模式，行为模式是对类或对象怎样交互和怎样分配职责进行描述。
适用场景： 1， 一个对象的行为取决于他的状态， 并且必须在运行时刻根据状态改变它的行为 
                     2， 一个操作包含庞大的多分支条件语句， 并且这些分支依赖于对象的状态
状态转换的地点可在Context中也可以在State子类中， 在State中转换更灵活，更容易修改和扩展逻辑， 但需要context增加一个借口给State修改状态，也使各个State子类产生耦合
在state子类中修改状态的ruby实现：
```
class State
	def handle(con)
		if con.s.class == self.class
			con.s =  Nonestate.new
			self.handle(con)
		else
			con.s.handle(con)
		end
	end
end
class Nonestate < State
	def handle(con)
		puts 'in Nonestate'
		con.s = Astate.new
	end
end
class Astate < State
	def handle(con)
		puts 'in Astate'
		con.s = Bstate.new
	end
end
class Bstate < State
	def handle(con)
		puts 'in Bstate'
		con.s = Astate.new
	end
end
class Content
	attr_accessor :s
	def initialize
		@s = State.new
	end
	def change_state(s)
		@s = s
	end
	def request
		@s.handle(self)
	end
end
c = Content.new
c.request
c.request
c.request
c.request
c.request
c.request
```
ps. 以前看到设计模式就头痛，现在好点了
