# 各种序列化库的体验 - Arthur的随笔 - CSDN博客
2011年07月21日 01:07:05[largetalk](https://me.csdn.net/largetalk)阅读数：2550
这里只用python来分析说明。
python自带的两个cPickle, marshal
我用过或尝试过的包括simplejson, AMF， protoBuf, MessagePack
就这些来分析比较一下吧。
```python
import time
import cPickle
import simplejson
import marshal
import msgpack
import cjson
test_obj = ['abc', 123, {"abc":123}, ("abc", 123), 4.56]
times = 100000
st = time.clock()
for x in xrange(times):
    cPickle.loads(cPickle.dumps(test_obj))
print 'cPickle process %s times used %s '%(times, time.clock()-st)
st = time.clock()
for x in xrange(times):
    simplejson.loads(simplejson.dumps(test_obj))
print 'simplejson process %s times used %s '%(times, time.clock()-st)
st = time.clock()
for x in xrange(times):
    cjson.decode(cjson.encode(test_obj))
print 'cjson process %s times used %s '%(times, time.clock()-st)
st = time.clock()
for x in xrange(times):
    marshal.loads(marshal.dumps(test_obj))
print 'marshal process %s times used %s '%(times, time.clock()-st)
st = time.clock()
for x in xrange(times):
    msgpack.loads(msgpack.dumps(test_obj))
print 'msgpack use loads/dumps process %s times used %s '%(times, time.clock()-st)
st = time.clock()
packer = msgpack.Packer()
unpacker = msgpack.Unpacker()
for x in xrange(times):
    unpacker.feed(packer.pack(test_obj))
    unpacker.unpack()
print 'msgpack use Packer/Unpacker process %s times used %s '%(times, time.clock()-st)
```
我本机的运行结果：
cPickle process 100000 times used 1.63 
simplejson process 100000 times used 2.45 
cjson process 100000 times used 0.91 
marshal process 100000 times used 0.28 
msgpack use loads/dumps process 100000 times used 1.17 
msgpack use Packer/Unpacker process 100000 times used 0.28 
可以看出marshal是很快的，但它有版本不兼容问题， simplejson比较慢，但好像有个cjson比cPickle还快， MessagePack使用loads/dumps速度和cPickle差不多， 使用pcker/unpacker则快很多，它号称比json快10倍，比protobuf快4倍，呵呵，不过我本地安装msgpack-idl --install python 一直没有成功，说没有gem包，就不能用来和protobuf进行比较了
剩下两种AMF, ProtoBuf则真正在rpc里用的比较多，上面几种都有不同的缺点， 比如cross language就不够好， 而AMF和protobuf这方面则作的不错， AMF出来的东西长度要长一些，因为它包括类型信息，而protobuf则只有数据信息，要小很多。 这是两种不同的设计哲学。今天太晚了，以后有空把这两种的使用和比较测试也写一下。
