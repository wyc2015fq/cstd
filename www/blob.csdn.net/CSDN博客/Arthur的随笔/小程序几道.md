# 小程序几道 - Arthur的随笔 - CSDN博客
2012年03月31日 16:13:40[largetalk](https://me.csdn.net/largetalk)阅读数：796标签：[lambda																[float																[matplotlib																[import																[system																[network](https://so.csdn.net/so/search/s.do?q=network&t=blog)](https://so.csdn.net/so/search/s.do?q=system&t=blog)](https://so.csdn.net/so/search/s.do?q=import&t=blog)](https://so.csdn.net/so/search/s.do?q=matplotlib&t=blog)](https://so.csdn.net/so/search/s.do?q=float&t=blog)](https://so.csdn.net/so/search/s.do?q=lambda&t=blog)
个人分类：[algorithm																[python](https://blog.csdn.net/largetalk/article/category/715661)](https://blog.csdn.net/largetalk/article/category/941205)
将字符串中空格长度大于1的空格变成一个空格， 时间复杂度O(N), 空间复杂度o(N)
```python
def test1():
    sr = 'abcd abcde   abcd dd            abcd 123'
    sl = list(sr)
    
    st = False
    i=j=0
    for x in sr:
        if x != ' ':
            st = False
            sl[i] = sl[j] 
            i += 1
            j += 1
        elif st == False:
            st = True
            sl[i] = sl[j] 
            i += 1
            j += 1
        else:
            j += 1
    
    print sr
    print ''.join(sl[:i])
```
matplotlib代码一例
```python
#coding: utf8
import matplotlib.pyplot as plt
from datetime import datetime
###result.txt format
#2012-04-01_13:29:01 0.00, 0.01, 0.05 739928 1316020 64.01 129900 777072 832856 20.78 585612 574972 12 10682 17 ESTABLISHED 12 LISTEN 10703 TIME_WAIT
#2012-04-01_13:30:01 0.00, 0.01, 0.05 738440 1317508 64.08 129980 778240 832856 20.78 585912 575912 2 10622 25 ESTABLISHED 12 LISTEN 10631 TIME_WAIT
#2012-04-01_13:31:01 0.00, 0.01, 0.05 737820 1318128 64.11 130060 779016 832856 20.78 586056 576648 2 9295 2 ESTABLISHED 12 LISTEN 9292 TIME_WAIT
#2012-04-01_13:32:01 0.00, 0.01, 0.05 739192 1316756 64.05 130076 779016 832856 20.78 586056 576664 1 3532 2 ESTABLISHED 12 LISTEN 3528 TIME_WAIT
#2012-04-01_13:33:01 0.05, 0.03, 0.05 727396 1328552 64.62 130116 780128 881624 22.00 597060 577712 1 5 3 ESTABLISHED 12 LISTEN
###
time_lst = []
avg1_lst = []
avg5_lst = []
avg15_lst = []
memper_lst = []
commit_lst = []
netlink_lst = []
establish_lst = []
listen_lst = []
timewait_lst = []
def getlink(lst):
    if len(lst) <= 2:
        return int(lst[0]), 0, 0
    if len(lst) <= 4:
        return int(lst[0]), int(lst[2]), 0
    if len(lst) >= 6:
        return int(lst[0]), int(lst[2]), int(lst[4])
with open('result.txt', 'r') as fp:
    for line in fp:
        data = line.split(' ')
        ti, avg1, avg5, avg15, memfree, memused, memper, kbb, kbca, kbc, commit, ka, kina, netlink, dblink = data[:15]
        time_lst.append(datetime.strptime(ti, '%Y-%m-%d_%H:%M:%S'))
        avg1_lst.append(float(avg1[:-1])*100)
        avg5_lst.append(float(avg5[:-1])*100)
        avg15_lst.append(float(avg15)*100)
        memper_lst.append(float(memper))
        commit_lst.append(float(commit))
        netlink_lst.append(int(netlink))
        est, listen, tw = getlink(data[15:])
        establish_lst.append(est)
        listen_lst.append(listen)
        timewait_lst.append(tw)
plt.figure(1)
plt.subplot(211)
plt.title("System Load Average Figure")
plt.xlabel("Time Line")
plt.ylabel("System Load Average")
#plt.text(2, 6, r'red: 1 minute, blue: 5 minute, green: 15 minute', fontsize=15, style='italic',bbox={'facecolor':'red', 'alpha':0.5, 'pad':10})
plt.plot(time_lst, avg1_lst, 'r-',  time_lst, avg5_lst, 'b-', time_lst, avg15_lst, 'g-')
plt.subplot(212)
plt.title("Memory Figure")
plt.xlabel("Time Line")
plt.ylabel("Memory Used Percentage")
plt.plot(time_lst, memper_lst, 'r-', time_lst, commit_lst, 'b-')
plt.figure(2)
plt.title("NetWork Figure")
plt.xlabel("Time Line")
plt.ylabel("Link Number")
plt.plot(time_lst, netlink_lst, 'r-', time_lst, establish_lst, 'b-', time_lst, listen_lst, 'g-', time_lst, timewait_lst, 'y-')
plt.show()
```
原题大概是：
两个数组a[N]，b[N]，其中A[N]的各个元素值已知，现给b[i]赋值，b[i] = a[0]*a[1]*a[2]...*a[N-1]/a[i]；
要求：
1.不准用除法运算
2.除了循环计数值，a[N],b[N]外，不准再用其他任何变量（包括局部变量，全局变量等）
3.满足时间复杂度O（n），空间复杂度O（1）
```python
a = [2,5,6,3,1,9]
print a
b = map(lambda x: reduce( lambda i,j: i*j, a[:a.index(x)], 1) * reduce( lambda i,j : i*j, a[a.index(x)+1:], 1),  a)
print b
c = [1]
for i in range(len(a)):
    if i == 0:
        continue
    c.append( a[i-1]*c[i-1])
for i in range(len(c)):
    c[i] = c[i] * reduce(lambda i,j: i*j , a[i+1:], 1)
print c
d = [0 for x in a]
d[0] = 1
for i in range(1, len(a)):
    d[0] *= a[i-1]
    d[i] = d[0]
d[0] = 1
for i in range(len(a)-2, 0, -1):
    d[0] *= a[i+1]
    d[i] *= d[0]
d[0] *= a[1]
print d
```
给出数n， 求0到n之间数字1出现的次数， 如f(13) = 6, f(10) = 2
```python
import math
def length11(n):
    return int( math.log10(n) )
def first(n):
    return n/pow(10, length11(n))
def tail(n):
    return n % pow(10, length11(n))
def f9(k):
    if k == 0:
        return 0
    return pow(10, k-1) + 10*f9(k-1)
def f1(n):
    if first(n) == 1:
        return tail(n) + 1
    else:
        return pow(10, length11(n))
def cal(n):
    if n== 0:
        return 0
    if n <= 9:
        return 1
    return f1(n) + first(n) * f9(length11(n))+ cal(tail(n))
print cal(213)
print cal(10)
```

