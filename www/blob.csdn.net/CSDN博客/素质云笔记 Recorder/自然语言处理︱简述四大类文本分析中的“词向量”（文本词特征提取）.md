# 自然语言处理︱简述四大类文本分析中的“词向量”（文本词特征提取） - 素质云笔记/Recorder... - CSDN博客





2016年08月09日 15:32:15[悟乙己](https://me.csdn.net/sinat_26917383)阅读数：30832
所属专栏：[R语言与自然语言处理](https://blog.csdn.net/column/details/13670.html)













笔者在看各种NLP的论文、文献、博客之中发现在应用过程中，有种类繁多的词向量的表达。笔者举例所看到的词向量有哪些。

词向量一般被看做是文档的特征，不同词向量有不同的用法，**本文介绍了四类词向量：**

**Hash算法及延伸、bow算法延伸、word2vec延伸、LDA主题延伸。**




————————————————————————————————————





**本篇是笔者刚刚入门所写，那么在阅读CIPS2016之后，根据里面的内容重新梳理了一遍，从CIPS2016里面相关内容来看，笔者本篇内容所写的，总结的还是很全面的，当时写的时候才入门NLP一个月，还是棒棒哒~让我傲娇一下，新博客链接：**

[cips2016+学习笔记︱简述常见的语言表示模型（词嵌入、句表示、篇章表示）](http://blog.csdn.net/sinat_26917383/article/details/54882554)





————————————————————————————————————





![](https://img-blog.csdn.net/20160810152354283)





**词向量类型：**

一个词一列向量，Hash算法，word2vec，hash把词打散成（01010101110）的数值，word2vec则打散同时定义成了向量，参考文献中，验证了将词向量加起来的确是一个有效的方法；**延伸：**word2vec考虑了上下语义，doc2vec还考虑了上下语句顺序，用在段落中较好。

一个词一个值，bow算法+词权重，LDA主题-词语矩阵，两者有递进关系，bow进化到LDA，当然LDA超级耗时，所以业界不喜欢用；







**根据词向量组成句向量的方式：**

如果是一词一列向量，一般用简单相加（相加被证明是最科学）来求得；

一个词一值的就是用词权重组合成向量的方式；

谷歌的句向量sen2vec可以直接将句子变为一列向量。




**词向量的额外效果**

消除歧义：LDA的主题-词语向量；

结合上下文语境：word2vec；

文档与文档之间的关系：bow+TFIDF（TFIDF能够较好区分文档差别的指标，而互信息较为有利于文档中核心词的提取）




一般来说，hash值效果会稍差一些，其他三类都很不错，有着很多可能性，一般有以下几个课题：

**文本分类方面**，会用BOW+TFIDF词向量（TFIDF较好区分文档之间）、LDA主题-词语向量（发觉潜在语义）、word2vec

**文本相似性方面**，用词向量来度量相似性简直再好不过，一般会用word2vec（结合了上下文语境，短文本非常优异，百分点已经成功践行）、LDA主题-词语向量（比较多的考虑了词语的歧义问题）

**文本主题建模方面，**LDA模型。




————————————————————————————————————




# 1、BoW算法衍生——One-hot Representation






## （1）词频做向量值








Bag-of-words model (BoW model)最早出现在自然语言处理（Natural Language Processing[](http://en.wikipedia.org/wiki/Natural_language_processing)）和信息检索（Information Retrieval）领域.。该模型忽略掉文本的语法和语序等要素，将其仅仅看作是若干个词汇的集合，文档中每个单词的出现都是独立的。BoW使用一组无序的单词(words)来表达一段文字或一个文档.。近年来，BoW模型被广泛应用于计算机视觉中。

基于文本的BoW模型的一个简单例子如下：




首先给出两个简单的文本文档如下：

        John likes to watch movies. Mary likes too.

        John also likes to watch football games.




基于上述两个文档中出现的单词，构建如下一个词典 (dictionary)：

       {"John": 1, "likes": 2,"to": 3, "watch": 4, "movies": 5,"also": 6, "football": 7, "games": 8,"Mary": 9, "too": 10}




上面的词典中包含10个单词, 每个单词有唯一的索引, 那么每个文本我们可以使用一个10维的向量来表示。如下：

       [1, 2, 1, 1, 1, 0, 0, 0, 1, 1]

       [1, 1,1, 1, 0, 1, 1, 1, 0, 0]




该向量与原来文本中单词出现的顺序没有关系，而是词典中每个单词在文本中出现的频率。
Distributed Representation是一个稠密、低维的实数限量，它的每一维表示词语的一个潜在特征，该特征捕获了有用的句法和语义特征。其特点是将词语的不同句法和语义特征分布到它的每一个维度上去表示。

![](https://img-blog.csdn.net/20160809145300089)







## （2）词权重做向量值（TFIDF/CHI/MI）



参考：机器学习那些事——文本挖掘中的特征提取

TFIDF等term weighting来当做词向量。会搭配着BOW模型使用，比如先定位了每句话出现的词，然后填上的不是频数，而是每个词的向量。比如python中的词典就是非常好的存储这个内容的过程。





`8 9219:0.24673737883635047 453:0.09884635754820137 10322:0.21501394457319623 11947:0.27282495932970074 6459:0.41385272697452935 46:0.24041607991272138 8987:0.14897255497578704 4719:0.22296154731520754 10094:0.13116443653818177 5162:0.17050804524212404 2419:0.11831944042647048 11484:0.3501901869096251 12040:0.13267440708284894 8745:0.5320327758892881 9048:0.11445287153209653 1989:0.04677087098649205 7102:0.11308242956243426 3862:0.12007217405755069 10417:0.09796211412332205 5729:0.148037967054332 11796:0.08409157900442304 9094:0.17368658217203461 3452:0.1513474608736807 3955:0.0656773581702849 6228:0.4356889927309336 5299:0.15060439516792662 3505:0.14379243687841153 10732:0.9593462052245719 9659:0.1960034406311122 8545:0.22597403804274924 6767:0.13871522631066047 8566:0.20352452713417019 3546:0.1136541497082903 6309:0.10475466997804883 10256:0.26416957780238604 10288:0.22549409383630933`



第一列的8表示类别编号，其余的每一列是词及其权重，使用冒号分隔，例如“9219:0.24673737883635047”表示编号为9219的词，对应的TF-IDF值为0.24673737883635047。如果特征向量有个N个，那么每条记录就对应着一个N维向量。
（来自网站：[使用libsvm实现文本分类](http://shiyanjun.cn/archives/548.html)）



————————————————————————————————————





# 2、hash算法衍生——simhash算法**——****One-hot Representation**



（参考： [R语言︱文本挖掘——jiabaR包与分词向量化的simhash算法（与word2vec简单比较）](http://blog.csdn.net/sinat_26917383/article/details/51068097)）



先用hash算法把每一个词打成一系列的0,1点，然后每个词的hash值相加。然后附上词权重。

![](https://img-blog.csdn.net/20160707112326108)







为了便于理解尽量不使用数学公式，分为这几步：
- 
1、分词，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==> 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。

- 
2、hash，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。

- 
3、加权，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。

- 
4、合并，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。

- 
5、降维，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。





————————————————————————————————————





# 3、word2vec词向量延伸




## （1）word2vec




word2vec是谷歌提出基于上下文语境来获取的词向量。如图是百分点公司的训练词向量的模型图。




![](https://img-blog.csdn.net/20160809145219822)





## （2）句向量






最直观的思路，对于phrase和sentence，我们将组成它们的所有word对应的词向量加起来，作为短语向量，句向量。在参考文献中，验证了将词向量加起来的确是一个有效的方法，但事实上还有更好的做法。

Le和Mikolov在文章《Distributed Representations of Sentences and Documents》[20]里介绍了sentence vector，这里我们也做下简要分析。详细参考：[火光摇曳的博客](http://www.flickering.cn/ads/2015/02/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BA%8C/)
————————————————————————————————————




# 4、主题模型中的topic-word向量




主题模型建立之后，会得到两个矩阵，一个是主题-词语向量矩阵；一个是文档-主题向量矩阵。其中的主题-词语矩阵，可以用来代表每个词。实际上，其是代表每个词在每个主题下的频率，但是作为潜在语义的判别也十分有效，业界会开发使用，来作为了解文档词语相关性的判别。



这个概率公式可以用矩阵表示：

![](https://img-my.csdn.net/uploads/201209/03/1346651772_3109.PNG)




        其中”文档-词语”矩阵表示每个文档中每个单词的词频，即出现的概率；”主题-词语”矩阵表示每个主题中每个单词的出现概率；”文档-主题”矩阵表示每个文档中每个主题出现的概率。
可参考博客：[主题模型-LDA浅析](http://blog.csdn.net/huagong_adu/article/details/7937616)







**每每以为攀得众山小，可、每每又切实来到起点，大牛们，缓缓脚步来俺笔记葩分享一下吧，please~**![](https://img-blog.csdn.net/20161213101203247)


———————————————————————————




