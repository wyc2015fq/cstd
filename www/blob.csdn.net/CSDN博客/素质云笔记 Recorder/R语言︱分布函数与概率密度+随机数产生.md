# R语言︱分布函数与概率密度+随机数产生 - 素质云笔记/Recorder... - CSDN博客





2016年04月19日 17:29:41[悟乙己](https://me.csdn.net/sinat_26917383)阅读数：7243
所属专栏：[R的数据操作与清洗](https://blog.csdn.net/column/details/13587.html)















# 1、常见概率分布






```
##正态分布
pnorm(1.96)                #P(x<=1.96)时的分布概率
pnorm(1.96,0,1)            #上同
pnorm(1.96,lower.tail = F) #P(x>1.96)注意与pnorm的区别
qnorm(0.975)               #已知分布概率求x值
dnorm(0)                   #f(0)概率密度值
rnorm(111)                 #产生符合正态分布的111个随机数


##泊松分布 Possion(x,λ)
dpois(2,0.9)      #等同概率密度
dpois(2.1,0.9)    #x一定需要整数
ppois(2.1,0.9)    #分布概率，取2.1的最小整数
```




其他一些分布函数：




![](https://img-blog.csdn.net/20160419171859914)








![](https://img-blog.csdn.net/20161111174356655)



**一个利用概率分布解决问题的例子**



1.某人进行射击，每次击中目标的命中率为0.02，独立射击400次，求至少击中两次的概率。

解：400重伯努利试验，用二项分布求解。




P{X = k} = C400k * (0.02)^k * (0.0=98)^(400-k)

P{X≥2} = 1 – P{X = 0} - P{X = 1}



```
> 1 - sum(pbinom(0:1, 400, 0.02))
[1] 0.9968561
```




# 2、根据分布产生随机数

均匀分布、正态分布是比较常见的产生随机数的分布






```
> runif(10)
 [1] 0.961465376 0.007521925 0.193619234 0.137027246 0.739370654 0.072907082
 [7] 0.674551635 0.650777811 0.984664183 0.796723066
```

显著性水平为5%的正态分布的双侧临界值是：




```
> qnorm(0.025)
[1] -1.959964
> qnorm(0.975)
[1] 1.959964
```





随机数中产生的问题





# 问：[set.seed设置了种子，但是每次产生的随机数还是不同？]()






解答：set.seed()只对运行该命令后的第一次随机产生结果有效。





**[plain]**[view plain](http://blog.csdn.net/sinat_26917383/article/details/51114335#)[copy](http://blog.csdn.net/sinat_26917383/article/details/51114335#)

[print](http://blog.csdn.net/sinat_26917383/article/details/51114335#)[?](http://blog.csdn.net/sinat_26917383/article/details/51114335#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)

- > set.seed(13)  
- > rnorm(10)  
-  [1]  0.5543269 -0.2802719  1.7751634  0.1873201  1.1425261  0.4155261  
-  [7]  1.2295066  0.2366797 -0.3653828  1.1051443  
- > set.seed(13)  
- > rnorm(10)  
-  [1]  0.5543269 -0.2802719  1.7751634  0.1873201  1.1425261  0.4155261  
-  [7]  1.2295066  0.2366797 -0.3653828  1.1051443  
- >   


要得到相同的随机数，还得再“重写”一遍
set seed(123)
rnorm()

这样，每次得到的随机数就一样。




——————————————————————————————————

# 应用一：rep()和replicate()批量取随机数



来源公众号：砍柴问樵夫

问题：假设我想从符合正态分布的数据集中随机抽取2个数据，排序， 这样的数据我需要10对，你会怎么做？





很多人都会想到用rep()这个函数，我们来试试。



`rep(sort(sample(rnorm(n=100,mean = 0,sd = 1),2)),10)`




结果文件：



```
> rep(sort(sample(rnorm(n=100,mean = 0,sd = 1),2)),10)
 [1] 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322
 [8] 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045
[15] 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045
```





很明显不符合我们的要求。

该怎么解决呢？

replicate()函数可以实现，具体如下：


`replicate(n=10,expr=sort(sample(rnorm(n=100,mean = 0,sd = 1),2)))`




结果文件：




```
[,1]       [,2]      [,3]       [,4]      [,5]       [,6]
[1,] -0.72719296 -0.9876203 -2.212692 -0.8753055 0.2981434 -1.2255357
[2,] -0.02896154  0.9458406  1.511990  1.9813026 1.2695440 -0.2565482
            [,7]       [,8]       [,9]    [,10]
[1,] -0.21979065 -0.6226580 -0.2889041 0.566944
[2,]  0.09309426  0.4599596  0.5187426 1.602581
```





大家应该注意到：rep()返回的是向量，replicate()返回的是矩阵。

下面列出两个函数的用法：


rep()：


rep(x, ...)

rep.int(x, times) #每个元素重复次数

rep_len(x, length.out) #生成向量长度




replicate()，replicate(n, expr, simplify = "array") #随机数生成器













