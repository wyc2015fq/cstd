
# R语言︱分布函数与概率密度+随机数产生 - 素质云笔记-Recorder... - CSDN博客

2016年04月19日 17:29:41[悟乙己](https://me.csdn.net/sinat_26917383)阅读数：7160所属专栏：[R的数据操作与清洗](https://blog.csdn.net/column/details/13587.html)





# 1、常见概率分布

`##正态分布
pnorm(1.96)                #P(x<=1.96)时的分布概率
pnorm(1.96,0,1)            #上同
pnorm(1.96,lower.tail = F) #P(x>1.96)注意与pnorm的区别
qnorm(0.975)               #已知分布概率求x值
dnorm(0)                   #f(0)概率密度值
rnorm(111)                 #产生符合正态分布的111个随机数

##泊松分布 Possion(x,λ)
dpois(2,0.9)      #等同概率密度
dpois(2.1,0.9)    #x一定需要整数
ppois(2.1,0.9)    #分布概率，取2.1的最小整数`
其他一些分布函数：

![](https://img-blog.csdn.net/20160419171859914)


![](https://img-blog.csdn.net/20161111174356655)
**一个利用概率分布解决问题的例子**
1.某人进行射击，每次击中目标的命中率为0.02，独立射击400次，求至少击中两次的概率。
解：400重伯努利试验，用二项分布求解。

P{X = k} = C400k * (0.02)^k * (0.0=98)^(400-k)
P{X≥2} = 1 – P{X = 0} - P{X = 1}
`> 1 - sum(pbinom(0:1, 400, 0.02))
[1] 0.9968561`

# 2、根据分布产生随机数
均匀分布、正态分布是比较常见的产生随机数的分布

`> runif(10)
 [1] 0.961465376 0.007521925 0.193619234 0.137027246 0.739370654 0.072907082
 [7] 0.674551635 0.650777811 0.984664183 0.796723066`
显著性水平为5%的正态分布的双侧临界值是：
`> qnorm(0.025)
[1] -1.959964
> qnorm(0.975)
[1] 1.959964`

随机数中产生的问题

# 问：
# [set.seed设置了种子，但是每次产生的随机数还是不同？ ]()

解答：set.seed()只对运行该命令后的第一次随机产生结果有效。
**[plain]**[view plain](http://blog.csdn.net/sinat_26917383/article/details/51114335#)[copy](http://blog.csdn.net/sinat_26917383/article/details/51114335#)
[print](http://blog.csdn.net/sinat_26917383/article/details/51114335#)[?](http://blog.csdn.net/sinat_26917383/article/details/51114335#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)
> set.seed(13)
> rnorm(10)
[1]  0.5543269 -0.2802719  1.7751634  0.1873201  1.1425261  0.4155261
[7]  1.2295066  0.2366797 -0.3653828  1.1051443
> set.seed(13)
> rnorm(10)
[1]  0.5543269 -0.2802719  1.7751634  0.1873201  1.1425261  0.4155261
[7]  1.2295066  0.2366797 -0.3653828  1.1051443
>

要得到相同的随机数，还得再“重写”一遍
set seed(123)
rnorm()
这样，每次得到的随机数就一样。

——————————————————————————————————
# 应用一：rep()和replicate()批量取随机数
来源公众号：砍柴问樵夫
问题：假设我想从符合正态分布的数据集中随机抽取2个数据，排序， 这样的数据我需要10对，你会怎么做？

很多人都会想到用rep()这个函数，我们来试试。

`rep(sort(sample(rnorm(n=100,mean = 0,sd = 1),2)),10)`

结果文件：
`> rep(sort(sample(rnorm(n=100,mean = 0,sd = 1),2)),10)
 [1] 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322
 [8] 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045
[15] 0.1188322 0.3224045 0.1188322 0.3224045 0.1188322 0.3224045`

很明显不符合我们的要求。
该怎么解决呢？
replicate()函数可以实现，具体如下：
`replicate(n=10,expr=sort(sample(rnorm(n=100,mean = 0,sd = 1),2)))`

结果文件：

`[,1]       [,2]      [,3]       [,4]      [,5]       [,6]
[1,] -0.72719296 -0.9876203 -2.212692 -0.8753055 0.2981434 -1.2255357
[2,] -0.02896154  0.9458406  1.511990  1.9813026 1.2695440 -0.2565482
            [,7]       [,8]       [,9]    [,10]
[1,] -0.21979065 -0.6226580 -0.2889041 0.566944
[2,]  0.09309426  0.4599596  0.5187426 1.602581`

大家应该注意到：rep()返回的是向量，replicate()返回的是矩阵。
下面列出两个函数的用法：
rep()：
rep(x, ...)
rep.int(x, times) \#每个元素重复次数
rep_len(x, length.out) \#生成向量长度

replicate()，replicate(n, expr, simplify = "array") \#随机数生成器





