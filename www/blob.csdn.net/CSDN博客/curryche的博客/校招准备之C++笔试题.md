# 校招准备之C++笔试题 - curryche的博客 - CSDN博客





2018年07月12日 15:30:16[curryche](https://me.csdn.net/whwan11)阅读数：945








1.若要用fopen函数打开一个新的二进制文件，该文件既能读也能写，则文件方式 

字符串应是（）。  

A “ab++” 

B “wb+” 

C “rb+” 

D “ab”
正确答案: B  

解析： 

A) “ab+” ： 

   文件不存在时要建立 

   然后打开一个二进制文件，进行读和追加
B) “wb+” ： 

   文件不存在时要建立 

   打开一个二进制文件，使文件内容先为空，读和写
C）”rb+” ： 

  文件不存在 报错 

  存在：打开，读写二进制文件。
D)”ab”： 

 文件不存在时要建立 

   然后打开一个二进制文件，进行末尾追加 
**mode说明**： 

r+ 打开可读写的文件，该文件必须存在。
rb+ 读写打开一个二进制文件，只允许读写数据。

rt+ 读写打开一个文本文件，允许读和写。

w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）

a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

wb 只写打开或新建一个二进制文件；只允许写数据。

wb+ 读写打开或建立一个二进制文件，允许读和写。

wt+ 读写打开或着建立一个文本文件；允许读写。

at+ 读写打开一个文本文件，允许读或在文本末追加数据。

ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。

2.下列对接口的说法，正确的是( )  

A.接口与抽象类是相同的概念 

B.若要实现一个接口为普通类则必须实现接口的所有抽象方法 

C.接口之间不能有继承关系 

D.一个类只能实现一个接口
正确答案: B 

解析： 

A 接口与抽象类是不同的概念。抽象类是用于捕捉子类的通用特性，接口是抽象方法的集合； 

B 实现接口必须实现接口的所有方法； 

C 接口可以继承一个或多个接口，抽象类只能继承一个类或者实现多个接口； 

D 一个类可以实现多个接口。
3.设struct { 

short a; 

char b; 

float c; 

}cs; 

则sizeof(cs)的值是() 

A.4 

B.6 

C.8
正确答案：C 

解析： 

short占2个字节，char占1个字节。然后char后边要填充一个空字节用于对齐。float占4个字节，所以一共是2 + 1 + 1 + 4 = 8字节。
4.以下程序 

main() 

{char 

str[][10]={“China”,”Beijing”},*p=str; 

printf(“%s\n”,p+10); 

} 

程序运行后的输出结果是(   )。 

A. China 

B. Bejing 

C. ng 

D. ing
正确答案：B 

解析： 

str定义为一个二维字符数组，即为str[2][10]，p指向这个数组的首指针，那么p+10指向这个数组第二维的首指针，所以输出字符串为Beijng
5. 

程序char c[5]={‘a’,’b’,’\0’,’c’,’\0’}; printf(“%s”,c);}的运行结果是（ ）  

A. ‘a”b’ 

B. ab\0c\0 

C. ab c 

D. ab
正确答案: D  

解析： 

printf函数打印字符串，遇到空字符结束
6.下列代码的结果是 

main()  

{  

    int a[5]={1,2,3,4,5};  

    int *ptr=(int *)(&a+1);  

    printf(“%d,%d”,*(a+1),*(ptr-1));  

} 

A. 3，5 

B. 2，4 

C. 2，5 

D. 3，4

正确答案: C 

解析： 

数组名就是数组0号元素的地址。 

a = &a[0] 

&a 是指向一个有5个整型元素的数组的地址。 a是一维指针，&a相当于是二维指针。 &a+1 就是从a向后跳过一个完整的数组所占用的内存空间。 整型5个元素的数组占用 5*sizeof(int)=5*4=20，所以 &a+1应该从a向后跳20字节。正好指到a[4]的后面。ptr是int *， 减1就是向前跳4个字节，ptr-1正好指向a[4]

7.派生类的成员函数可以直接访问基类的公有成员和保护成员。 

A. 是 

B. 否

正确答案: A 

解析： 

即使是private继承，派生类成员也是可以访问基类的public和protected成员的，只是这些成员在派生类里都为private性质的

8.下列代码的结果是 

main()  

{  

    int a[5]={1,2,3,4,5};  

    int ptr=(int )(&a+1);  

    printf(“%d,%d”,(a+1),(ptr-1));  

} 

A. 3，5 

B. 2，4 

C. 2，5 

D. 3，4

正确答案: C 

解析： 

数组名就是数组0号元素的地址。 

a = &a[0] 

&a 是指向一个有5个整型元素的数组的地址。 a是一维指针，&a相当于是二维指针。 &a+1 就是从a向后跳过一个完整的数组所占用的内存空间。 整型5个元素的数组占用 5*sizeof(int)=5*4=20，所以 &a+1应该从a向后跳20字节。正好指到a[4]的后面。ptr是int *， 减1就是向前跳4个字节，ptr-1正好指向a[4]

9..h头文件中的ifndef/define/endif 的作用？ 

A. 防止重复引用 

B. 规范化代码 

C. 标志被引用文件内容中可以被共享的代码 

D. 以上都不正确

正确答案: A 

解析： 

主要作用是防止重复引用，比如一个头文件定义如下：``#ifndef _HEAD_H_#define _HEAD_H_//代码部分#endif

假如该头文件第一次被引用，HEAD_H没有被定义，所以就执行宏定义，直到#endif 

该头文件第二次被引用的时候，HEAD_H已经被定义，下面的语句就不会执行

10.``int fun(int a){
 a^=(1<<5)-1;returna;
}

fun(21)运行结果是() 

A. 10 

B. 5 

C. 3 

D. 8

正确答案: A 

解析： 

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 

(1<<5): 左移5位相当于乘以2的5次方,即32,则,1左移5位得32

a = a^((1<<5) - 1);  //这里添加一个括号，为了说明减号比异或的优先级高 

原式相当于a = a^(31);此函数就是求取一数与31异或后的值

当a=21时,化为二进制:10101 

32的二进制:11111 

异或后得:01010,即十进制的10

11.C++内存分配中说法错误的是：__。 

A. 对于栈来讲，生长方向是向上的，也就是向着内存地址增加的方向 

B. 对于堆，大量的 new/delete 操作会造成内存空间的不连续 

C. 堆容易产生 memory leak 

D. 堆的效率比栈要低得多 

E. 栈变量引用容易逃逸 

F. 栈区一般由编译器自动分配释放，堆区一般由程序员分配释放。

正确答案: A 

解析： 

栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将 提示overflow。因此，能从栈获得的空间较小。 

 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储  的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小  受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

12.编译运行如下程序会出现什么结果``#include <stdio.h>classA
{
    A()
    {
        printf("A()");
    }
};
void main()
{
    A a;
}

则输出  

A. A() 

B. 编译错误 

C. 链接错误 

D. 以上都不对

正确答案: B 

解析： 

 编译出错，因为构造方法是私有的，不能被调用。这种情况下不能创建对象。 

单例模式会把构造方法声明为私有的，但是会提供一个public的静态方法，用来获取对象实例。
















