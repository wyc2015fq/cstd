# 拼多多2018校招编程题 - 六一儿童节 - curryche的博客 - CSDN博客





2018年08月04日 22:03:26[curryche](https://me.csdn.net/whwan11)阅读数：135








## 题目

六一儿童节 

时间限制：1秒

空间限制：32768K

六一儿童节，老师带了很多好吃的巧克力到幼儿园。每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]>=h[i])，他才会上去表演节目。老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。可以保证每个w[i]> 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。  

输入描述: 

第一行：n，表示h数组元素个数 

 第二行：n个h数组元素 

 第三行：m，表示w数组元素个数 

 第四行：m个w数组元素
输出描述: 

上台表演学生人数

输入例子1: 

3  

 2 2 3 

 2 

 3 1 
输出例子1: 

1

## 解法

代码

```cpp
#include<iostream>
#include<stdlib.h>
#include<iomanip>
#include<math.h>
#include<algorithm>
#include<vector>
#include<functional>
#include<string>
#include<climits>
#include <cstdlib>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {};
};

TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin);
void print_tree(TreeNode* root);

int jumpFloorII(int number);

int minNumberInRotateArray(vector<int> rotateArray);

bool hasPath(char* matrix, int rows, int cols, char* str);
bool hasPath_search(char* matrix, int rows, int cols, char* str, int row, int col, int &count, bool* visit);


void quickSort(int s[], int l, int r);

int main()
{
    int h, w, i, j, result;
    cin >> h;
    int* h_stu = new int[h];

    for (i = 0; i < h; i++)
    {
        cin >> h_stu[i];
    }

    cin >> w;
    int* w_candy = new int[w];
    for (i = 0; i < w; i++)
    {
        cin >> w_candy[i];
    }

    result = 0;
    quickSort(h_stu,0,h-1);
    quickSort(w_candy,0,w-1);

    //for (i = 0; i < w; i++)
    //{
    //  cout << w_candy[i] << endl;
    //}
    //for (i = 0; i < h; i++)
    //{
    //  cout << h_stu[i] << endl;
    //}

    i = 0;
    j = 0;
    while (i < w&&j<h)
    {
        while (j<h)
        {
            if (h_stu[j] <= w_candy[i])
            {
                result++;
                i++;
                j++;
                break;
            }
            else
                j++;
        }
    }

    cout << result << endl;
    system("pause");
    return 0;
}

void quickSort(int s[], int l, int r)
{
    if (l< r)
    {
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while (i < j && s[j] <= x) // 从右向左找第一个小于x的数 
                j--;
            if (i < j)
                s[i++] = s[j];
            while (i < j && s[i]> x) // 从左向右找第一个大于等于x的数 
                i++;
            if (i < j)
                s[j--] = s[i];
        }
        s[i] = x;
        quickSort(s, l, i - 1); // 递归调用 
        quickSort(s, i + 1, r);
    }
}
```





