# 京东秋招笔试编程题 - 采购单 - curryche的博客 - CSDN博客





2018年09月12日 09:42:01[curryche](https://me.csdn.net/whwan11)阅读数：92








## 题目

题目描述

过年啦！小B高兴的不行了，她收到了很多红包，可以实现好多的愿望呢。小B可是对商店货架上心仪的货物红眼好久了，只因囊中羞涩作罢，这次她可是要大大的shopping一番。小B想去购物时，总是习惯性的把要买的东西列在一个购买清单上，每个物品单独列一行（即便要买多个某种物品），这次也不例外。

小B早早的来到了商店，由于她太激动，以至于她到达商店的时候，服务员还没有把各个商品的价签排好，所有的价签还都在柜台上。因此还需要一段时间，等服务器把价签放到对应的商品处，小B才能弄清她的购买清单所需的费用。

小B都有些迫不及待了，她希望你能够根据购买清单，帮她算算最好和最坏的情况下所需的费用，你能帮她吗？ 

输入 

输入中有多组测试数据。每组测试数据的第一行为两个整数n和m（1=＜n, m=＜1000），分别表示价签的数量以及小B的购买清单中所列的物品数。第二行为空格分隔的n个正整数，表示货架上各类物品的价格，每个数的大小不超过100000。随后的m行为购买清单中物品的名称，所有物品名称为非空的不超过32个拉丁字母构成的字符串，保证清单中不同的物品种类数不超过n，且商店有小B想要购买的所有物品。
样例输入 

5 3 

4 2 1 10 5 

apple 

orange 

mango 

6 5 

3 5 1 6 8 1 

peach 

grapefruit 

banana 

orange 

orange
输出 

对每组测试数据，在单独的行中输出两个数a和b，表示购买清单上所有的物品可能需要的最小和最大费用。

样例输出 

7 19 

11 30
时间限制 

C/C++语言：1000MS其它语言：3000MS 

内存限制 

C/C++语言：65536KB其它语言：589824KB
## 解法

主要用到了hash映射和快排

代码

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <limits>
#include<string>
#include<map>
#include<algorithm>
using namespace std;


void FindNumsAppearOnce(vector<int> data, int* num1, int *num2);
unsigned int FindFirst1Bit(int num);
bool JudgeKbitIs1(int num, unsigned int k);

bool IsContinuous(vector<int> numbers);
//void quick_sort(vector<int>* num, int start, int end);
void quick_sort(int* num, int start, int end);

bool cmp(pair<string, int> p1, pair<string, int> p2)
{
    return p1.second > p2.second;
}

int main() {

    int N, M, max_p, min_p;
    map<string, int>::iterator iter;


    while (cin >> N >> M)
    {
        max_p = 0;
        min_p = 0;

        int* price = new int[N];
        string str;
        map<string, int> product;
        for (int i = 0; i<N; i++)
            cin >> price[i];

        for (int i = 0; i<M; i++)
        {
            cin >> str;
            iter = product.find(str);
            if (iter == product.end())
                product.insert(pair<string, int>(str, 1));
            else
                iter->second++;
        }
        vector<pair<string,int>> product_vec(product.begin(), product.end());

        sort(product_vec.begin(), product_vec.end(), cmp);
        quick_sort(price,0,N-1);


        for (int i = 0; i < product_vec.size(); i++)
        {
            min_p += product_vec[i].second*price[i];
            max_p += product_vec[i].second*price[N-i-1];
        }
        cout << min_p << " " << max_p << endl;
    }

    return 0;
}







void quick_sort(int* num, int start, int end)
{
    if (start >= end)
        return;
    int i, j, pivot;
    pivot = num[start];
    i = start;
    j = end;
    while (i<j)
    {
        while (i<j && num[j] > pivot)
            j--;

        if (i<j)
            num[i++] = num[j];

        while (i<j && num[i] <= pivot)
            i++;

        if (i<j)
            num[j--] = num[i];
    }
    num[i] = pivot;
    quick_sort(num, start, i - 1);
    quick_sort(num, i + 1, end);
}
```







