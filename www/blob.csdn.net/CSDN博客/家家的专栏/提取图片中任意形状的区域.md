# 提取图片中任意形状的区域  - 家家的专栏 - CSDN博客





2010年08月23日 17:00:00[依海之燕](https://me.csdn.net/yihaizhiyan)阅读数：816








      正在做一个基于内容的图像检索项目，客户要求可以让用户提取图片上的任意形状的子图作为输入。为了实现这个功能，花了不少精力，中间绕了不少圈子。现在问题总算解决了，把主要的思路记录一下，希望能帮到有同样需求的朋友。 

      由于这个项目使用了第三方的开源图像库opencv，所以这个功能也是借助opencv来实现的。

      首先需要解决的是在图片中绘制曲线的问题，思路很简单，只需要响应鼠标事件通过描点、连线的方式就可以完成。在opencv中需要使用回调来响应鼠标事件，opencv中文站上有很好的示例，关键代码：

```
![](http://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif)![](http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif)Code

#include "cv.h"
#include "highgui.h"
#include <stdio.h>
#include <stdlib.h>

IplImage* inpaint_mask = 0;
IplImage* img0 = 0, *img = 0, *inpainted = 0;
CvPoint prev_pt = {-1,-1};

void on_mouse( int event, int x, int y, int flags, void* zhang)
{
  if( !img )
   return;
  if( event == CV_EVENT_LBUTTONUP || !(flags & CV_EVENT_FLAG_LBUTTON) )
    prev_pt = cvPoint(-1,-1);
  else if( event == CV_EVENT_LBUTTONDOWN )
    prev_pt = cvPoint(x,y);
  else if( event == CV_EVENT_MOUSEMOVE && (flags & CV_EVENT_FLAG_LBUTTON) )
  {
    CvPoint pt = cvPoint(x,y);
    if( prev_pt.x < 0 )
    prev_pt = pt;
    cvLine( inpaint_mask, prev_pt, pt, cvScalarAll(255), 5, 8, 0 );
    cvLine( img, prev_pt, pt, cvScalarAll(255), 5, 8, 0 );
    prev_pt = pt;
    cvShowImage( "image", img );
  }
}

int main( int argc, char** argv )
{
   char* filename = argc >= 2 ? argv[1] : (char*)"fruits.jpg";
   if( (img0 = cvLoadImage(filename,-1)) == 0 )
     return 0;
   printf( "Hot keys: /n"
   cvNamedWindow( "image", 1 );
   img = cvCloneImage( img0 );
   inpainted = cvCloneImage( img0 );
   inpaint_mask = cvCreateImage( cvGetSize(img), 8, 1 );
   cvZero( inpaint_mask );
   cvZero( inpainted );
   cvShowImage( "image", img );
   cvShowImage( "watershed transform", inpainted );
   cvSetMouseCallback( "image", on_mouse, 0 );   
}
```

效果如下：

![](http://images.cnblogs.com/cnblogs_com/saintbird/key.jpg)

         第二步，利用封闭曲线提取图形，时间和精力都主要浪费在这一块了，最开始的想法是通过扫描线的方法获取，但最终做出来的效果差强人意，连自己这关都过不了。最后几经转折，找到了这样一个函数cvFloodFill()，这个函数可根据边界填充图像连通域，正是我所需要的。关键代码：

```
![](http://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif)![](http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif)Code
        if(event == CV_EVENT_RBUTTONUP)
    {
        cvFloodFill(maskImg,cvPoint(x,y),cvScalarAll(255));
        cvSaveImage("maskImg.bmp",maskImg);
        IplImage *segImage=cvCreateImage(cvGetSize(img),8,3);;
        cvCopy(img,segImage,maskImg);
        cvSaveImage("segImage.bmp",segImage);
        cvCopy(segImage,proc->img);
        cvReleaseImage(&segImage);
        cvDestroyWindow("Key Image");
    }
```

```
效果如下：


            ![](http://images.cnblogs.com/cnblogs_com/saintbird/seg.jpg)
```

转自： [http://www.cnblogs.com/saintbird/archive/2008/10/27/1305003.html](http://www.cnblogs.com/saintbird/archive/2008/10/27/1305003.html)



