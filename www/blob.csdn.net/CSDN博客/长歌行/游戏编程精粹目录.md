# 游戏编程精粹目录 - 长歌行 - CSDN博客





2013年02月19日 10:37:01[iuhsihsow](https://me.csdn.net/iuhsihsow)阅读数：4206









**游戏编程精粹1**



第1章　通用编程技术

1.0　神奇的数据驱动设计(Steve Rabin)　3

1.0.1　点子1——基础　3

1.0.2　点子2——最低标准　3

1.0.3　点子3——杜绝硬编码　3

1.0.4　点子4——将控制流写成脚本　4

1.0.5　点子5——什么时候不适合使用脚本？　5

1.0.6　点子6——避免重复数据　5

1.0.7　点子7——开发工具来生成数据　6

1.0.8　结论　6

1.1　面向对象的编程与设计技术(James Boer)　7

1.1.1　代码风格　7

1.1.2　类设计　9

1.1.3　类层次结构设计　10

1.1.4　设计模式　10

1.1.5　总结　16

1.1.6　参考资料　16

1.2　使用模板元编程的快速数学方法(Pete Isensee)　17

1.2.1　斐波纳契数　17

1.2.2　阶乘　18

1.2.3　三角学　19

1.2.4　实际世界中的编译程序　20

1.2.5　重访三角学　21

1.2.6　模板和标准C++　21

1.2.7　矩阵　21

1.2.8　总结　26

1.2.9　参考文献　31

1.3　一种自动的Singleton工具(Scott Bilas)　32

1.3.1　定义　32

1.3.2　优点　32

1.3.3　问题　33

1.3.4　传统的解决方法　33

1.3.5　较好的方法　33

1.3.6　更好的方法　34

1.3.7　参考文献　35

1.4　在游戏编程中使用STL(James Boer)　36

1.4.1　STL的类型和术语　36

1.4.2　STL概念　37

1.4.3　向量(Vector)　38

1.4.4　链表(List)　40

1.4.5　双队列(Deque)　42

1.4.6　映射表(Map)　43

1.4.7　堆栈(Stack)，队列(Queue)和优先队列(Priority Queue)　46

1.4.8　总结　47

1.4.9　参考文献　47

1.5　一个通用的函数绑定接口(Scott Bilas)　48

1.5.1　要求　48

1.5.2　关于平台　48

1.5.3　第一次尝试　49

1.5.4　第二次尝试　50

1.5.5　部分解决方法　51

1.5.6　调用约定　52

1.5.7　调用函数　54

1.5.8　完备解决方案　55

1.5.9　结论　56

1.5.10　参考文献　57

1.6　通用的基于句柄的资源管理器(Scott Bilas)　58

1.6.1　方法　58

1.6.2　Handle类　59

1.6.3　HandleMgr类　60

1.6.4　使用示例　61

1.6.5　注意　61

1.6.6　参考文献　68

1.7　资源和内存管理(James Boer)　69

1.7.1　资源类　69

1.7.2　资源管理类　71

1.7.3　句柄如何工作　74

1.7.4　可能的扩展和改进　74

1.7.5　结论　75

1.8　快速数据载入技巧(John Olsen)　76

1.8.1　预处理你的数据　76

1.8.2　保存你的数据　76

1.8.3　使用简单方法载入你的数据　77

1.8.4　更安全地载入你的数据　78

1.9　基于帧的内存分配(Steven Ranck)　80

1.9.1　常规内存分配的挑战　80

1.9.2　介绍基于帧的内存　80

1.9.3　分配和释放内存　82

1.9.4　例子　84

1.9.5　结论　86

1.10　简单快速的位数组(Andrew Kirmse)　87

1.10.1　概述　87

1.10.2　位数组　87

1.10.3　其他数组　88

1.10.4　应用　89

1.10.5　参考文献　89

1.11　在线游戏的网络协议(Andrew Kirmse)　90

1.11.1　定义　90

1.11.2　篡改报文　90

1.11.3　报文重放　91

1.11.4　其他技术　92

1.11.5　逆向工程　92

1.11.6　实现　93

1.11.7　参考文献　93

1.12　最大限度地利用Assert(Steve Rabin)　94

1.12.1　Assert基础　94

1.12.2　Assert技巧 #1：嵌入更多信息　95

1.12.3　Assert技巧 #2：嵌入更多更多信息　95

1.12.4　Assert技巧 #3：使之更好用一些　96

1.12.5　Assert技巧 #4：编写自己的assert宏　96

1.12.6　Assert技巧 #5：无价之宝　97

1.12.7　Assert技巧 #6：给“超级铁杆”　97

1.12.8　Assert技巧 #7：让它更简单——复制和粘贴　98

1.12.9　参考文献　98

1.13　Stats：实时统计和游戏内调试(John Olsen)　99

1.13.1　Why：需求驱动的技术　99

1.13.2　How：一个进化过程　100

1.13.3　What：一个基于C++类的系统　100

1.13.4　Where：可用性　102

1.13.5　小结　102

1.14　实时的游戏内建剖析(Steve Rabin)　103

1.14.1　开始考虑细节　103

1.14.2　剖析器将告诉你什么？　104

1.14.3　增加剖析器调用　105

1.14.4　剖析器的实现　106

1.14.5　ProfileBegin的细节　107

1.14.6　ProfileEnd的细节　107

1.14.7　处理剖析数据的细节　107

1.14.8　后期增强　108

1.14.9　将它们组合起来　108

1.14.10　参考文献　113


第2章　数学技巧

2.0　可预测随机数(Guy W. Lecky-Thompson)　117

2.0.1　可预测随机数　117

2.0.2　替换算法　119

2.0.3　无限宇宙算法　120

2.0.4　结论与展望　122

2.0.5　参考文献　123

2.1　插值方法(John Olsen)　124

2.1.1　使用浮点数学的帧速相关ease-out　124

2.1.2　使用整型数学的帧速相关ease-out　125

2.1.3　帧速无关线性内插　126

2.1.4　帧速无关ease-in和ease-out　127

2.1.5　危险地带　128

2.2　求刚体运动方程的积分(Miguel Gomez)　132

2.2.1　运动学：平移和旋转　132

2.2.2　动力学：力与旋转力矩(torque)　135

2.2.3　刚体的特性　136

2.2.4　求运动方程的积分　139

2.2.5　参考文献　140

2.3　三角函数的多项式逼近(Eddie Edwards)　141

2.3.1　多项式　142

2.3.2　定义域和值域　143

2.3.3　偶多项式和奇多项式　146

2.3.4　泰勒级数　146

2.3.5　截断的泰勒级数　149

2.3.6　拉格朗日级数　150

2.3.7　不连续性处理　153

2.3.8　结论　153

2.4　为数字稳定性而利用隐式欧拉积分(Miguel Gomez)　155

2.4.1　求初值问题的积分及稳定性　155

2.4.2　显式的欧拉方法　155

2.4.3　隐式欧拉方法　156

2.4.4　不准确性　158

2.4.5　寻找隐式解　158

2.4.6　结论　158

2.4.7　参考文献　158

2.5　小波：理论与压缩(Lo?c Le Chevalier)　160

2.5.1　原理　160

2.5.2　一个实例　162

2.5.3　应用　162

2.5.4　参考文献　163

2.6　水面的交互式模拟(Miguel Gomez)　164

2.6.1　二维波动方程　164

2.6.2　边界条件：岛屿和海岸线　166

2.6.3　实现问题　166

2.6.4　与水面交互　167

2.6.5　渲染　169

2.6.6　参考文献　170

2.7　游戏编程四元数(Jan Svarovsky)　171

2.7.1　将四元数当作矩阵替换物　171

2.7.2　为什么不使用欧拉角　172

2.7.3　X、Y、Z和W代表什么　172

2.7.4　源自什么数学基础　173

2.7.5　四元数如何表示旋转　174

2.7.6　参考文献　174

2.8　矩阵和四元数之间的转换(Jason Shankel)　175

2.8.1　四元数旋转　175

2.8.2　四元数到矩阵的转换　175

2.8.3　矩阵到四元数的转换　177

2.8.4　参考文献　178

2.9　四元数插值(Jason Shankel)　179

2.9.1　四元数计算　179

2.9.2　四元数插值　179

2.9.3　示例代码　182

2.9.4　推导　182

2.10　最短弧四元数(Stan Melax)　186

2.10.1　动机　186

2.10.2　数值不稳定性　186

2.10.3　稳定公式的推导　187

2.10.4　残存不稳定性条件　188

2.10.5　源代码　188

2.10.6　虚拟跟踪球　189

2.10.7　参考文献　189


第3章　人工智能

3.0　设计一个通用、健壮的AI引擎(Steve Rabin)　193

3.0.1　事件驱动与轮询的对比　193

3.0.2　消息概念　194

3.0.3　状态机　194

3.0.4　一个使用消息的事件驱动状态机　194

3.0.5　交待时间(Confession Time)　197

3.0.6　另一个小交待　197

3.0.7　状态机构建单元　198

3.0.8　状态机消息路由选择　198

3.0.9　发送消息　200

3.0.10　发送延迟的消息　200

3.0.11　删除游戏对象　201

3.0.12　增强：定义消息的范围　201

3.0.13　增强：记录所有的消息活动和状态变迁　203

3.0.14　增强：交换状态机　203

3.0.15　增强：多状态机　203

3.0.16　增强：一个状态机队列　204

3.0.17　代码外部脚本化行为　204

3.0.18　结论　204

3.0.19　参考文献　207

3.1　一个有限状态机类(Eric Dybsand)　208

3.1.1　FSMclass和FSMstate　210

3.1.2　定义FSMstate　210

3.1.3　定义FSMclass　211

3.1.4　为FSM创建状态　212

3.1.5　使用FSM　213

3.1.6　参考文献　219

3.2　博弈树(Jan Svarovsky)　220

3.2.1　极小极大算法的负极大改进算法　221

3.2.2　 剪枝　222

3.2.3　走步排序方法　223

3.2.4　 求精　224

3.2.5　参考文献　224

3.3　A*路径规划基础(Bryan Stout)　225

3.3.1　问题　225

3.3.2　方法概述　225

3.3.3　A*的特性　227

3.3.4　将A*应用到游戏路径规划　227

3.3.5　A*的弱点　231

3.3.6　进一步的工作　232

3.3.7　参考文献　232

3.4　A*审美优化(Steve Rabin)　233

3.4.1　直路径　233

3.4.2　多边形搜索空间中的直路径　234

3.4.3　平滑路径　234

3.4.4　预先计算的Catmull-Rom公式　235

3.4.5　改进分级路径的直接性　236

3.4.6　空旷区域上的分级寻径　238

3.4.7　在分级搜寻过程中减少停顿　238

3.4.8　最大化响应率　239

3.4.9　结论　239

3.4.10　参考文献　239

3.5　A*速度优化(Steve Rabin)　240

3.5.1　搜索空间优化　240

3.5.2　算法优化　244

3.5.3　结论　248

3.5.4　参考文献　253

3.6　简化的3D运动和使用导航网格进行寻径(Greg Snook)　254

3.6.1　简述　254

3.6.2　构造　255

3.6.3　滚动骰子并且移动鼠标　256

3.6.4　到此仅完成一半　258

3.6.5　它是有效的，但不是那么完美　260

3.6.6　结论　261

3.6.7　参考文献　269

3.7　Flocking：一种模拟群体行为的简单技术(Steven Woodcock)　270

3.7.1　实现　271

3.7.2　代码　273

3.7.3　局限性与可能的改进　276

3.7.4　资源与致谢　282

3.8　用于视频游戏的模糊逻辑(Mason McCuskey)　283

3.8.1　模糊逻辑如何工作　283

3.8.2　模糊逻辑运算　285

3.8.3　为模糊控制而刹车　286

3.8.4　模糊逻辑的其他应用　291

3.8.5　结论　291

3.8.6　资源　291

3.9　神经网络初探(André LaMothe)　292

3.9.1　生物学仿真　292

3.9.2　对游戏的应用　293

3.9.3　神经网络101　294

3.9.4　纯逻辑，Mr. Spock　298

3.9.5　分类与“图像”识别　302

3.9.6　Hebbian的Ebb　305

3.9.7　运行Hopfield　306

3.9.8　结论　309


第4章　多边形技术

4.0　为OpenGL优化顶点提交(Herbert Marselas)　313

4.0.1　即时模式　313

4.0.2　交叉存取数据　314

4.0.3　步数据和流数据　315

4.0.4　编译过的顶点数组　316

4.0.5　取消数据复制厂家指定扩展　317

4.0.6　数据格式　317

4.0.7　一般建议　318

4.0.8　结论　318

4.0.9　参考文献　319

4.1　调整顶点的投影深度值(Eric Lengyel)　320

4.1.1　考察投影矩阵　320

4.1.2　矫正深度值　321

4.1.3　选择一个适当的 　321

4.1.4　实现　323

4.1.5　源代码　323

4.2　矢量摄像机(David Paull)　324

4.2.1　矢量摄像机初步　325

4.2.2　本地空间优化　326

4.2.3　结论　327

4.3　摄像机控制技术(Dante Treglia II)　328

4.3.1　一种基本的第一人称摄像机　328

4.3.2　脚本摄像机　330

4.3.3　摄像机技巧　333

4.4　一种快速的圆柱棱台相交测试算法(Eric Lengyel)　337

4.4.1　视域棱台　337

4.4.2　计算有效半径　338

4.4.3　算法　339

4.4.4　实现　341

4.5　3D碰撞检测(Kevin Kaiser)　346

4.5.1　算法概述　346

4.5.2　包围球碰撞检测　346

4.5.3　三角形对三角形的碰撞检测　348

4.6　用于交互检测的多分辨率地图(Jan Svarovsky)　358

4.6.1　使用栅格　358

4.6.2　对象大小变化的问题　358

4.6.3　多分辨率地图　359

4.6.4　源代码　360

4.7　计算到区域内部的距离(Steven Ranck)　368

4.7.1　问题　368

4.7.2　算法描述　369

4.7.3　应用　371

4.8　对象阻塞剔除(Tim Round)　376

4.8.1　可视棱台裁剪　376

4.8.2　阻塞剔除　378

4.8.3　总结　379

4.9　永远不要让他们看到你的“抖动”——几何体细节层次选择问题(Yossarian King)　387

4.9.1　LOD选择　387

4.9.2　放大率因子　389

4.9.3　滞变阈值　389

4.9.4　实现　390

4.9.5　其他问题　391

4.10　八叉树构造(Dan Ginsburg)　393

4.10.1　八叉树概述　393

4.10.2　八叉树数据　394

4.10.3　建立树　394

4.10.4　多边形重叠　395

4.10.5　相邻节点　396

4.10.6　应用　396

4.10.7　结论　396

4.10.8　参考文献　397

4.11　松散的八叉树(Thatcher Ulrich)　398

4.11.1　四叉树　398

4.11.2　包围体　399

4.11.3　划分物体　400

4.11.4　使它松散　402

4.11.5　比较　405

4.11.6　结论　406

4.12　独立于观察的渐进网格(Jan Svarovsky)　407

4.12.1　渐进网格概述　407

4.12.2　关于这个主题的变种　408

4.12.3　边缘选择函数　410

4.12.4　难处理的边　410

4.12.5　实现　411

4.12.6　源代码　414

4.12.7　参考文献　415

4.13　插值的3D关键帧动画(Herbert Marselas)　416

4.13.1　线性插值　416

4.13.2　对顶点和法线进行插值　418

4.13.3　Hermite样条插值　418

4.13.4　对顶点进行样条插值　420

4.13.5　为什么用Hermite样条　421

4.13.6　总结　421

4.13.7　参考文献　421

4.14　一种快速而简单的皮肤构造技术(Torgeir Hagland)　422

4.14.1　为什么对低多边形有价值　422

4.14.2　方法　422

4.14.3　总结　423

4.14.4　参考文献　426

4.15　填充间隙——使用缝合和皮肤构造的高级动画(Ryan Woodland)　427

4.15.1　缝合　428

4.15.2　皮肤构造(Skinning)　430

4.15.3　进一步的问题　432

4.15.4　参考文献　434

4.16　实时真实地形生成(Guy W. Lecky-Thompson)　434

4.16.1　风景设计　434

4.16.2　建筑物　439

4.16.3　命名算法　442

4.16.4　参考文献　446

4.17　分形地形生成——断层构造(Jason Shankel)　447

4.17.1　断层构造　447

4.17.2　减少dHeight　447

4.17.3　生成随机直线　448

4.17.4　腐蚀(erosion)　449

4.17.5　示例代码　450

4.17.6　参考文献　450

4.18　分形地形生成——中点置换(Jason Shankel)　451

4.18.1　一维中点置换　451

4.18.2　二维中点置换——菱形正方形算法　452

4.18.3　高地中的菱形——正方形算法　454

4.19　分形地形生成——粒子沉积(Jason Shankel)　455

4.19.1　MBE模型　455

4.19.2　粒子沉积　455

4.19.3　倒置火山口　457

4.19.4　示例代码　458

4.19.5　参考文献　458


第5章　像素特效

5.0　2D镜头光晕(Yossarian King)　461

5.0.1　方法　461

5.0.2　实现　462

5.0.3　源代码　464

5.1　将3D硬件用于2D子画面特效(MasonMcCuskey)　465

5.1.1　进入3D　465

5.1.2　建立3D场景　465

5.1.3　建立纹理　466

5.1.4　绘制3D子画面　466

5.1.5　添加特效　468

5.1.6　结论　468

5.2　基于运动的静态光照(Steven Ranck)　469

5.2.1　传统的静态光照　469

5.2.2　基于运动的静态光照　472

5.2.3　结论　477

5.3　使用定点颜色插值模拟实时光照(Jorge Freitas)　478

5.3.1　光照方法　478

5.3.2　美工创作　479

5.3.3　插值光照　479

5.3.4　结论　480

5.4　衰减图(Sim Dietrich)　485

5.4.1　讲解　485

5.4.2　比较衰减图与光照图　488

5.4.3　CSG效果　489

5.4.4　基于范围的雾　489

5.4.5　其他形状　489

5.4.6　结论　489

5.5　使用纹理坐标生成技术的高级纹理(Ryan Woodland)　490

5.5.1　简单纹理坐标动画　490

5.5.2　纹理投影　490

5.5.3　反射映射　493

5.5.4　参考文献　494

5.6　硬件凹凸贴图(Sim Dietrich)　495

5.6.1　如何将凹凸图应用于对象上　495

5.6.2　为法线选择一个空间　496

5.6.3　另一种方法：使用正切空间凹凸贴图　496

5.6.4　解决方案：纹理空间凹凸贴图　498

5.6.5　纹理空间问题　499

5.6.6　结论　499

5.6.7　参考文献　500

5.7　底面阴影(Yossarian King)　501

5.7.1　阴影数学　501

5.7.2　实现　503

5.7.3　扩展　504

5.8　复杂对象上的实时阴影(Gabor Nagy)　505

5.8.1　介绍　505

5.8.2　光源、遮挡物体和接收物体　505

5.8.3　本文的目的　507

5.8.4　创建阴影图　507

5.8.5　在接收物体上投影阴影图　513

5.8.6　渲染接收物体　514

5.8.7　对基本算法的扩展与改进　514

5.8.8　参考文献　515

5.9　使用光滑预过滤和Fresnel项改善环境映射反射(Anis Ahmad)　516

5.9.1　第一个不正确的假设　516

5.9.2　第二个不正确的假设　518

5.9.3　结论　518

5.9.4　致谢　519

5.9.5　参考文献　519

5.10　游戏中玻璃的效果(Gabor Nagy)　520

5.10.1　介绍　520

5.10.2　透明物体　520

5.10.3　光栅化程序、帧缓冲、Z缓冲和像素混合　520

5.10.4　不透明物体与透明物体　521

5.10.5　绘制不透明物体　522

5.10.6　绘制透明物体　522

5.10.7　反射　525

5.10.8　有色玻璃　525

5.10.9　将它们放到一起　525

5.10.10　实现　526

5.10.11　参考文献　526

5.11　用于容器中液体的折射贴图(Alex Vlachos，Jason L. Mitchell)　527

5.11.1　介绍　527

5.11.2　折射项　527

5.11.3　反射项　528

5.11.4　Fresnel项　529

5.11.5　使用硬件渲染　529

5.11.6　该技术的扩展　530

5.11.7　结论　531

5.11.8　参考文献　531


第6章　附录

6.0　矩阵工具库(Dante Treglia II，Mark A. DeLoura)　535

6.1　文本工具库(Dante Treglia II)　537

6.2　关于随书光盘(Mark A. DeLoura)　538

作者索引　539








































































游戏编程精粹2



第1章 通用编程技术 

绪 论　3 

Scott Bilas 

1.1 优化C++游戏　5 

Andrew Kirmse 

1.1.1 对象的创建和销毁　5 

1.1.2 内存管理　8 

1.1.3 虚拟函数　9 

1.1.4 代码长度　10 

1.1.5 标准模板库　11 

1.1.6 高级特性　12 

1.1.7 参考文献　13 

1.2 内联函数和宏　14 

Peter Dalton 

1.2.1 内联函数的优点　14 

1.2.2 何时使用内联函数　15 

1.2.3 何时使用宏　16 

1.2.4 微软特有的情况　16 

1.2.5 参考文献　17 

1.3 抽象接口编程　18 

.Noel Liopis 

1.3.1 抽象接口　18 

1.3.2 添加一个工厂（factory）　19 

1.3.3 抽象接口特性　21 

1.3.4 一切都是有代价的　23 

1.3.5 结论　24 

1.3.6 参考文献　24 

1.4 从DLL中导出C++类　25 

Herb Marselas 

1.4.1 导出函数　25 

1.4.2 导出类　25 

1.4.3 导出类成员函数　27 

1.4.4 导出虚拟类成员函数　27 

1.4.5 总结　28 

1.5 避免DLL困境　29 

Herb Marselas 

1.5.1 显式链接还是隐式链接　29 

1.5.2 LoadLibrary和GetProcAddress　30 

1.5.3 提防DirectX　30 

1.5.4 使用操作系统特有的特性　31 

1.5.5 总结　32 

1.6 动态类型信息　34 

Scott Wakeling 

1.6.1 动态类型信息类简介　34 

1.6.2 暴露和查询DTI　35 

1.6.3 继承的含义是“是一个”　36 

1.6.4 处理通用对象　37 

1.6.5 实现永久性类型信息　38 

1.6.6 将永久性类型信息用于游戏保存数据库中　39 

1.6.7 结论　40 

1.6.8 参考文献　40 

1.7 用于通用C++成员访问的属性类　41 

Charles Cafrelli 

1.7.1 代码　41 

1.7.2 其他用途　44 

1.7.3 推荐读物　44 

1.8 一个游戏实体工厂　45 

Fran?ois Dominic Laramée 

1.8.1 组件　45 

1.8.2 flyweight类、行为类和导出类　45 

1.8.3 flyweight对象　46 

1.8.4 SAMMy，你在哪里?　46 

1.8.5 行为类层次　47 

1.8.6 使用模板方法模式来完成行为任务　48 

1.8.7 导出类　49 

1.8.8 实体工厂　50 

1.8.9 在运行阶段选择策略　52 

1.8.10 最后的注意事项　53 

1.8.11 参考文献　53 

1.9 在C++添加摒弃功能　55 

Noel Llopis 

1.9.1 可能的解决方案　55 

1.9.2 理想的解决方案　55 

1.9.3 使用和指定被摒弃的函数　56 

1.9.4 使用C++实现摒弃功能　56 

1.9.5 可改进的地方　58 

1.9.6 致谢　58 

1.9.7 参考文献　58 

1.10 一个插入式调试内存管理器　59 

Peter Dalton 

1.10.1 内存管理器初步　59 

1.10.2 内存管理器的记录工作　60 

1.10.3 报告信息　62 

1.10.4 注意事项　63 

1.10.5 进一步的改进　64 

1.10.6 参考文献　64 

1.11 一个内置的游戏剖析模块　66 

Jeff Evertt 

1.11.1 有关剖析的基本知识　66 

1.11.2 商用工具　67 

1.11.3 为何要自己开发模块　67 

1.11.4 剖析模块（Profiling module）的需求　68 

1.11.5 架构和实现　68 

1.11.6 实现的细节　69 

1.11.7 分析数据　69 

1.11.8 有关实现的注意事项　70 

1.12 用于Windows游戏的线性编程模型　71 

Javier F. Otaegui 

1.12.1 更新背景　71 

1.12.2 解决方案：多线程（Multithreading）　72 

1.12.3 参考文献　75 

1.13 栈缠绕　76 

Bryon Hapgood 

1.13.1 简单的TempRet　76 

1.13.2 TempRet链　77 

1.13.3 Thunking　78 

1.13.4 递归　80 

1.14 自我修改的代码　82 

Bryon Hapgood 

1.14.1 RAM代码的原理　82 

1.14.2 一个快速的Bit Blitter　83 

1.15 使用资源文件来管理文件　91 

Bruno Sousa 

1.15.1 何为资源文件　91 

1.15.2 设计　92 

1.15.3 实现　93 

1.15.4 有关实现的最后一些说明　94 

1.15.5 结论　95 

1.15.6 参考文献　95 

1.16 游戏输入的记录和重放　96 

Bruce Dawson 

1.16.1 记录输入有何用途　96 

1.16.2 原理　97 

1.16.3 测试输入记录功能　100 

1.16.4 结论　100 

1.16.5 参考文献　101 

1.17 一个灵活的文本分析系统　102 

James Boer 

1.17.1 分析系统　102 

1.17.2 宏、头文件和预处理技术　103 

1.17.3 该分析系统的结构　104 

1.17.4 小结　106 

1.18 一个通用的调节器　107 

Lasse Staff Jensen 

1.18.1 需求分析　107 

1.18.2 实现　107 

1.18.3 使用　112 

1.18.4 图形用户界面　112 

1.18.5 附注　114 

1.18.6 致谢　114 

1.19 生成真正的随机数　115 

Pete Isensee 

1.19.1 伪随机　115 

1.19.2 真正随机　115 

1.19.3 随机输入源　116 

1.19.4 硬件源　116 

1.19.5 混合函数　117 

1.19.6 局限性　117 

1.19.7 实现　117 

1.19.8 GenRand的随机程度　119 

1.19.9 参考文献　119 

1.20 使用Bloom过滤器来提高计算性能　120 

Mark Fischer 

1.20.1 Bloom的方式　120 

1.20.2 可能的情形　120 

1.20.3 工作原理　121 

1.20.4 定义　121 

1.20.5 范例1　121 

1.20.6 范例2　125 

1.20.7 最后的说明　125 

1.20.8 结论　126 

1.20.9 参考文献　126 

1.21 3Ds MAX中的Skin导出器和动画工具包　127 

Marco Tombesi 

1.21.1 导出　128 

1.21.2 参考文献　137 

1.22 在视频游戏中使用Web摄像机　138 

Nathan d'Obrenan 

1.22.1 初始化Web摄像机捕获窗口　138 

1.22.2 操纵Web摄像机数据　143 

1.22.3 结论　147 

1.22.4 参考文献　147 

第2章 数学技巧 

绪 论　151 

Eddie Edwards 

2.1 浮点计算技巧：使用IEEE浮点格式以提高性能　152 

Yossarian King 

2.1.1 概述　152 

2.1.2 IEEE浮点格式　152 

2.1.3 浮点数技巧　153 

2.1.4 用于正弦和余弦函数的线性查找表　158 

2.1.5 平方根函数的对数优化　160 

2.1.6 优化任何函数　161 

2.1.7 性能测量　163 

2.1.8 结论　163 

2.1.9 参考文献　164 


2.2 矢量和平面技巧　165 

John Olsen 

2.2.1 相对于碰撞面的高度　165 

2.2.2 找出碰撞点　166 

2.2.3 到碰撞点的距离　167 

2.2.4 反射式碰撞　168 

2.2.5 阻尼碰撞　170 

2.3 一种快速、健壮的计算3D线段交点的方法　172 

Graham Rhodes 

2.3.1 这种算法健壮的原因　172 

2.3.2 问题描述　172 

2.3.3 推导闭式解决方案方程　174 

2.3.4 线段　179 

2.3.5 实现描述　181 

2.3.6 可优化的地方　181 

2.3.7 结论　182 

2.3.8 参考文献　182 

2.4 反向弹道计算　183 

Aaron Nicholls 

2.4.1 一种特殊情况　184 

2.4.2 优化实现　189 

2.4.3 总结　190 

2.5 平行移动镜头　191 

Carl Dougan 

2.5.1 技术　191 

2.5.2 结论　194 

2.5.3 参考文献　194 

2.6 平滑的基于四元数的C2飞行路径　195 

Alex Vlachos 

2.6.1 导论　195 

2.6.2 位置插值　195 

2.6.3 朝向插值　196 

2.6.4 旋转方向和选择性求负　197 

2.6.5 四元数样条线插值　198 

2.6.6 有理映射中的奇异点　199 

2.6.7 镜头剪接　199 

2.6.8 代码　199 

2.6.9 参考文献　200 

2.7 递归逐维分组：一种快速的碰撞检测算法　201 

Steve Rabin 

2.7.1 其他应用　202 

2.7.2 该算法的缺陷　205 

2.7.3 查找碰撞物体对　206 

2.7.4 时间复杂度　208 

2.7.5 结论　209 

2.7.6 参考文献　209 

2.8 不规则碎片编程　210 

Jesse Laeuchli 

2.8.1 无规则碎片　210 

2.8.2 断层无规则碎片　211 

2.8.3 FBM　211 

2.8.4 实现　212 

2.8.5 使用FBM　215 

2.8.6 参考文献　216 

第3章 人工智能 

绪 论　219 

Steve Rabin 

3.1 AI优化策略　221 

Steve Rabin 

3.1.1 策略1：使用事件驱动行为而非轮询　221 

3.1.2 策略2：减少重复计算　222 

3.1.3 策略3：由管理员集中进行协调　222 

3.1.4 策略4：不那么频繁地运行AI　222 

3.1.5 策略5：将处理工作分散到多帧中完成　223 

3.1.6 策略6：利用细节级AI　223 

3.1.7 策略7：只解决问题的一部分　223 

3.1.8 策略8：离线完成困难的工作　224 

3.1.9 策略9：使用突发行为以避免编写脚本　224 

3.1.10 策略10：通过连续记录来分摊查询成本　224 

3.1.11 策略11：重新考虑问题　225 

3.1.12 结论　225 

3.1.13 参考文献　226 

3.2 用于游戏对象AI的微线程　227 

Bruce Dawson 

3.2.1 一个更简单的方法　228 

3.2.2 微线程　229 

3.2.3 栈管理　230 

3.2.4 并发症　231 

3.2.5 结论　232 

3.2.6 参考文献　232 

3.3 使用微线程管理AI　233 

Simon Carter 

3.3.1 拼凑　233 

3.3.2 良好的行为　233 

3.3.3 了然于胸　234 

3.3.4 并发症　236 

3.3.5 结论　238 

3.3.6 参考文献　239 

3.4 一种RTS命令排队体系结构　240 

Steve Rabin 

3.4.1 RTS命令　240 

3.4.2 命令排队　240 

3.4.3 循环命令　242 

3.4.4 结论　244 

3.4.5 参考文献　244 

3.5 一种基于分片的高性能视域和搜索系统　245 

Matt Pritchard 

3.5.1 概述　245 

3.5.2 定义　245 

3.5.3 组件1：各个玩家的可见性地图　246 

3.5.4 组件2：LOS模板　246 

3.5.5 组件3：合并的可视性地图　248 

3.5.6 改进搜索　249 

3.5.7 结论　251 

3.6 创建影响力地图　252 

Paul Tozour 

3.6.1 影响力地图　252 

3.6.2 一个简单的影响力地图　253 

3.6.3 影响力地图中的单元格数据　254 

3.6.4 计算合意值　255 

3.6.5 确定最佳的单元格大小　256 

3.6.6 影响力传播　256 

3.6.7 考虑地形　257 

3.6.8 特别考虑　258 

3.6.9 刷新影响力地图　259 

3.6.10 3D环境中的影响力地图　259 

3.6.11 参考文献和推荐读物　260 

3.7 策略评估技术　261 

Paul Tozour 

3.7.1 资源分配树　261 

3.7.2 计算希望的资源分配　262 

3.7.3 判断当前的分配情况　263 

3.7.4 策略决策　263 

3.7.5 值的估量　264 

3.7.6 依存图　264 

3.7.7 依存图节点　265 

3.7.8 经济规划　265 

3.7.9 查找脆弱的依存　266 

3.7.10 策略推理　266 

3.7.11 玩家个性　267 

3.7.12 总结　267 

3.7.13 参考文献　267 

3.8 3D游戏中的地形推理　269 

William van der Sterren 

3.8.1 以方便推理的方式表示地形　269 

3.8.2 中继点（waypoint）　270 

3.8.3 范例地形和AI需求　270 

3.8.4 战术分析（tactical analysis）　270 

3.8.5 从战术价值到中继点属性　271 

3.8.6 计算中继点属性　272 

3.8.7 从经验中学习　274 

3.8.8 将地形推理加入到游戏中　275 

3.8.9 其他应用　275 

3.8.10 结论　276 

3.8.11 参考文献和推荐读物　276 

3.9 用于可视点寻径的扩展几何体　277 

Thomas Young 

3.9.1 定义碰撞模型　277 

3.9.2 多边形寻径　278 

3.9.3 扩展并解决问题　278 

3.9.4 凸多边形的闵可夫斯基和　279 

3.9.5 扩展非凸几何体　280 

3.9.6 选择碰撞形状　281 

3.9.7 结论　281 

3.9.8 参考文献　281 

3.10 优化可视点寻径　283 

Thomas Young 

3.10.1 可视点寻径（points-of-visibility pathfinding）　283 

3.10.2 存储到每个点的最短路径　283 

3.10.3 将凸角相连　284 

3.10.4 轮廓区　285 

3.10.5 将轮廓区用于空间分区系统　287 

3.10.6 结论　287 

3.10.7 参考文献　287 

3.11 有齿物群的模拟：捕食者和猎物　288 

Steven Woodcock 

3.11.1 全新的世界　289 

3.11.2 有齿物群的模拟　291 

3.11.3 局限性和可改进的地方　291 

3.11.4 参考文献　292 

3.12 一个用C++编写的通用模糊状态机　293 

Eric Dybsand 

3.12.1 为何在游戏中使用FuSM　294 

3.12.2 如何在游戏中使用FuSM　294 

3.12.3 复习《游戏编程精粹1》中的C++通用有限状态机　295 

3.12.4 将通用FSM修改为FuSM　295 

3.12.5 在游戏中使用模糊逻辑　296 

3.12.6 参考文献　296 

3.13 避免模糊系统中的组合激增　297 

Michael Zarozinski 

3.13.1 问题　297 

3.13.2 解决方案　298 

3.13.3 范例　299 

3.13.4 结论　303 

3.13.5 参考文献　303 

3.14 一个在游戏中使用神经元网络的例子　304 

John Manslow 

3.14.1 游戏　304 

3.14.2 多玩家感知器　304 

3.14.3 选择输入　306 

3.14.4 收集数据　306 

3.14.5 训练MLP　307 

3.14.6 结果　308 

3.14.7 结论　308 

3.14.8 参考文献　309 

第4章 几何体管理 

绪 论　313 

Eric Lengyel 

4.1 各种VIPM方法的比较　314 

Tom Forsyth 

4.1.1 考虑因素　314 

4.1.2 Vanilla VIPM　316 

4.1.3 跳带　319 

4.1.4 多层跳带　319 

4.1.5 混合模式VIPM　320 

4.1.6 混合模式跳带　321 

4.1.7 滑窗　321 

4.1.8 小结　324 

4.1.9 参考文献　325 

4.2 使用联锁分片简化地形　326 

Greg Snook 

4.2.1 分片的重访问　327 

4.2.2 生成地图　328 

4.2.3 分片模板　328 

4.2.4 消除难看的接缝　329 

4.2.5 更好、更快、更强　330 

4.2.6 结论　331 

4.2.7 参考文献　331 

4.3 快速可视剔除、射线跟踪以及范围搜索的球形树　332 

John W. Ratcliff 

4.3.1 包围球　332 

4.3.2 使用球形树　332 

4.3.3 演示应用程序　333 

4.4 压缩的轴向包围盒树　335 

Miguel Gomez 

4.4.1 概览层次排序方法　335 

4.4.2 AABB树　336 

4.4.3 构建AABB树　336 

4.4.4 压缩AABB树　337 

4.4.5 近似范围　337 

4.4.6 利用冗余　338 

4.4.7 运行时效　339 

4.4.8 将来的工作　339 

4.4.9 参考文献　339 

4.5 直接访问四叉树查找　340 

Matt Pritchard 

4.5.1 性能剖析　340 

4.5.2 消除中间阻碍　341 

4.5.3 条件和要求　341 

4.5.4 判断树层　341 

4.5.5 位置映射　343 

4.5.6 判断位置　344 

4.5.7 遍历四叉树　344 

4.5.8 优化四叉树　344 

4.6 近似鱼缸折射　347 

Alex Vlachos 

4.6.1 鱼缸观察现象　347 

4.6.2 提高其真实性　349 

4.6.3 结论　349 

4.7 渲染打印分辨率的屏幕快照　350 

Alex Vlachos 

4.7.1 基本算法　350 

4.7.2 忠告及注意　353 

4.7.3 结论　353 

4.7.4 参考文献　353 

4.8 对任意表面应用贴花　354 

Eric Lengyel 

4.8.1 算法　354 

4.8.2 三角形剪裁　356 

4.8.3 实现代码　357 

4.8.4 参考文献　357 

4.9 用天空包围盒渲染远景　358 

Jason Shankel 

4.9.1 基本技术　358 

4.9.2 天空包围盒分辨率　359 

4.9.3 天空包围盒大小　359 

4.9.4 渲染场景　360 

4.9.5 立方体环境映射　360 

4.9.6 生成天空包围盒纹理　361 

4.9.7 结论　361 

4.9.8 源代码　361 

4.10 自阴影角色　362 

Alex Vlachos, David Gosselin, Jason L. Mitchell 

4.10.1 研究回顾　362 

4.10.2 角色几何分割　362 

4.10.3 渲染纹理　362 

4.10.4 渲染角色　363 

4.10.5 结论　364 

4.10.6 参考文献　364 

4.11 经典的Super Mario 64游戏第三人称控制和动画　365 

Steve Rabin 

4.11.1 设置　365 

4.11.2 转换控制器的输入　365 

4.11.3 旋转角色　367 

4.11.4 角色移动　368 

4.11.5 角色动画　368 

4.11.6 Super Mario 64动画分析　370 

4.11.7 结论　371 

4.11.8 参考文献　371 

第5章 图形显示 

绪 论　375 

D. Sim Dietrich Jr 

5.1 卡通渲染：实时轮廓边缘检测与渲染　376 

Carl S. Marshall 

5.1.1 着墨器（Inker）　376 

5.1.2 重要的边　377 

5.1.3 轮廓边缘检测技术　377 

5.1.4 基于边的着墨　377 

5.1.5 可编程顶点着色器着墨　379 

5.1.6 高级纹理特征着墨　381 

5.1.7 结论　381 

5.1.8 参考文献　382 

5.2 使用纹理映射的卡通渲染与可编程顶点着色器　383 

Adam Lake 

5.2.1 卡通着色技术　383 

5.2.2 上色　383 

5.2.3 可编程顶点着色器　386 

5.2.4 结论　388 

5.2.5 参考文献　388 

5.3 动态逐像素光照技术　389 

Dan Ginsburg, Dave Gosselin 

5.3.1 动态光照贴图的3D纹理　389 

5.3.2 Dot3凹凸贴图（Bump Mapping）　391 

5.3.3 使用立方贴图规一化　395 

5.3.4 逐像素聚光灯（Per-Pixel Spotlight）　396 

5.3.5 参考文献　396 

5.4 使用3D硬件生成过程云彩　398 

Kim Pallister 

5.4.1 云彩性质　398 

5.4.2 生成随机数　399 

5.4.3 噪音多个倍频的动画　401 

5.4.4 贴图到天空几何体　403 

5.4.5 功能延伸　404 

5.4.6 硬件限制　404 

5.4.7 可伸缩性　405 

5.4.8 结论　405 

5.4.9 参考文献　406 

5.5 针对较快镜头眩光的纹理屏蔽　407 

Chris Maughan 

5.5.1 镜头眩光遮挡　407 

5.5.2 硬件问题　407 

5.5.3 纹理屏蔽　409 

5.5.4 性能考虑　410 

5.5.5 改进　411 

5.5.6 示例代码　411 

5.5.7 替代途径　412 

5.5.8 参考文献　412 

5.6 实用优先缓冲阴影　413 

D. Sim Dietrich Jr. 

5.6.1 比较优先缓冲与深度缓冲　415 

5.6.2 解决锯齿化问题　416 

5.6.3 混合途径　417 

5.6.4 小结　418 

5.6.5 参考文献　418 

5.7 替用体技术：添加点缀　419 

Tom Forsyth 

5.7.1 整个过程　419 

5.7.2 渲染替换体　420 

5.7.3 更新试探法　423 

5.7.4 效率　424 

5.7.5 预测　424 

5.7.6 小结　425 

5.8 硬件加速过程纹理动画中的运算　426 

Greg James 

5.8.1 硬件运算　426 

5.8.2 将来的工作　435 

5.8.3 致谢　435 

5.8.4 示例源码　435 

5.8.5 参考文献　435 

第6章 音频编程 

绪 论　439 

James Boer 

6.1 游戏音频设计模式　440 

Scott Patterson 

6.1.1 桥接（Bridge）　440 

6.1.2 外观（Fa?ade）　441 

6.1.3 合成（Composite）　441 

6.1.4 代理（Proxy）　442 

6.1.5 修饰器（Decorator）　442 

6.1.6 命令（Command）　443 

6.1.7 备忘录（Memento）　443 

6.1.8 观测器（Observer）　443 

6.1.9 大泥球（Big Ball of Mud）（也称做“意大利面条式”代码）　444 

6.1.10 结论　445 

6.1.11 参考文献　445 

6.2 在采样合成器中声音的同步重用技术　446 

Thomas Engel 

6.2.1 存在的问题　446 

6.2.2 解决方案的思路　447 

6.2.3 解决方案　447 

6.2.4 结论　448 

6.3 软件DSP效果　450 

Ian Lewis 

6.3.1 滤波　450 

6.3.2 卷积（convolution）　451 

6.3.3 延迟　451 

6.3.4 插值（interpolation）　452 

6.3.5 参考文献　453 

6.4 数字音频的交互式处理管线　454 

Keith Weiner 

6.4.1 简介　454 

6.4.2 讨论　456 

6.4.3 代码　458 

6.4.4 额外注释　461 

6.4.5 结论　462 

6.5 游戏中的基本音乐音序器　463 

Scott Patterson 

6.5.1 音乐流与音序　463 

6.5.2 核心计算机音乐概念　464 

6.5.3 计算机音序器实现　466 

6.5.4 音频合成（composite）控制　472 

6.5.5 源码　473 

6.5.6 结论　473 

6.5.7 参考文献　473 

6.6 用于游戏的交互式音序器　474 

Scott Patterson 

6.6.1 音乐联想　474 

6.6.2 音乐意义　474 

6.6.3 过渡　476 

6.6.4 过渡类型　476 

6.6.5 控制粒度　477 

6.6.6 目标控制　477 

6.6.7 设计示例　479 

6.6.8 源码　480 

6.6.9 结论　480 

6.6.10 参考文献　480 

6.7 底层声音API　481 

Ian Lewis 

核心类　481 

索引　　483 








游戏编程精粹3



第1章 通用编程技术 

简介 　2 

Kim Pallister 

1.1 调度游戏中的事件　4 

Michael Harvey，Carl S. Marshall 

1.1.1 调度器的组成　5 

1.1.2 一个简单的调度器　8 

1.1.3 高级概念　10 

1.1.4 结论　11 

1.1.5 参考文献　12 

1.2 一个基于对象组合的游戏架构　13 

Scott Patterson 

1.2.1 游戏开发的各个阶段　13 

1.2.2 游戏架构设计　14 

1.2.3 游戏架构实现　17 

1.2.4 源代码　20 

1.2.5 参考文献　21 

1.3 让C中的宏重现光辉　23 

1.3.1 声明　23 

1.3.2 第1个宏技巧: 把枚举值转化为字符串　23 

.1.3.3 第2个宏技巧: 利用二进制表达式得到编译期常量　25 

1.3.4 第3个宏技巧：给标准断言添加描述性注释　26 

1.3.5 第4个宏技巧：编译期断言　26 

1.3.6 第5个宏技巧：得到一个数组里面的元素个数　27 

1.3.7 第6个宏技巧: 在一个字符串中间加入__LINE__　27 

1.3.8 第7个宏技巧：防止进入无限循环　28 

1.3.9 第8个宏技巧：小型的特制语言　29 

1.3.10 第9个宏技巧：简化类接口　30 

1.3.11 结论　33 

1.3.12 参考文献　33 

1.4 平台无关的函数绑定代码生成器　34 

Allen Pouratian 

1.4.1 年轻与智慧　34 

1.4.2 概要　35 

1.4.3 细节　36 

1.4.4 脚本　38 

1.4.5 网络　38 

1.4.6 结论　39 

1.4.7 参考文献　39 

1.5 基于句柄的智能指针　40 

Brian Hawkins 

1.5.1 用法　40 

1.5.2 句柄　41 

1.5.3 智能指针　42 

1.5.4 结论　43 

1.5.5 参考文献　43 

1.6 定制STL分配器　44 

Pete Isensee 

1.6.1 一个范例　44 

1.6.2 分配器的基础　45 

1.6.3 分配器的要求　45 

1.6.4 缺省的分配器对象　49 

1.6.5 编写自己的分配器　49 

1.6.6 潜在的用途　51 

1.6.7 分配器状态数据　51 

1.6.8 一些建议　52 

1.6.9 实现细节　52 

1.6.10 结论　52 

1.6.11 参考文献　53 

1.7 立即存盘　54 

Martin Brownlow 

1.7.1 为何如此困难　54 

1.7.2 SAVEMGR类　55 

1.7.3 SAVEOBJ类　55 

1.7.4 数据类型与扩展　56 

1.7.5 重载缺省函数　56 

1.7.6 一个简单的例子　57 

1.7.7 结论　58 

1.8 自动列表设计模式　59 

Ben Board 

1.8.1 实现　59 

1.8.2 实现时的注意事项　61 

1.8.3 结论　63 

1.9 浮点异常处理　64 

Soren Hannibal 

1.9.1 为什么要崩溃　64 

1.9.2 你的程序处理浮点异常么　65 

1.9.3 异常的类型　65 

1.9.4 代码　65 

1.9.5 调试浮点错误　66 

1.9.6 结论　66 

1.10 使用UML开发一个配合设计的游戏引擎　67 

Thomas Demachy 

1.10.1 对象就在游戏之中　67 

1.10.2 动态的类--正如动态的棋子　70 

1.10.3 协作与迭代　72 

1.10.4 实现上的问题　73 

1.10.5 结论　74 

1.10.6 参考文献　75 

1.11 使用Lex和Yacc分析自定义数据文件　76 

Paul Kelly 

1.11.1 Lex　77 

1.11.2 Yacc　77 

1.11.3 优点与缺陷　77 

1.11.4 Yacc和Lex中的交互　78 

1.11.5 针对游戏子系统的自定义数据文件　79 

1.11.6 把数据输出工具与Lex和Yacc结合起来　80 

1.11.7 一个完整的例子　80 

1.11.8 结论　84 

1.11.9 如何得到Flex和Bison　84 

1.11.10 参考文献　84 

1.12 为世界市场开发游戏　85 

Aaron Nicholls 

1.12.1 市场潜力　85 

1.12.2 门面事，先处理--显示和输入　86 

1.12.3 字符集　88 

1.12.4 界面和设计方面的考虑　90 

1.12.5 本地化　93 

1.12.6 设计和规划中的考虑　94 

1.12.7 测试　95 

1.12.8 结论　98 

1.12.9 参考文献　98 

1.13 3D游戏中的实时输入和用户界面　99 

Greg Seegert 

1.13.1 实现用户界面　99 

1.13.2 指定用户界面元素　100 

1.13.3 本地化问题　101 

1.13.4 输入系统　102 

1.13.5 鼠标与操纵杆　103 

1.13.6 在处理延迟方面用户界面的作用　104 

1.13.7 结论　105 

1.13.8 参考文献　105 

1.14 自然的选择：饼状菜单的演化　106 

Don Hopkins 

1.14.1 Feng GUI的饼状菜单　106 

1.14.2 对饼状菜单的研究与评估　107 

1.14.3 饼状菜单插件　108 

1.14.4 未来发展方向　112 

1.14.5 走进SimCity中的城镇　112 

1.14.6 Sims中的起居室　114 

1.14.7 结论　115 

1.14.8 参考文献　115 

1.15 轻量级的、基于规则的日志记录　117 

Brian Hawkins 

1.15.1 规则　117 

1.15.2 调试标志　117 

1.15.3 配置文件　118 

1.15.4 可配置的标志值　119 

1.15.5 日志记录　119 

1.15.6 用法　121 

1.15.7 结论　122 

1.15.8 参考文献　122 

1.16 日志服务　123 

Eric Robert 

1.16.1 管理信息　123 

1.16.2 系统层次　124 

1.16.3 Journal接口　127 

1.16.4 创建日志服务　129 

1.16.5 结论　132 

1.16.6 参考文献　132 

1.17 实时的层次化性能评测　133 

Greg Hjeistrom，Byon Garrabrant 

1.17.1 性能评测树　134 

1.17.2 用法　134 

1.17.3 实现　136 

1.17.4 结论　139 

1.17.5 参考文献　139 

第2章 数学技巧 

简介 　141 

John Byrd 

2.1 对数与随机数生成的2基快速函数　143 

James McNeill 

2.1.1 整数的2基对数　143 

2.1.2 位掩码与随机数生成　143 

2.1.3 函数是如何工作的　145 

2.1.4 参考文献　145 

2.2 使用分数矢量得到更精确的几何图形　146 

Thomas Young 

2.2.1 问题　146 

2.2.2 一个解决方法：分数矢量　149 

2.2.3 使用分数矢量　150 

2.2.4 数字的范围　151 

2.2.5 实现上的细节　152 

2.2.6 结论　153 

2.2.7 参考文献　153 

2.3 三角函数的更多近似计算方法　154 

Robin Green 

2.3.1 衡量误差　154 

2.3.2 正弦与余弦函数　155 

2.3.3 多项式逼近　162 

2.3.4 有关收敛性的注意事项　166 

2.3.5 结论　167 

2.3.6 参考文献　167 

2.4 四元数的压缩　168 

Mark Zarb-Adami 

2.4.1 四元数　168 

2.4.2 三个最小数方法　168 

2.4.3 极点方法　169 

2.4.4 实现　169 

2.4.5 性能　170 

2.4.6 结论　171 

2.4.7 答谢　171 

2.4.8 参考文献　171 

2.5 受限的逆向运动学　172 

Jason Weber 

2.5.1 骨节层次　172 

2.5.2 循环坐标推演　173 

2.5.3 旋转限制　174 

2.5.4 调整每个骨节，同时保持限制　175 

2.5.5 结论　177 

2.5.6 参考文献　177 

2.6 针对物理建模的单元自动机　179 

Tom Forsyth 

2.6.1 CA基础　179 

2.6.2 八叉树　182 

2.6.3 实际的物理　182 

2.6.4 核心处理模型　183 

2.6.5 气体　184 

2.6.6 水流　184 

2.6.7 流速　185 

2.6.8 热量　186 

2.6.9 火焰　188 

2.6.10 动态更新速率　189 

2.6.11 结论　190 

2.6.12 参考文献　191 

2.7 在动态仿真中处理摩擦　192 

Miguel Gomez 

2.7.1 库仑摩擦力　192 

2.7.2 数值方法　196 

2.7.3 一个三维公式　199 

2.7.4 几何图形问题　200 

2.7.5 结论　201 

2.7.6 参考文献　201 

第3章 人工智能 

简介 　203 

Steven WoodCock 

3.1 经GoCap优化过的机器学习　205 

Thor Alexander 

3.1.1 GoCap架构一览　205 

3.1.2 训练开车　207 

3.1.3 学习规则　208 

3.1.4 结论　212 

3.1.5 参考文献　212 

3.2 区域游览：对寻径模式的扩展　213 

Ben Board，Mike Ducker 

3.2.1 辞旧　214 

3.2.2 迎新　215 

3.2.3 分而治之　218 

3.2.4 路径遍历　220 

3.2.5 对此模式的扩展　224 

3.2.6 结论　224 

3.2.7 参考文献　224 

3.3 基于函数指针的内嵌式有限状态机　225 

Charles Farris 

3.3.1 什么是有限状态机　225 

3.3.2 FSM的实现　226 

3.3.3 实现CFSM　228 

3.3.4 使用CFSM　232 

3.3.5 结论　234 

3.3.6 参考文献　235 

3.4 在RTS中的地形分析--一个隐藏的重要因素 

Daniel Higgins 

3.4.1 区域　236 

3.4.2 凸包　240 

3.4.3 重要的匹配器　243 

3.4.4 关隘　246 

3.4.5 进行地形分析　249 

3.4.6 结论　250 

3.4.7 参考文献　250 

3.5 一个针对AI代理、对象，以及任务的可扩展触发器系统　251 

Steve Rabin 

3.5.1 触发器系统简介　251 

3.5.2 对象自有的触发器系统　252 

3.5.3 定义条件　252 

3.5.4 使用布尔逻辑组合条件　252 

3.5.5 定义响应　254 

3.5.6 求取触发器的值　254 

3.5.7 一次性触发与载入次数　255 

3.5.8 使用标志和计数器将触发器结合起来　256 

3.5.9 触发器系统与脚本语言的对比　257 

3.5.10 局限性　258 

3.5.11 结论　258 

3.5.12 参考文献　258 

3.6 基于A*算法的战术式寻径　259 

William van der Sterren 

3.6.1 有风险的A*　260 

3.6.2 对于有缺陷路径的战术式改良　262 

3.6.3 暴露时间与对敌人建模　262 

3.6.4 威胁并不仅仅是静态的　264 

3.6.5 更战术化的改进　265 

3.6.6 性能　265 

3.6.7 有效的火力线以及视野的探测　266 

3.6.8 扩展的A*算法的代价　267 

3.6.9 ASE程序　268 

3.6.10 结论　268 

3.6.11 参考文献　269 

3.7 快速游览网格的方法　270 

Stephen White，Christopher Christensen 

3.7.1 静态障碍与动态障碍　270 

3.7.2 游览网格　270 

3.7.3 门户　272 

3.7.4 建表　274 

3.7.5 其他的门户相关问题　275 

3.7.6 表示生物　276 

3.7.7 动态障碍　277 

3.7.8 在静态障碍与动态障碍之间进行游览　279 

3.7.9 有关游览网格的其他想法　279 

3.7.10 结论　280 

3.8 在寻径与碰撞之间选择一种关系　281 

Thomas Young 

3.8.1 在碰撞控制下的运动　281 

3.8.2 对于寻径的碰撞模型　281 

3.8.3 方法1：具有容错性的AI　282 

3.8.4 方法2：在无障碍空间一个子集内的寻径　284 

3.8.5 方法3：使用寻径器本身处理人物碰撞　286 

3.8.6 实现沿路的运动　288 

3.8.7 结论　289 

3.8.8 参考文献　289 

第4章 图形 

简介 　292 

Jeff Lander 

4.1 消除T形连接与重新三角化　295 

Eric Lengyel 

4.1.1 T形连接的消除　296 

4.1.2 重新三角化　297 

4.1.3 实现　298 

4.1.4 结论　299 

4.2 快速高程场法线的计算　300 

Jason Shankel 

4.2.1 一个任意网格上的法线　300 

4.2.2 高程场法线　301 

4.2.3 结论　303 

4.2.4 例子程序　303 

4.2.5 参考文献　304 

4.3 快速计算面片法线　305 

Martin Brownlow 

4.3.1 定义　305 

4.3.2 传统方法　305 

4.3.3 相关问题　306 

4.3.4 一个更简单的方法　306 

4.3.5 其他的优点　306 

4.3.6 此方法的精确度有多大　307 

4.3.7 结论　307 

4.3.8 参考文献　307 

4.4 快速、简单的遮蔽剪裁　308 

Wagner T. Corrêa，Princeton University 

4.4.1 可见性问题　308 

4.4.2 PLP算法　309 

4.4.3 cPLP算法　310 

4.4.4 讨论　310 

4.4.5 实验结果　311 

4.4.6 结论　312 

4.4.7 参考文献　312 

4.5 三角形条带的创建、优化以及渲染　314 

Carl S．Marshall 

4.5.1 三角形条带　314 

4.5.2 三角形条带的创建　315 

4.5.3 优化　318 

4.5.4 渲染　319 

4.5.5 倾向于缓存的三角形条带　319 

4.5.6 连续分层细节的三角形条带　319 

4.5.7 结论　320 

4.5.8 参考文献　320 

4.6 针对复杂数据集计算优化阴影体　321 

Alex Vlachos，Drew Card 

4.6.1 前期工作　321 

4.6.2 算法　321 

4.6.3 优化算法　323 

4.6.4 参考文献　324 

4.7 针对人物运动的表面细分　325 

William Leeson 

4.7.1 各种细分模式　325 

4.7.2 骨节的层次化结构以及顶点积累缓冲　329 

4.7.3 优化　330 

4.7.4 系统集成　332 

4.7.5 源代码　333 

4.7.6 结论　334 

4.7.7 参考文献　334 

4.8 改良的骨节变换计算　335 

Jason Weber 

4.8.1 背景知识　335 

4.8.2 简单的方法　336 

4.8.3 添加骨节　337 

4.8.4 改变权重　338 

4.8.5 系统集成与优化　340 

4.8.6 结论　342 

4.8.7 参考文献　342 

4.9 针对真实人物运动的架构　343 

Thomas Young 

4.9.1 问题：针对任意目标的运动　343 

4.9.2 问题：运动之间的平滑过渡　345 

4.9.3 解决问题的一个架构：局部修正器与独立的插值系数　346 

4.9.4 应用：处理任意目标的运动　347 

4.9.5 位移修正器　348 

4.9.6 应用：变换　349 

4.9.7 其他细节　349 

4.9.8 结论　350 

4.9.9 参考文献　350 

4.10 可编程顶点着色器的编译器　351 

Adam Lake 

4.10.1 可编程顶点着色器　351 

4.10.2 编译器　353 

4.10.3 编译器的组成部分　353 

4.10.4 结论　357 

4.10.5 致谢　357 

4.10.6 参考文献　357 

4.11 画板光束　359 

Brian Hawkins 

4.11.1 矩阵　359 

4.11.2 顶点　360 

4.11.3 UV映射　361 

4.11.4 结论　361 

4.12 针对等测引擎的3D技术　362 

Greg Snook 

4.12.1 进入第三个维度　363 

4.12.2 方法1：画板越多，效果越好　363 

4.12.3 方法2：变换纹理　364 

4.12.4 方法3：垂直插值的纹理　366 

4.12.5 结论　367 

4.12.6 参考文献　367 

4.13 使用法向地图进行曲面模拟　368 

Oscar Blasco 

4.13.1 法向地图　368 

4.13.2 整个过程的纵览　369 

4.13.3 数据准备　369 

4.13.4 投影线　370 

4.13.5 得到细节信息　371 

4.13.6 后处理　372 

4.13.7 已知的问题　372 

4.13.8 其他方法　373 

4.13.9 结论　373 

4.13.10 致谢　374 

4.13.11 参考文献　374 

4.14 动态的、具有照片效果的地形光照　375 

Naty Hoffman，Kenny Mitchell 

4.14.1 背景知识　375 

4.14.2 解的分类　377 

4.14.3 日照：地平角、椭圆阴影以及PTM　377 

4.14.4 天空光照：辐射透过量的近似与分块　379 

4.14.5 活动的云层阴影　380 

4.14.6 基于视频的解决方案　382 

4.14.7 非地形对象　383 

4.14.8 结论　383 

4.14.9 参考文献　383 

4.15 立体图光照技术　385 

Kenneth L. Hurley 

4.15.1 立体图的物理属性　385 

4.15.2 如何与立体图进行数据交换　386 

4.15.3 使用立体图进行渲染　386 

4.15.4 对云层进行编码　387 

4.15.5 在一个立体图中对光源进行编码　390 

4.15.6 在立体图中渲染散射光照　390 

4.15.7 将日夜循环编码进立体图中　391 

4.15.8 结论　391 

4.15.9 参考文献　391 

4.16 程序纹理　392 

Mike Milliger 

4.16.1 参数与函数　392 

4.16.2 进入游戏世界　393 

4.16.3 硬件加速　395 

4.16.4 结论　396 

4.16.5 致谢　397 

4.16.6 参考文献　397 

4.17 独一无二的纹理　398 

Tom Forsyth 

4.17.1 程序纹理　398 

4.17.2 智能纹理缓存　399 

4.17.3 合成模型　399 

4.17.4 层的映射与变换　399 

4.17.5 层的源与过滤器　400 

4.17.6 合成方法　400 

4.17.7 对数字的控制　401 

4.17.8 动态纹理　401 

4.17.9 可扩展性　402 

4.17.10 使用CPU还是图形芯片进行合成运算　403 

4.17.11 演示程序　403 

4.17.12 结论　404 

4.17.13 参考文献　404 

4.18 使用纹理作为查找表进行逐像素光照计算　405 

Alex Vlachos, John Isidoro，Chris Oat 

4.18.1 不使用立体图进行h归一化（n.h/h.h映射）的镜面逐像素光照　405 

4.18.2 使用一个(n.h)k图的逐像素镜面指数　407 

4.18.3 色彩偏移的光晕　409 

4.18.4 拥有正确的逐像素衰减的逐像素点光照　410 

4.18.5 拥有正确的逐像素衰减的逐像素聚光灯与方向性光照　411 

4.18.6 结论　413 

4.18.7 参考文献　413 

4.19 使用手工制作的着色模型进行渲染　414 

Jan Kautz 

4.19.1 着色模型　414 

4.19.2 基于微表面的着色模型　415 

4.19.3 NDF着色　415 

4.19.4 使用NDF的凸凹贴图　417 

4.19.5 扩展　418 

4.19.6 结论　418 

4.19.7 参考文献　418 

第5章 网络和多玩家游戏 

简介 　421 

Andrew Kirmse 

5.1 将实时策略游戏中的延迟最小化　422 

Jim Greer, EA.com，Zachary Booth Simpson, Mine Control 

5.1.1 帧锁定与事件锁定　422 

5.1.2 时间同步　426 

5.1.3 结论　428 

5.1.4 参考文献　428 

5.2 实时策略网络协议　429 

Jan Svarovsky 

5.2.1 其他的协议　429 

5.2.2 我们的协议　430 

5.2.3 精炼　432 

5.2.4 有用的模块　434 

5.2.5 在StarTopia中容易犯的错误　435 

5.2.6 示例游戏　436 

5.2.7 结论　436 

5.2.8 参考文献　436 

5.3 一个针对巨量多玩家游戏的灵活的仿真架构　437 

Thor Alexander 

5.3.1 架构一览　437 

5.3.2 支持类　438 

5.3.3 核心类　440 

5.3.4 管理器与工厂　443 

5.3.5 把它们都组合起来　445 

5.3.6 结论　448 

5.3.7 参考文献　448 

5.4 对多玩家游戏进行扩展　449 

Justin Randall 

5.4.1 改善游戏公平度的策略　449 

5.4.2 设计可扩展的服务器　451 

5.4.3 分布负载　456 

5.4.4 优化　458 

5.4.5 结论　460 

5.4.6 参考文献　461 

5.5 基于模板的对象序列化　462 

Jason Beardsley 

5.5.1 现存的解决方案　462 

5.5.2 可移植性　464 

5.5.3 Serializer 类　465 

5.5.4 扩展与优化　470 

5.5.5 未来的工作　472 

5.5.6 结论　472 

5.5.7 参考文献　472 

5.6 安全套接字　473 

Pete Isensee 

5.6.1 IPSec　473 

5.6.2 警告　474 

5.6.3 安全连接　474 

5.6.4 包格式　475 

5.6.5 发送数据　476 

5.6.6 接收数据　477 

5.6.7 示例实现　478 

5.6.8 CryptoAPI　480 

5.6.9 性能　480 

5.6.10 安全性　481 

5.6.11 结论　481 

5.6.12 参考文献　482 

5.7 一个网络监控与模拟工具　483 

Andrew Kirmse 

5.7.1 界面　483 

5.7.2 网络监控　484 

5.7.3 TCP模拟　484 

5.7.4 UDP模拟　484 

5.7.5 主机带宽模拟　485 

5.7.6 结论　485 

5.8 使用DirectPlay8.1创建多玩家游戏　486 

Gabriel Rohweder 

5.8.1 DirectPlay内幕　486 

5.8.2 数据传输　487 

5.8.3 可重入的回调函数　490 

5.8.4 使用DirectPlay发送语音　493 

5.8.5 相关资源　496 

5.9 使用Java微型版开发无线游戏　497 

David Fox 

5.9.1 网络特性　497 

5.9.2 Java微型版　498 

5.9.3 J2ME网络精髓　499 

5.9.4 HTTP的限制　500 

5.9.5 优化数据包　501 

5.9.6 从服务器获取图像　502 

5.9.7 结论　503 

5.9.8 参考文献　504 

第6章 音频处理 

简介 　506 

Scott Patterson 

6.1 使用Ogg Vorbis进行音频压缩　508 

Jack Moffitt 

6.1.1 心理声学压缩　508 

6.1.2 使用压缩的情况　510 

6.1.3 使用Ogg的代码示例　511 

6.1.4 结论　514 

6.1.5 参考文献　514 

6.2 创建一个美妙的3D音频环境　515 

Garin Hiebert 

6.2.1 3D音频的核心概念　515 

6.2.2 有效地使用你的音频引擎　516 

6.2.3 实现　517 

6.2.4 结论　518 

6.2.5 参考文献　518 

6.3 使用轴对齐的边界框设置音障　520 

Carlo Vogelsang 

6.3.1 问题　520 

6.3.2 解决方法　521 

6.3.3 实现　524 

6.3.4 结论　524 

6.3.5 参考文献　524 

6.4 使用双二次共振滤波器　525 

Phil Burk 

6.4.1 数字滤波器的工作原理　525 

6.4.2 IIR与FIR滤波器　526 

6.4.3 双二次滤波器的实现　526 

6.4.4 改变变量　527 

6.4.5 避免异常情况　527 

6.4.6 控制滤波器　528 

6.4.7 计算此滤波器的系数　528 

6.4.8 低通滤波器　529 

6.4.9 高通滤波器　529 

6.4.10 带通滤波器　529 

6.4.11 将滤波器进行串联　530 

6.4.12 将滤波器进行并联　530 

6.4.13 软件　530 

6.4.14 结论　530 

6.4.15 参考文献　530 

6.5 语音压缩与音效的线性预测编码　531 

Eddie Edwards 

6.5.1 对语音建模　532 

6.5.2 软件仿真　533 

6.5.3 取代声带　535 

6.5.4 控制重新合成器　536 

6.5.5 增加扬声器的深度　537 

6.5.6 对数据编码　537 

6.5.7 速度　538 

6.5.8 实验　538 

6.5.9 参考文献　538 

6.6 复杂声音的随机合成方法　539 

Phil Burk 

6.6.1 线性同余算法　539 

6.6.2 噪声种类　540 

6.6.3 软件示例　541 

6.6.4 软件　545 

6.6.5 结论　545 

6.6.6 参考文献　545 

6.7 针对游戏的实时模块化音频处理　546 

Frank Luchs 

6.7.1 模块化音频处理　546 

6.7.2 通过程序生成声音　547 

6.7.3 Sphinx MMOS系统　547 

6.7.4 处理器　548 

6.7.5 模块文件简介　548 

6.7.6 模块文件的应用　550 

6.7.7 源代码　552 

6.7.8 结论　553 

6.7.9 参考文献　553 

索引　554 






游戏编程精粹4



第1章　通用编程 

简介　ChrisCorry　2 

1.1　调试游戏程序的学问　Steve Rabin　4 

1.1.1　五步调试法　4 

1.1.2　第一步：始终如一地重现问题　4 

1.1.3　第二步：搜集线索　5 

1.1.4　第三步：查明错误的源头　6 

1.1.5　第四步：纠正问题　7 

1.1.6　第五步：对所作的修改进行测试　7 

1.1.7　高级调试技巧　8 

1.1.8　困难的调试情景和模式　10 

1.1.9　理解底层系统　12 

1.1.10　增加有助于调试的基础设施　12 

1.1.11　预防bug　13 

1.1.12　结论　14 

1.1.13　致谢　15 

1.1.14　参考文献　15 

1.2　一个基于HTML的日志和调试系统　James Boer　16 

1.2.1　于日志系统的优势　16 

1.2.2　究竟什么是事件日志？　16 

.1.2.3　HTML和调用堆栈　17 

1.2.4　工作原理　18 

1.2.5　一些有用的心得　21 

1.2.6　结论　21 

1.3　时钟：游戏的脉搏尽在掌握　Noel Llopis　23 

1.3.1　关于时间的基础　23 

1.3.2　时钟系统的组成　24 

1.3.3　避免失真　25 

1.3.4　结论　29 

1.4　设计和维护大型跨平台库　David Etherton　30 

1.4.1　设计　30 

1.4.2　Build系统　32 

1.4.3　细节　33 

1.4.4　结论　35 

1.4.5　参考文献　35 

1.5　利用模版化的空闲块列表克服内存碎片问题　Paul Glinker　36 

1.5.1　内存操作　36 

1.5.2　解决方案　37 

1.5.3　实现细节　37 

1.5.4　有效地使用我们的Freelist　40 

1.5.5　结论　40 

1.5.6　参考文献　41 

1.6　一个用C++实现的泛型树容器类　Bill Budge　42 

1.6.1　可重用的库　42 

1.6.2　树的概念　43 

1.6.3　树的实现　43 

1.6.4　利用STL　46 

1.6.5　结论　49 

1.6.6　参考文献　49 

1.7　弱引用和空对象　Noel Llopis　51 

1.7.1　使用指针　51 

1.7.2　弱引用　52 

1.7.3　空对象　55 

1.7.4　结论　56 

1.7.5　参考文献　57 

1.8　游戏中的实体管理系统　Matthew Harmon　58 

1.8.1　概述　58 

1.8.2　实体消息　60 

1.8.3　实体代码　61 

1.8.4　类的代码　63 

1.8.5　实体管理器　63 

1.8.6　基于消息的游戏循环　65 

1.8.7　开始：消息类　65 

1.8.8　从小处着手：基本实体消息　66 

1.8.9　游戏和环境消息　67 

1.8.10　系统成长：一些高级消息　67 

1.8.11　处理碰撞　69 

1.8.12　扩展到多玩家　69 

1.8.13　开发和调试消息　70 

1.8.14　好处　70 

1.8.15　光盘中的内容　71 

1.8.16　总结　71 

1.9　Windows和Xbox平台上地址空间受控的动态数组　Matt Pritchard　72 

1.9.1　传统的动态数组管理　72 

1.9.2　深入观察　73 

1.9.3　地址空间管理 != 存储管理　73 

1.9.4　重新思考关于数组增大的问题　74 

1.9.5　新的增长规则　74 

1.9.6　使用地址空间受控的数组　75 

1.9.7　结论　79 

1.10　用临界阻尼实现慢入慢出的平滑　Thomas Lowe　80 

1.10.1　可用的技术　80 

1.10.2　阻尼弦与临界阻尼　82 

1.10.3　实践　82 

1.10.4　设置平滑速率的上限　84 

1.10.5　结论　85 

1.10.6　参考文献　85 

1.11　一个易用的对象管理器　Natalya Tatarchuk　86 

1.11.1　对象管理的传统做法　86 

1.11.2　灵活的对象管理器　87 

1.11.3　结论　91 

1.11.4　参考文献　92 

1.12　使用自定义的RTTI属性对对象进行流操作及编辑　FredericMy　93 

1.12.1　扩展的RTTI　93 

1.12.2　属性　95 

1.12.3　编辑属性　97 

1.12.4　保存　99 

1.12.5　载入　100 

1.12.6　与旧版本文件的兼容性问题：类的描述　101 

1.12.7　与旧版本文件的兼容性问题：匹配　102 

1.12.8　“函数”属性　103 

1.12.9　技巧和提示　103 

1.12.10　思考　104 

1.12.11　结论　104 

1.12.12　参考文献　104 

1.13　使用XML而不牺牲速度　Mark T. Price　106 

1.13.1　为什么要使用XML呢？　106 

1.13.2　简单介绍XDS Meta格式　107 

1.13.3　XDS工具集　108 

1.13.4　使用XDS工具集　109 

1.13.5　整合　115 

1.13.6　总结　115 

1.13.7　参考文献　115 

第2章　数学 

简介　Jonathan Blow　118 

2.1　使用马其赛特旋转的Zobrist散列法　TobyJones　120 

2.1.1　Zobrist散列　120 

2.1.2　实现Zobrist散列　121 

2.1.3　马其赛特旋转(Mersenne Twister)　122 

2.1.4　马其赛特旋转的实现　123 

2.1.5　结论　124 

2.1.6　参考文献　124 

2.2　抽取截锥体和camera信息　WaldemarCeles　125 

2.2.1　平面变换(Plane Transformation)　125 

2.2.2　抽取锥体信息　127 

2.2.3　抽取camera信息　128 

2.2.4　任意投影变换　130 

2.2.5　实现　131 

2.2.6　结论　132 

2.2.7　参考文献　132 

2.3　解决大型游戏世界坐标中的精度问题　Peter Freese　133 

2.3.1　问题描述　133 

2.3.2　可能的解决方式　135 

2.3.3　偏移位置　137 

2.3.4　渲染流水线变化　140 

2.3.5　对性能的思考　143 

2.3.6　结论　143 

2.3.7　参考文献　144 

2.4　非均匀样条　Thomas Lowe　145 

2.4.1　样条的种类　145 

2.4.2　三次样条的基础理论　146 

2.4.3　圆形的非均匀样条　147 

2.4.4　平滑非均匀样条　149 

2.4.5　时控的非均匀样条　151 

2.4.6　计算起始和最终节点速率　152 

2.4.7　在样条上获取速率和加速度　153 

2.4.8　优化　153 

2.4.9　结论　153 

2.4.10　参考文献　154 

2.5　用协方差矩阵计算更贴切的包围对象　Jim Van Verth　155 

2.5.1　协方差矩阵　155 

2.5.2　特征值和特征向量　158 

2.5.3　计算协方差矩阵的特征向量　159 

2.5.4　创建包围对象　159 

2.5.5　结论　161 

2.5.6　参考文献　162 

2.6　应用于反向运动的雅可比转置方法　Marco Spoerl　163 

2.6.1　我们的测试环境　163 

2.6.2　雅可比矩阵是什么？　164 

2.6.3　雅可比转置矩阵简介　165 

2.6.4　实现算法　166 

2.6.5　结果和比较　168 

2.6.6　结论　171 

2.6.7　参考文献　171 

第3章　物理 

简介　Graham Rhodes　174 

3.1　死神的十指：战斗中的命中算法　Roger Smith、DonStoner　176 

3.1.1　射击带状物(Ribbon)　176 

3.1.2　射击靶心　177 

3.1.3　射击矩形　178 

3.1.4　使用霰弹枪射击小目标　179 

3.1.5　移动炮兵的攻击命中　179 

3.1.6　死亡的4种主要形式　180 

3.1.7　化学武器、火球及区域性魔法　182 

3.1.8　弹片的楔入　182 

3.1.9　攻击丛林　183 

3.1.10　攻击有猎物分布的丛林　183 

3.1.11　结论　184 

3.1.12　参考文献　184 

3.2　在低速CPU系统中交通工具的物理模拟　MarcinPancewicz、Paul Bragiel　185 

3.2.1　技术的概要和前提假设　185 

3.2.2　交通工具沿当前行驶方向上的加速及减速　186 

3.2.3　方向控制　188 

3.2.4　把所有要素结合起来　189 

3.2.5　地形的影响　189 

3.2.6　实现中遇到的问题　190 

3.2.7　可以改进的地方　191 

3.2.8　结论　192 

3.3　编写基于Verlet积分方程的物理引擎　NickPorcino　193 

3.3.1　关于物理引擎　193 

3.3.2　刚体　194 

3.3.3　积分器　194 

3.3.4　物理引擎　196 

3.3.5　针对特定平台的考虑　199 

3.3.6　扩展引擎的功能　199 

3.3.7　结论　200 

3.3.8　参考文献　200 

3.4　刚体动力学中的约束器　Russ Smith　201 

3.4.1　基本要点　201 

3.4.2　约束器构造模块　202 

3.4.3　创建有用的游戏约束器　205 

3.4.4　光盘中的内容　209 

3.4.5　结论　209 

3.4.6　参考文献　209 

3.5　在动力学模拟中的快速接触消除法　ádám Moravánszky、Pierre Terdiman　210 

3.5.1　减少接触　210 

3.5.2　对预处理的详细分析　213 

3.5.3　对接触的分组群的详细分析　214 

3.5.4　对持续性的详细分析　217 

3.5.5　结论　217 

3.5.6　参考文献　218 

3.6　互动水面　Jerry Tessendorf　219 

3.6.1　线性的波浪　220 

3.6.2　垂直导数操作符　221 

3.6.3　波浪的传播　222 

3.6.4　可以互动的障碍物及其发生源　224 

3.6.5　环境波浪　225 

3.6.6　网格的边界　225 

3.6.7　表面张力　226 

3.6.8　结论　226 

3.6.9　参考文献　226 

3.7　用多层物理模拟快速变形　Thomas Di Giacomo、Nadia Magnenat-Thalmann　228 

3.7.1　基于物理的动画LOD及相关的工作　228 

3.7.2　使用分层的质量块弹簧物理的快速变形　230 

3.7.3　结论　235 

3.7.4　参考文献　2363.8　快速且稳定的形变之模态分析　James F. O'Brien　237 

3.8.1　模式分解　239 

3.8.2　模式的理解和丢弃　241 

3.8.3　模态模拟　242 

3.8.4　总结　244 

3.8.5　结论　244 

3.8.6　参考文献　245 

第4章　人工智能 

简介　Paul Tozour　248 

4.1　第三人称视角摄像镜头的运动规则　Jonathan Stone　250 

4.1.1　Camera定位及运动　250 

4.1.2　Camera与场景边界　253 

4.1.3　Camera遮断　256 

4.1.4　简化场景　258 

4.1.5　结论　258 

4.1.6　参考文献　258 

4.2　叙述战斗：利用AI增强动作游戏中的张力　BorutPfeifer　260 

4.2.1　戏剧张力　260 

4.2.2　系统概述　263 

4.2.3　设计者的控制部分　263 

4.2.4　难度计算　264 

4.2.5　难度调节　265 

4.2.6　系统评价　266 

4.2.7　结论　267 

4.2.8　参考文献　267 

4.3　非玩家角色决策：处理随机问题　Karén Pivazyan　268 

4.3.1　概要　268 

4.3.2　动态规划算法　269 

4.3.3　代码　273 

4.3.4　优化　275 

4.3.5　DP算法的其他应用　275 

4.3.6　结论　276 

4.3.7　参考文献　276 

4.4　一个基于效用的面向对象决策架构　John Hancock　277 

4.4.1　决策树　278 

4.4.2　基于对象的更好的体系结构　278 

4.4.3　期望值　280 

4.4.4　其他的决策准则　281 

4.4.5　结论　282 

4.4.6　参考文献　283 

4.5　一个分布式推理投票架构　John Hancock　284 

4.5.1　分布式推理　284 

4.5.2　操纵仲裁者(Steering Arbiter)范例　286 

4.5.3　选择投票空间　289 

4.5.4　结论　290 

4.5.5　参考文献　291 

4.6　吸引子和排斥子　John M. Olsen　292 

4.6.1　合力　292 

4.6.2　引力曲线　293 

4.6.3　吸引曲线的和　294 

4.6.4　对应于特定配对的特定曲线　295 

4.6.5　动态曲线　295 

4.6.6　点、线、面　297 

4.6.7　AI控制的层次　298 

4.6.8　动画系统的交互　298 

4.6.9　移动(Steering)　299 

4.6.10　结论　299 

4.6.11　参考文献　299 

4.7　高级RTS游戏造墙算法　Mario Grimani　301 

4.7.1　算法　301 

4.7.2　算法改进　302 

4.7.3　输出链表的形式　306 

4.7.4　结论　307 

4.7.5　参考文献　307 

4.8　利用可编程图形硬件处理人工神经元网络　Thomas Rolfes　308 

4.8.1　CPU与GPU系统架构　308 

4.8.2　人工神经元网络　309 

4.8.3　实现　310 

4.8.4　结论　311 

4.8.5　参考文献　311 

第5章　图形图像 

简介　Alex Vlachos　314 

5.1　具有海报质量的屏幕截图　Steve Rabin　316 

5.1.1　提高分辨率　316 

5.1.2　提升像素质量　318 

5.1.3　使用一个磁盘均衡采样分布　320 

5.1.4　为抗锯齿调整像素的采样宽度　321 

5.1.5　增加分辨率同增加像素质量相结合　321 

5.1.6　结论　323 

5.1.7　参考文献　324 

5.2　非封闭网络模型的GPU容积阴影构架　WarrickBuchanan　325 

5.2.1　回到制图板　325 

5.2.2　在顶点阴影中实现这项技术　326 

5.2.3　需要注意的事项　329 

5.2.4　结论　330 

5.2.5　参考文献　330 

5.3　透视阴影贴图　Marc Stamminger　331 

5.3.1　引言　331 

5.3.2　后透视空间　332 

5.3.3　后透视空间中的光　334 

5.3.4　透视阴影贴图　335 

5.3.5　实现　338 

5.3.6　结论　339 

5.3.7　参考文献　340 

5.4　结合使用深度和基于ID的阴影缓冲　KurtPelzer　341 

5.4.1　已有的阴影映射技术　341 

5.4.2　深度和基于ID的阴影缓冲　342 

5.4.3　结合深度和ID缓冲　343 

5.4.4　组合的阴影缓冲概述　344 

5.4.5　第一次：从光照的视点渲染　345 

5.4.6　第二次：阴影检测　347 

5.4.7　在DX9 2.0级的阴影中的实现　351 

5.4.8　结论　353 

5.4.9　参考文献　353 

5.5　在场景中投射静态阴影　Alex Vlachos　355 

5.5.1　前期工作　355 

5.5.2　光束基本知识　355 

5.5.3　高级算法　356 

5.5.4　T型连接　357 

5.5.5　网格模型最优算法　358 

5.5.6　实现细节　359 

5.5.7　阴影中的动态物体　360 

5.5.8　结果　360 

5.5.9　结论　361 

5.5.10　参考文献　361 

5.6　为阴影体和优化的网格模型调整实时光照　Alex Vlachos、Chris Oat　362 

5.6.1　光照问题　362 

5.6.2　在面法线上操作　362 

5.6.3　调整漫射光照　364 

5.6.4　结论　366 

5.6.5　参考文献　366 

5.7　实时半调色法：快速而简单的样式化阴影　Bert Freudenberg、Maic Masuch、Thomas Strothotte　367 

5.7.1　引言　367 

5.7.2　原理　368 

5.7.3　实例的实现　371 

5.7.4　结论　372 

5.7.5　参考文献　372 

5.8　在3D模型中应用团队色的各种技术　GregSeegert　373 

5.8.1　什么是团队色?　373 

5.8.2　团队色的算法　373 

5.8.3　一个实际的例子　378 

5.8.4　光盘中的内容　379 

5.8.5　结论　379 

5.9　快速的棕褐色色调转换　Marwan Y. Ansari　380 

5.9.1　背景　380 

5.9.2　常规的方法　380 

5.9.3　优化　381 

5.9.4　结论　382 

5.9.5　参考文献　382 

5.10　使用场景亮度采样实现动态的Gamma　Michael Dougherty、Dave McCoy　383 

5.10.1　光照系数　383 

5.10.2　有限的动态范围　383 

5.10.3　图像的优化　384 

5.10.4　易变的光灵敏度　385 

5.10.5　转换　386 

5.10.6　算法　388 

5.10.7　结论　392 

5.11　热和薄雾的后处理效果　Chris Oat、NatalyaTatarchuk　393 

5.11.1　热和闪光的薄雾　393 

5.11.2　高级算法　393 

5.11.3　计算失真值　394 

5.11.4　失真值的解释　397 

5.11.5　结论　400 

5.11.6　参考文献　400 

5.12　用四元数的硬件蒙皮　Jim Hejl　401 

5.12.1　蒙皮的概念　402 

5.12.2　四元数参数化　404 

5.12.3　硬件实现　405 

5.12.4　结论　407 

5.12.5　参考文献　407 

5.13　动作捕捉数据的压缩　Sφren Hannibal　409 

5.13.1　处理的计划　409 

5.13.2　组织数据通道　410 

5.13.3　减少已储存的键的数量　410 

5.13.4　包装剩余的键　412 

5.13.5　运行时解压缩　412 

5.13.6　未来的改进　413 

5.13.7　结论　413 

5.13.8　参考文献　413 

5.14　基于骨骼的有关节的3D角色的快速碰撞检测　OliverHeim、Carl S. Marshall、Adam Lake　414 

5.14.1　碰撞检测与碰撞分解　414 

5.14.2　术语　414 

5.14.3　将碰撞检测集成到3D游戏引擎中　415 

5.14.4　基于骨骼的快速碰撞检测算法　416 

5.14.5　结论　423 

5.14.6　感谢　423 

5.14.7　参考文献　423 

5.15　使用地平线进行地形的遮挡剔除　Glenn Fiedler　424 

5.15.1　引言　424 

5.15.2　地平线剔除基础　425 

5.15.3　蛮力地平线剔除　426 

5.15.4　近似值　426 

5.15.5　近似地平线直线　427 

5.15.6　一个更好的近似值　427 

5.15.7　最小二次方线　428 

5.15.8　将它放入到第三维中　429 

5.15.9　最小二次方平面　430 

5.15.10　用近似值的地平线剔除　431 

5.15.11　被地形遮挡的对象　432 

5.15.12　使它成为动态的　432 

5.15.13　未来的方向　433 

5.15.14　结论　433 

5.15.15　参考文献　433 

第6章　网络和多人游戏 

简介 Pete Isensee　436 

6.1　设计与开发游戏大厅　Shekhar Dhupelia　437 

6.1.1　状态-事件系统的设计　437 

6.1.2　探讨大厅的子系统　438 

6.1.3　高级大厅子系统　439 

6.1.4　结论　441 

6.1.5　参考文献　442 

6.2　支持成千上万个客户端的服务器　Adam Martin　443 

6.2.1　服务器设计中的门槛　443 

6.2.2　问题　444 

6.2.3　主要技术　446 

6.2.4　服务器设计　451 

6.2.5　结论　452 

6.2.6　参考文献　452 

6.3　大型多人游戏状态的有效存储　Justine Quimby　454 

6.3.1　MMP的问题　454 

6.3.2　Qualities理论　455 

6.3.3　Qualities API　456 

6.3.4　使用Qualities的好处　459 

6.3.5　结论　459 

6.3.6　参考文献　460 

6.4　在客户/服务器环境下运用并行状态机　Jay Lee　461 

6.4.1　独立状态　461 

6.4.2　角色状态管理器　463 

6.4.3　使用CharacterStateMgr　464 

6.4.4　保持客户端和服务器端的同步　464 

6.4.5　状态依赖的子系统　466 

6.4.6　结论　467 

6.4.7　参考文献　467 

6.5　位打包：一种网络压缩技术　Pete Isensee　468 

6.5.1　一个实例　468 

6.5.2　难点　469 

6.5.3　位打包　469 

6.5.4　用于可打包数据类型的通用接口　471 

6.5.5　用于可打包数据类型的具体接口　471 

6.5.6　编解码器　472 

6.5.7　评价折衷　473 

6.5.8　改进　473 

6.5.9　结论　473 

6.5.10　参考文献　474 

6.6　多服务器网络游戏的时间和同步管理　石卫东(Larry Shi)、Tao Zhang　475 

6.6.1　为什么需要时间和同步管理　475 

6.6.2　时钟同步　475 

6.6.3　同步和响应　476 

6.6.4　用多时间管理来一石二鸟地实现同步和响应　476 

6.6.5　实现　476 

6.6.6　何时应使用多时管理　482 

6.6.7　总结　482 

6.6.8　致谢　482 

6.6.9　参考文献　482 

第7章　音频 

简介　Eddie Edwards　486 

7.1　OpenAL简介　Joe Valenzuela　487 

7.1.1　OpenAL API　487 

7.1.2　有关OpenAL的实现　493 

7.1.3　实现一致性指南　495 

7.1.4　未来OpenAL的发展蓝图　496 

7.1.5　总结　496 

7.1.6　参考文献　496 

7.2　简单的实时Lip-Synching系统　JakeSimpson　497 

7.2.1　实现　497 

7.2.2　动画方面需要注意的事项　498 

7.2.3　声音音量的水印标记　499 

7.2.4　注意　500 

7.2.5　总结　500 

7.3　动态变量和音频编程　James Boer　501 

7.3.1　动态变量是什么？　501 

7.3.2　动态变量类　501 

7.3.3　在音频编程中使用动态变量　503 

7.3.4　其他改进　506 

7.3.5　结论　506 

7.3.6　参考文献　506 

7.4　创建一个音频脚本系统　Borut Pfeifer　507 

7.4.1　游戏中音频的类别　508 

7.4.2　工具　510 

7.4.3　基于XML的音频标记库　510 

7.4.4　脚本系统组件　512 

7.4.5　进一步的工作　515 

7.4.6　总结　515 

7.4.7　参考文献　515 

7.5　使用EAX和ZoomFX API的环境音效解决方案　Scott Velasquez　516 

7.5.1　什么是环境音效　516 

7.5.2　音频引擎的系统要求　517 

7.5.3　潜在可听集(PAS，PotentiallyAudible Set)　518 

7.5.4　EAX介绍　520 

7.5.5　总结　528 

7.5.6　参考文献　528 

7.6　在游戏的物理引擎中控制实时声音　Frank Luchs　529 

7.6.1　游戏引擎　529 

7.6.2　混合声音合成　531 

7.6.3　可听见对象的属性　532 

7.6.4　对象形状的影响　532 

7.6.5　对象材质的影响　533 

7.6.6　撞击和碰撞　533 

7.6.7　演示　533 

7.6.8　总结　534 

7.6.9　参考文献　534 

附录　536 




游戏编程精粹5



第1章 通用编程

引言　2

William E.Damon Ⅲ

1.1  面向编辑器的上下文相关HUD　3

Grex游戏公司，Adm Martin

1.1.1  问题　3

1.1.2  解决方案　6

1.1.3  实现　7

1.1.4  用户控制　10

1.1.5  总结　11

1.1.6  参考文献　11

1.2  在游戏中解析文本数据　12

Aurelio Reis

1.2.1  开始之前　12

1.2.2  token到底是什么　12

1.2.3  编写词法分析器　13

1.2.4  工作原理　14

1.2.5  制定自己的格式　15

1.2.6  解析token列表　17

1.2.7  总结　18

1.2.8  参考文献　18

1.3  基于组件的对象管理　19

Circle Studio公司，Bjarne Rene

1.3.1  除旧迎新　19

1.3.2  组件　20

1.3.3  系统的创建　23

1.3.4  总结　29

1.4  用模板实现一个可在C++中使用的反射系统　30

Artificial Mind& Movement公司，Dominic Fillion

1.4.1  需求　31

1.4.2  第1部分：运行时类型信息　31

1.4.3  在RTTI的实现中使用模板　33

1.4.4  关于RTTI的其他修改建议　35

1.4.5  第2部分：属性对象　36

1.4.6  属性的存储　38

1.4.7  属性类型　38

1.4.8  属性注册钩子(Hook)函数　39

1.4.9  属性的注册　40

1.4.10  脚本应用　41

1.4.11  Tweaker应用　42

1.4.12  其他应用　42

1.4.13  总结　42

1.4.14  参考文献　43

1.5  可加速BSP算法的球体树　44

Artificial Mind& Movement公司，Dominic Filion

1.5.1  BSP算法　44

1.5.2  创建BSP树　45

1.5.3  优化最初步骤　46

1.5.4  总结　51

1.5.5  参考文献　51

1.6  改进后的视锥剔除算法　52

Frank PuigPlaceres

1.6.1  视锥剔除　52

1.6.2  传统的六面法　53

1.6.3  雷达法　54

1.6.4  这个点在视锥内部吗？　54

1.6.5  球体在哪里？　56

1.6.6  其他应用　57

1.6.7  进一步的改造　58

1.6.8  总结　60

1.6.9  参考文献　60

1.7  通用的分页管理系统　61

Ignacio InceraCruz

1.7.1  老式的分页解决方案：一查到底　61

1.7.2  GP分页解决方案：只检查需要的　62

1.7.3  索引是关键　62

1.7.4  GPtile：空间中的块　65

1.7.5  The world：搜索空间　67

1.7.6  窗口：在GPworld中航行　69

1.7.7  多窗口，多用户　70

1.7.8  优化：多线程分页　71

1.7.9  总结　71

1.7.10  参考文献　71

1.8  基于栈的大规模状态机　72

James Boer

1.8.1  传统状态机编码及相关问题　72

1.8.2  用C++方法解决游戏状态难题　74

1.8.3  状态接口类　75

1.8.4  状态的堆叠管理：为什么三维比二维好用　75

1.8.5  状态对象管理系统　76

1.8.6  总结　78

1.8.7  参考文献　79

1.9  使用BSP树构造CSG几何体　80

Octavian MariusChincisan

1.9.1  CSG的布尔运算　80

1.9.2  为什么要使用BSP树　84

1.9.3  BSP树的实现　85

1.9.4  组合装配　86

1.9.5  总结　88

1.9.6  参考文献　89

1.10  在游戏中集成Lua　90

eV Interactive公司，Matthew Harmon

1.10.1  Lua的概况　90

1.10.2  Lua与C语言的接口　92

1.10.3  在游戏中嵌入Lua　94

1.10.4  实时性方面的考虑　97

1.10.5  脚本管理框架　99

1.10.6  总结　102

1.10.7  参考文献　102

1.11  用基于policy的设计改进Freelist　103

Nathan Mefford

1.11.1  Freelist概述　103

1.11.2  Policy:雷霆救兵　104

1.11.3  分解Freelist　106

1.11.4  实现Freelist：这是它吗？　107

1.11.5  选择最佳的policy　109

1.11.6  可能性　111

1.11.7  总结　113

1.11.8  参考文献　113

1.12  实时远程调试信息日志生成器　114

Microids Canada公司，Patrick Duquette

1.12.1  对标准化的调试日志的需求　114

1.12.2  数据表示：你可看到我所看到的　115

1.12.3  本文提议的解决方案　115

1.12.4  游戏日志模块　117

1.12.5  可能的改进和扩展　118

1.12.6  总结　118

1.12.7  参考文献　118

1.13  透明的类的保存和加载技巧　119

Patrick Meehan　

1.13.1  小窍门　119

1.13.2  FreezeMgr的实现　120

1.13.3  其他几个特性　124

1.13.4  如何使用范例　125

1.13.5  总结　126

1.13.6  参考文献　126

1.14  高效且忽略缓存的ABT树实现方法　128

瑞士联邦理工学院(Swiss FederalInstitute of Technology，简称EPFL)，虚拟现实实验室(virtual Reality Lab，简称VRLab)，Sébastien Schertenleib

1.14.1  计算机内存结构　128

1.14.2  ABT树　129

1.14.3  确认阶段　134

1.14.4  总结　134

1.14.5  参考文献　134

1.15  状态机的可视化设计　136

Scott Jacobs

1.15.1  为什么需要代码生成　136

1.15.2  让“可视”成为可能　137

1.15.3  状态的管理　138

1.15.4  系统组装　138

1.15.5  总结　141

1.15.6  参考文献　141

1.16  泛型组件库　142

Warrick Buchanan

1.16.1  类型识别系统　142

1.16.2  工厂　143

1.16.3  工厂单例与子工厂　145

1.16.4  DLL工厂　145

1.16.5  组件　146

1.16.6  组件接口　147

1.16.7  接口版本管理　147

1.16.8  定义组件及其接口　149

1.16.9  组件的使用　150

1.16.10  配置组件库　151

1.16.11  总结　151

1.16.12  参考文献　151

1.17  选择自己的路线——菜单系统　152

Wendy Jones

1.17.1  为什么需要菜单系统　152

1.17.2  菜单系统的对象　153

1.17.3  总结　158

1.17.4  参考文献　159



第2章  数学

引言　162

Naughty Dog公司，Eric Lengyel

2.1  在计算机图形学中使用几何代数　163

Chris Lomont

2.1.1  引言　163

2.1.2  几何代数　164

2.1.3  线性代数　169

2.1.4  词典　171

2.1.5  实例　172

2.1.6  总结以及将来的方向　176

2.1.7  参考文献　177

2.2  最小加速度Hermite曲线　178

Tony Barrera,Barrera Kristiansen AB；G?vle大学创意媒体实验室AndersHast;乌普萨拉大学图像分析中心, Ewert Bengtsson

2.2.1  连接具有C1连续的最小弯曲曲线　180

2.2.2  封闭的最小弯曲的曲线　181

2.2.3  总结　182

2.2.4  参考文献　182

2.3  动画中基于样条的时间控制　183

Red StormEntertainment公司，James M. Van Verth

2.3.1  开始　183

2.3.2  一般的距离-时间函数　184

2.3.3  根据样条构造距离-时间函数　185

2.3.4  接口选择　191

2.3.5  总结　191

2.3.6  参考文献　191

2.4  快速四元数近似插值　193

Andy Thomason

2.4.1  使用四元数来表示旋转　193

2.4.2  四元数旋转插值　195

2.4.3  近似算法　196

2.4.4  算法之间的比较　206

2.4.5  Squad相关的计算　207

2.4.6  延伸阅读　208

2.4.7  总结　208

2.4.8  参考文献　208

2.5  极小极大数值近似　209

ChristopherTremblay

2.5.1  众所周知的优化　209

2.5.2  什么是理想的近似　210

2.5.3  极小极大近似的介绍　211

2.5.4  误差分析　214

2.5.5  进一步改进近似　215

2.5.6  参考文献　216

2.6  应用于镜面和入口的斜视锥　217

Eric Lengyel

2.6.1  平面的表示　217

2.6.2  投影矩阵　218

2.6.3  裁剪面的修改　219

2.6.4  OpenGL实现　221

2.6.5  Direct3D实现　224

2.6.6  致谢　225

2.6.7  参考文献　225



第3章  人工智能

引言　228

美国西北大学，Robin Hunicke

3.1  利用导航网格实现自动掩体寻找　230

Radical Entertainment公司，Borut Pfeifer

3.1.1  导航网格　230

3.1.2  开放目标寻路　231

3.1.3  搜索掩体位置　232

3.1.4  在掩体间行进　233

3.1.5  团队掩护行为　234

3.1.6  其他功能　235

3.1.7  总结　235

3.1.8  参考文献　236

3.2  使用人工势场实现快速目标评级　237

Factor 5公司，Markus Breyer

3.2.1  基本思想　237

3.2.2  公式　238

3.2.3  势值函数的评估　240

3.2.4  可视化　240

3.2.5  方向场的应用　241

3.2.6  多维扩展　242

3.2.7  总结　243

3.3  利用Lanchester损耗模型来预测战斗结果　244

Page 44 Studios有限责任公司，John Bolton

3.3.1  概述　244

3.3.2  场景1：全体混战　245

3.3.3  场景2：狭窄的石阶　247

3.3.4  场景3：炮战　248

3.3.5  场景4：关底Boss　250

3.3.6  关于战斗力的再讨论　251

3.3.7  局限性　252

3.3.8  总结　252

3.3.9  参考文献　252

3.4  为游戏AI实现一个实用的智能规划系统　254

RelicEntertainment公司，Jamie Cheng;加拿大阿尔伯塔大学计算机科学系，Finnegan Southey

3.4.1  规划系统的框架　255

3.4.2  规划域　255

3.4.3  一个多主体规划器的例子　258

3.4.4  规划的搜索　262

3.4.5  几个应用问题　263

3.4.6  优化　265

3.4.7  总结　266

3.4.8  参考文献　266

3.5  针对多线程架构的决策树查询算法优化　268

Intel公司，Chuck DeSylva

3.5.1  概述　268

3.5.2  注意事项　269

3.5.3  优化　270

3.5.4  总结　273

3.5.5  参考文献　273

3.6  利用并行虚拟机实现AI系统的并行开发　275

2015公司，Michael Ramsey

3.6.1  功能强大，但不白给　275

3.6.2  核心术语及概念　276

3.6.3  任务的创建　277

3.6.4  任务管理　279

3.6.5  PVM的实现　282

3.6.6  实际应用：即时战略游戏　283

3.6.7  强化游戏性　284

3.6.8  总结　285

3.6.9  参考文献　286

3.7  超越A*算法　287

Xtrem Strategy游戏公司，Mario Grimani；Monolith Productions公司，Matthew Titelbaum

3.7.1  问题的定义　287

3.7.2  算法　288

3.7.3  算法的改进　290

3.7.4  实现的细节　292

3.7.5  应用实例　292

3.7.6  性能方面的考虑　297

3.7.7  几个前沿问题　298

3.7.8  总结　299

3.7.9  参考文献　299

3.8  实现最小重新规划开销的先进寻路算法：动态A*(D*)算法　301

Marco Tombesi

3.8.1  D*算法　302

3.8.2  D*算法的实现细节　302

3.8.3  实例　303

3.8.4  在游戏中又如何呢？　305

3.8.5  总结　305

3.8.6  参考文献　305



第4章  物理学

引言　308

Red Storm娱乐公司，Mike Dickheiser

4.1  游戏物理中空气动力学的近似计算　310

美国应用研究联营公司(Applied ResearchAssociates Inc.)，Graham Rhodes

4.1.1  背景知识　310

4.1.2  钝体上的作用力　313

4.1.3  流线体上的作用力　315

4.1.4  应用实例　318

4.1.5  总结　319

4.1.6  参考文献　320

4.2  动态青草的模拟和其他自然环境特效　321

沃特卢大学，Rishi Ramraj

4.2.1  水面特效　321

4.2.2  青草的模拟　323

4.2.3  变化传播模型　324

4.2.4  树叶的模拟：模型的应用　325

4.2.5  总结　327

4.2.6  参考文献　327

4.3  使用质点-弹簧模型获得真实的布料动画　328

塞维利亚大学，Juan M. Cordero

4.3.1  布料的离散表示　328

4.3.2  作用力　330

4.3.3  动态系统方法　333

4.3.4  仿真模拟　334

4.3.5  结论　334

4.3.6  参考文献　335

4.4  适合游戏开发的实用柔体动画技术：受压柔体模型　336

波兰弗罗茨瓦夫大学，Maciej Matyka

4.4.1  简化的质点-弹簧模型　337

4.4.2  PSB模型背后的物理学　338

4.4.3  PSB模型的实现　339

4.4.4  典型的质点-弹簧模型　340

4.4.5  PSB步骤　341

4.4.6  体积计算　341

4.4.7  采用预估修正法的Heun积分　342

4.4.8  时间步长的计算速度　342

4.4.9  几个仿真实例　343

4.4.10  进一步的发展　344

4.4.11  总结　344

4.4.12  源代码说明　345

4.4.13  致谢　345

4.4.14  参考文献　345

4.5  使用反馈控制系统让“布娃娃”活起来　347

苹果公司，Michael Mandel

4.5.1  现有的研究成果　347

4.5.2  仿真过程的控制　348

4.5.3  行为动作的创建　350

4.5.4  总结　351

4.5.5  致谢　351

4.5.6  参考文献　351

4.6  预定式物理系统的设计　353

Daniel F.Higgins

4.6.1  什么是预定式物理系统　353

4.6.2  预定式物理引擎　356

4.6.3  打磨上光　360

4.6.4  龙卷风：一个好的开始　363

4.6.5  总结　365

4.6.6  参考文献　366

4.7  预定式物理系统：相关技术及应用　367

Shawn Shoemaker

4.7.1  为什么要使用预定式物理系统　367

4.7.2  预定式物理系统　368

4.7.3  应用1：RTS游戏中建筑物的毁坏　369

4.7.4  应用2：跳跃　369

4.7.5  应用3：爆炸特效中的物体运动　370

4.7.6  应用4：浮力　371

4.7.7  应用5：伞兵　371

4.7.8  总结　373

4.7.9  参考文献　373

4.8  三维汽车模拟器中真实的摄像机运动　374

匈牙利布达佩斯技术经济大学，控制工程与信息技术系，图形图像小组，Barnabás Aszódi，Szabolcs Czuczor

4.8.1  我们需要什么？物理法则　374

4.8.2  我们得到的是什么？偶尔不够真实的运动　375

4.8.3  考察摄像机的控制　376

4.8.4  终极决策：实现人类的行为　377

4.8.5  编程中涉及的问题　379

4.8.6  总结　382

4.8.7  关于演示程序　382



第5章  图形图像

引言　384

ATI公司，Jason L. Mitchell

5.1  在现代GPU上渲染逼真的云彩　386

育碧公司，Jean-Fran?ois Dubé

5.1.1  制造噪音　386

5.1.2  云彩的密度　388

5.1.3  云彩的光照处理　389

5.1.4  优化　390

5.1.5  总结　390

5.1.6  参考文献　391

5.2  下雪吧，下雪吧，下雪吧(下雨吧)　392

微软公司(现就职于Google公司)，NinianeWang;微软公司, Bretton Wade

5.2.1  使用纹理为粒子束建模　393

5.2.2  渲染雪或雨的视差　393

5.2.3  用锥体模拟摄像机的移动　394

5.2.4  合并到一个矩阵中　394

5.2.5  增加美工控制　395

5.2.6  总结　395

5.2.7  参考文献　395

5.3  Widget：快速渲染和持久化小物体　396

Martin Brownlow

5.3.1  Widget的网格　396

5.3.2  高效地绘制widget　397

5.3.3  裁剪widget　401

5.3.4  总结　403

5.3.5  参考文献　404

5.4  逼真的树木和森林的2.5维替用物　405

布达佩斯理工大学, Gábor Szijártó

5.4.1  引言　405

5.4.2  以前的基于图像的方法　406

5.4.3  改进以前的方法　407

5.4.4  算法　408

5.4.5  实现　409

5.4.6  总结　412

5.4.7  参考文献　413

5.5  无栅格的可控火焰　414

佛罗里达中心大学，计算机科学学院，NeeharikaAdabala；佛罗里达中心大学，计算机科学学院和电影与数字媒体学院，Charles E. Hughes

5.5.1  建模火焰　415

5.5.2  实时渲染　418

5.5.3  实例和讨论　419

5.5.4  总结　420

5.5.5  参考文献　420

5.6  使用公告牌粒子构建强大的爆炸效果　422

美国任天堂公司，Steve Rabin

5.6.1  最初的闪光　422

5.6.2  放射的火苗　423

5.6.3  白色的热核心　424

5.6.4  强烈的火球　424

5.6.5  散发的烟雾　425

5.6.6  碎片　426

5.6.7  效果表　426

5.6.8  额外的感觉　426

5.6.9  效率问题　427

5.6.10  总结　428

5.6.11  参考文献　428

5.7  渲染宝石的简单方法　429

ATI研究院公司，Thorsten Scheuermann

5.7.1  技术概览　429

5.7.2  法线和cubemap采样问题　430

5.7.3  传递的光能　430

5.7.4  反射　432

5.7.5  光斑　433

5.7.6  总结　436

5.7.7  参考文献　436

5.8  体积化的后期处理　437

A2M公司，Dominic Filion；摩托罗拉公司，Sylvain Boissé

5.8.1  体积化的后期处理　437

5.8.2  深度知识　438

5.8.3  使用shader作z比较　438

5.8.4  像素完美的裁剪　439

5.8.5  后期处理　440

5.8.6  最后一遍　440

5.8.7  多个体　440

5.8.8  总结　441

5.8.9  参考文献　441

5.9  过程式关卡生成　442

北得克萨斯大学，Timothy Roden和Ian Parberry

5.9.1  大致的方法　442

5.9.2  关卡设计　442

5.9.3  使用预制的几何体　443

5.9.4  图的生成　444

5.9.5  把预制件映射到图中　446

5.9.6  可见性和碰撞检测　448

5.9.7  增加关卡内容　448

5.9.8  总结　449

5.9.9  参考文献　449

5.10  重组shader　450

A2M公司，Dominic Filion

5.10.1  组合效果　450

5.10.2  处理组合爆炸　451

5.10.3  通过HLSL生成shader变体　452

5.10.4  整合重组的shader　454

5.10.5  通过shader建立完整的流水线　455

5.10.6  其他问题　455

5.10.7  总结　456

5.10.8  参考文献　456



第6章  网络和多玩家

引言　460

Shekhar Dhupelia

6.1  保持大型多人在线游戏大型、在线和永存　461

Tantrum游戏公司，Shea Street

6.1.1  快速浏览　461

6.1.2  大型化　462

6.1.3  保持在线　464

6.1.4  保持永存　465

6.1.5  总结　466

6.1.6  参考文献　466

6.2  实现一个无缝的世界服务器　467

育碧公司，Patrick Duquette

6.2.1  一些定义　467

6.2.2  实现　468

6.2.3  远程控制器，或如何管理服务器的启动时期　468

6.2.4  代理服务器　468

6.2.5  登录服务器　469

6.2.6  节点服务器　469

6.2.7  世界管理器　472

6.2.8  由此而往何处　473

6.2.9  IOCP　473

6.2.10  参考文献　473

6.3  设计一个脏话过滤系统　475

Shekhar Dhupelia

6.3.1  语法与内容　475

6.3.2  字典　475

6.3.3  解析器　476

6.3.4  过滤　476

6.3.5  最好的过滤实践　477

6.3.6  人工干涉　478

6.3.7  总结　478

6.3.8  参考文献　478

6.4  远程过程调用系统的快速和高效实现　480

Hyun-jik Bae

6.4.1  RPC：简介　483

6.4.2  RPC：设计　484

6.4.3  RPC：实现　486

6.4.4  RPC：使用　489

6.4.5  样例程序　490

6.4.6  更多特性　490

6.4.7  总结　492

6.4.8  参考文献　492

6.5  在对等通信中克服网络地址转换　493

Jon Watte

6.5.1  读者　493

6.5.2  IP地址　494

6.5.3  套接字使用　494

6.5.4  路由器、点、协议　495

6.5.5  UDP包图　496

6.5.6  什么是NAT　496

6.5.7  NAT是如何破坏客户/服务协议的　499

6.5.8  NAT是如何破坏对等协议的　501

6.5.9  用于游戏的端到端解决方案　503

6.5.10  总结　509

6.5.11  参考文献　509

6.6  一个可靠的消息协议　510

Martin Brownlow

6.6.1  术语定义　510

6.6.2  为什么要可靠的消息　510

6.6.3  传统的可靠消息　511

6.6.4  一个简单的方法　511

6.6.5  总结　514

6.6.6  延伸阅读　515

6.7  安全的随机数系统　516

Shekhar Dhupelia

6.7.1  随机数影响在线游戏　516

6.7.2  网络模型　517

6.7.3  随机数池　517

6.7.4  随机数发生器　518

6.7.5  重载标准的rand()和srand()　520

6.7.6  下一步：记录和调试　520

6.7.7  下一步：即时重放　520

6.7.8  总结　521

6.7.9  参考文献　521

6.8  安全的设计　522

Adam Martin, Grex游戏公司

6.8.1  安全问题真的如此重要么？　522

6.8.2  目标　523

6.8.3  术语　523

6.8.4  威胁模型：测试不安全性　524

6.8.5  安全策略：让威胁无效　527

6.8.6  同时修订两个文档　527

6.8.7  该技术的其他优势　528

6.8.8  延伸阅读　528

6.8.9  总结　529

6.8.10  参考文献　529



第7章  音频

引言　532

Mark DeLoura

7.1  多线程音频编程技巧　533

James Boer

7.1.1  多线程编程简介　533

7.1.2  线程的术语和机制　534

7.1.3  鉴别适合多线程编程的音频任务　535

7.1.4  Intel的超线程技术是什么　536

7.1.5  线程编程技巧和操作　536

7.1.6  多线程的示例程序　537

7.1.7  实时流数据机制　541

7.1.8  流和线程　541

7.1.9  总结　543

7.1.10  参考文献　543

7.2  基于组的声音管理　544

eV Interactive 公司，Matthew Harmon 

7.2.1  API包装预览　544

7.2.2  能力　545

7.2.3  定义组　546

7.2.4  实现细节　548

7.2.5  总结　549

7.3  利用三维曲面作为音频发生器　550

Sami hamlaoui

7.3.1  方法　550

7.3.2  点发生器：　551

7.3.3  线发生器　552

7.3.4  球体发生器　553

7.3.5  方体发生器　554

7.3.6  总结　555

7.3.7  光盘上的内容　555

7.3.8  参考文献　555

7.4  基于回馈延迟网络(FDN)的快速环境反响　556

Phenomic游戏开发公司，Christian Schüler

7.4.1  怎样将FDN作为资源来利用　556

7.4.2  什么是反响　557

7.4.3  回馈延迟网络(Feedback Delay Network)　557

7.4.4  选择正确的回馈矩阵　559

7.4.5  选择正确的延迟长度　560

7.4.6  控制回响时间　560

7.4.7  sweeping和细部延迟问题　561

7.4.8  总结和可能的改进　563

7.4.9  感谢　564

7.4.10  参考文献　564

7.5  单演讲者语音识别简介　566

Julien Hamaide

7.5.1  引言　566

7.5.2  识别系统　567

7.5.3  特征提取　568

7.5.4  即时配对匹配　570

7.5.5  训练　571

7.5.6  局限性　572

7.5.7  总结　572

7.5.8  参考文献　572




游戏编程精粹6



第1章　通用编程

简介　2

Adam Lake

1.1　Lock-Free算法　4

Toby Jones

1.1.1　Compare-And-Swap及其他通用原语　4

1.1.2　Lock-Free参数化的堆栈　6

1.1.3　Lock-Free参数化的队列　9

1.1.4　Lock-Free参数化的Freelist　11

1.1.5　总结　13

1.1.6　参考文献　13

1.1.7　相关资源　14

1.2　通过OpenMP来充分利用多核处理器的能力　15

Pete Isensee

1.2.1　OpenMP应用实例：粒子系统　15

1.2.2　好处　16

1.2.3　性能　16

1.2.4　OpenMP应用实例：碰撞检测　17

1.2.5　线程组　18

1.2.6　函数的并行化　18

1.2.7　缺陷　19

1.2.8　结论　20

1.2.9　参考文献　21

1.2.10　相关资源　21

1.3　用OpenCV库实现游戏中的计算机视觉　22

Arnau Ramisa、Enric Vergara、EnricMarti

1.3.1　引子　22

1.3.2　游戏中的计算机视觉　22

1.3.3　开放的计算机视觉库　22

1.3.4　计算机视觉在游戏中一个简单的应用　23

1.3.5　未来的工作　31

1.3.6　参考文献　31

1.4　游戏对象的地理网格注册　33

Roger Smith

1.4.1　引子　33

1.4.2　四叉树和八叉树　34

1.4.3　游戏对象的组织形式　35

1.4.4　总结　39

1.4.5　参考文献　39

1.5　BSP技术　40

Octavian Marius Chincisan

1.5.1　什么是BSP？为什么要使用BSP？　40

1.5.2　基于节点的BSP　41

1.5.3　渲染一个基于节点的BSP树　43

1.5.4　基于节点的BSP树(不进行分割)　43

1.5.5　凸状叶子BSP树　44

1.5.6　凸状叶子BSP树出入口生成　47

1.5.7　凸状叶子BSP树潜在可视集　48

1.5.8　PVS压缩　51

1.5.9　地形BSP　53

1.5.10　总结　53

1.5.11　参考文献　54

1.6　最相似字串匹配算法　55

James Boer

1.6.1　基于字符串的ID查找难题　55

1.6.2　问题的定义　56

1.6.3　现有的一些解决方案　56

1.6.4　我们自己定制的字串匹配解决方案　56

1.6.5　解决方案的实际应用　62

1.6.6　总结　63

1.6.7　参考文献　63

1.7　利用CppUnit实现单元测试　64

Blake Madden

1.7.1　单元测试技术概览　64

1.7.2　CppUnit概述　65

1.7.3　运行测试夹具　67

1.7.4　利用CppUnit进行模型类测试　68

1.7.5　私有函数的单元测试　74

1.7.6　用CppUnit测试底层功能　75

1.7.7　总结　79

1.7.8　参考文献　80

1.8　为游戏的预发布版本添加数字指纹，威慑并侦测盗版行为　81

Steve Rabin

1.8.1　威慑策略　81

1.8.2　利用水印和指纹来进行侦测　82

1.8.3　添加数字指纹的流程　83

1.8.4　数字指纹添加过程的安全性　83

1.8.5　数字指纹的添加策略　83

1.8.6　破解数字指纹　85

1.8.7　总结　86

1.8.8　参考文献　86

1.9　通过基于访问顺序的二次文件排序，实现更快速的文件加载　87

David Koenig

1.9.1　问题的提出　87

1.9.2　解决方案　88

1.9.3　基于访问的二次文件排序的工作流程　89

1.9.4　优化效果　90

1.9.5　影响最终优化结果的因素　90

1.9.6　潜在的问题　91

1.9.7　其他一些通用的最佳实践方法　91

1.9.8　总结　92

1.9.9　参考文献　92

1.10　你不必退出游戏：资产热加载技术可以实现快速的反复调整　93

Charles Nicholson

1.10.1　资产热加载的工作流程　93

1.10.2　资产热加载过程的剖析　94

1.10.3　实际应用中需要考虑的事项　97

1.10.4　示范程序　98

1.10.5　总结　99

1.10.6　进阶参阅　99



第2章　数学与物理

简介　　102

Jim Van Verth

2.1　浮点编程技巧　104

Chris Lomont

2.1.1　浮点数的格式　105

2.1.2　例程的设计　108

2.1.3　总结　117

2.1.4　参考文献　118

2.2　利用齐次坐标实现投影空间中的GPU计算　119

Vaclav Skala

2.2.1　相关的数学背景知识　119

2.2.2　利用齐次坐标进行计算　121

2.2.3　直线交叉　124

2.2.4　总结　125

2.2.5　附录A　125

2.2.6　附录B　126

2.2.7　致谢　127

2.2.8　参考文献　127

2.3　利用叉乘积求解线性方程组　128

Anders Hast

2.3.1　简介　128

2.3.2　隐式直线　130

2.3.3　高效的扫描转换的设置运算　132

2.3.4　求解三元一次方程组　134

2.3.5　总结　135

2.3.6　致谢　135

2.3.7　参考文献　135

2.4　适用于游戏开发的序列索引技术　137

Palem GopalaKrishna

2.4.1　相关术语　137

2.4.2　序列　138

2.4.3　范围序列　139

2.4.4　排列序列　142

2.4.5　组合序列　144

2.4.6　总结　147

2.4.7　参考文献　149

2.5　多面体浮力的精确计算　150

Erin Catto

2.5.1　浮力　150

2.5.2　多边形的面积　152

2.5.3　多面体的体积　153

2.5.4　物体部分没入水中的情况　154

2.5.5　算法的鲁棒性　157

2.5.6　阻力　158

2.5.7　关于源代码　159

2.5.8　总结　159

2.5.9　致谢　159

2.5.10　参考文献　159

2.6　带有刚体交互作用的基于粒子的实时流体仿真系统　161

Takashi Amada

2.6.1　流体仿真与平滑粒子的流体动力学　161

2.6.2　扩展SPH方法，以支持流体和刚体的交互作用　165

2.6.3　与动态刚体的交互作用：仿真更新　169

2.6.4　具体的实现细节　170

2.6.5　相关的优化　173

2.6.6　总结　174

2.6.7　参考文献　174



第3章　人工智能

引言　　176

Brain Schwab

3.1　游戏的制作方法——应用基于模型的决策——在雷神之锤III中应用蝗虫人工智能引擎　178

Armand Prieditis

Mukesh Dalal

3.1.1　引言　178

3.1.2　目前的游戏人工智能：基于规则　179

3.1.3　规则的问题　180

3.1.4　基于模型的游戏人工智能方法　182

3.1.5　对游戏的接口　182

3.1.6　对游戏人工智能开发者的好处和推论　183

3.1.7　雷神之锤III竞技场和蝗虫人工智能引擎　184

3.1.8　相关工作　185

3.1.9　结论和未来的工作　186

3.1.10　参考文献　186

3.2　独立非玩家角色合作行为的实现　187

Diego Garcés

3.2.1　可能的解决方案　187

3.2.2　非玩家角色的结构　189

3.2.3　合作的机制　189

3.2.4　例子：合作寻找玩家　194

3.2.5　结论　195

3.2.6　参考文献　195

3.3　针对游戏的基于行为的机器人架构　196

Hugo Pinto、Luis Otavio Alvares

3.3.1　包容体结构　196

3.3.2　扩展的行为网络　199

3.3.3　讨论　201

3.3.4　结论　201

3.3.5　参考文献　202

3.4　使用模糊感知器、有限状态自动机和扩展的行为网络为虚幻竞技场游戏构建一个目标驱动的机器人　203

Hugo Pinto、Luis Otavio Alvares

3.4.1　扩展的行为网络设计　203

3.4.2　层次模糊感知器　208

3.4.3　有限状态自动机行为模块　210

3.4.4　结论　211

3.4.5　参考文献　212

3.5　一个目标驱动的虚幻竞技场游戏角色程序：使用扩展的行为网络制作目标驱动的具有个性的代理　213

Hugo Pinto、Luis Otavio Alvares

3.5.1　扩展的行为网络　214

3.5.2　行为选择的质量　216

3.5.3　个性设计　218

3.5.4　结论　220

3.5.5　参考文献　221

3.6　用支持向量机为短期记忆建模　223

Julien Hamaide

3.6.1　支持向量机简介　223

3.6.2　短期记忆模型化　226

3.6.3　CPU的消耗限制　227

3.6.4　结论　228

3.6.5　参考文献　228

3.7　使用战力值评估模型进行战争役分析　229

Michael Ramsey

3.7.1　基本公式　229

3.7.2　计算兵力　230

3.7.3　计算潜在兵力　230

3.7.4　为武器效力进行建模　231

3.7.5　获得一个理论上的战争结局　232

3.7.6　关于CEV　232

3.7.7　一个QJM系统的例子　232

3.7.8　局限性　233

3.7.9　结论　234

3.7.10　参考文献　234

3.8　设计一个多层可插拔的AI引擎　235

Sebastien Schertenleib

3.8.1　相关工作　235

3.8.2　AI引擎架构　236

3.8.3　数据驱动类和属性　237

3.8.4　分优先级的任务管理器　240

3.8.5　性能问题和技术　241

3.8.6　工具　243

3.8.7　结论　244

3.8.8　参考文献　245

3.9　一个管理场景复杂度的模糊控制方法　247

Gabriyel Wong、Jialiang Wang

3.9.1　关键思想　247

3.9.2　为什么使用模糊控制？　247

3.9.3　工具　248

3.9.4　系统设计　249

3.9.5　游戏中的应用　251

3.9.6　假设　251

3.9.7　实现考虑　252

3.9.8　测试和结果　252

3.9.9　结论　254

3.9.10　致谢　254

3.9.11　参考文献　254



第4章　脚本和数据驱动系统

简介　　256

Graham Rhodes

4.1　脚本语言总述　258

Diego Garcés

4.1.1　为什么要使用脚本语言　258

4.1.2　简介　258

4.1.3　语言编码　259

4.1.4　与C++的整合　262

4.1.5　性能特点　267

4.1.6　开发支持特点　269

4.1.7　总结　271

4.1.8　参考文献　271

4.2　把C++对象绑定到Lua　273

Waldemar Celes、Luiz Henrique de Figueiredo、Roberto Ierusalimschy

4.2.1　绑定函数　273

4.2.2　绑定宿主对象和Lua数值　276

4.2.3　绑定宿主对象和Lua对象　278

4.2.4　宿主和Lua表绑定　282

4.2.5　总结　283

4.2.6　参考文献　285

4.3　使用LUA协同程序实现高级控制机制　286

Luiz Henrique de Figueiredo、Waldemar Celes、RobertoIerusalimschy

4.3.1　Lua协同程序　286

4.3.2　过滤器　287

4.3.3　迭代器　288

4.3.4　任务安排　291

4.3.5　协作式多线程　291

4.3.6　总结　296

4.3.7　参考文献　296

4.4　在多线程环境里处理高级脚本执行　297

Sebastien Schertenleib

4.4.1　基于组件的软件和脚本的解释程序　297

4.4.2　协同程序与微线程程序　298

4.4.3　微线程管理器　298

4.4.4　嵌入Python　300

4.4.5　试验和结果　304

4.4.6　总结　305

4.4.7　参考文献　305

4.5　使用非插入型代理导出角色属性　306

Matthew Campbell、Curtiss Murphy

4.5.1　角色、代理和属性　306

4.5.2　非插入型和动态体系结构　308

4.5.3　角色属性　308

4.5.4　角色代理　311

4.5.5　从理论到实践　313

4.5.6　总结　314

4.5.7　参考文献　314

4.6　基于组件的游戏对象系统　315

Chris Stoy

4.6.1　游戏对象　315

4.6.2　基本的游戏对象组件　316

4.6.3　在游戏对象中实现组建管理　317

4.6.4　组件间的通信　319

4.6.5　游戏组件模板　320

4.6.6　游戏对象模板　322

4.6.7　数据驱动的游戏对象创建　323

4.6.8　总结　324



第5章　图形学

简介　　326

Paul Rowan

5.1　交互角色真实的静止动作合成　328

Arjan Egges, Thomas Di Giacomo和Nadia Magnenat-Thalmann

5.1.1　简介　328

5.1.2　人体动画的主分量　329

5.1.3　姿势变换　331

5.1.4　姿势的连续微小变化　334

5.1.5　总结　337

5.1.6　参考文献　337

5.2　用自适应二叉树进行空间剖分　339

Martin Fleisz

5.2.1　如何建立自适应二叉树　339

5.2.2　ABT实现细节　340

5.2.3　找到合适的分割面　343

5.2.4　在动态场景中使用ABT　345

5.2.5　渲染ABT　346

5.2.6　总结　347

5.2.7　致谢　348

5.2.8　参考文献　348

5.3　用有向包围盒增强对象裁减　349

Ben St. John 

5.3.1　方法概要　349

5.3.2　传统技术　350

5.3.3　针对二维的有效解决方案　350

5.3.4　传统技术上的改进　352

5.3.5　对包围盒进行筛选　354

5.3.6　进一步改进　355

5.3.7　总结　356

5.3.8　参考文献　356

5.4　皮肤分离的优化渲染　357

Dominic Filion

5.4.1　简介　357

5.4.2　分割的概念　358

5.4.3　权重分割的启发式算法　359

5.4.4　骨骼调色板的启发式算法　359

5.4.5　启发式算法的细节　361

5.4.6　总结　364

5.5　GPU地形渲染　365

Harald Vistnes

5.5.1　算法　365

5.5.2　细节层次　366

5.5.3　避免裂缝　368

5.5.4　视锥体裁减　369

5.5.5　法线计算　369

5.5.6　碰撞检测　370

5.5.7　实现细节　370

5.5.8　运行结果　371

5.5.9　总结　372

5.5.10　参考文献　372

5.6　基于GPU的交互式流体动力学与渲染　373

Frank Luna

5.6.1　数学背景知识　374

5.6.2　GPU实现　376

5.6.3　流体互动　382

5.6.4　补充材料　383

5.6.5　总结　384

5.6.6　参考文献　384

5.7　基于多光源的快速逐像素光照渲染　386

Frank Puig Placeres

5.7.1　延迟解决方案　386

5.7.2　高端硬件的延迟着色实现　387

5.7.3　基本存储优化　389

5.7.4　着色器优化和硬件限制　391

5.7.5　扩展图像空间(Extending Image-Space)的后处理特效(Post-ProcessingEffects)　394

5.7.6　总结　394

5.7.7　参考文献　394

5.8　路标渲染的清晰化　395

J?rn Loviscach

5.8.1　反走样阈值划分纹理(Antialiasing Thresholded Textures)　396

5.8.2　阈值划分的优化纹理(Optimal Textures for Thresholding)　400

5.8.3　创作程序(The Authoring Application)　403

5.8.4　总结与展望　405

5.8.5　参考文献　405

5.9　天空渲染在游戏中的实际运用　407

Aurelio Reis

5.9.1　所需与所得相悖　407

5.9.2　天空的组成　408

5.9.3　瓶颈　409

5.9.4　立方体天空贴图概要　411

5.9.5　特殊时间　412

5.9.6　演示程序的黎明　413

5.9.7　进入地平线之下　414

5.9.8　总结　414

5.9.9　参考文献　415

5.10　基于OpenGL帧缓冲区对象的高动态范围渲染　416

Allen Sherrod

5.10.1　帧缓冲区对象简介　416

5.10.2　设置帧缓冲区对象　417

5.10.3　基于帧缓冲区对象的高动态范围渲染　419

5.10.4　总结　421

5.10.5　补充材料　421

5.10.6　参考文献　422



第6章　音频

简介　424

Alexander Brandon

6.1　由可变形网格(Deformable Meshes)实时生成声音　426

Marq Singer

6.1.1　对《游戏编程精粹4》的回顾　426

6.1.2　概述　427

6.1.3　对模态分析的简要回顾　427

6.1.4　声音要求　429

6.1.5　从变形到声音　429

6.1.6　总结　430

6.1.7　进一步阅读　430

6.1.8　参考文献　431

6.2　实时音效轻量级生成器　432

Frank Luchs

6.2.1　环境声引擎　432

6.2.2　声音合成　432

6.2.3　真实世界范例　434

6.2.4　总结　435

6.2.5　范例　436

6.2.6　参考文献　436

6.3　实时混音总线　437

James Boer

6.3.1　并非不重要的任务　437

6.3.2　实现音量总线链　438

6.3.3　以比率或分贝的形式来表示音量　440

6.3.4　执行效率问题　440

6.3.5　其他增强　441

6.3.6　总结　441

6.3.7　参考文献　441

6.4　可听集(Potentially Audible Sets)　442

Dominic Filion

6.4.1　PVS入门　442

6.4.2　PAS基础　443

6.4.3　直接声音路径　443

6.4.4　为门窗创建动态PAS　447

6.4.5　PAS扩展：传导(transmission)　448

6.4.6　PAS扩展：反射　449

6.4.7　总结　450

6.4.8　参考文献　450

6.5　一种开销较低的多普勒效果　451

Julien Hamaide

6.5.1　多普勒效果　451

6.5.2　编写多普勒效果程序　454

6.5.3　线性插值　454

6.5.4　根据R来计算下标　455

6.5.5　非恒定速度　456

6.5.6　信号对齐(Aliasing)　457

6.5.7　实现　457

6.5.8　总结　457

6.5.9　资源　458

6.6　仿造实时DSP效果　459

Robert Sparks

6.6.1　仿造　459

6.6.2　例子：收音机在房间中播放音乐　459

6.6.3　声音能量恒定曲线(Constant Power Volume Curve)　461

6.6.4　对声道音量进行进一步控制　461

6.6.5　在DirectSound中播放多声道文件　462

6.6.6　代价和好处　462

6.6.7　总结　462

6.6.8　致谢　462



第7章　网络及多人在线

简介　　464

Scott Jacobs

7.1　3D动画角色数据的动态自适应流　465

Thomas Di Giacomo、HyungSeok Kim、StephaneGarchery和Nadia Magnenat-Thalmann

Chris Joslin

7.1.1　简介　465

7.1.2　背景介绍与相关方法　465

7.1.3　处理可缩放3D数据的准备和实施　466

7.1.4　自适应数据的传输　471

7.1.5　总结　473

7.1.6　参考文献　473

7.2　大规模多人在线游戏基于复杂系统的高阶架构　475

Viknashavaran Narayanasamy、Kok-Wai Wong和Chun CheFung

7.2.1　复杂系统和突发性事件　475

7.2.2　多重架构　476

7.2.3　基于回馈的决策系统　484

7.2.4　总结　485

7.2.5　参考文献　485

7.3　为游戏物件生成全局唯一标识符　487

Yongha Kim

7.3.1　游戏物件GUID建立的需求　487

7.3.2　生成GUID　488

7.3.3　对于特殊情况的处理　489

7.3.4　总结　490

7.3.5　参考文献　490

7.4　利用Second Life为大规模多人在线游戏原形设计游戏概念原形　491

Peter A. Smith

7.4.1　简介　491

7.4.2　为什么要用到Second Life　491

7.4.3　初试“第二人生(Second Life)”　494

7.4.4　在Second Life中的设计要点　495

7.4.5　原形的开发　496

7.4.6　一个成功的例子　498

7.4.7　总结　499

7.4.8　参考文献　499

7.5　稳定的P2P游戏TCP连接及敏感NAT　501

Larry Shi

7.5.1　问题　501

7.5.2　技术水平　502

7.5.3　方法　503

7.5.4　应用方面　507

7.5.5　局限性　507

7.5.6　结论　508

7.5.7　参考文献　508








游戏编程精粹7



第1章　通用编程

简介　2

Adam Lake, 图形软件架构师，高级视觉计算(AVC)小组，英特尔

1.1　使用年龄和成本指标的高效率缓存替换　3

Colt“MainRoach”McAnlis，微软Ensemble工作室

1.1.1　概述　3

1.1.2　缓存替换算法　4

1.1.3　年龄和成本指标　5

1.1.4　结论　9

1.1.5　致谢　10

1.1.6　参考文献　10

1.2　高性能堆分配器　11

Dimitar Lazarov, Luxoflux

1.2.1　简介　11

1.2.2　相关工作　11

1.2.3　我们的解决方案　12

1.2.4　参考文献　18

1.3　用网络摄像头玩的视频游戏的光流　19

Arnau Ramisa, Institut d’Investigació enIntelligència Artificial

Enric Vergara, GeoVirtual

.Enric Martí, Universitat Autónoma de Barcelona

1.3.1　简介　19

1.3.2　OpenCV代码　20

1.3.3　第一种方法：图像差异　21

1.3.4　第二种方法：运动历史　21

1.3.5　第三种方法：Lucas-Kanade算法　22

1.3.6　光流游戏　23

1.3.7　参考文献　25

1.4　一个多平台线程引擎的设计与实现　26

Michael Ramsey

1.4.1　一个实用线程架构的系统设计　26

1.4.2　线程　28

1.4.3　线程分配策略　30

1.4.4　对象的线程　31

1.4.5　线程的安全性、重新进入、对象同步和数据访问　32

1.4.6　使用缓存线(或缓存的一致性)　32

1.4.7　如何使用GLRThreading库　32

1.4.8　结论　34

1.4.9　参考文献　34

1.5　给蜜蜂和游戏玩家：如何处理六边形贴片　35

Thomas Jahn, King Art

Jorn Loviscach, Hochschule Bremen

1.5.1　简介　35

1.5.2　六边形贴片的利弊　35

1.5.3　掌握六边形网格　38

1.5.4　实现技巧　39

1.5.5　应用　40

1.5.6　结论　42

1.5.7　参考文献　42

1.6　服务于即时战略游戏的基于细胞多孔机器(Cellular Automaton)的线条主界面　43

Carlos A. Dietrich

Luciana P. Nedel

Jooo L. D. Comba

1.6.1　关注上下文的控制等级　44

1.6.2　实现细节　45

1.6.3　结论　49

1.6.4　参考文献　49

1.7　第一人称射击游戏的脚步导航技术　50

Marcus Aurelius C. Farias

Daniela G. Trevisan

Luciana P. Nedel

1.7.1　介绍　50

1.7.2　用脚来导航　51

1.7.3　一个简单的游戏　55

1.7.4　玩家测试　56

1.7.5　结论　57

1.7.6　以后的工作　57

1.7.7　致谢　57

1.8　推迟函数调用的唤醒系统　58

Mark Jawad, Nintendo of America Inc

1.8.1　时间问题　58

1.8.2　案例分析　59

1.8.3　对函数调用分类　60

1.8.4　检视这个系统　60

1.8.5　结论　61

1.8.6　参考文献　61

1.9　多线程任务和依赖系统　62

Julien Hamaide

1.9.1　介绍　62

1.9.2　任务系统　63

1.9.3　依赖性管理器　66

1.9.4　后续的工作　68

1.9.5　结论　69

1.9.6　参考文献　70

1.10　高级调试技术　71

Martin Fleisz

1.10.1　程序崩溃　71

1.10.2　内存泄露　74

1.10.3　Windows错误汇报(WER)　75

1.10.4　框架　76

1.10.5　结论　77

1.10.6　参考文献　78

第2章　数学和物理

简介　80

Graham Rhodes, Applied Research

Associates, Inc.

2.1　随机数生成　82

Chris Lomont

2.1.1　背景：随机数生成　82

2.1.2　随机性测试　84

2.1.3　软件漂白　84

2.1.4　不加密随机数生成算法　85

2.1.5　加密RNG方法　89

2.1.6　创造随机数生成器的常见错误　90

2.1.7　代码　91

2.1.8　结论　91

2.1.9　参考文献　91

2.2　游戏中的快速通用光线查询　93

Jacco Bikker, IGAD/NHTV University of AppliedSciences——Breda, The Netherlands

2.2.1　光线追踪介绍　93

2.2.2　K维树概念和存储考虑　94

2.2.3　动态物体　101

2.2.4　示例程序　101

2.2.5　结论　102

2.2.6　参考文献　102

2.3　使用最远特性图的快速刚体碰撞检测　103

Rahul Sathe, Advanced Visual Computing, SSG，IntelCorp.

Dillon sharlet,Univesity of Colorado at Boulder

2.3.1　背景　103

2.3.2　预处理　104

2.3.3　运行时查询　106

2.3.4　性能分析和结束语　107

2.3.5　致谢　107

2.3.6　参考文献　108

2.4　使用投影空间来提高几何计算精度　109

Krzysztof Kluczek, Gda′nsk University ofTechnology

2.4.1　投影空间　109

2.4.2　R2空间中的基本对象　110

2.4.3　RP2空间中的点和直线　110

2.4.4　在RP2空间中的基本运算　111

2.4.5　在RP2空间中使用整数坐标进行精确的几何运算　112

2.4.6　在RP2空间中几何运算的数值范围限制　112

2.4.7　RP2空间运算的例子程序　114

2.4.8　拓展到第三维　116

2.4.9　结论　117

2.4.10　参考文献　117

2.5　使用XenoCollide算法简化复杂的碰撞　118

Gary Snethen, Crystal Dynamics

2.5.1　介绍　118

2.5.2　用支撑映射来表示形体　119

2.5.3　使用闵可夫斯基(Minkowski)差异来简化碰撞检测　121

2.5.4　使用闵可夫斯基入口简化(Minkowski Portal Refinement, MPR)来检测碰撞　122

2.5.5　使用MPR算法得到相交信息　125

2.5.6　结论　126

2.5.7　致谢　126

2.5.8　参考文献　126

2.6　使用变换语义的高效碰撞检测　128

José Gilvan Rodrigues Maia, UFC

Creto Augusto Vidal, UFC

Joaquim Bento Cavalcante-Neto, UFC

2.6.1　仿射变换和游戏　128

2.6.2　从矩阵中抽取语义　129

2.6.3　在碰撞检测中使用变换语义　131

2.6.4　结论　134

2.6.5　参考文献　135

2.7　三角样条　136

Tony Barrera, Barrera Kristiansen AB

Anders Hast, Creative Media Lab,University ofG?vle

Ewert Bengtsson, Centre For Image Analysis,UppsalaUniversity

2.7.1　背景知识　136

2.7.2　讨论　139

2.7.3　结论　139

2.7.4　参考文献　140

2.8　使用高斯随机性来拟真发射轨迹的变化　141

Steve Rabin, Nintendo of America Inc.

2.8.1　高斯分布　141

2.8.2　生成高斯随机性　142

2.8.3　其他应用　144

2.8.4　自然中的高斯分布　144

2.8.5　结论　144

2.8.6　参考文献　145

第3章　人工智能

简介　147

Brian Schwab

3.1　用行为克隆创建有趣的代理　149

John Harger

Nathan Fabian

3.1.1　实例：The Demo Game　149

3.1.2　结论　154

3.1.3　参考文献　155

3.2　设计一种真实并且统一的代理感知模型　156

Steve Rabin, Nintendo of America Inc.

Michael Delp, WXP Inc.

3.2.1　基本视觉模型　156

3.2.2　基本听觉模型　157

3.2.3　用椭圆扩充视觉模型工具箱　158

3.2.4　用确定性模拟人类视觉　159

3.2.5　用确定性模拟人类听觉　161

3.2.6　统一的感知模型　162

3.2.7　为统一感知模型添加记忆　163

3.2.8　结论　163

3.2.9　参考文献　163

3.3　管理AI算法复杂度：泛型编程方法　165

Iskander Umarov

Antoli Beliaev.

3.3.1　介绍　165

3.3.2　行为选择工作流程　166

3.3.3　实现　172

3.3.4　结论　178

3.3.5　参考文献　178

3.4　有关态度的一切：为意见、声望和NPC个性构建单元　180

Michael F.Lynch, Ph.D.,Rensselaer PolytechnicInstitute, Troy, NY

3.4.1　简介　180

3.4.2　态度　181

3.4.3　态度里有什么　182

3.4.4　复杂的态度对象　185

3.4.5　态度和行为　187

3.4.6　说服和影响　187

3.4.7　态度的社会交换　188

3.4.8　另一个例子　188

3.4.9　注意事项和结论　189

3.4.10　参考文献　190

3.5　用玩家追踪和交互玩家图来理解游戏AI　191

G. Michael Youngblood, UNC Charlotte

Priyesh N.Dixit, UNC Charlotte

3.5.1　简介　191

3.5.2　信息的价值　192

3.5.3　交互玩家图　197

3.5.4　行为的更深理解　201

3.5.5　结论　201

3.5.6　参考文献　202

3.6　面向目标的计划合并　204

Michael Dawe

3.6.1　回顾面向目标的计划系统　204

3.6.2　用于面向目标计划的计划合并　205

3.6.3　结论　208

3.6.4　参考文献　208

3.7　超越A*：IDA*和边缘搜索　209

Robert Kirk Delisle

3.7.1　A*和Dijkstra　210

3.7.2　迭代延伸A*(IDA*)　211

3.7.3　边缘搜索算法　212

3.7.4　结论　213

3.7.5　参考文献　213

第4章　音频

简介　215

Alexander Brandon

4.1　基于可编程图形硬件的音频信号处理　216

Mark France

4.1.1　GPGPU 编程概述　216

4.1.2　音频效果　217

4.1.3　室内效果　218

4.1.4　结论　219

4.1.5　参考文献　219

4.2　多流—编写次世代音频引擎的艺术　221

Jason Page, 索尼计算机娱乐公司欧洲分部

4.2.1　一切将如何开始　221

4.2.2　理解“次世代”音频　222

4.2.3　环绕声音　228

4.2.4　路由引导　231

4.2.5　结论　231

4.3　听仔细了，你应该不会再有机会听到这个了　233

Stephan Schütze

4.3.1　如何做到？采用不同的理念！　233

4.3.2　前进，砰！　234

4.3.3　旧的不去新的不来　236

4.3.4　称手利器　237

4.3.5　细节管理　238

4.3.6　为什么我们要再做一次　239

4.3.7　更进一步　239

4.3.8　结论　240

4.4　实时音频效果的运用　241

Ken Noland

4.4.1　声音系统的概览　242

4.4.2　声音缓存　243

4.4.3　分级缓存　244

4.4.4　效果和滤波器　245

4.4.5　压缩和流　246

4.4.6　结论　247

4.4.7　参考文献　247

4.5　上下文驱动，层叠混合　248

Robert Sparks

4.5.1　概述　248

4.5.2　实现　249

4.5.3　扩展实时调整的概念　252

4.5.4　效率　252

4.5.5　例子程序　253

4.5.6　结论　253

第5章　图形学

简介　255

Timothy E. Roden，Angelo StateUniversity

5.1　先进的粒子沉积　256

Jeremy Hayes，英特尔公司

5.1.1　为什么使用粒子　256

5.1.2　粒子沉积　256

5.1.3　改进粒子沉积　257

5.1.4　结论　263

5.1.5　参考文献　263

5.2　减少骨骼动画中的累积误差　264

Bill Budge，索尼娱乐美国分部

5.2.1　游戏动画系统的快速巡视　264

5.2.2　累积误差　265

5.2.3　结论　268

5.2.4　参考文献　268

5.3　粗糙材料漫反射光着色的另一个模型　269

Tony Barrera，Barrera KristiansenAB

Anders Hast，创造媒体实验室，University ofG?vle

Ewert Bengtsson，图像分析中心，UppsalaUniversity

5.3.1　简介　269

5.3.2　平坦效果　270

5.3.3　后向散射　272

5.3.4　结论　273

5.3.5　参考文献　273

5.4　高效的细分表面　275

Chris Lomont

5.4.1　细分方案的介绍　275

5.4.2　Loop细分的特征和选项　276

5.4.3　细分数据结构　281

5.4.4　细分算法的细节　283

5.4.5　性能问题　286

5.4.6　结论　288

5.4.7　参考文献　288

5.5　用径向基函数纹理来替代动画浮雕　290

Vitor Fernando Pamplona，Instituto deInformática: UFRGS

Manuel M. Oliveira，Instituto deInformática: UFRGS

Luciana Porcher Nedel，Instituto deInformática: UFRGS

5.5.1　简介　290

5.5.2　图像扭曲　291

5.5.3　径向基函数　292

5.5.4　插值扭曲函数　292

5.5.5　使用着色器评估扭曲函数　293

5.5.6　动画浮雕贴图　294

5.5.7　动画浮雕替代　294

5.5.8　结果　296

5.5.9　结论　297

5.5.10　鸣谢　297

5.5.11　参考文献　297

5.6　SM1.1和更高版本上的裁剪贴图　299

Ben Garney

GarageGames

5.6.1　裁剪贴图的基本概念　299

5.6.2　裁剪贴图的实现　300

5.6.3　如果你想节约些时间……　305

5.6.4　参考文献　306

5.7　一个先进的贴花系统　307

Joris Mans

Dmitry Andreev

5.7.1　要求　307

5.7.2　正常的贴花方法　307

5.7.3　先进的贴花方法　307

5.7.4　这个先进贴花系统的优势　310

5.7.5　性能和实验结果　312

5.7.6　演示　314

5.7.7　结论　314

5.7.8　参考文献　315

5.8　室外地形渲染的大纹理映射　316

Antonio Seoane, Javier Taibo, Luis Hernández, andAlberto Jaspe

VideaLAB, University of La Coru?a

5.8.1　简介　316

5.8.2　结构　317

5.8.3　更新缓存的内容　320

5.8.4　渲染问题　321

5.8.5　结果　323

5.8.6　结论　324

5.8.7　参考文献　324

5.9　基于艺术品的嫁接贴图渲染　325

Joshua A. Doss，先进的视觉计算，英特尔公司

5.9.1　资产　325

5.9.2　运行时　328

5.9.3　感谢　330

5.9.4　结论和未来的工作　330

5.9.5　参考文献　330

5.10　廉价的对话：动态实时口型同步(Lipsync)　331

Timothy E. Roden, Angelo State University

5.10.1　需求　331

5.10.2　一般过程　333

5.10.3　结论　336

5.10.4　参考文献　336

第6章　网络和多人游戏

简介　338

Diana Stelmack

6.1　游戏世界同步的高层抽象　339

Hyun-jik Baeb

6.1.1　HLA用法　340

6.1.2　游戏世界同步剖析　340

6.1.3　HLA组件　341

6.1.4　在HLA运行器中的视口　346

6.1.5　进一步讨论　348

6.1.6　结论　348

6.1.7　参考文献　348

6.2　网络游戏的身份验证　350

Jon Watte

6.2.1　介绍　350

6.2.2　游戏登录安全　350

6.2.3　保障游戏时安全　353

6.2.4　结论　354

6.2.5　参考文献　355

6.3　使用智能包嗅探器来调试游戏网络　357

David L. Koenig, The Whole Experience, Inc

6.3.1　智能包嗅探器概念　357

6.3.2　一个例子　357

6.3.3　传统调试技术的缺陷　358

6.3.4　实现　358

6.3.5　使用WinPcap库　359

6.3.6　降低安全风险　360

6.3.7　一个替代方案　361

6.3.8　例子程序　361

6.3.9　结论　361

6.3.10　参考文献　361

第7章　脚本和数据驱动系统

介绍　363

Scott Jacobs

Tom Forsyth

7.1　Lua自动绑定系统　364

Julien Hamaide

7.1.1　介绍　364

7.1.2　特性　364

7.1.3　函数的绑定　365

7.1.4　在Lua里的面向对象　365

7.1.5　在Lua里绑定C++对象　366

7.1.6　扩展绑定系统　371

7.1.7　结论　373

7.1.8　后续工作　374

7.1.9　例子　376

7.1.10　结论　376

7.1.11　参考文献　376

7.2　用内省(introspection)方式把C++对象序列化到数据库中　377

Joris Mans

7.2.1　元数据(Metadata)　377

7.2.2　数组　378

7.2.3　序列化成文本　378

7.2.4　数据库系统　378

7.2.5　例子　390

7.2.6　问题和将来的改进　390

7.2.7　结论　391

7.2.8　参考文献　391

7.3　数据端口　392

Martin Linklater

7.3.1　概述　392

7.3.2　类型安全　394

7.3.3　引用计数　394

7.3.4　实践例子　394

7.3.5　问题　395

7.3.6　结论　396

7.4　支持你本地的美术家：为你的引擎增加shader　397

Curtiss Murphy; Alion Science and Technology

7.4.1　shader专用名词　 397

7.4.2　程序、参数和管理器，哦我的老天！　398

7.4.3　灵活性是关键　399

7.4.4　原型　400

7.4.5　shader参数　401

7.4.6　例子——飞艇目标　403

7.4.7　高级技术　405

7.4.8　后续工作　407

7.4.9　结论　407

7.4.10　参考文献　407

7.5　与蟒共舞　用好AST　408

邹光先

7.5.1　简介　408

7.5.2　背景　408

7.5.3　方案　409

7.5.4　结论　411

7.5.5　参考文献　411




游戏编程精粹8



Section 1  Graphics           

         Introduction              1

         1.1   Fast Font Rendering with Instancing                3

         1.2   Principles and Practice of Screen SpaceAmbient Occlusion             12

         1.3   Multi-Resolution Deferred Shading                   32

         1.4   View Frustum Culling of Catmull-Clark Patchesin DirectX 11                   39

         1.5   Ambient Occlusion Using DirectX ComputeShader                  50

         1.6   Eye-View Pixel Anti-Aliasing for IrregularShadow Mapping            74

         1.7   Overlapped Execution on Programmable GraphicsHardware                 90

         1.8   Techniques for Effective Vertex and FragmentShading on the SPUs                101



Section 2  Physics andAnimation              

         Introduction              119

         2.1   A versatile and interactive anatomical humanface model              121

         2.2   Curved paths for seamless character animation             132

         2.3   Non-iterative, closed-form, inverse kinematicchain solver             141

         2.4   Particle swarm optimization for gameprogramming              152

         2.5   Improved numerical integration withanalytical techniques            168

         2.6   What a drag: modeling realisticthree-dimensional air and fluid resistance           183

         2.7   Application of quasi-fluid dynamics forarbitrary closed meshes             194

         2.8   Approximate convex decomposition forreal-time collision detection             201



Section 3  

         Introduction              211

         3.1   AI level of detail for reality large worlds          213

         3.2   A pattern-based approach to modular AI forgames                232

         3.3   Automated navigation mesh generation usingadvanced growth-based techniques     244

         3.4   A practical spatial architecture for animaland agent navigation            256

         3.5   Applying control theory to game AI an physics                 284

         3.6   Adaptive tactic selection in first-personshooter (FPS) Games                 279

3.7   Embracing chaos theory: generating apparentunpredictability through deterministic systems           288

3.8   Needs-based AI                 302

3.9   A framework for emotional digital actors                 312

3.10 Scalable dialog authoring                  323

3.11 Graph-based data mining for player traceanalysis in MMORPGs



Section 4  Generalprogramming

         Introduction              353

         4.1   Fast-IsA             355

         4.2   Registered variables                 363

         4.3   Efficient and scalable multi-core programming                373

         4.4   Game optimization through the lens of memoryand data access          385

         4.5   Stack allocation                 393

         4.6   Design and implementation of an in-gamememory profiler           402

         4.7   A more informative error log generator          409

         4.8   Code coverage for QA               416

         4.9   Domain-specific languages in game engines           428

         4.10 A flexible user interface layout system fordivergent environments                442

         4.11 Road creation for projectable terrain meshes                  453

         4.12 Developing for digital drawing tablets             462

4.13 Creating a multi-threaded actor-basedarchitecture using intel threading building blocks   473

Section 5  Networking andmultiplayer

         Introduction              485

         5.1   Secure channel communication                487

         5.2   Social networks in games: playing with yourfacebook friends                 498

         5.3   Asynchronous I/O for scalable game servers           506

         5.4   Introduction to 3D streaming technology inmassively multiplayer online games          514



Section 6  Audio

         Introduction              539

         6.1   A practical DSP radio effect              542

         6.2   Empowering your audio team with a greatengine                   553

         6.3   Real-time sound synthesis for rigid bodies               563



Section 7  General purposecomputing on GPUs

         Introduction              573

         7.1   Using heterogeneous parallel architectureswith OpenGL              575

         7.2   PhysX GPU rigid bodies in batman: arkhamasylum                  590

         7.3   Fast GPU fluid simulation in PhysX           602



Index                  616






