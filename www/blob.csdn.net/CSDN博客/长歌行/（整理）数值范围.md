# （整理）数值范围 - 长歌行 - CSDN博客





2013年11月12日 09:39:16[iuhsihsow](https://me.csdn.net/iuhsihsow)阅读数：2081








 从网上整理







PartI C++

原始网址：

[http://blog.csdn.net/xuexiacm/article/details/8122267](http://blog.csdn.net/xuexiacm/article/details/8122267)





### [C/C++中各种类型int、long、double、char表示范围（最大最小值）](http://blog.csdn.net/xuexiacm/article/details/8122267)


分类： [问题](http://blog.csdn.net/xuexiacm/article/category/1265178)[读书笔记](http://blog.csdn.net/xuexiacm/article/category/1098050)[C++primer](http://blog.csdn.net/xuexiacm/article/category/1259491)2012-10-28
 22:165304人阅读[评论](http://blog.csdn.net/xuexiacm/article/details/8122267#comments)(0)收藏[举报](http://blog.csdn.net/xuexiacm/article/details/8122267#report)




**[cpp]**[view
 plain](http://blog.csdn.net/xuexiacm/article/details/8122267#)[copy](http://blog.csdn.net/xuexiacm/article/details/8122267#)

- #include<iostream>
- #include<string>
- #include <limits>
- **using****namespace** std;  
- 
- **int** main()  
- {  
-     cout << "type: \t\t" << "************size**************"<< endl;  
-     cout << "bool: \t\t" << "所占字节数：" << **sizeof**(**bool**);  
-     cout << "\t最大值：" << (numeric_limits<**bool**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<**bool**>::min)() << endl;  
-     cout << "char: \t\t" << "所占字节数：" << **sizeof**(**char**);  
-     cout << "\t最大值：" << (numeric_limits<**char**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<**char**>::min)() << endl;  
-     cout << "signed char: \t" << "所占字节数：" << **sizeof**(**signed****char**);  
-     cout << "\t最大值：" << (numeric_limits<**signed****char**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<**signed****char**>::min)() << endl;  
-     cout << "unsigned char: \t" << "所占字节数：" << **sizeof**(unsigned **char**);  
-     cout << "\t最大值：" << (numeric_limits<unsigned **char**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<unsigned **char**>::min)() << endl;  
-     cout << "wchar_t: \t" << "所占字节数：" << **sizeof**(**wchar_t**);  
-     cout << "\t最大值：" << (numeric_limits<**wchar_t**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<**wchar_t**>::min)() << endl;  
-     cout << "short: \t\t" << "所占字节数：" << **sizeof**(**short**);  
-     cout << "\t最大值：" << (numeric_limits<**short**>::max)();  
-     cout << "\t\t最小值：" << (numeric_limits<**short**>::min)() << endl;  
-     cout << "int: \t\t" << "所占字节数：" << **sizeof**(**int**);  
-     cout << "\t最大值：" << (numeric_limits<**int**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**int**>::min)() << endl;  
-     cout << "unsigned: \t" << "所占字节数：" << **sizeof**(unsigned);  
-     cout << "\t最大值：" << (numeric_limits<unsigned>::max)();  
-     cout << "\t最小值：" << (numeric_limits<unsigned>::min)() << endl;  
-     cout << "long: \t\t" << "所占字节数：" << **sizeof**(**long**);  
-     cout << "\t最大值：" << (numeric_limits<**long**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**long**>::min)() << endl;  
-     cout << "unsigned long: \t" << "所占字节数：" << **sizeof**(unsigned **long**);  
-     cout << "\t最大值：" << (numeric_limits<unsigned **long**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<unsigned **long**>::min)() << endl;  
-     cout << "double: \t" << "所占字节数：" << **sizeof**(**double**);  
-     cout << "\t最大值：" << (numeric_limits<**double**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**double**>::min)() << endl;  
-     cout << "long double: \t" << "所占字节数：" << **sizeof**(**long****double**);  
-     cout << "\t最大值：" << (numeric_limits<**long****double**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**long****double**>::min)() << endl;  
-     cout << "float: \t\t" << "所占字节数：" << **sizeof**(**float**);  
-     cout << "\t最大值：" << (numeric_limits<**float**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**float**>::min)() << endl;  
-     cout << "size_t: \t" << "所占字节数：" << **sizeof**(**size_t**);  
-     cout << "\t最大值：" << (numeric_limits<**size_t**>::max)();  
-     cout << "\t最小值：" << (numeric_limits<**size_t**>::min)() << endl;  
-     cout << "string: \t" << "所占字节数：" << **sizeof**(string) << endl;  
- // << "\t最大值：" << (numeric_limits<string>::max)() << "\t最小值：" << (numeric_limits<string>::min)() << endl;
-     cout << "type: \t\t" << "************size**************"<< endl;  
- **return** 0;  
- }  




![](https://img-my.csdn.net/uploads/201210/30/1351591412_5204.PNG)



/*运行结果分析：


以上结果已经很明白了，一下补充说明几点：


概念、整型：表示整数、字符和布尔值的算术类型合称为整型（integral type）。


关于带符号与无符号类型：整型 int、stort  和  long 都默认为带符号型。要获得无符号型则必须制定该类型为unsigned，比如unsigned long。unsigned int类型可以简写为unsigned，也就是说，unsigned后不加其他类型说明符就意味着是unsigned int。


一字节表示八位，即：1byte = 8 bit;


int: 4byte =  32 bit 有符号signed范围：2^31-1 ~ -2^31即：2147483647 ~ -2147483648无符号unsigned范围：2^32-1 ~ 0即：4294967295 ~ 0


long: 4 byte = 32 bit 同int型


double: 8 byte = 64 bit 范围：1.79769e+308 ~ 2.22507e-308


long double: 12 byte = 96 bit 范围： 1.18973e+4932 ~ 3.3621e-4932


float: 4 byte = 32 bit 范围： 3.40282e+038 ~ 1.17549e-038


int、unsigned、long、unsigned long 、double的数量级最大都只能表示为10亿，即它们表示十进制的位数不超过10个，即可以保存所有9位整数。而short只是能表示5位；





另外对于浮点说而言：使用double类型基本上不会有错。在float类型中隐式的精度损失是不能忽视的，二双精度计算的代价相对于单精度可以忽略。事实上，在有些机器上，double类型比float类型的计算要快得多。float型只能保证6位有效数字，而double型至少可以保证15位有效数字（小数点后的数位），long double型提供的精度通常没有必要，而且还要承担额外的运行代价。


double是8字节共64位，其中小数位占52位，2-^52=2.2204460492503130808472633361816e-16，量级为10^-16，故能够保证2^-15的所有精度。


在有些机器上，用long类型进行计算所付出的运行时代价远远高于用int类型进行同样计算的代价，所以算则类型前要先了解程序的细节并且比较long类型与int类型的实际运行时性能代价。




——桑海整理




partII C#

原文地址：[http://www.cnblogs.com/libingql/archive/2011/08/08/2131388.html](http://www.cnblogs.com/libingql/archive/2011/08/08/2131388.html)





# [3.1.1、整数类型](http://www.cnblogs.com/libingql/archive/2011/08/08/2131388.html)



一、整型类型

        C#中定义了8中整数类型：字节型(byte)、无符号字节型(ubyte)、短整型(short)、无符号短整型(ushort)、整型(int)、无 符号整型(uint)、长整型(long)、无符号长整型(ulong)。划分依据是该类型的变量在内存中所占的位数。

        C#中每个整数类型都对应于.NET类库中定义的一个结构，这些结构在程序集System中定义。上述结构均提供两个基本属性：MinValue和MaxValue，分别表示类型的最小值和最大值。
|数据类型|说明|取值范围|对应于System程序集中的结构|
|----|----|----|----|
|sbyte|有符号8位整数|-128~127|SByte|
|byte|无符号8位整数|0~255|Byte|
|short|有符号16位整数|-32768~32767|Int16|
|ushort|无符号16位整数|0~65535|UInt16|
|int|有符号32位整数|-2147483648-2147483647|Int32|
|uint|无符号32位整数|0~4294967295|UInt32|
|long|有符号64位整数|-9223372036854775808~9223372036854775807|Int64|
|ulong|无符号64位整数|0~18446744073709551615|UInt64|




整数取值范围代码：


![复制代码](http://common.cnblogs.com/images/copycode.gif)
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace IntegerRange
{
class Program
    {
staticvoid Main(string[] args)
        {
            Console.WriteLine("整数类型的取值范围:");
// sbyte
            Console.Write("SByte:\t");
            Console.Write(SByte.MinValue);
            Console.Write("~");
            Console.WriteLine(SByte.MaxValue);

// byte
            Console.Write("Byte:\t");
            Console.Write(Byte.MinValue);
            Console.Write("~");
            Console.WriteLine(Byte.MaxValue);

// short
            Console.Write("Int16:\t");
            Console.Write(Int16.MinValue);
            Console.Write("~");
            Console.WriteLine(Int16.MaxValue);

// ushort
            Console.Write("UInt16:\t");
            Console.Write(UInt16.MinValue);
            Console.Write("~");
            Console.WriteLine(UInt16.MaxValue);

// int
            Console.Write("Int32:\t");
            Console.Write(Int32.MinValue);
            Console.Write("~");
            Console.WriteLine(Int32.MaxValue);

// uint
            Console.Write("UInt32:\t");
            Console.Write(UInt32.MinValue);
            Console.Write("~");
            Console.WriteLine(UInt32.MaxValue);

// long
            Console.Write("Int64:\t");
            Console.Write(Int64.MinValue);
            Console.Write("~");
            Console.WriteLine(Int64.MaxValue);

// ulong
            Console.Write("UInt64:\t");
            Console.Write(UInt64.MinValue);
            Console.Write("~");
            Console.WriteLine(UInt64.MaxValue);

            Console.WriteLine();
        }
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)


执行结果：


![复制代码](http://common.cnblogs.com/images/copycode.gif)
整数类型的取值范围:
SByte:  -128~127
Byte:   0~255
Int16:  -32768~32767
UInt16: 0~65535
Int32:  -2147483648~2147483647
UInt32: 0~4294967295
Int64:  -9223372036854775808~9223372036854775807
UInt64: 0~18446744073709551615

请按任意键继续. . .
![复制代码](http://common.cnblogs.com/images/copycode.gif)


如果类型取值超出了取值范围，程序在运行时就会发生溢出。

Byte溢出代码：


![复制代码](http://common.cnblogs.com/images/copycode.gif)
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace IntegrateOverflow
{
class Program
    {
staticvoid Main(string[] args)
        {
byte b =100;
            b = (byte)(b +200); // 溢出

            Console.WriteLine(b);
        }
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)


执行结果：

44
请按任意键继续. . .








**Part III Js:**




原文地址：[http://monmonkey.com/javascript/jiben1.html](http://monmonkey.com/javascript/jiben1.html)





## 数值（Number）
[首页](http://www.monmonkey.com/) > [JavaScript基本对象](http://monmonkey.com/javascript/jibenduixiang.html) >
 数值（Number）
#### ■ 目录
- [数值](http://monmonkey.com/javascript/jiben1.html#shuzhi)
- [数值对象](http://monmonkey.com/javascript/jiben1.html#duixiang)
- [把字符串转换成数值](http://monmonkey.com/javascript/jiben1.html#zifuchuan)
- [转换成n进制](http://monmonkey.com/javascript/jiben1.html#jinzhi)
- [数值报错](http://monmonkey.com/javascript/jiben1.html#baocuo)
- [极限值](http://monmonkey.com/javascript/jiben1.html#jixian)

#### ■ 一览

[MAX_VALUE](http://monmonkey.com/javascript/jiben1.html#MAX_VALUE), [MIN_VALUE](http://monmonkey.com/javascript/jiben1.html#MIN_VALUE), [NaN](http://monmonkey.com/javascript/jiben1.html#NaN), [NEGATIVE_INFINITY](http://monmonkey.com/javascript/jiben1.html#NEGATIVE_INFINITY), [Number()](http://monmonkey.com/javascript/jiben1.html#newNumber), [POSITIVE_INFINITY](http://monmonkey.com/javascript/jiben1.html#POSITIVE_INFINITY), [toString(*radix*)](http://monmonkey.com/javascript/jiben1.html#toString)

#### ■ 数值


JavaScript 中可以使用10进制数、8进制数、16进制数、实数、浮点数。以 0 开头的整数是8进制数，以 0x 开头的整数是16进制数。
12345    // 10进制数 12345
1.23     // 实数 1.23
1.23e4   // 1.23 × 10的4次方
1.23E4   // 1.23 × 10的4次方
0777     // 8进制数777
0xff88   // 16进制数FF88


#### ■ 数值对象


◆ *number* = new Number(*value*)


生成一个保存了 *value* 的值的数值对象。为了符合面向对象中“数据类型都可以生成对象”的思想，JavaScript准备了这个类，不过基本没什么人用。严格来说，数值和数值对象是不同的东西。
xx = new Number(123);
yy = 123;
zz = xx + yy;
alert(typeof(xx));  // 取得xx的type，结果是object（对象）
alert(typeof(yy));  // 取得yy的type，结果是number（数值）
alert(typeof(zz));  // 取得zz的type，结果是number（计算结果是数值）


#### ■ 把字符串转换成数值


把字符串转换成数值可以使用 parseInt()、parseFloat()、Number() ，或者直接减去数值 0 。
str = "123";
num1 = parseInt(str);
num2 = parseFloat(str);
num3 = Number(str);
num4 = str - 0;


#### ■ 转换成n进制


◆ *number*.toString(*radix*)


使用 toString() 可以把数值转换成 *radix* 进制数（2～36。默认为10）的字符串。下面的例子把 65535 转换成了 16 进制数的字符串 "ffff" 。
xx = 65535;
alert(xx.toString(16));


#### ■ 数值报错


◆ Number.NaN


NaN 是表示“非数值”(Not a Number)的特殊值。它不能使用 == 之类的关系运算符，要确认一个变量是否为数值，请使用 isNaN() 。
var mon = 13;
if ((mon < 1) || (12 < mon)) {
    mon = Number.NaN;
}
if (isNaN(mon)) {
    alert("错误的月份。");
}


#### ■ 极限值


◆ Number.MAX_VALUE


◆ Number.MIN_VALUE


MAX_VALUE 是可使用的最大值（约 1.79769e308）。MIN_VALUE 是可使用的最小值（约 5e-324），接近 0 ，但不是负数，比MIN_VALUE更小的值会被转换成 0 。
xx = 1.8 * 1.0e308;
if (xx >= Number.MAX_VALUE) {
   alert("超过可计算的范围。");
}



◆ Number.POSITIVE_INFINITY


◆ Number.NEGATIVE_INFINITY


POSITIVE_INFINITY 是表示“无限大的正数”的特殊值。NEGATIVE_INFINITY 是表示“无限大的负数”的特殊值。它们可以用来检查乘法等计算的计算结果有没有超出 JavaScript 可使用数值的范围。
xx = 1.8 * 1.0e308;
if ((xx == Number.POSITIVE_INFINITY)
 || (xx == Number.NEGATIVE_INFINITY)) {
   alert("超过可计算的范围。");
}




附：

如果整数位数太多，会有精度损失，使用console输入一下数值，会在第17位后的数字进行四舍五入。


>1234567890123456789

1234567890123456800







