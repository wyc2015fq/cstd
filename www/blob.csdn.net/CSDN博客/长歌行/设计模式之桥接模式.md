# 设计模式之桥接模式 - 长歌行 - CSDN博客





2013年02月01日 16:23:03[iuhsihsow](https://me.csdn.net/iuhsihsow)阅读数：815
个人分类：[C、C++																[设计架构](https://blog.csdn.net/iuhsihsow/article/category/1076810)](https://blog.csdn.net/iuhsihsow/article/category/1072760)

所属专栏：[初探设计模式（C++实现）](https://blog.csdn.net/column/details/baadf00df00dabadfds0.html)








将整体里面的可能变化的部分抽象出来




其实个人对桥接模式不是很理解，貌似接触的里面没有这么复杂的结构




不过还是多用聚合，少用继承吧。（总觉得聚合组合比较好管理，一个好的继承是需要千锤百炼的，多重继承，多层继承的内存消耗不可小觑）




自己对这个模式都没有怎么理解，那么写出的代码估计也不敢恭维，不过还是写下来，作为记录吧。



```cpp
// Bridge.cpp : Defines the entry point for the console application.
//

// 情景假设
// 一个渲染引擎，支持D3D和OpenGL， 需要提供一系列接口，用于绘制不同物体
// 如茶壶，立方体等

// 最简单的实现是，四个函数，2 * 2，但是当多一种物体，就要多加两个函数，
// 关键是修改的部位比较靠底层。

// 使用桥接模式的话，会更支持扩展

#include "stdafx.h"


class ObjRenderInfo;

class Object
{
public:
	 virtual ObjRenderInfo* GetObjInfor() = 0;
};

class Teapot : public Object
{
public:
	ObjRenderInfo* GetObjInfor(){return NULL;}
};

class Cube : public Object
{
public:
	ObjRenderInfo* GetObjInfor(){return NULL;}
};

class ObjRender
{
public:
	void SetObj(Object * obj)
	{
		m_object = obj;
	}
	virtual void Render() = 0;
protected:
	Object *m_object;	
};

class D3DRender : public ObjRender
{
public:
	void Render()
	{
		if (m_object)
		{
			ObjRenderInfo *pInfo = m_object->GetObjInfor();
			// 使用D3d的函数结合物体本身的渲染信息，如几何体，纹理进行渲染
			D3dRenderFunction(pInfo);
		}
	}
private:
	void D3dRenderFunction(ObjRenderInfo *){;}
};

class OpenGLRender : public ObjRender
{
public:
	void Render()
	{
		if (m_object)
		{
			ObjRenderInfo *pInfo = m_object->GetObjInfor();
			// 使用OpenGL的函数结合物体本身的渲染信息，如几何体，纹理进行渲染
			OpenGLRenderFunction(pInfo);
		}
	}
private:
	void OpenGLRenderFunction(ObjRenderInfo *){;}
};


// 如果要再绘制茶杯，就添加一个茶杯类就OK了。
int _tmain(int argc, _TCHAR* argv[])
{
	ObjRender *pD3dRender = new D3DRender;
	Object *pObj = new Teapot;
	pD3dRender->SetObj(pObj);
	pD3dRender->Render();
	if (pD3dRender)
	{
		delete pD3dRender;
		pD3dRender = NULL;
	}
	if (pObj)
	{
		delete pObj;
		pObj = NULL;
	}
	return 0;
}
```






