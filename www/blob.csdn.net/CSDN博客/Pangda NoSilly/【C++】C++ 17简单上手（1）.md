# 【C++】C++ 17简单上手（1） - Pangda NoSilly - CSDN博客

2018年06月26日 19:24:43[hepangda](https://me.csdn.net/hepangda)阅读数：445


C++ 17标准已经发布了有一段时间了（甚至于后一个版本C++ 20也在路上了），最近终于得空（懒癌治愈），查阅了相关资料，简单上手一下。感觉到，一个是“现代”C++和C语言确实已经是天差地别，另一个就是标准库中的东西以及新语法确实更加方便我们编程了。虽然这些特性也许很长一段时间内都不一定用得上，然而学习一下总是好的，并且，体验一下“更现代”的C++的感觉也不错。

## 带初始化的选择语句

这个特性用于`if`和`switch`语句中，现在允许在这两个选择语句中声明并初始化一个变量，该变量在整个选择语句中都可用。这个特性显然有助于代码的清晰性，现在你可以这样写了：

```
if (int fd = open("filename", O_RDWR | O_CREAT); fd == -1) {
    perror("something");
} else {
    // 可以继续在这里使用fd
}

switch (int op = getOp(); op) {
case xxx:
    ...
case yyy:
    ...
case zzz:
    ...
}
```

## constexpr if

这个特性是一种编译期`if`，用于在编译期检查相关条件，并决定执行相关代码。模板编程相关的内容可能非常需要这个特性，另外，此特性也有助于消除多余的`std::enable_if`。例如，之前可能需要使用两个模板才能完成的变参模板函数，现在可以通过`constexpr if`进行，大大提升了代码的可读性：

```cpp
template<typename T>
std::enable_if_t<std::is_integral<T>::value, std::string> to_string(T arg) {
    return std::to_string(arg);
}

template<typename T>
std::enable_if_t<!std::is_integral<T>::value, std::string> to_string(T arg) {
    return arg;
}

// 以上写法使用新特性可以写为：

template<typename T>
std::string to_string(T arg) {
    if constexpr (std::is_integral<T>::value) {
        return std::to_string(arg);
    } else {
        return arg;
    }
}
```

## 结构化绑定

这个特性可以看做是一个语法糖， 它允许我们将`std::pair`、`std::tuple`等支持使用`std::get<>`函数获得其中对应项的值的类，或者一个访问权限全部为`public`的类（或结构体）的每个元素绑定到若干个变量上，类似于：

```cpp
auto [first, second] = std::pair(true, 123);
// 此时first == true， second == 123

int ar[4] = { 1, 2, 3, 4 };
auto [a1, a2, a3, a4] = ar;
// 此时a1 == 1, a2 == 2, a3 == 3, a4 == 4

struct abc {
    int a, b, c;
};
constexpr abc getAbc() {
    return { 10, 20, 30 };
}
auto [a, b, c] = getAbc();
// 此时a == 10, b == 20, c == 30

// 当然结构化绑定肯定可以用在Range-based for中
std::map<int, double> m;
for (auto [i, j]: m) {
    std::cout << i << ": " << j << std::endl;
}
```

## 字节类型

在头文件`<cstddef>`中加入了新的类型`std::byte`，该类型使用了基于`unsigned char`的`enum class`实现，并且定义了相关的位运算，以及相关的非成员函数`to_integer`：

```
// using namespace std;
byte by{ 0b10100101 };
cout << to_integer<int>(by) << endl;    // 165
cout << to_integer<int>(~by) << endl;  // 90
cout << to_integer<int>(by | byte{ 0b01011010 }) << endl;   // 255
```

## 新的数学库函数

在头文件`<cmath>`中加入了一大票特殊数学函数，这些函数应该是和科学计算相关的，并不是比较常见的初等计算。这些函数有：关联拉盖尔多项式，关联勒让德多项式，beta函数，第一类完全椭圆积分，第二类完全椭圆积分，第三类完全椭圆积分，常规修正柱贝塞尔函数，第一类柱贝塞尔函数，非常规修正柱贝塞尔函数，柱诺依曼函数，第一类不完全椭圆积分，第二类不完全椭圆积分，第三类不完全椭圆积分，指数积分，埃尔米特多项式，勒让德多项式，拉盖尔多项式，黎曼 zeta 函数，第一类球贝塞尔函数，球关联勒让德函数，球诺依曼函数。

## `register`关键字被废弃

`register`关键字不再具有任何意义，但是仍然作为保留字，这应该是为了兼容性考虑。

## 删除三元符

因为历史原因而使用的特性——三元符`trigraph`寿终正寝，在新的标准中彻底被扫地出门。不过在此之前，大量的编译器实质上也都默认禁止这一特性，需要手动开启。所以，影响应该不算大。在此之前：
|三元符|代表的符号|
|----|----|
|`??=`|`#`|
|`??(`|`[`|
|`??)`|`]`|
|`??<`|`{`|
|`??>`|`}`|
|`??/`|`/`|
|`??!`|`|`|
|`??'`|`^`|
|`??-`|`~`|

## 删除`bool`类型的自增运算

相比`bool`类型一直被禁止的自减运算，它的自增运算一直被允许是一件很令人迷惑的事情，显然`bool`类型不应当具有这种性质。于是在新标准中，`bool`类型的自增运算不再被允许了：

```
bool a = true;
a++;    // 错误：不允许递增布尔值
++a;    // 当然这种自增也被禁止
```

## constexpr lambda

自从引入了`constexpr`关键字之后，近来的C++标准都在想办法让这个关键字更“好用”，于是，在新标准中，lambda表达式现在可以是一个常量表达式。以下的代码将被允许：

```
auto sum = [](int a, int b) constexpr {
    return a + b;
};

int ar[sum(1, 3)];
```

## noexcept成为类型系统的一部分

这个特性意味着，一个函数后的`noexcept(true)`和`noexcept(false)`将使该函数成为两种完全不相同的类型，虽然他们的函数类型不相同，但不允许这样重载函数。以下是一组实例：

```cpp
int f() noexcept(true)  { return 0; }
int f() noexcept(false) { return 1; }
```

在这个例子中，返回值为0的f函数和返回值为1的f函数是两个类型不相同的函数，但这两个函数不允许同时存在，新标准仍然不允许函数这样进行重载。

## template auto

这个特性是指，模板中的非类型参数（即在之前的标准不需要使用`typename`关键字声明的参数），可以使用`auto`关键字进行自动推导。即，以下的代码是合法的：

```cpp
template<auto x>
void printX() {
    std::cout << x << std::endl;
}
```

