# 正则表达式的简单梳理 - bigfacesafdasgfewgf - CSDN博客





2015年05月21日 10:16:29[bigface1234fdfg](https://me.csdn.net/puqutogether)阅读数：1058标签：[正则表达式																[Shell																[字符串匹配																[POSIX](https://so.csdn.net/so/search/s.do?q=POSIX&t=blog)
个人分类：[Shell																[Linux](https://blog.csdn.net/puqutogether/article/category/3147399)](https://blog.csdn.net/puqutogether/article/category/3236387)








    这篇博文我们按照每一种正则表达式符号来整理。

**1）行首定位符“^”：匹配行首的字符**



```
#-----------------------------/chapter8/ex8-2.sh------------------
#! /bin/bash

#列出/etc目录中的以字母po开头的文件
str=`ls /etc | grep "^po"`
echo "$str"
```

注意：str变量的赋值，即等号右边需要有反引号；其中用到了管道命令，grep命令处理对象是前面ls的结果，不然grep后面要接被处理文件名；正则表达式要用双引号""括起来，在awk、sed中是用两条反斜杠\...\括起来。


**2）行尾定位符"$"：匹配行尾的字符**



```
#-----------------------------/chapter8/ex8-3.sh------------------
#! /bin/bash

#列出/etc目录中以conf结尾的文件名
str=`ls /etc | grep "conf$"`

echo "$str"
```

**3）匹配整行："^一整行内容$"**



**4）单个字符匹配"."：可以代表任意字符，包括空格，不包括换行符\n**



```
#-----------------------------/chapter8/ex8-4.sh------------------
#! /bin/bash

#列出所有的包含字符串“samba”的文件名
str=`ls /etc | grep "samba"`

echo "$str"

echo "==============================="

#列出包含字符串samba以及另外一个字符的文件名
str=`ls /etc | grep "samba."`

echo "$str"
```

注意：有了"."就表示一定有个字符在这儿，也可以用多个"."表示多个字符存在，例如"l..p"。



**5）限定符"*"：重复其前面的字符0次或者多次**



```
#-----------------------------/chapter8/ex8-5.sh------------------
#! /bin/bash

#筛选出以字符s开头，紧跟着1个字符s，任意个字符s的文件名
str=`ls /etc | grep "^sss*"`

echo "$str"
```

注意：可以表达重复0次；正则表达式的*和linux shell中的*不一样，那个是表示匹配任意字符（串），不一定要是重复前面的字符，可以说范围更广。



**6）字符集匹配“[]”：匹配中括号中的任意一个字符即可**



```
#-----------------------------/chapter8/ex8-6.sh------------------
#! /bin/bash

#筛选所有以字符r开头，并且紧跟着1个字符c的文本行
str=`ls /etc |grep "^rc"`

echo "$str"<pre name="code" class="plain">#-----------------------------/chapter8/ex8-7.sh------------------
#! /bin/bash

#筛选以字符串“ss”开头，后面至少紧跟着1个字符“s”的文本行
str=`ls /etc | egrep "^sss+"`

echo "$str"
```


注意：[a-z]匹配小写字母，[A-Z]匹配大写字母，[a-zA-Z]匹配字母，[0-9]匹配数字。


          当元字符“*”和 “.”在"[]"内时，只能表示一个普通的字符，没有上面的特殊含义了。




**7）字符集不匹配“[^]”：功能和上面正好相反**



**8）限定符“+”：功能类似于"*"，但是重复前面字符的次数必须大于等于1次，不能是0次**



```
#-----------------------------/chapter8/ex8-7.sh------------------
#! /bin/bash

#筛选以字符串“ss”开头，后面至少紧跟着1个字符“s”的文本行
str=`ls /etc | egrep "^sss+"`

echo "$str"
```

**9）限定符“?”：功能类似于“*”，但是重复其那面字符的次数必须只能是0次或1次**


```
#-----------------------------/chapter8/ex8-8.sh------------------
#! /bin/bash

#筛选以字符串“ss”开头，后面跟着0或者1个s的文本行
str=`ls /etc | egrep "^sss?"`

echo "$str"
```



**10）竖线"|"和圆括号"()"：多个正则表示之间的或的关系**



```
#-----------------------------/chapter8/ex8-9.sh------------------
#! /bin/bash

#筛选含有字符串“ssh”、“ssl”或者以字符串“yum”开头的文本行
str=`ls /etc | egrep "(ssh|ssl|^yum)"`

echo "$str"
```

**11）"{m, n}"、"{m}"、"{m,}"：指定重复出现的次数**
**前面的限定符"*", "+", "?"都可以重复前面的字符不同的次数，但是重复出现的次数都不可控。我们使用"{m, n}"、"{m}"、"{m,}"就可以控制重复出现的次数。**

**"{m, n}"：前置字符最少出现m次，最多出现n次；**

**"{m}"：前置字符出现m次；**

**"{m,}"：前置字符最少出现m次。**

**如果重复的字符不是唯一的呢？这时可以和中括号字符集匹配"[]"结合使用，如下：**



```
#-----------------------------/chapter8/ex8-16.sh------------------
#! /bin/bash

#筛选符合格式的电话号码
str=`egrep "800-[[:digit:]]{3}-[[:digit:]]{4}$" demo4.txt`

echo "$str"
```

**注意：在普通正则表达式中没有对{}的定义，需要加转义字符：\{m, n\}。**

**12）POSIX字符集可以方便表示"[]"的字符集**
![](https://img-blog.csdn.net/20150521111643360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHVxdXRvZ2V0aGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


**注意：使用POSIX字符集时需要两层中括号。**](https://so.csdn.net/so/search/s.do?q=字符串匹配&t=blog)](https://so.csdn.net/so/search/s.do?q=Shell&t=blog)](https://so.csdn.net/so/search/s.do?q=正则表达式&t=blog)




