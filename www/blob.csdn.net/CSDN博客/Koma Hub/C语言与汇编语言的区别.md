# C语言与汇编语言的区别 - Koma Hub - CSDN博客
2019年03月14日 22:06:46[Koma_Wong](https://me.csdn.net/Rong_Toa)阅读数：41
个人分类：[C/C++																[汇编](https://blog.csdn.net/Rong_Toa/article/category/8750815)](https://blog.csdn.net/Rong_Toa/article/category/7156199)
> 
源地址：[C语言与汇编语言的区别](http://mp.weixin.qq.com/s?__biz=MjM5MzUxMTAwMg==&mid=2649733198&idx=5&sn=829e5c9cdf13adccf818f7faf3a11d1e&chksm=be8efb7b89f9726dbc6541557a63f1055f4a674efbf10cfc9176daeec102b0286188243d54d5&mpshare=1&scene=1&srcid=0312XZGj5kk8p3JNh4tJnf19#rd)
EDN电子技术设计 **EDN电子技术设计**
微信号 edn-china
功能介绍 EDN China电子技术设计为电子设计工程师和设计经理人提供前沿深度的电子资讯、设计实例应用方案。
从事嵌入式系统开发多年，对于软件方面，从初期的单片机汇编语言编程，到后来的C++界面程序编写，已有相当多的经验累积。正是有了多年的实战经验，对于汇编与高级语言在原理及应用等方面形成了自已的一些理解，也是我经常思考的问题，但一直没有以书面的方式记录下来，今天之所以写下这些文字，正是想做一个归纳，日后也好参考。
其实，**C语言与汇编语言的区别**一直是程序员们津津乐道的话题。如果你问一个程序员这样的问题，他也许会这么回答你：“C语言可读性好，代码便于维护，便于开发;汇编语言编写的程序不容易看懂，可维护性不好，但是执行效率高。”这样回答是没有错的，但只是一个概括，不够深入。比方说，**汇编语言为什么执行效率比C语言高呢?C语言的可读性又好在哪里呢?汇编语言不同样可以用注解来提高可读性吗?**等等这些的问题。要真正能回答这些问题，不是一件简单的事情，也不是三言两语能解释得清的，需要比较彻底地分析汇编与C的本质上的区别。
**先说汇编**，写过汇编的程序员都知道，“**汇编语言实质上机器语言的助记符。**”这句话需要这样来解析：
- 
1.CPU只能运行它所支持的指令集，而这些指令集当中的每天条指令都是一些二进制数的序列，也就是“0”和“1”的有序组合;
- 
2.“0”和“1”的组合不便于程序员的记忆因此有了“MOV A 0x40”等这样的助记符，也就是说在程序员编写程序的时候，用“MOV A 0x40”来代替一串“0”和“1”的序列，这样一看就知道是吧“0x40”单元中的数据搬到累加器A当中来。而如果是用0”和“1”的序列，毫无特征，很难被程序员记住。这也是为什么要有汇编语言产生的原因了。
以上对汇编语言的解释基本上就道出了*汇编语言的本质*，知道了汇编语言的本质，我们不难理解，汇编语言编译成CPU可执行的机器语言其实只要做一个翻译的动作就好了，因为，**助记符与对应的二进制指令是一一对应的**。进而，我们再来解释为什么汇编语言会比C语言有更高的执行效率。
首先，我们要理解一点，类似于C的高级语言面对的对象是程序员，而不是CPU，为什么这样说呢?原因非常简单，CPU不认识C语言，CPU只认识以“0”“1”形式存在的指令。而C语言的所有语法以及它代码组织形式都是有助于程序员编写代码的。所以，C语言编写完程序后，需要通过编译器将C语言编译成与相应CPU指令集对应的机器语言。
问题来了，前面我们说过，汇编语言与机器语言是一一对应的。但是C语言呢?当然没这么好事了。C语言的语法是固定的，**C语言编写的程序要编译成CPU能读懂的机器语言指令没办法一一对应**，所以就需要有编译规则了。比方说一个for循环会有若干条实现对应for循环功能的机器指令对应，而一个switch，也相应会有机器指令段代替。所以C语言最终要编译机器代码，必须要遵从许许多多的这样的规则才行。
我试验过，用C编写一个简单的程序，比方说只包含一个for循环，编译出的代码和用汇编写的最优代码几乎是一样。但代码量一大，由于受制于规则(不受制也不行呀，否则编不出来)，***编出来的代码与用汇编语言写出来的代码相比就走了不少“弯路”了***。虽然说，现在的很多C编译器在编译的时候都会有优化，但是，不可能做得到效率上等同于与机器语言一一对应的汇编语言的效率。毕竟，汇编语言可以理解为直接就是面对CPU的，只不过是机器语言用助记符代替而矣。
以上只是两种语言效率上区别的一个主要原因，其实，**对于资源的利用上，汇编语言同样有优势**。汇编是直接面对CPU的语言，只要是在指令集支持的范围内，汇编语言可以直接而灵活地管理包括特殊功能寄存器、通用寄存器、存储单元的每一个字节，甚至是每一个bit。C语言对内存的使用及管理功能也是很强大的，但毕竟还是受制于语法。
举个最简单的例子，C语言当中没有对应三字节或是五字节的变量类型，要么int型，要么long型，所以每次申请必须是固定的字节数，势必造成内存使用上的浪费。而大部份汇编语言根本没有这样的语法，在伪指令的帮助下(其实也只是提高可读性)，汇编语言程序可以使用任意字节数的变量，当然处理起来比C语言麻烦得多，最终还是一个字节一个字节地拼接处理，而用C语言写程序就轻松了，不用管这些，最终编译器会搞定嘛。而轻松的代价就是造成了浪费。而内存使用效率不高同时也会影响到整个程序的整体效率。
汇编的最后部份，来说明一下**伪指令**这个东西吧。一个不善于用伪指令写汇编程序的程序员不是一个好的程序员，这就和写**C语言不用宏**是一个道理。伪指令存在价值在于他提高了汇编语言的可读性，同时也能简化汇编语言的编程。比方说最通用的创建立即数名称，而不是用二进制或十六进制数;创建数据表;ARM当中的创建全局及局部变量等。这个不多说了，针对于不同的MCU或CPU有不同的伪指令。
再来说说C吧，C语言丰富而实用的语句决定了C语言程序灵活性以及强大的代码组织能力。利用C语言，我们可以很方便地编写出庞大的工程，在版本管理工具的帮助下，可以很轻松地实现多人协作编程。特别是引入RT-OS以后，C语言的程序框架更加灵活了，添加功能(任务)更加轻松。因为，所有的任务的调控可以直接交给操作系统来做，而程序员需要做的是编写任务(含一个或多个功能模块)的内容，以及设置任务的优先级，堆栈数等等。而**任务间的通信可以摆脱“全局变量”这个祸害，完全可以通过信号量、邮箱（这个邮箱是什么鬼）、队列等形式来沟通**。为什么说“全局变量”是祸害呢?单程序量不大的时候，“全局变量”可能是好东西，因为方便嘛，哪都能改它，哪都能读它。
可是，一旦程序大了，源码文件一多，如果都习惯用全局变量来传递及存贮共用量的话，灾难就会降临。你会看到数以千计的全局变量在各各函数间纵横交错，如果这些变量不是你创建的，你会很难知道它的作用，因为系统太大了，它出现的地方太多了，而且，像这样的变量实在太多，你会因此而感到恐惧，相信很多有经验的程序员都经历过吧!然而，这将埋下系统崩溃级别的隐患。
因为，这些全局变量太多，而且出现在太多的地方，很难完全统计出哪些地方可能会修改它们，一量有遗漏，变量的值可能就会和我们想要的值有出入，后果非常严重。更有甚者，当全局变量是指向数组的指针或者是数组本身的时候。有的程序员可能对多得数不清的这些变量感到困惑，容易犯的一个错误是写这些全局数组时没有加以保护，经常都会写出数组的范围，而将其它无关的变量给莫名其妙地改了。导致的后果可能是出错，也有可能是死机，而且，由于这种问题极其隐蔽，很难找出来。
所以，在大的系统当中，幸亏有了OS这种东西的存在，它不但能帮我们摆脱全局变量这个祸害，而帮助程序员更加方便地组织各个功能模块。并且，让每个任务单一化，进而降低了程序编写的难度。而用汇编语言编写较大的工程，是困难重重的事情。
首先，必须面对上面提到的全局变量的问题，另外还得面对其它的困难，比方说内存的使用。在C语言里，程序员只要申请各种类型的变量然后就可以使用了，而具体用的是哪个单元的空间，交给编译器去管理就好了。而你**用汇编语言写程序的时候，必须要指明所用内存的地址**，问题来了，程序员不得不对所有内存的使用了如指掌，因为所有内存单元的使用都必须体现出来，这也是汇编语言的特点。当程序量一旦大到某种呈度的时候，规划这些内存的使用本身就是一个高难度的工作，因为同时你还得保证各个地方在使用它们的时候没有冲突。真的很难，我是有体会的。这时候，我们再想象一下，如果程序太大，我们要几个人来协作编写的话，问题就更加复杂了，因为，**没有了编译器的帮忙，程序员之间要协商好内存使用的规则，这太难了**，因为面对它们的只不过是一些数量庞大的地址空间，光是划分区域倒是简单，但涉及到程序间的交互很大的麻烦就来了，每个程序员必须提供各自的变量接口，因为汇编的可读性本来就差，这些接口包括了每一个可能共用的变量(在汇编中只是内存空间资源)，以及说明它们的功能，这个工作量非常大，而且一旦做得不好，很容易出错，出了错还很难查。
用汇编编写程序还有很多比C困难的地方，再举一个简单的例子。汇编语言是低级语言，是机器语言面向程序员的一个一对一的翻译，所以对于程序员来说，它的功能不够丰富。在C语言里写一个(13200.68/98.56)*256.24的程序，可以直接就表示成"double a; a=(13200.68/98.56)*256.24;"，而在汇编里就没这么轻松了，汇编里面一般都没有直接支持浮点运算的指令，通常情况下都是得专门编写一个函数来做浮点运算。结果就是汇编程序编写比C麻烦很多，而且还不直观。另外，用汇编语言编写程序对程序员的要求也更高，因为，**程序员必须能撑握CPU或MCU的内存结构、总线结构、功能模块、堆栈系统、中断资源及机制等等**，否则，是写不下去的。
最后总结，C语言与汇编根本不是一码事，怎么可能几句话就能道出它们的区别呢?就目前的情形来说，由于IC工艺的成熟，MCU的存贮资源越来越便宜，工作频率也越来越高，所以在资源利用率以及执行效率上没有像以前要求那么高了。而且，实现的功能越来越强大，这些因素都助长了C以及C++在嵌入式开发当中地位越来越高。就连MCS-51的程序编写也以C语言主导了，这还要归功于KEIL这个强大且十分容易入手的工具。面向程序员的高级语言比面向CPU的汇编语言好用得，在硬件条件允许的情况下，程序员当然选择用高级语言编程，不旦提高了编程效率，也提高了代码的可维护性，并且十分有利于编写大型的工程。
