# 51单片机8X8点阵滚动显示温度--C51源代码 - Koma Hub - CSDN博客
2018年06月06日 20:48:57[Koma_Wong](https://me.csdn.net/Rong_Toa)阅读数：875
```cpp
//LED8*8滚动显示
//列扫描，低电平有效
/*--------------------------------------------------------------*/
//包含头文件
#include <reg52.h>
#include "74HC595.H"
#include<intrins.h>  //包含_nop_()函数定义的头文件
/*--------------------------------------------------------------*/
//全局变量定义
unsigned char  i,flag,t,w,t;
unsigned int  m,n;
unsigned char  t1,t2,t3,t4;
/*--------------------------------------------------------------*/
//代码库
#define  num  sizeof(buff)	//代码长度
unsigned char code aa[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
unsigned char code table2[]={
    0x60,0x60,0x00,0x3E,0x7F,0x41,0x7F,0x3E,/*"0",0*/
    0x60,0x60,0x00,0x42,0x7F,0x7F,0x40,0x00,/*"1",1*/
    0x60,0x60,0x00,0x62,0x73,0x59,0x4F,0x46,/*"2",2*/
    0x60,0x60,0x00,0x22,0x6B,0x49,0x7F,0x36,/*"3",3*/
    0x60,0x60,0x00,0x38,0x3E,0x7F,0x7F,0x20,/*"4",4*/
    0x60,0x60,0x00,0x4F,0x4F,0x49,0x79,0x31,/*"5",5*/
    0x60,0x60,0x00,0x3E,0x7F,0x49,0x7B,0x32,/*"6",6*/
    0x60,0x60,0x00,0x03,0x73,0x79,0x0F,0x07,/*"7",7*/
    0x60,0x60,0x00,0x36,0x7F,0x49,0x7F,0x36,/*"8",8*/
    0x60,0x60,0x00,0x26,0x6F,0x49,0x7F,0x3E,/*"9",9*/
};
unsigned char code table1[]= {
//取模方式 阴码 列扫描 逆向
    0x00,0x3E,0x7F,0x41,0x7F,0x3E,0x00,0x00,/*"0",0*/
    0x00,0x42,0x7F,0x7F,0x40,0x00,0x00,0x00,/*"1",1*/
    0x00,0x62,0x73,0x59,0x4F,0x46,0x00,0x00,/*"2",2*/
    0x00,0x22,0x6B,0x49,0x7F,0x36,0x00,0x00,/*"3",3*/
    0x00,0x38,0x3E,0x7F,0x7F,0x20,0x00,0x00,/*"4",4*/
    0x00,0x4F,0x4F,0x49,0x79,0x31,0x00,0x00,/*"5",5*/
    0x00,0x3E,0x7F,0x49,0x7B,0x32,0x00,0x00,/*"6",6*/
    0x00,0x03,0x73,0x79,0x0F,0x07,0x00,0x00,/*"7",7*/
    0x00,0x36,0x7F,0x49,0x7F,0x36,0x00,0x00,/*"8",8*/
    0x00,0x26,0x6F,0x49,0x7F,0x3E,0x00,0x00,/*"9",9*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
};
unsigned char buff[]={
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
    0x00,0x03,0x03,0x3E,0x7F,0x41,0x63,0x22,/*"C",0*/
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",10*/
};
/************************************************************************
以下是DS18B20的操作程序
************************************************************************/
sbit DQ=P3^3;
unsigned char time;   //设置全局变量，专门用于严格延时
/*****************************************************
函数功能：将DS18B20传感器初始化，读取应答信号
出口参数：flag
***************************************************/
bit Init_DS18B20(void)
{
    bit flag;         //储存DS18B20是否存在的标志，flag=0，表示存在；flag=1，表示不存在
    DQ = 1;           //先将数据线拉高
    for(time=0;time<2;time++) //略微延时约6微秒
        ;
    DQ = 0;           //再将数据线从高拉低，要求保持480~960us
    for(time=0;time<200;time++)  //略微延时约600微秒
        ;         //以向DS18B20发出一持续480~960us的低电平复位脉冲
    DQ = 1;           //释放数据线（将数据线拉高）
    for(time=0;time<10;time++)
        ;  //延时约30us（释放总线后需等待15~60us让DS18B20输出存在脉冲）
    flag=DQ;          //让单片机检测是否输出了存在脉冲（DQ=0表示存在）
    for(time=0;time<200;time++)  //延时足够长时间，等待存在脉冲输出完毕
        ;
    return (flag);    //返回检测成功标志
}
/*****************************************************
函数功能：从DS18B20读取一个字节数据
出口参数：dat
***************************************************/
unsigned char ReadOneChar(void)
{
    unsigned char i=0;
    unsigned char dat;  //储存读出的一个字节数据
    for (i=0;i<8;i++)
    {
        DQ =1;       // 先将数据线拉高
        _nop_();	    //等待一个机器周期
        DQ = 0;      //单片机从DS18B20读书据时,将数据线从高拉低即启动读时序
        dat>>=1;
        _nop_();     //等待一个机器周期
        DQ = 1;     //将数据线"人为"拉高,为单片机检测DS18B20的输出电平作准备
        for(time=0;time<2;time++)
        ;      //延时约6us，使主机在15us内采样
        if(DQ==1)
            dat|=0x80;  //如果读到的数据是1，则将1存入dat
        else
            dat|=0x00;//如果读到的数据是0，则将0存入dat
        //将单片机检测到的电平信号DQ存入r[i]
        for(time=0;time<8;time++)
        ;              //延时3us,两个读时序之间必须有大于1us的恢复期
    }
    return(dat);    //返回读出的十进制数据
}
/*****************************************************
函数功能：向DS18B20写入一个字节数据
入口参数：dat
***************************************************/
WriteOneChar(unsigned char dat)
{
    unsigned char i=0;
    for (i=0; i<8; i++)
    {
        DQ =1;         // 先将数据线拉高
        _nop_();	     //等待一个机器周期
        DQ=0;          //将数据线从高拉低时即启动写时序
        DQ=dat&0x01;   //利用与运算取出要写的某位二进制数据,
        //并将其送到数据线上等待DS18B20采样
        for(time=0;time<10;time++)
        ;//延时约30us，DS18B20在拉低后的约15~60us期间从数据线上采样
        DQ=1;          //释放数据线
        for(time=0;time<1;time++)
        ;//延时3us,两个写时序间至少需要1us的恢复期
        dat>>=1;       //将dat中的各二进制位数据右移1位
    }
    for(time=0;time<4;time++)
    ; //稍作延时,给硬件一点反应时间
}
void ReadyReadTemp(void)
{
    Init_DS18B20();     //将DS18B20初始化
    WriteOneChar(0xCC); // 跳过读序号列号的操作
    WriteOneChar(0x44); // 启动温度转换
    for(time=0;time<100;time++)
    ;	 //温度转换需要一点时间
    Init_DS18B20();     //将DS18B20初始化
    WriteOneChar(0xCC); //跳过读序号列号的操作
    WriteOneChar(0xBE); //读取温度寄存器,前两个分别是温度的低位和高位
}
/*--------------------------------------------------------------*/
//显示函数
void Display(void)
{
    if(flag==2){
        Ser_IN[[aa[i]]]; //列扫描数据
        Ser_IN(buff[i + n]);				//查表取出行扫描数据
        Par_OUT();							//输出显示
        i++; 
        if(i == 8) i = 0;				//循环扫描
        m++; 
        if(m == 100) {m = 0; n++;}		//滚动速度控制
        if(n == num-7)
        {
            n = 0;				//循环显示
            flag=1;
        }
    }
}
/*--------------------------------------------------------------*/
//定时器初始化
void T_init(void)
{
    TMOD = 0x11;
    TH0  = 0xfc; //1MS
    TL0  = 0x66;
    EA = 1;					//允许CPU中断
    ET0 = 1; 				//定时器0中断打开
    TR0  = 1;
}
/*--------------------------------------------------------------*/
//定时器中断服务
void T0_intservice(void) interrupt 1 using 0
{
    TH0 = 0xfc;
    TL0 = 0x66;
    Display();
}
/*--------------------------------------------------------------*/
//主函数
void main (void)
{
    unsigned char TL;     //储存暂存器的温度低位
    unsigned char TH;    //储存暂存器的温度高位
    unsigned char TN;      //储存温度的整数部分
    unsigned char TD;       //储存温度的小数部分
    flag=1;
    T_init();
    while(1){
        if(flag==1){
            ReadyReadTemp();     //读温度准备
            TL=ReadOneChar();    //先读的是温度值低位
            TH=ReadOneChar();    //接着读的是温度值高位
            TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
            //这样得出的是温度的整数部分,小数部分被丢弃了
            TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，
            t1=TN/100;              //取百位
            t2=(TN%100)/10;    //取十位
            t3=TN%10;             //取个位
            t4=TD;
            flag=0;
        }
        if(flag==0){
            for(w=1;w<6;w++){
                if(w==5){
                    flag=2;
                }
                for(t=0;t<8;t++){
                    switch(w){
                        case 1:
                            buff[t+(8*w)]=table1[(8*t1)+t];
                            break;
                        case 2:
                            buff[t+(8*w)]=table1[(8*t2)+t];
                            break;
                        case 3:
                            buff[t+(8*w)]=table1[(8*t3)+t];
                            break;
                        case 4:
                            buff[t+(8*w)]=table2[(8*t4)+t];
                            break;
                    }
                }
            }
        }
    };
}
//Note: 74HC595驱动
//      '''                   '''
//Note: MR 主复位接电源正极, OE 使能端,输出有效接电源负极
/*--------------------------------------------*/
#ifndef '''74HC595_H'''
#define '''74HC595_H'''
/*--------------------------------------------*/
sbit SD	   = P1^4;	//串行数据输入
sbit ST_CK = P1^5;	//存储寄存器时钟输入
sbit SH_CK = P1^6;	//移位寄存器时钟输入
/*--------------------------------------------*/
//数码管断码和位码的定义
//unsigned char code seg[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,0x00,0xff};
//0   1    2    3    4    5    6    7    8    9    a    b    c     d    e     f    8   无
//unsigned char code pos[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
//1    2    3   4    5    6     7   8
/*--------------------------------------------*/
//函数声明
void Ser_IN(unsigned char Data);	//串行数据输入
void Par_OUT(void);					//串行数据输出
//void Ser_Par(unsigned char Data);	//串行输入,并行输出
/*--------------------------------------------*/
//串行数据输入
void Ser_IN(unsigned char Data)
{
    unsigned char i;
    for(i = 0; i < 8; i++)
    {
        SH_CK = 0;			//CLOCK_MAX=100MHz
        SD = Data & 0x80;
        Data <<= 1;
        SH_CK = 1;
    }
}
/*--------------------------------------------*/
//并行数据输出
void Par_OUT(void)
{
    ST_CK = 0;
    ST_CK = 1;
}
/*--------------------------------------------*/
//串行输入,并行输出
/*void Ser_Par(unsigned char Data)
{
Ser_IN(Data);
Par_OUT();
}
*/
/*--------------------------------------------*/
#endif
```
转载地址：[http://www.jdgcs.org/wiki/Downloads](http://www.jdgcs.org/wiki/Downloads)
在此仅做备份，如有侵权，请联系删除！
