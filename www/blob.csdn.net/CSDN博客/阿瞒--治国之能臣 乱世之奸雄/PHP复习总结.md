# PHP复习总结 - 阿瞒--治国之能臣 乱世之奸雄 - CSDN博客
2012年11月04日 14:24:35[baofenny](https://me.csdn.net/jiaminbao)阅读数：1189
php数据类型：
 1.基本数据类型：
  整型(int)
  浮点型(float)从左边不是零的数起，往后推14位数。
  布尔型(boolean)
  字符型(string)
 2.复合数据类型：
  数组(array)
  对象(object)
 3.特殊数据类型：
  null
  undefind
php中内存空间：
 1TB=1024GB | 1G=1024M | 1M=1024K | 1K=1024B | 1Byte=8bit
php中逻辑运算符：
 or、and优先级比=还低。$a=true and false; 结果为：ture;
       .把两边数据不管什么类型的，都转换成字符串来链接起来。
 ++  --都是对一个变量来操作的。$a=++3;这是错误的。
 break是直接跳出一个循环体，continue不跳出循环体，而是跳过这次循环，并没有退出这个循环。直接执行下次新的 循环。
 break2是跳出两层，continue2也是跳出两层循环。
 $a = 218;  
 function demo(&$b){ 这是一个引用地址的问题；只是把内存中$a占有的空间地址引用了过 去;
 $b = 314;
 }
 demo ($a);
 echo $a;
 for($i=0;$i<=10;$i++){
 .........
 }
 $i=0;
 while($i<=10){
 .......
 $i++;
 }
 $i=0;
 do{
 ........
 $i++;
 }
 while($i<=10)
位运算：
 二进制：逢二进一；原码、反码、补码；
  用二进制表示一个数就是一个原码；
 因为一个数在内存中占有四个字节，而一个字节又有八位来表示，所以一个数有32位来表示；
 1.二进制最高位是符号位，“0”代表正数，“1”代表负数；
 2.正数的原码、反码、补码都是一样的；
 3.负数的反码=它的原码符号位不变，其它位取反；
 4.负数的补码=它的反码+1；
 5.0的反码，补码都是0；
 6.php没有无符号数，换言之，php中的数都是有符号的；
 7.在计算机运算的时候，都是以补码的方式来运算的；
四个位运算：（首先要找到补码，它一定是以补码的方式来运算的。）
 & ｜ ^ ~(位运算)  &两位全为1，结果为1；｜一个为1；^两位一个为1，一个为0，结果为1；~  取反以后就是这个数的补码，首先要找到补码；
 <<  >>  (移位运算) :  >>低位溢出，符号位不变，并用符号位补溢出的高位；<<符号位不变  ，低位补0；
数组：
 ture false null 也可以做为键值；1、0、"";
 print_r();var_dump();来打印数组；count()、is_array()、explode、implode、
 arr["bar"]="100";数组中要加引号；这是数组的引用陷井；
排序：
 排序分两大类：
 1.内部排序：交换排序分为（冒泡｜快速）
  冒泡排序
  选择排序  
  插入排序
  快速排序
 2.外部排序：
  因为数据太大，要通过外部文件来处理；
 冒泡排序：(再次循环，一次外部循环一次内部循环)
 $arr=[0,5,-1,10,-12,-100,253];
 $temp=0;
 for($i=0;$i<count($arr)-1;$i++){
  for($j=0;$j<count($arr)-1-$i;$j++){
   if($arr[$j]>$arr[$j+1]){
   $temp=$arr[$j];
   $arr[$j]=$arr[$j+1];
   $arr[$j+1]=$temp;
   }
  }
 }
function allarr(&$arr){
 $temp=0;
 $flag=false;(标志位,用于优化)
 for($i=0;$i<count($arr)-1;$i++){
  for($j=0;$j<count($arr)-1-$i;$j++){
   if($arr[$j]>$arr[$j+1]){
   $temp=$arr[$j];
   $arr[$j]=$arr[$j+1];
   $arr[$j+1]=$temp;
   $flag=true;
   }
  }
 }
  if(!flag){
  break;
  }
  $flag=false;
 }
 $myarr=[0,5,-1];
 allarr($myarr);
 print_r($myarr);
引用地址的复习：（这里函数和数组分别开辟了不同的栈和堆）
 function allarr(&$arr){
 $temp=0;
 for($i=0;$i<count($arr)-1;$i++){
  for($j=0;$j<count($arr)-1-$i;$j++){
   if($arr[$j]>$arr[$j+1]){
   $temp=$arr[$j];
   $arr[$j]=$arr[$j+1];
   $arr[$j+1]=$temp;
   }
  }
 }
 }
 $myarr=[0,5,-1];
 allarr($myarr);
 print_r($myarr);
选择排序：
![](https://img-my.csdn.net/uploads/201211/04/1352010495_4760.jpg)
插入排序：假设一个最小值；
![](https://img-my.csdn.net/uploads/201211/04/1352014024_1432.jpg)
![](https://img-my.csdn.net/uploads/201211/04/1352014065_7568.jpg)
查找：
 顺序查找
![](https://img-my.csdn.net/uploads/201211/04/1352025217_6825.jpg)
 二分查找：前提这个数组已经是一个有序数组；
  首先找到数组中间这个数，然后与要查找 的数比较，如果，要查找 的数大于中间这个 
 数，则说明应当向后找，否则，向前找。如果相等则说明找到。
![](https://img-my.csdn.net/uploads/201211/04/1352025246_7857.jpg)
函数在接收一个对象时,传递的是一个地址.
而在接收一个数组时，是把数组传递了过去，也就是说拷贝了过去。如果想传递地址过去，就只有用&来引用。
$p1 = 50;
$p2 = false;
function text(&$p,&$i) {
 $p = 100;
 $i = true;
}
text($p1,$p2);
一般来讲，基本数据类型在函数中传递的是一个具体的值，这样引用是把变量的地址赋给了新的变量，
来改变变量原来的值。
header()和session_start(),setCookie();前面不能有任何输出.
面向对象总结：
构造函数：
 在创建对象的时候，就指定这个对象的年龄和名字。
  1.没有返回值；
  2.在创建一个类的新对象时，系统会自动的调用该类的构造方法完成对新对象的初始化。
 __construct();||类名；优先__construct();
 $this只能在类的内部使用，不能在类的外部使用。
析构函数：
    不接收参数，没有返回值；
 主要用于销毁资源；
 先调用的后销毁；（先入后出）
 当结束进程的时候，垃圾回收机制开启。(所谓垃圾对象，就是指，没有任何变量再引用它。)
全局变量和静态变量是在内存中的全局区；（static $变量名；）
全局变量在定义的时候不能赋值；也就是定义和赋值分开来声明；
静态变量： 在外部访问用：类名：：类变量名；内部访问用：类名：：类变量名｜｜self::类变量名;
静态方法：在类外部访问：类名：：类方法名 ｜｜对象名->类方法名;
在我们编程中，一般用静态方法来操作静态变量，静态方法不能操作非静态变量；
 静态方法是属于一个类的，而非静态变量是属于单个对象的；普通方法可以操作静态和非静态变量；
什么时候使用静态方法？
 当所有对象要共同使用一个变量时；比如统计所有学员的总学费问题；
访问控制修饰符：
 public protected private
成员属性一定要指定一个访问修饰符，成员方法不指定则默认为public;
面向对象编程三大特性:
  封装性：这个和访问修饰符密切相关；修饰符可以说是封装性的三个特性；
   封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的
   其它部分只有通过被授权的操作（方法），才能对数据进行操作。
 __set(); || __get();来操作我们的变量；
 class demo{
 public $name;
 function __set($name,$val) {
  $this->$name=$val;
 }
 }
 $p1 = new demo;
 $p1->name = "val"; //这是__set();和__get();这两个魔术方法的使用方式；
  继承性：就是把父类里的一些属性，方法来继承过来；
   继承可以解决代码复用，在几个类中同时存在几个相同属性和方法时；
  calss 子类 extends 父类{
  }
 当继承父类的子类，默认不会继承父类的构造方法；
 在子类中希望调用父类的成员方法，需要在子类中用  类名：：方法名｜｜parent::方法名；
 如果子类中的方法名和父类里的方法名一样的话，这就可以说是父类的重写或是父类的覆盖；
函数重载
 php中用一个魔术方法来实现，__call(); __call();这是一个对象调用某个方法，而该方法不存在，则系统会自动调用；
![](https://img-my.csdn.net/uploads/201211/07/1352223752_3559.jpg)
方法的重写｜覆盖：
  1.子类的方法的参数个数，方法名称要和父类方法的参数个数，方法名称一样。
  2.子类方法不能缩小父类方法的访问权限；（访问修饰符）
多态：
 调用不变，结果变化；比如调用动物叫声，引用不同的动物，就有不同的叫声；
抽象类：
 这个类只是因为让其它类来使用它。它本身就不需要被实例化。主要用途是让子类来实例它。
 这样可以达到代码复用。
 abstract class 类名｛
 方法是没有方法体的。
 ｝
接口：  接口是更加抽象的抽象类，抽象类里的方法可以用有方法体，
 接口里的所有方法都是没有方法体。接口体现了程序设计的
 多态和高内聚低偶合的设计师思想政治。
 类和类之间称为继承；类和接口之间称为实现；
 interface iUsb{
 方法；没有方法体；
 }
 //实现某个接口，则必须实现该类的所有方法；
 class camera implements iUsb {
 }
 一个类可以实现多个接口，并用逗号隔开；
 接口中可以有属性，但必须是常量，默认是public;
 接口中的方法都是必须是public的，默认就是public；
 一个接口不能为、继承其它的类，但是可以继承别的接口；
如果我们希望某个类不被其它类来继承（可能因为安全考虑），可以使用final.
const前面不能有修饰符，在定义的时候必须给初值，并不能修改。访问常量方法：类名：：常量名称；self::常量名；
一个常量是属于一个类的，而不是某个对象的；
一块内存可以分为五个区域：堆区、栈区、全局区、变量区、代码区；在内存中以补码形式来处理；
错误和异常处理：
 代码要写的健壮才好；
 ide()方法处理方法；
PHP处理错误的方式：
 自定义一个错误处理函数：
 set error handler();php的默认错误处理程序是内建的错误处理程序。
get | post的区别有哪些：
 1.安全性get请求的数据会显示在地址栏上，post请求的数据，放在http消息体
 2.从可以提交数据的大小看
  2.1 http协议本身并没胡限制数据大小。
  2.2 浏览器在对get和post请求做显示，get请求数据2k+35,post并没有限制大小
 3.get请求可以更好的添加到收藏夹。
细节：302状态码也可以让其跳转到外网去。
 header(Location:"a.php");
200状态码是请求完成；
404状态码是请求一个不存在的页面；
304状态码是在缓存里取出的内容；
![](https://img-my.csdn.net/uploads/201211/09/1352395804_2617.jpg)
dmqt
curd
超全局数组 9个
 $_SERVER主要包含Http请求行和消息头的信息，同时还有服务器自己的一些信息。
 $_ENV包含了开发的环境变量信息。
 $_GLOBALS 一个包含了全部变量的全局组合数组，变量的名字就是数组的键。同时一个自定义全局变量，
    也会自动化的被$_GLOBALS管理。 
总结MVC的处理过程:
 1.首先控制器接收用户的请求，并疱定应该调用哪个模型（service也就是要引用的类吧）来进行处理。
 2.然后调用模型用来处理用户的请求并返回数据。
 3.最后控制器用相应的视图显示模型返回的数据，并通过浏览器呈现给用户。 
![](https://img-my.csdn.net/uploads/201211/10/1352483900_2775.jpg)
MVC不适用小型项目，小项目一般就用分层结构就可以了。
我们没有必要第一个请求，就对应一个控制器，可以这样，把同一逻辑的请求（对同一张表的操作），
提交给一个控制器即可。
PHP文件编程（IO编程）：
在对文件进行操作的过程中，我们是以流的概念来操作。
 如果你的数据是从程序员（内存）向文件（磁盘）流动则我们称之为输出流。
 反之，则称为输入流。
当设置用户登陆页面的时候，设置的用户名和密码不要写死，可以建一个.ini的配置文件来读取里面的信息。
用parse_ini_file()这个函数来读取。它返回的是一个数组。  
 在文件里面是以\r\n的方式来换行的，但是在网页里面是以<br/>来换行的。
 $cons = str_replace("\r\n","<br/>",$cons);
文件下载：
 // 输入文件标签
 Header("Content-type: application/octet-stream");
 Header("Accept-Ranges: bytes");
 Header("Accept-Length: ".filesize($file_dir . $file_name));
 Header("Content-Disposition: attachment; filename=" . $file_name);
mkdir这个函数也可以创建多级目录；mkdir("aa/bbb/ccc",0777,true);
rmdir这个函数删除一个空文件夹；如果里面有文件就不能删除；
fwrite("文件名"，"w+");这个函数创建一个文件；
unlink("文件路径")这个函数删除一个文件;unset();用于删除变量；
delete也可以删除一个文件。
PHP文件编程实际运用·文件上传：
 首先把编码给转换了：enctype="multipart/form=data";
 要用$_FILES这个超全局变量来获取；
 上传中文文件要用iconv()函数来改变编码；
![](https://img-my.csdn.net/uploads/201211/10/1352483930_3172.jpg)
