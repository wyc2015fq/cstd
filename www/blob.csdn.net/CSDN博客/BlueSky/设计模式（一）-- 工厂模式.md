# 设计模式（一）-- 工厂模式 - BlueSky - CSDN博客
2016年05月19日 13:03:28[ASIA_kobe](https://me.csdn.net/ASIA_kobe)阅读数：335
个人分类：[设计模式](https://blog.csdn.net/ASIA_kobe/article/category/6236253)
 在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。
 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。
**模式的问题**：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？
解决方案：[建立一个工厂来创建对象](http://blog.csdn.net/hguisu/article/details/7505909)。
## 0.引言
1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。
    2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。
    3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。
    4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。而且这空调必须对应给系列车才能使用。于是这个工厂开始生产宝马车和需要的空调。
         最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.
# **一、概念**
简单工厂提供创建对象实例的功能，而无需关心起具体实现。
简单工厂方法的内部主要实现的功能是：选择合适的实现类来创建实例对象。而不是通过构造方法来进行创建对象实例，而是通过一个产生对象实例的工厂来创建对象实例。
工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。 　　
                        一个抽象工厂类，可以派生出多个具体工厂类。 
每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 
　　                  一个抽象工厂类，可以派生出多个具体工厂类。 
每个具体工厂类可以创建多个具体产品类的实例。 
区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。
　　   工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
简单而言：
简单工厂 即 把实例化对象放到一个具体的工厂类中，通过工厂类中的getInstance(type)实例来获取，其中工厂类中包含判断的逻辑即你想实例化那种类型的产品对象；
工厂方法 即 把简单工厂的工厂类变为抽象类，具体的对象实例化则有工厂的具体类去实现，每种具体工厂类则对应一个具体的产品类，此时获取可以通过反射机制来创建具体的实例对象；
抽象工厂 即 有多个产品抽象类，有一个抽象工厂类，抽象工厂可以派生多个具体工厂，每个具体工厂可以创建多个具体的产品实例。
# **二、结构图**
![](https://img-blog.csdn.net/20160519092532753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
# **三、具体代码实现**
参见https://github.com/asiacui/DesignModel
# **四、优缺点**
优点
工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个[软件体系结构](http://baike.baidu.com/view/1317046.htm)的优化。
缺点
由于工厂类集中了所有实例的创建逻辑，违反了[高内聚](http://baike.baidu.com/view/292136.htm)责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；
这些缺点在[工厂方法模式](http://baike.baidu.com/view/1580263.htm)中得到了一定的克服。
使用场景
工厂类负责创建的对象比较少；
客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；
由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。
