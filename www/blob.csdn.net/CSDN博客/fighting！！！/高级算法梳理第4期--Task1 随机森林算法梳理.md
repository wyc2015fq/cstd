# 高级算法梳理第4期--Task1 随机森林算法梳理 - fighting！！！ - CSDN博客
2019年01月27日 12:31:05[dujiahei](https://me.csdn.net/dujiahei)阅读数：132
参考：周志华《机器学习》
[https://blog.csdn.net/m0_37548423/article/details/86656070](https://blog.csdn.net/m0_37548423/article/details/86656070)
[https://www.cnblogs.com/pinard/p/6156009.html](https://www.cnblogs.com/pinard/p/6156009.html)
[https://www.cnblogs.com/maybe2030/p/4585705.html](https://www.cnblogs.com/maybe2030/p/4585705.html)
[https://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm#inter](https://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm#inter)
[https://www.itcodemonkey.com/article/5181.html](https://www.itcodemonkey.com/article/5181.html)
[https://www.jianshu.com/p/a779f0686acc](https://www.jianshu.com/p/a779f0686acc)
- 西瓜书-第8章
	- 个体与集成
		- 集成学习
			集成学习 (ensemble learning) 通过构建并结合多个学习器来完成学习任务，有时也被称为多分类器系统 (multi-classifier system) 、基于委员会的学习 (committee-based learning) 等.
			- 一般结构
				
![](https://img.mubu.com/document_image/7d8dd8fa-533f-4f3d-abe6-3a42385cf58a-2329912.jpg)
				集成学习的一般结构:先产生一组"个体学习器" (individual learner) ，再用某种策略将它们结合起来.
- 同质集成(homogeneous)
				集成中只包含同种类型的个体学习器。同质集成中的个体学习器亦称"基学习器" (base learner), 相应的学习算法称为"基学习算法" (base learning algorithm).
- 异质集成 (heterogenous)
				集成也可包含不同类型的个体学习器，例如同时包含决策树和神经网络，这样的集成是"异质"的 (heterogenous) .异质集成中的个体学习器由不同的学习算法生成，这时就不再有基学习算法;相应的，个体学习器一般不称为基学习器，常称为"组件学习器" (component learner) 或直接称为个体学习器.
- 对不同规模数据的策略
				- 数据集大：划分成多个小数据集，学习多个模型进行组合
- 数据集小：利用Bootstrap方法进行抽样，得到多个数据集，分别训练多个模型再进行组合
- 分类（根据个体学习器的生成方式）
				- 序列化方法
					个体学习器问存在强依赖关系、必须串行生成。代表：Boosting
- 并行化方法
					个体学习器间不存在强依赖关系、可同时生成。代表：随机森林，Bagging
- Boosting
		Boosting 是一族可将弱学习器提升为强学习器的算法.这族算法的工作机制类似:先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器;如此重复进行，直至基学习器数目达到事先指定的值 T ， 最终将这 T 个基学习器进行加权结合.
		- Boosting族算法的代表——AdaBoost  [Freund and Schapire, 1997] 
			- 推导方式
				- 加性模型" (additive model) ，即基学习器的线性组合来最小化指数损失函数(exponentialloss function) [Friedman et 址， 2000]
					
![](https://img.mubu.com/document_image/f8c99f28-66bf-4dc8-9f8f-cd5140dfca77-2329912.jpg)
					Boosting 算法要求基学习器能对特定的数据分布进行学习，这可通过"重赋权法" (re-weighting) 实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重.对无法接受带权样本的基学习算法，则可通过"重采样法" (re-sampling) 来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得的样本集对基学习器进行训练.→般而言，这两种做法没有显著的优劣差别.需注意的是， Boosting 算法在训练的每一轮都要检查当前生成的基学习器是否满足基本条件(例如罔 8.3 的第 5 行，检查当前
					基分类器是否是比随机猜测好) ，一旦条件不满足，则当前基学习器即被抛弃，且学习过程停止.在此种情形下，初始设置的学习轮数 T 也许遥远未达到，可能导致最终集成中只包含很少的基学习器而性能不佳.若采用"重采样法"，则可获得"重启动"机会以避免训练过程过早停止 [Kohavi and Wolpert, 1996] , 即在抛弃不满足条件的当前基学习器之后，可根据当前分布重新对训练样本进行采样，再基于新的采样结果重新训练出基学习器，从而使得学习过程可以持续到预设的 T 轮完成.
- Bagging与随机森林
		- 引入
			欲得到泛化性能强的集成，集成中的个体学习器应尽可能相互独立;虽然"独立"在现实任务中无法做到，但可以设法使基学习器尽可能具有较大的差异.给定一个训练数据集，一种可能的做法是对训练样本进行采样，产生出若干个不同的子集，再从每个数据子集中训练出一个墓学习器.这样，由于训练数据不同，我们获得的基学习器可望具有比较大的差异.然而，为获得好的集成，我们同时还希望个体学习器不能太差.如果来样出的每个子集都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足以进行有效学习，这显然无法确保产生出比较好的基学习器.为解决这个问题，我们可考虑使用相互有交叠的采样子集.​
- Bagging
			Bagging 这个名字是由Bootstrap AGGregatlNG 缩写而来.Bagging [Breiman, 1996a] 是井行式集成学习方法最著名的代表.从名字即可看出，它直接基于我们在 2.2.3 节介绍过的自助来样法 (bootstrap sampling). 给定包含 m 个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过 m次随机采样操作，我们得到含 m 个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现.
			- 推导
				
![](https://img.mubu.com/document_image/2b5c02c4-5493-4fdf-944d-d0cbb9205b17-2329912.jpg)
				采样出 T 个含 m 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合.这就是 Bagging 的基本流程.在对预测输出进行结合时， Bagging 通常对分类任务使用简单投票法?对回归任务使用简单平均法.若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者. 
				​
- 补充
				训练一个Bagging集成与直接使用基学习算法训练一个学习器的复杂度同阶，说明Bagging是一个很高效的集成学习算法。
				自助采样过程还给 Bagging 带来了另一个优点:由于每个基学习器只使用了初始训练集中约 63.2% 的样本，剩下约 36.8% 的样本可用作验证集来对泛化性能进行"包外估计" (out-oιbag estimate) [Breiman, 1996a; Wolpert and Macready, 1999]. 
				​​包外样本还有许多其他用途.例如当基学习器是决策树时，可使用包外样本来辅助剪枝，或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理;当基学习器是是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险.
- 对比
				- 标准AdaBoost 只适用于二分类任务。
- Bagging 能不经修改地用于多分类、回归任务。
- 随机森林
			随机森林(Random Forest ，简称 RF) [Breiman, 2001a] 是 Bagging的一个扩展变体.盯在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择.
			- 推导
				传统决策树在选择划分属性时是在当前结点的属性集合(假定有 d 个属性)中选择一个最优属性;而在RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k个属性的子集，然后再从这个子集中选择一个最优属性用于划分. 这里的参数k 控制了随机性的引入程度;若令 k = d ， 则基决策树的构建与传统决策树相同;若令 k = 1 ， 则是随机选择 一个属性用于划分; 一般情况下，推荐值 k = log2 d [Breiman, 2001]. 
				ps: 感觉随机森林与决策树的关系，有点像交叉验证法与留一法的关系。​
- 对比
				随机森林对 Bagging 只做了小改动 ， 但是与 Bagging 中 基学习器的"多样性"仅通过样本扰动(通过对初始训练集采样)而来不同，随机森林中基学习器的多样性不仅来自样本扰动 ，还来自属性扰动，这就使得最终集成的泛化性能可通
				过个体学习器之间差异度 的增加而进一步提升.
				随机森林的训练效率常优于 Bagging ，因为在个体决策树 的构建过程中 ， Bagging 使用 的是 " 确定型" 决策树在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的" 随机型"决策树则只需考察-个属性子集。
				​
- 结合策略
		- 学习器的结合带来的好处  [ Dietterich ， 2000] 
			
![](https://img.mubu.com/document_image/b96cc714-bed9-49fb-ab9d-3d261bad6da1-2329912.jpg)
- 统计
				由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能， 此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器则会减小这一风险。
- 计算
				学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险。
- 表示
				某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中 ，此时若使用单学习器则肯定无效，而通过结合多个学习器， 由于相应的假设空 间有所扩大，有可能学得更好的近似， 
- 平均法
			对数值型输出 ， 最常见的结合策略是使用平均法 ( averaging) .  加权平均法的权重一般是从训练数据中学习而得，现实任务中的训练样本通常不充分或存在噪声，这将使得学出的权重不完全可靠.尤其是对规模比较大的集成来说，要学习的权重比较多，较容易导致过拟合.因此，实验和应用均显示出，加权平均法未必一起优于简单平均法 [Xu et al., 1992; Ho et al., 1994; Kittler et al., 1998]. 一般而言，在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法.
			- 简单平均法( simple averaging) 
- 加权平均法(weighted averaging) 
- 投票法（Voting）
			标准的绝对多数投票法提供了"拒绝预测"选项，这在可靠性要求较高的学习任务中是一个很好的机制.但若学习任务要求必须提供预测结果，则绝对多数投票法将退化为相对多数投票法.因此，在不允许拒绝预测的任务中，绝对多数、相对多数投票法统称为"多数投票法"。
			以下方法军没有限制个体学习器输出值的类型。常见的输出类型有类标记，称之为“硬投票”（hard voting）；类概率，称之为“软投票”（soft voting）。​
			2. 不同类型的时 (x) 值不能混用.对一些能在预测出类别标记的同时产生分类置信度的学习器，其分类置信度可转化为类概率使用.若此类假未进行规范化，例如支持向量机的分类问隔值，则必须使用一些技术如 Platt 缩放(Platt scaling) [Platt, 2000] 、等分回归 (isotonic regression) [Zadrozny and Elkan, 2001 J 等进行"校准" (calibration) 后才能作为类概率使用.有趣的是，虽然分类器估计出的类概率值一般都不太准确?但基于类概率进行结合却往往比直接基于类标记进行结合性能更好.需注意的是，若基学习器的类型不同，则其类概率值不能直接进行比较;在此种情形下，通常可将类概率输出转化为类标记输出(例如将类概率输出最大的时 (x) 设为 1 ，其他设为 0) 然后再投票。
			​
			- 绝对多数投票法(majority voting) 
				即若某标记得票过半数，则预测为该标记;否则拒绝预测. 
				"多数投票法"的英文术语使用不太一级:有文献称为 majority voting ，也有直接称为 voting。
- 相对多数投票法
				即预测为得票最多的标记，若同时有多个标记获最高票，则从中随机选取一个。
- 加权投票法
				与加权平均法类似。
- 学习法
			当训练数据很多时?一种更为强大的结合策略是使用"学习法"，即通过另一个学习器来进行结合. Stacking [Wolpert, 1992; Brei皿础， 1996b] 是学习法的典型代表.这里我们把个体学习器称为初级学习器，用于结合的学习器称为次级学习器或元学习器(meta-learner)。
			- 代表--Stacking
				
![](https://img.mubu.com/document_image/13b17d39-88ae-420c-986d-da71e2a4b688-2329912.jpg)
				Stacking 先从初始数据集训练出初级学习器，然后"生成"一个新数据集用于训练次级学习器.在这个新数据集中，初级学习器的输出被当作样例输入特征，而初始样本的标记仍被当作样例标记.  初级学习器可以是同质的，也可以是异质的。
- 随机森林
	- 思想
		生成n棵决策树，然后这n棵决策树进行投票或者平均得出最终结果。而每棵树的每个结点生成的方式为随机选取样本、随机地选择特征。
- 推广
		- extra trees
			extra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有：
			1） 对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra trees一般不采用随机采样，即每个决策树采用原始训练集。
			2） 在选定了划分特征后，RF的决策树会基于基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。
			由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。即模型的方差相对于RF进一步减少，但是偏倚相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。
- Totally Random Trees Embedding
			Totally Random Trees Embedding(以下简称 TRTE)是一种非监督学习的数据转化方法。它将低维的数据集映射到高维，从而让映射到高维的数据更好的运用于分类回归模型。我们知道，在支持向量机中运用了核方法来将低维的数据集映射到高维，此处TRTE提供了另外一种方法。
			　　TRTE在数据转化的过程也使用了类似于RF的方法，建立T个决策树来拟合数据。当决策树建立完毕以后，数据集里的每个数据在T个决策树中叶子节点的位置也定下来了。比如我们有3颗决策树，每个决策树有5个叶子节点，某个数据特征xx划分到第一个决策树的第2个叶子节点，第二个决策树的第3个叶子节点，第三个决策树的第5个叶子节点。则x映射后的特征编码为(0,1,0,0,0,     0,0,1,0,0,     0,0,0,0,1), 有15维的高维特征。这里特征维度之间加上空格是为了强调三颗决策树各自的子编码。
			　　映射到高维特征后，可以继续使用监督学习的各种分类回归算法了。
- Isolation Forest
			Isolation Forest（以下简称IForest）是一种异常点检测的方法。它也使用了类似于RF的方法来检测异常点。
			对于在T个决策树的样本集，IForest也会对训练集进行随机采样,但是采样个数不需要和RF一样，对于RF，需要采样到采样集样本个数等于训练集个数。但是IForest不需要采样这么多，一般来说，采样个数要远远小于训练集个数？为什么呢？因为我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来了。
			　对于每一个决策树的建立， IForest采用随机选择一个划分特征，对划分特征随机选择一个划分阈值。这点也和RF不同。
			另外，IForest一般会选择一个比较小的最大决策树深度max_depth,原因同样本采集，用少量的异常点检测一般不需要这么大规模的决策树。
			　对于异常点的判断，则是将测试样本点xx拟合到T颗决策树。计算在每颗决策树上该样本的叶子节点的深度ht(x)ht(x)。，从而可以计算出平均高度h(x)。
- 优缺点
		- 优点
			1） 训练可以高度并行化，对于大数据时代的大样本训练速度有优势。个人觉得这是的最主要的优点。
			2） 由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。
			3） 在训练后，可以给出各个特征对于输出的重要性
			4） 由于采用了随机采样，训练出的模型的方差小，泛化能力强。
			5） 相对于Boosting系列的Adaboost和GBDT， RF实现比较简单。
			6） 对部分特征缺失不敏感。
- 缺点
			1）在某些噪音比较大的样本集上，RF模型容易陷入过拟合。
			2) 取值划分比较多的特征容易对RF的决策产生更大的影响，从而影响拟合的模型的效果。
- sklearn参数
		- n_estimators
			随机森林中树的棵树，默认是10棵。
- criterion
			样本集切分策略，默认是gini指数，此时树模型为CART模型，当值选为信息增益的时候，模型就成了ID3模型，默认为CART模型。
- bootstrap
			是统计学中的一种重采样技术，可以简单理解成是有放回地抽样，默认是True,即采取有放回抽样这种策略，这不就是bagging的思想么。
- oob_score
			袋外估计(out-of-bag)，这个外是针对于bagging这个袋子而言的，我们知道，bagging采取的随机抽样的方式去建立树模型，那么那些未被抽取到的样本集，也就是未参与建立树模型的数据集就是袋外数据集，我们就可以用这部分数据集去验证模型效果，默认值为False。
- 应用场景
		- 数据维度相对低（几十维），同时对准确性有较高要求时。
- 因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。
