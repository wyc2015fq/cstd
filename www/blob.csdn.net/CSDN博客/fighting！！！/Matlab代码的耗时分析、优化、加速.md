# Matlab代码的耗时分析、优化、加速 - fighting！！！ - CSDN博客
2018年12月16日 22:25:32[dujiahei](https://me.csdn.net/dujiahei)阅读数：61
转自 [http://blog.sina.com.cn/s/blog_6f64146b01019ojm.html](https://link.jianshu.com?t=http%3A%2F%2Fblog.sina.com.cn%2Fs%2Fblog_6f64146b01019ojm.html)
**Profile(**分析）
在加速你的matlab程序之前，你需要知道你的代码哪一部分运行最慢。matlab提供个简单的机制，让你能够知道你的代码的某一部分运行所占用CPU时间。通过在代码段开始添加tic，及在结束添加toc；matlab就能计算出这一代码段的运行时间。
Tic和toc方法存在两个问题：
（1）显示的时间是运行时间“wall clock”。这个时间受你在运行你的代码时，你的计算机是否同时运行其它别的程序。
（2）你需要不断地压缩计时范围来查找你代码运行最慢的位置。
一个最好的方法是利用matlab 内嵌的代码分析器。在你的程序前面通过添加命令profile on;及在程序结束添加profile viewer;并运行你的程序。当程序正常运行结束时，代码分析器窗口将弹出，并显示分析结果。它包含的信息
有：
Function Name :函数名；
Calls :函数被调用次数；
Total Time :执行该函数的CPU总用时，包含任何其它被它调用的函数的CPU时间。
Self Time :执行该函数的CUP总用时，不包含任何其它被它调用的函数的CUP时间。
Total Time Plot :时间用时的曲线图。
以上信息可进行各种排序和详细查看。
注意：当你完成你的代码分析后，请删除profile on和profile viewer，因为嵌入代码分析器会使用的程序运行变慢。
**标准提示**
**☆**有问题找帮助文档。学会使用帮助文档，学会针对待解决的问题检索文档资料。
**☆性能**
查看MATLAB->Programming->Improving Performace and Memory Usage;或MATLAB->Programming
Fundamentals->Performace->Techniques for Improveing Performace。
**多线程**
如果你使用的是多核心的计算机，那么你就可以让Matlab同时运行多个线程，Matlab程序中一些底层的函数
(Low-level function)就有可能采用并行计算的方法。打开多线程的方法：File->Preferences选择General->
Multithreading。扣选Enable multihread computation box。如果不限制使用核心的数目，可以保留使用Automatic。
**注意：**Matlab R2008a之前的版本在AMD处理器上是不支持多线程的。
**向量化循环**
Matlab的运算是针对向量（矢量）和矩阵进行设计的，因此它在向量和矩阵上的运算速度比采用循环的方式更快。
例如：
index=0;
for time=0:0.001:60;
index=index+1;
waveForm(index)=cos(time);
end;
采用以下代码可加快速度。
Time=0:0.01:60;
waveForm=cos(time);
一些有用的，可用于代替循环的函数：
any();size();find();cumsum();sum();
**向量预分配**
Matlab采用内存中一块连续的空间来存储向量和矩阵数据，而不是用链表。这就意味着你每给向量或矩阵增加一元
素，Matlab需要寻找一块足够大的内存区域来存储这个扩大后的向量或矩阵，然后复制现有的数据到新的内存区
域。在循环中增加向量或矩阵元素的元数是允许的，但并不是明智之举，而应该是一次性分配向量或矩阵的大小，
或一次性重定义尺寸。
Results=0;
for index=2:1000;
results(index)=results(index-1)+index;
end
上述代码将比以下代码速度慢：
results=zeros(1,1000);
for index=2:1000;
results(kindex)=results(kindex-1)+index;
end;
**注意：**当你需要用zeros()来创建一个指定数据类型的向量或矩阵时，你可以使用创建参数来指定类型，而不是“重铸”。results=int8(zeros(1,1000));将创建一个有1000个元素的double型零向量，然后把它转换成int8类型。如果我们使用results=zeros(1,1000,'int8'); Matlab将支持建立1000个int8类型的向量，在创建可实现性及速度上将更具有优势。
**不要改变数据类型**
Matlab为了能够支持宽松的数据类型（例如一个变量能够存储不同类型的数据，而不是指定它为特定的数据类型），则Matlab除了存储单纯的数据之外，还需要伴随数据存储一定数量的头信息（header），这就意味着需要内存空间支存储数据类型，同时意味需要在数据类型转换上支付额外的计算机资源开支。
**对于实数据使用　**real...函数。
Matlab中的一些函数能够同时适用于实类型数据和复类型数据。如果你只使用实数据，那么采用特定的版本的，非复数据函数，那么它运行的速度将变得更快。这些函数如：reallog(), realpow(),realsqrt()。
**使用“短路”逻辑操作**
Matlab的“短路”逻辑操作可以在判断条件达到充分条件后就停止计算处理，而不需要知道判断所有条件。例如：if(index>=3)&&(data(index)==5); 当index小于3时，第二个条件判断将不被处理，这样就少了去判断data(index)==5)的时间，提高速度。
**使用函数指针**
Matlab的一些函数使用函数名作用参数，常用一个变量支保存这个函数名字符串（）如：func='tan';然后用这个变量作为函数的参数：fzero(func,0))。这种方法对于简单的函数调用是很好的，但是对于在循环中的重复调用就存在两个问题：
（1）在每一个循环中，Matlab需要去搜索这个函数的路径（如tan），这需要花费时间。
（2）在循环过程中，路径可能会改变。这会保证在这一次循环中，某个版本的函数(如tan)被首先调用，而下一次
循环中这个版本的函数又被首先调用，最终会造成结果不一致。
解决的办法是使用文件指针(;或func=@sin),它能返回函数唯一的识别码。调用方式同上。
**文件**I**／**O
通常高级输入输出操作（load()和save()）比一般的低级操作（fread()和fwrite()）快。
**☆内存使用**
关于内存的使用可查看帮助文档Using Menory Efficently。可查与Memory Usage相关的信息。
一定记注：可以使用whos()来查看数据变量占有用的内存空间大小。
**复制数组**
当你复制一个数组时，Matlab开始只复制一个指向数据的一个指针，仅当你随后对任一版本进行修时，数据的复制
才真正的执行。这种操作包括数组作为函数参数进行传递的情况－作为值传递的参数传递，而不是作为参考的传
递。因此，你应该尽量避开对大数组进行小改动的操作。
**数据不用时，释放内存**
如果一个变量以后已经不再使用，那么你可以删除它clear VariableName;则这个小块的数据将可以重用。
**注意：**如果各变量在内存是连续的，则Matlab很容易重用这些大块的内存，因此最好是先建立大的变量，后再建立
小的变量，并且把它们组合起来。
**结构体存储**
上文已经提到，在Matlab中的变量包含有描述数据类型的头信息。对于一个结构体，则有一个描述整个结构的头信
息，及每个元素也分别有一个头信息。为了最小化地使用内存，我们应该小心地使用混合数据类型的数组和结构。
例如：
pixel.red(1:600,1:400)
pixel.grn(1:600,1:400)
pixel.blu(1:600,1:400)
则我们就需要存储4个头信息。而：
pixel(1:600,1:400).red
pixel(1:600,1:400).grn
pixel(1:600,1:400).blu
我们就有720001个头信息。
**使用最小的合适的数据类型**
为了减小内存使用量，对于特定的运算经常使用最小的数据类型。例如：
（1）对于虚部为零的数据，最好不要用complex去存储。
（2）如果精度足够，可采用single变量，而不用double。
（3）使用uint16来进行计数操作，它能存储值为0到65535。但它比默认的double型省一半的内存。
**使用稀疏矩阵**
如果矩阵绝大多的数据为零值，可以把它转化成稀疏形式（使用sparse()函数）。它将只存储非零数据的数值和索
引。因为需要额外的存储数据的索引，因此只有二维数据的零值大约超过75％时，这种方法才是有效的，否则稀
疏形式反而需要更多的内存空间。
**☆并行循环**
如果从一个for循环的外部看，for循环满足以下标准：
（1）循环的计数是整数；
（2）每次循环都是独立的；
（3）计算循环先后顺序无关。
那么这个for循环就有可能可以替换成parfor循环（matlab2008a中可用优化算打开并行通信池：parfor循环包含于
matlabpool open 和matlabpool close之间）。
**注意：**打开一个并行工作池worker pool大约需要10-15秒钟，关闭一个工作池大概需要5秒钟。计算这个时间在
内，这个方法对于循环时间超过30秒的情况才是值得的。
