# Python-GoogleCourse 学习 Day6 - fighting！！！ - CSDN博客
2019年02月26日 22:15:36[dujiahei](https://me.csdn.net/dujiahei)阅读数：9
## 参考：
[http://www.runoob.com/python3/python3-class.html](http://www.runoob.com/python3/python3-class.html)
[https://www.cnblogs.com/lzcys8868/p/7797501.html](https://www.cnblogs.com/lzcys8868/p/7797501.html)
[https://www.cnblogs.com/HByang/articles/9224817.html](https://www.cnblogs.com/HByang/articles/9224817.html)
[https://www.cnblogs.com/heiheihaha/p/4410112.html](https://www.cnblogs.com/heiheihaha/p/4410112.html)
## 知识点：
- 类和对象
	Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。
	- 面向对象技术简介
		类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
		方法：类中定义的函数。
		类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
		数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
		方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
		局部变量：定义在方法中的变量，只作用于当前实例的类。
		实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。
		继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
		实例化：创建一个类的实例，类的具体对象。
		对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
		和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。
		Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。
		对象可以包含任意数量和类型的数据。
- 类定义和类对象
		- 类定义
			法格式如下：
			class ClassName:
			<statement-1>
			.
			.
			.
			<statement-N>
			类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。
- 类对象
			类对象支持两种操作：属性引用和实例化。
			- 属性引用
				属性引用使用和 Python 中所有的属性引用一样的标准语法：[obj.name](http://obj.name)。
				类对象创建后，类命名空间中所有的命名都是有效属性名。
- 实例化--_init_方法理解
				类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用。
				__init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。​
- self 理解：self代表类的实例，而非类
				类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。
- 类的方法
			在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。
- 继承
		Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:
		class DerivedClassName(BaseClassName1):
		<statement-1>
		.
		.
		.
		<statement-N>
		需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。
		BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:
		class DerivedClassName(modname.BaseClassName):
- 公有和私有
		​Python中默认的成员函数，成员变量都是公开的(public),而且python中没有类似public,private等关键词来修饰成员函数，成员变量。
		在python中定义私有变量只需要在变量名或函数名前加上 ”__“两个下划线，那么这个函数或变量就会为私有的了。
		在类的外面访问私有属性会引发异常。
		属性被私有化，即使继承他的字类也不能访问到。​
		在内部，python使用一种 name mangling 技术，将 __membername替换成 _classname__membername，所以你在外部使用原来的私有成员的名字时，会提示找不到。
- python 错误和异常
	- 语法错误
		Python 的语法错误或者称之为解析错，是初学者经常碰到的，例如缺少冒号。
		语法分析器指出出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。​
- 异常
		即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。
		大多数的异常都不会被程序处理，都以错误信息的形式展现。
		异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。
		错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。​
		- 异常处理
			使用try....except
			​一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。
			处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。
			一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组.
			ry except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。​
			使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。
			异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。​
- 抛出异常
			Python 使用 raise 语句抛出一个指定的异常。
			​raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。
			如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。
- 用户自定义异常
			你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。
			​当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。
			大多数的异常的名字都以"Error"结尾，就跟标准的异常命名一样。​
- 定义清理行为
			try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。
			不管 try 子句里面有没有发生异常，finally 子句都会执行。
			如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。
- 预定义清理行为
			一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法。
