# ROC曲线与AUC值 - fighting！！！ - CSDN博客
2019年02月26日 11:38:59[dujiahei](https://me.csdn.net/dujiahei)阅读数：57
转自：[http://www.cnblogs.com/gatherstars/p/6084696.html](http://www.cnblogs.com/gatherstars/p/6084696.html)
本文根据以下文章整理而成，链接：
（1）[http://blog.csdn.net/ice110956/article/details/20288239](http://blog.csdn.net/ice110956/article/details/20288239)
（2）[http://blog.csdn.net/chjjunking/article/details/5933105](http://blog.csdn.net/chjjunking/article/details/5933105)
# 1.概述
　　AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。这样的标准其实有很多，例如：大约10年前在machine learning文献中一统天下的标准：分类精度；在信息检索(IR)领域中常用的recall和precision，等等。其实，度量反应了人们对”好”的分类结果的追求，同一时期的不同的度量反映了人们对什么是”好”这个最根本问题的不同认识，而不同时期流行的度量则反映了人们认识事物的深度的变化。
　　近年来，随着machine learning的相关技术从实验室走向实际应用，一些实际的问题对度量标准提出了新的需求。特别的，现实中样本在不同类别上的不均衡分布(class distribution imbalance problem)。使得accuracy这样的传统的度量标准不能恰当的反应分类器的performance。举个例子：测试样本中有A类样本90个，B 类样本10个。分类器C1把所有的测试样本都分成了A类，分类器C2把A类的90个样本分对了70个，B类的10个样本分对了5个。则C1的分类精度为 90%，C2的分类精度为75%。但是，显然C2更有用些。另外，在一些分类问题中犯不同的错误代价是不同的(cost sensitive learning)。这样，默认0.5为分类阈值的传统做法也显得不恰当了。
为了解决上述问题，人们从医疗分析领域引入了一种新的分类模型performance评判方法——ROC分析。ROC分析本身就是一个很丰富的内容，有兴趣的读者可以自行Google，这里只做些简单的概念性的介绍。
　　ROC的全名叫做Receiver Operating Characteristic，其主要分析工具是一个画在二维平面上的曲线——ROC curve。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC curve来表示分类器的performance很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。
# 2.ROC曲线
## 2.1ROC的动机
　　对于0，1两类分类问题，一些分类器得到的结果往往不是0，1这样的标签，如神经网络得到诸如0.5，0.8这样的分类结果。这时，我们人为取一个阈值，比如0.4，那么小于0.4的归为0类，大于等于0.4的归为1类，可以得到一个分类结果。同样，这个阈值我们可以取0.1或0.2等等。取不同的阈值，最后得到的分类情况也就不同。如下面这幅图：
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105301206-555790185.png)
　　蓝色表示原始为负类分类得到的统计图，红色表示原始为正类得到的统计图。那么我们取一条直线，直线左边分为负类，直线右边分为正类，这条直线也就是我们所取的阈值。阈值不同，可以得到不同的结果，但是由分类器决定的统计图始终是不变的。这时候就需要一个独立于阈值，只与分类器有关的评价指标，来衡量特定分类器的好坏。还有在类不平衡的情况下，如正样本有90个，负样本有10个，直接把所有样本分类为正样本，得到识别率为90%，但这显然是没有意义的。如上就是ROC曲线的动机。
## 2.2ROC的定义
　　关于两类分类问题，原始类为positive、negative，分类后的类别为p'、n'。排列组合后得到4种结果，如下图所示：
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105324471-798238482.png)
　　于是我们得到四个指标，分别为：真阳、伪阳、伪阴、真阴。ROC空间将伪阳性率（FPR）定义为 X 轴，真阳性率（TPR）定义为 Y 轴。这两个值由上面四个值计算得到，公式如下：
　　TPR：在所有实际为阳性的样本中，被正确地判断为阳性之比率。TPR=TP/(TP+FN)
　　FPR：在所有实际为阴性的样本中，被错误地判断为阳性之比率。FPR=FP/(FP+TN)
　　放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。不难发现，这两个指标之间是相互制约的。如果某个医生对于有病的症状比较敏感，稍微的小症状都判断为有病，那么他的第一个指标应该会很高，但是第二个指标也就相应地变高。最极端的情况下，他把所有的样本都看做有病，那么第一个指标达到1，第二个指标也为1。
## 2.3ROC的图形化表示
　　我们以FPR为横轴，TPR为纵轴，得到如下ROC空间：
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105420346-41033633.png)
　　我们可以看出：左上角的点（TPR=1，FPR=0），为完美分类，也就是这个医生医术高明，诊断全对；点A（TPR>FPR），医生A的判断大体是正确的。中线上的点B（TPR=FPR），也就是医生B全都是蒙的，蒙对一半，蒙错一半；下半平面的点C（TPR<FPR），这个医生说你有病，那么你很可能没有病，医生C的话我们要反着听，为真庸医。
上图中一个阈值，得到一个点。现在我们需要一个独立于阈值的评价指标来衡量这个医生的医术如何，也就是遍历所有的阈值，得到ROC曲线。还是一开始的那幅图，假设如下就是某个医生的诊断统计图，直线代表阈值。我们遍历所有的阈值，能够在ROC平面上得到如下的ROC曲线。
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105441706-341239353.png)
　　曲线距离左上角越近，证明分类器效果越好。
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105504034-991875038.png)
　　如上，是三条ROC曲线，在0.23处取一条直线。那么，在同样的FPR=0.23的情况下，红色分类器得到更高的TPR。也就表明，ROC越往上，分类器效果越好。我们用一个标量值AUC来量化他。
# 3.AUC值
## 3.1AUC值的定义
　　AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。
　　AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。
　　0.5 < AUC < 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。
　　AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。
　　AUC < 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。
## 3.2AUC值的物理意义
　　假设分类器的输出是样本属于正类的socre（置信度），则AUC的物理意义为，任取一对（正、负）样本，正样本的score大于负样本的score的概率。
## 3.3AUC值的计算
　　（1）第一种方法：AUC为ROC曲线下的面积，那我们直接计算面积可得。面积为一个个小的梯形面积之和，计算的精度与阈值的精度有关。
　　（2）第二种方法：根据AUC的物理意义，我们计算正样本score大于负样本的score的概率。取N*M（N为正样本数，M为负样本数）个二元组，比较score，最后得到AUC。时间复杂度为O(N*M)。
　　（3）第三种方法：与第二种方法相似，直接计算正样本score大于负样本的score的概率。我们首先把所有样本按照score排序，依次用rank表示他们，如最大score的样本，rank=n(n=N+M)，其次为n-1。那么对于正样本中rank最大的样本（rank_max），有M-1个其他正样本比他score小，那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)。最后我们得到正样本大于负样本的概率为：
![](https://images2015.cnblogs.com/blog/788753/201611/788753-20161121105619909-390514975.png)
时间复杂度为O(N+M)。
