# 如何让脚本支持jsr223 - 彩虹糖的博客 - CSDN博客





2018年03月28日 16:06:49[彩虹糖梦](https://me.csdn.net/caozixuan98724)阅读数：788








这个问题源于编译原理的第一次作业，要求书写一个具有读取简单计算式并输出结果的脚本，给出的测试文件要求我们支持jsr223。

从JDK1.6开始，Java引入了jsr223，可以方便的在JVM上执行脚本语言，网上的教程主要针对的是java已经提供的ScriptEngine，比如如下这个代码示例：

```java
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
public class TestScript1 {
    public static void main(String[] args) throws Exception {
        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
        ScriptEngine scriptEngine = scriptEngineManager.getEngineByName("javascript");
        String exp = "2*6-(6+5)";
        Object result = scriptEngine.eval(exp);
        System.out.println(exp + "=" + result);
    }
}
```

（代码摘自：[jsr223-Java中的script引擎接口](http://www.ticmy.com/?p=267)）

但是关于如何支持自己写的脚本，相关资料偏少，通过询问大佬们，和在github上找到的一个叫[BrainfuckScriptEngine](https://github.com/natanbc/BrainfuckScriptEngine)的项目，大致了解了如何让自己的脚本支持jsr223。

要让自己的脚本支持jsr223，主要要做两件事情：创建一个engine类**继承**AbstractScriptEngine，创建一个Factory类**实现**ScriptEngineFactory接口。

### 一.engine类继承AbstractScripEngine

在上文提到的BrainfuckScriptEngine这个项目中，作者把engine类和真正实现脚本的类interpreter分开来写，但因为本次作业Calculator类要实现的功能比较少，可以把Calculator和engine合为一个类，记做calculator（类的名字当然是可以随便起的）。

首先查看JDK手册了解一下继承AbstractScriptEngine中有哪些方法：



![](https://img-blog.csdn.net/20180328153132217)





根据编译器的提示，我们必须实现的方法有以下四个：

```java
public Object eval(String script, ScriptContext context) throws ScriptException;
public Object eval(Reader reader, ScriptContext context) throws ScriptException;
public Bindings createBindings();
public ScriptEngineFactory getFactory();
```

但是从我们作业给出的测试文件来看，我们只用到了第一个方法，其他方法返回空即可，于是代码可以这么写：

```java
import java.io.Reader;
import javax.script.*;


public class calculator extends AbstractScriptEngine{

    @Override
    public Object eval(String script, ScriptContext context) throws ScriptException {
        try {
            // 在这里添加处理script这个字符串需要的代码。
            return null;
        } catch(ScriptException e) {
            throw new ScriptException(e);
        }
    }

    @Override
    public Object eval(Reader reader, ScriptContext context) throws ScriptException {
        return null;
    }

    @Override
    public Bindings createBindings() {
        return null;
    }

    @Override
    public ScriptEngineFactory getFactory() {
        return null;
    }
```

### 二. factory类实现ScriptEngineFactory接口

新建一个类名为calculatorEngineFactory，实现ScriptEngineFactory接口。

还是先看一下ScriptEngineFactory接口中有哪些要实现的方法。

![](https://img-blog.csdn.net/20180328154735488)


这些方法按照我的理解是定义了engine的相关属性，提供给其他类访问engine的方法。

在这一次给出的测试脚本中，大部分属性都是没有用的，最有用的应该是getEngineName()和getMethodCallSyntax()和getScriptEngine()这三个方法，其他方法随便写即可。

```java
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;

public class calculatorEngineFactory implements ScriptEngineFactory {

    public String getEngineName() {
        // define your engine nanme
        return "calculator";
    }

    public String getEngineVersion() {
        return "1.0";
    }

    public List getExtensions() {
        return null;
    }

    public List getMimeTypes() {
        return null;
    }

    public List getNames() {
        return Arrays.asList( "calculator");
    }

    public String getLanguageName() {
        return "Calculator Script";
    }

    public String getLanguageVersion() {
        return "1.0";
    }

    public Object getParameter(String var1) {
        if (Objects.equals(var1, "javax.script.engine")) {
            return this.getEngineName();
        } else if (Objects.equals(var1, "javax.script.engine_version")) {
            return this.getEngineVersion();
        } else if (Objects.equals(var1, "javax.script.name")) {
            return this.getNames();
        } else if (Objects.equals(var1, "javax.script.language")) {
            return this.getLanguageName();
        } else {
            return Objects.equals(var1, "javax.script.language_version") ? this.getLanguageVersion() : null;
        }
    }

    public String getMethodCallSyntax(String var1, String var2, String... var3) {
        return "";
    }

    public String getOutputStatement(String var1) {
        return null;
    }

    public String getProgram(String... var1) {
        return "";
    }

    public ScriptEngine getScriptEngine() 
    { 
        // return your object
        return new calculator(); 
    }
}
```

### 三.登记所写的类

如图所示：

![](https://img-blog.csdn.net/20180328155920751)![](https://img-blog.csdn.net/20180328155926788)


在src文件夹下新建文件夹META-INF，再在META-INF文件夹下创建文件夹services文件夹，在services文件夹下创建文件（无扩展名）javax.script.ScriptEngineFactory，再在这个文件内写入calculatorEngineFactory（也就是你的factory类的名字）。

这样子我们便完成了对jsr223的支持。

### 四.补充

在jsr223中，我们经常会用到put这个方法，来将变量和对应的值关联起来，构建键值对，但在默认的键值对中，key的属性是String，value的属性是Object，而我们一般用到的不是Object，所以要进行类型转换，这样子使用put方法构建键值对就不会报错了。

```java
@Override
public void put(String s, Object o){
    super.put(s,Double.valueOf(o.toString()));
}
```













