# 1.7 爬取汽车之家实战 - 博客堂 - CSDN博客





2017年05月02日 21:47:43[最小森林](https://me.csdn.net/u012052268)阅读数：5841








# 1.7 爬取汽车之家实战



- [7 爬取汽车之家实战](#17-爬取汽车之家实战)- [任务简介 及 爬虫架构极](#1-任务简介-及-爬虫架构极)
- [url管理器](#2-url管理器)
- [网页下载器](#3-网页下载器)
- [网页解析器](#4-网页解析器)
- [保存获取的信息](#5-保存获取的信息)





## 1. 任务简介 及 爬虫架构极

前面学习了，爬虫的基本架构。现在要动手实践了，因为师兄说“学一门语言就必须上手去练习！”。

爬取哪个网站呢？正好，最近需要汽车之家上面的数据， 我就爬这个。**本文代码全部共享于GitHub上，地址**：[爬取汽车之家实战：github](https://github.com/xqtbox/python3-autohome-spider)

> 
目标：爬取100种汽车的名字，以及网友对它的评分。


下面开始编程：
- 在pychram中创建一个工程
- 在工程中新建一个python包
- 新建一个main类
- 创建各个功能类：url管理器、网页下载器、网页解析器、保存获取的信息

下面贴上main类的代码（有详细注释）：

```python
# 加载url管理器、下载器、解析器、输出器
from autohome_spider import url_manager, html_downloader, html_parser, html_outputer


class SpiderMain(object):
    # 初始化各个对象
    def __init__(self):
        self.urls = url_manager.UrlManager()
        self.downloader = html_downloader.HtmlDownloader()
        self.parser = html_parser.HtmlParser()
        self.outputer = html_outputer.HtmlOutputer()

    def craw(self, root_url):
        # 记录当前爬取的是第几个url
        count = 1
        # 将入口url添加进url管理器，这样url管理器就有了待爬取的url,我们就可以启动爬虫的循环
        self.urls.add_new_url(root_url)
        # 当url管理器有新的url时，启动循环
        while self.urls.has_new_url():
            try:
                # 获取待爬取的url
                new_url = self.urls.get_new_url()
                # 实时打印爬取数和爬取url
                print('craw %s : %s' % (count, new_url))
                # 下载器下载页面
                html_cont = self.downloader.download(new_url)
                # print(html_cont)

                # 解析器解析url和页面，得到新的url和数据(返回两个值)
                new_urls, new_data = self.parser.parse(new_url, html_cont)

                # 获得的新的url添加进url管理器
                self.urls.add_new_urls(new_urls)
                # 收集数据
                self.outputer.collect_data(new_data)

                # 设置爬取数
                if count == 100:
                    break

                count = count + 1
            except Exception as e:
                print(str(e))

        # 输出收集好的数据
        self.outputer.output_html()

if __name__ == '__main__':
    # 爬虫入口url
    root_url = 'http://www.autohome.com.cn/78/#pvareaid=103177'
    obj_spider = SpiderMain()
    obj_spider.craw(root_url)
```

## 2. url管理器

url管理器存放已经抓取的url和还没抓取的url

```python
class UrlManager(object):
    # 初始化存放新的url列表和爬取过的url列表
    def __init__(self):
        self.new_urls = set()
        self.old_urls = set()

    # 向url管理器添加一个新的url
    def add_new_url(self, url):
        # url是否是空
        if url is None:
            return
        # url是否存在在新的url列表和爬取过的url列表中
        if url not in self.new_urls and url not in self.old_urls:
            self.new_urls.add(url)

    # 向url管理器添加新的url(urls是 解析器 返回的新的url列表)
    def add_new_urls(self, urls):
        # urls是否是空
        if urls is None or len(urls) == 0:
            return
        # 逐一添加url
        for url in urls:
            self.add_new_url(url)

    # url管理器是否有新的待爬取url
    def has_new_url(self):
        return len(self.new_urls) != 0

    # 从url管理器中获取新的待爬取url
    def get_new_url(self):
        # 获取url并从new_urls中移除
        new_url = self.new_urls.pop()
        # 添加进已爬取old_urls中
        self.old_urls.add(new_url)
        # 返回新的url
        return new_url
```

## 3. 网页下载器

网页下载器 将下载所给的url的网页html代码。在这里要特别注意“乱码问题”，解决办法见我另一篇文章–>：[Python字符串的encode与decode研究心得——解决乱码问题](http://blog.csdn.net/u012052268/article/details/71101721)

代码如下：

```python
from urllib import request
from urllib import parse
### 使用urllib库进行下载HTML页面

class HtmlDownloader(object):
    def download(self, url):
        if url is None:
            return None
        values = {'name': 'voidking', 'language': 'Python'}
        data = parse.urlencode(values).encode(encoding='utf-8', errors='ignore')
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0','Content-Length': '0'}
        request1 = request.Request(url=url, data=data, headers=headers, method='GET')
        response = request.urlopen(request1)

        if response.getcode() != 200:
            return None

        buff = response.read()
        html = buff.decode("gb2312",errors='ignore')
        return html
from urllib import request
from urllib import parse
### 使用urllib库进行下载HTML页面

class HtmlDownloader(object):
    def download(self, url):
        if url is None:
            return None
        values = {'name': 'voidking', 'language': 'Python'}
        data = parse.urlencode(values).encode(encoding='utf-8', errors='ignore')
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0','Content-Length': '0'}
        request1 = request.Request(url=url, data=data, headers=headers, method='GET')
        response = request.urlopen(request1)

        if response.getcode() != 200:
            return None

        buff = response.read()
        html = buff.decode("gb2312",errors='ignore')
        return html
```

## 4. 网页解析器

网页解析器的主要作用是： 

1. 匹配html代码中的所需信息（车名，评分） 

2. 找出当前页面中指向另外的车页面的url
代码如下：

```python
from bs4 import BeautifulSoup
import re
from urllib import parse


class HtmlParser(object):

    # 获取html中的新的连接
    def _get_new_urls(self, page_url, soup):
        # 结果存入列表
        new_urls = set()
        # 正则匹配：<a href="/3589/#pvareaid=101201" title="博瑞">博瑞</a>
        links = soup.find_all('a', href=re.compile(r'/\d+/#pvareaid=\d+'),title=re.compile(r'\S'))
        for link in links:
            # 获取相对url
            new_url = link['href']
            # 拼接为完整url
            new_full_url = parse.urljoin(page_url, new_url)
            # print(new_full_url)
            new_urls.add(new_full_url)
        # print(new_urls)
        return new_urls

    # 获取当前页面 汽车的名字以及评分
    def _get_new_data(self, page_url, soup):
        # 存放数据
        res_data = {}
        # url
        res_data['url'] = page_url

        # 获取html中的车名
        # <div class="subnav-title-name">   <a href="/78/">广汽本田-<h1>雅阁</h1></a>     </div>
        title_node = soup.find(
            'div', class_='subnav-title-name').find('a')
        # 转换成字符串 并去除<h1>标签
        res_data['title'] = title_node.get_text().strip('<h1>').strip('</h1>')

        # 获取html中的汽车评分
        # <a class="font-score" href="http://k.autohome.com.cn/78/8369/#pvareaid=101486">4.38</a>
        summary_node = soup.find('a', class_='font-score')
        res_data['summary'] = summary_node.get_text()
        print(res_data)
        return res_data

    def parse(self, page_url, html_cont):
        if page_url is None or html_cont is None:
            return

        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')
        soup2 = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')
        new_urls = self._get_new_urls(page_url, soup)
        new_data = self._get_new_data(page_url, soup2)
        return new_urls, new_data
```

## 5. 保存获取的信息

这个类用于保存获取的信息，将所需要的信息保存为一个页面，便于查看。如下图：

![图片](http://i2.muimg.com/567571/4ab5112ea5ca5b94.png)

代码如下：

```python
class HtmlOutputer(object):
    def __init__(self):
        self.datas = []

    def collect_data(self, data):
        if data is None:
            return
        self.datas.append(data)

    def output_html(self):
        # 在windows下新文件的默认编码是gbk，需手动改为utf-8
        fout = open('output.html', 'w', encoding='utf-8')
        fout.write('<html>')
        fout.write('<body>')
        fout.write('<table>')

        # 表头
        fout.write('<tr>')
        fout.write('<td>公司-车名</td>')
        fout.write('<td>网友评分</td>')
        fout.write('</tr>')


        for data in self.datas:
            fout.write('<tr>')
            # fout.write('<td>%s</td>' % data['url'])
            fout.write('<td>%s</td>' % data['title'])
            fout.write('<td> %s</td>' % data['summary'])
            fout.write('</tr>')

        fout.write('</table>')
        fout.write('</body>')
        fout.write('</html>')

        fout.close()
```




