# Java 中类和方法修饰符 - 博客堂 - CSDN博客





2017年02月15日 10:53:03[最小森林](https://me.csdn.net/u012052268)阅读数：241标签：[java](https://so.csdn.net/so/search/s.do?q=java&t=blog)
个人分类：[java](https://blog.csdn.net/u012052268/article/category/3058811)









[Java](http://lib.csdn.net/base/javase) 中类和方法修饰符

类的修饰

访问修饰符 修饰符 class 类名 extends 父类名称 implements 接口名称（notes: 访问修饰符符与修饰符的位置可以互换）
|访问修饰符| | |
|----|----|----|
|名称|说明|备注|
|pubic|可以被所有类访问(使用)|public 类必须定义在和类名相同的同名文件中|
|package|可以被同一个包中的类访问(使用)|默认的访问权限，可以省略此关键字，可以定义在和public类的同一个文件中|


|修饰符| | |
|----|----|----|
|名称|说明|备注|
|final|使用此修饰符的类不能够被继承||
|abstract|如果要使用abstract类，之前必须首先建一个继承abstract类的新类，新类中实现abstract类中的抽象方法|类只要有一个abstract方法，类就必须定义为abstract，但abstract类不一定非要有abstract方法不可|



变量的修饰

﹟Java中没有全局变量，只有方法变量、实例变量（类中的非静态变量）、类变量（类中的静态变量）

﹟方法中的变量不能够有访问修饰符，所以下面的修饰符表仅针对类中定义的变量。

﹟声明实例变量或静态变量时如果没有赋初值，将被初始化为null(引用类型)或者0、false(布尔类型) 而方法变量必须被初始化。

﹟可以通过实例变量初始化器来初始化初始化比较复杂的实例变量，实例变量的初始化是一个用{}包含的语句块，在类的构造被调用时运行，运行于父类的构造器之后，构造器之前。

﹟类变量(静态变量)也可以通过类变量初始化器来进行初始化，类变量的初始化器是一个用static{}包含的语句块，只可能被初始化一次。
|**访问修饰符**| | |
|----|----|----|
|名称|说明|备注|
|public|可以被任何类访问||
|protected|可以被同一包中的所有类访问、可以被所有子类访问|子类没有在同一包中也可以访问|
|private|只能够被当前类的方法访问||
|缺省（无访问修饰符）|可以被同一包中的所有的类访问|如果子类没有在同一个包中，也不能访问|


|修饰符| | |
|----|----|----|
|名称|**说明**|备注|
|static|**静态变量（又称为类变量，其它的成为实例变量）**|可以被类的所有实例共享。并不需要创建类的实例就可以访问静态变量|
|final|**常量，值只能够分配一次，不能更改**|注意不要使用const,虽然它和C、C++中的const关键字含义一样，可以同static一起使用，避免对类的每个实例变量维护一个拷贝|
|transient|**告诉编译器，在类的对象序列化时，此变量不需要持久保存**|主要是因为改变变量可以通过其它变量来得到，使用它是为了性能的问题|
|**volatile**|指出可能有多个线程改变此变量，要求编译器优化以保证对变量的修改能够被正确处理||



方法修饰符

访问修饰符  修饰符 返回类型  方法名称(参数列表) throws 异常

﹟类的构造器方法不能够有修饰符、返回类型和throws子句

﹟类的构造方法被调用时，它首先调用父类的构造器方法，然后运行实例变量赋值，实例变量初始化器，然后才运行构造器本身。

﹟如果构造器方法没有显示的调用一个父类的构造器，那么编译器会自动为它加上一个默认的super(),而如果父类又没有默认的无参构造器，编译器就会报错，super必须是构造器方法的第一个子句。

﹟注意理解private构造器方法的使用技巧。
|**访问修饰符**| | |
|----|----|----|
|名称|说明|备注|
|public|可以从所有类访问||
|protected|可以被同一包中的所有类访问可以被所有子类访问|子类没有在同一包中也可访问|
|private|只能够被当前类的方法访问||
|缺省无访问修饰符||如果子类没有在同一个包中也不能访问|


|**修饰符**| | |
|----|----|----|
|名称|说明|备注|
|static|静态方法（又称为类方法，其它的成为实例方法）|提供不依赖于类实例的服务并不需要创建类的实例就可以访问静态方法|
|final|防止任何子类重载该方法|注意不要使用const,虽然它和C、 C++中的const关键字含义一样|
|abstract|抽象方法，类中已声明而没有类的实现的方法|不能将static方法，final方法或者类的构造器方法声明为abstract|
|native|用该修饰符定义的方法在类中没有实现，而大多数情况下该方法的实现是用C、C++编写的|参见Sun的[Java](http://lib.csdn.net/base/java)Native接口(JNI),JNI提供了运行时加载一个native 方法的实现，并将其于一个Java类关联的功能|
|synchronized|多线程的支持|当一个此方法被调用时，没有其他线程能够调用该方法，其它的synchronized的方法也不能调用该方法，直到该方法返回|



接口：

访问修饰符 interface 接口名称 extends 接口列表

﹟接口不能够定义其声明的方法的实现

﹟接口中的变量总是需要定义为 “public static final 变量名称”但可以不包含这些修饰符，编译器默认就是这样，显示的包含修饰符主要是为了程序清晰。
|访问修饰符| |
|----|----|
|名称|说明|
|public|所有|
|无访问修饰符（默认）|同一个包内|



