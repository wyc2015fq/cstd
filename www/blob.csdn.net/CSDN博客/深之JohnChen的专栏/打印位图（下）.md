# 打印位图（下）  - 深之JohnChen的专栏 - CSDN博客

2005年09月06日 11:35:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：1716



/*

HDC hDC,打印机dc

HBITMAP hBmp,待打印位图

int iX,位图的左上角点x坐标

int iY,位图的左上角点y坐标

double dScaleX,打印机分辨率和屏幕分辨率x方向的比值，在没有指定位图显示高度和宽度的时候用的上

double dScaleY,打印机分辨率和屏幕分辨率y方向的比值，在没有指定位图显示高度和宽度的时候用的上

int iWidth=0,位图的显示宽度

int iLength=0位图的显示高度

*/

void Draw(HDC hDC,HBITMAP hBmp,int iX,int iY,double dScaleX=1.0,double dScaleY=1.0,int iWidth=0,int iLength=0)

{

HPALETTE hPal;

BITMAPbm;

BITMAPINFOHEADERbi;

LPBITMAPINFOHEADER lpbi;

DWORDdwLen;

HANDLEhDIB;

HANDLEhandle;

HDC hDC1;

if(GetDeviceCaps(hDC,RASTERCAPS) & RC_PALETTE )

{

UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 256);

LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];

pLP->palVersion = 0x300;

pLP->palNumEntries =GetSystemPaletteEntries( hDC, 0, 255, pLP->palPalEntry );

hPal=CreatePalette(pLP );

delete[] pLP;

}

if (hPal==NULL)hPal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

::GetObject(hBmp,sizeof(bm),(LPSTR)&bm);

bi.biSize= sizeof(BITMAPINFOHEADER);

bi.biWidth= bm.bmWidth;

bi.biHeight = bm.bmHeight;

bi.biPlanes = 1;

bi.biBitCount= bm.bmPlanes * bm.bmBitsPixel;

bi.biCompression= BI_RGB;

bi.biSizeImage= 0;

bi.biXPelsPerMeter= 0;

bi.biYPelsPerMeter= 0;

bi.biClrUsed= 0;

bi.biClrImportant= 0;

int nColors = (1 << bi.biBitCount);

if( nColors > 256 )

nColors = 0;

dwLen= bi.biSize + nColors * sizeof(RGBQUAD);

hDC1 = ::GetDC(NULL);

hPal = SelectPalette(hDC1,hPal,FALSE);

RealizePalette(hDC1);

hDIB = GlobalAlloc(GMEM_FIXED,dwLen);

if (!hDIB)

{

SelectPalette(hDC1,hPal,FALSE);

::ReleaseDC(NULL,hDC1);

DeleteObject(hPal);

return ;

}

lpbi = (LPBITMAPINFOHEADER)hDIB;

*lpbi = bi;

::GetDIBits(hDC1, hBmp, 0L, (DWORD)bi.biHeight,

(LPBYTE)NULL, (LPBITMAPINFO)lpbi, (DWORD)DIB_RGB_COLORS);

bi = *lpbi;

if (bi.biSizeImage == 0)

bi.biSizeImage = ((((bi.biWidth * bi.biBitCount) + 31) & ~31) / 8)* bi.biHeight;

dwLen += bi.biSizeImage;

if (handle = GlobalReAlloc(hDIB, dwLen, GMEM_MOVEABLE))

hDIB = handle;

else

{

GlobalFree(hDIB);

SelectPalette(hDC1,hPal,FALSE);

::ReleaseDC(NULL,hDC1);

DeleteObject(hPal);

return ;

}

lpbi = (LPBITMAPINFOHEADER)hDIB;

BOOL bGotBits = GetDIBits( hDC1, hBmp,0L,(DWORD)bi.biHeight,(LPBYTE)lpbi+ (bi.biSize + nColors * sizeof(RGBQUAD)),

(LPBITMAPINFO)lpbi,(DWORD)DIB_RGB_COLORS);

if( !bGotBits )

{

GlobalFree(hDIB);

SelectPalette(hDC1,hPal,FALSE);

::ReleaseDC(NULL,hDC1);

DeleteObject(hPal);

return;

}

if(iWidth==0||iLength==0)

{

iWidth=lpbi->biWidth;

iLength=lpbi->biHeight;

iWidth=(int)(dScaleX*iWidth);

iLength=(int)(iLength*dScaleY);

}

StretchDIBits(hDC,iX,iY,iWidth,iLength,0,0,lpbi->biWidth,lpbi->biHeight,(LPBYTE)lpbi // address for bitmap bits

+ (bi.biSize + nColors * sizeof(RGBQUAD)),(LPBITMAPINFO)lpbi,DIB_RGB_COLORS,SRCCOPY);

SelectPalette(hDC1,hPal,FALSE);

::ReleaseDC(NULL,hDC1);

DeleteObject(hDIB);

DeleteObject(hPal);

}

// 附：得到一个DC位图的代码

HBITMAP GetSrcBit(HDC hDC,DWORD BitWidth, DWORD BitHeight)

{

HDC hBufDC;

HBITMAP hBitmap, hBitTemp;

hBufDC = CreateCompatibleDC(hDC);

hBitmap = CreateCompatibleBitmap(hDC, BitWidth, BitHeight);

hBitTemp = (HBITMAP) SelectObject(hBufDC, hBitmap);

StretchBlt(hBufDC, 0, 0, BitWidth, BitHeight,

hDC, 0, 0, BitWidth, BitHeight, SRCCOPY);

hBitmap = (HBITMAP) SelectObject(hBufDC, hBitTemp);

::DeleteDC(hBufDC);

return hBitmap;

}


