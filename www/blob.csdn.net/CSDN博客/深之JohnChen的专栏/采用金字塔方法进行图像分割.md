# 采用金字塔方法进行图像分割 - 深之JohnChen的专栏 - CSDN博客

2010年07月30日 19:43:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：6571


图像分割指的是将数字图像细分为多个图像子区域的过程，在OpenCv中实现了三种跟图像分割相关的算法，它们分别是：分水岭分割算法、金字塔分割算法以及均值漂移分割算法。

**分水岭分割算法**    分水岭分割算法需要您或者先前算法提供标记，该标记用于指定哪些大致区域是目标，哪些大致区域是背景等等；分水岭分割算法的分割效果严重依赖于提供的标记。OpenCv中的函数cvWatershed实现了该算法

**金字塔分割算法**    金字塔分割算法由cvPrySegmentation所实现，该函数的使用很简单；需要注意的是图像的尺寸以及金字塔的层数，图像的宽度和高度必须能被2整除，能够被2整除的次数决定了金字塔的最大层数

**均值漂移分割算法**    均值漂移分割算法由cvPryMeanShiftFiltering所实现，均值漂移分割的金字塔层数只能介于[1,7]之间

友情链接一下，个人感觉比较好的这方面博客：

[http://www.cnblogs.com/xrwang/archive/2010/02/28/ImageSegmentation.html](http://www.cnblogs.com/xrwang/archive/2010/02/28/ImageSegmentation.html)

效果图：

![](http://hiphotos.baidu.com/shentuhongfeng/pic/item/b320f3199cf6217c43a9ad86.jpg)

#include "cv.h"
#include "highgui.h"
#include <math.h>

IplImage* image[2] = { 0, 0 }, *image0 = 0, *image1 = 0;
CvSize size;

int w0, h0,i;
int threshold1, threshold2;
int l,level = 4;
int sthreshold1, sthreshold2;
int l_comp;
int block_size = 1000;
float parameter;
double threshold;
double rezult, min_rezult;
CvFilter filter = CV_GAUSSIAN_5x5;
CvConnectedComp *cur_comp, min_comp;
CvSeq *comp;
CvMemStorage *storage;

CvPoint pt1, pt2;

void ON_SEGMENT(int a)
{   
    cvPyrSegmentation(image0, image1, storage, &comp, 
                      level, threshold1+1, threshold2+1);

    /*l_comp = comp->total;

    i = 0;
    min_comp.value = cvScalarAll(0);
    while(i<l_comp)
    {
        cur_comp = (CvConnectedComp*)cvGetSeqElem ( comp, i );
        if(fabs(255- min_comp.value.val[0])>
           fabs(255- cur_comp->value.val[0]) &&
           fabs(min_comp.value.val[1])>
           fabs(cur_comp->value.val[1]) &&
           fabs(min_comp.value.val[2])>
           fabs(cur_comp->value.val[2]) )
           min_comp = *cur_comp;
        i++;
    }*/
    cvShowImage("Segmentation", image1);
}

int main( int argc, char** argv )
{
    char* filename = argc == 2 ? argv[1] : (char*)"fruits.jpg";
        if( (image[0] = cvLoadImage( filename, 1)) == 0 )
        return -1;
    cvNamedWindow("Source", 0);
    cvShowImage("Source", image[0]);

    cvNamedWindow("Segmentation", 0);

    storage = cvCreateMemStorage ( block_size );

    image[0]->width &= -(1<<level);
    image[0]->height &= -(1<<level);

    image0 = cvCloneImage( image[0] );
    image1 = cvCloneImage( image[0] );
    // 对彩色图像进行分割
    l = 1;
    threshold1 =255;
    threshold2 =30;

    ON_SEGMENT(1);

sthreshold1 = cvCreateTrackbar("Threshold1", "Segmentation", &threshold1, 255, 
ON_SEGMENT);
sthreshold2 = cvCreateTrackbar("Threshold2", "Segmentation", &threshold2, 255, 
ON_SEGMENT);

    cvShowImage("Segmentation", image1);
    cvWaitKey(0);

    cvDestroyWindow("Segmentation");
    cvDestroyWindow("Source");

    cvReleaseMemStorage(&storage );

    cvReleaseImage(&image[0]);
    cvReleaseImage(&image0);
    cvReleaseImage(&image1);

    return 0;
}

