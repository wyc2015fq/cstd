# 串口编程 - 深之JohnChen的专栏 - CSDN博客

2006年12月15日 20:19:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2995标签：[编程																[properties																[工具																[exception																[语言																[测试](https://so.csdn.net/so/search/s.do?q=测试&t=blog)](https://so.csdn.net/so/search/s.do?q=语言&t=blog)](https://so.csdn.net/so/search/s.do?q=exception&t=blog)](https://so.csdn.net/so/search/s.do?q=工具&t=blog)](https://so.csdn.net/so/search/s.do?q=properties&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)
个人分类：[VC](https://blog.csdn.net/byxdaz/article/category/7211574)


        串口编程的方式有两种:一种MSCOMM控件;二种[CSerialPort v1.21](http://www.naughter.com/download/serialport.zip)类.

        1、MSCOMM控件实例

        参考：[http://dev.yesky.com/231/2309731_1.shtml](http://dev.yesky.com/231/2309731_1.shtml)

       2、 [CSerialPort v1.21](http://www.naughter.com/download/serialport.zip)类

       参考：[http://www.naughter.com/serialport.html](http://www.naughter.com/serialport.html)

       // 打印控制 

 BYTE* pBuf = new BYTE[1000];
 memset(pBuf,0,1000);
 try
 {
  COMMCONFIG config;
  CSerialPort::GetDefaultConfig(1, config);

  CSerialPort port;
  port.Open(1, 9600, CSerialPort::NoParity, 8, CSerialPort::OneStopBit, CSerialPort::XonXoffFlowControl);

  HANDLE hPort = port.Detach();
  port.Attach(hPort);

  DWORD dwModemStatus;
  port.GetModemStatus(dwModemStatus);

  DCB dcb;
  port.GetState(dcb);

  dcb.BaudRate = 9600;
  port.SetState(dcb);    

  DWORD dwErrors;                      
  port.ClearError(dwErrors);

  port.SetBreak();
  port.ClearBreak();

  COMSTAT stat;
  port.GetStatus(stat);

  DWORD dwBytesWaiting = port.BytesWaiting();
  dwBytesWaiting;

  COMMTIMEOUTS timeouts;
  port.GetTimeouts(timeouts);

  port.Setup(1000, 1000);

  port.GetConfig(config);

  config.dcb.BaudRate = 9600;
  port.SetConfig(config);

  port.Set0WriteTimeout();
  port.Set0ReadTimeout();  

  DWORD dwMask;
  port.GetMask(dwMask);

  port.SetMask(EV_TXEMPTY); 

  //port.WaitEvent(dwMask);

  port.TerminateOutstandingWrites();

  // port.TransmitChar('p');

  port.Set0Timeout(); // 0超时
  /*
  // 1秒超时
  COMMTIMEOUTS Timeouts;
  GetTimeouts(Timeouts);
  Timeouts.WriteTotalTimeoutMultiplier = 1000;
  Timeouts.WriteTotalTimeoutConstant = 1000;
  port.SetTimeouts(Timeouts);
        */

  // 打印文本

  str = "/x1bl/x1cK/x1bn/x1bQ225/x1bZ/x1b./x07/x1bj"; //初始化打印机信息
  char sBuf[1000];
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  Sleep(2000);
  // 读取返回值，判断是否处于OLIVETTI打印状态
  char sRxBuf[10];
  memset(sRxBuf,0,10);
  port.Read(sRxBuf,10);
  port.TerminateOutstandingReads();

int iQueryTime = 0;
  while(!(sRxBuf[0]==27 && sRxBuf[1]==114 && sRxBuf[2]==80))
  {
     iQueryTime++;
   if(iQueryTime<=3)
   {
    str = "/x1b/x30"; //总清,打印机软复位
    memset(sBuf,0,1000);
    memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
    port.Write(sBuf, (DWORD) strlen(sBuf));

    str = "/x1bn/x1bQ225/x1bZ/x1b."; //初始化打印机
    memset(sBuf,0,1000);
    memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
    port.Write(sBuf, (DWORD) strlen(sBuf)); 

    str = "/x1bj"; //查询状态 
    memset(sBuf,0,1000);
    memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
    port.Write(sBuf, (DWORD) strlen(sBuf));    
    Sleep(1000);
    // 读取返回值，判断是否处于OLIVETTI打印状态
    memset(sRxBuf,0,10);
    port.Read(sRxBuf,10);
    port.TerminateOutstandingReads();
    MessageBox("请放打印纸张！");
    Sleep(2000);
   }
            else
   {
    MessageBox("请选择OLIVETTI PR2E打印机！");
    str = "/x1b/x30"; //总清
    memset(sBuf,0,1000);
    memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
    port.Write(sBuf, (DWORD) strlen(sBuf));

    str = "/x1b/x25/x41"; //置位PORT A [BP8901 默认为PORT A]
    memset(sBuf,0,1000);
    memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
    port.Write(sBuf, (DWORD) strlen(sBuf));

    port.ClearDTR();

    port.ClearRTS();

    port.SetDTR();

    port.SetRTS();

    port.SetXOFF();

    port.SetXON();

    COMMPROP properties;
    port.GetProperties(properties);

    port.ClearWriteBuffer();

    port.ClearReadBuffer();

    port.Flush();

    port.Close();
    return;
   }

  }

  str = "/x1c/x26"; //设置中西文兼容格式
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1bL015"; //绝对垂直位置
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1bH005"; //绝对水平位置
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  CString strText1 = "AAAAAAAAAAAAAAAAAAAAAAAA";
  str = strText1; 
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1bL016"; //绝对垂直位置
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1bH005"; //绝对水平位置
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  CString strText2 = "BBBBBBBBBBBBBBBBBBBBBBBBBBBBB";
  str = strText2; 
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1c/x2e"; //设置取消中西文兼容格式
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  str = "/x1bO"; //退纸
  memset(sBuf,0,1000);
  memcpy(sBuf,str.GetBuffer(str.GetLength()),str.GetLength());
  port.Write(sBuf, (DWORD) strlen(sBuf));

  port.ClearDTR();

  port.ClearRTS();

  port.SetDTR();

  port.SetRTS();

  port.SetXOFF();

  port.SetXON();

  COMMPROP properties;
  port.GetProperties(properties);

  port.ClearWriteBuffer();

  port.ClearReadBuffer();

  port.Flush();

  port.Close();

 }
 catch (CSerialException* pEx)
 {
  TRACE(_T("Handle Exception, Message:%s/n"), pEx->GetErrorMessage());
  pEx->Delete();
 }

 delete [] pBuf;

 // 说明
/x1bl        清错
/x1bn/x1bQ080/x1bZ/x1b.                     初始化打印机
/x1bj                 主机询问打印机状态
/x07                  声音提示
/x1b J004        设置左边界为４个字符
x1b&85　　　设置行距为８５／２４０英寸或者８５／２１６英寸
/x1b<　　　　设置打印字距为１０字符／英寸
/x1bUc　　　打印机进纸控制

// 串口调式工具下载：[http://download.it168.com/07/0705/07051.shtml](http://download.it168.com/07/0705/07051.shtml)

  SUDT SerialTrace 是一款用于侦听、拦截、记录、分析RS232/422/485串行接口通信协议的专业软件。它适用于串行口相关的软硬件开发、测试工程师。

  SUDT SerialTrace 可以让您对串行口的命令和数据进行全方位的侦听、拦截、保存，为日后的数据导入、仿真、分析提供了便利。

  SUDT SerialTrace 为用户提供了仿真功能，双击拦截到的读写数据，即可被自动复制到仿真终端的发送窗口，便于用户修改以及模拟测试。

  SUDT SerialTrace 支持串行中继功能，利用计算机的两个串口分别与两台设备互联，可拦截两台设备间的通信信息。

  SUDT SerialNull 是一款虚拟串口的专业配置工具，主要用于模拟RS232串口的虚拟连接，适用于串行口相关的软硬件开发、测试工程师。

  SUDT SerialNull 可以在不占用真实串口的情况下，创建任意数量并互为连接的纯虚拟串口对。

  SUDT SerialNull 在系统中所创建的虚拟串口在功能以及使用上与真实物理串口一致。

  SUDT SerialRemap 是一款专业的串口映射（重定向）工具，允许将指定的物理串口或虚拟串口的数据映射（重定向）到本工具所创建的虚拟串口。例如：系统中存在com9 (该串口为物理串口或虚拟串口) ，但是串口应用程序仅支持com1-com4，此时可以使用SerialRemap创建一个端口号在com1-com4之间的虚拟串口，该虚拟串口会自动将数据映射（重定向）到com9。SerialRemap 在系统中所创建的虚拟串口在功能以及使用上与真实物理串口一致。

[**AccessPort 串口调试器**](http://www.sudt.com/cn/ap/index.html)**（免费软件）**
|![](http://www.sudt.com/cn/ap/images/bullet_ball_red.gif)|**强大的数据拦截功能**可以将指定端口的数据流、控制流信息拦截并保存下来，供分析之用。如察看端口状态的变化（波特率、数据位、校验位、停止位），拦截上行、下行的数据，处理速度快，拦截效率高。|
|----|----|
|![](http://www.sudt.com/cn/ap/images/bullet_ball_red.gif)|**简单、易用的数据调试功能**简洁的界面布局，高度易用的设计，支持手动发送、自动发送、传输文件、后台接收数据等功能，各种操作一目了然。|
|![](http://www.sudt.com/cn/ap/images/bullet_ball_red.gif)|**调试过程中可动态改变端口参数**在不改变当前端口的前提下，可以动态的修改指定参数，如：波特率、数据位、校验位、停止位、流控制等，增强了调试的灵活性。|
|![](http://www.sudt.com/cn/ap/images/bullet_ball_red.gif)|**十六进制、字符形式－－双模式切换功能**数据接收区、发送区都具有UtralEdit的双模式切换功能，便于数据的编辑以及显示，全面支持Unicode，解决了编辑和显示时十六进制、字符形式难于相互切换的难题。|
|![](http://www.sudt.com/cn/ap/images/bullet_ball_red.gif)|**多国语言支持，国际版本**目前支持简体中文、繁体中文、英文三种语言，国际化的设计使得程序很容易实现语言本地化|

[http://www.sudt.com](http://www.sudt.com)


