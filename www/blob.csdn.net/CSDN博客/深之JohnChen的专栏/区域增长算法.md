# 区域增长算法 - 深之JohnChen的专栏 - CSDN博客

2006年05月24日 17:23:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：4184


**区域增长算法**

                                                                                                             cndg

       区域增长的算法实现: 1)根据图像的不同应用选择一个或一组种 子,它或者是最亮或最暗的点,或者是位 于点簇中心的点 2...通过像素集合的区域增长算法实现: 区域A 区域B 种子像素增长.3)增长的规则 4)
结束条件.

BOOL RegionGrow(int nSeedX, int nSeedY, BYTE * pUnchInput,int nWidth, int nHeight, BYTE * pUnRegion,CRect &R)
{

  int nDx[] = {-1,1,0,0};
  int nDy[] = {0,0,-1,1};
 int nSaveWidth = nWidth;

 // 定义堆栈，存储坐标
 int * pnGrowQueX ;
 int * pnGrowQueY ;

 // 分配空间
 pnGrowQueX = new int [nWidth*nHeight];
 pnGrowQueY = new int [nWidth*nHeight];

 // 定义堆栈的起点和终点
 // 当nStart=nEnd, 表示堆栈中只有一个点
 int nStart ;
 int nEnd ;

 //初始化
 nStart = 0 ;
 nEnd = 0 ;

 // 把种子点的坐标压入栈
 pnGrowQueX[nEnd] = nSeedX;
 pnGrowQueY[nEnd] = nSeedY;

 // 当前正在处理的象素
 int nCurrX ;
 int nCurrY ;

 // 循环控制变量
 int k ;

 // 图象的横纵坐标,用来对当前象素的8邻域进行遍历
 int xx;
 int yy;

 while (nStart<=nEnd)
 {
  // 当前种子点的坐标
  nCurrX = pnGrowQueX[nStart];
  nCurrY = pnGrowQueY[nStart]; 

  // 对当前点的4邻域进行遍历
  for (k=0; k<4; k++) 
  { 
   // 4邻域象素的坐标
   xx = nCurrX+nDx[k];
   yy = nCurrY+nDy[k];

   // 判断象素(xx，yy) 是否在图像内部
   // 判断象素(xx，yy) 是否已经处理过
   // pUnRegion[yy*nWidth+xx]==0 表示还没有处理

   // 生长条件：判断象素(xx，yy)和当前象素(nCurrX,nCurrY) 象素值差的绝对值
   if ( (xx < nWidth) && (xx>=0) && (yy>=0) && (yy<nHeight) 
   && (pUnRegion[yy*nWidth+xx]==0) && (pUnchInput[yy*nSaveWidth+xx]==1)) 
   {
    // 堆栈的尾部指针后移一位
    nEnd++;

    // 象素(xx，yy) 压入栈
    pnGrowQueX[nEnd] = xx;
    pnGrowQueY[nEnd] = yy;

    // 把象素(xx，yy)设置成逻辑1（255）
    // 同时也表明该象素处理过
    pUnRegion[yy*nWidth+xx] = 255 ;
   }
  }
  nStart++;
 }

 //找出区域的范围
    int nMinx=pnGrowQueX[0], nMaxx=pnGrowQueX[0], nMiny=pnGrowQueY[0], nMaxy = pnGrowQueY[0];
    for (k=0; k<nEnd; k++)
 {
        if (pnGrowQueX[k] > nMaxx)
             nMaxx = pnGrowQueX[k];
       if (pnGrowQueX[k] < nMinx) 
            nMinx = pnGrowQueX[k];
       if (pnGrowQueY[k] > nMaxy)
            nMaxy = pnGrowQueY[k];
       if (pnGrowQueY[k] < nMiny) 
           nMiny = pnGrowQueY[k];
 }

    if ((nMaxy - nMiny) > 40 && (nMaxx - nMinx) > 40)
 {
    R.left = nMinx;
    R.right = nMaxx;
    R.top = nMiny;
    R.bottom = nMaxy;
       return TRUE;
 }
    // 释放内存
 delete []pnGrowQueX;
 delete []pnGrowQueY;
 pnGrowQueX = NULL ;
 pnGrowQueY = NULL ;
 return FALSE;
}

//调用方法
void OnButton(LPBYTE S,int ImageWidth,int ImageHeight)
{
 int i=0,j=0;
CRect rect;
 LPBYTE lpFlag = new BYTE[ImageWidth*ImageHeight];
 memset(lpFlag,0,ImageWidth*ImageHeight);
 for (i=0; i<ImageHeight; i++)
 {
  for (j=0; j<ImageWidth; j++)
  {
   if (S[i*ImageWidth+j] == 1 && lpFlag[i*ImageWidth+j] == 0)
   {
    RegionGrow(j, i, S, ImageWidth, ImageHeight, lpFlag,rect);
   }
  }

 }

 if(lpFlag!=NULL)
 {
  delete []lpFlag;
  lpFlag = NULL;
 }
}

