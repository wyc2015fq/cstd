# 游戏外挂的原理 - 深之JohnChen的专栏 - CSDN博客

2005年11月28日 13:27:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：3316


                游戏外挂已经深深地影响着众多网络游戏玩家,今天在网上看到了一些关于游戏外挂编写的技术,于是转载上供大家参考
1、游戏外挂的原理 

　　外挂现在分为好多种，比如模拟键盘的，鼠标的，修改数据包的，还有修改本地内存的，但好像没有修改服务器内存的哦，呵呵。其实修改服务器也是有办法的，只是技术太高一般人没有办法入手而已。（比如请GM去夜总会、送礼、收黑钱等等办法都可以修改服务器数据，哈哈）

　　修改游戏无非是修改一下本地内存的数据，或者截获API函数等等。这里我把所能想到的方法都作一个介绍，希望大家能做出很好的外挂来使游戏厂商更好的完善自己的技术。我见到一篇文章是讲魔力宝贝的理论分析，写得不错，大概是那个样子。下来我就讲解一下技术方面的东西，以作引玉之用。

　　2 技术分析部分

　　2.1 模拟键盘或鼠标的响应

　　我们一般使用：

　　UINT SendInput(
　　　　UINT nInputs,　　 // count of input events
　　　　LPINPUT pInputs,　// array of input events
　　　　int cbSize　　　　// size of structure
　　);
　　API函数。第一个参数是说明第二个参数的矩阵的维数的，第二个参数包含了响应事件，这个自己填充就可以，最后是这个结构的大小，非常简单，这是最简单的方法模拟键盘鼠标了，呵呵。注意，这个函数还有个替代函数：

　　VOID keybd_event(
　　　　BYTE bVk,　　　　　　　// 虚拟键码
　　　　BYTE bScan,　　　　　　// 扫描码
　　　　DWORD dwFlags,
　　　　ULONG_PTR dwExtraInfo　// 附加键状态
　　);
　　与

　　VOID mouse_event(
　　　　DWORD dwFlags,　　　　　 // motion and click options
　　　　DWORD dx,　　　　 　　　 // horizontal position or change
　　　　DWORD dy,　　　　　　　　// vertical position or change
　　　　DWORD dwData,　　　　　　// wheel movement
　　　　ULONG_PTR dwExtraInfo　　// application-defined information
　　);
　　这两个函数非常简单了，我想那些按键精灵就是用的这个吧。上面的是模拟键盘，下面的是模拟鼠标的。这个仅仅是模拟部分，要和游戏联系起来我们还需要找到游戏的窗口才行，或者包含快捷键，就象按键精灵的那个激活键一样，我们可以用GetWindow函数来枚举窗口，也可以用Findwindow函数来查找制定的窗口（注意，还有一个FindWindowEx），FindwindowEx可以找到窗口的子窗口，比如按钮，等什么东西。当游戏切换场景的时候我们可以用FindWindowEx来确定一些当前窗口的特征，从而判断是否还在这个场景，方法很多了，比如可以GetWindowInfo来确定一些东西，比如当查找不到某个按钮的时候就说明游戏场景已经切换了，等等办法。有的游戏没有控件在里面，这是对图像做坐标变换的话，这种方法就要受到限制了。这就需要我们用别的办法来辅助分析了。

　　至于快捷键我们要用动态连接库实现了，里面要用到hook技术了，这个也非常简单。大家可能都会了，其实就是一个全局的hook对象然后SetWindowHook就可以了，回调函数都是现成的，而且现在网上的例子多如牛毛。这个实现在外挂中已经很普遍了。如果还有谁不明白，那就去看看MSDN查找SetWindowHook就可以了。

　　不要低估了这个动态连接库的作用，它可以切入所有的进程空间，也就是可以加载到所有的游戏里面哦，只要用对,你会发现很有用途的。这个需要你复习一下Win32编程的基础知识了。呵呵，赶快去看书吧。

　　2.2 截获消息

　　有些游戏的响应机制比较简单，是基于消息的，或者用什么定时器的东西。这个时候你就可以用拦截消息来实现一些有趣的功能了。

　　我们拦截消息使用的也是hook技术，里面包括了键盘消息，鼠标消息，系统消息，日志等，别的对我们没有什么大的用处，我们只用拦截消息的回调函数就可以了，这个不会让我写例子吧。其实这个和上面的一样，都是用SetWindowHook来写的，看看就明白了很简单的。

　　至于拦截了以后做什么就是你的事情了，比如在每个定时器消息里面处理一些我们的数据判断，或者在定时器里面在模拟一次定时器，那么有些数据就会处理两次，呵呵。后果嘛，不一定是好事情哦，呵呵，不过如果数据计算放在客户端的游戏就可以真的改变数据了，呵呵，试试看吧。用途还有很多，自己想也可以想出来的，呵呵。

　　2.3 拦截Socket包

　　这个技术难度要比原来的高很多。

　　首先我们要替换WinSock.DLL或者WinSock32.DLL，我们写的替换函数要和原来的函数一致才行，就是说它的函数输出什么样的，我们也要输出什么样子的函数，而且参数，参数顺序都要一样才行，然后在我们的函数里面调用真正的WinSock32.DLL里面的函数就可以了。

　　首先：我们可以替换动态库到系统路径。

　　其次：我们应用程序启动的时候可以加载原有的动态库，用这个函数LoadLibary然后定位函数入口用GetProcAddress函数获得每个真正Socket函数的入口地址。

　　当游戏进行的时候它会调用我们的动态库，然后从我们的动态库中处理完毕后才跳转到真正动态库的函数地址，这样我们就可以在里面处理自己的数据了，应该是一切数据。呵呵，兴奋吧，拦截了数据包我们还要分析之后才能进行正确的应答，不要以为这样工作就完成了，还早呢。等分析完毕以后我们还要仿真应答机制来和服务器通信，一个不小心就会被封号。

　　分析数据才是工作量的来源呢，游戏每次升级有可能加密方式会有所改变，因此我们写外挂的人都是亡命之徒啊，被人愚弄了还不知道。

　　2.4 截获API

　　上面的技术如果可以灵活运用的话我们就不用截获API函数了，其实这种技术是一种补充技术。比如我们需要截获Socket以外的函数作为我们的用途，我们就要用这个技术了，其实我们也可以用它直接拦截在Socket中的函数，这样更直接。

　　现在拦截API的教程到处都是，我就不列举了，我用的比较习惯的方法是根据输入节进行拦截的，这个方法可以用到任何一种操作系统上，比如Windows 98/2000等，有些方法不是跨平台的，我不建议使用。这个技术大家可以参考《Windows核心编程》里面的545页开始的内容来学习，如果是Win98系统可以用“Windows系统奥秘”那个最后一章来学习。 

