# 图像识别初探 - 深之JohnChen的专栏 - CSDN博客

2006年03月01日 13:24:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：13688


目录

1 前言. 1

1.1 植物的发展史. 1

1.1.1 植物界的类群及多样性. 1

1.1.2 植物的分类等级. 2

1.2植物的识别方法. 3

1.2.1 花与种子的特性. 3

1.2.2 叶子的特征. 3

1.3 什么是数字图像处理. 5

1.3.1 数字图像处理概念及其意义. 5

1.3.2 数字图像处理中的基本图像类型. 6

1.3.3 图像格式分析. 7

1.4 什么是模式识别. 8

1.4.1 模式识别的概念. 8

1.4.2 模式识别研究方向. 9

1.4.3 模式识别在实际中的应用. 10

2 预处理与算法研究. 10

2.1 图像的预处理. 10

2.2 数字图像处理方法. 11

2.2.1 二值处理. 11

2.2.2 模糊模式识别算法. 12

2.2.3 边缘检测与轮廓提取. 12

3.2.4 信息存储. 14

3 算法实现. 14

3.1 分析实际工作过程. 14

3.2 算法实现过程. 15

3.2.1 掏空内部点算法的基本思想. 15

3.2.2 边界跟踪算法的基本思想. 15

3.2.3 部分实现代码. 18

4 小结分析. 25

5 参考文献. 26

6 致谢. 27

1 前言
1.1 植物的发展史
1.1.1 植物界的类群及多样性
植物界的发生和发展经历了漫长的历史，随着地球历史的发展，由原始生物不断演化，其间大约经历了30亿年，有的种族由兴盛到衰亡，新的种类又在进化中产生，形成地球上现存的已知的约50多万种植物。植物种类的繁多，数量浩瀚，是生物圈的重要组成部分[4]。

植物对人类生活已经济生活有极其重要的作用，衣、食、住、行、医药及工业品等都与植物的生产利用密不可分，因此植物是最重要的生产对象，也是重要的研究对象。

植物的分布极为广泛，几乎可以说自然界处处都有着植物。而且在形态结构上表现出多种多样，有肉眼看不见的单细胞的原始低等植物，也有分化程度很高、由多细胞组成的、结构复杂的树木花草。根据不同植物的特征以及它们的进化关系

其中种子植物是现今地球上种类最多、形态构造最复杂、和人类经济活动最密切的一类植物。全部树木、农作物和绝大多数的经济植物都是种子植物。种子植物从形态构造到生活习性等各方面同样表现了极其不同的多样性。

    为了能更好的运用植物与识别植物，对植物的分类与识别，越来越体现出其重要性。因此产生了植物分类学的说法，植物分类学是研究植物类群的分类、探索植物间的亲缘关系和阐明植物界自然系统得科学。植物分类对于区分植物种类，探索植物间亲缘关系，阐明植物系统得进化规律具有很重要的意义。

1.1.2 植物的分类等级
前面讲了植物分类的基本单位是种，根据亲缘关系把共同性比较多的一些种归纳成属（Genus），再把共同性较多的一些属归纳成科（Familia），如此类推而成目（order）、纲（C1assis）和门（Division）。因此植物界（Plantae）从上到下的分类等级顺序为门、纲、目、科、属、种。在各分类等级之下根据需要建立亚级分类等级，如亚门（Subdivision）、亚纲（Subclassis）、亚目（Suborder）、亚科（Subfamilia）和亚属（Subgenus）。

种以下的分类等级则根据该类群与原种性状的差异程度分为亚种（Subspecies）、变种（Varietas）和变型（Forma）。亚种比变种包括的范围更广泛一些，除了在形态上有显著的区别外，而且在地理分布上也有一定的区域性。变种又比变型在形态上的差异要大一些。实际分类工作中要根据野外调查的资料和标本的特征经过综合研究分析方能确定。

各分类等级的具体名称（如种子植物门、被子植物亚门、双子叶植物纲等）的拉丁文名称常有固定的词尾，可供识别，如种子植物门（Spermatophyta）的词尾为-ta，亚门为-ae，纲为-eae，目为-ales，科为-aceae；科名的拉丁名词尾一般是-aceae，但是也有少数例外，如唇形科Labatae，菊科Compositae，禾本科Graminae。

因此对植物进行有效的识别，是目前植物界很重要的问题。

1.2植物的识别方法
1.2.1 花与种子的特性
一朵完全的花由花柄、花托、花萼、花冠、雄蕊和雌蕊六部分组成。花萼由萼片组成,花冠由花瓣组成。花萼和花冠合称花被,是花的外层部分,有保护雄蕊和雌蕊的作用。雌蕊和雄蕊合称花蕊,是花的主要部分。一个雄蕊由花丝和花药组成。花丝着生在花托上。花丝顶端着生花药。花药中有花粉囊,里面包有花粉。一个雌蕊由子房、花柱和柱头组成。

种子是由种皮、胚和胚乳三部分组成。种皮为种子的最外层，具有保护作用。种皮上有脐和种孔。

我们可以根据花和种子的形态，以及内部的不同组成来区分植物，但是由于此次主要运用的是图像识别的方法。因此，不考虑通过花和种子来识别植物

1.3 什么是数字图像处理
1.3.1 数字图像处理概念及其意义
所谓数字图像处理[7]就是利用计算机对图像信息进行加工以满足人的视觉心理或者应用需求的行为。实质上是一段能够被计算机还原显示和输出为一幅图像的数字码。

21世纪是一个充满信息的时代，图像作为人类感知世界的视觉基础，是人类获取信息、表达信息和传递信息的重要手段。

数字图像处理[9]，即用计算机对图像进行处理，其发展历史并不长。数字图像处理技术源于20世纪20年代，当时通过海底电缆从英国伦敦到美国纽约传输了一幅照片，采用了数字压缩技术。首先数字图像处理技术可以帮助人们更客观、准确地认识世界，人的视觉系统可以帮助人类从外界获取3/4以上的信息，而图像、图形又是所有视觉信息的载体，尽管人眼的鉴别力很高，可以识别上千种颜色，但很多情况下，图像对于人眼来说是模糊的甚至是不可见的，通过图象增强技术，可以使模糊甚至不可见的图像变得清晰明亮。另一方面，通过数字图像处理中的模式识别技术，可以将人眼无法识别的图像进行分类处理。通过计算机模式识别技术可以快速准确的检索、匹配和识别出各种东西。

数字图像处理技术已经广泛深入地应用于国计民生休戚相关的各个领域。

1.3.2 数字图像处理中的基本图像类型
在计算机中，按照颜色和灰度的多少可以将图像争为二值图像、灰度图像、索引图像和真彩色RGB图像四种基本类型。目前，大多数图像处理软件都支持这四种类型的图像。

(1) 二值图像：

一幅二值图像的二维矩阵仅由0、1两个值构成，“0”代表黑色，“1”代白色。由于每一像素（矩阵中每一元素）取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别（OCR）和掩膜图像的存储。

(2) 灰度图像：

灰度图像矩阵元素的取值范围通常为[0，255]。因此其数据类型一般为8位无符号整数的（int8），这就是人们经常提到的256灰度图像。“0”表示纯黑色，“255”表示纯白色，中间的数字从小到大表示由黑到白的过渡色。在某些软件中，灰度图像也可以用双精度数据类型（double）表示，像素的值域为[0，1]，0代表黑色，1代表白色，0到1之间的小数表示不同的灰度等级。二值图像可以看成是灰度图像的一个特例。

(3) 索引图像：

索引图像的文件结构比较复杂，除了存放图像的二维矩阵外，还包括一个称之为颜色索引矩阵MAP的二维数组。MAP的大小由存放图像的矩阵元素值域决定，如矩阵元素值域为[0，255]，则MAP矩阵的大小为256ⅹ3，用MAP=[RGB]表示。MAP中每一行的三个元素分别指定该行对应颜色的红、绿、蓝单色值，MAP中每一行对应图像矩阵像素的一个灰度值，如某一像素的灰度值为64，则该像素就与MAP中的第64行建立了映射关系，该像素在屏幕上的实际颜色由第64行的[RGB]组合决定。也就是说，图像在屏幕上显示时，每一像素的颜色由存放在矩阵中该像素的灰度值作为索引通过检索颜色索引矩阵MAP得到。索引图像的数据类型一般为8位无符号整形（int8），相应索引矩阵MAP的大小为256ⅹ3，因此一般索引图像只能同时显示256种颜色，但通过改变索引矩阵，颜色的类型可以调整。索引图像的数据类型也可采用双精度浮点型（double）。索引图像一般用于存放色彩要求比较简单的图像，如Windows中色彩构成比较简单的壁纸多采用索引图像存放，如果图像的色彩比较复杂，就要用到RGB真彩色图像。

(4) RGB彩色图像：

RGB图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红（R）、绿（G）、蓝（B）三原色的组合来表示每个像素的颜色。但与索引图像不同的是，RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个M x N的二维矩阵分别表示各个像素的R、G、B三个颜色分量。RGB图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像，当然也可以存放灰度图像。

1.3.3 图像格式分析
　　数字化图像数据有两种存储方式[6]：位图存储(Bitmap)和矢量存储(Vector)
我们平常是以图像分辨率（即象素点）和颜色数来描述数字图象的。例如一张分辨率为640*480,16位色的数字图片，就由2^16=65536种颜色的307200(=640*480)个素点组成。

　　位图图像：位图方式是将图像的每一个象素点转换为一个数据，当图像是单色（只有黑白二色）时，8个象素点的数据就占据一个字节（一个字节就是8个二进制数，1个二进制数存放象素点）；16色的图像每两个象素点用一个字节存储；256色图像每一个象素点用一个字节存储。这样就能够精确地描述各种不同颜色模式的图像图面。位图图像弥补了矢量式图像的缺陷，它能够制作出色彩和色调变化丰富的图像，可以逼真地表现自然界的景象，同时也可以很容易地在不同软件之间交换文件，这就是位图图像的优点；而其缺点则是它无法制作真正的3D图像，并且图像缩放和旋转时会产生失真的现象，同时文件较大，对内存和硬盘空间容量的需求也较高。位图方式就是将图像的每一像素点转换为一个数据。如果用1位数据来记录，那么它只能代表2种颜色（21=2）；如果以8位来记录，便可以表现出256种颜色或色调(28=256)，因此使用的位元素越多所能表现的色彩也越多。通常我们使用的颜色有16色、256色、增强16位和真彩色24位。一般所说的真彩色是指24位(28×28×28)的位图存储模式适合于内容复杂的图像和真实照片。但随着分辨率以及颜色数的提高，图像所占用的磁盘空间也就相当大；另外由于在放大图像的过程中，其图像势必要变得模糊而失真，放大后的图像像素点实际上变成了像素“方格”。 用数码相机和扫描仪获取的图像都属于位图。

　　矢量图像：矢量图像存储的是图像信息的轮廓部分，而不是图像的每一个象素点。例如，一个圆形图案只要存储圆心的坐标位置和半径长度，以及圆的边线和半径长度，以及圆的边线和内部的颜色即可。该存储方式的缺点是经常耗费大量的时间做一些复杂的分析演算工作，图像的显示速度较慢；但图像缩放不会失真；图像的存储空间也要小得多。所以，矢量图比较适合存储各种图表和工程设计图。

1.4 什么是模式识别
1.4.1 模式识别的概念
模式识别[8]是一种从大量信息和数据出发，在专家经验和已有认识的基础上，利用计算机和数学推理的方法对形状、模式、曲线、数字、字符格式和图形自动完成识别的过程。模式识别包括相互关联的两个阶段，即学习阶段和实现阶段，前者是对样本进行特征选择，寻找分类的规律，后者是根据分类规律对未知样本集进行分类和识别。广义的模式识别属计算机科学中智能模拟的研究范畴，内容非常广泛，包括声音和语言识别、文字识别、指纹识别、声纳信号和地震信号分析、照片图片分析、化学模式识别等等。计算机模式识别实现了部分脑力劳动自动化。

模式识别－－对表征事物或现象的各种形式的（数值的，文字的和逻辑关系的）信息进行处理和分析，以对事物或现象进行描述、辨认、分类和解释的过程，是信息科学和人工智能的重要组成部分。

模式还可分成抽象的和具体的两种形式。前者如意识、思想、议论等，属于概念识别研究的范畴，是人工智能的另一研究分支。我们所指的模式识别主要是对语音波形、地震波、心电图、脑电图、图片、文字、符号、三位物体和景物以及各种可以用物理的、化学的、生物的传感器对对象进行测量的具体模式进行分类和辨识。

模式识别问题指的是对一系列过程或事件的分类与描述，具有某些相类似的性质的过程或事件就分为一类。模式识别问题一般可以应用以下4种方法进行分析处理。

统计模式识别方法：统计模式识别方法是受数学中的决策理论的启发而产生的一种识别方法，它一般假定被识别的对象或经过特征提取向量是符合一定分布规律的随机变量。其基本思想是将特征提取阶段得到的特征向量定义在一个特征空间中，这个空间包含了所有的特征向量，不同的特征向量，或者说不同类别的对象都对应于空间中的一点。在分类阶段，则利用统计决策的原理对特征空间进行划分，从而达到识别不同特征的对象的目的。统计模式识别中个应用的统计决策分类理论相对比较成熟，研究的重点是特征提取。

人工神经网络模式识别：人工神经网络的研究起源于对生物神经系统的研究。人工神经网络区别于其他识别方法的最大特点是它对待识别的对象不要求有太多的分析与了解，具有一定的智能化处理的特点。

句法结构模式识别：句法结构模式识别着眼于对待识别对象的结构特征的描述。

在上述4种算法中，统计模式识别是最经典的分类识别方法，在图像模式识别中有着非常广泛的应用。

1.4.2 模式识别研究方向
    模式识别研究主要集中在两方面，即研究生物体（包括人）是如何感知对象的，属于认知科学的范畴，以及在给定的任务下，如何用计算机实现模式识别的理论和方法。前者是生理学家、心理学家、生物学家和神经生理学家的研究内容，后者通过数学家、信息学专家和计算机科学工作着近几十年来的努力，已经取得了系统的研究成果。

　　一个计算机模式识别系统基本上事有三部分组成的[11]，即数据采集、数据处理和分类决策或模型匹配。任何一种模式识别方法都首先要通过各种传感器把被研究对象的各种物理变量转换为计算机可以接受的数值或符号（串）集合。习惯上，称这种数值或符号（串）所组成的空间为模式空间。为了从这些数字或符号（串）中抽取出对识别有效的信息，必须对它进行处理，其中包括消除噪声，排除不相干的信号以及与对象的性质和采用的识别方法密切相关的特征的计算（如表征物体的形状、周长、面积等等）以及必要的变换（如为得到信号功率谱所进行的快速傅里叶变换）等。然后通过特征选择和提取或基元选择形成模式的特征空间。以后的模式分类或模型匹配就在特征空间的基础上进行。系统的输出或者是对象所属的类型或者是模型数据库中与对象最相似的模型编号。针对不同应用目的，这三部分的内容可以有很大的差别，特别是在数据处理和识别这两部分，为了提高识别结果的可靠性往往需要加入知识库（规则）以对可能产生的错误进行修正，或通过引入限制条件大大缩小待识别模式在模型库中的搜索空间，以减少匹配计算量。在某些具体应用中，如机器视觉，除了要给出被识别对象是什么物体外，还要求出该物体所处的位置和姿态以引导机器人的工作。

1.4.3 模式识别在实际中的应用
模式识别[5]已经在天气预报、卫星航空图片解释、工业产品检测、字符识别、语音识别、指纹识别、医学图像分析等许多方面得到了成功的应用。所有这些应用都是和问题的性质密切不可分的，至今还没有发展成统一的、有效的可应用于所有的模式识别的理论。当前的一种普遍看法是不存在对所有的模式识别问题都使用的单一模型和解决识别问题的单一技术，我们现在拥有的是一个工具袋，我们所要做的是结合具体问题把统计的和句法（结构）的识别方法结合起来，把统计模式识别或句法模式识别与人工智能中的启发式搜索结合起来，把人工神经元网络与各种以有技术以及人工智能中的专家系统，不确定方法结合起来，深入掌握各种工具的效能和应用的可能性，互相取长补短，开创模式识别应用的新局面。

2 预处理与算法研究
2.1 图像的预处理
    首先多找几种形态各异的叶子，通过数码相机获取到某个叶子的平面图形，为了避免一些外界干扰信息，在做这些预处理时，把叶子平铺在白色背景的纸上。使得到的图片尽量保持叶子的完整形状。图像的预处理工作有很多，除噪声，抗干扰等等，因此首先我们得对图像进行一些必要的预处理，以免为后面的工作带来不必要的麻烦，预处理的好坏直接影响到图像处理工作，当然最好的预处理就是没有预处理。

2.2 数字图像处理方法
2.2.1 二值处理
二值化[7]是预处理中最关键的步骤，因为它直接产生能够被分合算法使用的二值化图像。可以说，二值化结果的好坏决定了分合算法结果的好坏，从而决定了叶子轮廓定位能否成功。

二值化的方法举不胜举[10]，但都可以分为取全局阈值的二值化和取局部阈值的二值化两大类。

取全局阈值的二值化方法中，有一种叫做“组内方差最小化方法”，由Otsu于1979年提出。它的思路是，最好的阈值应该使得被阈值分开的两组的方差的加权和达到最小，其中某组的加权系数就是该组的概率（其实就是该组像素数目占总像素数目的比例）。

设所有像素被阈值t分为两组，灰度≤t的称作组1，灰度>t的称作组2；σ12(t)，σ22(t)是1组和2组各自的方差；q1(t)，q2(t)是1组和2组各自的概率；μ1(t)，μ2(t)是1组和2组各自的灰度平均值。定义组内方差σW2(t)为这两个组的方差的加权和：

所有像素的平均灰度和方差记做μ和σ2。有下面的关系式成立：

这个全局取阈值方法常常可以得到不错的效果。非常适合叶子定位的应用。但是这样对轮廓的提取还是有点不大好做，所以我以组内方差最小化方法为基础，构造了一种局域取阈值的方法。其思路是：首先对整幅图像用组内方差最小化方法求出阈值，并记录下组间方差。然后把整幅图像划分为m×n个正方形，每个正方形边长都为十几个像素量级。对每个正方形的子图像按组内方差最小化方法求出一个阈值和一个组间方差。最后某一个正方形子图像二值化所使用的阈值是由全局阈值和局域阈值，以全局组间方差和局域组间方差作为权重，再加上事先指定的加大全局阈值权重的因子，综合计算出来。显然全局阈值应该占到绝大部分的比重，因为正方形子图内的像素分部可能与全局分布极不相同，甚至出现全是单一灰度的极端情形。如果仅仅用子图的像素分布来决定子图使用的阈值，那么各个子图取的阈值就会各自相差很大，导致结果图像零乱破碎，无法使用。

该局域取阈值二值化方法有边界效应的缺陷。所谓边界效应，是指由于相邻两个正方形子图所取阈值不同，造成边界两边本来灰度变化缓慢的像素有可能一边被二值化成黑色，一边被二值化成白色，形成突变。

2.2.2 模糊模式识别算法
模糊模式识别：模糊识别的理论基础是模糊数学。从识别模式的识别过程来讲, 模糊模式识别的方法可以分为两种: 直接方法和间接方法. 直接方法按最大隶属原则归类, 间接方法按择近原则归类。

模糊模式识别[12]的直接方法：

设U 为全体被识别对象的集合, A～1 , A～2 ,⋯, A～n 是论域U 的n 个模糊子集(模糊模式) .现在要对一个确定的对象u0 ∈ U 进行识别.此时模式A～1 ⋯A～n 是模糊的, 但是具体的对象u0 是清楚的, 这时要用“ 最大隶属原则”归类.最大隶属原则:设A～1 , A～2 , ⋯, A～n 是论域U 上的n 个模糊子集, u0 是U 的固定元素,若μA～i( u0) = max (A～1( u0) ,μA～2( u0) ⋯μA～n( u0) ) 则认为u0 相对隶属于模糊子集A～i这种直接由计算元素的隶属函数来判断具体对象归属的方法即为模糊模式识别的直接方法, 其效果显然依赖于建立模式隶属函数的技巧.建立隶属函数，模糊模式识别的直接方法的首要问题是确定隶属函数。合理地确定出隶属函数常采用模糊统计、模糊分析, 经验评分等方法, 隶属函数要经过检验, 并在检验中加以调整, 以提高识别的有效性.

2.2.3 边缘检测与轮廓提取
边缘检测是图像处理中的重要内容,边缘是图像的最基本特征.所谓边缘就是指周围像素灰度有阶跃变化或屋顶变化的那些像素的集合.Poggoi等在论文中说：“边缘或许对应着图像中物体（的边界）或许并没用对应着图像中物体（的边界），但是边缘具有十分令人满意的性质，它能大大地减少所要处理的信息但是又保留了图像中物体的形状信息。”并定义边缘检测为“主要是（图像的）灰度变化的度量、检测和定位”。边缘与图像中物体的边界有关但又是不同的[3]。边缘反映的是图像灰度的不连续性[13]。

    缘是指周围像素灰度有阶跃变化或屋顶变化的那些像素的集合。Poggio等在[42]中说：“边缘或许对应着图像中物体（的边界）或许并没用对应着图像中物体（的边界），但是边缘具有十分令人满意的性质，它能大大减少索要处理的信息但是又保留了图像中物体的形状信息”。

常见的边缘点有3种。第一种是阶梯形边缘（Step-edge)，即从一个灰度到比它高好多的另一个灰度。第二种是屋顶型边缘（Roof-edge）它的灰度是慢慢增加到一定程度然后慢慢减少。还有一种是线性边缘（Line-edge)，它的灰度从一个级别跳到另一个灰度级别之后然后回来。

边缘在边界检测、图像分割、模式识别、机器视觉等中有很重要的作用。

边缘是边界检测的重要基础，也是外形检测的基础。边缘广泛存在于物体与背景之间、物体与物体之间，基元与基元之间，因此它也是图像分割所依赖的重要特征。

边缘检测对于物体的识别也是很重要的。主要有以下几个理由：首先人眼通过追踪未知物体的轮廓（轮廓是由一段段的边缘片段组成的）而扫视一个未知的物体。第二，经验告诉我们：如果我们能够成功地得到图像的轮廓，那么图像分析就会大大简化，图像识别就会容易很多。第三，很多图像并没有具有的物体，对这些图像的理解取决于它们的纹理性质，而提取这些纹理性质与边缘检测有极其密切的关系。

计算机视觉处理可以看作是为了实现某一个任务从包含有大量的不相关的变量中抽取不变量，总之就是简化信息。这就意味着要扔掉一些不必要的信息而尽可能理由物体的不变性质。而边缘就是最重要的不变性质：光线的变化显著地影响了一个区域的外观，但是不会改变它的边缘。更重要的是人的视觉系统也是对边缘很敏感的。

边缘检测的方法主要有以下几种：

第一种检测梯度的最大值。由于边缘发生在图像灰度变化比较大的地方，对应连续情形就是说函数梯度较大的地方，所以研究比较好的求导算子就成为一种思路。Roberts算子、Prewitt算子和Soble算子等就是比较简单而常用的例子。还有一种比较直观的方法就是利用当前像素领域中的一些像素值拟合一个曲面，然后求这个连续曲面在当前像素处梯度。从统计角度来说，我们可以通过回归分析得到一个曲面，然后也可以做类似的处理

第二种是检测二阶导数的零交叉点。这是因为缘处的梯度取得最大值（正的或者负的），也就是灰度图像的拐点是边缘。从分析学上我们知道，拐点处函数的二阶导数是0。

第三种，统计型方法。比如说利用假设检验来检测边缘。

第四种，小波多尺度边缘检测。 

一些经典的边缘检测的算法包括：梯度算子、Sobel算子、Kirsh算子、Laplacian算子、Marr算子。

3.2.4 信息存储
在把图像信息提取出来以后，为了以后能很好的比较为作为一个模版信息库，就得把图像信息存储起来，由于图片的格式各不同，因此在选择图像格式时也有一定的要求，由上面的图片格式分析得出，BMP位图是最适合为图像处理时应用的图形格式工程应用中经常要处理256级的灰度BMP图像，如通过黑白采集卡采集得到的图像。BMP灰度图像作为Windows环境下主要的图像格式之一，以其格式简单，适应性强而倍受欢迎。

3 算法实现
3.1 分析实际工作过程
首先，我们要做的是将叶子进行灰度处理，灰度处理要用到它的极端形式，也就是我们说的二值化处理了，接着就是对经过处理的二值图进行边缘检测，提取它的轮廓，然后将其信息存储到信息库里保存起来。在比较时，也就是对刚才的过程进行反操作。

3.2 算法实现过程
3.2.1 掏空内部点算法的基本思想
    掏空内部点的算法很简单，首先得到图像的黑白二值图，得到的图像设黑色为0，白色为1。然后我们首先按从上往下，从左往右现在找到其第一个黑点，也就是0点，然后找其点的8个方位的点，每个点都与0点相比较，如果所有值都相等，那么这个点就为此图的内部点，就去掉此点信息，将此点的值设为1，然后重新寻找新的内部点，如果不是所有的都相等，那么直接寻找下一个点信息。

3.2.2 边界跟踪算法的基本思想
一个边界上的像素可以用一个通路来遍历，并且总可以为这一遍历选择一条封闭的通路。本文采用的边缘提取算法是一种特定对边界进行自动跟踪的遍历形式1。用N-近邻的概念，对N的数值运算都假定为模8运算。N近邻有两种类型，一是直接近邻，即两个像素的相应单元共有一条边。一是非直接近邻，即两个像素相应单元仅在一个角上相接触。

算法描述：

设定:F是边界点集合R的初始点，N是其近邻被检查的当前点。S是用图6中编码所表示的。

搜索方向START是一个标志，当跟踪开始时为真，FOUND也是一个标志，当找到边界上的下一点时为真。

1)选边界上一点F，

2)将当前点N置为F，搜索方向S置为6，标志START置为TRUE。

3)当N与F不同或标志START为TRUE时，做4)～11)步。

4)Begin置标志FOUND为FALSE。

5)While　FOUND为FALSE时，做6)～10)步。

　　Begin　搜索(S-1)

6)If　N的(S-1)-近邻B是在R内，then

　　Begin

7)置N为B，S为S–2。置FOUND为TRUE。

　End

8)Else

　　Begin

　　　IF　N的S-近邻B是在R内,then

　　　　置N为B，同时置FOUND为TRUE。

9)ELSE

　　Begin

　　　IF　N的(S+1)-近邻是在R内，then

　　　置N为B，并置FOUND为TRUE。

10)Else将S增加2。

　　　End

　　　End

11)置START为FALSE。

　　End

12)算法结束。

本算法以封闭的通路来遍历。如果不是封闭的通路，该算法也总是按封闭的通路来遍历。比如一条线段AB，该算法实现的时候，是从A遍历到B，在B点又回到A，也形成一个封闭的通路，这时起点和终点相同，算法结束。现以图6为例说明本算法。 

1)选定边界上具有代表性的8个点组成边界集合R={A, B, C, D, E, F, G, H}，如图7a假定它是图像的边界线，图中箭头指向为下一边界点的方向(按图6 的编码方向)。设定A为遍历边界的起始点。

2)当前点A，搜索S = 6 方向，标志START = TRUE。

3)A有8个方向，根据本算法，首先判断A 的(S - 1) = 5这个方向的点是否为边界点, 其结果为否; 再判断A 的S = 6 方向的点, 它也不是边界点再判断( S + 1) = 7 方向的点，它正是边界点B ，那么置FOUND = TRUE ，表明找到边界点。 然后再沿着这一点继续找下一边界点，开始下一轮循环

4)对B点，先判断B 的(S - 1) = 5 这个方向的点是否为边界点，其结果为否; 再判断B 的S = 6 方向的点，它是边界点C。 这时置FOUND = TRUE ，结束本次循环，不再判断其它方向，开始找C 的下一边界点。 如图7b ;

5)在C 点，第一次判断(S - 1) = 5 这个方向的点就是边界点D ，此时需置S = S - 2 = 6 - 2 =4 ，搜索方向改变了。 同样置FOUND = TURE。 如图7c ;

6)对于D 点，同样先判断(S - 1) 这个方向，但此时方向已经改变了，(S - 1) = 4 - 1 = 3 ，此方向上的点不是边界点，再检查S = 4 方向，此方向的E 点是边界，FOUND = TRUE如图7d ;

7) E 点第一次判断(S - 1) = 3 这个方向，就找到边界点F ，又置S = S - 2 = 4 - 2 = 2 ，搜索方向再一次改变，FOUND = TRUE。 如图7e ;

8) 在F 点，判断(S - 1) = 1 方向的点，不是边界点，再判断S = 2 方向，G正是边界点，置FOUND = TRUE1 如图7f ;

9) 在G点，判断(S - 1) = 1 方向的点，H 是边界点，置S = S - 2 = 0 ，FOUND = TRUE1 如图7g ;

10) 在H 点，判断(S - 1) = - 1 ，本算法对N - 近邻规定为模8 运算，因此- 1 模8运算后为7 ，这个方向的点非边界点，再判断S = 0 的点，A 点正是这个方向的边界点，终点和起点相同,算法结束

3.2.3 部分实现代码
首先读取叶子图像信息[1]

　　if(this.openFileDialog.ShowDialog()==DialogResult.OK)

           {

              bmp=new Bitmap(this.openFileDialog.FileName);

              bmp2=new Bitmap(this.openFileDialog.FileName);

              bmp3=new Bitmap(this.openFileDialog.FileName);

              bmp4=new Bitmap(this.openFileDialog.FileName);

              bmp5=new Bitmap(this.openFileDialog.FileName);

              this.pictureBox1.Image=bmp;

              pictureBox1.Visible=true;

           }

接着对叶子进行灰度处理，我们先不对其进行二值处理可以看到以下结果

       for(int i=0;i

           {

              for(int j=0;j

              {

                  Color Color1=bmp.GetPixel(i,j);

                  int red=Convert.ToInt32((30*Color1.R+59*Color1.G+11*Color1.B)/3);

                  bmp2.SetPixel(i,j,Color.FromArgb(red,red,red));

              }      

              }

           this.pictureBox2.Image=bmp2;

由此我们可以看出，只进行一般的灰度处理并没能达到我们下一步进行轮廓提取的要求[2]，因为，图片的信息还很朦胧，图像像素之间的色差还不明显，因此，在此基础上，我们改进下，直接对其进行了二值化处理，其算法改进如下：

for(int i=0;i

                     {

                            for(int j=0;j

                            {

                                   Color Color1=bmp.GetPixel(i,j);

                                   int red=Convert.ToInt32((Color1.R+Color1.G+Color1.B)/3);

                                   if(red>128)   //如果大于128将其设为白色255

                                          //精确灰度处理算法 0.3*R+0.59*G+0.11*B 

                                          //优化算法(30*R+59*G+11*B)/100

                                          red=255;   

                                   else 

                                          red=0;

                                   bmp2.SetPixel(i,j,Color.FromArgb(red,red,red));

                    将图片信息暂时填充到内存中      

                            }            

                     }

此时，我们得到了一个像素色差非常大的图，为下一步进行轮廓的提取提供了很有利的条件，在轮廓提取方面，根据模式识别书上提供的一些算法。

掏空内部点的算法： 

for(int i=1;i

                            {

                                   for(int j=1;j

                                   {

                                          Color Color0=bmp2.GetPixel(i,j);

                                          Color Color1=bmp2.GetPixel(i,j-1);

                                          Color Color2=bmp2.GetPixel(i-1,j);

                                          Color Color3=bmp2.GetPixel(i+1,j);

                                          Color Color4=bmp2.GetPixel(i,j+1);

                                          int red;

                                          if(Color0.B==0)

                                          {

       if(Math.Abs(Color1.R-Color0.R)==0&&

Math.Abs(Color2.R-Color0.R)==0&&

Math.Abs(Co  lor3.R-Color0.R)==0&&

Math.Abs(Color4.R-Color0.R)==0)

                                                        red=255;

                                                 else 

                                                        red=0;

                                                 CountBmp+=1;

                                          }

                                          else

                                                 red=255;

                                          bmp3.SetPixel(i,j,Color.FromArgb(red,red,red));

图10 掏空算法结果

其中if语句就是判断某个点的周围4个点是不是都是黑点，原思路用了比较8个点。

4 小结分析
1) 对于使用第一种掏空内部点的算法，其好处是算法比较简单，容易实现，但是由于处理时的for循环比较多，经常要重复使用，因此耽搁了处理时间，只适合处理比较小的图片，这一部分还得进一步的加强改进。另外由于这个算法的局限性，它只是掏空所在图形中所有与其余8点相同的点，所以没有考虑到图形的完整边缘，因此，如果取二值图时，叶子图形内部出现白色空点时，还是被处理为一个新的轮廓，这样提取出来的轮廓就不仅仅是叶子的轮廓，还有一点白色空点被读取进来了。

2) 对于使用第二种边界跟踪的算法，是对边界上某一点的8个方向进行搜索，必能在一个方向上找到边界上与之相邻的下一点，一旦找到，设一标志，并记录搜索到的本边界点的方向，以便沿此方向搜索下一点1本算法以3个方向为一组来对边界上某一点的8个方向进行检测的，如图6，8个方向分四组{5，6，7},{3，4，5}，{1，2，3}，{7，0，1}1先搜索6方向。

(1).若在6方向上找到边界点，那么继续沿着此方向找; 

(2).若在5方向找到边界点，下次改变方向，在第二组{3，4，5}方向找其它的点1 同理，每组中在第一个方向上5，3，1，7找到边界点，都改变方向，以提高下一边界点的搜索速度。

(3).若5，6，7方向都没找到，那么边界的走向是向上的，本算法就沿着(7，0，1)，(1，2，3)，(3，4，5)，(5，6，7)方向搜索。

与第一种算法比较起来本算法执行速度快，效率高，对边界点的提取能按着边界的走向及时调整方向自动搜索，而且不会出现向边界相反的方向查找的可能，也就不会出现图像二值处理不完美时，带来图片内部的空点被识别进去，极大的减少了误差的出现。

随着国家信息化进程的加速，图像识别的应用需求将越来越广泛，因此应当加强这方面的研究工作。应用系统的性能的关键与瓶颈仍然在图像识别核心算法性能上，最终目标是研究零误识率和低拒识率的高速识别算法

5 参考文献
[1] 刘洪成编著．C# 高级编程学习捷径．北京：清华大学出版社，2003年．

[2] Karli Watso, Marco Bellinaso 等著．康博译．C#入门经典：第16章 GDI+简介．北京：清华大学出版社，2002年4月．

[3] H.M.Deitel, P.J.Deitel, J.Listfield, T.R.Nieto, C.Yaeger, M.Zlatkina著．葛昊晗，汤涌涛，李强等译．Ｃ#大学教程：第16章 图形和多媒体．北京：清华大学出版社，2003年11月．

[4] 曹慧娟主编．植物学．北京：中国林业出版社，1992年4月．

[5] 王士同主编．人工智能教程．北京：电子工业出版社，2001年10月.

[6] 林福宗主编．图像文件格式大全．北京：清华大学出版社，1998年．

[7] 霍宏涛主编．数字图像处理．北京：北京理工大学出版社，2002年9月．

[8] 边肇祺，张学工等编著. 模式识别(第二版）. 北京：清华大学出版社，2000．

[9] 张宏林，蔡锐编著．Visual C++数字图像模式识别技术及工程实践．人民邮电出版社发行，2003年1月.

[10] 陈辉编著．二值图并序交互细化方法．山东工业大学学报，1997年7月．

