# 几种图像处理库的研究 - 深之JohnChen的专栏 - CSDN博客

2009年03月09日 12:19:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：19134



### 几种图像处理库的研究

目前比较出名的图像处理库有很多，比如LEADTOOLS，这个是功能非常强大的图像多媒体库，但是这个是收费注册的。开源的图像库也有不少，比如：ImageStone、GIMP、CxImage等，虽然它们的功能没有LEADTOOLS强大，但是一般的图像处理是可以应付的。

下面分别介绍这几种图像处理库的使用方法。

### LEADTOOLS

### LEAD Technologies 是一个拥有九年多开发数字图形技术历史的公司，他专为程序开发者提供软件开发工具包。他已经为微软等公司提供了很多图形图象技术。这个软件包是该公司开发的开发工具的集合，包括占线帮助，Lead API、C++ 类库、ActiveX 控件、VCLs 和一些实例原代码等。这个软件包是开发工具的集合包括占线帮助，Lead API、C++ 类库、ActiveX 控件、VCLs 和一些实例原代码等。

(1)对显示设备的全面支持：在显示时，你的程序中无需考虑是哪种显示模式，如16色还是真彩色。LeadTools为你做了所有的事。当然你也可以通过设置参数获得对显示设备更多的控制。你还可以实现自己的调色板。

(2)支持多种文件格式：表10.1是LeadTools所支持的常用文件格式，其中读表示用LeadTools能打开的文件格式，写表示LeatTools能存成的文件格式：

(3)图象处理：如二值化、平滑、加噪声、增加对比度、色调、饱和度、亮度、Gamma校正、中值滤波、半影调、抖动、橡皮筋、滚动、填充、反色、镜象、马赛克、浮雕、打印、扫描、拷贝、粘贴、裁剪、缩放、截屏、调色板、直方图、有关数据库的操作、还有制作幻灯的功能，如淡入、淡出、卷帘等等、真的很爽。表10.2是Version5.1的所有属性、事件、和方法列表，看看有没有你所需要的功能。以字母顺序排列，其中标[P]的表示只有专业级(Professional)和特殊级(Express)用户才能使用。

(4) 新增功能：

Vector的新功能

Annotations的新对象和新功能

OCR Module 更新

新增模块：ICR Module

新增模块：OMR Module (Forms 处理) 

新增的公共图象对话框

100余种图象处理功能

DjVu® ，KDC和其他的新格式支持

Medical Imaging 更新

Multimedia 更新

C++ Class Lib 更新

COM Object 更新，包含新的.NET 示例

相关包的破解地址：[http://www.greatcracks.com/cracked_software/l4](http://www.greatcracks.com/cracked_software/l4)

相关开发包介绍：

LEADTOOLS Medical Imaging SDK

LEADTOOLS Medical Imaging包含了一些精心挑选的、经过优化的特性，可以满足医疗成像应用程序开发的特殊需要，比如，完全的DICOM数据集支持，可以支持8-16位灰度级，以及12和16位的图像处理，窗位(Window Leveling)显示，还包含LUT处理。

特征综述

支持8、10、12、16灰度级和24位图像，包括JPEG（8、10、12、16位无损灰度级，8、12位有损灰度级，24位无损和有损色彩），JPEG2000（包括有损和无损8-16位灰度级图像和24位色彩）行程，无压缩，光学表示（单色1、单色2、调色板、RGB、ARGB、CMYK、YBR 全422、YBR全、YBR_RCT、YBR_ICT），以及单框架和多框架图像。

完全支持DICOM 3（2003文件规范），包括所有标准的IOD类和形态（CR、CT、MR、NM、US、RF、SC、VL等），还包含VR’s。

为DICOM的基本目录提供简单的执行操作和完全技术支持。只需要几行代码就可以使用高级COM对象来创建DICOMDIR。

通过调用一个函数，可以将一种转移语法变为另一种转移语法。自动识别DICOM文件（Little-Endian/Big-Endian，隐藏/显示VR等等）。并具有高级和低级函数，可用于数据集的简单导航和操作（插入、删除、修改）。

单框架或多框架的图像（压缩的或未压缩的）。

对大量不同厂商的硬件支持。

包含了可使用的源代码和可执行代码。

对DICOM有4个不同的编程接口－API、COM、VCL、C++类库。支持DICOM2003标准中所有的VR’s，包括“其它浮动字符串”。

具有高级和低级函数，可用于数据集的简单导航和操作（插入、删除、修改）。

LEADTOOLS自动加入了项定界项和序列定界项以简化数据集的嵌套（VR of “SQ”）。

易于对项进行顺序定位（FFFE，E000）。

简化了重组处理（多重覆盖和曲线数据）。

支持对单框架或多框架压缩或未压缩图像的像素数据的封装或本机编码。　
DICOMLUT/Overlay/Palette支持。在LEADTOOLS Medical Imaging中，对于Modality 

LUT，VOI LUT，Palette色彩图像的高级支持意味着开发人员可以毫不费力地在一个应用程序中实现DICOM表示状态。LEADTOOLS还可以将Modality LUT应用于图像数据，以进一步简化图像处理和统计计算。

DICOM注释对象支持。可以从数据集内存储／获取DICOM注释，并且将它们转换为LEAD注释对象，反之亦然。为了附加的统计计算和存储为DICOM表示状态，注释也可以被转换为Region of interest。
Cookie剪切工具：可以从一个放射性图像扫描文件中提取出单独的薄片（对于识别一个扫描MRI或CT系列内的每个薄片很有帮助）。

MRI大脑分析工具：可以用于计算胼胝体（大脑中部的白色物质，就像字母X）和脑球体之间的比率。

LEADTOOLS Multimedia

您可以使用LEADTOOLS Multimedia SDK创建具有专业水准的高品质的多媒体应用程序。该控件中加入了诸如捕获、播放和编辑等多媒体功能以及对最新的DirectShow过滤和许多多媒体文件格式的支持，即可以加载和转换多种文件格式（包括WAV、AVI、ASF、WMA、WMV、MPEG-1、OGG等等）。可以编程控制多媒体处理、压缩，视频和音频输入；还增加了摄像控制（亮度、对比度、缩放等等）；以及更灵活的捕获选项等等更多功能。

特征综述 About Feature

**多媒体捕获**
能够从WDM、本地DirectShow包括DV、Windows视频捕获设备中捕获视频图像，还可以控制DV设备等。

**多媒体播放**
能够播放所有DirectShow所支持的文件。可以支持DVD导航，还可以将播放设置保存到文件或二进制流中等等。

**多媒体转换**
利用控件包提供的功能，您的用户可以将多媒体文件在AVI，Windows Media content，WAVE和MPEG1 Audio（MP3）格式之间互相转换，还可以选择DV设备输出等等功能。

**多媒体文件格式**
支持大部分流行的多媒体格式（AVI、ASF、WMV、WAV、OGG、MPEG-2、MPG）。点击此处可以得到一个所支持格式的列表。

**多媒体压缩**
通过可用的DirectShow过滤器压缩多媒体文件（内存中进行）。（Windows Media）

**多媒体处理**
具有处理AVI、Windows Media content、WAVE和MPEG1Audio（MP3）格式或DirectShow过滤器捕获到的数据的能力。在电影回放、转换或被捕获时可以使用LEAD Video callback DirectShow过滤器中的200种像处理功能来处理电影。

**DirectShow****过滤器**
LEADTOOLS Multimedia包含了一个多媒体过滤器包的测试版，这个多媒体过滤器包具有强大的多媒体处理功能。

**产品演示**
LEADTOOLS Multimedia具有一些演示程序，可以帮助您开发您的项目。其中有音频、视频检测demo，音频更换demo，Mediainfo demo等等。

### LEADTOOLS Raster Imaging SDK

LEADTOOLS Raster Imaging SDK是为开发者提供的用于创建功能强大的图像应用程序工具；采用LEADTOOLS的色彩转换、显示、压缩（JPEG、TIFF、CCITT G4 以及LEAD的CMP属性）、图象处理、TWAIN扫描、特效（超过2000种）、图像格式支持(超过150种图像文件格式)、打印、Internet/intranet 图像、数据库图像、图像公共对话框和屏幕捕获等特性，使用它，由此为你节省大量的时间与费用。

特征综述 About Feature

**文件格式支持**
采用工业标准和专有压缩技术，可同时支持150多种图像文件格式以及sub-格式的加载、保存和转换。另外，采用LEADTOOLS能添加更多的格式支持，例如采用LEADTOOLS PDF插件，即能实现对PDF文件的加载、保存和转换支持。

**压缩支持**
支持多种工业标准的压缩技术，包括JPEG、CCITT、LZW （使用于GIF及某些TIFF文件）、ZIPLIB （使用于PNG文件）、Huffman算法、RLE及紧缩位压缩算法（Packbits）。另外，采用LEADTOOLS JPEG2000 插件和 LEADTOOLS CMW 插件可添加JPEG2000 及先进的CMW压缩技术。

**TWAIN****扫描支持**
TWAIN 驱动几乎包含在所有的扫描仪及其它图像采集设备中，同时随着最新的发展技术，TWAIN 也是性能良好与高可靠性驱动的最佳选择。当前LEADTOOLS 的光栅图像产品支持所有包括在TWAIN v1.9 规范中的功能。

**屏幕捕获**
具有强大的屏幕捕获功能，能从文件、菜单、窗口、不同形状的屏幕客户区域等捕获资源。屏幕捕获工具是极其有用的，特别是在文档编辑及需提供其它图像输入方式的时显得更为重要。

**数据库支持**
同时提供高端或低端的数据库支持，其中包括绑定VB数据控件功能、OLEDB 接口、ODBC 接口以及低端加载和保存图像到内存的功能。

**Internet ****支持**
提供几种不同级别Internet支持，包括：可封装到CAB文件的对象、能在web服务器端构造的对象、从URL或存储器装载图像的功能、支持HTTP 和FTP的控件、解析并加载到web服务器端的文件控件，以及用来构造功能强大、通过TCP/IP发送远程过程调用的客户服务器应用程序控件。

**显示与显示效果**
对图像如何被显示进行完全地控制，包括缩放、展开、图像显示的区域控制以及超过2000种的特效效果。LEADTOOLS 甚至包含了一个平铺窗口，这样你能方便地显示图像概要及选用适合最终用户的卷起、平铺方案。

**打印支持**
由于能使用与显示图像同样的代码来进行打印，所以打印图像与显示图像同样容易。你能控制图像打印的尺寸和位置；另外，能结合Windows GDI函数同LEADTOOLS打印一起使用，提供在同一页上打印文本和多个图像的灵活性。

**图像处理**
超过200种图象处理功能，分为四个基本类别：过滤、变换、色彩转换及绘图。在LEADTOOLS中的大多数图像处理功能支持不同着重区域，允许图像的某一部份被处理。通过添加更多用于数字绘图的功能，LEAD在LEADTOOLS Raster Imaging Pro中提供了包含大量用于数字绘图功能，包括笔刷、形状、纹理的创建与使用以及更多。

**色彩转换**
为确保你能把图像从一种格式转换到另一种格式，或是在任何其它显示设备上显示图象，LEADTOOLS 包含了强大的色彩转换功能。该色彩转换功能包括：支持8 种以上色彩平滑过渡算法、多种调色板选项以及把图像数据从任何支持的每个像素所占用的位转换到其他支持的每个像素所占用的位功能。支持的数值有1-8位色或灰度、16位色、24 位色和32 位色。如果你需要12或16位灰度或48与64位色支持。

**图像公共对话框**
LEADTOOLS 图像公共对话框通过扩展Windows公共对话框以提供具体的图像处理功能，节省了大量的繁琐编程时间，同时能给最终用户提供一个一致的外观和感觉。这个公共对话框针对图像处理、变换及特效提供专业的图像公共对话框功能。

LEADTOOLS Vector Imaging Pro

LEADTOOLS Vector Imaging Pro控件包含了创建功能强大的，支持矢量和光栅图像格式的2-D和3-D浏览器、编辑器、转换器的一切所需要求。通过创建这样的应用程序，您不需要安装或注册一些更昂贵的用于创建矢量文件的原始程序，您只需添加您所需要的功能。如果您在为矢量成像寻找具有最丰富特色的软件开发工具包时，LEADTOOLS Vector Imaging Pro也许是您最好的选择。

特征综述 About Feature

**支持矢量图像格式**
矢量图像可以被加载、保存、转换和输出为光栅图像格式，包括CGM、DGN、DRW、DWF、DXF、EMF、WMF、PLT、Gerber、PCL、PCT、SVG、VWPG、CMX和SHP。

**支持原始对象**
支持原始对象，包括圆弧、位图、笔刷、照相机、圆、复制、椭圆、椭圆弧、字体、组、层、线、笔、饼、弦、Poly Draw、多边形、多边线、Poly Bezier、光栅、长方形、文本、顶点和Clipping对象。

**支持浏览和编辑**
具有低级和高级函数，可以控制矢量图像的浏览，包括缩放（统一的或围绕任何轴线）、移动镜头、旋转（围绕任何轴线）和抗失真。矢量图形可以以任何希望的方式编辑，包括添加、修改、删除和将对象复制到粘贴板或者复制到各个不同的矢量图形中。

**支持打印**
可以把矢量图形缩小到任何分辨率而不会使图形出现扭曲，这样就可以确保在打印时，图形细节不会丢失。

**支持矢量转换**
不需要创建文件的原始程序就可以将矢量文件转换为另一种格式。

**支持光栅图像**
矢量文件可以被转换为任何分辨率的光栅图像，并且可以被保存为LEADTOOLS Raster Imaging 产品支持的任何150种图像文件格式。

LEADTOOLS 软件开发工具包也包括了常见的光栅成像特色包括图像处理（转换、过滤、绘制、Region of Internet），色彩转换，显示，特效（从2000多种效果中选出的），压缩，图像格式（导入/导出），打印，Internet/Intranet成像，数据库成像，成像对话框和屏幕捕获。

**LEADTOOLS****现在还支持****Unicode****编码**
为了向大量的开发人员提供矢量成像功能，控件包提供了5个编程接口：低层次的API、C++类库，以及易于使用但功能强大的ActiveX、COM、VCL控件。LEADTOOLS Vector Imaging Pro带有示例源代码，适用于Visual Basic, C/C++, Visual C++ (MFC), C++ Builder, Visual J++, Visual FoxPro, Access, Delphi, and VB and JavaScript，并且支持Visual Studio 6.0数据库连接（Oracle, SQL, OLE DB, ODBC和JET）。

LEADTOOLS Barcode Module

LEADTOOLS Barcode Module产品允许程序员很容易地在应用软件中加入编码，这样就可以读写Linear（1D）、DataMatrix (2D)、PDF417(2D)和QR编码的条形码——包括对41种不同子类型的支持。LEADTOOLS Barcode Modules还加入了LEADTOOLS文档和医学图像工具包。

特征综述 About Feature

Barcode Modules :
设计Linear (1D), DataMatrix (2D), PDF 417 (2D)和QR Code (2D) 条形码样式

可以在任何方向上读出多个条形码。

可以将条形码写入任何超过150种图像文件格式或者写入任何服从窗口的打印机。

利用2D条形码技术，每个条形码符号可用数以千计的字符来编码。

可以从选定目标区域内读出或写入条形码。

可以读出指定颜色的条形码。

可以写入指定颜色的条形码。

使LEADTOOLS的广泛的图像处理技术一体化，以便完全控制用户的条形码识别过程。

下表列出了每个模块的特点：

读取/写入1D Symbols条形码

高级的/标准的

自动条形码类型检测。

从目标区域读出或者写入条形码。

可以从不同的方向读出，比如从左到右，从右到上，对角线方向等等。

读取倾斜的条形码符号。

可以读出多个条形码符号。

可以读出混合的条形码类型，并以x/y的形式来返回报告。

可以写入条形码符号，条形码符号带有大小和位置参数。

可以检验字符处理。

读取/写入2D DataMatrix条形码
包括差错检测码（ECC），能够修复被破坏的条形码符号。

读出或者写入彩色和灰色的条形码。

可以在一个条形码符号中存储多达2218个ASCII字符，还可以把符号串接起来，用多达33225个字符对其编码。

（读取模块）可以读出条形码，条形码是独立于歪斜失真、方向和取向改变之外的。从目标区域读出条形码，条形码包含在任何支持的图像文件格式中（支持类型超过150种），并可从扫描仪或者数字照相机获取。

（写入模块）可以写入任何支持的光栅格式（超过150种）到目标区域，也可以打印到任何支持Windows的打印机上。

读出/写入2D PDF 417 条形码
可以在一个条形码符号种存储多达1815个ASCII字符。

包括了差错检测码（ECC），能够修复被破坏的条形码符号。

（读取模块）可以读出条形码，条形码是独立于歪斜失真、方向和取向改变之外的。从目标区域读出条形码，条形码包含于任何支持的图像文件格式中（支持类型超过150种），并可从扫描仪或者数字照相机获取。

（写入模块）可以写入任何支持的光栅格式（超过150种）到目标区域，也可以打印到任何支持Windows的打印机上。

读出/写入2D QR Code Modules
可以从ALPHA或者数字文本中创建QR编码的条形码符号。

包含差错检测码（ECC），它可以排除可能出现的被破坏的读出数据。

可以在一个条形码符号中存储多达2335个ASCII字符。

可以使用差错检测码（ECC）来修复被破坏的条形码符号。

可以读出独立于歪斜的、定位的、取向改变和反射之外的条形码。

可以将QR编码条形码符号输出到任何支持的Windows打印机上。

ADTOOLS Document Imaging SDK

LEADTOOLS Document Imaging 是一套可以扫描多种语言文档的COM和VCL控件。它可以执行光学字符识别，并且将扫描出的文本以四十多种不同的格式输出，包括MS Word，MS Excel，Dbase和WordPerfect等等。当它用于格式识别和处理应用时，可以加快光符识别处理速度。

注释
本产品具有强大的注释功能，可以添加文本、高亮、附注、音频、椭圆、圆、方形、按钮、线条、箭头、长方形、多边形、修订（中断信息）、热点、手写字、指针、图像、图章、标尺和超级链接，以上所有对于文档、色彩和灰度图像都具有多层安全特性。文档成像（Document Imaging）和文档成像套装（Document Imaging Suite）产品都具有此注释功能。

显示，处理以及内存优化
本产品不仅包含了光栅成像产品的所有显示功能，还拥有被称为双色缩放比例的专业化显示选项，此功能能够大大的提高成像图像的质量以及屏幕上黑白图像的可读性。

图像获取 – TWAIN捕获
TWAIN驱动是几乎所有扫描器和其它图像获取设备的标准，再加上技术的进一步完善，因此我们的LEADTOOLS Fast TWAIN产品绝对是您在性能和可靠性方面的最佳选择。目前LEADTOOLS 文档成像（LEADTOOLS Document Imaging）产品支持TWAIN 1.9规范中的所有功能。

图像增强功能
扫描和传真过程中，噪声和失真不可避免，而它们会导致光符字符识别的精度下降并影响人类阅读。要克服这些缺点，用户只需使用LEADTOOLS文档成像产品中名为Doc-Clean的功能，此功能可以消除成像图像中的噪声、边界、线条和装订孔，平滑文本，反转白色文本为黑色文本，还包含可延伸的倾斜图像（抗扭斜），粗化线条和文本（膨胀）以及腐蚀过厚的文本的其它功能（腐蚀）。

专用存储和压缩功能
Mixed Raster Content（MRC）使用一种技术将图像划分为图像和文本，然后使用一种适合于此类型图像的压缩技术来获取最高的压缩率以及最佳的图像质量。

光学字符识别（OCR）
光学字符识别功能能够将图像转换成编码形式的字符串，或将其内容以各种文档、数据库以及表单的格式保存（更多有关内容，请参考LEADTOOLS OCR功能）。文档成像套装（Document Imaging Suite）产品包含有此功能，如果您使用的是文档成像（Document Imaging）产品，则可以购买一个OCR插件来获取此功能。

条形码
条形码应用于文档成像领域已有多年的历史，它主要用来帮助识别文档，能够包含文档信息以及用于其它用途的各种信息。鉴于条形码在文档成像应用程序中的强大功能，LEAD公司推出了多种强大的条形码扩展功能，您可以购买这些功能来满足您的应用程序的特定需求。

全面成像特征功能
为使LEADTOOLS图像成像系列产品成为用途最广泛和最强大的图像成像产品，LEAD公司开发了全面的（双色、灰度以及彩色）成像特征功能包括图像处理（变换、过滤、绘制），颜色转换、显示、特效（精选自两千多种特效），压缩、（导入/导出的）图像格式，打印、国际互联网/企业内部互联网成像、数据库成像、成像通用对话框以及屏幕抓拍等等。


### ImageStone

### ImageStone是一套功能强大的C++图像处理库，它可以在多个平台之间移植。功能包括：读写图像文件（JPG，GIF，PNG，TIFF，TGA...），显示，柱状图分析，undo/redo支持，超过100种预定义的特效等。下载地址：http://www.codeguru.com/cpp/g-m/bitmap/viewers/article.php/c12577/里面有全部的源码和详细的帮助文档加9个例子程序，其中example  008是一个比较完善的图像处理程序。 Introduction

ImageStone is a powerful C++ class library for image manipulation. It is written in pure C++ and is easy to port. Its features include load/save (supports BMP, GIF, JPG, PNG, TIF, ICO, TGA, PCX, PSD...), display, histogram, undo/redo, and image transformation with over 100 predefined effects.

License

ImageStone is free. You can use the code however you want (free or commercial), as long as you don't claim it as your own. (If you use it in your product, I hope I could be notified.)

Using ImageStone

It's extremely easy. All you need to do is add #include "ImageStone.h" at the beginning of your source code. If you are using ImageStone in a MFC project, just add this include line at the end of the StdAfx.h file.

The most basic and most important class is FCObjImage. Learn how to use it.

#### ... load/save image file under any OS
// for Windows : ImageStone uses GDI+ to load/save image,//Jpg/Png/Gif/Bmp/Tga/Tif be supported// for Linux : Only Bmp/Tga are supported, but you can set//FreeImage handler to support more.FCObjImageimg ;img.Load ("test.jpg") ;if (!img.IsValidImage()){assert(false) ;returnfalse ;}// print image's information : width, height, bit per pixelprintf ("image's width : %d",img.Width()) ;printf ("image's height : %d", img.Height()) ;printf ("image's bpp : %d",img.ColorBits()) ;// Load/Save function determine image's format by file's ext name// save image as jpeg file, its quality set 90 (ranges from 1 to 99)img.Save ("save.jpg", 90) ;img.Save ("save.png") ;img.Save ("save.tif") ;// Another way to set qualityFCImagePropertyprop ;prop.SetPropertyValue (IMAGE_TAG_JPEG_QUALITY, "90") ;img.Save ("save.jpg", prop) ;
#### ... load image from memory under any OS
// Load image into memorychar* p = 0 ;intn = 0 ;FCOXOHelper::LoadFileToBuffer ("test.jpg", p, n) ;FCObjImageimg ;img.Load (p, n, IMG_JPG) ;delete[] p ;// this line demonstrates how to determine the image's format by// the file's ext nameIMAGE_TYPEt = FCObjImage::GetImageHandleFactory()->QueryImageFileType("test.jpg");
#### ... load image from DIB stream under any OS
// Load image into memorychar* p = 0 ;intn = 0 ;FCOXOHelper::LoadFileToBuffer ("test.bmp", p, n) ;p += sizeof(BITMAPFILEHEADER) ;// now p points to a DIB streamFCObjImageimg ;img.LoadDIBStream (p, n) ;delete[] p ;
#### ... load image from a resource under Windows
// Load image from local exe fileFCObjImageimg ;FCWin32::LoadImageRes (img, MAKEINTRESOURCE(nID), TEXT("JPG"),IMG_JPG) ;// Load image from DLL's resourceHMODULEhDll = LoadLibrary (TEXT("ResDll.dll")) ;FCWin32::LoadImageRes (img, MAKEINTRESOURCE(nID), TEXT("JPG"),IMG_JPG, hDll) ;// Load image from standard BITMAP resourceFCWin32::LoadImageBitmapRes (img, MAKEINTRESOURCE(nID)) ;
#### ... load/save image via FreeImage library 
// change to FreeImage library to load/save image// for more detail, refer to example 005FCObjImage::SetImageHandleFactory (new FCImageHandleFactory_FreeImage) ;img.Load ("test.jpg") ;// change to GDI+ load/save imageFCObjImage::SetImageHandleFactory (new FCImageHandleFactory_Gdiplus) ;img.Load ("test.jpg") ;
#### ... combine ImageHandleFactory
// use FreeImage to load/save PSD/PCX imageclass CMyImageFactory : public FCImageHandleFactory{protected:virtual FCImageHandleBase* CreateImageHandle (IMAGE_TYPE imgType){switch (imgType){case IMG_BMP : returnnew FCImageHandle_Bmp ;case IMG_TGA : returnnew FCImageHandle_Tga ;case IMG_JPG : returnnew FCImageHandle_Gdiplus ;case IMG_GIF : returnnew FCImageHandle_Gdiplus ;case IMG_TIF : returnnew FCImageHandle_Gdiplus ;case IMG_PNG : returnnew FCImageHandle_Gdiplus ;case IMG_PCX : returnnew FCImageHandle_FreeImage ;case IMG_PSD : returnnew FCImageHandle_FreeImage ;}return 0 ;}// protected avoid user delete object.virtual ~CMyImageFactory() {}};// use our custom factory to read/write imageFCObjImage::SetImageHandleFactory (new CMyImageFactory) ;FCObjImageimg ;img.Load ("test.jpg") ;
#### ... load multi-frame GIF
FCObjMultiFrameimg ;img.Load ("test.gif") ;img.GetFrame(0)->Save ("001.jpg") ;img.GetFrame(1)->Save ("001.jpg") ;...
#### ... Load a jpeg's EXIF information
FCObjImageimg ;FCImagePropertyprop ;img.Load ("test.jpg", &prop) ;// get camera's ISO speedstd::stringm = prop.QueryPropertyValue (IMAGE_TAG_EXIF_ISOSpeed) ;// get camera's equip modelstd::stringn = prop.QueryPropertyValue (IMAGE_TAG_EquipModel) ;
#### ... draw image object under Windows
FCObjImageimg ;// capture current screenRECTrc = {0, 0, GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN)} ;FCWin32::CaptureScreen (img, rc) ;// Draw image (no stretch) where top-left at (0,0) of hdcFCWin32::DrawImage (img, hdc, 0, 0) ;// Stretch image on region of hdcRECTrcOnDC = {100, 100, 200, 200} ;FCWin32::DrawImage (img, hdc, rcOnDC) ;// Stretch image on central of hdc's region and keep image's aspectFCWin32::DrawImageAspect (img, hdc, rcOnDC) ;// Stretch region of image on region of hdcRECTrcImg = {20, 20, 50, 50} ;FCWin32::DrawImage (img, hdc, rcOnDC, rcImg) ;
#### ... copy/paste image to/from Clipboard
FCObjImageimg ;img.Load ("test.jpg") ;// copy image to ClipboardFCWin32::CopyToClipboard (img) ;// get image on ClipboardFCWin32::GetClipboardImage (img) ;
#### ... convert between GDI HBITMAP and FCObjImage
// create HBITMAP from FCObjImage objectFCObjImageimg ;img.Load ("test.jpg") ;HBITMAPh = FCWin32::CreateDDBHandle (img) ;// create FCObjImage object from HBITMAPFCWin32::CreateImageFromDDB (h, img) ;
#### ... convert between GDI+ bitmap and FCObjImage
// create GDI+ Bitmap from FCObjImage objectFCObjImageimg ;img.Load ("test.jpg") ;Gdiplus::Bitmap* pBmp = FCWin32::GDIPlus_CreateBitmap(img) ;delete pBmp ;// create FCObjImage object from GDI+ BitmapFCWin32::GDIPlus_LoadBitmap (*pBmp, img) ;
#### ... process image
FCObjImageimg ;img.Load ("test.jpg") ;// resize (smooth) imageimg.Stretch (nWidth, nHeight) ;img.Stretch_Smooth (nWidth, nHeight) ;// Use SinglePixelProcessProc interface to process image.// There are over 100 pre-implemented effects;// please refer to class derived from FCInterface_PixelProcessFCPixelRotateaCmd (37) ;img.SinglePixelProcessProc (aCmd) ;FCPixelBrightnessaCmd (150) ;// 150%img.SinglePixelProcessProc (aCmd) ;FCPixelMosaicaCmd(5) ;img.SinglePixelProcessProc (aCmd) ;FCPixelOilPaintaCmd (3) ;img.SinglePixelProcessProc (aCmd) ;
#### ... custom image processing
// our processor : change pixel's RGB valueclass CMyPixelProcessor : public FCSinglePixelProcessBase{public:CMyPixelProcessor (int nR, int nG, int nB) : m_R(nR), m_G(nG),m_B(nB) {}private:virtualvoid ProcessPixel (FCObjImage* pImg, int x, int y,BYTE* pPixel){PCL_B(pPixel) = FClamp0255 (PCL_B(pPixel) + m_B) ;PCL_G(pPixel) = FClamp0255 (PCL_G(pPixel) + m_G) ;PCL_R(pPixel) = FClamp0255 (PCL_R(pPixel) + m_R) ;}intm_R, m_G, m_B ;};// this class has the same function to upper class,// but implements other classclass CMyImageProcessor : public FCPixelWholeImageBase{public:CMyPixelProcessor (int nR, int nG, int nB) : m_R(nR), m_G(nG),m_B(nB) {}private:virtualvoid ProcessWholeImage (FCObjImage* pImg,FCObjProgress* pProgress){for (int y=0 ; y < pImg->Height() ; y++){for (int x=0 ; x < pImg->Width() ; x++){BYTE* p = pImg->GetBits(x,y) ;PCL_B(p)= FClamp0255 (PCL_B(p) + m_B) ;PCL_G(p)= FClamp0255 (PCL_G(p) + m_G) ;PCL_R(p)= FClamp0255 (PCL_R(p) + m_R) ;}if (pProgress)pProgress->SetProgress (100 * y / pImg->Height()) ;}}intm_R, m_G, m_B ;};// use our custom processorFCObjImageimg ;img.Load ("test.jpg") ;CMyPixelProcessoraCmd (20, 20, 20) ;img.SinglePixelProcessProc (aCmd) ;CMyImageProcessoraCmd (20, 20, 20) ;img.SinglePixelProcessProc (aCmd) ;
#### ... add text on image
FCObjImageimg ;img.Load ("c://test.jpg") ;// now we create text layerFCObjTextLayerimgT ;PACK_TextLayertp ;tp.m_bAddShadow= false ;tp.m_bAntiAliased = true ;tp.m_bBold= true ;tp.m_bItalic= true ;tp.m_crFont= PCL_RGBA(0,0,255) ;tp.m_nFontSize= 128 ;tp.m_strFace= "Arial" ;tp.m_strText= "Hello" ;FCWin32::CreateTextLayer_GDIPlus (imgT, tp) ;// Now we have created a text image. Additionaly,// we can add some affect to it, such as gradient colorPOINTpt1={0,0}, pt2={0,50} ;FCPixelGradientLineaCmd (pt1, pt2, PCL_RGBA(0,0,255),FCColor::crWhite()) ;imgT.SinglePixelProcessProc (aCmd) ;// blend text layer on imageRECTrc = {0, 0, imgT.Width(), imgT.Height()} ;img.AlphaBlend (imgT, rc, rc, 100) ;


**GIMP**

The GIMP是一个免费的、分布式的图片润饰、图象制作和处理软件，内含几乎所有图象处理所需的功能，号称Linux下的PhotoShop。GIMP在Linux系统推出时就风靡了许多绘图爱好者的喜爱，它的接口相当轻巧，但其功能却不输于专业的绘图软件；它提供了各种的影像处理工具、滤镜，还有许多的组件模块，对于要制作一个又酷又炫的网页按钮或网站Logo来说是一个非常方便好用的绘图软件，因为它也提供了许多的组件模块，你只要稍加修改一下，便可制作出一个属于你的网页按钮或网站Logo。 如今推出了For Windows版本，还不赶快试试... **注：需要安装GTK+环境包才能正常安装.**

下载地址：http://dlc2.pconline.com.cn/filedown.jsp?dlid=10351&linkid=6361451


**CxImage**

CxImage类库是一个优秀的图像操作类库。它可以快捷地存取、显示、转换各种图像。有的读者可能说，有那么多优秀的图形库，如OpenIL,FreeImage,PaintLib等等，它们可谓是功能强大，齐全，没必要用其它的类库。但我要说，这些类库基本上没有免费的，使用这些类库，你要被这样那样的许可协议所束缚。在这点上，CxImage类库是完全免费的。另外，在使用上述类库时，你会遇到重重麻烦。因为它们大部分是平台无关的，且用C语言写成，有的还夹杂着基本的C++ wrapper和成堆德编译选项的声明需要你去处理。而CxImage类库在这方面做得很好。还有让我最看好的，就是作者完全公开了源代码。相对于那些封装好的图形库和GDI+来说，这一点使我们可以进一步学习各种编解码技术，而不再浮于各种技术的表面。如果想下载CxImage，可以[http://www.codeproject.com](http://www.codeproject.com/)上下载。 CxImage类库的结构：

一个CxImage对象是一个扩展了的位图。作者只是在位图结构上添加了一些起存储信息作用的成员变量。一个CxImage对象（同时）也是一组层。每个层只有在需要时才会分配相应的缓冲区。CxImage::pDib代表着背景图像，CxImage::pAlpha代表着透明层，CxImage::pSelection代表着被选中的层，被用来创建图像处理时让用户感兴趣的区域。在这三个特殊层面的基础上，你可以增加一些额外的层，这些层可以存储在CxImage::pLayers中。一般说来，层是一个完整的CxImage对象。因此，你可以构造很复杂的嵌套层。下面是CxImage的一些成员变量: 
class CxImage{...protected:void* pDib;//包含文件头，调色板等等BITMAPINFOHEADER head; //标准的文件头（位图）CXIMAGEINFO info;//扩展了的信息BYTE* pSelection;//用户选中的区域BYTE* pAlpha;//alpha通道CxImage** pLayers;//通用层}typedef struct tagCxImageInfo {DWORDdwEffWidth;//DWORD 扫描线宽BYTE*pImage;//图像位数void*pGhost;//if this is a ghost, pGhost point to the bodyDWORDdwType;//原图像的格式charszLastError[256]; //出错信息longnProgress;//监视循环的次数longnEscape;//跳出标志longnBkgndIndex;//GIF, PNG, MNG格式使用RGBQUAD nBkgndColor;//RGB三原色透明度BYTEnQuality;//JPEG格式使用longnFrame;//TIF, GIF, MNG使用 :实际的帧数longnNumFrames;//TIF, GIF, MNG使用 :帧总数DWORDdwFrameDelay;//GIF, MNG使用longxDPI;//水平分辨率longyDPI;//垂直分辨率RECTrSelectionBox;//选中的矩形区BYTEnAlphaMax;//阴影的最大不透明度boolbAlphaPaletteEnabled;//如果调色板中有Alpha通道则为真boolbEnabled;//打开绘图函数longxOffset;longyOffset;DWORDdwEncodeOption;//一些编码选项RGBQUAD last_c;//一些优化选项BYTElast_c_index;boollast_c_isvalid;longnNumLayers;DWORDdwFlags;} CXIMAGEINFO;要在picture box中显示一个png格式的文件，只需:CxImage image("myfile.png", CXIMAGE_FORMAT_PNG);HBITMAP m_bitmap = image.MakeBitmap(m_picture.GetDC()->m_hDC);m_picture.SetBitmap(m_bitmap);其它格式则类推。Examples: how to ...... convert from a format to anotherCxImageimage;// bmp -> jpgimage.Load("image.bmp", CXIMAGE_FORMAT_BMP);if (image.IsValid()){if(!image.IsGrayScale()) image.IncreaseBpp(24);image.SetJpegQuality(99);image.Save("image.jpg",CXIMAGE_FORMAT_JPG);}// png -> tifimage.Load("image.png", CXIMAGE_FORMAT_PNG);if (image.IsValid()){image.Save("image.tif",CXIMAGE_FORMAT_TIF);}... load an image resource//Load the resource IDR_PNG1 from the PNG resource typeCxImage* newImage = new CxImage();newImage->LoadResource(FindResource(NULL,MAKEINTRESOURCE(IDR_PNG1),"PNG"),CXIMAGE_FORMAT_PNG);or//Load the resource IDR_JPG1 from DLLCxImage* newImage = new CxImage();HINSTANCE hdll=LoadLibrary("imagelib.dll");if (hdll){HRSRC hres=FindResource(hdll,MAKEINTRESOURCE(IDR_JPG1),"JPG");newImage->LoadResource(hres,CXIMAGE_FORMAT_JPG,hdll);FreeLibrary(hdll);}or//Load a bitmap resource;HBITMAP bitmap = ::LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_BITMAP1)));CxImage *newImage = new CxImage();newImage->CreateFromHBITMAP(bitmap);... decode an image from memoryCxImage image((BYTE*)buffer,size,image_type);orCxMemFile memfile((BYTE*)buffer,size);CxImage image(&memfile,image_type);orCxMemFile memfile((BYTE*)buffer,size);CxImage* image = new CxImage();image->Decode(&memfile,type);... encode an image in memorylong size=0;BYTE* buffer=0;image.Encode(buffer,size,image_type);...free(buffer);orCxMemFile memfile;memfile.Open();image.Encode(&memfile,image_type);BYTE* buffer = memfile.GetBuffer();long size = memfile.Size();...free(buffer);... create a multipage TIFFCxImage *pimage[3];pimage[0]=&image1;pimage[1]=&image2;pimage[2]=&image3;FILE* hFile;hFile = fopen("multipage.tif","w+b");CxImageTIF multiimage;multiimage.Encode(hFile,pimage,3);fclose(hFile);orFILE* hFile;hFile = fopen("c://multi.tif","w+b");CxImageTIF image;image.Load("c://1.tif",CXIMAGE_FORMAT_TIF);image.Encode(hFile,true);image.Load("c://2.bmp",CXIMAGE_FORMAT_BMP);image.Encode(hFile,true);image.Load("c://3.png",CXIMAGE_FORMAT_PNG);image.Encode(hFile);fclose(hFile);... copy/paste an image//copyHANDLE hDIB = image->CopyToHandle();if (::OpenClipboard(AfxGetApp()->m_pMainWnd->GetSafeHwnd())) {if(::EmptyClipboard()) {if (::SetClipboardData(CF_DIB,hDIB) == NULL ) {AfxMessageBox( "Unable to set Clipboard data" );}}}CloseClipboard();//pasteHANDLE hBitmap=NULL;CxImage *newima = new CxImage();if (OpenClipboard()) hBitmap=GetClipboardData(CF_DIB);if (hBitmap) newima->CreateFromHANDLE(hBitmap);CloseClipboard();
需要大家注意的是:整个CxImage类库非常大。如果你只需要能处理其中的几种格式，你可以在主要的头文件ximage.h中找到一些开关选项来关闭一些图像库。JPG、PNG、TIFF中的每一个库，都会向最终程序增加约100KB的内容。而CxImage类库压缩后只有约60KB。所以，你需要谨慎挑选一些你真正需要的类库。作者提供的示例工程在编译后，你会发现如下一些文件: ·CxImage : cximage.lib - static library ·CxImageCrtDll : cximagecrt.dll - DLL not using mfc ·CxImageMfcDll : cximage.dll - DLL using mfc ·Demo : demo.exe - program linked with cximage.lib and the C libraries ·DemoDll : demodll.exe - program linked with cximagecrt.dll ·j2k,jasper,jbig,jpeg,png,tiff,zlib : static C libraries 构建这些工程需要耗费几分钟的时间（中间文件可达60MB）。下面则是使用CxImage类库前必须设置的一些参数：
Project Settings|- C/C++||- Code Generation|||- Use run-time library : Multithreaded DLL (must be the same for|||all the linked libraries)|||- Struct member alignment : must be the same for all the linked|||libraries||- Precompiled headers : not using precompiled headers||- Preprocessor||- Additional Include Directories:../cximage|- Link|- General|- Object/library modules: ../png/Debug/png.lib../jpeg/Debug/jpeg.lib../zlib/Debug/zlib.lib../tiff/Debug/tiff.lib../cximage/Debug/cximage.lib..

