# 多线程学习笔记 - 深之JohnChen的专栏 - CSDN博客

2009年07月18日 00:02:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：4704


**多线程学习笔记**

**多线程概述**

　　进程和线程都是操作系统的概念。进程是应用程序的执行实例，每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成，进程在运行过程中创建的资源随着进程的终止而被销毁，所使用的系统资源在进程终止时被释放或关闭。
　　线程是进程内部的一个执行单元。系统创建好进程后，实际上就启动执行了该进程的主执行线程，主执行线程以函数地址形式，比如说main或WinMain函数，将程序的启动点提供给Windows系统。主执行线程终止了，进程也就随之终止。
　　每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。一个进程中的所有线程都在该进程的虚拟地址空间中，共同使用这些虚拟地址空间、全局变量和系统资源，所以线程间的通讯非常方便，多线程技术的应用也较为广泛。
　　多线程可以实现并行处理，避免了某项任务长时间占用CPU时间。要说明的一点是，目前大多数的计算机都是单处理器（CPU）的，为了运行所有这些线程，操作系统为每个独立线程安排一些CPU时间，操作系统以轮换方式向线程提供时间片，这就给人一种假象，好象这些线程都在同时运行。由此可见，如果两个非常活跃的线程为了抢夺对CPU的控制权，在线程切换时会消耗很多的CPU资源，反而会降低系统的性能。这一点在多线程编程时应该注意。
Win32 SDK函数支持进行多线程的程序设计，并提供了操作系统原理中的各种同步、互斥和临界区等操作。Visual C++ 6.0中，使用MFC类库也实现了多线程的程序设计，使得多线程编程更加方便。

**Win32 API****对多线程编程的支持**

Win32 提供了一系列的API函数来完成线程的创建、挂起、恢复、终结以及通信等工作。下面将选取其中的一些重要函数进行说明。 

1、HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,

DWORD dwStackSize,

LPTHREAD_START_ROUTINE lpStartAddress,

LPVOID lpParameter,

DWORD dwCreationFlags,

LPDWORD lpThreadId);

该函数在其调用进程的进程空间里创建一个新的线程，并返回已建线程的句柄，其中各参数说明如下：

lpThreadAttributes：指向一个 SECURITY_ATTRIBUTES 结构的指针，该结构决定了线程的安全属性，一般置为 NULL； 

dwStackSize：指定了线程的堆栈深度，一般都设置为0； 

lpStartAddress：表示新线程开始执行时代码所在函数的地址，即线程的起始地址。一般情况为(LPTHREAD_START_ROUTINE)ThreadFunc，ThreadFunc 是线程函数名； 

lpParameter：指定了线程执行时传送给线程的32位参数，即线程函数的参数； 

dwCreationFlags：控制线程创建的附加标志，可以取两种值。如果该参数为0，线程在被创建后就会立即开始执行；如果该参数为CREATE_SUSPENDED,则系统产生线程后，该线程处于挂起状态，并不马上执行，直至函数ResumeThread被调用； 

lpThreadId：该参数返回所创建线程的ID； 

如果创建成功则返回线程的句柄，否则返回NULL。 

2、DWORD SuspendThread(HANDLE hThread);

该函数用于挂起指定的线程，如果函数执行成功，则线程的执行被终止。

3、DWORD ResumeThread(HANDLE hThread);

该函数用于结束线程的挂起状态，执行线程。

4、VOID ExitThread(DWORD dwExitCode);

该函数用于线程终结自身的执行，主要在线程的执行函数中被调用。其中参数dwExitCode用来设置线程的退出码。 

5、BOOL TerminateThread(HANDLE hThread,DWORD dwExitCode);

　　一般情况下，线程运行结束之后，线程函数正常返回，但是应用程序可以调用TerminateThread强行终止某一线程的执行。各参数含义如下： 

hThread：将被终结的线程的句柄； 

dwExitCode：用于指定线程的退出码。 

使用TerminateThread()终止某个线程的执行是不安全的，可能会引起系统不稳定；虽然该函数立即终止线程的执行，但并不释放线程所占用的资源。因此，一般不建议使用该函数。

6、 BOOL GetExitCodeThread(

HANDLE* hThread*,// handle to the thread

LPDWORD* lpExitCode*// address to receive termination status

);

得到终止线程状态，如果状态为STILL_ACTIVE，线程没有终止，否则线程终止。

7、BOOL PostThreadMessage(DWORD idThread,

UINT Msg,

WPARAM wParam,

LPARAM lParam);

该函数将一条消息放入到指定线程的消息队列中，并且不等到消息被该线程处理时便返回。

idThread：将接收消息的线程的ID； 

Msg：指定用来发送的消息； 

wParam：同消息有关的字参数； 

lParam：同消息有关的长参数； 

调用该函数时，如果即将接收消息的线程没有创建消息循环，则该函数执行失败。

注：没有对应SendThreadMessage函数，因为SendMessage是不安全的，发送消息到一个窗口，自己等待，消息处理完成之后返回。如果消息始终没有处理完成返回的话，就会存在死锁问题，所以线程中没有对应SendThreadMessage之类的函数。

SendMessag、PostMessage、GetMessage、PeekMessage区别

SendMessag是发送消息到另一个窗口，自己等待，消息处理完成之后返回。（表面上另一个窗口消息处理是自己窗口来执行完成的，其实另一个窗口消息处理真正的执行者是SendMessag这个窗口）

PostMessage是发送消息到消息队列中，自己马上返回。

GetMessage消息过滤，等到有合适的消息时才返回，同时会将消息从队列中删除。

PeekMessage消息过滤，查看了一下消息队列，PeekMessage可以设置最后一个参数wRemoveMsg来决定是否将消息保留在队列中。

**MFC****对多线程编程的支持**

MFC中有两类线程，分别称之为工作者线程和用户界面线程。二者的主要区别在于工作者线程没有消息循环，而用户界面线程有自己的消息队列和消息循环。
　　工作者线程没有消息机制，通常用来执行后台计算和维护任务，如冗长的计算过程，打印机的后台打印等。用户界面线程一般用于处理独立于其他线程执行之外的用户输入，响应用户及系统所产生的事件和消息等。但对于Win32的API编程而言，这两种线程是没有区别的，它们都只需线程的启动地址即可启动线程来执行任务。
　　在MFC中，一般用全局函数AfxBeginThread()来创建并初始化一个线程的运行，该函数有两种重载形式，分别用于创建工作者线程和用户界面线程。两种重载函数原型和参数分别说明如下：

(1) CWinThread* AfxBeginThread(AFX_THREADPROC pfnThreadProc,

LPVOID pParam,

nPriority=THREAD_PRIORITY_NORMAL,

UINT nStackSize=0,

DWORD dwCreateFlags=0,

LPSECURITY_ATTRIBUTES lpSecurityAttrs=NULL);

PfnThreadProc:指向工作者线程的执行函数的指针，线程函数原型必须声明如下：

UINT ExecutingFunction(LPVOID pParam);

请注意，ExecutingFunction()应返回一个UINT类型的值，用以指明该函数结束的原因。一般情况下，返回0表明执行成功。

pParam：传递给线程函数的一个32位参数，执行函数将用某种方式解释该值。它可以是数值，或是指向一个结构的指针，甚至可以被忽略；

nPriority：线程的优先级。如果为0，则线程与其父线程具有相同的优先级；

nStackSize:线程为自己分配堆栈的大小，其单位为字节。如果nStackSize被设为0，则线程的堆栈被设置成与父线程堆栈相同大小；

dwCreateFlags：如果为0，则线程在创建后立刻开始执行。如果为CREATE_SUSPEND，则线程在创建后立刻被挂起；

lpSecurityAttrs：线程的安全属性指针，一般为NULL；

(2) CWinThread* AfxBeginThread(CRuntimeClass* pThreadClass,

int nPriority=THREAD_PRIORITY_NORMAL,

UINT nStackSize=0,

DWORD dwCreateFlags=0,

LPSECURITY_ATTRIBUTES lpSecurityAttrs=NULL);

pThreadClass 是指向 CWinThread 的一个导出类的运行时类对象的指针，该导出类定义了被创建的用户界面线程的启动、退出等；其它参数的意义同形式1。使用函数的这个原型生成的线程也有消息机制，在以后的例子中我们将发现同主线程的机制几乎一样。

下面我们对CWinThread类的数据成员及常用函数进行简要说明。

m_hThread：当前线程的句柄；

m_nThreadID:当前线程的ID；

m_pMainWnd：指向应用程序主窗口的指针.

**线程间通讯**

　　一般而言,应用程序中的一个次要线程总是为主线程执行特定的任务,这样,主线程和次要线程间必定有一个信息传递的渠道,也就是主线程和次要线程间要进行通信。这种线程间的通信不但是难以避免的，而且在多线程编程中也是复杂和频繁的，下面将进行说明。

使用全局变量进行通信

由于属于同一个进程的各个线程共享操作系统分配该进程的资源，故解决线程间通信最简单的一种方法是使用全局变量。对于标准类型的全局变量，我们建议使用volatile 修饰符，它告诉编译器无需对该变量作任何的优化，即无需将它放到一个寄存器中，并且该值可被外部改变。如果线程间所需传递的信息较复杂，我们可以定义一个结构，通过传递指向该结构的指针进行传递信息。

使用自定义消息

我们可以在一个线程的执行函数中向另一个线程发送自定义的消息来达到通信的目的。一个线程向另外一个线程发送消息是通过操作系统实现的。利用Windows操作系统的消息驱动机制，当一个线程发出一条消息时，操作系统首先接收到该消息，然后把该消息转发给目标线程，接收消息的线程必须已经建立了消息循环。

**线程的同步**

　　虽然多线程能给我们带来好处，但是也有不少问题需要解决。例如，对于像磁盘驱动器这样独占性系统资源，由于线程可以执行进程的任何代码段，且线程的运行是由系统调度自动完成的，具有一定的不确定性，因此就有可能出现两个线程同时对磁盘驱动器进行操作，从而出现操作错误。
使隶属于同一进程的各线程协调一致地工作称为线程的同步。MFC提供了多种同步对象，下面我们只介绍最常用的四种：

临界区（CCriticalSection）

事件（CEvent）

互斥量（CMutex）

信号量（CSemaphore）

***A******、使用****** CCriticalSection ******类***

　　当多个线程访问一个独占性共享资源时,可以使用“临界区”对象。任一时刻只有一个线程可以拥有临界区对象，拥有临界区的线程可以访问被保护起来的资源或代码段，其他希望进入临界区的线程将被挂起等待，直到拥有临界区的线程放弃临界区时为止，这样就保证了不会在同一时刻出现多个线程访问共享资源。

CCriticalSection类的用法非常简单，步骤如下：

定义CCriticalSection类的一个全局对象（以使各个线程均能访问），如CCriticalSection critical_section；

在访问需要保护的资源或代码之前，调用CCriticalSection类的成员Lock（）获得临界区对象：

critical_section.Lock();

在线程中调用该函数来使线程获得它所请求的临界区。如果此时没有其它线程占有临界区对象，则调用Lock()的线程获得临界区；否则，线程将被挂起，并放入到一个系统队列中等待，直到当前拥有临界区的线程释放了临界区时为止。

访问临界区完毕后，使用CCriticalSection的成员函数Unlock()来释放临界区：

critical_section.Unlock();

再通俗一点讲，就是线程A执行到critical_section.Lock();语句时，如果其它线程(B)正在执行critical_section.Lock();语句后且critical_section. Unlock();语句前的语句时，线程A就会等待，直到线程B执行完critical_section. Unlock();语句，线程A才会继续执行。

***B******、使用****** CEvent ******类***

CEvent 类提供了对事件的支持。事件是一个允许一个线程在某种情况发生时，唤醒另外一个线程的同步对象。例如在某些网络应用程序中，一个线程（记为A）负责监听通讯端口，另外一个线程（记为B）负责更新用户数据。通过使用CEvent 类，线程A可以通知线程B何时更新用户数据。每一个CEvent 对象可以有两种状态：有信号状态和无信号状态。线程监视位于其中的CEvent 类对象的状态，并在相应的时候采取相应的操作。
　　在MFC中，CEvent 类对象有两种类型：人工事件和自动事件。一个自动CEvent 对象在被至少一个线程释放后会自动返回到无信号状态；而人工事件对象获得信号后，释放可利用线程，但直到调用成员函数ReSetEvent()才将其设置为无信号状态。在创建CEvent 类的对象时，默认创建的是自动事件。 CEvent 类的各成员函数的原型和参数说明如下：

1、CEvent(BOOL bInitiallyOwn=FALSE,

BOOL bManualReset=FALSE,

LPCTSTR lpszName=NULL,

LPSECURITY_ATTRIBUTES lpsaAttribute=NULL);

bInitiallyOwn:指定事件对象初始化状态，TRUE为有信号，FALSE为无信号；

bManualReset：指定要创建的事件是属于人工事件还是自动事件。TRUE为人工事件，FALSE为自动事件；

后两个参数一般设为NULL，在此不作过多说明。

2、BOOL CEvent：：SetEvent();

　　将 CEvent 类对象的状态设置为有信号状态。如果事件是人工事件，则 CEvent 类对象保持为有信号状态，直到调用成员函数ResetEvent()将其重新设为无信号状态时为止。如果CEvent 类对象为自动事件，则在SetEvent()将事件设置为有信号状态后，CEvent 类对象由系统自动重置为无信号状态。

如果该函数执行成功，则返回非零值，否则返回零。

3、BOOL CEvent：：ResetEvent();

该函数将事件的状态设置为无信号状态，并保持该状态直至SetEvent()被调用时为止。由于自动事件是由系统自动重置，故自动事件不需要调用该函数。如果该函数执行成功，返回非零值，否则返回零。我们一般通过调用WaitForSingleObject函数来监视事件状态。

***C******、使用******CMutex ******类***

　　互斥对象与临界区对象很像.互斥对象与临界区对象的不同在于:互斥对象可以在进程间使用,而临界区对象只能在同一进程的各线程间使用。当然，互斥对象也可以用于同一进程的各个线程间，但是在这种情况下，使用临界区会更节省系统资源，更有效率。

***D******、使用******CSemaphore ******类***

　　当需要一个计数器来限制可以使用某个线程的数目时，可以使用“信号量”对象。CSemaphore 类的对象保存了对当前访问某一指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程的数目。如果这个计数达到了零，则所有对这个CSemaphore 类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零时为止。一个线程被释放已访问了被保护的资源时，计数值减1；一个线程完成了对被控共享资源的访问时，计数值增1。这个被CSemaphore 类对象所控制的资源可以同时接受访问的最大线程数在该对象的构建函数中指定。

CSemaphore 类的构造函数原型及参数说明如下：

CSemaphore (LONG lInitialCount=1,

LONG lMaxCount=1,

LPCTSTR pstrName=NULL,

LPSECURITY_ATTRIBUTES lpsaAttributes=NULL);

lInitialCount:信号量对象的初始计数值，即可访问线程数目的初始值；

lMaxCount：信号量对象计数值的最大值，该参数决定了同一时刻可访问由信号量保护的资源的线程最大数目；

后两个参数在同一进程中使用一般为NULL，不作过多讨论；

　　在用CSemaphore 类的构造函数创建信号量对象时要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时，则说明当前占用资源的线程数已经达到了所允许的最大数目，不能再允许其它线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore()函数将当前可用资源数加1。

互斥对象、临界区、事件、信号量之间的区别：

互斥对象与临界区对象很像.互斥对象与临界区对象的不同在于:互斥对象可以在进程间使用,而临界区对象只能在同一进程的各线程间使用。命名的互斥对象可以在进程间使用.

事件是一个允许一个线程在某种情况发生时，唤醒另外一个线程的同步对象。

“信号量”对象通过一个计数器来限制可以使用某个线程的数目。计数达到了零时，线程进入等待队列中等待。计数大于零时，线程可以访问资源，同时计数减一。

**编程中注意细节**

1、volatile 修饰符的作用是告诉编译器无需对该变量作任何的优化，即无需将它放到一个寄存器中，并且该值可被外部改变。对于多线程引用的全局变量来说，volatile 是一个非常重要的修饰符。
2、WaitForSingleObject

DWORD WaitForSingleObject(HANDLE hHandle,DWORD dwMilliseconds);

hHandle为要监视的对象（一般为同步对象，也可以是线程）的句柄；

dwMilliseconds为hHandle对象所设置的超时值，单位为毫秒；

当在某一线程中调用该函数时，线程暂时挂起，系统监视hHandle所指向的对象的状态。如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds毫秒，但hHandle所指向的对象还没有变成有信号状态，函数照样返回。参数dwMilliseconds有两个具有特殊意义的值：0和INFINITE。若为0，则该函数立即返回；若为INFINITE，则线程一直被挂起，直到hHandle所指向的对象变为有信号状态时为止。

3、使用CreateThread出现类似cannot convert parameter 3 from 'unsigned int (void *)' to 'unsigned long (__stdcall *)(void *)'中文，需要将参数3强制转换成LPTHREAD_START_ROUTINE。

4、CreateThread

线程函数参数类型为：LPTHREAD_START_ROUTINE

定义：ypedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(

LPVOID lpThreadParameter

);

AfxBeginThread

线程函数参数类型为：AFX_THREADPROC

定义：typedef UINT (AFX_CDECL *AFX_THREADPROC)(LPVOID);

5、ON_THREAD_MESSAGE 表示线程消息映射。

6、尽量少的使用全局变量、static变量做共享数据，尽量使用参数传递对象。被参数传递的对象，应该只包括必需的成员变量。所谓必需的成员变量，就是必定会被多线程操作的。

7、在MFC中请慎用线程。因为MFC的框架假定你的消息处理都是在主线程中完成的。首先窗口句柄是属于线程的，如果拥有窗口句柄的线程退出了，如果另一个线程处理这个窗口句柄，系统就会出现问题。而MFC为了避免这种情况的发生，使你在子线程中调用消息（窗口）处理函数时，就会不停的出Assert错误，烦都烦死你。典型的例子就时CSocket，因为CSocket是使用了一个隐藏窗口实现了假阻塞，所以不可避免的使用了消息处理函数，如果你在子线程中使用CSocket，你就可能看到assert的弹出了。

8、不要在不同的线程中同时注册COM组件。两个线程，一个注册1.ocx, 2.ocx, 3.ocx, 4.ocx; 而另一个则注册5.ocx, 6.ocx, 7.ocx, 8.ocx，结果死锁发生了，分别死在FreeLibrary和DllRegisterServer，因为这8个ocx是用MFC中做的，也可能是MFC的Bug，但DllRegisterServer却死在GetModuleFileName里。

9、不要把线程搞的那么复杂。很多初学者，恨不能用上线程相关的所有的函数，这里互斥，那里等待，一会儿起线程，一会儿关线程的。好的多线程程序，应该是尽量少的使用线程。这句话怎么理解呐，就是说尽量统一一块数据共享区存放数据队列，工作子线程从队列中取数据，处理，再放回数据，这样才会模块化，对象化；而不是每个数据都起一个工作子线程处理，处理完了就关闭，写的时候虽然直接，等维护起来就累了。

10、在写c++代码时，一直牢记着一句话：决不应该调用CreateThread。相反，应该使用VisualC++运行期库函数_beginthreadex。许多CRT的函数在多线程的情况下必须有特殊的支持，不能简单的使用CreateThread。有些CRT的函数象malloc(), 　fopen(), 　_open(), 　strtok(), 　ctime(), 　或localtime()等函数需要专门的线程局部存储的数据块，这个数据块通常需要在创建线程的时候就建立，如果使用CreateThread，这个数据块就没有建立，然后会怎样呢？在这样的线程中还是可以使用这些函数而且没有出错，实际上函数发现这个数据块的指针为空时，会自己建立一个，然后将其与线程联系在一起，这意味着如果你用CreateThread来创建线程，然后使用这样的函数，会有一块内存在不知不觉中创建，遗憾的是，这些函数并不将其删除，而CreateThread和ExitThread也无法知道这件事，于是就会有Memory 　Leak，在线程频繁启动的软件中(比如某些服务器软件)，迟早会让系统的内存资源耗尽。 


**常用线程问题**

1、在线程里用控件是不明智的选择。

2、多线程的自动启动方法.

A、窗口建立后，执行AfxBeginThread.但终止线程时，比较麻烦。有时你还必须用CloseHandle和TerminateThread来强行终止线程。这样容易造成内存泄露。

B、设置一个CEvent类对象，你可以控制他的信号量（分两种：被触发，未被触发），在建立线程时，设置线程挂起并等待信号。这样，在线程建立后（你可以提早建立线程，但它时被挂起的），你就可以想什么时候启动线程就启动线程。而且关闭也很方便（事件触发）。这是微软推荐做法。
3、不要跨线程访问复杂的MFC对象。大多数复杂的MFC对象的内部实现引用了线程局部存储（TLS）。在线程中发送一个自定义消息到窗口句柄就可以访问了。

4、mfc的大多数类不是线程安全的，cwnd及其消息路由是其中之最。mfc界面类的大多数方法，最后都是通过sendmessage实现的，而消息处理的过程中会引发其他消息的发送及处理。如果消息处理函数本身不是线程安全的。你从工作线程中调用这些方法迟早会同你界面线程的用户消息响应发生冲突。

5、Cxxxx::fromhandle会根据调用者所在线程查表，如果查不到用户创建的Cxxxx对应对象，它会创建一个临时对象出来并返回给你，你根本不可能期望它的成员变量会是有意义的。所以要用也只能用cwnd::fromhandle，因为它只包含一个m_hwnd成员。不过，要记住跨线程直接或间接地调用::sendmessage,通常都是行为不可预测的。

6、一个线程不可以也不应该访问另一个线程中的包装类对象（因为包装类对象就相当于窗口，这是MFC的目标，并不是包装类本身不能被跨线程访问），“不可以”就是通过在包装类成员函数中的断言宏实现的（在CWnd::AssertValid中），而“不应该”下面会解释。
虽然包装类对象不能跨线程访问，但是窗口句柄却可以跨线程访问。因为包装类对象不仅等同于窗口，还改变了窗口的交互方式（这也正是C++类的概念的应用），使得不用非得使用消息机制才能和窗口交互。注意前面提到的，如果跨线程访问包装类对象，而又使用C++类的概念操作它，则其必须进行线程保护，而“不能跨线程访问”就消除了这个问题。因此临时对象的产生就只是如前面所说，方便代码的编写而已，不提供子类化的效果，因为窗口句柄可以跨线程访问。

**窗口类**

窗口类是一个结构，其一个实例代表着一个窗口类型，与C++中的类的概念非常相近（虽然其表现形式完全不同，C++的类只不过是内存布局和其上的操作这个概念的类型），故被称作为窗口类。
窗口是具有设备操作能力的逻辑概念，即一种能操作设备（通常是显示器）的东西。由于窗口是窗口类的实例，就象C++中的一个类的实例，是可以具有成员函数的（虽然表现形式不同），但一定要明确窗口的目的——操作设备（这点也可以从Microsoft针对窗口所制订的API的功能看出，主要出于对设备操作的方便）。因此不应因为其具有成员函数的功能而将窗口用于功能对象的创建，这虽然不错，但是严重违反了语义的需要，是不提倡的，但却由于MFC界面包装类的加入导致大多数程序员经常将逻辑混入界面。
窗口类是个结构，其中的大部分成员都没什么重要意义，只是Microsoft一相情愿制订的，如果不想使用界面API（Windows User Interface API），可以不管那些成员。其中只有一个成员是重要的——lpfnWndProc，消息处理函数。
外界（使用窗口的代码）只能通过消息操作窗口，这就如同C++中编写的具有良好的面向对象风格的类的实例只能通过其公共成员函数对其进行操作。因此消息处理函数就代表了一个窗口的一切（忽略窗口类中其他成员的作用）。很容易发现，窗口这个实例只具有成员函数（消息处理函数），不具有成员变量，即没有一块特定内存和一特定的窗口相关联，则窗口将不能具有状态（Windows还是提供了Window Properties API来缓和这种状况）。这也正是上面问题发生的根源。
为了处理窗口不能具有状态的问题（这其实正是Windows灵活的表现），可以有很多种方法，而MFC出于能够很容易的对已有窗口类进行扩展，选择了使用一个映射将一个窗口句柄（窗口的唯一标示符）和一个内存块进行绑定，而这块内存块就是我们熟知的MFC界面包装类（从CWnd开始派生延续）的实例。

**MFC****状态**

状态就是实例通过某种手段使得信息可以跨时间段重现，C++的类的实例就是由外界通过公共成员函数改变实例的成员变量的值以实现具有状态的效果。在MFC 中，具有三种状态：模块状态、进程状态、线程状态。分别为模块、进程和线程这三种实例的状态。由于代码是由线程运行，且和另外两个的关系也很密切，因此也被称作本地数据。
**模块本地数据**
具有模块本地性的变量。模块指一个加载到进程虚拟内存空间中的PE文件，即exe文件本身和其加载的dll文件。而模块本地性即同样的指针，根据代码从不同的模块执行而访问不同的内存空间。这其实只用每个模块都声明一个全局变量，通过一个切换的过程即可实现模块本地性。MFC中，这个过程是通过调用AfxSetModuleState来切换的，而通常都使用 AFX_MANAGE_STATE这个宏来处理，因此下面常见的语句就是用于模块状态的切换的：
AFX_MANAGE_STATE( AfxGetStaticModuleState() );
    MFC中定义了一个结构（AFX_MODULE_STATE），其实例具有模块本地性，记录了此模块的全局应用程序对象指针、资源句柄等模块级的全局变量。其中有一个成员变量是线程本地数据，类型为AFX_MODULE_THREAD_STATE，其就是本文问题的关键。
**进程本地数据**
具有进程本地性的变量。与模块本地性相同，即同一个指针，在不同进程中指向不同的内存空间。这一点Windows本身的虚拟内存空间这个机制已经实现了，不过在dll中定义的全局变量，如果dll支持Win32s，则其是共享其全局变量的，即不同的进程加载了同一dll将访问同一内存。Win32s是为了那些基于Win32的应用程序能在Windows 3.1上运行，由于Windows 3.1是16位操作系统，早已被淘汰，而现行的dll模型其本身就已经实现了进程本地性（不过还是可以通过共享节来实现Win32s中的dll的效果），因此进程状态其实就是一全局变量。
    MFC中作为本地数据的结构有很多，如_AFX_WIN_STATE、_AFX_DEBUG_STATE、_AFX_DB_STATE等，都是MFC内部自己使用的具有进程本地性的全局变量。
**线程本地数据**
具有线程本地性的变量。如上，即同一个指针，不同的线程将会访问不同的内存空间。这点MFC是通过线程本地存储（TLS——Thread Local Storage，其使用方法由于与本文无关，在此不表）实现的。
    MFC中定义了一个结构（_AFX_THREAD_STATE）以记录某些线程级的全局变量，如最近一次的模块状态指针，最近一次的消息等。

1）、 TLS是一种机制，每个线程可以持有一个指针，指向它自己的一份数据结构拷贝（注意是为每个线程拷贝一份，它们是独立无关的）
2）、MFC使用TLS来追踪每个线程所使用的GDI对象和USER对象
3）、TLS对的运作方式是。每个线程有一个由4字节槽（SLOTS）组成的数组，这个数组保证至少有TLS_MINIMUM_AVAILABLE个槽在其中，目前的操作系统保证至少有64个槽，每个槽可以指定放置任何特殊结构。如果结构WORDCOUNT放在槽4，那么每个线程可以配置一个WORDCOUNT结构空间，并设定让TLS槽4指向它
4）、设定TLS
DWORD TlsAlooc(VOID);//在TLS数据中配置一个槽，并传回数据索引
    成功，传回TLS数组中的一个槽，在DLL之中，典型的用法在收到DLL_PROCESS_ATTACH时调用此函数，调用一次只能获得一个槽，可以把所有线程都可以使用的那些全局变量指定到配置而来的槽之中。
5）、你只要配置一个槽就好，它可以被所有数据结构使用，线程的个数有限。
如果你有数个结构，把它们封装在一个大结构中，然后，为TLS线程设定一个值，给目前线程使用。
我们使用的函数是TlsSetValue(),规格如下
BOOL TlsSetValue(
DWORD dwTLsIndex,//由TLSALLOC传回的槽索引
LPVOID lpTlsValue//要储存到上述槽中的数据
)
 （1）当DLL获得DLL_PROCESS_ATTACH时，调用TLSALLOC，设传回4。DLL把此值储存于一个全局变量中，然后配置一块内存，假设在0X1F0000处，DLL调用TLSSETVALUE让槽4和地址0X1F0000产生关系（仅仅针对该线程）
 （2）当下一线程附着到同一个DLL时，DLL知道已经有一个槽被配置过了，因为全局变量中已经有值（槽编号），所以它再配置一块内存，假设在OX203000处，DLL调用TLSSETVALUE，让槽4与地址OX203000产生关联，仅与这个线程有关，与上个线程
无关
6）、取得槽内容：
LPVOID TlsGetValue(DWORD dwTLsIndex)；
返回设定在槽中的值
7）、释放槽
当DLL最终获得了DLL_PROCESS_DETACH，就释放
BOOL TlsFree(DWORD dwTLsIndex)；
8）、一个线程不能处理另一个线程的TLS槽，一个TLS索引只在同一进程有效
9）、使用_declspec(thread)，可以保证对每个线程独一无二，具有线程局部性
如DLL中有以下声明
DWORD gprogresscounter;
如果这样
_declspec(thread) DWORD gprogresscounter;保证对每个线程唯一，也可以用在结构体上
struct _sostruct
{
......
......
}
_declspec(thread) struct _sostruct abc;
将数据或结构体放在TLS上，是编译器的任务，每个以这种方式声明对象的EXE和DLL，将在可执行文件中有一个特殊的节区，内含所有的线程局部变量。
**模块线程状态**
    MFC中定义的一个结构（AFX_MODULE_THREAD_STATE），其实例即具有线程本地性又具有模块本地性。也就是说不同的线程从同一模块中和同一线程从不同模块中访问MFC库函数都将导致操作不同的内存空间。其应用在AFX_MODULE_STATE中，记录一些线程相关但又模块级的数据，如本文的重点——窗口句柄映射。

**包装类对象和句柄映射**

句柄映射——CHandleMap，MFC提供的一个底层辅助类，程序员是不应该直接使用它的。其有两个重要的成员变量：CMapPtrToPtr m_permanentMap, m_temporaryMap;。分别记录永久句柄绑定和临时句柄绑定。前面说过，MFC使用一个映射将窗口句柄和其包装类的实例绑定在一起，m_permanentMap和m_temporaryMap就是这个映射，映射分为永久包装类对象和临时包装类对象，而在前面提到过的 AFX_MODULE_THREAD_STATE中就有一个成员变量：CHandleMap* m_pmapHWND;（之所以是CHandleMap*是使用懒惰编程法，尽量节约资源）以专门完成HWND的绑定映射，除此以外还有如 m_pmapHDC、m_pmapHMENU等成员变量以分别实现HDC、HMENU的绑顶映射。而为什么这些映射要放在模块线程状态而不放在线程状态或模块状态是很明显的——这些包装类包装的句柄都是和线程相关的（如HWND只有创建它的线程才能接收其消息）且这个模块中的包装类对象可能不同于另一个模块的（如包装类是某个DLL中专门派生的一个类，如a.dll中定义的CAButton的实例和b.dll中定义的CBButton的实例如果同时在一个线程中。此时线程卸载了a.dll，然后CAButton的实例得到消息并进行处理，将发生严重错误——类代码已经被卸载掉了）。

包装类存在的意义有二：包装对HWND的操作以加速代码的编写和提供窗口子类化（不是超类化）的效果以派生窗口类。包装类对象针对线程分为两种：永久包装类对象（以后简称永久对象）和临时包装类对象（以后简称临时对象）。临时对象的意义仅仅只有包装对HWND的操作以加速代码编写，不具有派生窗口类的功能。永久对象则具有前面说的包装类的两个意义。
在创建窗口时（即CWnd::CreateEx中），MFC通过钩子提前（WM_CREATE和WM_NCCREATE之前）处理了通知，用AfxWndProc子类化了创建的窗口并将对应的CWnd*加入当前线程的永久对象的映射中，而在AfxWndProc中，总是由CWnd::FromHandlePermanent（获得对应HWND的永久对象）得到当前线程中当前消息所属窗口句柄对应的永久对象，然后通过调用得到的CWnd*的WindowProc成员函数来处理消息以实现派生窗口类的效果。这也就是说永久对象具有窗口子类化的意义，而不仅仅是封装HWND的操作。
要将一个HWND和一个已有的包装类对象相关联，调用CWnd::Attach将此包装类对象和HWND映射成永久对象（但这种方法得到的永久对象不一定具有子类化功能，很可能仍和临时对象一样，仅仅起封装的目的）。如果想得到临时对象，则通过CWnd::FromHandle这个静态成员函数以获得。临时对象之所以叫临时，就是其是由MFC内部（CHandleMap::FromHandle）生成，其内部（CHandleMap::DeleteTemp）销毁（一般通过CWinThread::OnIdle中调用AfxUnlockTempMaps）。因此程序员是永远不应该试图销毁临时对象的（即使临时对象所属线程没有消息循环，不能调用CwinThread::OnIdle，在线程结束时，CHandleMap的析构仍然会销毁临时对象）。

7、MFC对象不要跨线程使用，因为MFC不是线程安全的。比如CWnd对象不要跨线程使用,可以用窗口句柄（HWND）代替。CSocket/CAsyncSocket对象不要跨线程使用,用SOCKET句柄代替.那么到底什么是线程安全呢?什么时候需要考虑?如果程序涉及到多线程的话，就应该考虑线程安全问题。比如说设计的接口，将来需要在多线程环境中使用，或者需要跨线程使用某个对象时，这个就必须考虑了。所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

一般而言“线程安全”由多线程对共享资源的访问引起。如果调用某个接口时需要我们自己采取同步措施来保护该接口访问的共享资源,则这样的接口不是线程安全的.MFC和STL都不是线程安全的. 怎样才能设计出线程安全的类或者接口呢?如果接口中访问的数据都属于私有数据,那么这样的接口是线程安全的.或者几个接口对共享数据都是只读操作,那么这样的接口也是线程安全的.如果多个接口之间有共享数据,而且有读有写的话,如果设计者自己采取了同步措施，调用者不需要考虑数据同步问题，则这样的接口是线程安全的，否则不是线程安全的。

实例：

DWORD WINAPI ThreadProc( void *pData )  // 线程函数（比如用于从COM口获取数据）
{ 
    // 数据获取循环
    // 数据获得后放在变量i中
    CAbcDialog *pDialog = reinterpret_cast< CAbcDialog* >( pData ); 
    ASSERT( pDialog );  // 此处如果ASSERT_VALID( pDialog )将断言失败
    pDialog->m_Data = i; 
    pDialog->UpdateData( FALSE );  // UpdateData内部ASSERT_VALID( this )断言失败
   … 
} 
BOOL CAbcDialog::OnInitDialog() 
{ 
    CDialog::OnInitDialog(); 
    // 其他初始化代码
    CreateThread( NULL, 0, ThreadProc, this, 0, NULL );  // 创建线程
    return TRUE; 
}

//解决方法

#define AM_DATANOTIFY ( WM_USER + 1 ) 
static DWORD g_Data = 0; 
DWORD WINAPI ThreadProc( void *pData )  // 线程函数（比如用于从COM口获取数据）

{ 
    // 数据获取循环
    // 数据获得后放在变量i中
    g_Data = i; 
    CWnd *pWnd = CWnd::FromHandle( reinterpret_cast< HWND >( pData ) ); 
    ASSERT_VALID( pWnd );  // 本例应该直接调用平台SendMessage而不调用包装类的，这里只是演示
    pWnd->SendMessage( AM_DATANOTIFY, 0, 0 ); 
    … 
} 
BEGIN_MESSAGE_MAP( CAbcDialog, CDialog ) 
    … 
    ON_MESSAGE( AM_DATANOTIFY, OnDataNotify ) 
    … 
END_MESSAGE_MAP() 
BOOL CAbcDialog::OnInitDialog() 
{ 
    CDialog::OnInitDialog(); 
    // 其他初始化代码
    CreateThread( NULL, 0, ThreadProc, m_hWnd, 0, NULL );  // 创建线程
    return TRUE; 
} 
LRESULT CAbcDialog::OnDataNotify( WPARAM /* wParam */, LPARAM /* lParam */ ) 
{ 
    UpdateData( FALSE ); 
    return 0; 
} 
void CAbcDialog::DoDataExchange( CDataExchange *pDX ) 
{ 
    CDialog::DoDataExchange( pDX ); 
    DDX_Text( pDX, IDC_EDIT1, g_Data ); 
}

8、一个主线程Create一个子线程，那么为了保证安全退出，应该在退出时怎么样处理？

问题的难点在于怎么样知道子线程是否退出了。

解答：

检索线程的退出代码

若要获取辅助线程或用户界面线程的退出代码，请调用 GetExitCodeThread 函数。有关此函数的信息，请参见 Platform SDK。此函数获取线程（存储在 CWinThread 对象的 m_hThread 数据成员中）的句柄和 DWORD 的地址。

如果线程仍然是活动的，GetExitCodeThread 会将 STILL_ACTIVE 放在提供的 DWORD 地址中；否则将退出代码放在此地址中。

检索 CWinThread 对象的退出代码还需要一步。默认情况下，当 CWinThread 线程终止时，删除该线程对象。这意味着不能访问 m_hThread 数据成员，因为 CWinThread 对象不再存在。若要避免此情况，请执行以下两个操作之一：

将 m_bAutoDelete 数据成员设置为 FALSE。这使 CWinThread 对象在线程终止后仍可以继续存在。然后可以在线程终止后，访问 m_hThread 数据成员。但是如果使用此技术，您有责任销毁 CWinThread 对象，因为框架不会自动为您删除该对象。这是首选方法。

－或－

单独存储线程的句柄。创建线程后，（使用 ::DuplicateHandle）将其 m_hThread 数据成员复制到其他变量，并通过该变量访问该成员。这样，终止后即可以自动删除对象，并且仍然可以查出线程终止的原因。请注意：在可以复制句柄之前，线程不终止。执行此操作的最安全的方式是将 CREATE_SUSPENDED 传递到 AfxBeginThread，存储句柄，然后通过调用 ResumeThread 继续执行线程。

任一方法都可以使您确定 CWinThread 对象终止的原因。

下面给出一段代码：

// 启动工作者线程,线程对象不自动退出,需要手动delete

void VideoInstance::StartThreads()

{ 

m_pThread_MduHeart = AfxBeginThread(Thread_MDUHeart, (void*)this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED, NULL);

ASSERT( m_pThread_MduHeart != NULL );

m_pThread_MduHeart->m_bAutoDelete = FALSE; // 这点很重要.保证线程退出码在外能被检查到。

m_pThread_MduHeart->ResumeThread();

Sleep(100);

m_pThread_RecvData = AfxBeginThread(Thread_MduRealVideo, (void*)this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED, NULL);

ASSERT( m_pThread_RecvData != NULL );

m_pThread_RecvData->m_bAutoDelete = FALSE; // 这点很重要.保证线程退出码在外能被检查到。

m_pThread_RecvData->ResumeThread();

}

// 退出实例的线程对象并删除线程对象,主要是为了正常退出线程

void VideoInstance::QuitInstance()

{

// 设置线程退出信号,需要手动重置

::SetEvent(this->m_hEventQuit);

DWORD dwExitCode1 = STILL_ACTIVE; 

DWORD dwExitCode2 = STILL_ACTIVE;

while(1)

{

// 检索线程的退出代码前要求线程对象还没有退出

::GetExitCodeThread(m_pThread_MduHeart->m_hThread, &dwExitCode1);

::GetExitCodeThread(m_pThread_RecvData->m_hThread, &dwExitCode2);

if( dwExitCode1 != STILL_ACTIVE && dwExitCode2 != STILL_ACTIVE)

break;

}

// 手动删除线程对象

delete m_pThread_MduHeart;

delete m_pThread_RecvData;

m_pThread_MduHeart = NULL;

m_pThread_RecvData = NULL;

}

参考资料:

[http://www.vckbase.com/document/viewdoc/?id=1704](http://www.vckbase.com/document/viewdoc/?id=1704)

[http://www.vckbase.com/document/viewdoc/?id=1706](http://www.vckbase.com/document/viewdoc/?id=1706)

[http://www.vckbase.com/document/viewdoc/?id=1707](http://www.vckbase.com/document/viewdoc/?id=1707)

[http://www.vckbase.com/document/viewdoc/?id=1708](http://www.vckbase.com/document/viewdoc/?id=1708)


