# 图像的几何不变矩 - 深之JohnChen的专栏 - CSDN博客

2009年12月28日 10:36:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：13860


矩特征主要表征了图像区域的几何特征,又称为几何矩，由于其具有旋转、平移、尺度等特性的不变特征，所以又称其为不变矩。在图像处理中，几何不变矩可以作为一个重要的特征来表示物体，可以据此特征来对图像进行分类等操作。如果想详细了解不变矩的概念、公式等请参考下面的论文：
不变矩方法研究
一种实用的不变矩计算方法

[http://download.csdn.net/source/1943495](http://download.csdn.net/source/1943495)

1.HU矩

几何矩是由Hu(Visual pattern recognition by moment invariants)在1962年提出的，图像f(x，y)的(p+q)阶几何矩定义为

        Mpq =∫∫(x^p)*(y^q)f(x，y)dxdy(p，q = 0，1，……∞）

矩在统计学中被用来反映随机变量的分布情况，推广到力学中，它被用作刻画空间物体的质量分布。同样的道理，如果我们将图像的灰度值看作是一个二维或三维的密度分布函数，那么矩方法即可用于图像分析领域并用作图像特征的提取。最常用的，物体的零阶矩表示了图像的“质量”：

                   Moo= ∫∫f(x，y )dxdy 

一阶矩(M01，M10)用于确定图像质心( Xc，Yc)：

              Xc = M10/M00;Yc = M01/M00;

若将坐标原点移至 Xc和 Yc处，就得到了对于图像位移不变的中心矩。如

            Upq =∫∫[(x-Xc)^p]*[(y-Yc)^q]f(x，y)dxdy。

        Hu在文中提出了7个几何矩的不变量，这些不变量满足于图像平移、伸缩和旋转不变。如果定义

         Zpq=Upq/(U20 + U02)^(p+q+2)，

      Hu 的7种矩为：

      H1=Z20+Z02;H1=(Z20+Z02)^2+4Z11^2;......

矩是描述图像特征的算子，它在模式识别与图像分析领域中有重要的应用．迄今为止，常见的矩描述子可以分为以下几种：几何矩、正交矩、复数矩和旋转矩．其中几何矩提出的时间最早且形式简单，对它的研究最为充分。几何矩对简单图像有一定的描述能力，他虽然在区分度上不如其他三种矩，但与其他几种算子比较起来，他极其的简单，一般只需用一个数字就可表达。所以，一般我们是用来做大粒度的区分，用来过滤显然不相关的文档。

比如在图形库中，可能有100万幅图，也许只有200幅图是我们想要的。使用一维的几何矩的话，就可以对几何矩进行排序，建立索引，然后选出与目标图的几何矩最近的2000幅图作比较就好了。而对于其他的矩来说，由于一般是多维的关系，一般不好排序，只能顺序查找，自然速度有巨大的差别.所以。虽然几何矩不太能选出最像的，但可以快速排除不像的，提高搜索效率。

几种简单的几何矩：

令平面上点坐标为P(x,y),重心为C(x!,y!),
二阶行距：rowMoment = [∑（x- x!）*（x- x!）]/A
二阶列距：colMoment = [∑（y- y!）*（y- y!）]/A
A为点的个数。
由以上两个信息可以算出图形的圆度：circleDisgree = rowMoment /colMoment .如果图形的circleDisgree 越小于1，则它越趋向于长轴为y方向的椭圆。如果图形的circleDisgree 越大于1，则它越趋向于长轴为x方向的椭圆.如果图形的circleDisgree 越接近于1，则它越趋向于圆。
所以我们可以使用圆度这种几何矩，对其进行索引，实现快速过滤。

//代码实例

double* Getsquare(int **Array1,int Width,int Height//Array1图像灰度矩阵

{

int x,y;

double pSum,dx,dy;

int xmax,xmin,ymax,ymin,xSum,ySum,PointSum;

double dd,n1,n2,xAve,yAve;

pSum=Height*Width;

xSum=0;ySum=0;PointSum=0;

xmin=10000;ymin=10000;xmax=-1;ymax=-1;

for (y=0 ;y<Height; y++)

{

for (x=0; x<Width; x++)

{

if (Array1[x][y]==255)

{

continue;

}

xSum=xSum+x;ySum=ySum+y;++PointSum;

if (x<xmin)

{

xmin=x;

}

if (x>xmax)

{

xmax=x;

}

}

if (y<ymin)

{

ymin=y;

}

if (y>ymax)

{

ymax=y;

}

}

if (pSum==0)

{

goto Loop;

}

xAve=xSum/pSum;

yAve=ySum/pSum;

///////////////////////////////////////////上面为计算x,y平均值

for (x=1; x<16; x++)

{

SqureNumber[x]=0;

}

// 11 20 02 21+ 21- 12+ 12- 30+ 30- 03+ 02-

for (y=0; y<Height; y++)

{

for (x=0; x<Width; x++)

{

if (Array1[x][y]==255)

{

continue;

}

dx=x-xAve;dy=y-yAve;

SqureNumber[1]=SqureNumber[1]+dx*dx;// 计算 u(11) 11

SqureNumber[2]=SqureNumber[2]+dx*dx;// 计算 u(20) 20

SqureNumber[3]=SqureNumber[3]+dy*dy;// 计算 u(02) 02

if (dy>0)

{

SqureNumber[4]=SqureNumber[4]+dx*dx*dy; // 计算 u(21)+ 21+

}

else

{

SqureNumber[5]=SqureNumber[5]+dx*dx*dy; // 计算 u(21)- 21-

}

if( dx>0 )

{

SqureNumber[6]=SqureNumber[6]+dx*dy*dy; // 计算 u(12)+ 12+

}

else

{

SqureNumber[7]=SqureNumber[7]+dx*dy*dy; // 计算 u(12}- 12-

}

if (dx>0 )

{

SqureNumber[8]=SqureNumber[8]+dx*dx*dx ;// 计算 u(30)+ 30+

}

else

{

SqureNumber[9]=SqureNumber[9]+dx*dx*dx; // 计算 u(30)- 30-

}

if (dy>0)

{

SqureNumber[10]=SqureNumber[10]+dy*dy*dy ;// 计算 u(03)+ 03+

}

else

{

SqureNumber[11]=SqureNumber[11]+dy*dy*dy;// 计算 u(03)- 03-

}

}//end for x

}// end for y;

for (x=1; x<12; x++)

{

SqureNumber[x]=SqureNumber[x]/pSum;

}

///////////////////////////////////////////////////////计算图像的各阶矩

for (x=12; x<21; x++)

{

SqureNumber[x]=0;

}

SqureNumber[12]=((SqureNumber[2]-SqureNumber[3])/(SqureNumber[2]+SqureNumber[3]))/2; //长宽比特征

dd=sqrt((SqureNumber[2]-SqureNumber[3])*(SqureNumber[2]-SqureNumber[3])+4*SqureNumber[1]*SqureNumber[1]);

dd=dd+(SqureNumber[2]-SqureNumber[3]);

SqureNumber[16]=2*atan(dd/(2*SqureNumber[1]))/M_PI; ///字型倾斜度

dd=sqrt((SqureNumber[2]-SqureNumber[3])*(SqureNumber[2]-SqureNumber[3])+4*SqureNumber[1]*SqureNumber[1]);

n1=((SqureNumber[2]+SqureNumber[3])+dd)/2;

n2=((SqureNumber[2]+SqureNumber[3])-dd)/2;

SqureNumber[14]=(n1-n2)/(n1+n2);//拉长度

n1=sqrt((ymax-ymin)*(xmax-xmin));

dd=sqrt((SqureNumber[2]+SqureNumber[3])/PointSum);

SqureNumber[15]=dd/n1;//伸展度

dd=(SqureNumber[8]-SqureNumber[9])/(SqureNumber[8]+SqureNumber[9]);

SqureNumber[16]=(dd+1)/2;//水平偏移度

dd=(SqureNumber[10]-SqureNumber[11])/(SqureNumber[10]+SqureNumber[11]);

SqureNumber[17]=(dd+1)/2;//垂直偏移度

dd=(SqureNumber[4]-SqureNumber[5])/(SqureNumber[4]+SqureNumber[5]);

SqureNumber[18]=(dd+1)/2;//水平伸展度度

dd=(SqureNumber[6]-SqureNumber[7])/(SqureNumber[6]+SqureNumber[7]);

SqureNumber[19]=(dd+1)/2;//垂直伸展度

Loop:;

}

2.Zernike矩

在模式识别中,一个重要的问题是对目标的方向性变化也能进行识别。Zernike 矩是一组正交矩,具有旋转不变性的特性,即旋转目标并不改变其模值。。由于Zernike 矩可以构造任意高阶矩,所以Zernike 矩的识别效果优于其他方法.

Zernike 提出了一组多项式{ V nm ( x , y) } 。这组多项式在单位圆{ x2 + y2 ≤1} 内是正交的,具有如下形式: V nm ( x , y) = V nm (ρ,θ) = Rnm (ρ) exp ( jmθ) ,并且满足∫∫ x^2+y^2 <= 1[( V nm ( x , y) 的共轭]* V pq ( x , y) d x d y.= [pi/(n+1)]*δnpδmq .

if(a==b)δab = 1 elseδab = 0，n 表示正整数或是0；m是正整数或是负整数它表示满足m的绝对值<=n 而且n-m的绝对值是偶数这两个条件；ρ表示原点到象素（x，y）的向量的距离；θ表示向量ρ跟x 轴之间的夹角（逆时针方向）.

![](https://p-blog.csdn.net/images/p_blog_csdn_net/Zernike/zernike.bmp)

对于一幅数字图象,积分用求和代替,即A nm =∑x∑y f(x,y) *[( V nm (ρ,θ) 的共轭],x^2+y^2 <=1

实际计算一幅给定图象的Zernike 矩时,必须将图象的重心移到坐标圆点,将图象象素点映射到单位圆内。由以上可知,使[ V nm (ρ,θ) 的共轭]可提取图象的特征,低频特性由n 值小的[( V nm (ρ,θ) 的共轭]来提取,高频特性由n 值大的来提取。Zernike 矩可以任意构造高价矩, 而高阶矩包含更多的图象信息, 所以Zernike 矩识别效果更好。,Zernike 矩仅仅具有相位的移动。

它的模值保持不变。所以可以将| A nm | 作为目标的旋转不变性特征。因为| A nm | =| A n , - m | ,所以只需计算m ≥0 的情况。



