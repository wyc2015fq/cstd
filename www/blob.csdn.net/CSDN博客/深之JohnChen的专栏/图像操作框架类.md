# 图像操作框架类 - 深之JohnChen的专栏 - CSDN博客

2010年11月22日 21:10:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2722标签：[框架																[ext																[图像处理																[dst																[null																[tiff](https://so.csdn.net/so/search/s.do?q=tiff&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=dst&t=blog)](https://so.csdn.net/so/search/s.do?q=图像处理&t=blog)](https://so.csdn.net/so/search/s.do?q=ext&t=blog)](https://so.csdn.net/so/search/s.do?q=框架&t=blog)
个人分类：[图像处理与识别](https://blog.csdn.net/byxdaz/article/category/144582)


这里封装了一个图像相关处理的框架类，主要用于一些图像处理。有些图像是多页的，需要拆分成单页来处理图像操作，最后将处理的结果都保存起来。图像操作比如边缘处理、图像分割、膨胀与腐蚀等图像处理算法这里不会讲解，这里只是封装了一个图像相关处理的类CImageOperator，图像文件格式判断、文件加载、多页拆分与合并无需关注，只需在函数ImageProcess中处理实际项目中用到一些图像算法。

      CImageOperator类内容如下：

ImageOperator.h

#pragma once
/*图像相关操作类,主要用于一些图像处理
 *功能包括：1、tif图像拆分与合并；
			2、图像多页处理；
*/
#include "unicode//ximage.h"
#pragma comment(lib, "cximage_unicode.lib")
//#pragma comment(lib, "j2k_unicode.lib")
#pragma comment(lib, "jasper_unicode.lib")
#pragma comment(lib, "jbig_unicode.lib")
#pragma comment(lib, "Jpeg_unicode.lib")
#pragma comment(lib, "png_unicode.lib")
#pragma comment(lib, "Tiff_unicode.lib")
#pragma comment(lib, "zlib_unicode.lib")
#pragma comment(lib, "mng_unicode.lib")
#pragma comment(lib, "libdcr_unicode.lib")

#include <list>
using namespace std;

class CImageOperator
{
public:
	CImageOperator(void);
	~CImageOperator(void);
	/*
	*功能说明：拆分TIF
	*参数说明：pSrcFileName，表示源图像文件名称；nNo，表示第几个页[从0开始]；dst，表示拆分后的目标图像；pFileName，表示生成拆分图像文件名称
	*返回值：bool类型。true,表示成功；flase，表示失败
	*/
	bool SplitTif(TCHAR *pSrcFileName,long nNo,CxImage *dst,TCHAR *pFileName=NULL);

	/*
	*功能说明：合并TIF
	*参数说明：pSrcFileName，表示源图像文件名称；addImage，表示添加图像；nNo，表示在某位置插入图像(默认-1，表示从结尾插入图像)
	*返回值：bool类型。true,表示成功；flase，表示失败
	*/
	bool MergeAddTif(TCHAR *pSrcFileName,TCHAR *pAddFileName,long nNo=-1);

	/*
	*功能说明：文件图像处理
	*参数说明：pSrcFileName，表示原始图像文件；
	listEffectFrameNo，表示需要处理的页编号列表，用于TIF/GIF图像，如果是其他图像格式就处理整个文件；
	pDstFileName，表示目标图象文件
	*返回值：bool类型。true,表示成功；flase，表示失败
	*/
	bool ImageFileProcess(TCHAR *pSrcFileName,list<long> listEffectFrameNo,TCHAR *pDstFileName);
protected:
	/*
	*功能说明：图像处理[一些算法的处理，比如二值化、提取边缘、膨胀、腐蚀等]
	*参数说明：src，表示原始图像；dst，表示目标图象
	*返回值：bool类型。true,表示成功；flase，表示失败
	*/
	bool ImageProcess(CxImage *src,CxImage *dst);
	CString FindExtension(const CString& name);//获取文件后缀名称
	int FindType(const CString& ext);//得到图象类型
};

ImageOperator.cpp

#include "StdAfx.h"
#include "ImageOperator.h"

CImageOperator::CImageOperator(void)
{
}

CImageOperator::~CImageOperator(void)
{
}

/*
*功能说明：拆分TIF
*参数说明：pSrcFileName，表示源图像文件名称；nNo，表示第几个页[从0开始]；dst，表示拆分后的目标图像；pFileName，表示生成拆分图像文件名称
*返回值：bool类型。true,表示成功；flase，表示失败
*/
bool CImageOperator::SplitTif(TCHAR *pSrcFileName,long nNo,CxImage *dst,TCHAR *pFileName)
{
	bool bSucess = true;
	if(pSrcFileName==NULL)
	{
		return false;
	}
	CxImage ciSrc;
	bSucess = ciSrc.Load(pSrcFileName,CXIMAGE_FORMAT_TIF);
	if(!bSucess)
	{
		return false;
	}
	long nFrameCount = ciSrc.GetNumFrames();
	if(nNo>=nFrameCount)
	{
		return false;
	}
	if(dst==NULL)
	{
		dst = new CxImage();
	}
	ciSrc.SetFrame(nNo);
	ciSrc.Load(pSrcFileName,CXIMAGE_FORMAT_TIF);
	if(pFileName==NULL)
	{
		ciSrc.Save(L".//split_tmp.tif",CXIMAGE_FORMAT_TIF);
		dst->Load(L".//split_tmp.tif",CXIMAGE_FORMAT_TIF);
		DeleteFile(L".//split_tmp.tif");
	}
	else
	{
		ciSrc.Save(pFileName,CXIMAGE_FORMAT_TIF);
		dst->Load(pFileName,CXIMAGE_FORMAT_TIF);
	}

	return bSucess;
}

/*
*功能说明：合并TIF
*参数说明：pSrcFileName，表示源图像文件名称；addImage，表示添加图像；nNo，表示在某位置插入图像
*返回值：bool类型。true,表示成功；flase，表示失败
*/
bool CImageOperator::MergeAddTif(TCHAR *pSrcFileName,TCHAR *pAddFileName,long nNo)
{
	bool bSucess = true;
	if(pSrcFileName==NULL)
	{
		return false;
	}
	if(pAddFileName==NULL)
	{
		return true;
	}
	CxImage ciSrc;
	bSucess = ciSrc.Load(pSrcFileName,CXIMAGE_FORMAT_TIF);
	if(!bSucess)
	{
		return false;
	}
	long nSrcImageFrameCount = ciSrc.GetNumFrames();
	CxImage *src = new CxImage[nSrcImageFrameCount];
	long i = 0;
	for(i=0;i<nSrcImageFrameCount;i++)
	{
		ciSrc.SetFrame(i);
		ciSrc.Load(pSrcFileName,CXIMAGE_FORMAT_TIF);
		src[i].Copy(ciSrc);
	}
	CxImage ciAddImage;
	bSucess = ciAddImage.Load(pAddFileName,CXIMAGE_FORMAT_TIF);
	if(!bSucess)
	{
		return false;
	}
	long nAddImageFrameCount = ciAddImage.GetNumFrames();
	CxImage *addImage =  new CxImage[nAddImageFrameCount];
	for(i=0;i<nSrcImageFrameCount;i++)
	{
		ciAddImage.SetFrame(i);
		ciAddImage.Load(pAddFileName,CXIMAGE_FORMAT_TIF);
		addImage[i].Copy(ciAddImage);
	}
	long nFrameCount = nSrcImageFrameCount + nAddImageFrameCount;
	CxImage *srcCombine = new CxImage[nFrameCount];

	CxImage **mulImage;
	mulImage = new CxImage *[nFrameCount];
	if(nNo==-1)
	{
		//在原始图像末尾添加图像
		for( i=0;i < nFrameCount; i++)
		{
			if(i<nSrcImageFrameCount)
			{
				mulImage[i] = &src[i];
			}
			else
			{
				mulImage[i] = &addImage[i-nSrcImageFrameCount];
			}
		}
	}
	else
	{
		//在指定位置添加图像
		if(nNo>=nSrcImageFrameCount)
		{
			//在原始图像末尾添加图像
			for( i=0;i < nFrameCount; i++)
			{
				if(i<nSrcImageFrameCount)
				{
					mulImage[i] = &src[i];
				}
				else
				{
					mulImage[i] = &addImage[i-nSrcImageFrameCount];
				}
			}
		}
		else
		{
			long k = 0,j = 0;
			for( i=0;i < nSrcImageFrameCount; i++)
			{
				if(i==nNo)
				{
					for(j=0;j<nAddImageFrameCount;j++)
					{
						mulImage[k] = &addImage[j];
						k++;
					}

					mulImage[k] = &src[i];
					k++;
				}
				else
				{
					mulImage[k] = &src[i];
					k++;
				}
			}
		}
	}

	FILE* hFile;
	hFile = _wfopen(pSrcFileName,L"w+b");
	srcCombine->Encode(hFile,mulImage, nFrameCount ,CXIMAGE_FORMAT_TIF);
	fclose( hFile );
	delete []srcCombine;
	delete []mulImage;
	delete []src;
	delete []addImage;
	return bSucess;
}

/*
*功能说明：文件图像处理
*参数说明：pSrcFileName，表示原始图像文件；
		   listEffectFrameNo，表示需要处理的页编号列表，用于TIF/GIF图像，如果是其他图像格式就处理整个文件；
		   pDstFileName，表示目标图象文件
*返回值：bool类型。true,表示成功；flase，表示失败
*/
bool CImageOperator::ImageFileProcess(TCHAR *pSrcFileName,list<long> listEffectFrameNo,TCHAR *pDstFileName)
{
	bool bSucess = true;
	//获取图象格式
	CString strExt = FindExtension(pSrcFileName);
	int nImageType = FindType(strExt);
	//加载图象
	CxImage ciSrc;//源图像
	bSucess = ciSrc.Load(pSrcFileName,nImageType);
	if(!bSucess)
	{
		return false;
	}
	CxImage ciDst;//目标图像
	//如果是TIF图象，需要按指定页读取
	if(nImageType==CXIMAGE_FORMAT_TIF || nImageType==CXIMAGE_FORMAT_GIF)
	{
		//将图像分解成桢图像
		long nFrameCount = ciSrc.GetNumFrames();
		CxImage *pAllFrameImage = new CxImage[nFrameCount];
		CxImage **mulImage;
		mulImage = new CxImage *[nFrameCount];
		long i = 0;
		for(i=0;i<nFrameCount;i++)
		{
			ciSrc.SetFrame(i);
			ciSrc.Load(pSrcFileName,nImageType);
			pAllFrameImage[i].Copy(ciSrc);
			mulImage[i] = &pAllFrameImage[i];
		}

		list<long>::iterator iterFrameNo;
		for(iterFrameNo=listEffectFrameNo.begin();iterFrameNo!=listEffectFrameNo.end();++iterFrameNo)
		{
			if(*iterFrameNo>=nFrameCount)
			{
				continue;
			}
			bSucess = ImageProcess(&pAllFrameImage[*iterFrameNo],&ciDst);
			if(!bSucess)
			{
				return false;
			}
			//将目标数据写回ciSrc
			pAllFrameImage[*iterFrameNo].Copy(ciDst);
		}
		//获取目标图象格式,生成新的图像
		CString strDstExt = FindExtension(pDstFileName);
		int nDstImageType = FindType(strDstExt);
		FILE* hFile;
		hFile = _wfopen(pDstFileName,L"w+b");
		bSucess = pAllFrameImage->Encode(hFile,mulImage, nFrameCount ,nDstImageType);
		fclose( hFile );
		if(pAllFrameImage!=NULL)
		{
			delete []pAllFrameImage;
			pAllFrameImage = NULL;
		}
		if(mulImage!=NULL)
		{
			delete []mulImage;
			mulImage = NULL;
		}
	}
	else
	{
		bSucess = ciSrc.Load(pSrcFileName,nImageType);
		if(!bSucess)
		{
			return false;
		}
		bSucess = ImageProcess(&ciSrc,&ciDst);
		if(!bSucess)
		{
			return false;
		}
		//获取目标图象格式,生成新的图像
		CString strDstExt = FindExtension(pDstFileName);
		int nDstImageType = FindType(strDstExt);
		bSucess = ciDst.Save(pDstFileName,nDstImageType);
		if(!bSucess)
		{
			return false;
		}
	}
	return bSucess;
}

/*
*功能说明：图像处理[一些算法的处理，比如提取边缘、膨胀、腐蚀等]
*参数说明：src，表示原始图像；dst，表示目标图象
*返回值：bool类型。true,表示成功；flase，表示失败
*/
bool CImageOperator::ImageProcess(CxImage *src,CxImage *dst)//图像处理
{
	bool bSucess = true;
	//这里书写图像处理的相关代码

	//测试代码，边缘处理
	bSucess = src->Edge();
	if(!bSucess)
	{
		return false;
	}
	//////////////////////////////////////////////////////////

	dst->Copy(*src);
	return bSucess;
}

//获取文件后缀名称
CString CImageOperator::FindExtension(const CString& name)
{
	int len = name.GetLength();
	int i;
	for (i = len-1; i >= 0; i--){
		if (name[i] == '.'){
			return name.Mid(i+1);
		}
	}
	return CString("");
}

//得到图象类型
int CImageOperator::FindType(const CString& ext)
{
	int type = 0;
	if (ext== "bmp" || ext== "BMP")					type = CXIMAGE_FORMAT_BMP;
#if CXIMAGE_SUPPORT_JPG
	else if (ext=="jpg"||ext=="jpeg" || ext=="JPG" || ext=="JPEG")	type = CXIMAGE_FORMAT_JPG;
#endif
#if CXIMAGE_SUPPORT_GIF
	else if (ext == "gif" || ext=="GIF")				type = CXIMAGE_FORMAT_GIF;
#endif
#if CXIMAGE_SUPPORT_PNG
	else if (ext == "png" || ext=="PNG")				type = CXIMAGE_FORMAT_PNG;
#endif
#if CXIMAGE_SUPPORT_MNG
	else if (ext=="mng"||ext=="jng" || ext=="mng" || ext=="jng")	type = CXIMAGE_FORMAT_MNG;
#endif
#if CXIMAGE_SUPPORT_ICO
	else if (ext == "ico" || ext=="ico")				type = CXIMAGE_FORMAT_ICO;
#endif
#if CXIMAGE_SUPPORT_TIF
	else if (ext=="tiff"||ext=="tif" || ext=="TIFF" || ext=="TIF")	type = CXIMAGE_FORMAT_TIF;
#endif
#if CXIMAGE_SUPPORT_TGA
	else if (ext=="tga" || ext=="TGA")				type = CXIMAGE_FORMAT_TGA;
#endif
#if CXIMAGE_SUPPORT_PCX
	else if (ext=="pcx" || ext=="PCX")				type = CXIMAGE_FORMAT_PCX;
#endif
#if CXIMAGE_SUPPORT_WBMP
	else if (ext=="wbmp" || ext=="WBMP")				type = CXIMAGE_FORMAT_WBMP;
#endif
#if CXIMAGE_SUPPORT_WMF
	else if (ext=="wmf"||ext=="emf" || ext=="WMF" || ext=="emf")	type = CXIMAGE_FORMAT_WMF;
#endif
#if CXIMAGE_SUPPORT_J2K
	else if (ext=="j2k"||ext=="jp2" || ext=="J2K" || ext=="JP2")	type = CXIMAGE_FORMAT_J2K;
#endif
#if CXIMAGE_SUPPORT_JBG
	else if (ext=="jbg" || ext=="JBG")				type = CXIMAGE_FORMAT_JBG;
#endif
#if CXIMAGE_SUPPORT_JP2
	else if (ext=="jp2"||ext=="j2k" || ext=="JP2" || ext=="J2K")	type = CXIMAGE_FORMAT_JP2;
#endif
#if CXIMAGE_SUPPORT_JPC
	else if (ext=="jpc"||ext=="j2c" || ext=="JPC" || ext=="J2C")	type = CXIMAGE_FORMAT_JPC;
#endif
#if CXIMAGE_SUPPORT_PGX
	else if (ext=="pgx" || ext=="PGX")				type = CXIMAGE_FORMAT_PGX;
#endif
#if CXIMAGE_SUPPORT_RAS
	else if (ext=="ras" || ext=="RAS")				type = CXIMAGE_FORMAT_RAS;
#endif
#if CXIMAGE_SUPPORT_PNM
	else if (ext=="pnm"||ext=="pgm"||ext=="ppm" || ext=="PNM" || ext=="PGM" || ext=="PPM") type = CXIMAGE_FORMAT_PNM;
#endif
	else type = CXIMAGE_FORMAT_UNKNOWN;

	return type;
}

注：CxImage是一款优秀的图像操作类库。它可以快捷地存取、显示、转换各种图像。

下载地址:[http://www.codeproject.com/KB/graphics/cximage.aspx](http://www.codeproject.com/KB/graphics/cximage.aspx)


