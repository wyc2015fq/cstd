# 区域增长算法递归实现 - 深之JohnChen的专栏 - CSDN博客

2006年05月31日 10:12:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：3858标签：[算法																[byte																[null																[delete](https://so.csdn.net/so/search/s.do?q=delete&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=byte&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[图像处理与识别](https://blog.csdn.net/byxdaz/article/category/144582)


**区域增长算法递归实现**

void RegionGrowTwo(int nSeedX, int nSeedY, BYTE * pUnchInput,BYTE * D, int nWidth, int nHeight, BYTE * pUnRegion,int &iLeft,int & iRight,int & iTop,int & iBottom)
{
  int nDx[] = {-1,1,0,0};
 int nDy[] = {0,0,-1,1};  
 int k=0;
 int nCurrX ;
 int nCurrY ;
 int xx=0,yy=0;
 nCurrX = nSeedX;
 nCurrY = nSeedY;
 if(nCurrX<iLeft)
  iLeft = nCurrX;
 if(nCurrX>iRight)
  iRight = nCurrX;
 if(nCurrY<iTop)
  iTop = nCurrY;
 if(nCurrY>iBottom)
  iBottom = nCurrY;

//  pUnRegion[nCurrY*nWidth+nCurrX] = 255 ;
     // 对当前点的4邻域进行遍历
     int times = 0;
  for (k=0; k<4; k++) 
  { 
   // 4邻域象素的坐标
   xx = nCurrX+nDx[k];
   yy = nCurrY+nDy[k];

   // 判断象素(xx，yy) 是否在图像内部
   // 判断象素(xx，yy) 是否已经处理过
   // pUnRegion[yy*nWidth+xx]==0 表示还没有处理

   // 生长条件：判断象素(xx，yy)和当前象素(nCurrX,nCurrY) 象素值差的绝对值
   if ( (xx < nWidth) && (xx>=0) && (yy>=0) && (yy<nHeight) 
   && (pUnRegion[yy*nWidth+xx]==0) && (pUnchInput[yy*nWidth+xx]==1)) 
   {
    // 同时也表明该象素处理过
    pUnRegion[yy*nWidth+xx] = 255 ;
    if(xx<iLeft)
     iLeft = xx;
    if(xx>iRight)
     iRight = xx;
    if(yy<iTop)
     iTop = yy;
    if(yy>iBottom)
     iBottom = yy;

    RegionGrowTwo(xx,yy,pUnchInput,D,nWidth,nHeight,pUnRegion,iLeft,iRight,iTop,iBottom);  
   }
   else
    times++;
  }

}

/*
*  区域增长，递归实现
* S,源图象
  D,目标图象
 ImageWidth,ImageHeight,表示图象的宽、高
*/
void  RegionGrowOne(BYTE *S,BYTE *D,int ImageWidth,int ImageHeight)
{
 int iLeft=0,iRight=0,iTop=0,iBottom=0;
 int k1,k2,k3,k4,ii1=0,off=0;
 int i=0,j=0;
 LPBYTE lpFlag = new BYTE[ImageWidth*ImageHeight];
 memset(lpFlag,0,ImageWidth*ImageHeight);
 memcpy(D,S,ImageWidth*ImageHeight);
 for (i=0; i<ImageHeight; i++)
 {
  for (j=0; j<ImageWidth; j++)
  {
   if (S[i*ImageWidth+j] == 1 && lpFlag[i*ImageWidth+j] == 0)
   {
    iLeft=65535,iRight=0,iTop=65535,iBottom=0;
    RegionGrowTwo(j,i,S,D,ImageWidth,ImageHeight,lpFlag,iLeft,iRight,iTop,iBottom);
    if((iRight-iLeft)>40 && (iBottom-iTop)>40)  //表示区域大于40*40时就画出边框
    {
     //画边框
     k1 = (iLeft -1 )<0 ?0:(iLeft -1 );
     k2 = (iRight+1)>=ImageWidth?(ImageWidth-1):(iRight+1);
     k3 = (iTop-1)<0?0:(iTop-1);
     k4 = (iBottom+1)>=ImageHeight?(ImageHeight-1):(iBottom+1);
     for(ii1 = k1;ii1 <= k2;ii1++)
     {
      off = ii1 + k3*ImageWidth;
      D[off] = 11;
      off = ii1 + k4*ImageWidth;
      D[off] = 11;
     }
     for(ii1 = k3 ;ii1<=k4;ii1++)
     {
      off = ii1 * ImageWidth + k1;
      D[off] = 11;
      off = ii1 * ImageWidth + k2;
      D[off] = 11;
     }
     /////////////////////////////////////////////////
    }
   }
  }

 }

 if(lpFlag!=NULL)
 {
  delete []lpFlag;
  lpFlag = NULL;
 }

}


