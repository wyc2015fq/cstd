# 网络编程学习小结 - 深之JohnChen的专栏 - CSDN博客

2009年08月29日 13:42:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：65506


几种网络编程方式：

ISAPI、CGI、WinInet、Winsock

它们之间的区别：

1）ISAPI主要是开发基于浏览器客户端与服务器端程序。效率比CGI方式高，而且也扩展了CGI没有的一些功能。（基于TCP/IP模型中的应用层）

2）CGI主要是开发基于浏览器客户端与服务器端程序。（基于TCP/IP模型中的应用层）

3）WinInet主要是开发客户端程序。（基于TCP/IP模型中的应用层）

4）Winsock主要是基于socket来开发客户端与服务器端程序。（基于TCP/IP模型中的各层）要想开发低层协议的程序的话就要了解协议的报文格式。

网络基础知识：

网络硬件

数据通讯原理 (详见[http://download.csdn.net/source/1196517](http://download.csdn.net/source/1196517))

OSI七层网络模型与TCP/IP四层网络模型 （详见[http://bbs.51cto.com/topic/thread-396621.html](http://bbs.51cto.com/topic/thread-396621.html)）

网络原理和协议 （详见[http://www.cnpaf.net/](http://www.cnpaf.net/)）

Winsock

网络编程：

建议，把机械工业出版社出的《Windows网络编程技术》看N遍后，再利用MFC或者SDK编写一些小的通信例程，然后编写较大规模的网络程序，最后你就明白了网络编程了！

《Windows网络编程技术》专门讨论Windows网络编程技术,覆盖Windows
 95/98/NT 4/2000/CE平台。内容包括NetBIOS和Windows重定向器方法、Winsock方法、客户端远程访问服务器方法。本书论述深入浅出、用大量实例详解了微软网络API函数的应用。

《TCP/IP详解,卷1:协议》是一本完整而详细的TCP/IP协议指南。描述了属于每一层的各个协议以及它们如何在不同操作系统中运行。

《网络通信编程实用案例精选》是一本介绍利用vlsuaIC++进行网络通信程序开发的书籍。书中精选了大量网络实例，涵盖了本地汁算机网络编程、局域网网络通信编程、IE编程、网络通信协议编程、串口通信编程、代理服务器编程和高级网络通信编程．

RFC文档目录:http://oss.org.cn/man/develop/rfc/default.htm

ACE：ACE自适配通信环境（ADAPTIVE
   Communication   Environment）是可以自由使用、开放源码的面向对象框架，在其中实现了许多用于并发通信软件的核心模式。ACE提供了一组丰富的可复用C++  Wrapper   Facade（包装外观）和框架组件，可跨越多种平台完成常见的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。ACE资料参考：[http://docs.huihoo.com/ace_tao/index.html](http://docs.huihoo.com/ace_tao/index.html)

建议在[www.codeproject.com](http://www.codeproject.com/)、[http://www.codeguru.com/](http://www.codeguru.com/)网站上找些老外写的网络代码研究研究,最好能参加实际的网络项目，这样能见识更多成熟的网络类库。最好能参加实际的网络项目，这样能见识更多成熟的网络类库。 

** 开源网络封装库** :

ACE,ICE,asio，cppsocket，netclass，poco，SimpleSocket，socketman，Sockets 

开源下载工具 

fdm, eMulePlus，eMule 

开源FTP 

FileZilla 

开源服务器 

Apache 

网游服务器开源框架 

GNE，HawkNL，RakNet，SDL_net 

网络协议分析软件：

Sniffer工具

Wireshark 开源的经典的协议分析工具Wireshark,
[http://www.wireshark.org/](http://www.wireshark.org/)

WPE -------抓包

Ethereal  -------协议分析

SockMon5  -------抓包及错误分析 

Windows网络编程细节问题：
    1.
如果在已经处于 ESTABLISHED状态下的socket(一般由端口号和标志符区分)调用closesocket(一般不会立即关闭而经历TIME_WAIT的过程)后想继续重用该socket:

    BOOL bReuseaddr=TRUE;

setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof

(BOOL));

    2.
如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程:

    BOOL bDontLinger = FALSE;

    setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&bDontLinger,sizeof(BOOL));

    3.在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限:

int nNetTimeout=1000;//1秒

//发送时限

setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char
 *)&nNetTimeout,sizeof(int));

//接收时限

setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char
 *)&nNetTimeout,sizeof(int));

    4.在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);系统默认的状态发送和接收一次为8688字节(约为8.5K);在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发:

//
接收缓冲区

int nRecvBuf=32*1024;//设置为32K

setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));

//发送缓冲区

int nSendBuf=32*1024;//设置为32K

setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));

5.
如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能:

int nZero=0;

setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char
 *)&nZero,sizeof(nZero));

6.同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区):

int nZero=0;

setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char
 *)&nZero,sizeof(int));

7.一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性:

BOOL bBroadcast=TRUE;

setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&bBroadcast,sizeof(BOOL));

8.在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可以设置connect()延时,直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的作用，在阻塞的函数调用中作用不大)

BOOL bConditionalAccept=TRUE;

setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)

&bConditionalAccept,sizeof(BOOL));

9.如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采取的措施是"从容关闭"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体应用的要求(即让没发完的数据发送出去后在关闭socket)?

struct linger {

u_short l_onoff;

u_short l_linger;

};

linger m_sLinger;

m_sLinger.l_onoff=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)

//
如果m_sLinger.l_onoff=0;则功能和B)作用相同;

m_sLinger.l_linger=5;//(容许逗留的时间为5秒)

setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&m_sLinger,sizeof

(linger));

注意点:

      A.在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用;

B.如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0;

10.一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息:

BOOL bDebug=TRUE;

setsockopt(s,SOL_SOCKET,SO_DEBUG,(const char*)&bDebug,sizeof(BOOL));

11.往往通过setsockopt()设置了缓冲区大小，但还不能满足数据的传输需求，一般习惯是自己写个处理网络缓冲的类，动态分配内存。

    12、#include
 <Afxsock.h>，#include<winsock2.h>冲突问题

解决方法：在StdAfx.h
头文件中添加winsock2.h,Afxsock.h

先#include <winsock2.h>
再#include <Afxsock.h>

    13、获取数据包，一般来说想获取数据包可以使用IP_HDRINCL选项，但是在Windows
 2000/XP中setsockopt()中IP_HDRINCL是个不合法的选项，但是可以使用
 WSAIoctl() 函数调用SIO_RCVALL捕获IP数据包。简单步骤如下：
1)、Create
 a raw socket. 

2)、Bind the socket to the local IP over which the traffic is to be sniffed.

3)、WSAIoctl() the socket with SIO_RCVALL to give it sniffing powers.

4)、Put the socket in an infinite loop of recvfrom.

5)、n' joy! the Buffer from recvfrom.

    14、IP、TCP、UDP、ICMP数据包格式
/*The IP header */

typedef struct tagIPHEADER{

 unsigned char version:4;

 unsigned char header_len:4;

 unsigned char tos;

 unsigned short total_len;

 unsigned short ident;

 unsigned short flags;

 unsigned char ttl;

 unsigned char proto;

 unsigned short checksum;

 unsigned int sourceIP;

 unsigned int destIP;

}IPHEADER;

struct TCPPacketHead{

 WORD SourPort;

 WORD DestPort;

 DWORD SeqNo;

 DWORD AckNo;

 BYTE HLen;

 BYTE Flag;

 WORD WndSize;

 WORD ChkSum;

 WORD UrgPtr;

};

struct ICMPPacketHead {

 BYTE Type;

 BYTE Code;

 WORD ChkSum;

};

struct UDPPacketHead {

 WORD SourPort;

 WORD DestPort;

 WORD Len;

 WORD ChkSum;

}; 

15、几种winsock I/O模型比较：

select模型核心就是select函数，它可用于判断套接字上是否存在数据，或者能否向一个套接字写入数据。这个函数可以有效地防止应用程序在套接字处于阻塞模式中时，send或recv进入阻塞状态；同时也可以防止产生大量的WSAEWOULDBLOCK错误select的优势是能够从单个线程的多个套接字上进行多重连接及I/O。

WSAAsyncSelect 模型是以消息机制为基础，能够处理一定的客户连接量，但是扩展性也不是很好。因为消息泵很快就会阻塞，降低了消息处理的速度。WSAAsyncSelect和WSAEventSelect模型提供了读写数据能力的异步通知，但他们不提供异步数据传送，而重叠及完成端口提供异步数据的传送。

WSAEventSelect 模型以时间为基础的网络事件通知，但是与WSAAsyncSelect不同的是，它主要是由事件对象句柄完成的，而不是通过窗口。但是一个线程只能等待64个事件（需要开辟多个线程解决），伸缩性不如完成端口。

重叠模型可以使程序能达到更佳的系统性能。基本设计原理就是让应用程序使用重叠的数据结构，一次投递一个或多个I/O请求。针对这些提交的请求，在他们完成之后，应用程序可为他们提供服务。它又分为两种实现方法：事件通知和完成例程。重叠I/O模型事件通知依赖于等待事件通知的线程数（WSAWaitForMultipleEvents调用的每个线程，该I/O模型一次最多都只能支持6
 4个套接字。），处理客户通信时，大量线程上下文的切换是它们共同的制约因素。

完成端口提供了最好的伸缩性，往往可以使系统达到最好的性能，是处理成千上万的套接字的首选。从本质上说，完成端口模型要求创建一个windows完成端口对象，该对象通过指定数量的线程，对重叠I/O请求进行管理，以便为已经完成的重叠I/O请求提供服务。但是完成端口只是支持NT系统、WIN2000系统。

重叠模型和完成端口模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。
 而select模型、WSAAsyncSelect 模型、WSAEventSelect 模型，数据到达并拷贝到单套接字接收缓冲区中，此时应用程序会被告知可以读入的容量。当应用程序调用接收函数之后，数据才从单套接字缓冲区拷贝到应用程序的缓冲区，差别就体现出来了。

    16、服务器与客户端IO模型选择

对于如何挑选最适合自己应用程序的I/O模型已经很明晰了。同开发一个简单的运行多线程的锁定模式应用相比，其他每种I/O模型都需要更为复杂的编程工作。因此，针对客户机和服务器应用开发模型的选择，有以下原则。

1）. 客户端

若打算开发一个客户机应用，令其同时管理一个或多个套接字，那么建议采用重叠I/O或WSAEventSelect模型

，以便在一定程度上提升性能。然而，假如开发的是一个以Windows为基础的应用程序，要进行窗口消息的管理，那么WSAAsyncSelect模型恐怕是一种最好的选择，因为WSAAsyncSelect本身便是从Windows消息模型借鉴来的。采用这种模型，程序需具备消息处理功能。

2）. 服务器端

若开发的是一个服务器应用，要在一个给定的时间，同时控制多个套接字，建议采用重叠I/O模型，这同样是从性能角度考虑的。但是，如果服务器在任何给定的时间，都会为大量I/O请求提供服务，便应考虑使用I/O完成端口模型，从而获得更佳的性能。

    17、shutdown、closesocket区别

shutdown
从容关闭，为了保证通信双方都能够收到应用程序发出的所有数据，一个合格的应用程序的做法是通知接受双发都不在发送数据！这就是所谓的“正常关闭”套接字的方法，而这个方法就是由shutdown函数,传递给它的参数有SD_RECEIVE,SD_SEND,SD_BOTH三种，如果是SD_RECEIVE就表示不允许再对此套接字调用接受函数。这对于协议层没有影响，另外对于tcp套接字来说，无论数据是在等候接受还是即将抵达，都要重置连接（注意对于udp协议来说，仍然接受并排列传入的数据，因此udp套接字而言shutdown毫无意义）。如果选择SE_SEND,则表示不允许再调用发送函数。对于tcp套接字来说，这意味着会在所有数据发送出并得到接受端确认后产生一个FIN包。如果指定SD_BOTH，答案不言而喻。  

closesocket 正式关闭，关闭连接，释放所有相关的资源。因为无连接协议没有连接，所以不会有正式关闭和从容关闭，直接调用closesocket函数。

18、TCP链接三次握手、终止链接四次握手

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090829/1.JPG)

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090829/2.JPG)

    19、getpeername 、getsockname

getpeername
函数用于获得通信方的套接字地址信息，该信息上关于已建立连接的那个套接字的。
getsockname
函数是getpeername的对应函数。它返回的是指定套接字的本地接口的地址信息。

   
 20、MFC下CSocket编程注意事项

1）、在使用MFC编写socket程序时，必须要包含<afxsock.h>都文件。

2）、AfxSocketInit() 这个函数，在使用CSocket前一定要先调用该函数,否则使用CSocket会出错。

3）、CSocket::Create 的接口就是, 实现上还执行了 CSocket::Bind , 非常不容易被发现。如果是以 Create 方法初始化的前提下不能再调用
 Bind ,要不一定出错。一般写服务器程序都不要用Create 为好,用下面的 

CSocket::Socket
 初始化然后Bind。

   
 21、winsock   有两个不同的版本

winsock  
 有两个不同的版本，第一版很old了，win95时代的，win2000后推崇第二版winsock   2，   出了主板本号外，还有子版本号，这些功能上有差别，winsock2  
 支持原始套接字编程，   MFC   还封装了winsock，使用WINSOCK.h   要用到WSOCK32.LIB，   还有一些扩展api功能，需要MSWSOCK.h  
 MSWSOCK.DLL  。 现在winsock.h  
 winsock2.h   都用ws2_32.lib。

  
 22、sockaddr_in , sockaddr , in_addr区别

struct   sockaddr   {  

                unsigned   short   sa_family;     

                char   sa_data[14];     

        };  

  上面是通用的socket地址，具体到Internet   socket，用下面的结构，二者可以进行类型转换  

  struct   sockaddr_in   {  

                short   int   sin_family;     

                unsigned   short   int   sin_port;     

                struct   in_addr   sin_addr;     

                unsigned   char   sin_zero[8];     

        };  

        struct   in_addr就是32位IP地址。  

        struct   in_addr   {  

                union {

                        struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;

                        struct { u_short s_w1,s_w2; } S_un_w;

                        u_long S_addr; 

                } S_un;

               
 #define s_addr  S_un.S_addr

        };  

   inet_addr()是将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位IP地址(0xC0A80001)。

填值的时候使用sockaddr_in结构，而作为函数（如socket,
 listen, bind等）的参数传入的时候转换成sockaddr结构就行了，毕竟都是16个字符长。

通常的用法是： 

  int   sockfd;  

  struct   sockaddr_in   my_addr;  

  sockfd   =   socket(AF_INET,   SOCK_STREAM,   0);     

  my_addr.sin_family   =   AF_INET;     

  my_addr.sin_port   =   htons(MYPORT);     

  my_addr.sin_addr.s_addr   =   inet_addr("192.168.0.1");  

  bzero(&(my_addr.sin_zero),   8);     

  bind(sockfd,   (struct   sockaddr   *)&my_addr,   sizeof(struct   sockaddr));

想来你是要进行网络编程，使用socket, listen, bind等函数。你只要记住，填值的时候使用sockaddr_in结构，而作为函数的参数传入的时候转换成sockaddr结构就行了，毕竟都是16个字符长。 

   23、几个特殊的地址

INADDR_LOOPBACK  
 (127.0.0.1)   总是代表经由回环设备的本地主机；   INADDR_ANY   

(0.0.0.0)  
 表示任何可绑定的地址；   INADDR_BROADCAST   (255.255.255.255)   表示任何主机。

INADDR_ANY 的具体含义是，绑定到0.0.0.0。此时，对所有的地址都将是有效的，如果系统考虑冗余，采用多个网卡的话，那么使用此种bind，将在所有网卡上进行绑定。在这种情况下，你可以收到发送到所有有效地址上数据包。

例如：

SOCKADDR_IN Local;

Local.sin_addr.s_addr = htonl(INADDR_ANY);

另外一种方式如下：

SOCKADDR_IN Local;

hostent* thisHost = gethostbyname("");

char* ip = inet_ntoa(*(struct in_addr *)*thisHost->h_addr_list); 

Local.sin_addr.s_addr = inet_addr(ip); 

在这种方式下，将在系统中当前第一个可用地址上进行绑定。在多网卡的环境下，可能会出问题。

  
 24、常见协议

FTP协议：[http://blog.csdn.net/superman419/archive/2009/04/10/4063476.aspx](http://blog.csdn.net/superman419/archive/2009/04/10/4063476.aspx)

SMTP协议：[http://www.cnpaf.net/class/smtp/](http://www.cnpaf.net/class/smtp/)

POP3协议：[http://www.cnpaf.net/class/pop3/](http://www.cnpaf.net/class/pop3/)
[http://www.yesky.com/20020305/1600243.shtml](http://www.yesky.com/20020305/1600243.shtml)

ICMP协议：[http://blog.csdn.net/byxdaz/archive/2007/08/01/1720971.aspx](http://blog.csdn.net/byxdaz/archive/2007/08/01/1720971.aspx)

RAS协议：[http://blog.ixpub.net/html/94/10181094-31509.html](http://blog.ixpub.net/html/94/10181094-31509.html)

TAPI协议：[http://blog.csdn.net/chszs/archive/2008/12/08/3475908.aspx](http://blog.csdn.net/chszs/archive/2008/12/08/3475908.aspx)

Telnet协议：[http://www.cnblogs.com/liuweijian/archive/2005/09/12/235493.html](http://www.cnblogs.com/liuweijian/archive/2005/09/12/235493.html)

HTTP协议：[http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html](http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html)

代理协议socks：[http://blog.csdn.net/byxdaz/archive/2010/03/31/5439291.aspx](http://blog.csdn.net/byxdaz/archive/2010/03/31/5439291.aspx)

25、为什么需要htons(), ntohl(), ntohs()，htons() 函数?

在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到htons(), ntohl(), ntohs()，htons()这4个函数。

网络字节顺序与本地字节顺序之间的转换函数：

      htonl()--"Host to Network Long"

      ntohl()--"Network to Host Long"

      htons()--"Host to Network Short"

      ntohs()--"Network to Host Short" 

之所以需要这些函数是因为计算机数据表示存在两种字节顺序：NBO与HBO

网络字节顺序NBO（Network Byte Order）：

      按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。

主机字节顺序（HBO，Host Byte Order）：

      不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。 

如 Intel   x86结构下,short型数0x1234表示为34   12, int型数0x12345678表示为78   56   34   12   

如IBM   power PC结构下,short型数0x1234表示为12   34, int型数0x12345678表示为12   34   56   78

由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power   pc那样的顺序 。在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换。

26、如何查询端口被占用的程序

大家在启动服务器时，有时正常启动有时又启动不了是怎么回事呢？？那为什么关掉迅雷等软件就又好了呢？？现在就来给大家讲解一下，

![](http://hi.csdn.net/attachment/201106/9/0_1307630456vqvv.gif)

[](http://img.blog.163.com/photo/Tl2tguIIMavHqSmPIqmjUg==/1422293057320130173.jpg)

这些端口如果被其他程序占用就不能正常启动，比如有时启动时会提示WEB启动失败，其实就是80端口被占用了，而迅雷等下载软件恰恰就是占用了80端口，关掉就行了。但有时迅雷等都没有开也启动不了，那就是别的东西占用了，那怎么办呢？我来叫你查看端口并关掉的方法。
1.在开始--运行里面输入cmd点回车，会出现运行窗口。
2.在提示符后输入netstat -ano回车，找到tcp
 80端口对应的pid，比如1484.

3.ctrl+alt+del打开任务管理器，选进程，这里有很多正在运行的程序怎么找？别急点上面的查看--选择列--在PID（进程标示符）前面打钩。好了，下面的进程前面都有了PID号码。这时上一步找到的PID就有用了，找到1484，比如PEER.EXE什么的，结束进程吧。这时再开服务器，看WEB可以启动了！

27、TCP连接探测中的Keepalive和心跳包

如何及时有效地检测到一方的非正常断开，一直有两种技术可以运用。一种是由TCP协议层实现的Keepalive，另一种是由应用层自己实现的心跳包。

TCP默认并不开启Keepalive功能，因为开启Keepalive功能需要消耗额外的宽带和流量，尽管这微不足道，但在按流量计费的环境下增加了费用，另一方面，Keepalive设置不合理时可能会因为短暂的网络波动而断开健康的TCP连接。并且，默认的Keepalive超时需要7,200,000 milliseconds，即2小时，探测次数为5次。

对于实用的程序来说，2小时的空闲时间太长。因此，我们需要手工开启Keepalive功能并设置合理的Keepalive参数。

// 开启KeepAlive

BOOL bKeepAlive = TRUE;

int nRet = ::setsockopt(socket_handle, SOL_SOCKET, SO_KEEPALIVE, (char*)&bKeepAlive, sizeof(bKeepAlive));

if (nRet == SOCKET_ERROR)

{

return FALSE;

}

// 设置KeepAlive参数

tcp_keepalive alive_in = {0};

tcp_keepalive alive_out = {0};

alive_in.keepalivetime = 5000;    // 开始首次KeepAlive探测前的TCP空闭时间

alive_in.keepaliveinterval = 1000;  // 两次KeepAlive探测间的时间间隔

alive_in.onoff = TRUE;

unsigned long ulBytesReturn = 0;

nRet = WSAIoctl(socket_handle, SIO_KEEPALIVE_VALS, &alive_in, sizeof(alive_in),

&alive_out, sizeof(alive_out), &ulBytesReturn, NULL, NULL);

if(nRet == SOCKET_ERROR)

{

return FALSE;

}

windows和linux下Keepalive设置方法，参考：http://blog.csdn.net/dongfangyu/article/details/5537781

TCP的keepalive和HTTP的keepalive之间的关系？

TCP 的 SO_KEEPALIVE 确切的应该叫做 is_keep_alive?，它是一个探测服务，由内核完成的。

当一端 recv(socket, ...) 时，如果对端一直没有消息返回，就会一直阻塞，本端根本不知道对端处于什么状态。所以本端可以周期发一个探测包，对端如果一定时间没有返回确认包，则认为对端已经断开连接， recv 会返回，不再继续阻塞。

HTTP 的 keepalive 是双方通过 "Connection: keep-alive" 数据头来建立长连接，每次发送完请求不关闭套接字，而是继续下一次循环的 recv()，等待对端继续发送数据。如果设置了超时时间，那么 recv() 返回，关闭连接。

TCP 的 SO_KEEPALIVE，当网络突然中断时，用来及时探测对端断开，避免无限制阻塞 recv。

HTTP 的 keepalive，是双方约定长连接、还是收完一次数据后立刻关闭套接字。


