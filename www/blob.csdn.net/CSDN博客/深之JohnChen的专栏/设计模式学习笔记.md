# 设计模式学习笔记 - 深之JohnChen的专栏 - CSDN博客

2009年08月07日 22:29:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：6928标签：[设计模式																[decorator																[算法																[iterator																[prototype																[command](https://so.csdn.net/so/search/s.do?q=command&t=blog)](https://so.csdn.net/so/search/s.do?q=prototype&t=blog)](https://so.csdn.net/so/search/s.do?q=iterator&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)](https://so.csdn.net/so/search/s.do?q=decorator&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)
个人分类：[软件工程																[日记博文](https://blog.csdn.net/byxdaz/article/category/144576)](https://blog.csdn.net/byxdaz/article/category/184372)


创建型模式
Singleton：模式解决实体对象个数问题，除Singleton之外，其他创建型模式解决的都是new所带来的耦合关系

。
Factory mothod（工厂方法） 、abstract factory （抽象工厂）、Builder都需要一个额外的工厂类来负责实例化"

易变对象".而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。

结构型模式
Adapter模式注重转换接口，将不吻合的接口适配对接。
Bridge模式注重分离接口与其实现，支持多维度变化。
Composite模式注重统一接口，将“一对多”的关系转化为“一对一”的关系。
Decorator模式注重稳定接口，在此前提下为对象扩展功能。
Facade模式注重简化接口，简化组件系统与外部客户程序的依赖关系。
Flyweight模式注重保留接口，在内部使用共享技术对对象存储进行优化。
Proxy模式注重假借接口，增加间接层来实现灵活控制。

行为型模式
Template Method模式封装算法结构，支持算法子步骤变化。
Strategy模式注重封装算法,支持算法的变化。
State模式注重封装与状态相关的变化，支持状态的变化。
Memento模式注重封装对象状态的变化，支持状态保存/恢复。
Mediator模式注重封装对象间的交互，支持对象交互的变化。
Chain Of Responsibility模式注重封装对象责任，支持责任的变化。
Command模式注重将请求封装为对象，支持请求的变化。
Iterator模式注重封装集合对象内部结构，支持集合的变化。
Interpreter模式注重封装特定领域变化，支持领域问题的频繁变化。
Observer模式注重封装对象通知，支持通信对象的变化。
Visitor模式注重封装对象操作变化，支持在运行时为类层次结构动态添加新的操作。

设计模式总结视频:[http://download.csdn.net/source/1409917](http://download.csdn.net/source/1409917)设计模式书籍：[http://download.csdn.net/source/179573](http://download.csdn.net/source/179573)
设计模式代码：[http://download.csdn.net/source/583857](http://download.csdn.net/source/583857)


