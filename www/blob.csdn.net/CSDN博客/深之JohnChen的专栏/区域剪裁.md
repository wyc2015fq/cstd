# 区域剪裁 - 深之JohnChen的专栏 - CSDN博客

2009年05月19日 10:44:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：1612标签：[byte																[delete																[null](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=delete&t=blog)](https://so.csdn.net/so/search/s.do?q=byte&t=blog)
个人分类：[图像处理与识别](https://blog.csdn.net/byxdaz/article/category/144582)


区域剪裁是指从图像中裁减一部分区域，按照规定的大小输出区域图像。 

//函数功能：区域剪裁
//参数说明：iSrc，表示原图像
//iDst，表示目标图像
//rect，表示需要剪裁的区域
//nStdWidth，表示目标图象的高度
//nStdHeight，表示目标图象的宽度
//nType，表示填充类型[1，表示白色；2，表示黑色；3，表示原始图像对应的颜色]
//返回值说明：BOOL 类型，TRUE，表示操作成功；FLASE，表示操作失败。
BOOL CutImage(CxImage* iSrc ,RECT rect, int nStdWidth, int nStdHeight,CxImage* iDst,int nType)
{
  LONG nWidth,nHeight,nEffectWidth,nBpp,nXDpi,nYDpi,nNewEffectWidth;
  nWidth = iSrc->GetWidth();
  nHeight = iSrc->GetHeight();
  nEffectWidth = iSrc->GetEffWidth();
  nBpp = iSrc->GetBpp();
  nXDpi = iSrc->GetXDPI();
  nYDpi = iSrc->GetYDPI();
  nNewEffectWidth = (nStdWidth * nBpp + 31)/32 * 4;
  BYTE *pData = new BYTE[nNewEffectWidth*nStdHeight+1];

  BYTE *pSrc = iSrc->GetBits();
  int i = 0,j = 0,nOffset = 0,nMid1 = 0,nMid2 = 0,nNewOffset = 0;
  nMid1 = (rect.right - rect.left)/2;
  nMid2 = (rect.bottom - rect.top)/2;
  //int nLeft = (nStdWidth/2 - nMid1)>=0?(nStdWidth/2 - nMid1):0;
  //int nUp = (nStdHeight/2 - nMid2)>=0?(nStdHeight/2 - nMid2):0;
  int nLeft = nStdWidth/2 - nMid1;
  int nUp = nStdHeight/2 - nMid2;
  RECT rect2;
  /*if(nLeft<0)
  {
   rect2.left = rect.left-nLeft/2;
   rect2.right = rect.right +nLeft/2;
  }
  else
  {
   rect2.left = rect.left;
   rect2.right = rect.right;
  }

  if(nUp<0)
  {
     rect2.top = rect.top - nUp/2;
  rect2.bottom = rect.bottom + nUp/2;
  }
  else
  {
  rect2.top = rect.top;
  rect2.bottom = rect.bottom;     
  }
*/

  if(1==nType)
  {
   memset(pData,255,sizeof(BYTE)*(nNewEffectWidth*nStdHeight+1));
  }
  if(2==nType)
  {
   memset(pData,0,sizeof(BYTE)*(nNewEffectWidth*nStdHeight+1));
  }
  if(3==nType)
  {
   memset(pData,128,sizeof(BYTE)*(nNewEffectWidth*nStdHeight+1));
   POINT ptCenter;
   ptCenter.y = (rect.top+rect.bottom)/2;
   ptCenter.x = (rect.left+rect.right)/2;
   for(j=0;j<nStdHeight;j++)
   {
    for(i=0;i<nStdWidth;i++)
    {
               nNewOffset = j * nNewEffectWidth + (nBpp/8) * i;
      if(nNewOffset<0)
       continue;
               nOffset = (ptCenter.y+j-nStdHeight/2)*nEffectWidth + (nBpp/8) * (ptCenter.x + i - nStdWidth/2); 
      if(nOffset<0)
       continue;
      if((ptCenter.x + i - nStdWidth/2)>=nWidth)
       continue;
      if((ptCenter.x + i - nStdWidth/2)<0)
       continue;
      if((ptCenter.y+j-nStdHeight/2)>=nHeight)
       continue;
      if((ptCenter.y+j-nStdHeight/2)<0)
       continue;
      if(nBpp==24)
      {
       pData[nNewOffset] = pSrc[nOffset];
       pData[nNewOffset+1] = pSrc[nOffset+1];
       pData[nNewOffset+2] = pSrc[nOffset+2];
      }
      else
      {
       pData[nNewOffset] = pSrc[nOffset];
       BYTE t =  pSrc[nOffset];
      }
    }
   }
  }

  for(i=rect.top;i<=rect.bottom && i<nHeight;i++)
  {
   for(j=rect.left;j<=rect.right && j<nWidth;j++)
   {
    nOffset = i * nEffectWidth + (nBpp/8) * j;
    if(nOffset<0)
    continue;
    nNewOffset = (nUp+i-rect.top) * nNewEffectWidth + (nBpp/8) * (nLeft + j - rect.left);
    if(nNewOffset<0)
    continue;
    if((nUp+i-rect.top)>=nStdHeight)
     continue;
    if((nUp+i-rect.top)<0)
     continue;
    if((nLeft+j-rect.left)>=nStdWidth)
     continue;
    if((nLeft+j-rect.left)<0)
     continue;
    if(nBpp==24)
    {
     pData[nNewOffset] = pSrc[nOffset];
     pData[nNewOffset+1] = pSrc[nOffset+1];
     pData[nNewOffset+2] = pSrc[nOffset+2];
    }
    else
    {
     pData[nNewOffset] = pSrc[nOffset];
    }
   }
  }

  if(4==nType)
  {
   POINT ptCenter,ptCenter2;
   ptCenter.y = (rect.top+rect.bottom)/2;
   ptCenter.x = (rect.left+rect.right)/2;
   RECT rectOutDege;
      rectOutDege.left = (ptCenter.x - nStdWidth/2)>=0?(ptCenter.x - nStdWidth/2):0;
   rectOutDege.right = (ptCenter.x + nStdWidth/2)>=0?(ptCenter.x + nStdWidth/2):0;
   rectOutDege.top = (ptCenter.y - nStdHeight/2)>=0?(ptCenter.y - nStdHeight/2):0;
   rectOutDege.bottom = (ptCenter.y + nStdHeight/2)>=0?(ptCenter.y + nStdHeight/2):0;
   ptCenter2.y = (rectOutDege.top+rectOutDege.bottom)/2;
   ptCenter2.x = (rectOutDege.left+rectOutDege.right)/2;
   int m,n;
   for(j=rectOutDege.top;j<rect.top;j++)
   {
    for(i=rectOutDege.left;i<rectOutDege.right;i++)
    {
     nNewOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i-rectOutDege.left);
     if(nNewOffset<0)
      continue;
              if(i<rect.left)
     {
      nOffset = (rect.top-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.left - rectOutDege.left);
     }
     else if(i>rect.right)
     {
      nOffset = (rect.top-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.right - rectOutDege.left);
     }
     else
     {
      nOffset = (rect.top-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i - rectOutDege.left);
     }
     if(nOffset<0)
      continue;
     if(nBpp==24)
     {
      pData[nNewOffset] = pData[nOffset];
      pData[nNewOffset+1] = pData[nOffset+1];
      pData[nNewOffset+2] = pData[nOffset+2];
     }
     else
     {
      pData[nNewOffset] = pData[nOffset];
     }
    }
   }

   for(j=rect.bottom;j<rectOutDege.bottom;j++)
   {
    for(i=rectOutDege.left;i<rectOutDege.right;i++)
    {
     nNewOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i-rectOutDege.left);
     if(nNewOffset<0)
      continue;
     if(i<rect.left)
     {
      nOffset = (rect.bottom - rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.left-rectOutDege.left); 
     }
     else if(i>rect.right)
     {
      nOffset = (rect.bottom - rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.right-rectOutDege.left); 
     }
     else
     {
      nOffset = (rect.bottom - rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i - rectOutDege.left); 
     }
     if(nOffset<0)
      continue;
     if(nBpp==24)
     {
      pData[nNewOffset] = pData[nOffset];
      pData[nNewOffset+1] = pData[nOffset+1];
      pData[nNewOffset+2] = pData[nOffset+2];
     }
     else
     {
      pData[nNewOffset] = pSrc[nOffset];
     }
    }
   }

   for(i=rectOutDege.left;i<rect.left;i++)
   {
    for(j=rectOutDege.top;j<rectOutDege.bottom;j++)
    {
     nNewOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i-rectOutDege.left);
     if(nNewOffset<0)
      continue;
     if(j<rect.top)
     {
      nOffset = (rect.top-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.left-rectOutDege.left); 
     }
     else if(j>rect.bottom)
     {
      nOffset = (rect.bottom-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.left-rectOutDege.left); 
     }
     else
     {
      nOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.left-rectOutDege.left); 
     }
     if(nOffset<0)
      continue;
     if(nBpp==24)
     {
      pData[nNewOffset] = pData[nOffset];
      pData[nNewOffset+1] = pData[nOffset+1];
      pData[nNewOffset+2] = pData[nOffset+2];
     }
     else
     {
      pData[nNewOffset] = pData[nOffset];
     }
    }
   }

   for(i=rect.right;i<rectOutDege.right;i++)
   {
    for(j=rectOutDege.top;j<rectOutDege.bottom;j++)
    {
     nNewOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (i-rectOutDege.left);
     if(nNewOffset<0)
      continue;
     if(j<rect.top)
     {
      nOffset = (rect.top-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.right-rectOutDege.left); 
     }
     else if(j>rect.bottom)
     {
      nOffset = (rect.bottom-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.right-rectOutDege.left); 
     }
     else
     {
      nOffset = (j-rectOutDege.top) * nNewEffectWidth + (nBpp/8) * (rect.right-rectOutDege.left); 
     }
     if(nOffset<0)
      continue;
     if(nBpp==24)
     {
      pData[nNewOffset] = pData[nOffset];
      pData[nNewOffset+1] = pData[nOffset+1];
      pData[nNewOffset+2] = pData[nOffset+2];
     }
     else
     {
      pData[nNewOffset] = pData[nOffset];
     }
    }
   }

  }

  CxImage tmp;
  tmp.Copy(*iSrc);
  tmp.Create(nStdWidth,nStdHeight,nBpp,iSrc->GetType());
  tmp.SetPalette(iSrc->GetPalette());
  COLORREF color;
  for(i=0;i<nStdHeight;i++)
  {
   for(j=0;j<nStdWidth;j++)
   {
         nOffset = i * nNewEffectWidth + (nBpp/8) * j; 
   if(nBpp==24)
   {
    color = RGB(pData[nOffset+2],pData[nOffset+1],pData[nOffset]);
    tmp.SetPixelColor(j,i,color);
   }
   else
   {
    tmp.SetPixelIndex(j,i,pData[nOffset]);
   }
   }
  }

  if(iDst)
   iDst->Transfer(tmp);
  else
   iSrc->Transfer(tmp);
  if(pData)
  {
   delete []pData;
   pData = NULL;
  }
  return TRUE;
}

