# 如何判断CPU是大端还是小端模式 - 深之JohnChen的专栏 - CSDN博客

2015年10月09日 10:09:51[byxdaz](https://me.csdn.net/byxdaz)阅读数：5536



## 如何判断CPU是大端还是小端模式

http://blog.sina.com.cn/s/blog_66a61f310100i7m0.html

MSB:Most Significant Bit  ------- 最高有效位
    LSB:Least Significant Bit ------- 最低有效位

**　　大端模式（big-edian）**
　　big-endian：MSB存放在最低端的地址上。

举例，双字节数0x1234以big-endian的方式存在起始地址0x00002000中：

        | data |<-- address
        | 0x12 |<-- 0x00002000
        | 0x34 |<-- 0x00002001

　　在Big-Endian中，对于bit序列中的序号编排方式如下（以双字节数0x8B8A为例）：

        ----+---------------------------------------------------+
        bit | 00 01 02 03 04 05 06 07 | 08 09 10 11 12 13 14 15 |
        ----+MSB---------------------------------------------LSB+
        val |  1  0  0  0  1  0  1  1 |  1  0  0  0  1  0  1  0 |
        ----+---------------------------------------------------+
        = 0x8B8A 

**　　小端模式(little-endian)**

　　little-endian：LSB存放在最低端的地址上。

　　举例，双字节数0x1234以little-endian的方式存在起始地址0x00002000中：

        | data |<-- address
        | 0x34 |<-- 0x00002000
        | 0x12 |<-- 0x00002001

　　在Little-Endian中，对于bit序列中的序号编排和Big-Endian刚好相反，其方式如下（以双字节数0x8B8A为例）：

        ----+---------------------------------------------------+
        bit | 15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00 |
        ----+MSB---------------------------------------------LSB+
        val |  1  0  0  0  1  0  1  1 |  1  0  0  0  1  0  1  0 |
        ----+---------------------------------------------------+
        = 0x8B8A

c) 网络字节序：**TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。**

网络字节顺序是“所见即所得”的顺序。而Intel类型的CPU的字节顺序与此相反。

比如上面的 short B=0102H(十六进制，每两位表示一个字节的宽度）。所见到的是“0102”，按一般数学常识，数轴从左到右的方向增加，即内存地址从左到右增加的话，在内存中这个 short B的字节顺序是：

01 02

这就是网络字节顺序。所见到的顺序和在内存中的顺序是一致的！

我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。
Note:采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。

    在ARM体系中，每个字单元包含4个字节单元或者两个半字单元。在字单元中，4个字节哪一个是高位字节，哪一个是低位字节则有两种不同的格式：big-endian和little-endian格式。在小端模式中，低位字节放在低地址，高位字节放在高地址；在大端模式中，低位字节放在高地址，高位字节放在低地址。

在C语言中，不同于结构体，共用体（联合体）中的几种不同类型的变量存放在同一段内存单元中。利用这一特点，可以用联合体变量判断ARM或x86环境下，存储系统是是大端还是小端模式。

#include "stdio.h"

int main()

{

  union w

 {

  int a;  //4 bytes

  char b; //1 byte

 } c;

  c.a=1;

  if (c.b==1)

  printf("It is Little_endian!\n");

  else

  printf("It is Big_endian!\n");

  return 1;

}

说明：

1  在c中，联合体（共用体）的数据成员都是从低地址开始存放。

2  若是小端模式，由低地址到高地址c.a存放为0x01 00 00 00，c.b被赋值为0x01；

  ————————————————————————————

   地址 0x00000000 0x00000001 0x00000002 0x00000003

   c.a  01         00         00         00

   c.b  01         00        

  ————————————————————————————  

3  若是大端模式，由低地址到高地址c.a存放为0x00 00 00 01，c.b被赋值为0x0；

  ———————————————————————————— 

   地址 0x00000000 0x00000001 0x00000002 0x00000003

   c.a  00         00         00         01

   c.b  00         00                 

  ————————————————————————————  

4  根据c.b的值的情况就可以判断cpu的模式了，现在XP环境下的intel CPU是小端模式，不信你可测试下！

的确判别一个 系统 是大头序还是小头序的方法是有的。 

比如： 

-BEGIN- 

int x=1; // 0x00000001 

if (*(char*)&x) { 

/* little endian. memory image 01 00 00 00 */ 

}else{ 

/* big endian. memory image 00 00 00 01 */ 

} 

-END- 

内存数据（0x00000001）-〉大头/小头字符序-〉数值（1） 

这里判别的前提条件是知道内存数据及所对应的数值，所以可以判定出大小头字符序。   

另外参考：http://www.cnblogs.com/wxxweb/archive/2011/06/28/2092108.html

参考：大小端转换函数 http://blog.csdn.net/ysdaniel/article/details/6772392


