# 几种换肤软件使用问题 - 深之JohnChen的专栏 - CSDN博客

2006年01月15日 15:15:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：5726


**几种换肤软件的使用和使用中的BUG**
                                                                                                                                      johnchen

  最近由于要修改程序的界面，自己也不想扩展一些类来子类化控件来实现换肤，所以在网上找了一些换肤软件拿来用。使用了AppFace和SkinMagic工具包换皮肤。但是感觉都不是太好，也不知道有没有开源的换肤工具包。现在来说说这两个软件好处和不足。
1。AppFace For VC 支持Win9X/NT/2K/XP,UNICODE/ANSI,能够对目标进程里的所有Widows标准控件,系统菜单,通用对话框等实现换肤，对非商业用途而言，它是完全免费的。关键的是AppFace的使用非常简单,很容易添加到已有的工程中。对于没有注册的用户可以使用BASIC SKIN；若要使用POWERFUL SKIN等皮肤的话只有90天的使用期。对于注册的用户没有限制。我使用AppFace换肤之后发现程序刷新很严重，有点闪的感觉。

2。使用SkinMagic Toolkit美化界面，比较好用没有出现程序刷新很严重的问题，但是对于没有注册的用户有限制，标题出现 [Powered by SkinMagic] 的问题；我在[www.vckbase.com](http://www.vckbase.com/)下了个破解版，虽然没有出现 [Powered by SkinMagic] 的问题，但是点击关闭按钮没有作用，还有位图按钮也不见问题，最严重的是在WIN 2000/XP/2003上是可以运行的，可是在WIN 98上运行不了。这些可能是没有注册为正式版的原因吧。注册的软件应该没有问题吧，反正我没有注册过也不知道。

下面讲讲它们的使用方法：

**AppFace**

1。AppFace For VC 支持Win9X/NT/2K/XP,UNICODE/ANSI,能够对目标进程里的所有Widows标准控件,系统菜单,通用对话框等实现换肤，对非商业用途而言，它是完全免费的。关键的是AppFace的使用非常简单,很容易添加到已有的工程中。我使用的是 0.2 版,你也可以到它的网站 [http://www.appface.com](http://www.appface.com/) 去下载最新版本 。 
　　AppFace 支持三种皮肤加载方式,从磁盘文件加载，从资源加载，从内存加载。下面我就说说如何从资源加载URF皮肤文件:
　　首先，要确保你下载了AppFace for VC 开发包，我们要用到其中的三个文件: "appface.h", "appface.dll" ,"gtclassic.urf" 。
　　接着，创建一个 VC 可执行文件工程, MDI/SDI/DIALOG/WIN32 类型的都可以,我以创建一个DIALOG 工程 ResSkin 进行说明 。将"appface.h" 拷贝到该工程目录下,将"Appface.dll"拷贝到该工程的输出目录下,例如:"debug/",将"gtclassic.urf"拷贝到资源所在目录下 。在VC 的项目管理器中进入资源管理项,在右键菜单中选择"Import",将"gtclassic.urf"添加进工程,资源类型设定为: "MYRESTYPE",资源ID设定为"IDR_MY_URF"。注意:资源ID 前面一定要加双引号 。 
准备工作全部完成了,现在进入正题: 

1、在ResSkin.cpp 中加入: #include "appface.h" 
2、在CResSkinApp::InitInstance() 成员函数中添加如下代码 
CResSkinApp::InitInstance()
        {
        ...
        CAppFace af ; //line 1
        af.Start(_T("IDR_MY_URF"),GTP_LOAD_RESOURCE,NULL,_T("MYTYPE"),NULL) 
        ; //line 2
      CResSkinDlg dlg;
        m_pMainWnd = &dlg;
        int nResponse = dlg.DoModal();
      ...
        af.Remove() ; //line 3
      }

编译... 
3、上面是官方的做法,由于appface 也支持从内存中加载urf,所以您也可以这样做: 
      CResSkinApp::InitInstance()
        {
        ...
        CAppFace af ; //Init
      //Load
        if(HRSRC hr = ::FindResource(NULL,"IDR_MY_URF","MYTYPE"))
        {
        ULONG nResSize = ::SizeofResource(NULL,hr) ;
        if(HGLOBAL hz = ::LoadResource(NULL,hr))
        {
        char* p = (char*)LockResource(hz);
        if(p)
        af.Start(p,GTP_LOAD_MEMORY,nResSize,NULL,NULL) ;
        } 
        }
      CResSkinDlg dlg;
        m_pMainWnd = &dlg;
        int nResponse = dlg.DoModal();
      ...
        af.Remove() ; //Release
      }

你可以使用这种方法从资源中加载其它数据。 
　　需要注意的是: 如果将URF添加进资源时,资源ID没有用双引号括起来, 加载时必须这样写：
af.Start(_T("IDR_MY_URF"),GTP_LOAD_RESOURCE,NULL,MAKEINTRESOURCE(_T("MYTYPE")),NULL)) ; 
//line 2 

![](http://www.vckbase.com/document/journal/vckbase37/images/resskin1.jpg)
运行效果图

# SkinMagic Toolkit 1、将SkinMagicTrial.dll放置在调试目录  2、设置库文件目录，在项目[连接器]的[附加依赖项]中加入库SkinMagicTrial.lib3、在项目的stdafx.h文件中加入头文件 #include "SkinMagicLib.h"  [创建过程]  1、初始化SkinMagic库：  要使用SkinMagic，这一步必不可少。在应用程序类的InitInstance()函数中行加入如下代码（粗体部分）：  CWinApp::InitInstance();  VERIFY( 1 == InitSkinMagicLib(AfxGetInstanceHandle(), NULL ,   NULL, NULL ));  说明:  int InitSkinMagicLib( //初始化SkinMagic工具库  HINSTANCE hInstance, //应用程序句柄  char* szApplication , //皮肤文件中定义的应用程序名，置为NULL即可  char* szRegCode, //SkinMagic的使用注册码。若无置为NULL  char* szReserved2 //保留位，为NULL  );  2、调入皮肤文件：  皮肤的调用有两种方法，一是直接从皮肤文件中调用，另一种方法是从资源文件中调用，分别说明如下：  1）从皮肤文件中调用皮肤：紧接上句，加入如下代码  VERIFY( 1 == LoadSkinFile("corona.smf"));  2）从资源文件中调用皮肤：  VERIFY(1 == LoadSkinFromResource(NULL,"FUTURA","skin"));  说明：int LoadSkinFromResource(  HMODULE hModule, //包含皮肤文件的模块句柄，若NULL表面在本模块中 char* lpSkinName , //皮肤资源的名称char* lpType); //资源的类型  3、为窗口添加皮肤：  １）为标准窗口（拥有标题栏、系统菜单、可变大小等特征，比如文档/视图结构和有菜单的对话框）添加皮肤，通常用于主窗口。在应用程序类的InitInstance()函数的底部加入如下代码：  VERIFY( 1 == SetWindowSkin( m_pMainWnd->m_hWnd , "MainFrame" ));  m_pMainWnd->ShowWindow(SW_SHOW);  m_pMainWnd->UpdateWindow();  说明：  int SetWindowSkin(  HWND hWnd, //要使用皮肤的窗口句柄  char* lpSkinName //为skinFrameWnd对象指定的名称  );  2）为对话框添加皮肤  在对话框显示之前调用，通常在应用程序初始化函数中调用  VERIFY( 1 == SetWindowSkin( m_pMainWnd->m_hWnd , "MainFrame" ));  VERIFY( 1 == SetDialogSkin( "Dialog" ) );  m_pMainWnd->ShowWindow(SW_SHOW);  m_pMainWnd->UpdateWindow();  说明：  int SetDialogSkin(   char* lpSkinName //为skinFrameWnd对象指定的名称  );  使用该函数后，以后程序创建的对话框都将使用该皮肤，但对话框大小不可变。

 3）为单个对话框窗口添加皮肤，例如在对话框视图中：重载对话框视图的创建函数OnCreate，加入如下代码：

  VERIFY( 1 == SetSingleDialogSkin( m_hWnd, "Dialog" ) );
EnableWindowScrollbarSkin( m_hWnd , SB_BOTH );

  说明：

  int SetSingleDialogSkin(
  HWND hWnd, //要使用皮肤的窗口句柄
  char* lpSkinName //为skinFrameWnd对象指定的名称
  );
  int EnableWindowScrollbarSkin( //为滚动条添加皮肤
  HWND hWnd, //要使用皮肤的窗口句柄
  int* fnBar //要使用皮肤的滚动条,SB_BOTH表明是横竖都是用皮肤
  );

  4、释放SkinMagic资源

  重载应用程序的ExitInstance()函数，添加如下代码：

  ExitSkinMagicLib();

运行效果图：
![](http://www.vckbase.com/document/journal/vckbase28/images/UsingSkinMagicimg2.gif)

