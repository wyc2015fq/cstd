# C#学习笔记18——.NET 事务处理 - 深之JohnChen的专栏 - CSDN博客

2011年09月01日 23:25:01[byxdaz](https://me.csdn.net/byxdaz)阅读数：1591


事务处理是在数据处理时经常遇到的问题，经常用到的方法有以下3种总结整理如下：

方法1：直接写入到sql 中在存储过程中使用 BEGIN TRANS, COMMIT TRANS,ROLLBACK TRANS 实现。优点：事务逻辑包含在一个单独的调用中，有运行一个事务的最佳性能，立于应用程序。限制： 事务上下文仅存在于数据库调用中，数据库代码与数据库系统有关。

例如 

BEGIN TRANS 

DECLARE @orderDetailsError int,@productError int 

DELETE FROM ""OrderDetails"" WHERE ProductID=42 

SELECT @orderDetailsError = @@ERROR 

DELETE FROM Products WHERE ProductID=42 

SELECT @productError = @@ERROR 

IF @orderDetailsError = 0 AND @productError= 0 

COMMIT TRANS 

ELSE 

ROLLBACK TRANS 

方法2 ：使用ADO.NET 实现 

使用ADO.NET 实现，使用这种方式的优点是可以在中间层来管理事务，当然你也可以选择在数据层来实现。SqlConnection 和OleDbConnection 对象有一个 BeginTransaction 方法，它可以返回 SqlTransaction 或者OleDbTransaction 对象。而且这个对象有 Commit 和 Rollback 方法来管理事务， 本例为更新数据库中某张表的一个示例。
DataTable dt = new DataTable(); 
System.Data.SqlClient.SqlConnection cnn = newSystem.Data.SqlClient.SqlConnection("连接字符串"); 
System.Data.SqlClient.SqlCommand cm = new System.Data.SqlClient.SqlCommand(); 
cm.Connection = cnn; 
cnn.Open(); 
System.Data.SqlClient.SqlTransaction trans = cnn.BeginTransaction(); 
try 
{ 
foreach(DataRow dr in dt.Rows) 
{ 
cm.CommandText = "update [表] set [数量] = @amount where productID = @productID"; 
cm.Parameters.Add("@amount",SqlDbType.Int); 
cm.Parameters["@amount"].Value =Convert.ToInt32(dr["amount"]); 
cm.Parameters.Add("@productID",SqlDbType.VarChar); 
cm.Parameters["@productID"].Value =dr["productID"].ToString(); 
cm.ExecuteNonQuery(); 
} 
trans.Commit(); 
} 
catch 
{ 
trans.Rollback(); 
} 
finally 
{ 
cnn.Close(); 
trans.Dispose(); 
cnn.Dispose(); 
} 
}

优点: 简单性 和数据据事务差不多的快 独立于数据库，不同数据库的专有代码被隐藏了 缺点: 事务不能跨越多个数据库连接 事务执行在数据库连接层上，所以需要在事务过程中维护一个数据库连接ADO.NET分布事务也可以跨越多个数据库，但是其中一个SQL SERVER 数据库的话，通过用SQL SERVER连接服务器连接到别的数据库，但是如果是在DB2和Orcal之间就不可以。 以上两种事务是经常用到的事务处理方法。

在开始一个事务处理时，可以选择在该事务处理中执行的命令独立级别。该级别确定了如何在一个数据库会话中查看在另一个数据库会话中所进行的修改，并不是所有的数据库引擎都支持以下4个级别。SQL Server的默认独立级别ReadCommitted是数据一致性和数据可用性的一种很好的折衷，因为它比RepeatableRead或 Serializable模式中需要的数据锁定都少。但是，有时应提高独立级别，这样在.NET中，才能用一种非默认的级别开始事务处理。使用哪个级别没有硬性规则，全凭经验。
|独 立  级 别|说 明|
|----|----|
|ReadCommitted|SQL Server默认级别。这个级别可以确保只有第一个事务处理结束后，在第二个事务处理中才能访问第一个事务处理写入的数据|
|ReadUncommitted|即使一个事务处理还没有处理完数据，也允许另一个事务处理从数据库中读取数据。例如，如果两个用户在访问同一个数据库，第一个用户插入一些数据，但没有完成事务处理(通过Commit或Rollback方法)，第二个用户把它们的独立级别设置为ReadUncommitted，因此可以访问数据|
|RepeatableRead|这个级别扩展了ReadCommitted级别，如果在事务处理中使用了相同的语句，无论是否有其他潜在的数据库更新，总是可以返回相同的数据。这个级别要求对数据进行额外的锁定，这会降低性能。  这个级别可以保证，对于初始查询的每一行，都不会修改数据，但允许显示“假想(phantom)”行—— 这些行是在进行事务处理时，由另一个事务处理插入的全新数据行|
|Serializable|这是最“高级”的事务处理级别，对数据库中的数据进行序列化的访问。利用这种独立级别，不会显示假想行，所以在序列化的事务处理中使用的SQL语句总是检索相同的数据。序列化事务处理对性能的负面影响不应低估，如果肯定不需要这个独立级别，最好不要加上它|

方法3 COM+事务（分布式事务）

.NET Framework 依靠 MTS/COM+ 服务来支持自动事务。COM+ 使用 Microsoft Distributed TransactionCoordinator (DTC) 作为事务管理器和事务协调器在分布式环境中运行事务。这样可使 .NET 应用程序运行跨多个资源结合不同操作 定义一个COM+事务处理的类TransactionScope scope = new TransactionScope(TransactionScopeOption.Required)TransactionOption枚举类型支持5个COM+值（Disabled,NotSupported,Required,RequiresNew,Supported）Disabled 忽略当前上下文中的任何事务。 NotSupported 使用非受控事务在上下文中创建组件。 Required 如果事务存在则共享事务，并且如有必要则创建新事务。RequiresNew 使用新事务创建组件，而与当前上下文的状态无关。 Supported 如果事务存在，则共享该事务。一般来说COM+中的组件需要Required 或Supported。当组件用于记录或查帐时RequiresNew 很有用，因为组件应该与活动中其他事务处理的提交或回滚隔离开来。

以下是COM+事务处理的一个示例： 

分布式事务实例

static void Main(string[] args)
{
//如果存在事务则使用该事务，不存在则创建新事务
using (TransactionScope scope = newTransactionScope(TransactionScopeOption.Required))
{
try
{
Program p = new Program();
p.add1();
p.add2();
//没有异常则提交
scope.Complete();
Console.WriteLine("插入成功");
Console.ReadLine();
}
catch (Exception)
{
//出现异常则回滚
scope.Dispose();
Console.WriteLine("插入失败");
Console.ReadLine();
}
}

}

//使用以上COM+事务，必须启动控制面板中管理工具中服务的MS DTC（DistributedTransaction Coordinator） 首先我们要明白什么是分布式事务，如果所有数据的修改仅依靠单个数据源就能完成，则这个事务就相当简单了。然而，随着商业需求的日益增加，应用程序变得越来越复杂，经常需要访问多个数据库，这些数据库通常分布在不同的地方，这就是分布式事务。而COM+正好满足了我们的需求，我们仍然以上面的示例做说明，如果上面示例的两个测试方法中连接字符串分别连接的是不同的两个数据库，那么当修改其中一个数据库时另一个数据库也将被修改，但是事务中的每个数据源必须装有MS DTC，MSDTC最先集成在SQL Server中，现在已成为COM+必不可少的部分，通过在事务处理中加入其他的因子，MS DTC确认所有的过程完成并提交他们。MS DTC支持使用XA协议的数据库，XA协议是一种两阶段执行的协议，由SQL Server和Oracle支持。单个事务处理可以把数据写到SQL Server和Oracle数据库上。 让我们进一步研究MS DTC，了解其工作方式。为了能用两阶段提交协议进行协调，事务中的每个数据源必须装有MS DTC。在这些安装中，主要的协调器总是在事务的起源之处。这个主要的协调器称为提交协调器，它负责确保事务的提交或终止。不管事务是成功地提交还是回滚，提交协调器都负责向客户应用程序返回一个报告。分布式事务处理不仅对数据库有用，而且单个事务处理还可以把数据写到数据库和消息队列上，如果这两个操作中的一个失败，另一个操作就会回滚。消息队列简介: 消息队列技术是分布式应用中交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行--它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。

注意事项

1。事务必须在连接打开后BeginTransaction();

2.事务添加到SqlCommand（sqlCommand.Transaction = sqlTransaction; ）

3、其他数据库对应做相应调整

4、可以用微软提供的一个dll,很方便.

