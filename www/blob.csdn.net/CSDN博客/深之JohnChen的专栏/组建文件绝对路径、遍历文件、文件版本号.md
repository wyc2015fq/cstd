# 组建文件绝对路径、遍历文件、文件版本号 - 深之JohnChen的专栏 - CSDN博客

2017年09月26日 10:11:01[byxdaz](https://me.csdn.net/byxdaz)阅读数：467
个人分类：[常见代码](https://blog.csdn.net/byxdaz/article/category/6893276)



//h头文件

```cpp
#include <stdio.h>
#include <string.h>
#include <list>
#include <string.h>
#include <ctype.h>
using namespace std;

typedef struct tagFileInfo 
{
	string strFileName;			//文件名
	string strPathFileName;		//全路径文件名
}FileInfo;

//-------------------------------------------------------------------------------------
// 功能：组建绝对路径
// 参数：pBuffer[in]:缓冲区		nLength[in,out]:缓冲区长度
//		  pAttachName[in]:文件名前缀
//		  pAttachDir[in]:附加目录(入"TempFile\\",如无"\\"会自动追加)
// 返回：成功与否
//-------------------------------------------------------------------------------------
BOOL ConstructFileName(char* pBuffer,int& nLength,const char* pAttachName,const char* pAttachDir);

//功能：组建绝对路径[目录自动生成]
BOOL ConstructFileNameEx(char* pBuffer,int& nLength,const char* pAttachName,const char* pAttachDir);

//查找某目录下文件和文件夹
void FindFiles(char * lpPath,list<FileInfo> & listFile,bool bFindSubFolder = false);
//-------------------------------------------------------------------------------------
// 功能：获取文件版本信息
// 参数：szFileName[in]:文件绝对路径		szVersion[out]:版本号
//		  nVersionLength[in,out]:版本长度
// 返回：成功与否
//-------------------------------------------------------------------------------------
BOOL	GetFileVersionInformation(const char* szFileName,char* szVersion,int& nVersionLength);
```

//cpp文件

```cpp
#include <MMSystem.h>
#include <IPHlpApi.h>
#include <Dbghelp.h>

#pragma comment(lib,"winmm.lib")
#pragma comment(lib,"Iphlpapi.lib")
#pragma comment(lib,"Dbghelp.lib")
#pragma comment(lib,"Version.lib")

//-------------------------------------------------------------------------------------
// 功能：组建绝对路径
// 参数：pBuffer[in]:缓冲区		nLength[in,out]:缓冲区长度
//		  pAttachName[in]:文件名前缀
//		  pAttachDir[in]:附加目录(入"TempFile\\",如无"\\"会自动追加)
// 返回：成功与否
//-------------------------------------------------------------------------------------
BOOL ConstructFileName(char* pBuffer,int& nLength,const char* pAttachName,const char* pAttachDir)
{
	char szBuffer[512]={0};
	DWORD dwPathLength = ::GetModuleFileName(NULL,szBuffer,512);
	if(0 == dwPathLength)
		return FALSE;

	char* pTarget = ::strrchr(szBuffer,'\\')+1;
	pTarget[0] = 0;

	if(NULL != pAttachDir)
	{
		::strcat(szBuffer,pAttachDir);
		pTarget = ::strrchr((char*)pAttachDir,'\\');
		if(NULL == pTarget)
			::strcat(szBuffer,"\\");
	}

	if(NULL != pAttachName)
		::strcat(szBuffer,pAttachName);

	int nRealLength = ::strlen(szBuffer);
	if(nRealLength > nLength)
		return FALSE;

	::strcpy_s(pBuffer,nLength,szBuffer);
	nLength = nRealLength;
	return TRUE;
}

//功能：组建绝对路径[目录自动生成]
BOOL ConstructFileNameEx(char* pBuffer,int& nLength,const char* pAttachName,const char* pAttachDir)
{
	//	if(NULL == pAttachName)
	//		return FALSE;

	char szBuffer[512]={0};
	DWORD dwPathLength = ::GetModuleFileName(NULL,szBuffer,512);
	if(0 == dwPathLength)
		return FALSE;

	char* pTarget = ::strrchr(szBuffer,'\\')+1;
	pTarget[0] = 0;

	if(NULL != pAttachDir)
	{
		::strcat(szBuffer,pAttachDir);
		pTarget = ::strrchr((char*)pAttachDir,'\\');
		if(NULL == pTarget)
			::strcat(szBuffer,"\\");

		MakeSureDirectoryPathExists(szBuffer);
	}

	if(NULL != pAttachName)
		::strcat(szBuffer,pAttachName);

	int nRealLength = ::strlen(szBuffer);
	if(nRealLength > nLength)
		return FALSE;

	::strcpy_s(pBuffer,nLength,szBuffer);
	nLength = nRealLength;
	return TRUE;
}

//查找某目录下文件和文件夹
void FindFiles(char * lpPath,list<FileInfo> & listFile,bool bFindSubFolder)
{
	char szFind[MAX_PATH];
	WIN32_FIND_DATA FindFileData;
	strcpy(szFind,lpPath);
	strcat(szFind,"*.*");
	HANDLE hFind=::FindFirstFile(szFind,&FindFileData);
	if(INVALID_HANDLE_VALUE == hFind)
		return;

	FileInfo fiFileInfo;
	char szFile[MAX_PATH] = {0};
	while(TRUE)
	{
		if(FindFileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)
		{
			if(FindFileData.cFileName[0]!='.')
			{
				strcpy(szFile,lpPath);
				strcat(szFile,"");
				strcat(szFile,FindFileData.cFileName);
				if(bFindSubFolder)	//搜索子文件夹
				{
					FindFiles(szFile,listFile,bFindSubFolder);
				}
			}
		}
		else
		{
			strcpy(szFile,lpPath);
			strcat(szFile,"");
			strcat(szFile,FindFileData.cFileName);
			fiFileInfo.strFileName = FindFileData.cFileName;
			fiFileInfo.strPathFileName = szFile;
			listFile.push_back(fiFileInfo);
		}

		if(!FindNextFile(hFind,&FindFileData))
			break;
	}
	FindClose(hFind);
}

//-------------------------------------------------------------------------------------
// 功能：获取文件版本信息
// 参数：szFileName[in]:文件绝对路径		szVersion[out]:版本号
//		  nVersionLength[in,out]:版本长度
// 返回：成功与否
//-------------------------------------------------------------------------------------
BOOL GetFileVersionInformation(const char* szFileName,char* szVersion,int& nVersionLength)
{
	char szFullFileName[MAX_PATH] = {0};

	if(NULL == szFileName)
	{
		::GetModuleFileName(NULL, szFullFileName, sizeof(szFullFileName));
	}
	else
	{
		strcpy(szFullFileName, szFileName);
	}

	BOOL bSucceed = FALSE;
	DWORD dwVerHnd = 0;
	DWORD dwVerInfoSize = ::GetFileVersionInfoSize(szFullFileName, &dwVerHnd);
	if(dwVerInfoSize)
	{
		HANDLE		hMem;
		LPVOID		lpvMem; 
		unsigned int uInfoSize = 0;
		VS_FIXEDFILEINFO *pFileInfo;

		hMem = ::GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
		lpvMem = ::GlobalLock(hMem);
		::GetFileVersionInfo(szFullFileName, dwVerHnd, dwVerInfoSize, lpvMem);
		::VerQueryValue(lpvMem, (LPTSTR)"\\", (void**)&pFileInfo, &uInfoSize);

		WORD nVer[5] = {0};
		nVer[0] = HIWORD(pFileInfo->dwProductVersionMS);
		nVer[1] = LOWORD(pFileInfo->dwProductVersionMS);
		nVer[2] = HIWORD(pFileInfo->dwProductVersionLS);
		nVer[3] = LOWORD(pFileInfo->dwProductVersionLS);
		::sprintf_s(szVersion,nVersionLength,"%d.%d.%d.%d", nVer[0], nVer[1], nVer[2], nVer[3]);

		nVersionLength = ::strlen(szVersion);
		bSucceed = TRUE;

		::GlobalUnlock(hMem);
		::GlobalFree(hMem);
	}

	return  bSucceed;
}
```



