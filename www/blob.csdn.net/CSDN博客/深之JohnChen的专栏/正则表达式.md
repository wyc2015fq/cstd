# 正则表达式 - 深之JohnChen的专栏 - CSDN博客

2009年01月17日 10:48:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：1242标签：[正则表达式																[正则表达式工具																[windows																[引擎																[regex																[perl](https://so.csdn.net/so/search/s.do?q=perl&t=blog)](https://so.csdn.net/so/search/s.do?q=regex&t=blog)](https://so.csdn.net/so/search/s.do?q=引擎&t=blog)](https://so.csdn.net/so/search/s.do?q=windows&t=blog)](https://so.csdn.net/so/search/s.do?q=正则表达式工具&t=blog)](https://so.csdn.net/so/search/s.do?q=正则表达式&t=blog)
个人分类：[技术资料](https://blog.csdn.net/byxdaz/article/category/144574)


**正则表达式**

引言

正则表达式（regular expression）就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。比如表达式“ab+” 描述的特征是“一个 'a' 和任意个 'b' ”，那么 'ab', 'abb', 'abbbbbbbbbb' 都符合这个特征。

正则表达式可以用来：（1）验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。（2）用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。（3）用来替换，比普通的替换更强大。

正则表达式学习起来其实是很简单的，不多的几个较为抽象的概念也很容易理解。之所以很多人感觉正则表达式比较复杂，一方面是因为大多数的文档没有做到由浅入深地讲解，概念上没有注意先后顺序，给读者的理解带来困难；另一方面，各种引擎自带的文档一般都要介绍它特有的功能，然而这部分特有的功能并不是我们首先要理解的。
1. 正则表达式规则

1.1 普通字符

字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。

[举例1：表达式 "c"，在匹配字符串 "abcde" 时](http://www.regexlab.com/zh/workshop.asp?pat=c&txt=abcde)，匹配结果是：成功；匹配到的内容是："c"；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）

[举例2：表达式 "bcd"，在匹配字符串 "abcde" 时](http://www.regexlab.com/zh/workshop.asp?pat=bcd&txt=abcde)，匹配结果是：成功；匹配到的内容是："bcd"；匹配到的位置是：开始于1，结束于4。

1.2 简单的转义字符

一些不便书写的字符，采用在前面加 "/" 的方法。这些字符其实我们都已经熟知了。

|表达式|可匹配|
|----|----|
|/r, /n|代表回车和换行符|
|/t|制表符|
|//|代表 "/" 本身|

还有其他一些在后边章节中有特殊用处的标点符号，在前面加 "/" 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 "^" 和 "$" 字符，则表达式就需要写成 "/^" 和 "/$"。

|表达式|可匹配|
|----|----|
|/^|匹配 ^ 符号本身|
|/$|匹配 $ 符号本身|
|/.|匹配小数点（.）本身|

这些转义字符的匹配方法与 "普通字符" 是类似的。也是匹配与之相同的一个字符。

[举例1：表达式 "/$d"，在匹配字符串 "abc$de" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5C$d&txt=abc$de)，匹配结果是：成功；匹配到的内容是："$d"；匹配到的位置是：开始于3，结束于5。

1.3 能够与 '多种字符' 匹配的表达式

正则表达式中的一些表示方法，可以匹配 '多种字符' 其中的任意一个字符。比如，表达式 "/d" 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。

|表达式|可匹配|
|----|----|
|/d|任意一个数字，0~9 中的任意一个|
|/w|任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个|
|/s|包括空格、制表符、换页符等空白字符的其中任意一个|
|.|小数点可以匹配除了换行符（/n）以外的任意一个字符|

[举例1：表达式 "/d/d"，在匹配 "abc123" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5Cd%5Cd&txt=abc123)，匹配的结果是：成功；匹配到的内容是："12"；匹配到的位置是：开始于3，结束于5。

[举例2：表达式 "a./d"，在匹配 "aaa100" 时](http://www.regexlab.com/zh/workshop.asp?pat=a.%5Cd&txt=aaa100)，匹配的结果是：成功；匹配到的内容是："aa1"；匹配到的位置是：开始于1，结束于4。

1.4 自定义能够匹配 '多种字符' 的表达式

使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。

|表达式|可匹配|
|----|----|
|[ab5@]|匹配 "a" 或 "b" 或 "5" 或 "@"|
|[^abc]|匹配 "a","b","c" 之外的任意一个字符|
|[f-k]|匹配 "f"~"k" 之间的任意一个字母|
|[^A-F0-3]|匹配 "A"~"F","0"~"3" 之外的任意一个字符|

[举例1：表达式 "[bcd][bcd]" 匹配 "abc123" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5bbcd%5d%5bbcd%5d&txt=abc123)，匹配的结果是：成功；匹配到的内容是："bc"；匹配到的位置是：开始于1，结束于3。

[举例2：表达式 "[^abc]" 匹配 "abc123" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5B%5Eabc%5D&txt=abc123)，匹配的结果是：成功；匹配到的内容是："1"；匹配到的位置是：开始于3，结束于4。

1.5 修饰匹配次数的特殊符号

前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。

使用方法是："次数修饰"放在"被修饰的表达式"后边。比如："[bcd][bcd]" 可以写成 "[bcd]{2}"。

|表达式|作用|
|----|----|
|{n}|表达式重复n次，比如：["/w{2}" 相当于 "/w/w"](http://www.regexlab.com/zh/workshop.asp?pat=/w%7b2%7d&txt=ab+c6)；["a{5}" 相当于 "aaaaa"](http://www.regexlab.com/zh/workshop.asp?pat=a%7b5%7d&txt=bbaaaaaddee)|
|{m,n}|表达式至少重复m次，最多重复n次，比如：["ba{1,3}"可以匹配 "ba"或"baa"或"baaa"](http://www.regexlab.com/zh/workshop.asp?pat=ba%7b1,3%7d&txt=a,baaa,baa,b,ba)|
|{m,}|表达式至少重复m次，比如：["/w/d{2,}"可以匹配 "a12","_456","M12344"...](http://www.regexlab.com/zh/workshop.asp?pat=/w/d%7b2,%7d&txt=b1,a12,_456,_4AA,M12344,12346546547446534543543)|
|?|匹配表达式0次或者1次，相当于 {0,1}，比如：["a[cd]?"可以匹配 "a","ac","ad"](http://www.regexlab.com/zh/workshop.asp?pat=a%5bcd%5d%3F&txt=a,c,d,ac,ad)|
|+|表达式至少出现1次，相当于 {1,}，比如：["a+b"可以匹配 "ab","aab","aaab"...](http://www.regexlab.com/zh/workshop.asp?pat=a%2Bb&txt=a%2Cb%2Cab%2Caab%2Caaab)|
|*|表达式不出现或出现任意次，相当于 {0,}，比如：["/^*b"可以匹配 "b","^^^b"...](http://www.regexlab.com/zh/workshop.asp?pat=%5C%5E*b&txt=%5E%2Cb%2C%5E%5E%5Eb%2C%5E%5E%5E%5E%5E%5E%5Eb)|

[举例1：表达式 "/d+/.?/d*" 在匹配 "It costs $12.5" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5Cd%2B%5C.%3F%5Cd*&txt=It%20costs%20%2412.5)，匹配的结果是：成功；匹配到的内容是："12.5"；匹配到的位置是：开始于10，结束于14。

[举例2：表达式 "go{2,8}gle" 在匹配 "Ads by goooooogle" 时](http://www.regexlab.com/zh/workshop.asp?pat=go%7b2,8%7dgle&txt=Ads%20by%20goooooogle%2C%20or%20gooogle)，匹配的结果是：成功；匹配到的内容是："goooooogle"；匹配到的位置是：开始于7，结束于17。

1.6 其他一些代表抽象意义的特殊符号

一些符号在表达式中代表抽象的特殊意义：

|表达式|作用|
|----|----|
|^|与字符串开始的地方匹配，不匹配任何字符|
|$|与字符串结束的地方匹配，不匹配任何字符|
|/b|匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符|

进一步的文字说明仍然比较抽象，因此，举例帮助大家理解。

[举例1：表达式 "^aaa" 在匹配 "xxx aaa xxx" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5eaaa&txt=xxx+aaa+xxx)，匹配结果是：失败。因为 "^" 要求与字符串开始的地方匹配，因此，只有当 "aaa" 位于字符串的开头的时候，"^aaa" 才能匹配，[比如："aaa xxx xxx"](http://www.regexlab.com/zh/workshop.asp?pat=%5eaaa&txt=aaa+xxx+xxx)。

[举例2：表达式 "aaa$" 在匹配 "xxx aaa xxx" 时](http://www.regexlab.com/zh/workshop.asp?pat=aaa$&txt=xxx+aaa+xxx)，匹配结果是：失败。因为 "$" 要求与字符串结束的地方匹配，因此，只有当 "aaa" 位于字符串的结尾的时候，"aaa$" 才能匹配，[比如："xxx xxx aaa"](http://www.regexlab.com/zh/workshop.asp?pat=aaa$&txt=xxx+xxx+aaa)。

[举例3：表达式 "./b." 在匹配 "@@@abc" 时](http://www.regexlab.com/zh/workshop.asp?pat=.%5Cb.&txt=@@@abc)，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。
进一步说明："/b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "/w" 范围，另一边是非"/w" 的范围。

[举例4：表达式 "/bend/b" 在匹配 "weekend,endfor,end" 时](http://www.regexlab.com/zh/workshop.asp?pat=%5Cbend%5Cb&txt=weekend,endfor,end)，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18。

一些符号可以影响表达式内部的子表达式之间的关系：

|表达式|作用|
|----|----|
|||左右两边表达式之间 "或" 关系，匹配左边或者右边|
|( )|(1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到|

[举例5：表达式 "Tom|Jack" 在匹配字符串 "I'm Tom, he is Jack" 时](http://www.regexlab.com/zh/workshop.asp?pat=Tom%7CJack&txt=I%27m+Tom%2C+he+is+Jack)，匹配结果是：成功；匹配到的内容是："Tom"；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是："Jack"；匹配到的位置时：开始于15，结束于19。

[举例6：表达式 "(go/s*)+" 在匹配 "Let's go go go!" 时](http://www.regexlab.com/zh/workshop.asp?pat=%28go%5Cs*%29%2B&txt=Let%27s%20go%20go%20go%21)，匹配结果是：成功；匹配到内容是："go go go"；匹配到的位置是：开始于6，结束于14。

[举例7：表达式 "￥(/d+/.?/d*)" 在匹配 "＄10.9,￥20.5" 时](http://www.regexlab.com/zh/workshop.asp?pat=%uFFE5%28%5Cd%2B%5C.%3F%5Cd*%29&txt=%uFF0410.9%2C%uFFE520.5)，匹配的结果是：成功；匹配到的内容是："￥20.5"；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是："20.5"。

2. 正则表达式中的一些高级规则

2.1 匹配次数中的贪婪与非贪婪

在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如："{m,n}", "{m,}", "?", "*", "+"，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 "dxxxdxxxd"，举例如下：

|表达式|匹配结果|
|----|----|
|[(d)(/w+)](http://www.regexlab.com/zh/workshop.asp?pat=(d)(%5Cw%2B)&txt=dxxxdxxxd)|"/w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"|
|[(d)(/w+)(d)](http://www.regexlab.com/zh/workshop.asp?pat=(d)(%5Cw%2B)(d)&txt=dxxxdxxxd)|"/w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "/w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"/w+" 可以 "让出" 它本来能够匹配的最后一个 "d"|

由此可见，"/w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "*" 和 "{m,n}" 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这种匹配原则就叫作 "贪婪" 模式。

非贪婪模式：

在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：

|表达式|匹配结果|
|----|----|
|[(d)(/w+?)](http://www.regexlab.com/zh/workshop.asp?pat=(d)(%5Cw%2B%3F)&txt=dxxxdxxxd)|"/w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："/w+?" 只匹配了一个 "x"|
|[(d)(/w+?)(d)](http://www.regexlab.com/zh/workshop.asp?pat=(d)(%5Cw%2B%3F)(d)&txt=dxxxdxxxd)|为了让整个表达式匹配成功，"/w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是："/w+?" 匹配 "xxx"|

更多的情况，举例如下：

[举例1：表达式 "<td>(.*)</td>" 与字符串 "<td><p>aa</p></td> <td><p>bb</p></td>" 匹配时](http://www.regexlab.com/zh/workshop.asp?pat=%3Ctd%3E%28%2E%2A%29%3C%2Ftd%3E&txt=%3Ctd%3E%3Cp%3Eaa%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3Ebb%3C%2Fp%3E%3C%2Ftd%3E)，匹配的结果是：成功；匹配到的内容是 "<td><p>aa</p></td> <td><p>bb</p></td>" 整个字符串，表达式中的 "</td>" 将与字符串中最后一个 "</td>" 匹配。

[举例2：相比之下，表达式 "<td>(.*?)</td>" 匹配举例1中同样的字符串时](http://www.regexlab.com/zh/workshop.asp?pat=%3Ctd%3E%28%2E%2A%3F%29%3C%2Ftd%3E&txt=%3Ctd%3E%3Cp%3Eaa%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3Ebb%3C%2Fp%3E%3C%2Ftd%3E)，将只得到 "<td><p>aa</p></td>"，再次匹配下一个时，可以得到第二个 "<td><p>bb</p></td>"。

2.2 反向引用 /1, /2...

表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 "<td>(.*?)</td>"。

其实，"小括号包含的表达式所匹配到的字符串" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "/" 加上一个数字。"/1" 引用第1对括号内匹配到的字符串，"/2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。

举例如下：

[举例1：表达式 "('|")(.*?)(/1)" 在匹配 " 'Hello', "World" " 时](http://www.regexlab.com/zh/workshop.asp?pat=%28%27%7C%22%29%28%2E%2A%3F%29%28%5C1%29&txt=%27Hello%27%2C+%22World%22)，匹配结果是：成功；匹配到的内容是：" 'Hello' "。再次匹配下一个时，可以匹配到 " "World" "。

[举例2：表达式 "(/w)/1{4,}" 在匹配 "aa bbbb abcdefg ccccc 111121111 999999999" 时](http://www.regexlab.com/zh/workshop.asp?pat=%28%5Cw%29%5C1%7B4%2C%7D&txt=aa%20bbbb%20abcdefg%20ccccc%20111121111%20999999999)，匹配结果是：成功；匹配到的内容是 "ccccc"。再次匹配下一个时，将得到 999999999。这个表达式要求 "/w" 范围的字符至少重复5次，[注意与 "/w{5,}" 之间的区别](http://www.regexlab.com/zh/workshop.asp?pat=%5Cw%7B5%2C%7D&txt=aa%20bbbb%20abcdefg%20ccccc%20111121111%20999999999)。

[举例3：表达式 "<(/w+)/s*(/w+(=('|").*?/4)?/s*)*>.*?<//1>" 在匹配 "<td id='td1' style="bgcolor:white"></td>" 时](http://www.regexlab.com/zh/workshop.asp?pat=%3C%28%5Cw%2B%29%5Cs%2A%28%5Cw%2B%28%3D%28%27%7C%22%29%2E%2A%3F%5C4%29%3F%5Cs%2A%29%2A%3E%2E%2A%3F%3C%2F%5C1%3E&txt=%3Ctd+id%3D%27td1%27+style%3D%22bgcolor%3Awhite%22%3E%3C%2Ftd%3E%0D%0A%3Cbody+onload%3D%22doit%28%29%22%3E%3C%2Fbody%3E)，匹配结果是成功。如果 "<td>" 与 "</td>" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。

2.3 预搜索，不匹配；反向预搜索，不匹配

前面的章节中，我讲到了几个代表抽象意义的特殊符号："^"，"$"，"/b"。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 "字符串的两头" 或者 "字符之间的缝隙" 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 "两头" 或者 "缝隙" 附加条件的，更加灵活的表示方法。

正向预搜索："(?=xxxxx)"，"(?!xxxxx)"

格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的 "缝隙" 或者 "两头" 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 "/b"，本身不匹配任何字符。"/b" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。

[举例1：表达式 "Windows (?=NT|XP)" 在匹配 "Windows 98, Windows NT, Windows 2000" 时](http://www.regexlab.com/zh/workshop.asp?pat=Windows+%28%3F%3DNT%7CXP%29&txt=Windows+98%2C+Windows+NT%2C+Windows+2000)，将只匹配 "Windows NT" 中的 "Windows "，其他的 "Windows " 字样则不被匹配。

[举例2：表达式 "(/w)((?=/1/1/1)(/1))+" 在匹配字符串 "aaa ffffff 999999999" 时](http://www.regexlab.com/zh/workshop.asp?pat=%28%5Cw%29%28%28%3F%3D%5C1%5C1%5C1%29%28%5C1%29%29%2B&txt=aaa+ffffff+999999999)，将可以匹配6个"f"的前4个，可以匹配9个"9"的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。

格式："(?!xxxxx)"，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。

[举例3：表达式 "((?!/bstop/b).)+" 在匹配 "fdjka ljfdl stop fjdsla fdj" 时](http://www.regexlab.com/zh/workshop.asp?pat=%28%28%3F%21%5Cbstop%5Cb%29%2E%29%2B&txt=fdjka+ljfdl+stop+fjdsla+fdj)，将从头一直匹配到 "stop" 之前的位置，如果字符串中没有"stop"，则匹配整个字符串。

[举例4：表达式 "do(?!/w)" 在匹配字符串 "done, do, dog" 时](http://www.regexlab.com/zh/workshop.asp?pat=do%28%3F%21%5Cw%29&txt=done%2C+do%2C+dog)，只能匹配 "do"。在本条举例中，"do" 后边使用 "(?!/w)" 和使用 "/b" 效果是一样的。

反向预搜索："(?<=xxxxx)"，"(?<!xxxxx)"

这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 "左侧"，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 "正向预搜索" 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。

举例5：表达式 "(?<=/d{4})/d+(?=/d{4})" 在匹配 "1234567890123456" 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp 不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java 1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions 命名空间，以及本站推荐的[最简单易用的 DEELX 正则引擎](http://www.regexlab.com/zh/deelx/)。

3. 其他通用规则

还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。

3.1 表达式中，可以使用 "/xXX" 和 "/uXXXX" 表示一个字符（"X" 表示一个十六进制数）

|形式|字符范围|
|----|----|
|/xXX|编号在 0 ~ 255 范围的字符，比如：[空格可以使用 "/x20" 表示](http://www.regexlab.com/zh/workshop.asp?pat=%5Cx20&txt=It+is%2E)|
|/uXXXX|任何字符可以使用 "/u" 再加上其编号的4位十六进制数表示，比如：["/u4E2D"](http://www.regexlab.com/zh/workshop.asp?pat=%5Cu4E2D&txt=%D6%D0%B9%FA)|

3.2 在表达式 "/s"，"/d"，"/w"，"/b" 表示特殊意义的同时，对应的大写字母表示相反的意义

|表达式|可匹配|
|----|----|
|/S|[匹配所有非空白字符（"/s" 可匹配各个空白字符）](http://www.regexlab.com/zh/workshop.asp?pat=%5CS%2B&txt=abc+123+%40%23%24%25)|
|/D|[匹配所有的非数字字符](http://www.regexlab.com/zh/workshop.asp?pat=%5CD%2B&txt=abc+123+%40%23%24%25)|
|/W|[匹配所有的字母、数字、下划线以外的字符](http://www.regexlab.com/zh/workshop.asp?pat=%5CW%2B&txt=abc+123+%40%23%24%25)|
|/B|[匹配非单词边界，即左右两边都是 "/w" 范围或者左右两边都不是 "/w" 范围时的字符缝隙](http://www.regexlab.com/zh/workshop.asp?pat=%5CB%2E%5CB&txt=abc+123+%40%23%24%25)|

3.3 在表达式中有特殊意义，需要添加 "/" 才能匹配该字符本身的字符汇总

|字符|说明|
|----|----|
|^|匹配输入字符串的开始位置。要匹配 "^" 字符本身，请使用 "/^"|
|$|匹配输入字符串的结尾位置。要匹配 "$" 字符本身，请使用 "/$"|
|( )|标记一个子表达式的开始和结束位置。要匹配小括号，请使用 "/(" 和 "/)"|
|[ ]|用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 "/[" 和 "/]"|
|{ }|修饰匹配次数的符号。要匹配大括号，请使用 "/{" 和 "/}"|
|.|匹配除了换行符（/n）以外的任意一个字符。要匹配小数点本身，请使用 "/."|
|?|修饰匹配次数为 0 次或 1 次。要匹配 "?" 字符本身，请使用 "/?"|
|+|修饰匹配次数为至少 1 次。要匹配 "+" 字符本身，请使用 "/+"|
|*|修饰匹配次数为 0 次或任意次。要匹配 "*" 字符本身，请使用 "/*"|
|||左右两边表达式之间 "或" 关系。匹配 "|" 本身，请使用 "/|"|

3.4 括号 "( )" 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 "(?:xxxxx)" 格式

[举例1：表达式 "(?:(/w)/1)+" 匹配 "a bbccdd efg" 时](http://www.regexlab.com/zh/workshop.asp?pat=%28%3F%3A%28%5Cw%29%5C1%29%2B&txt=a%20bbccdd%20efg)，结果是 "bbccdd"。括号 "(?:)" 范围的匹配结果不进行记录，因此 "(/w)" 使用 "/1" 来引用。

3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global

|表达式属性|说明|
|----|----|
|Ignorecase|默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 "大小写" 概念延伸至 UNICODE 范围的大小写。|
|Singleline|默认情况下，小数点 "." 匹配除了换行符（/n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。|
|Multiline|默认情况下，表达式 "^" 和 "$" 只匹配字符串的开始①和结尾④位置。如：①xxxxxxxxx②/n③xxxxxxxxx④配置为 Multiline 可以使 "^" 匹配①外，还可以匹配换行符之后，下一行开始前③的位置，使 "$" 匹配④外，还可以匹配换行符之前，一行结束②的位置。|
|Global|主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。|


4. 其他提示

4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见[本站 DEELX 正则引擎的说明文档](http://www.regexlab.com/zh/deelx/syntax.htm)。

4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 "^" 和 "$"，比如："^/d+$" 要求整个字符串只有数字。

4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 "/b"，比如：[使用 "/b(if|while|else|void|int……)/b" 来匹配程序中的关键字](http://www.regexlab.com/zh/workshop.asp?pat=%5Cb%28if%7Cwhile%7Celse%7Cvoid%7Cint%29%5Cb&txt=if%28ifdo%29%0D%0A++++dosome%28%29%3B%0D%0Aelse%0D%0A++++doelse%28%29%3B)。

4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 "123"、"123."、"123.5"、".5" 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成："/d*/.?/d*"，因为如果什么都没有，这个表达式也可以匹配成功。[更好的写法是："/d+/.?/d*|/./d+"](http://www.regexlab.com/zh/workshop.asp?pat=%5Cd%2B%5C%2E%3F%5Cd%2A%7C%5C%2E%5Cd%2B&txt=123%2C+123%2E%2C+123%2E5%2C+%2E5%2C+%2E)。

4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。

4.6 合理选择贪婪模式与非贪婪模式，参见[话题讨论](http://www.regexlab.com/zh/regtopic.htm#reluctant)。

4.7 或 "|" 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 "|" 两边的表达式因为交换位置而有所不同。

5. 进阶与实战

有了从本文中掌握的基础，我们可以从实践中进一步巩固我们使用正则表达式的技巧。

关于windows下的正则表达式工具，这里推荐的是：RegexBuddy和PowerGREP。在linux下，也有好用的正则表达式工具，例如grep的兄弟们，只不过是都是基于命令行的。而这两款windows下的小工具，其突出特点是可视化，允许尝试和预览，极大地方便了使用者。

RegexBuddy：网址是[http://www.regexbuddy.com](http://www.regexbuddy.com/)。在编写正则式时，它提供可视化的支持、提示、调试方面的便利；在使用正则表达式时，它无私地将正则式转换为多种语言的字串，还提供了代码输出功能。正则式助手，该称号名副其实。

**基本界面**

正则式的基本功能无外乎搜索和替换。在本文中，我们使用匹配Email的正则式，代码如下：

[?](http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples)[[Copy to clipboard]](javascript:;)[View Code](javascript:;) PERL

/b[A-Z0-9._%-]+@[A-Z0-9.-]+/.[A-Z]{2,4}/b

此时，RegexBuddy的界面如图：![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/1.JPG)

[](http://pic.yupoo.com/zhasm/9681657ba942/uzya6kg4.jpg)

在点击“Explain Token”时，能对当前的正则式片断的作用作出详细解释，例如当你把光标移动到/b上再点击Explain Token，就会激活帮助文档，自动定位到Word Boundaries这一段。

如果想对刚才编写的这条正则式进行测试和验证，可以点击“Test”进行测试。这时，在下边的文本框输入所需要匹配测试的文字，例如[dog@animals.com](mailto:dog@animals.com)，匹配结果就以黄色背景色标出。在本例中，你**或许**没有得到正确的匹配，呵呵，那是正常的。为什么？答案见文章结尾。

**拷贝粘贴**

RegexBuddy能把正则![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/2.JPG)式以多种字符串格式拷贝出来。还是刚才那条正则式，根据需要，它可以被拷贝为：

[?](http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples)[[Copy to clipboard]](javascript:;)[View Code](javascript:;) PERL

'//b[A-Z0-9._%-]+@[A-Z0-9.-]+//.[A-Z]{2,4}//b'

"//b[A-Z0-9._%-]+@[A-Z0-9.-]+//.[A-Z]{2,4}//b"

'///b[A-Z0-9._%-]+@[A-Z0-9.-]+//.[A-Z]{2,4}//b/i'

具体的选项在copy菜单里，如下图所示。你不必为单双引号、正反斜线操心了。

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/3.JPG)


在paste菜单项中也有类似应用，不赘述。

**正则式****->****代码**

如果你想把刚才编写好的正则式应用在程序中，这里还有一个选项：Use，界面见下图：

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/4.JPG)

在上面的match和replace之间点击，其代码也相应自动调整；当选取不同的language时，代码也会相应调整。它支持的语言格式为：

C# 

Delphi(NET/Win32) 

Java/JavaScript/ECMAScript 

PCRE 

PHP 

Perl 

Python 

RealBasic 

Ruby 

VB 

另外，它还有function选项，分别用以实现下述功能：

If/else branch whethe the regex matches (part of) a string. If/else验证正则式是否匹配字串（的一部分）。最常用的功能。

If/else branch whethe the regex matches a string entirely. If/else验证正则式是否匹配整条字串。

Get the part of a string matched by the regex. 取得字串中与正则式匹配的部分。Get the part of a string matched by a capturing group. 取得字串中所匹配的捕获组。这一条我也是刚刚知道，很有用哟。

Get an array of all regex matches in a string.将字串中所有的匹配保存到数组中。

Iterate over all matches in a string。列出字串中所有的匹配项。（例如，在使用正则式’/w’来匹配字串’abc’时，本function列出的内容为’a',’b',’c’.）。单词iterate的含义是**重复**。

Comment with RegexBuddy’s regex tree. RegexBuddy的正则树的注释。

**文本分割****split**

如果需要处理的文本是以某种分隔符隔开的，而该种分隔符恰好又能使用正则式描述，（例如html标签），此时regexbuddy的split功能就可以大显身手了。我随便打开了一个饭否[网页](chrome://performancing/content/scribefire.xul)，对其源代码中的消息部分（<div id=“stream”>与</div>之内）的文本进行了处理，使用如下正则式删除了所有的尖括号内容，只留下普通文本。

使用的正则式为：

[?](http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples)[[Copy to clipboard]](javascript:;)[View Code](javascript:;) PERL

<[^>]+>

软件界面以及运行结果请见下图。

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/5.JPG)

**结尾：**

关于本文开头提出的小问题，细心的你或许一下子就能看出答案了！见下图：

![](https://p-blog.csdn.net/images/p_blog_csdn_net/byxdaz/EntryImages/20090117/6.JPG)

只要选中Case insensitive选项中OK啦！如果你没有找到，或许是因为该软件是英文的，一时间您没有注意到该选项；或者您对正则式还不太熟悉。

**软件下载**

上文已经提到，其官网为[www.regexbuddy.com](http://www.regexbuddy.com/)，可以去下载其最新版试用。**该软件为商业软件**。

如果需要RegexBuddy 2.3.2完全版或者RegexBuddy3.2.0破解版，请留言或者从csdn中下载。

http://download.csdn.net/source/974189


