# 常见几种字符之间的转换 - 深之JohnChen的专栏 - CSDN博客

2008年05月08日 23:17:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2904


## 常见几种字符之间的转换

## 一、字符串/整型转换

1、  int atoi(const char *nptr);

atoi()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('')才结束转换，并将结果返回。

long int strtol(const char *nptr,char **endptr,int base);

2、  strtol()会将参数nptr字符串根据参数base来转换成长整型数。参数base范围从2至36，或0。参数base代表采用的进制方式，如 base值为10则采用10进制，若base值为16则采用16进制等。当base值为0时则是采用10进制做转换，但遇到如'0x'前置字符则会使用 16进制做转换。一开始strtol()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时('')结束转换，并将结果返回。若参数endptr不为NULL，则会将遇到不合条件而终止的nptr中的字符指针由endptr返回。

3、  gcvt（将浮点型数转换为字符串，取四舍五入）

相关函数

ecvt，fcvt，sprintf

表头文件

#include

定义函数

char *gcvt(double number，size_t ndigits，char *buf);

函数说明

gcvt ()用来将参数number转换成ASCII码字符串，参数ndigits表示显示的位数。gcvt()与ecvt()和fcvt()不同的地方在于， gcvt()所转换后的字符串包含小数点或正负符号。若转换成功，转换后的字符串会放在参数buf指针所指的空间。

返回值

返回一字符串指针，此地址即为buf指针。

4、  atof(),ftoa(),itoa()，strtod（将字符串转换成浮点数）等。

5、  范例

/* 将字符串a，b，c 分别采用10，2，16进制转换成数字*/

#include <stdio.h>

main()

{

char a[]=”1000000000”;

char b[]=”1000000000”;

char c[]=”ffff”;

printf(“a=%d/n”,strtol(a,NULL,10));

printf(“b=%d/n”,strtol(b,NULL,2));

printf(“c=%d/n”,strtol(c,NULL,16));

}

执行

a=1000000000

b=512

c=65535

二、 C++ 中 string与wstring互转

方法一：

string WideToMutilByte(const wstring& _src)

{

int nBufSize = WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, NULL, 0, 0, FALSE);

char *szBuf = new char[nBufSize];

WideCharToMultiByte(GetACP(), 0, _src.c_str(),-1, szBuf, nBufSize, 0, FALSE);

string strRet(szBuf);

delete []szBuf;

szBuf = NULL;

return strRet;

}

wstring MutilByteToWide(const string& _src)

{

//计算字符串 string 转成 wchar_t 之后占用的内存字节数

int nBufSize = MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,NULL,0);

//为 wsbuf 分配内存 BufSize 个字节

wchar_t *wsBuf = new wchar_t[nBufSize];

//转化为 unicode 的 WideString

MultiByteToWideChar(GetACP(),0,_src.c_str(),-1,wsBuf,nBufSize);

wstring wstrRet(wsBuf);

delete []wsBuf;

wsBuf = NULL;

return wstrRet;

}

几种C++ std::string和std::wstring相互转换的转换方法。

第一种方法：调用WideCharToMultiByte()和MultiByteToWideChar()，代码如下（关于详细的解释，可以参考《windows核心编程》）：

#include <string>

#include <windows.h>

using namespace std;

//Converting a WChar string to a Ansi string

std::string WChar2Ansi(LPCWSTR pwszSrc)

{

         int nLen = WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, NULL, 0, NULL, NULL);

         if (nLen<= 0) return std::string("");

         char* pszDst = new char[nLen];

         if (NULL == pszDst) return std::string("");

         WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, pszDst, nLen, NULL, NULL);

         pszDst[nLen -1] = 0;

         std::string strTemp(pszDst);

         delete [] pszDst;

         return strTemp;

}

string ws2s(wstring& inputws)

{

        return WChar2Ansi(inputws.c_str());

}

//Converting a Ansi string to WChar string

std::wstring Ansi2WChar(LPCSTR pszSrc, int nLen)

{

    int nSize = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszSrc, nLen, 0, 0);

    if(nSize <= 0) return NULL;

         WCHAR *pwszDst = new WCHAR[nSize+1];

    if( NULL == pwszDst) return NULL;

    MultiByteToWideChar(CP_ACP, 0,(LPCSTR)pszSrc, nLen, pwszDst, nSize);

    pwszDst[nSize] = 0;

    if( pwszDst[0] == 0xFEFF)                    // skip Oxfeff

        for(int i = 0; i < nSize; i ++)

                            pwszDst[i] = pwszDst[i+1];

    wstring wcharString(pwszDst);

         delete pwszDst;

    return wcharString;

}

std::wstring s2ws(const string& s)

{

     return Ansi2WChar(s.c_str(),s.size());

}

第二种方法：采用ATL封装_bstr_t的过渡：（注，_bstr_是Microsoft Specific的，所以下面代码可以在VS2005通过，无移植性）；

#include <string>

#include <comutil.h>

using namespace std;

#pragma comment(lib, "comsuppw.lib")

string ws2s(const wstring& ws);

wstring s2ws(const string& s);

string ws2s(const wstring& ws)

{

         _bstr_t t = ws.c_str();

         char* pchar = (char*)t;

         string result = pchar;

         return result;

}

wstring s2ws(const string& s)

{

         _bstr_t t = s.c_str();

         wchar_t* pwchar = (wchar_t*)t;

         wstring result = pwchar;

         return result;

}

第三种方法：使用CRT库的mbstowcs()函数和wcstombs()函数，平台无关，需设定locale。

#include <string>

#include <locale.h>

using namespace std;

string ws2s(const wstring& ws)

{

         string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";

         setlocale(LC_ALL, "chs");

         const wchar_t* _Source = ws.c_str();

         size_t _Dsize = 2 * ws.size() + 1;

         char *_Dest = new char[_Dsize];

         memset(_Dest,0,_Dsize);

         wcstombs(_Dest,_Source,_Dsize);

         string result = _Dest;

         delete []_Dest;

         setlocale(LC_ALL, curLocale.c_str());

         return result;

}

wstring s2ws(const string& s)

{

         setlocale(LC_ALL, "chs");

         const char* _Source = s.c_str();

         size_t _Dsize = s.size() + 1;

         wchar_t *_Dest = new wchar_t[_Dsize];

         wmemset(_Dest, 0, _Dsize);

         mbstowcs(_Dest,_Source,_Dsize);

         wstring result = _Dest;

         delete []_Dest;

         setlocale(LC_ALL, "C");

         return result;

}

三、utf8.utf16.utf32的相互转化

可以参考Unicode.org 上有ConvertUTF.c和ConvertUTF.h （下载地址：[http://www.unicode.org/Public/PROGRAMS/CVTUTF/](http://www.unicode.org/Public/PROGRAMS/CVTUTF/)）

头文件 ConvertUTF.h:

/*

 * Copyright 2001-2004 Unicode, Inc.

 *

 * Disclaimer

 *

 * This source code is provided as is by Unicode, Inc. No claims are

 * made as to fitness for any particular purpose. No warranties of any

 * kind are expressed or implied. The recipient agrees to determine

 * applicability of information provided. If this file has been

 * purchased on magnetic or optical media from Unicode, Inc., the

 * sole remedy for any claim will be exchange of defective media

 * within 90 days of receipt.

 *

 * Limitations on Rights to Redistribute This Code

 *

 * Unicode, Inc. hereby grants the right to freely use the information

 * supplied in this file in the creation of products supporting the

 * Unicode Standard, and to make copies of this file in any form

 * for internal or external distribution as long as this notice

 * remains attached.

 */

/* ---------------------------------------------------------------------

    Conversions between UTF32, UTF-16, and UTF-8.  Header file.

    Several funtions are included here, forming a complete set of

    conversions between the three formats.  UTF-7 is not included

    here, but is handled in a separate source file.

    Each of these routines takes pointers to input buffers and output

    buffers.  The input buffers are const.

    Each routine converts the text between *sourceStart and sourceEnd,

    putting the result into the buffer between *targetStart and

    targetEnd. Note: the end pointers are *after* the last item: e.g.

    *(sourceEnd - 1) is the last item.

    The return result indicates whether the conversion was successful,

    and if not, whether the problem was in the source or target buffers.

    (Only the first encountered problem is indicated.)

    After the conversion, *sourceStart and *targetStart are both

    updated to point to the end of last text successfully converted in

    the respective buffers.

    Input parameters:

       sourceStart - pointer to a pointer to the source buffer.

              The contents of this are modified on return so that

              it points at the next thing to be converted.

       targetStart - similarly, pointer to pointer to the target buffer.

       sourceEnd, targetEnd - respectively pointers to the ends of the

              two buffers, for overflow checking only.

    These conversion functions take a ConversionFlags argument. When this

    flag is set to strict, both irregular sequences and isolated surrogates

    will cause an error.  When the flag is set to lenient, both irregular

    sequences and isolated surrogates are converted.

    Whether the flag is strict or lenient, all illegal sequences will cause

    an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,

    or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code

    must check for illegal sequences.

    When the flag is set to lenient, characters over 0x10FFFF are converted

    to the replacement character; otherwise (when the flag is set to strict)

    they constitute an error.

    Output parameters:

       The value "sourceIllegal" is returned from some routines if the input

       sequence is malformed.  When "sourceIllegal" is returned, the source

       value will point to the illegal value that caused the problem. E.g.,

       in UTF-8 when a sequence is malformed, it points to the start of the

       malformed sequence. 

    Author: Mark E. Davis, 1994.

    Rev History: Rick McGowan, fixes & updates May 2001.

               Fixes & updates, Sept 2001.

------------------------------------------------------------------------ */

/* ---------------------------------------------------------------------

    The following 4 definitions are compiler-specific.

    The C standard does not guarantee that wchar_t has at least

    16 bits, so wchar_t is no less portable than unsigned short!

    All should be unsigned values to avoid sign extension during

    bit mask & shift operations.

------------------------------------------------------------------------ */

typedef unsigned long UTF32;   /* at least 32 bits */

typedef unsigned short      UTF16;       /* at least 16 bits */

typedef unsigned char UTF8;     /* typically 8 bits */

typedef unsigned char Boolean; /* 0 or 1 */

/* Some fundamental constants */

#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD

#define UNI_MAX_BMP (UTF32)0x0000FFFF

#define UNI_MAX_UTF16 (UTF32)0x0010FFFF

#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF

#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF

typedef enum {

       conversionOK,               /* conversion successful */

       sourceExhausted,      /* partial character in source, but hit end */

       targetExhausted,       /* insuff. room in target for conversion */

       sourceIllegal             /* source sequence is illegal/malformed */

} ConversionResult;

typedef enum {

       strictConversion = 0,

       lenientConversion

} ConversionFlags;

/* This is for C++ and does no harm in C */

#ifdef __cplusplus

extern "C" {

#endif

ConversionResult ConvertUTF8toUTF16 (

              const UTF8** sourceStart, const UTF8* sourceEnd,

              UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);

ConversionResult ConvertUTF16toUTF8 (

              const UTF16** sourceStart, const UTF16* sourceEnd,

              UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);

ConversionResult ConvertUTF8toUTF32 (

              const UTF8** sourceStart, const UTF8* sourceEnd,

              UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);

ConversionResult ConvertUTF32toUTF8 (

              const UTF32** sourceStart, const UTF32* sourceEnd,

              UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);

ConversionResult ConvertUTF16toUTF32 (

              const UTF16** sourceStart, const UTF16* sourceEnd,

              UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);

ConversionResult ConvertUTF32toUTF16 (

              const UTF32** sourceStart, const UTF32* sourceEnd,

              UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);

Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);

#ifdef __cplusplus

}

#endif

/* --------------------------------------------------------------------- */

实现文件ConvertUTF.c：

/**//*

* Copyright 2001-2004 Unicode, Inc.

*

* Disclaimer

*

* This source code is provided as is by Unicode, Inc. No claims are

* made as to fitness for any particular purpose. No warranties of any

* kind are expressed or implied. The recipient agrees to determine

* applicability of information provided. If this file has been

* purchased on magnetic or optical media from Unicode, Inc., the

* sole remedy for any claim will be exchange of defective media

* within 90 days of receipt.

*

* Limitations on Rights to Redistribute This Code

*

* Unicode, Inc. hereby grants the right to freely use the information

* supplied in this file in the creation of products supporting the

* Unicode Standard, and to make copies of this file in any form

* for internal or external distribution as long as this notice

* remains attached.

*/

/**//* ---------------------------------------------------------------------

    Conversions between UTF32, UTF-16, and UTF-8. Source code file.

    Author: Mark E. Davis, 1994.

    Rev History: Rick McGowan, fixes & updates May 2001.

    Sept 2001: fixed const & error conditions per

    mods suggested by S. Parent & A. Lillich.

    June 2002: Tim Dodd added detection and handling of incomplete

    source sequences, enhanced error detection, added casts

    to eliminate compiler warnings.

    July 2003: slight mods to back out aggressive FFFE detection.

    Jan 2004: updated switches in from-UTF8 conversions.

    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.

    See the header file "ConvertUTF.h" for complete documentation.

------------------------------------------------------------------------ */

#include "ConvertUTF.h"

#ifdef CVTUTF_DEBUG

#include <stdio.h>

#endif

static const int halfShift  = 10; /**//* used for shifting by 10 bits */

static const UTF32 halfBase = 0x0010000UL;

static const UTF32 halfMask = 0x3FFUL;

#define UNI_SUR_HIGH_START  (UTF32)0xD800

#define UNI_SUR_HIGH_END    (UTF32)0xDBFF

#define UNI_SUR_LOW_START   (UTF32)0xDC00

#define UNI_SUR_LOW_END     (UTF32)0xDFFF

#define false       0

#define true        1

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF16 (

    const UTF32** sourceStart, const UTF32* sourceEnd,

    UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF32* source = *sourceStart;

    UTF16* target = *targetStart;

    while (source < sourceEnd) {

    UTF32 ch;

    if (target >= targetEnd) {

        result = targetExhausted; break;

    }

    ch = *source++;

    if (ch <= UNI_MAX_BMP) { /**//* Target is a character <= 0xFFFF */

        /**//* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */

        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

        if (flags == strictConversion) {

            --source; /**//* return to the illegal value itself */

            result = sourceIllegal;

            break;

        } else {

            *target++ = UNI_REPLACEMENT_CHAR;

        }

        } else {

        *target++ = (UTF16)ch; /**//* normal case */

        }

    } else if (ch > UNI_MAX_LEGAL_UTF32) {

        if (flags == strictConversion) {

        result = sourceIllegal;

        } else {

        *target++ = UNI_REPLACEMENT_CHAR;

        }

    } else {

        /**//* target is a character in range 0xFFFF - 0x10FFFF. */

        if (target + 1 >= targetEnd) {

        --source; /**//* Back up source pointer! */

        result = targetExhausted; break;

        }

        ch -= halfBase;

        *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

        *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

    }

    }

    *sourceStart = source;

    *targetStart = target;

    return result;

}

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF32 (

    const UTF16** sourceStart, const UTF16* sourceEnd,

    UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF16* source = *sourceStart;

    UTF32* target = *targetStart;

    UTF32 ch, ch2;

    while (source < sourceEnd) {

    const UTF16* oldSource = source; /**//*  In case we have to back up because of target overflow. */

    ch = *source++;

    /**//* If we have a surrogate pair, convert to UTF32 first. */

    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

        /**//* If the 16 bits following the high surrogate are in the source buffer */

        if (source < sourceEnd) {

        ch2 = *source;

        /**//* If it's a low surrogate, convert to UTF32. */

        if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

            ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

            + (ch2 - UNI_SUR_LOW_START) + halfBase;

            ++source;

        } else if (flags == strictConversion) { /**//* it's an unpaired high surrogate */

            --source; /**//* return to the illegal value itself */

            result = sourceIllegal;

            break;

        }

        } else { /**//* We don't have the 16 bits following the high surrogate. */

        --source; /**//* return to the high surrogate */

        result = sourceExhausted;

        break;

        }

    } else if (flags == strictConversion) {

        /**//* UTF-16 surrogate values are illegal in UTF-32 */

        if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

        --source; /**//* return to the illegal value itself */

        result = sourceIllegal;

        break;

        }

    }

    if (target >= targetEnd) {

        source = oldSource; /**//* Back up source pointer! */

        result = targetExhausted; break;

    }

    *target++ = ch;

    }

    *sourceStart = source;

    *targetStart = target;

#ifdef CVTUTF_DEBUG

if (result == sourceIllegal) {

    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x/n", ch, ch2);

    fflush(stderr);

}

#endif

    return result;

}

/**//* --------------------------------------------------------------------- */

/**//*

* Index into the table below with the first byte of a UTF-8 sequence to

* get the number of trailing bytes that are supposed to follow it.

* Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is

* left as-is for anyone who may want to do such conversion, which was

* allowed in earlier algorithms.

*/

static const char trailingBytesForUTF8[256] = {

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,

    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5

};

/**//*

* Magic values subtracted from a buffer value during UTF8 conversion.

* This table contains as many values as there might be trailing bytes

* in a UTF-8 sequence.

*/

static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,

             0x03C82080UL, 0xFA082080UL, 0x82082080UL };

/**//*

* Once the bits are split out into bytes of UTF-8, this is a mask OR-ed

* into the first byte, depending on how many bytes follow.  There are

* as many entries in this table as there are UTF-8 sequence types.

* (I.e., one byte sequence, two byte etc.). Remember that sequencs

* for *legal* UTF-8 will be 4 or fewer bytes total.

*/

static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

/**//* --------------------------------------------------------------------- */

/**//* The interface converts a whole buffer to avoid function-call overhead.

* Constants have been gathered. Loops & conditionals have been removed as

* much as possible for efficiency, in favor of drop-through switches.

* (See "Note A" at the bottom of the file for equivalent code.)

* If your compiler supports it, the "isLegalUTF8" call can be turned

* into an inline function.

*/

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF8 (

    const UTF16** sourceStart, const UTF16* sourceEnd,

    UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF16* source = *sourceStart;

    UTF8* target = *targetStart;

    while (source < sourceEnd) {

    UTF32 ch;

    unsigned short bytesToWrite = 0;

    const UTF32 byteMask = 0xBF;

    const UTF32 byteMark = 0x80;

    const UTF16* oldSource = source; /**//* In case we have to back up because of target overflow. */

    ch = *source++;

    /**//* If we have a surrogate pair, convert to UTF32 first. */

    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

        /**//* If the 16 bits following the high surrogate are in the source buffer */

        if (source < sourceEnd) {

        UTF32 ch2 = *source;

        /**//* If it's a low surrogate, convert to UTF32. */

        if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

            ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

            + (ch2 - UNI_SUR_LOW_START) + halfBase;

            ++source;

        } else if (flags == strictConversion) { /**//* it's an unpaired high surrogate */

            --source; /**//* return to the illegal value itself */

            result = sourceIllegal;

            break;

        }

        } else { /**//* We don't have the 16 bits following the high surrogate. */

        --source; /**//* return to the high surrogate */

        result = sourceExhausted;

        break;

        }

    } else if (flags == strictConversion) {

        /**//* UTF-16 surrogate values are illegal in UTF-32 */

        if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

        --source; /**//* return to the illegal value itself */

        result = sourceIllegal;

        break;

        }

    }

    /**//* Figure out how many bytes the result will require */

    if (ch < (UTF32)0x80) {         bytesToWrite = 1;

    } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

    } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

    } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

    } else {                bytesToWrite = 3;

                        ch = UNI_REPLACEMENT_CHAR;

    }

    target += bytesToWrite;

    if (target > targetEnd) {

        source = oldSource; /**//* Back up source pointer! */

        target -= bytesToWrite; result = targetExhausted; break;

    }

    switch (bytesToWrite) { /**//* note: everything falls through. */

        case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

    }

    target += bytesToWrite;

    }

    *sourceStart = source;

    *targetStart = target;

    return result;

}

/**//* --------------------------------------------------------------------- */

/**//*

* Utility routine to tell whether a sequence of bytes is legal UTF-8.

* This must be called with the length pre-determined by the first byte.

* If not calling this from ConvertUTF8to*, then the length can be set by:

*  length = trailingBytesForUTF8[*source]+1;

* and the sequence is illegal right away if there aren't that many bytes

* available.

* If presented with a length > 4, this returns false.  The Unicode

* definition of UTF-8 goes up to 4-byte sequences.

*/

static Boolean isLegalUTF8(const UTF8 *source, int length) {

    UTF8 a;

    const UTF8 *srcptr = source+length;

    switch (length) {

    default: return false;

    /**//* Everything else falls through when "true" */

    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

    case 2: if ((a = (*--srcptr)) > 0xBF) return false;

    switch (*source) {

        /**//* no fall-through in this inner switch */

        case 0xE0: if (a < 0xA0) return false; break;

        case 0xED: if (a > 0x9F) return false; break;

        case 0xF0: if (a < 0x90) return false; break;

        case 0xF4: if (a > 0x8F) return false; break;

        default:   if (a < 0x80) return false;

    }

    case 1: if (*source >= 0x80 && *source < 0xC2) return false;

    }

    if (*source > 0xF4) return false;

    return true;

}

/**//* --------------------------------------------------------------------- */

/**//*

* Exported function to return whether a UTF-8 sequence is legal or not.

* This is not used here; it's just exported.

*/

Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {

    int length = trailingBytesForUTF8[*source]+1;

    if (source+length > sourceEnd) {

    return false;

    }

    return isLegalUTF8(source, length);

}

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF16 (

    const UTF8** sourceStart, const UTF8* sourceEnd,

    UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF8* source = *sourceStart;

    UTF16* target = *targetStart;

    while (source < sourceEnd) {

    UTF32 ch = 0;

    unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

    if (source + extraBytesToRead >= sourceEnd) {

        result = sourceExhausted; break;

    }

    /**//* Do this check whether lenient or strict */

    if (! isLegalUTF8(source, extraBytesToRead+1)) {

        result = sourceIllegal;

        break;

    }

    /**//*

     * The cases all fall through. See "Note A" below.

     */

    switch (extraBytesToRead) {

        case 5: ch += *source++; ch <<= 6; /**//* remember, illegal UTF-8 */

        case 4: ch += *source++; ch <<= 6; /**//* remember, illegal UTF-8 */

        case 3: ch += *source++; ch <<= 6;

        case 2: ch += *source++; ch <<= 6;

        case 1: ch += *source++; ch <<= 6;

        case 0: ch += *source++;

    }

    ch -= offsetsFromUTF8[extraBytesToRead];

    if (target >= targetEnd) {

        source -= (extraBytesToRead+1); /**//* Back up source pointer! */

        result = targetExhausted; break;

    }

    if (ch <= UNI_MAX_BMP) { /**//* Target is a character <= 0xFFFF */

        /**//* UTF-16 surrogate values are illegal in UTF-32 */

        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

        if (flags == strictConversion) {

            source -= (extraBytesToRead+1); /**//* return to the illegal value itself */

            result = sourceIllegal;

            break;

        } else {

            *target++ = UNI_REPLACEMENT_CHAR;

        }

        } else {

        *target++ = (UTF16)ch; /**//* normal case */

        }

    } else if (ch > UNI_MAX_UTF16) {

        if (flags == strictConversion) {

        result = sourceIllegal;

        source -= (extraBytesToRead+1); /**//* return to the start */

        break; /**//* Bail out; shouldn't continue */

        } else {

        *target++ = UNI_REPLACEMENT_CHAR;

        }

    } else {

        /**//* target is a character in range 0xFFFF - 0x10FFFF. */

        if (target + 1 >= targetEnd) {

        source -= (extraBytesToRead+1); /**//* Back up source pointer! */

        result = targetExhausted; break;

        }

        ch -= halfBase;

        *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

        *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

    }

    }

    *sourceStart = source;

    *targetStart = target;

    return result;

}

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF8 (

    const UTF32** sourceStart, const UTF32* sourceEnd,

    UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF32* source = *sourceStart;

    UTF8* target = *targetStart;

    while (source < sourceEnd) {

    UTF32 ch;

    unsigned short bytesToWrite = 0;

    const UTF32 byteMask = 0xBF;

    const UTF32 byteMark = 0x80;

    ch = *source++;

    if (flags == strictConversion ) {

        /**//* UTF-16 surrogate values are illegal in UTF-32 */

        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

        --source; /**//* return to the illegal value itself */

        result = sourceIllegal;

        break;

        }

    }

    /**//*

     * Figure out how many bytes the result will require. Turn any

     * illegally large UTF32 things (> Plane 17) into replacement chars.

     */

    if (ch < (UTF32)0x80) {         bytesToWrite = 1;

    } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

    } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

    } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;

    } else {                bytesToWrite = 3;

                        ch = UNI_REPLACEMENT_CHAR;

                        result = sourceIllegal;

    }

    target += bytesToWrite;

    if (target > targetEnd) {

        --source; /**//* Back up source pointer! */

        target -= bytesToWrite; result = targetExhausted; break;

    }

    switch (bytesToWrite) { /**//* note: everything falls through. */

        case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

        case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);

    }

    target += bytesToWrite;

    }

    *sourceStart = source;

    *targetStart = target;

    return result;

}

/**//* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF32 (

    const UTF8** sourceStart, const UTF8* sourceEnd,

    UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

    ConversionResult result = conversionOK;

    const UTF8* source = *sourceStart;

    UTF32* target = *targetStart;

    while (source < sourceEnd) {

    UTF32 ch = 0;

    unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

    if (source + extraBytesToRead >= sourceEnd) {

        result = sourceExhausted; break;

    }

    /**//* Do this check whether lenient or strict */

    if (! isLegalUTF8(source, extraBytesToRead+1)) {

        result = sourceIllegal;

        break;

    }

    /**//*

     * The cases all fall through. See "Note A" below.

     */

    switch (extraBytesToRead) {

        case 5: ch += *source++; ch <<= 6;

        case 4: ch += *source++; ch <<= 6;

        case 3: ch += *source++; ch <<= 6;

        case 2: ch += *source++; ch <<= 6;

        case 1: ch += *source++; ch <<= 6;

        case 0: ch += *source++;

    }

    ch -= offsetsFromUTF8[extraBytesToRead];

    if (target >= targetEnd) {

        source -= (extraBytesToRead+1); /**//* Back up the source pointer! */

        result = targetExhausted; break;

    }

    if (ch <= UNI_MAX_LEGAL_UTF32) {

        /**//*

         * UTF-16 surrogate values are illegal in UTF-32, and anything

         * over Plane 17 (> 0x10FFFF) is illegal.

         */

        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

        if (flags == strictConversion) {

            source -= (extraBytesToRead+1); /**//* return to the illegal value itself */

            result = sourceIllegal;

            break;

        } else {

            *target++ = UNI_REPLACEMENT_CHAR;

        }

        } else {

        *target++ = ch;

        }

    } else { /**//* i.e., ch > UNI_MAX_LEGAL_UTF32 */

        result = sourceIllegal;

        *target++ = UNI_REPLACEMENT_CHAR;

    }

    }

    *sourceStart = source;

    *targetStart = target;

    return result;

}

/**//* ---------------------------------------------------------------------

    Note A.

    The fall-through switches in UTF-8 reading code save a

    temp variable, some decrements & conditionals.  The switches

    are equivalent to the following loop:

    {

        int tmpBytesToRead = extraBytesToRead+1;

        do {

        ch += *source++;

        --tmpBytesToRead;

        if (tmpBytesToRead) ch <<= 6;

        } while (tmpBytesToRead > 0);

    }

    In UTF-8 writing code, the switches on "bytesToWrite" are

    similarly unrolled loops.

   --------------------------------------------------------------------- */

四、C++ 的字符串与C#的转化

1、将system::String 转化为C++的string：

// convert_system_string.cpp

// compile with: /clr

#include <string>

#include <iostream>

using namespace std;

using namespace System;

void MarshalString ( String ^ s, string& os ) {

   using namespace Runtime::InteropServices;

   const char* chars =

      (const char*)(Marshal::StringToHGlobalAnsi(s)).ToPointer();

   os = chars;

   Marshal::FreeHGlobal(IntPtr((void*)chars));

}

void MarshalString ( String ^ s, wstring& os ) {

   using namespace Runtime::InteropServices;

   const wchar_t* chars =

      (const wchar_t*)(Marshal::StringToHGlobalUni(s)).ToPointer();

   os = chars;

   Marshal::FreeHGlobal(IntPtr((void*)chars));

}

int main() {

   string a = "test";

   wstring b = L"test2";

   String ^ c = gcnew String("abcd");

   cout << a << endl;

   MarshalString(c, a);

   c = "efgh";

   MarshalString(c, b);

   cout << a << endl;

   wcout << b << endl;

}

2、将System::String转化为char*或w_char*

// convert_string_to_wchar.cpp

// compile with: /clr

#include < stdio.h >

#include < stdlib.h >

#include < vcclr.h >

using namespace System;

int main() {

   String ^str = "Hello";

   // Pin memory so GC can't move it while native function is called

   pin_ptr<const wchar_t> wch = PtrToStringChars(str);

   printf_s("%S/n", wch);

   // Conversion to char* :

   // Can just convert wchar_t* to char* using one of the

   // conversion functions such as:

   // WideCharToMultiByte()

   // wcstombs_s()

   //  etc

   size_t convertedChars = 0;

   size_t  sizeInBytes = ((str->Length + 1) * 2);

   errno_t err = 0;

   char    *ch = (char *)malloc(sizeInBytes);

   err = wcstombs_s(&convertedChars,

                    ch, sizeInBytes,

                    wch, sizeInBytes);

   if (err != 0)

      printf_s("wcstombs_s  failed!/n");

    printf_s("%s/n", ch);

}

五、GBK与UTF-8的转换

VC中GBK与UTF8字符串的转换

     void   ConvertGBKToUtf8(CString strGBK)   {

      int   len=MultiByteToWideChar(CP_ACP,   0,   (LPCTSTR)strGBK,   -1,   NULL,0);

     unsigned   short   *   wszUtf8   =   new   unsigned   short[len+1];

     memset(wszUtf8,   0,   len   *   2   +   2);

     MultiByteToWideChar(CP_ACP,   0,   (LPCTSTR)strGBK,   -1,   wszUtf8,   len);

     len   =   WideCharToMultiByte(CP_UTF8,   0,   wszUtf8,   -1,   NULL,   0,   NULL,   NULL);

     char   *szUtf8=new   char[len   +   1];

     memset(szUtf8,   0,   len   +   1);

   WideCharToMultiByte   (CP_UTF8,   0,   wszUtf8,   -1,   szUtf8,   len,   NULL,NULL);

    strGBK   =   szUtf8;

    delete[]   szUtf8;

    delete[]   wszUtf8;

   }

    void   ConvertUtf8ToGBK(CString strUtf8)   {

     int   len=MultiByteToWideChar(CP_UTF8,   0,   (LPCTSTR)strUtf8,   -1,   NULL,0);

     unsigned   short   *   wszGBK   =   new   unsigned   short[len+1];

     memset(wszGBK,   0,   len   *   2   +   2);

     MultiByteToWideChar(CP_UTF8,   0,   (LPCTSTR)strUtf8,   -1,   wszGBK,   len);

     len   =   WideCharToMultiByte(CP_ACP,   0,   wszGBK,   -1,   NULL,   0,   NULL,   NULL);

   char   *szGBK=new   char[len   +   1];

     memset(szGBK,   0,   len   +   1);

     WideCharToMultiByte   (CP_ACP,   0,   wszGBK,   -1,   szGBK,   len,   NULL,NULL);

   strUtf8   =   szGBK;

   delete[]   szGBK;

   delete[]   wszGBK;

   }

六、UTF-8与GB2312之间的互换

int WideCharToMultiByte(

       UINT CodePage, // code page

       DWORD dwFlags, // performance and mapping flags

       LPCWSTR lpWideCharStr, // wide-character string

       int cchWideChar, // number of chars in string

       LPSTR lpMultiByteStr, // buffer for new string

       int cbMultiByte, // size of buffer

       LPCSTR lpDefaultChar, // default for unmappable chars

       LPBOOL lpUsedDefaultChar // set when default char used

); //将宽字符转换成多个窄字符

int MultiByteToWideChar(

       UINT CodePage, // code page

       DWORD dwFlags, // character-type options

       LPCSTR lpMultiByteStr, // string to map

       int cbMultiByte, // number of bytes in string

       LPWSTR lpWideCharStr, // wide-character buffer

       int cchWideChar // size of buffer

);//将多个窄字符转换成宽字符     

// 把Unicode 转换成 GB2312

     void UnicodeToGB2312(char* pOut,unsigned short uData)

     {

            WideCharToMultiByte(CP_ACP,NULL,&uData,1,pOut,sizeof(WCHAR),NULL,NULL);

            return;

     }    

//GB2312 转换成　Unicode

WCHAR * Gb2312ToUnicode(char *gbBuffer)  {

       WCHAR *uniChar;

       uniChar = new WCHAR[1];

       ::MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,gbBuffer,2,uniChar,1);

       return uniChar;

}

The example code is simple MFC dialog application showing encoding and decoding. The same code works for both ANSI and Unicode. The function to encode is:
`CString EncodeToUTF8(LPCTSTR szSource)``{``  WORD ch;`` ``  BYTE bt1, bt2, bt3, bt4, bt5, bt6;`` ``  int n, nMax = _tcslen(szSource);`` ``  CString sFinal, sTemp;`` ``  for (n = 0; n < nMax; ++n)``  {``    ch = (WORD)szSource[n];`` ``    if (ch == _T('='))``    {``      sTemp.Format(_T("=%02X"), ch);`` ``      sFinal += sTemp;``    }``    else if (ch < 128)``    {``      sFinal += szSource[n];``    }``    else if (ch <= 2047)``    {``       bt1 = (BYTE)(192 + (ch / 64));``       bt2 = (BYTE)(128 + (ch % 64));`` ``      sTemp.Format(_T("=%02X=%02X"), bt1, bt2);``            ``      sFinal += sTemp;``    }``    else if (ch <= 65535)``    {``       bt1 = (BYTE)(224 + (ch / 4096));``       bt2 = (BYTE)(128 + ((ch / 64) % 64));``       bt3 = (BYTE)(128 + (ch % 64));`` ``      sTemp.Format(_T("=%02X=%02X=%02X"), bt1, bt2, bt3);``            ``      sFinal += sTemp;``    }``    else if (ch <= 2097151)``    {``       bt1 = (BYTE)(240 + (ch / 262144));``       bt2 = (BYTE)(128 + ((ch / 4096) % 64));``       bt3 = (BYTE)(128 + ((ch / 64) % 64));``       bt4 = (BYTE)(128 + (ch % 64));`` ``      sTemp.Format(_T("=%02X=%02X=%02X=%02X"), bt1, bt2, bt3, bt4);``      sFinal += sTemp;``    }``    else if (ch <=67108863)``    {``      bt1 = (BYTE)(248 + (ch / 16777216));``      bt2 = (BYTE)(128 + ((ch / 262144) % 64));``      bt3 = (BYTE)(128 + ((ch / 4096) % 64));``      bt4 = (BYTE)(128 + ((ch / 64) % 64));``      bt5 = (BYTE)(128 + (ch % 64));`` ``      sTemp.Format(_T("=%02X=%02X=%02X=%02X=%02X"), bt1, bt2, bt3, bt4, bt5);``      sFinal += sTemp;``    }``    else if (ch <=2147483647)``    {``       bt1 = (BYTE)(252 + (ch / 1073741824));``       bt2 = (BYTE)(128 + ((ch / 16777216) % 64));``       bt3 = (BYTE)(128 + ((ch / 262144) % 64));``       bt4 = (BYTE)(128 + ((ch / 4096) % 64));``       bt5 = (BYTE)(128 + ((ch / 64) % 64));``       bt6 = (BYTE)(128 + (ch % 64));`` ``      sTemp.Format(_T("=%02X=%02X=%02X=%02X=%02X=%02X"), ``                bt1, bt2, bt3, bt4, bt5, bt6);``      sFinal += sTemp;``    }`` ``  }`` ``  return sFinal;``}`` `
The function to decode is:
`CString DecodeFromUTF8(LPCTSTR szSource)``{``  TRACE(_T("/n"));`` ``  int n, nMax = _tcslen(szSource);``  WORD ch;`` ``  CString sFinal, sTemp;`` ``  BYTE z, y, x, w, v, u;``  ``  for (n = 0; n < nMax; ++n)``  {``    ch = (WORD)szSource[n];`` ``    if (ch != _T('='))``    {``      sFinal += (TCHAR)ch;``      continue;``    }`` ``    if (n >= nMax - 2) break; // something is wrong``    z = MakeByte(szSource[n+1], szSource[n+2]);`` ``    if (z < 127)``    {``      sFinal += (TCHAR)z;``      n = n + 2;``    }``    else if (z >= 192 && z <= 223)``    {``      // character is two bytes``      if (n >= nMax - 5) break; // something is wrong``      y = MakeByte(szSource[n+4], szSource[n+5]);``      sFinal += (TCHAR)( (z-192)*64 + (y-128) );``      n = n + 5;``    }``    else if (z >= 224 && z <= 239)``    {``      // character is three bytes``      if (n >= nMax - 8) break; // something is wrong``      y = MakeByte(szSource[n+4], szSource[n+5]);``      x = MakeByte(szSource[n+7], szSource[n+8]);``      sFinal += (TCHAR)( (z-224)*4096 + (y-128)*64 + (x-128) );``      n = n + 8;``    }``    else if (z >= 240 && z <= 247)``    {``      // character is four bytes``      if (n >= nMax - 11) break; // something is wrong``      y = MakeByte(szSource[n+4], szSource[n+5]);``      x = MakeByte(szSource[n+7], szSource[n+8]);``      w = MakeByte(szSource[n+10], szSource[n+11]);``      sFinal += (TCHAR)( (z-240)*262144 + (y-128)*4096 + ``             (x-128)*64 + (w-128) );``      n = n + 11;``    }``    else if (z >= 248 && z <= 251)``    {``      // character is four bytes``      if (n >= nMax - 14) break; // something is wrong``      y = MakeByte(szSource[n+4], szSource[n+5]);``      x = MakeByte(szSource[n+7], szSource[n+8]);``      w = MakeByte(szSource[n+10], szSource[n+11]);``      v = MakeByte(szSource[n+13], szSource[n+14]);``      sFinal += (TCHAR)( (z-248)*16777216 + (y-128)*262144 + ``           (x-128)*4096 + (w-128)*64 + (v-128) );``      n = n + 14;``    }``    else if (z >= 252 && z <= 253)``    {``      // character is four bytes``      if (n >= nMax - 17) break; // something is wrong``      y = MakeByte(szSource[n+4], szSource[n+5]);``      x = MakeByte(szSource[n+7], szSource[n+8]);``      w = MakeByte(szSource[n+10], szSource[n+11]);``      v = MakeByte(szSource[n+13], szSource[n+14]);``      u = MakeByte(szSource[n+16], szSource[n+17]);``      sFinal += (TCHAR)( (z-252)*1073741824 + (y-128)*16777216 + ``          (x-128)*262144 + (w-128)*4096 + (v-128)*64 + (u-128) );``      n = n + 17;``    }``    ``  }`` ``  return sFinal;``}`
The `Decode `function also requires this helper function `MakeByte` to convert a two-character pair into the appropriate byte.
`// helper function for decoding``BYTE MakeByte(TCHAR ch1, TCHAR ch2)``{``  BYTE bt1 = 0, bt2 = 0;`` ``  switch (ch2)``  {``    case _T('0'):``      bt2 = 0x00;``      break;``    case _T('1'):``      bt2 = 0x01;``      break;``    case _T('2'):``      bt2 = 0x02;``      break;``    case _T('3'):``      bt2 = 0x03;``      break;``    case _T('4'):``      bt2 = 0x04;``      break;``    case _T('5'):``      bt2 = 0x05;``      break;``    case _T('6'):``      bt2 = 0x06;``      break;``    case _T('7'):``      bt2 = 0x07;``      break;``    case _T('8'):``      bt2 = 0x08;``      break;``    case _T('9'):``      bt2 = 0x09;``      break;``    case _T('A'):``      bt2 = 0x0A;``      break;``    case _T('B'):``      bt2 = 0x0B;``      break;``    case _T('C'):``      bt2 = 0x0C;``      break;``    case _T('D'):``      bt2 = 0x0D;``      break;``    case _T('E'):``      bt2 = 0x0E;``      break;``    case _T('F'):``      bt2 = 0x0F;``      break;``  }`` ``  switch (ch1)``  {``    case _T('0'):``      bt1 = 0x00;``      break;``    case _T('1'):``      bt1 = 0x10;``      break;``    case _T('2'):``      bt1 = 0x20;``      break;``    case _T('3'):``      bt1 = 0x30;``      break;``    case _T('4'):``      bt1 = 0x40;``      break;``    case _T('5'):``      bt1 = 0x50;``      break;``    case _T('6'):``      bt1 = 0x60;``      break;``    case _T('7'):``      bt1 = 0x70;``      break;``    case _T('8'):``      bt1 = 0x80;``      break;``    case _T('9'):``      bt1 = 0x90;``      break;``    case _T('A'):``      bt1 = 0xA0;``      break;``    case _T('B'):``      bt1 = 0xB0;``      break;``    case _T('C'):``      bt1 = 0xC0;``      break;``    case _T('D'):``      bt1 = 0xD0;``      break;``    case _T('E'):``      bt1 = 0xE0;``      break;``    case _T('F'):``      bt1 = 0xF0;``      break;``  }`` ``  BYTE btFinal = bt2 | bt1;`` ``  return  btFinal;  `` ``}`` `


