# 字符串字符分割代码 - 深之JohnChen的专栏 - CSDN博客

2017年05月02日 18:20:43[byxdaz](https://me.csdn.net/byxdaz)阅读数：604


```cpp
#include <list>
#include <string>
#include <vector>
using namespace std;

//获取两种字符之间的数字
void GeDataListByStartStopSplitFlag(char *pContent,std::list<int> & listId,char cStartFlag='{',char cStopFlag='}');

//获取分割数据（通过分隔符）
void GeDataListBySplitFlag(char *pContent,std::list<std::string> & listId,char *pSplitFlag=",");

//分割字符
void StringSplit(char *pStr,int nSplitFlag,list<string> & listSplit);

// 字符串分割
int StringSplitEx(std::vector<std::string>& dst, const std::string& src, const std::string& separator);

// 去掉前后空格
std::string& StringTrim(std::string &str);
```

```cpp
//获取两种字符之间的数据
void GeDataListByStartStopSplitFlag(char *pContent,std::list<int> & listId,char cStartFlag,char cStopFlag)
{
	listId.clear();
	if(pContent != NULL)
	{
		char *p = pContent;
		char *q = NULL;
		char *qn = NULL;
		int nId = 0;
		char szId[32] = {0};
		while(true)
		{
			q = strchr(p,cStartFlag);
			if(q != NULL)
			{
				qn = strchr(q+1,cStopFlag);
				if(qn != NULL)
				{
					memset(szId,0,sizeof(szId));
					memcpy(szId,q+1,qn-q-1);
					nId = atoi(szId);
					listId.push_back(nId);
					p = qn+1;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
	}
}

//获取分割数据（通过分隔符）
void GeDataListBySplitFlag(char *pContent,std::list<std::string> & listId,char *pSplitFlag)
{
	listId.clear();
	if(pContent != NULL)
	{
		int nSplitFlagLength = strlen(pSplitFlag);
		char *p = pContent;
		char *q = NULL;
		char *qn = NULL;
		int nId = 0;
		char szId[128] = {0};
		while(true)
		{
			q = strstr(p,pSplitFlag);
			if(q != NULL)
			{
				memset(szId,0,sizeof(szId));
				memcpy(szId,p,q-p);
				listId.push_back(szId);
				//下一个
				p = q+nSplitFlagLength;
			}
			else
			{
				if(p != '\0')
				{
					memset(szId,0,sizeof(szId));
					strcpy(szId,p);
					listId.push_back(szId);
				}
				break;
			}
		}
	}
}
```

```cpp
//分割字符
void StringSplit(char *pStr,int nSplitFlag,list<string> & listSplit)
{
	listSplit.clear();

	if(NULL == pStr)
		return;

	if('\0' == nSplitFlag)
	{
		listSplit.push_back(pStr);
	}
	else
	{
		char *p = NULL;
		char *q = pStr;
		char szTmp[128] = {0};
		while(true)
		{
			p = strchr(q,nSplitFlag);
			memset(szTmp,0,sizeof(szTmp));
			if(p != NULL)
			{
				memcpy(szTmp,q,p-q);
				listSplit.push_back(szTmp);
				q = p+1;
				if(q == NULL)
				{
					break;
				}
			}
			else
			{
				strcpy(szTmp,q);
				listSplit.push_back(szTmp);
				break;
			}
		}
	}
}
```

```
// 字符串分割
int StringSplitEx(std::vector<std::string>& dst, const std::string& src, const std::string& separator)
{
	if (src.empty() || separator.empty())
		return 0;

	int nCount = 0;
	std::string temp;
	size_t pos = 0, offset = 0;

	// 分割第1~n-1个
	while ((pos = src.find_first_of(separator, offset)) != std::string::npos)
	{
		temp = src.substr(offset, pos - offset);
		if (temp.length() >= 0) {
			dst.push_back(temp);
			nCount++;
		}
		offset = pos + 1;
	}

	// 分割第n个
	temp = src.substr(offset, src.length() - offset);
	if (temp.length() >= 0) {
		dst.push_back(temp);
		nCount++;
	}

	return nCount;
}

//去前后空格
std::string& StringTrim(std::string &str)
{
	if (str.empty()) {
		return str;
	}
	str.erase(0, str.find_first_not_of(" "));
	str.erase(str.find_last_not_of(" ") + 1);
	return str;
}
```



