# 纯资源动态连接库显示图像 - 深之JohnChen的专栏 - CSDN博客

2007年11月05日 12:14:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：1516标签：[dll																[colors																[button																[mfc																[null																[脚本](https://so.csdn.net/so/search/s.do?q=脚本&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=mfc&t=blog)](https://so.csdn.net/so/search/s.do?q=button&t=blog)](https://so.csdn.net/so/search/s.do?q=colors&t=blog)](https://so.csdn.net/so/search/s.do?q=dll&t=blog)
个人分类：[VC](https://blog.csdn.net/byxdaz/article/category/7211574)


纯资源 DLL 是仅包含资源（如图标、位图、字符串和对话框）的 DLL。使用纯资源 DLL 是在多个程序之间共享同一组资源的好方法。提供其资源被针对多种语言进行本地化的应用程序也是一种好方法若要创建纯资源 DLL，请创建一个新的 Win32 DLL（非 MFC）项目，并将资源添加到此项目。 
- 在“新建项目”对话框中选择“Win32 项目”，并在“Win32 项目向导”中指定 DLL 项目类型。 
- 为 DLL 创建一个包含资源（如字符串或菜单）的新资源脚本，并保存该 .rc 文件。 
- 在“项目”菜单上单击“添加现有项”，并在项目中插入这个新的 .rc 文件。 
- 指定 [/NOENTRY](http://msdn.microsoft.com/library/CHS/vccore/html/_core_.2f.noentry.asp) 链接器选项。/NOENTRY 防止链接器将 _main 引用链接到 DLL 中；此选项是创建纯资源 DLL 所必需的。 
- 生成 DLL。 

使用纯资源 DLL 的应用程序应调用 **LoadLibrary** 来[显式链接到 DLL](http://msdn.microsoft.com/library/CHS/vccore/html/_core_loadlibrary_and_afxloadlibrary.asp)。若要访问资源，请调用一般函数 **FindResource** 和 **LoadResource**，这两个函数对任何类型的资源都有效，或调用下列资源特定的函数之一： 
- **FormatMessage**
- **LoadAccelerators**
- **LoadBitmap**
- **LoadCursor**
- **LoadIcon**
- **LoadMenu**
- **LoadString**

使用完资源后，应用程序应调用 **FreeLibrary**。

实例1:

HMODULE hMod = LoadLibrary("WindllTest.dll");
 if(!hMod)
  return;

HBITMAP hb = LoadBitmap(hMod,MAKEINTRESOURCE(IDB_BITMAP1));
((CButton *)GetDlgItem(IDC_BUTTON2))->SetBitmap(hb);

 FreeLibrary(hMod); 

实例2:

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
 LPBITMAPINFOHEADER lpbi;
 LPLOGPALETTE lpPal;
 HANDLE hLogPal;
 HPALETTE hPal = NULL;
 int i;
 lpbi = (LPBITMAPINFOHEADER)lpbmi;
 if (lpbi->biBitCount <= 8)
  *lpiNumColors = (1 << lpbi->biBitCount);
 else
  *lpiNumColors = 0; // No palette needed for 24 BPP DIB
 if (lpbi->biClrUsed > 0)
  *lpiNumColors = lpbi->biClrUsed; // Use biClrUsed
 if (*lpiNumColors)
 {
  hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
   sizeof (PALETTEENTRY) * (*lpiNumColors));
  lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
  lpPal->palVersion = 0x300;
  lpPal->palNumEntries = *lpiNumColors;
  for (i = 0; i < *lpiNumColors;i++)
  {
   lpPal->palPalEntry[i].peRed = lpbmi->bmiColors[i].rgbRed;
   lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
   lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;
   if (i<=10 || i>=246)
    lpPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
   else
    lpPal->palPalEntry[i].peFlags = 0;
  }
  hPal = CreatePalette (lpPal);
  GlobalUnlock (hLogPal);
  GlobalFree (hLogPal);
 }
 return hPal;
}

void showImage()
{

 HMODULE hMod = LoadLibrary("WindllTest.dll");
 if(!hMod)
  return;
    HRSRC hrs = FindResource(hMod,MAKEINTRESOURCE(IDB_BITMAP1),RT_BITMAP); 
 HGLOBAL hg = LoadResource(hMod,hrs);
 HBITMAP hBitmapFinal;
 LPBITMAPINFOHEADER lpbi;
 HPALETTE lphPalette;
 int iNumColors;
 HDC hdc;
 hdc = ::GetDC(NULL);
 lpbi = (LPBITMAPINFOHEADER)LockResource(hg);
 lphPalette = CreateDIBPalette((LPBITMAPINFO)lpbi, &iNumColors);
 if (lphPalette)
 {
  ::SelectPalette(hdc,lphPalette,FALSE);
  ::RealizePalette(hdc);
 }

 hBitmapFinal = ::CreateDIBitmap(hdc,
  (LPBITMAPINFOHEADER)lpbi,
  (LONG)CBM_INIT,
  (LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),
  (LPBITMAPINFO)lpbi,
  DIB_RGB_COLORS );
 UnlockResource(hg);
    ((CButton *)GetDlgItem(IDC_BUTTON2))->SetBitmap(hBitmapFinal);

 FreeLibrary(hMod);

}


