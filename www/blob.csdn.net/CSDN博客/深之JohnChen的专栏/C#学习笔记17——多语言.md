# C#学习笔记17——多语言 - 深之JohnChen的专栏 - CSDN博客

2011年09月01日 23:17:50[byxdaz](https://me.csdn.net/byxdaz)阅读数：5626标签：[语言																[c#																[string																[table																[dataset																[encoding](https://so.csdn.net/so/search/s.do?q=encoding&t=blog)](https://so.csdn.net/so/search/s.do?q=dataset&t=blog)](https://so.csdn.net/so/search/s.do?q=table&t=blog)](https://so.csdn.net/so/search/s.do?q=string&t=blog)](https://so.csdn.net/so/search/s.do?q=c#&t=blog)](https://so.csdn.net/so/search/s.do?q=语言&t=blog)
个人分类：[.Net & C#](https://blog.csdn.net/byxdaz/article/category/628880)


C#实现多语言方法有很多种。这里只介绍两种，一种是修改对应每种语言的资源文件；另外一种是通过XML自动加载某语言的xml文件，同时动态读取对应的自动值并显示。

一、修改资源文件

1、要在项目稳定以后，再做多语言本地化。

2、做语言主要注意一下几点

![](http://hi.csdn.net/attachment/201109/1/0_13148902945HP8.gif)

2.1控件（包括窗体）的多语言支持，可以在vs2008的命令提示中输入winres。采用可视化的操作界面进行设置

窗体需要设置LocalLizable= true

并选择Language

2.2变量多语言：

(1)代码中一定不要使用硬编码。

(2)使用此编码方式：string msg = Properties.Resources.InfoMsg。InfoMsg是通过Resources.resx设置。

因此所有的需要多语言处理的都要用变量的方式在Resources.resx进行设置

(3)在程序完成后，复制Resources.resx文件。将其命名为Resources.en-GB.resx。

3、在程序出口处，加入以下语句

System.Globalization.CultureInfo UICulture= new System.Globalization.CultureInfo("en-GB");

Thread.CurrentThread.CurrentUICulture =UICulture;

通过以上步骤即可完成程序多语言

注意：多语言处理后，程序bin目录下就会出现相应的多语言的文件夹

![](http://hi.csdn.net/attachment/201109/1/0_1314890306brau.gif)

二、动态加载语言的xml配置文件

通过配置文件实现，通过从配置文件中读取资源，然后在显示窗口的时候，即Load()方法中，动态显示相应的选择语言。 

　　下面是在C#的Windows编程中实现多语言的步骤：

　　第一步：设置默认语言和修改默认语言

　　我们定义了一个XML文件来存放默认语言，文件名为LanguageDefine.xml。

　　LanguageDefine.xml

> 

```
＜?xml  version="1.0" standalone="yes"?＞
  ＜Language＞
  ＜DefaultLanguage＞ZH＜/DefaultLanguage＞
  ＜/Language＞
```


　　该文件只有一个DefaultLanguage属性，用于存放默认语言，需要注意的是这个属性要与语言配置文件中_后的字符串相同。

　　下面是用于读取默认语言和修改默认语言的函数：

> 
```
//读取默认语言
  public static string ReadDefaultLanguage(){
  　XmlReader  reader = new XmlTextReader("resources/LanguageDefine.xml");
  　XmlDocument  doc = new XmlDocument();
  　doc.Load(reader);
  　XmlNode  root = doc.DocumentElement;
  　//选取DefaultLangugae节点
  　XmlNode  node = root.SelectSingleNode("DefaultLanguage");
  
  　string  result = "EN";
  　if (node !=  null)
  　　//取出节点中的内容
  　　result =  node.InnerText;
  
  　　reader.Close();
  　return  result;
  }
  //修改默认语言
  public static void WriteDefaultLanguage(string lang){
  　DataSet ds  = new DataSet();
  　ds.ReadXml("resources/LanguageDefine.xml");
  　DataTable  dt = ds.Tables["Language"];
  
  　dt.Rows[0]["DefaultLanguage"]  = lang;
  　ds.AcceptChanges();
  　ds.WriteXml("resources/LanguageDefine.xml");
  }
```

　　我们又用一个XML文件来存储要显示的语言的种类，和在特定的语言下语言选择下拉菜单的显示文字。现我们只构造了两种语言，不过通过添加Item，我们可以很容易的实现增加一种语言的功能。

　　我们是通过一个ComboBox下拉菜单来实现多语言的选择的，当选择了相应的语言时，我们会把系统的默认语言，即LanguageDefine.xml中的语言改成所选的语言。同时，系统马上重新Load()，以显示所选择的语言对应的界面。

　　AppConfig.xml

> 

```
＜?xml  version="1.0" encoding="gb2312"?＞
  ＜AppConfig＞
  ＜Area＞
  ＜Language＞ZH＜/Language＞
  ＜List＞
  ＜Item＞中文[ZH]＜/Item＞
  ＜Item＞英文[EN]＜/Item＞
  ＜/List＞
  ＜/Area＞
  ＜Area＞
  ＜Language＞EN＜/Language＞
  ＜List＞
  ＜Item＞Chinese[ZH]＜/Item＞
  ＜Item＞English[EN]＜/Item＞
  ＜/List＞
  ＜/Area＞
  ＜Area＞
  ＜/AppConfig＞
```

　　相应的读取该配置文件的函数是：

> 

```
public static IList  GetLanguageList(string lang){
  IList result = new ArrayList();
  
  XmlReader reader = new XmlTextReader("resources/AppConfig.xml");
  XmlDocument doc = new XmlDocument();
  doc.Load(reader);
  
  XmlNode root = doc.DocumentElement;
  XmlNodeList nodelist = root.SelectNodes("Area[Language='" + lang +'"]  /List/Item");
  foreach (XmlNode node in nodelist){
  　result.Add(node.InnerText);  
  }
  reader.Close();
  
  return result;
  }
```

　　第三步：根据语言获取要显示页面的显示值

　　通过上面的几步，我们可以在每个页面的Load()方法中，根据ReadDefaultLanguage()函数，获取这个页面的显示语言。取得默认语言后，我们要该语言的资源文件中读取相应的资源。

　　该资源文件的格式如下(现只显示英文的资源文件，中文资源文件的格式与其相同，只是text中的值换成了相应的中文值)：

　　AppResource_EN.xml

> 

```
＜?xml  version="1.0" encoding="utf-8" ?＞
  ＜Resource＞
  ＜Form＞
  ＜Name＞FrmLogon＜/Name＞
  ＜Controls＞
  ＜Control  name="frmlogon" text="User logon" /＞
  ＜Control  name="lblusername" text="Username:" /＞
  ＜Control  name="lblpassword" text="Password:" /＞
  ＜Control  name="lbllanguage" text="Language:" /＞
  ＜Control  name="btnlogon" text="Logon" /＞
  ＜Control  name="btncancel" text="Exit" /＞
  ＜Control  name="btnchangepwd" text="Change Password" /＞
  ＜/Controls＞
  ＜/Form＞
  ＜Form＞
  ＜Name＞FrmPasswordChange＜/Name＞
  ＜Controls＞
  ＜Control name="frmpasswordchange"  text="Change password" /＞
  ＜Control  name="lblusername" text="Username:" /＞
  ＜Control  name="lblpassword" text="Old Password:" /＞
  ＜Control  name="lblnewpassword" text="New Password:" /＞
  ＜Control  name="lblpasswordconfirm" text="Password Confirm:" /＞
  ＜Control  name="btnok" text="OK" /＞
  ＜Control  name="btncancel" text="Return" /＞
  ＜/Controls＞
  ＜/Form＞
  ＜/Resource＞
```

　　我们把一个窗体中要实现多语言显示的控件的名称全都放在＜Controls＞＜/Controls＞中，name指的是控件的Name属性，而text指的是控件的Text属性。

　　读取的函数如下：

> 

```
/// ＜summary＞
  /// 读取多语言的资源文件
  /// ＜/summary＞
  /// ＜param  name="frmName"＞窗体的Name＜/param＞
  /// ＜param  name="lang"＞要显示的语言(如ZH或EN)＜/param＞
  /// ＜returns＞＜/returns＞
  public static Hashtable ReadResource(string frmName,string lang){
  　Hashtable  result = new Hashtable();
  
  　XmlReader  reader = null;
  　FileInfo fi  = new FileInfo("resources/AppResource_" + lang + ".xml");
  　if  (!fi.Exists)
  　　reader =  new XmlTextReader("resources/AppResource.xml");
  　else
  　　reader =  new XmlTextReader("resources/AppResource_" + lang +  ".xml");
  
  　XmlDocument  doc = new XmlDocument();
  　doc.Load(reader);
  
  　XmlNode  root = doc.DocumentElement;
  　XmlNodeList  nodelist = root.SelectNodes("Form[Name='" + frmName +  "']/Controls/Control");
  　foreach  (XmlNode node in nodelist){
  　　try{
  　　　XmlNode  node1 = node.SelectSingleNode("@name");
  　　　XmlNode  node2 = node.SelectSingleNode("@text");
  　　　if (node1  != null){
  　　　　result.Add(node1.InnerText.ToLower(),node2.InnerText);
  　　　}
  　　　}catch(FormatException  fe){
  　　　　Console.WriteLine(fe.ToString());
  　　　}
  　　}
  　　reader.Close();
  　return  result;
  }
```

　　第四步：显示相应的值

　　我们可以在每个窗体的Load()事件中，调用相应的函数，来实现这个功能。当然，我们首先必须先，获得这个窗体要显示的语言的代码(如EN或ZH)，该值可以存放在一个"全局"变量中(比如把值通过Global.SetValue("lang",langugae)存入，通过Global.GetValue("lang")取出)。

> 

```
/// ＜summary＞
  /// 获取控件的名称
  /// ＜/summary＞
  /// ＜param  name="form"＞＜/param＞
  public static void getNames(Form form)
  {
  
  　//根据用户选择的语言获得表的显示文字
  　Hashtable  table = 　　AppConfig.ReadResource(form.Name,Global.GetValue("lang").ToString());
  　Control.ControlCollection  controlNames = form.Controls;
  　//可以在这里设置窗体的一些统一的属性，这样所有的窗体都会应用该设置
  　//  form.KeyPreview = true;
  　//  form.MaximizeBox = false;
  　//  form.MinimizeBox = false;
  　//  form.ControlBox = false;
  　//  form.FormBorderStyle = FormBorderStyle.FixedDialog;
  　//  form.StartPosition = FormStartPosition.CenterScreen;
  　//  form.TopMost = true;
  　//  form.KeyDown += new KeyEventHandler(OnEnter);
  　try
  　{
  　　foreach(Control  control in controlNames)
  　　{
  　　　if(control.GetType()  == typeof(System.Windows.Forms.Panel))
  GetSubControls(control.Controls,table);
  
  　　　if(control.GetType()  == typeof(System.Windows.Forms.GroupBox))
  GetSubControls(control.Controls,table);
  
  　　　//  if(control.GetType() == typeof(System.Windows.Forms.TextBox) &&  control.Enabled)
  　　　//  control.GotFocus += new EventHandler(Txt_Focus);
  
  　　　if(table.Contains(control.Name.ToLower()))
  control.Text = (string)table[control.Name.ToLower()];
  　　}
  　　if(table.Contains(form.Name.ToLower()))
  　　　form.Text  = (string)table[form.Name.ToLower()];
  　}
  　catch(Exception  ex)
  　　Console.WriteLine(ex.ToString());
  }
```

　　因为有些控件其内部还有子控件，所以我们还要有个读取控件中子控件的显示值的函数。

> 

```
/// ＜summary＞
  /// 获得子控件的显示名
  /// ＜/summary＞
  /// ＜param  name="controls"＞＜/param＞
  /// ＜param  name="table"＞＜/param＞
  private static void GetSubControls(Control.ControlCollection  controls,Hashtable table)
  {
  　foreach(Control  control in controls)
  　{
  　　if(control.GetType()  == typeof(System.Windows.Forms.Panel))
  GetSubControls(control.Controls,table);
  
  　　if(control.GetType()  == typeof(System.Windows.Forms.GroupBox))
  GetSubControls(control.Controls,table);
  
  　　if(table.Contains(control.Name.ToLower()))
  control.Text = (string)table[control.Name.ToLower()];
  　}
  }
```



