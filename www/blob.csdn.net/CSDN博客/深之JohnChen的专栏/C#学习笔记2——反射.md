# C#学习笔记2——反射 - 深之JohnChen的专栏 - CSDN博客

2011年08月29日 22:19:05[byxdaz](https://me.csdn.net/byxdaz)阅读数：1391


**C#反射 **

一、反射的概述 
反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等，。System.reflection命名空间包含的几个类，允许你反射（解析）这些元数据表的代码 

和反射相关的命名空间（我们就是通过这几个命名空间访问反射信息）： 
System.Reflection.MemberInfo 
System.Reflection.EventInfo 
System.Reflection.FieldInfo 
System.Reflection.MethodBase 
System.Reflection.ConstructorInfo 
System.Reflection.MethodInfo 
System.Reflection.PropertyInfo 
System.Type 
System.Reflection.Assembly 

反射的层次模型： 
注：层次间都是一对多的关系 

反射的作用： 
1． 可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。
2． 应用程序需要在运行时从某个特定的程序集中载入一个特定的类型，以便实现某个任务时可以用到反射。
3． 反射主要应用与类库，这些类库需要知道一个类型的定义，以便提供更多的功能。 

应用要点： 
1． 现实应用程序中很少有应用程序需要使用反射类型
2． 使用反射动态绑定需要牺牲性能
3． 有些元数据信息是不能通过反射获取的
4． 某些反射类型是专门为那些clr 开发编译器的开发使用的，所以你要意识到不是所有的反射类型都是适合每个人的。 

二、如何使用程序集
**反射appDomain 的程序集**
当你需要反射AppDomain中包含的所有程序集，示例如下： 
static void Main 

{ 

//通过GetAssemblies调用appDomain的所有程序集 

foreach (Assembly assem in Appdomain.currentDomain.GetAssemblies()) 

{ 

//反射当前程序集的信息 

reflector.ReflectOnAssembly(assem) 

} 

} 

说明：调用AppDomain对象的GetAssemblies方法 将返回一个由System.Reflection.Assembly元素组成的数组。 

**反射单个程序集**
上面的方法讲的是反射AppDomain的所有程序集，我们可以显示的调用其中的一个程序集，system.reflecton.assembly类型提供了下面三种方法： 

1． Load 方法：极力推荐的一种方法，Load 方法带有一个程序集标志并载入它，Load 将引起CLR把策略应用到程序集上，先后在全局程序集缓冲区，应用程序基目录和私有路径下面查找该程序集，如果找不到该程序集系统抛出异常 

2． LoadFrom 方法：传递一个程序集文件的路径名（包括扩展名），CLR会载入您指定的这个程序集，传递的这个参数不能包含任何关于版本号的信息，区域性，和公钥信息，如果在指定路径找不到程序集抛出异常。 

3．LoadWithPartialName：永远不要使用这个方法，因为应用程序不能确定再在载入的程序集的版本。该方法的唯一用途是帮助那些在.Net框架的测试环节使用.net 框架提供的某种行为的客户，这个方法将最终被抛弃不用。 

注意：system.AppDomain也提供了一种Load 方法，他和Assembly的静态Load 方法不一样，AppDomain的 load 方法是一种实例方法，返回的是一个对程序集的引用，Assembly的静态Load 方发将程序集按值封装发回给发出调用的 AppDomain.尽量避免使用AppDomain的load 方法。

**反射技术**
程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。反射通常具有以下用途： 
使用 Assembly 定义和加载程序集，加载在程序集清单中列出的模块，以及从此程序集中查找类型并创建该类型的实例。 
使用 Module 了解如下的类似信息：包含模块的程序集以及模块中的类等。您还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。 
使 用 ConstructorInfo 了解如下的类似信息：构造函数的名称、参数、访问修饰符（如 public 或 private）和实现详细信息（如 abstract 或 virtual）等。使用 Type 的GetConstructors 或GetConstructor 方法来调用特定的构造函数。 
使用 MethodInfo 来了解如下的类似信息：方法的名称、返回类型、参数、访问修饰符（如public 或 private）和实现详细信息（如 abstract 或 virtual）等。使用 Type 的 GetMethods 或 GetMethod 方法来调用特定的方法。 
使用 FieldInfo 来了解如下的类似信息：字段的名称、访问修饰符（如 public 或 private）和实现详细信息（如 static）等；并获取或设置字段值。 
使用 EventInfo 来了解如下的类似信息：事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等；并添加或移除事件处理程序。 
使用PropertyInfo 来了解如下的类似信息：属性的名称、数据类型、声明类型、反射类型和只读或可写状态等；并获取或设置属性值。 
使用ParameterInfo 来了解如下的类似信息：参数的名称、数据类型、参数是输入参数还是输出参数，以及参数在方法签名中的位置等。

反射接口 
如果你想要获得一个类型继承的所有接口集合，可以调用Type的FindInterfacesGetInterface或者GetInterfaces。所有这些方法只能返回该类型直接继承的接口，他们不会返回从一个接口继承下来的接口。要想返回接口的基础接口必须再次调用上述方法。

**通过反射创建类型的实例**
通过反射可以获取程序集的类型，我们就可以根据获得的程序集类型来创建该类型新的实例，这也是前面提到的在运行时创建对象实现晚绑定的功能
我们可以通过下面的几个方法实现： 
1．System.Activator 的CreateInstance方法。该方法返回新对象的引用。具体使用方法参见msnd 
2．System.Activator 的createInstanceFrom与上一个方法类似，不过需要指定类型及其程序集 
3．System.Appdomain 的方法：createInstance,CreateInstanceAndUnwrap,CreateInstranceFrom和CreateInstraceFromAndUnwrap 
4． System.type的InvokeMember实例方法：这个方法返回一个与传入参数相符的构造函数，并构造该类型。 
5．System.reflection.constructinfo 的Invoke实例方法 

举例说明：

```
using System;
 using System.Reflection;

 namespace ReflectionExample
{
class Class1
{
[STAThread]
static void Main(string[] args)

{

Console.WriteLine("列出程序集中所有类型");

Assembly a = Assembly.LoadFrom("ReflectionExample.exe");

Type[] mytypes = a.GetTypes();

foreach(Type t in mytypes)

{

Console.WriteLine(t.Name);

}

Console.WriteLine("列出HelloWorld中的所有方法");

Type ht = typeof(HelloWorld);

MethodInfo[] mif = ht.GetMethods();

foreach(MethodInfo mf in mif)

{

Console.WriteLine(mf.Name);

}

Console.WriteLine("实例化HelloWorld，并调用HelloWorld方法");
Object obj = Activator.CreateInstance(ht);
string[] s =  {"wssmax"};

Object objName = Activator.CreateInstance(ht,s);
MethodInfo msayhello = ht.GetMethod("SayHello");
msayhello.Invoke(obj,null);

msayhello.Invoke(objName,null);
Console.ReadLine();
}

}

}
```
` `
```
using System;
 
 namespace ReflectionExample
{

public class HelloWorld

{

string myName;

public HelloWorld(string name)
{

myName = name;

}

public HelloWorld():this(null)
{}

public string Name

{
get {return myName;}
}
public void SayHello()
{
if(myName == null)
Console.WriteLine("Hello World");
else
Console.WriteLine("Hello "+myName);

}

}
}
```

```

```

得到double类的信息：

```
using System;
 using System.Text;
 using System.Windows.Forms;
 using System.Reflection;
 
namespace Wrox.ProCSharp.TypeView
{
class MainClass
{
static void Main()
{
// modify this line to retrieve details of any
// other data type
Type t = typeof(double);
AnalyzeType(t);
MessageBox.Show(OutputText.ToString(), "Analysis of type " + t.Name);
Console.ReadLine();
}
static void AnalyzeType(Type t)
{
AddToOutput("Type Name: " + t.Name);
AddToOutput("Full Name: " + t.FullName);
AddToOutput("Namespace: " + t.Namespace);
Type tBase = t.BaseType;
if (tBase != null)
AddToOutput("Base Type:" + tBase.Name);
Type tUnderlyingSystem = t.UnderlyingSystemType;
if (tUnderlyingSystem != null)
AddToOutput("UnderlyingSystem Type:" + tUnderlyingSystem.Name);

AddToOutput("\nPUBLIC MEMBERS:");
MemberInfo [] Members = t.GetMembers();
foreach (MemberInfo NextMember in Members)

{
AddToOutput(NextMember.DeclaringType + " " + NextMember.MemberType +
" " + NextMember.Name);
}
}

static void AddToOutput(string Text)
{
OutputText.Append("\n" + Text);
}

static StringBuilder OutputText = new StringBuilder(500);
}
}
```

三、示例代码

反射出程序集的属性, 方法及事件

**程序代码：**

```
using System.Windows.Forms;
using System.Reflection;
namespace WindowsFormsApplication1
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}
private void toolStripTextBox1_KeyPress(object sender, KeyPressEventArgs e)
{
if (e.KeyChar == (char)Keys.Enter)
{
//已知程序集的文件名或路径，加载程序集。
Assembly assembly = Assembly.LoadFrom(toolStripTextBox1.Text);
TreeNode tn = new TreeNode();
treeView1.Nodes.Clear();
//遍历程序集所有的类
foreach (System.Type t in assembly.GetTypes())
{
tn = new TreeNode(t.Name, 1, 1);
TreeNode property = new TreeNode("属性", 0, 0);
tn.Nodes.Add(property);
//遍历每个类的属性
foreach (PropertyInfo p in t.GetProperties())
{
TreeNode pn = new TreeNode(p.Name, 0, 0);
property.Nodes.Add(pn);
}
TreeNode method = new TreeNode("方法", 2, 2);
tn.Nodes.Add(method);
//遍历每个类的方法
foreach (MethodInfo m in t.GetMethods())
{
string s = "";
//遍历某个方法的参数
foreach (ParameterInfo par in m.GetParameters())
{
s += string.Format("{0} {1},", par.ParameterType.Name, par.Name);
}
if (s.Length > 0)
s = s.Substring(0, s.Length - 1);
s = m.ReturnType.Name + " " + m.Name + "(" + s +")";
TreeNode mn = new TreeNode(s, 2, 2);
method.Nodes.Add(mn);
}
TreeNode even = new TreeNode("事件", 3, 3);
tn.Nodes.Add(even);
//遍历每个类的事件
foreach (EventInfo ei in t.GetEvents())
{
string s = ("event " + ei.EventHandlerType.Name + " " +ei.Name);
TreeNode en = new TreeNode(s, 3, 3);
even.Nodes.Add(en);
}
treeView1.Nodes.Add(tn);
}
}

}
}
}
```


