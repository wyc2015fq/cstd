# 程序集和应用程序域 - 深之JohnChen的专栏 - CSDN博客

2010年02月02日 13:14:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：1331



    这两个概念MSDN对它们有相关的说明，但是不好理解。个人对它们的理解：程序集是发布的软件的基本单元（exe或dll）；应用程序域是应用程序的运行空间，调用一个或多个程序集。

**程序集(assembly)**
**“****程序集是包含编译好的、面向.NET Framework****的代码的逻辑单元”**这句话可以理解如下：
首先：程序集是代码的逻辑单元，是逻辑上的概念。它不完全等价于编译好的DLL物理文件，但一般我们认为静态专用程序集与编译出的DLL文件或EXE文件是一致的。
其次：它是被编译好的。它不是项目名称或命名空间，更不是源代码。
最后：它是是面向.NET Framework的。意味着它虽然被编译了，但仍需要依托于.NET Framework来运行。

一个程序集可以是一个包括元数据的DLL或EXE，也可以由多个文件组成，例如资源文件、元数据、DLL和EXE。

**注意：Win32****的DLL****（动态链接库）和DotNet****中的DLL****（程序集文件）的扩展名虽然都是DLL****，但是二者内部的数据组织是不一样的，所以千万不要把二者混为一谈。**

**程序集的分类：****静态程序集和动态程序集：**
**静态程序集：**静态程序集包括中间语言元数据（MSIL，类似于Java字节码的东西），以及该程序集的资源（位图、JPEG 文件、资源文件等）。静态程序集存储硬盘文件中。
**动态程序集：**动态程序集直接从内存运行并且在执行前不存储到磁盘上，如ASP.NET 2.0中的网站程序运行的时候产生的是动态程序集。

**专用程序集和共享程序集：****专用程序集**一般附带在某些软件上，且只为该软件提供专用的类库，这些库包含的代码只能用于该应用程序。一般专用程序集是与应用程序放在同一目录下的，在部署的时候与应用程序一起复制到目标机器上即可。
**共享程序集**是其他应用程序可以使用的公共库，一般是安装到系统GAC中。因为其他软件可以访问共享程序集，所以所有共享程序集必须带有强名称（由发行者签名）。

本地应用程序目录可用于存储专用程序集，所以专用程序集一般不会有版本冲突问题。其他应用程序都不会重写私有的程序集。当然，仍可以使用私有程序集的版本号，这样有助于代码的修改与管理，但它不是.NET所必须的。这种专用程序集是大多数程序员所喜欢的，它可以很好地避免DLL Hell的问题。但这种专用程序集只能部署在应用程序所在的目录之中，而无法像以往的Win32 DLL那样放置在System32目录中供多个应用程序共享，但有的时候设计人员仍有共享程序集的需求（把程序集部署到GAC目录中），这样一来又带来了我们似乎又看到DELL HELL又在慢慢地逼近我们，其实DLL共享程序集中根本不可能出现DELL HELL。因为共享程序集并不是简单地把私有程序集复制到GAC所在目录中，开发人员只能使用相关工具把强命名程序集（Strong-name Assembly）放在GAC所在目录中。**在GAC****中可以允许同名称但是不同版本号的程序集存在，当不同版本的强命名程序集安装在GAC****中后，不同的应用程序会根据版本号信息去调用不同的程序集**，这样就不会产生DLL程序集冲突的问题了。

**应用程序域（AppDomain****）**

在操作系统中，程序和程序之间应实现某种形式的隔离，防止程序和程序之间产生不可预知的影响，这种隔离是必须的。在DotNet技术之前，通常采用进程来形成隔离边界。每一个应用程序被加载到单独的进程中，每个进程都有其私有的内存，运行在一个进程中的应用程序不能写入另一个应用程序的内存，您也不能在两个进程间进行直接调用。

在.NET结构中，应用程序有一个新的边界：应用程序域。应用程序域是一个用于隔离应用程序的“轻量级分界线”。所谓的“轻量级”是因为多个应用程序域可以存在于单个操作系统进程中。

应用程序域可以确保在一个域中运行的代码不会影响进程中的其他应用程序;能够在不停止整个进程的情况下停止单个应用程序。

![](http://hiphotos.baidu.com/grayworm/pic/item/b67628d9286d072210df9b11.jpg)

进程2321有两个应用程序域。在应用程序域A中，实例化了对象1和2，对象1在程序集1中，对象2在程序集2中。在进程2322中，第二个应用程序域有实例1。实例和静态成员不能在应用程序域之间共享，也不能直接访问另一个应用程序域中的对象。

AppDomain类用于创建和中断应用程序域，加载和卸载程序集。

常用属性和方法：

FriendlyName取得应用程序域的友好名称

CreateDomain()创建新的应用程序域。

ExecuteAssembly() 执行应用程序域中的程序集。它可用来执行另一个应用程序域中的代码。

Unload() 执行域的正常卸载。只有应用程序域中正在运行的所有线程都已停止或域中不再有运行的线程之后，才卸载该应用程序域。

创建应用程序域：

class AppDomain1

{

public static void Main()

{

Console.WriteLine("Creating new AppDomain.");

//创建应用程序域

AppDomain domain = AppDomain.CreateDomain("MyDomain");

//显示当前应用程序域的友好名称

Console.WriteLine("Host domain: " + AppDomain.CurrentDomain.FriendlyName);

//显示新建应用程序域的友好名称

Console.WriteLine("child domain: " + domain.FriendlyName);

}

}

**将程序集加载到应用程序域中**

**1、****程序集代码(生成dll)**

usingSystem;

usingSystem.Collections.Generic;

usingSystem.Linq;

usingSystem.Text;

namespaceClassLibrary

{

classNewClass

{

publicstringMyName;

publicstringMyInfo;

publicstringmyName

{

get { returnMyName; }

set { MyName = value; }

}

publicstringmyInfo

{

get { returnMyInfo; }

set { MyInfo = value; }

}

publicNewClass()

{

MyName = "";

MyInfo = "";

}

publicvoidshow()

{

Console.WriteLine(MyName + MyInfo);

}

}

}

2、**程序集加载到应用程序域****代码**

usingSystem;

usingSystem.Collections.Generic;

usingSystem.Linq;

usingSystem.Text;

usingSystem.Reflection;

namespaceAppDomain3

{

classProgram

{

staticvoidMain(string[] args)

{

AppDomainad = AppDomain.CurrentDomain;

Assemblya = ad.Load("ClassLibrary");

//取得应用程序集中的NewClass类型

Typet = a.GetType("ClassLibrary.NewClass");

//创建NewClass类型的实例

objecto = Activator.CreateInstance(t);

//给对象的属性赋值

PropertyInfop1 = t.GetProperty("myName");

PropertyInfop2 = t.GetProperty("myInfo");

p1.SetValue(o, "中国", null);

p2.SetValue(o, "China", null);

//调用对象的show方法

MethodInfomi = t.GetMethod("show");

mi.Invoke(o, null);

}

}

}

参考：

MSDN反射方法类/接口

http://msdn.microsoft.com/zh-cn/library/system.reflection.methodbase.invoke(VS.80).aspx



