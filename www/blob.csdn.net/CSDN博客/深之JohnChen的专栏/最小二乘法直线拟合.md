# 最小二乘法直线拟合 - 深之JohnChen的专栏 - CSDN博客

2006年02月08日 15:15:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2547标签：[null																[class](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)
个人分类：[图像处理与识别](https://blog.csdn.net/byxdaz/article/category/144582)


class CFoldPoint

{

public:

  double x;double y;

}

typedef CTypedPtrList<CPtrList,CFoldPoint*> CFoldPointList;
typedef CDoubleArray<double,double> CDoubleArray;

//最小二乘法直线拟合
BOOL CalculateLineKB(CFoldPointList *m_FoldList,double &k,double &b)
{
 //最小二乘法直线拟合
 //m_FoldList为关键点(x,y)的链表
 //拟合直线方程(Y=kX+b)

 if(m_FoldList==NULL)return FALSE;
 long lCount=m_FoldList->GetCount();
 if(lCount<2)return FALSE;
 CFoldPoint *pFold;
 double mX,mY,mXX,mXY,n;
 mX=mY=mXX=mXY=0;
 n=lCount;
 POSITION pos=m_FoldList->GetHeadPosition();
 while(pos != NULL)
 {
  pFold=m_FoldList->GetNext(pos);
  mX+=pFold->X;
  mY+=pFold->Y;
  mXX+=pFold->X*pFold->X;
  mXY+=pFold->X*pFold->Y;
 }
 if(mX*mX-mXX*n==0)return FALSE;
 k=(mY*mX-mXY*n)/(mX*mX-mXX*n);
 b=(mY-mX*k)/n;
 return TRUE;
}

