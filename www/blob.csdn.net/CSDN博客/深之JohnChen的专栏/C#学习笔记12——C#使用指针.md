# C#学习笔记12——C#使用指针 - 深之JohnChen的专栏 - CSDN博客

2011年08月31日 23:58:17[byxdaz](https://me.csdn.net/byxdaz)阅读数：1253标签：[c#																[编程																[.net																[工作																[button																[object](https://so.csdn.net/so/search/s.do?q=object&t=blog)](https://so.csdn.net/so/search/s.do?q=button&t=blog)](https://so.csdn.net/so/search/s.do?q=工作&t=blog)](https://so.csdn.net/so/search/s.do?q=.net&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=c#&t=blog)
个人分类：[.Net & C#](https://blog.csdn.net/byxdaz/article/category/628880)


这是C/C++程序迷们经常谈论的一个话题，同时也是一个复杂的、难以理解的话题－指针！每次谈到C#，大多数我遇到的人都持这样的观点－C#中没有指针的概念。而实际上，它已经被废除了，取而代之的是C#中的非安全编程－如何在程序中使用指针。不同于其字面意思的是，C#使用指针编程并没有什么不安全的。它如此受关注的根本原因是，非安全编程不同于习惯的.NET开发规范，而需要编程人员进行明确定本地环境设置(仅适用于本地执行)。本文我将从区别两个最容易被疑惑的概念－非安全代码与非受控代码开始讨论非安全编程这个主题。接下来我们将讨论如何编写非安全代码，亦即如何在C#使用指针。

受控代码是指在CLR管理下执行的代码。CLR负责了许多幕后的工作：
◆管理对象的内存
◆进行类型验证
◆垃圾回收

实际就是要将用户从上述的这些工作中解脱出来了，专心于业务实现。用户不再需要直接手工地进行内存操作，因为这些工作已由CLR完成了。

另一方面，非受控代码就是在CLR上下文外执行的代码了。最好的例子就是我们平时使用的Win32 DLL，比如kernel32.dll，user32.dll以及安装上我们系统上的各种COM组件。如何为它们分配内存、如何释放这些内存、如何实现类型验证？这些工作都需要它们自己来完成。一个典型的C++程序中分配一个字符指针的语句也是非受控代码的另一类例子，因为作为一名编程者，你要负责：
◆调用内存分配函数
◆确保类型转换的结果正确
◆确保指针在使用完毕后其内存被释放

如果你留心上面的解释，所有这些工作都是由CLR来完成以减轻编程者的负担。

非安全代码是介于受控与非受控代码间的一种代码类型

非安全代码仍然象受控代码一样是在CLR的管理下执行的，但在同时它又象非受控代码一样允许你通过指针直接访问内存。因此你获得了两者的优点。如果你正在编写写一个.NET应用程序，但同时又希望可以广泛使用Win32 DLL中的各种函数－需要C#使用指针的，那么此时非安全代码就是你的救星了。

我们已经明确了两者的区别后，就开始编写实际的代码，毫无疑问，这才是最精彩的部分，你还在想什么呢？
深入非安全代码

编写非安全代码需要使用特殊的关键字unsafe与fixed。如果你还记得的话，有三种指针操作符：* & -> 

下面是对指针的一些使用上的理解：
1． 指针类型可以是实体变量（int，double）也可以是enum，同时也支持结构体变量struct。但不能是类。不过空指针可以指向类，只不过空指针不能进行任何操作，也只能把空指针作为传递对象来使用。
2． C#提供一个的关键字stackalloc用于申请堆栈内存。注意，这个申请内存分配的是栈内存，当函数执行完毕后，内存会被自动回收。不过我想用这个栈内存基本可以解决40％的问题，而且使用的时候不必担心内存泄漏问题。
3． .net 好像不直接支持堆内存的申请（这个对.net来说很危险），不过我们可以通过调用win32 api 的方法进行申请。这样就可以解决剩下40%的问题。

4．结构体是一个特殊的对象。他与类的定义就差一个关键字，使用方法也和类一样，可以定义属性，可以定义方法。但是在进行指针操作的时候双方就有很大的差别了。结构体可以通过sizeof()取得大小，大小与结构体里有多少实体变量有关，但是如果struck里定义了类的对象，或者指针，sizeof可能会编译不过（void* 的空指针例外，不过需要在结构体声明处加上unsafe）。
5． fixed关键字：fixed()会告诉垃圾收集器，类实例的某些成员有指向他们的指针，所以这些实例不能移动目前了解的不多，不过有一个很实用的例子可以让指针能够和.net里的数组进行交互操作：

private void button1_Click(objectsender, EventArgs e)
{
MyClass myObject = newMyClass();
//不能创建指向类的指针，这是因为垃圾收集器不包含指针的任何信息，只包含引用的信息
//大多数类都包含值类型的成员，可以为这些值类型成员创建类型成员创建指针，但需要一种特殊的语法
fixed (long* pObject = &(myObject.X))
fixed(float* fObject=&(myObject.F))
{
this.label2.Text = pObject->ToString();
this.label2.Text += fObject->ToString();
}
}

6．指针的取地址操作 和C里面的一样

private void button2_Click(object sender, EventArgs e)
{
int x = 10;
int* pX = &x;
this.label3.Text +="Addressis"+ (uint)pX; 
}

7. 一个使用指针的基于堆栈的高效数组举例：C#很容易使用数组，但是有一个缺点就是这些数组实际上都是对象，是System.Array的实例，因此数组只能存储在堆上，会增加系统的开销，而使用指针就可以做到，但只能用于一位数组。

private void pointer_Load(object sender, EventArgs e)
{
//分配堆栈内存，不会把内存初始化为任何默认值
decimal* pDecimals=stackalloc decimal[10];
pDecimals[0] = 0; //pDecimals[0] is the same as *pDecimals
pDecimals[1] = 1; //pDecimals[1]is the same as *(pDecimals+1)
pDecimals[2] = 2;
pDecimals[3] = 3;
pDecimals[4] = 4;
pDecimals[5] = 5;
pDecimals[6] = 6;
pDecimals[7] = 7;
pDecimals[8] = 8;
pDecimals[9] = 9;
for (int i = 0; i< 10; i++)
{ 
this.label1.Text+=pDecimals[i].ToString();
}
}


