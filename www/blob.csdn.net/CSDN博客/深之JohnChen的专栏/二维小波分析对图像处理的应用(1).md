# 二维小波分析对图像处理的应用(1)  - 深之JohnChen的专栏 - CSDN博客

2005年09月01日 15:47:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：4704



      一：引言 本文从二维小波理论出发，对其在图像处理的应用上进行了一些分析和处理，力图反映出小波分析在图像处理方面有着其独特的特点。本文就以下几点进行阐述：

①小波基本概念

②图像压缩

③图像消噪

④图象增强

⑤图象平滑处理

    二：小波基本概念

小波定义：设 ,其傅立叶变换为 ,当 满足允许条件，即完全重构条件或恒等分辨条件. 时，我们称 为一个基本小波或母小波，将母函数 经伸缩和平移后，得 。 我们称其为一个小波序列。其中a为伸缩因子，b为平移因子。

小波变换是一种信号的时间——尺度分析方法，他具有多分辨率分析的特点，而且在时频两域都具有表征信号局部特征的能力，是一种窗口大小固定不变但其形状可变，时间窗和频率窗都可变的时频局部化分析方法。即再低频部分具有较高的频率分辨率和时间分辨率，在高频部分具有较高的时间分辨率和较低的频率分辨率，很适合探测正常信号中夹带的瞬态反常现象并展示其成分，所以被誉为分析信号的显微镜。

波分析是把信号分解成低频al和高频dl两部分，在分解中，低频al中失去的信息由高频dl捕获。在下一层的分解中，又将al分解成低频a2和高频d2两部分，低频a2中失去的信息由高频d2捕获，如此类推下去，可以进行更深层次的分解。

二维小波函数是通过一维小波函数经过张量积变换得到的，二维小波函数分解是把尺度j的低频部分分解成四部分：尺度j+1的低频部分和三个方向（水平、垂直、斜线）的高频部分。

三：图像压缩

对于图像来说，如果需要进行快速或实时传输以及大量存储，就需要对图像数据进行压缩。在同样的通信容量下，如果图像数据压缩后在传输，就可以传输更多的图像信息。例如，用普通的电话线传输图像信息。图像压缩研究的就是寻找高压缩比的方法且压缩后的图像要有合适的信噪比,在压缩传输后还要恢复原信号，斌且在压缩、传输、恢复的过程中，还要求图像的失真度小。这就是图像压缩的研究问题。

       图像数据往往存在各种信息的冗余、如空间冗余、信息熵冗余 、视觉冗余 和结构冗余等等。所谓压缩就是去掉各种冗余，保留对我们有用的信息。图像压缩的过程常称为编码。相对的，图像的恢复当然就是解码了。

       图像压缩的方法通常可分为有失真编码和无失真编码两大类：

       无失真编码方法如改进的霍夫曼编码。

       有失真编码方法的还原图像较之原始图像存在着一些误差，但视觉效果是可以接受的。常见的方法有预测编码、变换编码、量化编码、信息熵编码、分频带编码和结构编码等等。

       而将小波分析引入图像压缩的范畴也是一个重要的手段，并且有着它自己的特点。它的特点在于压缩比高、压缩速度快，压缩后能保持信号与图像的特征基本不变，且在传递过程中可以抗干扰等等。

       下面我们就举一个粒子来说明怎样用小波分析进行图像压缩。

       例如现在有一个二维图像（文件名为），我们利用二维小波分析来进行图像压缩。

由原理可知，一个图像作小波分解后，可得到一系列不同分辨率的子图像，不同分辨率的子图像对应的频率是不相同的。高分辨率（高频）子图像上大部分点的数值都接近于0，越是高就越是明显。而对于一个图像来说，表现一个图像的最主要的部分是低频部分，所以最简单的压缩方法是利用小波分解去掉图像的高频部分而只保留低频部分。

程序大致如下：

clear

%装入图像

load wbarb;

%显示图像

 syms X;

subplot(221);

image(coast);

colormap(map)

title('原始图像');

axis square

disp('压缩前图像X的大小');

whos('coast')

%对图像用小波进行层小波分解

[c,s]=wavedec2(X,2,'bior3.7');

%提取小波分解结构中的一层的低频系数和高频系数

cal=appcoef2(c,s,'bior3.7',1);

%水平方向

ch1=detcoef2('h',c,s,1);

%垂直方向

cv1=detcoef2('v',c,s,1);

%斜线方向

cd1=detcoef2('d',c,s,1);

%各频率成份重构

a1=wrcoef2('a',c,s,'bior3.7',1);

h1=wrcoef2('h',c,s,'bior3.7',1);

v1=wrcoef2('v',c,s,'bior3.7',1);

d1=wrcoef2('d',c,s,'bior3.7',1);

c1=[a1,h1;v1,d1];

%显示分频信息

subplot(222);

image(c1);

axis square;

title ('分解后低频和高频信息');

%进行图像压缩

%保留小波分解第一层低频信息

%首先对第一层信息进行量化编码

ca1=appcoef(c,s,'bior3.7',1);

ca1=wcodemat(ca1,440,'mat',0);

%改变图像高度并显示

ca1=0.5*ca1;

subplot(223);

image(ca1);

colormap(map);

axis square;

title('第一次压缩图像');

disp('第一次压缩图像的大小为：');

whos('ca1')

%保留小波分解第二层低频信息进行压缩

ca2=appcoef2(c,s,'bior3.7',2);

%首先对第二层信息进行量化编码

ca2=wcodemat(ca2,440,'mat',0);

%改变图像高度并显示

ca2=0.25*ca2;

subplot(224);

image(ca2);

colormap(map);

axis square;

title('第二次压缩图像');

disp('第二次压缩图像的大小为：');

whos('ca2')

输出结果如图：

 Name
 Size
 Bytes
 class

压缩前图像
 X
 256×256
 524288
 Double array

第一次压缩图像
 Ca1
 135×135
 145800
 Double array

第二次压缩图像
 Ca2
 75×75
 45000
 Double array

在这里可以看出，第一次压缩我们是提取原始图像中小波分解第一层的低频信息，此时压缩效果较好，压缩比较小（约为1/3大小）。第二次压缩实提取第一层分解低频部分的低频部分（即第二层的低频部分）,其压缩比较大（约为1/12），压缩效果在视觉上也基本过得去。

       上面的保留原始图像中低频信息的压缩办法只是一种最简单的压缩办法。它不需经过其他处理即可获得较好的压缩效果。当然，对于上面的例子我们还可以只提取小波分解的第三、第四层的低频信息。从理论上说，我们可以获得任意压缩比的压缩图像。只不过在对压缩比和图像质量都有较高要求时，它就不如其他编码方法了。

下面我们在举一个例子，这一次用 中函数来对上图进行压缩。 

Clear;

%装入图形信号

load wbarb;

%显示图像

subplot(221);

image(X);

colormap(map);

title('原始图像');

disp('压缩前图像的大小');

whos('X');

axis square;

%对图像进行压缩

%对图像用db3小波进行二层小波分解

[c,s]=wavedec2(X,5,'db3');

[thr,sorh,keepapp]=ddencmp('cmp','wv',X);

[Xcomp,cxc,lxc,perf0,perfl2]=wdencmp('gbl',c,s,'db3',5,thr,sorh,keepapp);

%将压缩后的图像于原始图像相比较

subplot(222);

image(Xcomp);

colormap(map);

title(' 压缩后的图像');

disp('压缩后图像的大小');

whos('Xcomp')

%显示有关参数

disp('小波分解系数中值为0的系数个数百分比');

disp(perf0);

disp('压缩后剩余能量百分比');

disp(perfl2);

输出结果如下：

小波分解系数中值为0的系数个数百分比：49.8088

压缩后剩余能量百分比：99.9754

       总之，是事无绝对。一种压缩图像的方法不可能尽善尽美。要想很好的进行图像的压缩，就需要综合的利用多种其他技术，特别是数据编码和解码算法。

