# 智能客户端(SmartClient)  - 深之JohnChen的专栏 - CSDN博客

2006年03月29日 14:56:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2441


**智能客户端(SmartClient) **

本文主要讨论基于企业环境的客户端应用程序模型，由于本人曾经从事过传统的客户端/服务器两层结构应用程序和基于.net平台的多层结构应用程序的开发，因此本文将着重描述.net平台上的智能客户端应用程序模型，并根据一般的企业应用系统的需求来一步一步构造出一个较为完整的客户端软件框架。

**简介**
    智能客户端的概念作为Microsoft.net平台的一个特性而被提出，其实它的很多功能在传统的应用程序中早已存在，只是.net平台从系统和语言级别对它提供了支持，使开发智能客户端应用程序更为便捷。本文将从企业应用系统的角度来讨论智能客户端应具有的功能和特性以及如何在.net平台上实现。

**概述**    1、当前的客户端应用程序模型比较
    当前的客户端应用程序模型大致分为两种：C/S（客户端/服务器模型）和B/S（浏览器/服务器模型）。以企业环境为对象的软件开发人员，对于以浏览器为基础的精简型客户端 (Thin Client) 应用程序模型，以及对应的丰富型客户端 (Rich Client) 之间，究竟该如何取舍，面临了困难的世代替换。
    以浏览器为基础的应用程序的优缺点：
- 易于安装：可以用于许多桌上型计算机，并且和客户机算计的操作平台无关。大多数计算机已经默认安装有浏览器软件（有些应用系统需要基于IE浏览器，或者需要安装java虚拟机，在此暂且忽略不及）。 
- 易于部署与维护：只需要在服务器端进行部署和维护工作。 
- 必须在线工作：工作效率和网络是否延迟有关。 
- 不能充分利用客户端计算机的资源：只能通过有限的HTML语言来呈现用户界面，没有利用客户端计算机的计算处理能力。只能利用浏览器的打印功能来打印资料，不适用于企业的报表打印。 
- 网络传输量大：由于客户端不能保存状态数据，因此必须在客户端和服务器之间传输用户界面内容以及所需的数据。
- 安全性较低。对于服务器来说可以通过防火墙软件来过滤数据，因为所有传输内容都是基于HTTP端口。但很难对数据进行加密和签名以保证在传输过程中的完整性。（HTTPS似乎并不能解决问题）
- 适合电子商务或不要求严格控制客户端的应用程序。 　

    丰富型客户端应用程序的优缺点：
- 可以离线工作：前提是本地必须有缓存数据的能力，这涉及到与服务器数据同步的问题。 
- 充分利用客户端计算机的资源：可以为用户提供丰富的界面元素，可以存取本机磁盘与本机应用程序接口 (API)，执行速度较快。 
- 网络传输量较小：只需在客户端和服务器之间传输数据。 
- 安全性较高。可以方便的在客户端和服务器执行加密和解密操作，同时也可以通过Web Service来消除传统的应用程序诸如防火墙和HTTP的障碍。 
- 安装、部署和维护工作较为繁琐：对客户端计算机在操作平台和附加软件上有一定的限制和要求。 
- 适合企业内部应用程序。 　

    目前，还有一种不是基于浏览器的瘦客户端应用程序。通过诸如Microsoft Terminal Server、Citrix System的Independent Computing Architecture和MetaFrame产品这样的技术和工具把它们提供给用户。这些类型的解决方案可以让用户运用胖客户端的经验，并通过集中的软件安装和维护来进行管理，这对公司来说是很划算的。这种模式的问题是，当应用程序没有连接到应用服务器时，用户就不能用了。客户端不进行真正的处理，处理完全依赖应用程序服务器，这种情况会导致服务器性能问题，并消耗桌面计算机的CPU周期。
    总之，相对于丰富型客户端，以浏览器为基础的模型对于信息科技 (IT) 系统管理员而言是非常棒的模型，但对于开发人员与使用者而言却有很多不足的地方。
Microsoft .NET Framework 将满足这三方的需求。它的智能型客户端应用程序模型结合了丰富型客户端模型的强大功能与弹性，还有以浏览器为基础之模型的容易部署与稳定性。
    2、客户端应用程序还应具备的其他功能
    对于企业应用系统来说，客户端应用程序作为整个系统与用户的交互界面，还需要考虑以下功能：
- 安全性：这里的安全性主要是指应用层次的安全性，主要通过用户权限、角色分配来实现。对于客户端应用程序来说，通常需要提供一个登录窗体或登录页面来完成用户身份的认证。对安全性要求较高的应用系统可能还需要通过公共密钥基础设施（PKI）为应用提供可靠的安全服务，客户端则附加了加密签名模块。 
- 可扩展性：客户端应用程序应该具有包含各种不同类型的应用模块的能力，同时又能在使用过程中的不断的增加应用来完善整个系统。因此可以将客户端应用程序设计为一个容器，而各个应用模块作为组件由容器进行动态加载。 
- 可配置性：由于用户权限和用户喜好的不同，客户端加载的应用组件以及呈现的表现形式都因人而异。需要由应用系统将用户权限的范围以及用户的个性化配置信息传递给客户端，由客户端应用程序来解释并呈现相应的用户界面。 　

**定义**    综上所述，我们对智能客户端应用模型下一个概括性的定义：一个可扩展的能集成不同应用的桌面应用程序，并具有以下特征：
- 无接触部署：安装时只要将一个主程序文件下载到本地，直接运行即可，无须改变注册表或共享的系统组件，其他应用组件将在第一次运行时自动下载。
- 自动更新：只需将新版本的程序发布在服务器上，由客户端自动发现最新版本的程序和应用组件，并自动下载和更新。
- 离线运用：允许脱离服务器时，利用本地的客户端程序和应用组件进行工作。
- 动态加载应用组件：应用软件开发商可根据企业应用系统的公共接口进行开发，然后将应用组件发布在企业的服务器上，客户端应用程序将自动发现并加载该应用组件。
- 个性化用户界面：用户可根据喜好自行设置客户端应用程序，配置信息将被保存到服务器上。

    以下我们将以.net平台WinForms应用程序为例，对上述特征进行详细描述。

**.net平台WinForms应用程序举例**    一、系统需求
        1、客户端软件要求

> - 任何支持 .NET Framework 的操作系统 
- 已安装 SP1 的 .NET Framework 
- Internet Explorer 5.0.1 或更高版本 　

        2、服务器软件要求
            自动发布、更新服务器：Microsoft .NET Framework、MDAC2.7、IIS

    二、运行方式
    客户端应用程序有两种运行方式，不同的运行方式将直接影响以后的程序集发布和更新，以下将详细解释：
        1、网络运行
    .NET Framework 安装提供了一个挂接 Internet Explorer 5.01 和更高版本以侦听所请求的 .NET 程序集的机制。在请求期间，可执行程序被下载到磁盘上称为程序集下载缓存的位置（Windows2000下为：C:/Documents and Settings/Administrator /Local Settings/Application Data/assembly下的某个子目录中），同时该程序集本身以及它引用的其他相关程序集也被下载到本地IE缓存中（Windows2000下为：C:/Documents and Settings/Administrator/Local Settings/Temporary Internet Files）。然后，名为 IEExec 的进程在具有有限安全设置的环境中启动该应用程序。例如：您可以在IE的地址栏中输入一个已发布在web服务器上的.net可执行程序（http://SmartClient/MyApplication.Exe），IE并不会像其他文件一样提示您另存为，而是直接执行该程序。

    通过这种方式运行的应用程序拥有非常有限的安全设置（Internet权限集），该权限集中的权限包括：安全性、文件对话框、正在打印、独立存储文件、用户界面。独立存储文件允许您的应用程序保存一些数据（Windows2000下为：C:/Documents and Settings/Administrator.TOMATO/Local Settings/Application Data/IsolatedStorage下的某个子目录中，默认存储空间大小为10MB）,您可以通过System.IO.IsolatedStorage命名空间中的类来保存数据而不会抛出安全异常。

举例：
//按用户、域、程序集获取独立存储区
IsolatedStorageFile isoStore = IsolatedStorageFile.GetStore(IsolatedStorageScope.User | IsolatedStorageScope.Domain | IsolatedStorageScope.Assembly, null, null);
//创建目录
isoStore.CreateDirectory("TestDir");
//创建文件
IsolatedStorageFileStream isoStream1 = new IsolatedStorageFileStream("TestDir//test.txt", FileMode.Create, isoStore);
//写入文件
StreamWriter writer = null;
writer = new StreamWriter(isoStream1);
writer.WriteLine("Hello Isolated Storage");
writer.Close();
isoStream1.Close();

    为了让你的智能应用程序运转，你需要改变一些客户端的安全设置，实质上就是通知客户端运行时间相信你的应用程序。一种方法就是将带有你的程序集的站点添加到IE中可信任站点清单中，然后用安装在你的管理工具目录下的Microsoft .NET Framework Configuration工具来修改.NET Framework安全设置。打开Framework Configuration工具，选择运行库安全策略，然后选择调整安全区域。对于受信任站点中指定的所有站点，将信任级别调整到完全信任。作为选择，你也可以用Framework Configuaration工具来修改安全策略，使它信任你的应用程序的个别程序集。右击运行库安全策略，选择提高程序集的信任级别。

    另一个可选择的方法就是用代码组，用Framework Configuration工具来帮助你提高应用系统的程序集的安全设置。你需要让所有运用你的应用程序的桌面用户做这种改变。为了帮助完成该任务，Framework Configuration工具可以创建一个包含安全策略的Microsoft Installer （MSI）部署包。MSI安装了应用程序加载器来分布你的应用程序需要的安全策略和加载器装配。右击运行库安全策略，选择创建部署包。

    在网络运行中，自动更新是依靠IE的缓存机制来完成的。即当您需要下载并运行一个应用程序时，IE将向Web服务器发送一个HTTP请求，该请求将获取服务器上该程序的最新更新日期，如果该日期大于本地缓存的程序的日期或者本地缓存中不存在该程序，则从服务器上下载，否则直接使用本地缓存的程序。因此对于.net本身所具有的版本机制而言，不能作为版本更新的依据，只有在某个程序集文件引用另外一个程序集时，才会由.net运行时依据自身的版本机制判断版本号。

注意事项：
- 这种运行方式通常需要在运行前先设置用户的安全策略。 
- 加载应用组件时，需要一个完整的url地址。 
- 如果应用程序集中需要调用Web Service，该Web Service所在的服务器地址只能是最初下载程序集的服务器，可以构造一个重定向来解决该问题。 
- 某些文件可能不能通过自动更新机制来完成版本更新，如：.Config应用程序的配置文件。 
- 如果某些应用程序集文件的版本之间存在着某些关联性，则在某些情况下（如：网络突然中断）可能会出现不能正确加载并导致客户端应用程序出错的问题。 
- 如果用户清空IE的缓存，则客户端应用程序将不能离线工作。 　

        2、本地运行
    顾名思义，这种运行方式客户端应用程序和其他应用组件并不在IE缓存和.net下载缓存中运行，需要用户首先下载客户端程序集并保存到一个本地目录下，然后运行。这样客户端应用程序以及其他应用组件就拥有了所有的本地安全权限。

    虽然不涉及安全性问题，但应用组件以及程序的自动更新如何实现？这就需要一个单独的组件来完成这些任务。通过该链接地址可以下载一个非常完善且支持扩展的自动更新组件（[http://www.gotdotnet.com/team/windowsforms/DotNetUpdater.zip](http://www.gotdotnet.com/team/windowsforms/DotNetUpdater.zip)），该打包文件中提供了源码、一些例子以及文档。该更新组件使用HTTP-DAV技术来完成文件在服务器和客户端之间的传输，因此对Web服务器有一定的限制，IIS5.0和新版本的Apache支持该功能。具体使用方式请参见内含文档。

注意事项：
- 由于需要自己来实现更新和下载功能，所以会增加一定的工作量。（就是使用第三方的更新组件，也需要对其进行完善以满足自己的要求） 
- 基本解决了网络运行的缺点，但需要每次更新时重新下载所有的文件（如果采用增量更新的话，某些情况下会出现某个版本的文件被遗漏的问题），会增加网络流量。 
- 应该在后台线程中执行更新和下载，不影响用户的正常操作。 　

    三、创建程序
    客户端应用程序的执行步骤：
- 登录系统。通过输入用户名和密码或其他任何方式进行系统登录，通常需要一个登录窗体。（该步操作需要客户端应用程序在线执行，因此可以考虑在窗体上提供一个离线工作的按钮，然后直接使用上次在线登录时服务器传递的配置文件副本。这样做会引发一些安全性问题和客户端数据和服务器数据同步的问题。） 
- 由应用服务器验证通过以后，根据系统设定的用户权限获取用户可以加载的应用组件及其相应的配置信息，同时从数据库中获取用户的个性化配置信息，将这些配置信息组合成一个XML配置文件流传递给客户端应用程序。该步操作通常由一个Web服务调用来执行。 
- 客户端程序解析该配置文件流，根据个性化配置信息设置主窗体样式，根据应用组件配置信息加载相应的程序集文件。保存该配置文件以备离线工作时使用。 
- （本地运行方式）启动后台更新线程，该线程定时搜索更新服务器上是否有最新版本的程序，如果有则自动下载，并提示用户更新程序。 
- 用户通过点击相应的应用组件的按钮或菜单，在客户端主窗体中将显示应用组件自身携带的用户界面。 　

    客户端应用程序基本包含了登录窗体、主窗体和应用组件加载器。加载器内有一个应用组件集合类，同时还提供一些方法用于主程序和应用组件之间以及不同应用组件之间的通讯，某些应用组件是作为公共组件为其他应用提供数据，因此应该通过统一的方法来获取数据。

注意事项和建议：
    1、对于网络运行方式，程序集在动态加载的过程从服务器被下载到本地缓存中，而本地运行方式的下载过程由更新组件执行，加载过程则客户端主窗体执行。
在.net中动态加载程序集的方法：
using System.Reflection;
//网络运行方式，加载的程序集路径为服务器上的url地址
assemblyFileName = "http://SmartClient/AppComponent1.dll";
//本地运行方式，加载的程序集路径为本地的目录路径
assemblyFileName = @"c:/SmartClient/AppComponent1.dll";
Assembly asm = Assembly.LoadFrom(assemblyFileName);

    2、客户端应用程序的主窗体作为应用组件的容器，可以通过两种方法来显示应用组件的用户界面：
    第一种方式是将客户端应用程序设计为多文档界面（MDI）应用程序，每个应用组件都包含有各自的启动主窗体，客户端应用程序执行每个应用组件时，将构造并显示该组件的启动窗体类型。MDI 应用程序中常有包含子菜单的“窗口”菜单项，用于在主窗口或应用之间进行切换。

    另一种方式是在客户端应用程序的主窗体界面中预留一块应用界面区域，而每个应用组件作为一个用户控件在执行时被添加到应用界面区域的控件数组中。应用界面区域通常是一个面板（Pane）控件，通过更改用户控件的Z顺序在各个应用之间进行切换（Control. BringToFront()）。

    3、在客户端应用程序根据配置信息加载相应的应用组件时，同时需要在客户端主窗体的工具栏或菜单上创建对应的按钮和菜单项，并添加事件以便于用户操作。客户端应用程序和应用组件之间应尽量保持独立性，减少关联，以体现客户端应用程序结构清晰和简单。可以通过.net中的回调（事件委托）等方法实现这一点。

    4、.net由于缓存的原因，在加载程序集时会出现以下问题：
//第一次加载
Assembly asm = Assembly.LoadFrom (@"c:/SmartClient/AppComponent1.dll");
Activator.CreateInstanceFrom(asm.GetType("AppComponent1.MainForm"));

//第二次加载一个不同目录下的文件名称相同但内容不同的程序集
Assembly asm = Assembly.LoadFrom (@"c:/test/AppComponent1.dll");
Activator.CreateInstanceFrom(asm.GetType("AppComponent1.MainForm"));

第二次加载后，没有正确的构造出不同目录下的程序集中的窗体类型，而是使用了缓存中的第一次加载时的构造类型。
为了解决上述问题，必须在不同的应用程序域（Domain）中构造这两个类型实例。
//第二次加载一个不同目录下的文件名称相同但内容不同的程序集
AppDomain newDomain = AppDomain.CreateDomain("newDomain");
newDomain.CreateInstanceFromAndUnwrap(@"c:/test/AppComponent1.dll", "AppComponent1.MainForm");

使用此方法时需要注意，如果您构造的类型实例包含一个带参数的构造函数，则这些参数对象必须是可跨应用程序域访问的对象，即是可序列化的对象。可以通过继承MarshalByRefObject对象或使用[Serializable]特性标记类，同时设置远程对象的生存期策略。
示例：
public class ParameterClass : MarshalByRefObject
{
    public override Object InitializeLifetimeService()
    {
        //定义远程处理生存期服务所使用的生存期租约对象
        ILease lease = (ILease)base.InitializeLifetimeService();
        if (lease.CurrentState == LeaseState.Initial)
        {
            //设置租约的初始时间。该租约将永远不会到期，并且与之关联的对象将具有无限长的生存期。
            lease.InitialLeaseTime =TimeSpan.Zero;
        }
    }
}

    四、发布程序

    1、在发布和更新服务器上设置一个虚拟目录（如：SmartClient）将应用组件的所有文件放置在相应的目录下。
    虚拟目录的设置属性中必须包括：读取和目录浏览权限，执行许可为纯脚本。
    对于本地运行方式，需要根据客户端应用程序的版本号设置多个目录，每个目录存放不同版本的所有文件。（也可以在新版本目录下只存放更新了的文件，但需要修改更新组件。当用户更新版本时，必须下载大于当前版本的所有新版本目录下的文件，以防止某些情况下会出现某个版本的文件被遗漏的问题）。
    在本地运行方式中，还需要在根目录下维护一个更新版本清单文件，因为它允许用户以老版本客户端应用程序登录。

    2、发布一个Web Service。该Web服务主要完成以下任务：
- 执行客户端用户的身份验证 
- 从整个应用系统的安全模块中获取该用户允许执行的应用组件的清单，包含应用组件的位置、文件名称和应用组件本身所需的配置信息。（在本地运行方式下，该清单还和版本有关） 
- 从数据库中获取该用户的个性化配置信息，和上一步获取的信息合并为一个XML文件流。 
- 将该配置文件流作为返回参数返回给客户端应用程序。 　

    3、将客户端应用程序放置在虚拟根目录下作为应用组件程序集的加载器，同时在企业内部网站上增加一个指向客户端应用程序的链接。对于网络运行方式，还将提供一个安全策略部署包（MSI）文件的链接。
    用户第一次运行时的执行步骤
    网络运行方式：
- 下载并安装安全策略部署包 
- 通过点击客户端应用程序的链接，下载并执行客户端应用程序 
- 将该链接添加到收藏夹中或建立桌面快捷方式，以便于运行 　

    本地运行方式：
- 不直接点击客户端应用程序的链接，将此链接另存到用户选择的目录下 
- 在资源管理器中执行客户端应用程序 
- 在桌面上建立可执行文件的快捷方式，以便于运行 　

    五、更新程序
    网络运行方式的更新步骤较为简单，只须将更新了的文件直接覆盖老文件即可。其缺点是某些程序集附带的引用文件不能自动下载新版本，只有清空客户端的IE缓存后才能实现更新。

    本地运行方式的更新步骤如下：
- 在服务器虚拟根目录下新建一个以新版本号命名的目录，增量更新只需将更新了的文件复制到该目录下，否则需要将所有文件都复制到目录。 
- 修改保存所有版本清单的文件，并指明当前活动的最新版本号，用于和客户端进行版本比较。 　

    六、扩展应用组件
    为了实现企业应用系统的可扩展性，通过接口定义，可以使应用开发商通过实现这些接口将自己的应用组件方便的添加到客户端应用程序中。以下介绍一些接口中主要包含的方法和属性。
- 应用组件名称属性：用于标明该应用组件功能的注释性文本。 
- 应用组件在客户端应用程序上的各个界面元素属性：指客户端应用程序上的工具栏、菜单栏、下拉菜单项和列表框等用于标志该应用组件的控件上，需要应用组件提供的文本、图片、图标、菜单、事件处理方法等。 
- 初始化方法：在客户端应用程序加载应用组件时，首先执行的方法。在加载应用组件时，对于由服务器传来的配置文件中包含的各个应用组件自身的配置信息，客户端应用程序并不解析，而是将该配置信息在初始化应用组件时作为参数传递给应用组件，增加了灵活性。 
- 获取应用组件加载器方法：获取应用组件加载器后，可以通过其中包含的公共方法获取一些应用所需的共享数据。 
- 获取应用组件启动控件的方法：启动控件可以是窗体或用户控件。 
- 关闭应用组件的方法（可选）：当客户端应用程序被关闭时，执行该方法。应用组件本身根据自身情况决定是否可以立即关闭，同时立即释放组件所占用的系统资源。

    对于MDI应用程序，可以在启动窗体的关闭事件中处理而不需要该方法。

    客户端应用程序内的应用组件加载器可以通过枚举组件程序集内的类型来判断该组件是否符合借口定义。同时可以将多个应用组件打包在一个应用程序集中。此过程非常耗时。
示例：
//根据程序集文件名称,加载程序集
Assembly asm = Assembly.LoadFrom(assemblyFile);
Type[] types = asm.GetTypes();

//搜索程序集中的所有类型
foreach (Type t in types)
{
    //指示类型是否由引用封送,支持远程处理
if (!t.IsMarshalByRef)
    continue;
    //判断该程序集的类型是否有符合应用组件接口的类型
if (Array.IndexOf(t.GetInterfaces(), pluginType) > 0)
    {
        ...
    }
}

**小结**    上述仅仅是对创建智能客户端应用程序作了简单的描述和示范，并对其中可能遇到的问题给与了必要的解释，希望能对您创建更为强大、灵活、便捷的应用程序提供帮助。

**参考资源链接**1、Security and Versioning Models in the Windows Forms Engine Help You Create and Deploy Smart Clients
[http://msdn.microsoft.com/msdnmag/issues/02/07/NetSmartClients/default.aspx](http://msdn.microsoft.com/msdnmag/issues/02/07/NetSmartClients/default.aspx)

2、Smart Client Application Model and the .NET Framework
[http://msdn.microsoft.com/netframework/techinfo/articles/smartclient/default.asp](http://msdn.microsoft.com/netframework/techinfo/articles/smartclient/default.asp)

3、State Sanity Using Smart Clients
[http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnforms/html/Winforms05202002.asp](http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnforms/html/Winforms05202002.asp)

4、Increasing Permissions for Web-Deployed Windows Forms Applications
[http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnforms/html/winforms11122002.asp](http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnforms/html/winforms11122002.asp)

5、.NET Application Updater Component
[http://www.gotdotnet.com/team/windowsforms](http://www.gotdotnet.com/team/windowsforms)

