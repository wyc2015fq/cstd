# 面试资料一 - 深之JohnChen的专栏 - CSDN博客

2007年07月16日 16:05:00[byxdaz](https://me.csdn.net/byxdaz)阅读数：2466标签：[面试																[vector																[iterator																[iostream																[数据结构																[编译器](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=数据结构&t=blog)](https://so.csdn.net/so/search/s.do?q=iostream&t=blog)](https://so.csdn.net/so/search/s.do?q=iterator&t=blog)](https://so.csdn.net/so/search/s.do?q=vector&t=blog)](https://so.csdn.net/so/search/s.do?q=面试&t=blog)
个人分类：[C/C++																[日记博文](https://blog.csdn.net/byxdaz/article/category/144576)](https://blog.csdn.net/byxdaz/article/category/284144)


1、return语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。例如

char * Func(void)

{

char str[] = “hello world”;// str的内存位于栈上

…

return str;// 将导致错误

}

2、引用与指针的比较

引用是C++中的概念，初学者容易把引用和指针混淆一起。一下程序中，n是m的一个引用（reference），m是被引用物（referent）。

int m;

int &n = m;

n相当于m的别名（绰号），对n的任何操作就是对m的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。所以n既不是m的拷贝，也不是指向m的指针，其实n就是m它自己。

引用的一些规则如下：

（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。

（2）不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。

（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

以下示例程序中，k被初始化为i的引用。语句k = j并不能将k修改成为j的引用，只是把k的值改变成为6。由于k是i的引用，所以i的值也变成了6。

int i = 5;

int j = 6;

int &k = i;

k = j;// k和i的值都变成了6;

上面的程序看起来象在玩文字游戏，没有体现出引用的价值。引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。

以下是“值传递”的示例程序。由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。

void Func1(int x)

{

x = x + 10;

}

…

int n = 0;

Func1(n);

cout << “n = ” << n << endl;// n = 0

以下是“指针传递”的示例程序。由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。

void Func2(int *x)

{

(* x) = (* x) + 10;

}

…

int n = 0;

Func2(&n);

cout << “n = ” << n << endl;// n = 10

以下是“引用传递”的示例程序。由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。

void Func3(int &x)

{

x = x + 10;

}

…

int n = 0;

Func3(n);

cout << “n = ” << n << endl;// n = 10

对比上述三个示例程序，会发现“引用传递”的性质象“指针传递”，而书写方式象“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用”这东西？

答案是“用适当的工具做恰如其分的工作”。

指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？

如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。

3、**计算内存容量**

用运算符sizeof可以计算出数组的容量（字节数）。示例7-3-3（a）中，sizeof(a)的值是12（注意别忘了’/0’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。

**注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。**示例7-3-3（b）中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。

char a[] = "hello world";

char *p= a;

cout<< sizeof(a) << endl;// 12字节

cout<< sizeof(p) << endl;// 4字节

示例7-3-3（a）计算数组和指针的内存容量

void Func(char a[100])

{

cout<< sizeof(a) << endl;// 4字节而不是100字节

}

示例7-3-3（b）数组退化为指针

## 4、指针参数是如何传递内存的？

如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例7-4-1中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？

void Test(void)

{

char *str = NULL;

GetMemory(str, 100);// str 仍然为 NULL

strcpy(str, "hello");// 运行错误

}

示例7-4-1 试图用指针参数申请动态内存

毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。

如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例7-4-2。

void Test2(void)

{

char *str = NULL;

GetMemory2(&str, 100);// 注意参数是 &str，而不是str

strcpy(str, "hello");

cout<< str << endl;

free(str);

}

示例7-4-2用指向指针的指针申请动态内存

由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例7-4-3。

void Test3(void)

{

char *str = NULL;

str = GetMemory3(100);

strcpy(str, "hello");

cout<< str << endl;

free(str);

}

示例7-4-3 用函数返回值来传递动态内存

用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例7-4-4。

void Test4(void)

{

char *str = NULL;

str = GetString();// str 的内容是垃圾

cout<< str << endl;

}

示例7-4-4 return语句返回指向“栈内存”的指针

用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。

如果把示例7-4-4改写成示例7-4-5，会怎么样？

void Test5(void)

{

char *str = NULL;

str = GetString2();

cout<< str << endl;

}

示例7-4-5 return语句返回常量字符串

函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。

## 5、free和delete把指针怎么啦？

别看free和delete的名字恶狠狠的（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。

用调试器跟踪示例7-5，发现指针p被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，p成了“野指针”。如果此时不把p设置为NULL，会让人误以为p是个合法的指针。

如果程序比较长，我们有时记不住p所指的内存是否已经被释放，在继续使用p之前，通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。

char *p = (char *) malloc(100);

strcpy(p, “hello”);

free(p);// p所指的内存被释放，但是p所指的地址仍然不变

…

if(p != NULL)// 没有起到防错作用

{

strcpy(p, “world”);// 出错

}

示例7-5p成为野指针

6、**内联函数的编程风格**

关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。如下风格的函数Foo不能成为内联函数：

inline void Foo(int x, int y); // inline仅与函数声明放在一起

void Foo(int x, int y)

{

…

}

而如下风格的函数Foo则成为内联函数：

void Foo(int x, int y); 

inline void Foo(int x, int y)// inline与函数定义体放在一起

{

…

}

所以说，inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。

定义在类声明之中的成员函数将自动地成为内联函数，例如

class A

{

public:

void Foo(int x, int y) { … } // 自动地成为内联函数

}

将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

// 头文件

class A

{

public:

void Foo(int x, int y)； 

}

// 定义文件

inline void A::Foo(int x, int y)

{

…

}

7、template

函数模板template <Class T> Max (T a,T b) 或者template <Typename T> Max (T a,T b) 

类模板template <Class T>class Person {

int a,b,c;

T var;

};

8、

原作者姓名 Jeff Bogan 

介绍
这是一篇指导您如何在Microsoft Visual Studio下学习STL并进行实践的文章。这篇文章从STL的基础知识讲起，循序渐进，逐步深入，涉及到了STL编写代码的方法、STL代码的编译和调试、命名空间（namespace）、STL中的ANSI / ISO字符串、各种不同类型的容器（container）、模板（template）、游标（Iterator）、算法（Algorithms）、分配器（Allocator）、容器的嵌套等方面的问题，作者在这篇文章中对读者提出了一些建议，并指出了使用STL时应该注意的问题。这篇文章覆盖面广，视角全面。不仅仅适合初学者学习STL，更是广大读者使用STL编程的实践指南。 

正文
这是一篇指导您如何在Microsoft Visual Studio下学习STL并进行实践的文章。这篇文章从STL的基础知识讲起，循序渐进，逐步深入，涉及到了STL编写代码的方法、STL代码的编译和调试、命名空间（namespace）、STL中的ANSI / ISO字符串、各种不同类型的容器（container）、模板（template）、游标（Iterator）、算法（Algorithms）、分配器（Allocator）、容器的嵌套等方面的问题，作者在这篇文章中对读者提出了一些建议，并指出了使用STL时应该注意的问题。这篇文章覆盖面广，视角全面。不仅仅适合初学者学习STL，更是广大读者使用STL编程的实践指南。

STL简介

STL (标准模版库，Standard Template Library)是当今每个从事C++编程的人需要掌握的一项不错的技术。我觉得每一个初学STL的人应该花费一段时间来熟悉它，比如，学习STL时会有急剧升降的学习曲线，并且有一些命名是不太容易凭直觉就能够记住的（也许是好记的名字已经被用光了），然而如果一旦你掌握了STL，你就不会觉得头痛了。和MFC相比，STL更加复杂和强大。
STL有以下的一些优点：

可以方便容易地实现搜索数据或对数据排序等一系列的算法；

调试程序时更加安全和方便；

即使是人们用STL在UNIX平台下写的代码你也可以很容易地理解（因为STL是跨平台的）。

背景知识

写这一部分是让一些初学计算机的读者在富有挑战性的计算机科学领域有一个良好的开端，而不必费力地了解那无穷无尽的行话术语和沉闷的规则，在这里仅仅把那些行话和规则当作STLer们用于自娱的创造品吧。

使用代码
本文使用的代码在STL实践中主要具有指导意义。

一些基础概念的定义

模板（Template）——类（以及结构等各种数据类型和函数）的宏（macro）。有时叫做甜饼切割机（cookie cutter），正规的名称应叫做范型（generic）——一个类的模板叫做范型类（generic class），而一个函数的模板也自然而然地被叫做范型函数（generic function）。
STL——标准模板库，一些聪明人写的一些模板，现在已成为每个人所使用的标准C++语言中的一部分。
容器（Container）——可容纳一些数据的模板类。STL中有vector，set，map，multimap和deque等容器。
向量（Vector）——基本数组模板，这是一个容器。
游标（Iterator）——这是一个奇特的东西，它是一个指针，用来指向STL容器中的元素，也可以指向其它的元素。

Hello World程序

我愿意在我的黄金时间在这里写下我的程序：一个hello world程序。这个程序将一个字符串传送到一个字符向量中，然后每次显示向量中的一个字符。向量就像是盛放变长数组的花园，大约所有STL容器中有一半是基于向量的，如果你掌握了这个程序，你便差不多掌握了整个STL的一半了。

//程序：vector演示一
//目的：理解STL中的向量

// #include "stdafx.h" -如果你使用预编译的头文件就包含这个头文件
#include <vector>  // STL向量的头文件。这里没有".h"。
#include <iostream>  // 包含cout对象的头文件。
using namespace std;  //保证在程序中可以使用std命名空间中的成员。

char* szHW = "Hello World";  
//这是一个字符数组，以”/0”结束。

int main(int argc, char* argv[])
{
  vector <char> vec;  //声明一个字符向量vector (STL中的数组) 

  //为字符数组定义一个游标iterator。
  vector <char>::iterator vi;

  //初始化字符向量，对整个字符串进行循环，
  //用来把数据填放到字符向量中，直到遇到”/0”时结束。
  char* cptr = szHW;  // 将一个指针指向“Hello World”字符串
  while (*cptr != '/0')
  {  vec.push_back(*cptr);  cptr++;  }
  // push_back函数将数据放在向量的尾部。

  // 将向量中的字符一个个地显示在控制台
  for (vi=vec.begin(); vi!=vec.end(); vi++)  
  // 这是STL循环的规范化的开始——通常是 "!=" ， 而不是 "<"
  // 因为"<" 在一些容器中没有定义。 
  // begin()返回向量起始元素的游标（iterator），end()返回向量末尾元素的游标（iterator）。
  {  cout << *vi;  }  // 使用运算符 “*” 将数据从游标指针中提取出来。
  cout << endl;  // 换行

  return 0;
}

push_back是将数据放入vector（向量）或deque（双端队列）的标准函数。Insert是一个与之类似的函数，然而它在所有容器中都可以使用，但是用法更加复杂。end()实际上是取末尾加一（取容器中末尾的前一个元素），以便让循环正确运行——它返回的指针指向最靠近数组界限的数据。就像普通循环中的数组，比如for (i=0; i<6; i++) {ar[i] = i;} ——ar[6]是不存在的，在循环中不会达到这个元素，所以在循环中不会出现问题。

STL的烦恼之一——初始化

STL令人烦恼的地方是在它初始化的时候。STL中容器的初始化比C/C++数组初始化要麻烦的多。你只能一个元素一个元素地来，或者先初始化一个普通数组再通过转化填放到容器中。我认为人们通常可以这样做：

//程序：初始化演示
//目的：为了说明STL中的向量是怎样初始化的。

#include <cstring>  // <cstring>和<string.h>相同
#include <vector>
using namespace std;

int ar[10] = {  12, 45, 234, 64, 12, 35, 63, 23, 12, 55  };
char* str = "Hello World";

int main(int argc, char* argv[])
{
  vector <int> vec1(ar, ar+10);
  vector <char> vec2(str, str+strlen(str));
  return 0;
}

在编程中，有很多种方法来完成同样的工作。另一种填充向量的方法是用更加熟悉的方括号，比如下面的程序：

//程序：vector演示二
//目的：理解带有数组下标和方括号的STL向量

#include <cstring>
#include <vector>
#include <iostream>
using namespace std;

char* szHW = "Hello World";
int main(int argc, char* argv[])
{
  vector <char> vec(strlen(sHW)); //为向量分配内存空间
  int i, k = 0;
  char* cptr = szHW;
  while (*cptr != '/0')
  {  vec[k] = *cptr;  cptr++;  k++;  }
  for (i=0; i<vec.size(); i++)
  {  cout << vec[i];  }
  cout << endl;
  return 0;
}

这个例子更加清晰，但是对游标（iterator）的操作少了，并且定义了额外的整形数作为下标，而且，你必须清楚地在程序中说明为向量分配多少内存空间。

命名空间（Namespace）

与STL相关的概念是命名空间（namespace）。STL定义在std命名空间中。有3种方法声明使用的命名空间：

1．用using关键字使用这个命名空间，在文件的顶部，但在声明的头文件下面加入：
using namespace std;
这对单个工程来说是最简单也是最好的方法，这个方法可以把你的代码限定在std命名空间中。

2．使用每一个模板前对每一个要使用的对象进行声明（就像原形化）：
using std::cout;
using std::endl;
using std::flush;
using std::set;
using std::inserter;
尽管这样写有些冗长，但可以对记忆使用的函数比较有利，并且你可以容易地声明并使用其他命名空间中的成员。

3．在每一次使用std命名空间中的模版时，使用std域标识符。比如：
typedef std::vector VEC_STR;
这种方法虽然写起来比较冗长，但是是在混合使用多个命名空间时的最好方法。一些STL的狂热者一直使用这种方法，并且把不使用这种方法的人视为异类。一些人会通过这种方法建立一些宏来简化问题。

除此之外，你可以把using namespace std加入到任何域中，比如可以加入到函数的头部或一个控制循环体中。

一些建议

为了避免在调试模式（debug mode）出现恼人的警告，使用下面的编译器命令：

#pragma warning(disable: 4786)

另一条需要注意的是，你必须确保在两个尖括号之间或尖括号和名字之间用空格隔开，因为是为了避免同“>>”移位运算符混淆。比如
vector <list<int>> veclis;
这样写会报错，而这样写：
vector <list <int> > veclis;
就可以避免错误。

                                STL实践指南（中）

STL实践指南  Practical Guide to STL
作者：Jeff Bogan 
翻译：周翔

（接上篇）

另一种容器——集合（set）

这是微软帮助文档中对集合（set）的解释：“描述了一个控制变长元素序列的对象（注：set中的key和value是Key类型的，而map中的key和value是一个pair结构中的两个分量）的模板类，每一个元素包含了一个排序键（sort key）和一个值(value)。对这个序列可以进行查找、插入、删除序列中的任意一个元素，而完成这些操作的时间同这个序列中元素个数的对数成比例关系，并且当游标指向一个已删除的元素时，删除操作无效。”
而一个经过更正的和更加实际的定义应该是：一个集合（set）是一个容器，它其中所包含的元素的值是唯一的。这在收集一个数据的具体值的时候是有用的。集合中的元素按一定的顺序排列，并被作为集合中的实例。如果你需要一个键/值对（pair）来存储数据，map是一个更好的选择。一个集合通过一个链表来组织，在插入操作和删除操作上比向量（vector）快，但查找或添加末尾的元素时会有些慢。
下面是一个例子：

//程序：set演示
//目的：理解STL中的集合（set）

#include <string>
#include <set>
#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
  set <string> strset;
  set <string>::iterator si;
  strset.insert("cantaloupes");
  strset.insert("apple");
  strset.insert("orange");
  strset.insert("banana");
  strset.insert("grapes");
  strset.insert("grapes");  
  for (si=strset.begin(); si!=strset.end(); si++)  
  {  cout << *si << " ";  }
  cout << endl;
  return 0;
}

// 输出： apple banana cantaloupes grapes orange
//注意：输出的集合中的元素是按字母大小顺序排列的，而且每个值都不重复。

如果你感兴趣的话，你可以将输出循环用下面的代码替换：

copy(strset.begin(), strset.end(), ostream_iterator<string>(cout, " "));

.集合（set）虽然更强大，但我个人认为它有些不清晰的地方而且更容易出错，如果你明白了这一点，你会知道用集合（set）可以做什么。

所有的STL容器

容器（Container）的概念的出现早于模板（template），它原本是一个计算机科学领域中的一个重要概念，但在这里，它的概念和STL混合在一起了。下面是在STL中出现的7种容器：

vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。
deque（双端队列double-ended queue）——在功能上和vector相似，但是可以在前后两端向其中添加数据。 
list（列表）——游标一次只可以移动一步。如果你对链表已经很熟悉，那么STL中的list则是一个双向链表（每个节点有指向前驱和指向后继的两个指针）。
set（集合）——包含了经过排序了的数据，这些数据的值(value)必须是唯一的。
map（映射）——经过排序了的二元组的集合，map中的每个元素都是由两个值组成，其中的key（键值，一个map中的键值必须是唯一的）是在排序或搜索时使用，它的值可以在容器中重新获取；而另一个值是该元素关联的数值。比如，除了可以ar[43] = "overripe"这样找到一个数据，map还可以通过ar["banana"] = "overripe"这样的方法找到一个数据。如果你想获得其中的元素信息，通过输入元素的全名就可以轻松实现。
multiset（多重集）——和集合（set）相似，然而其中的值不要求必须是唯一的（即可以有重复）。
multimap（多重映射）——和映射（map）相似，然而其中的键值不要求必须是唯一的（即可以有重复）。
注意：如果你阅读微软的帮助文档，你会遇到对每种容器的效率的陈述。比如：log(n*n)的插入时间。除非你要处理大量的数据，否则这些时间的影响是可以忽略的。如果你发现你的程序有明显的滞后感或者需要处理时间攸关（time critical）的事情，你可以去了解更多有关各种容器运行效率的话题。

怎样在一个map中使用类？

Map是一个通过key（键）来获得value(值)的模板类。
另一个问题是你希望在map中使用自己的类而不是已有的数据类型，比如现在已经用过的int。建立一个“为模板准备的（template-ready）”类，你必须确保在该类中包含一些成员函数和重载操作符。下面的一些成员是必须的：

缺省的构造函数（通常为空）

拷贝构造函数

重载的”=”运算符

你应该重载尽可能多的运算符来满足特定模板的需要，比如，如果你想定义一个类作为 map中的键（key），你必须重载相关的运算符。但在这里不对重载运算符做过多讨论了。

//程序：映射自定义的类。
//目的：说明在map中怎样使用自定义的类。

#include <string>
#include <iostream>
#include <vector>
#include <map>
using namespace std;

class CStudent
{
public :
  int nStudentID;
  int nAge;
public :
  //缺省构造函数——通常为空
  CStudent()  {  }
  // 完整的构造函数
  CStudent(int nSID, int nA)  {  nStudentID=nSID; nAge=nA;  }
  //拷贝构造函数
  CStudent(const CStudent& ob)  
    {  nStudentID=ob.nStudentID; nAge=ob.nAge;  }
  // 重载“=”
  void operator = (const CStudent& ob)  
    {  nStudentID=ob.nStudentID; nAge=ob.nAge;  }
};

int main(int argc, char* argv[])
{
  map <string, CStudent> mapStudent;

  mapStudent["Joe Lennon"] = CStudent(103547, 22);
  mapStudent["Phil McCartney"] = CStudent(100723, 22);
  mapStudent["Raoul Starr"] = CStudent(107350, 24);
  mapStudent["Gordon Hamilton"] = CStudent(102330, 22);

  // 通过姓名来访问Cstudent类中的成员
  cout << "The Student number for Joe Lennon is " << 
    (mapStudent["Joe Lennon"].nStudentID) << endl;

  return 0;
}

TYPEDEF

如果你喜欢使用typedef关键字，下面是个例子：
typedef set <int> SET_INT;
typedef SET_INT::iterator SET_INT_ITER

编写代码的一个习惯就是使用大写字母和下划线来命名数据类型。

ANSI / ISO字符串

ANSI/ISO字符串在STL容器中使用得很普遍。这是标准的字符串类，并得到了广泛地提倡，然而在缺乏格式声明的情况下就会出问题。你必须使用“<<”和输入输出流（iostream）代码（如dec, width等）将字符串串联起来。
可在必要的时候使用c_str()来重新获得字符指针。

                                STL实践指南（下）
STL实践指南  Practical Guide to STL
作者：Jeff Bogan 
翻译：周翔

（接中篇）

游标（Iterator）

我说过游标是指针，但不仅仅是指针。游标和指针很像，功能很像指针，但是实际上，游标是通过重载一元的”*”和”->”来从容器中间接地返回一个值。将这些值存储在容器中并不是一个好主意，因为每当一个新值添加到容器中或者有一个值从容器中删除，这些值就会失效。在某种程度上，游标可以看作是句柄（handle）。通常情况下游标（iterator）的类型可以有所变化，这样容器也会有几种不同方式的转变：
iterator——对于除了vector以外的其他任何容器，你可以通过这种游标在一次操作中在容器中朝向前的方向走一步。这意味着对于这种游标你只能使用“++”操作符。而不能使用“--”或“+=”操作符。而对于vector这一种容器，你可以使用“+=”、“—”、“++”、“-=”中的任何一种操作符和“<”、“<=”、“>”、“>=”、“==”、“!=”等比较运算符。
reverse_iterator ——如果你想用向后的方向而不是向前的方向的游标来遍历除vector之外的容器中的元素，你可以使用reverse_iterator 来反转遍历的方向，你还可以用rbegin()来代替begin()，用rend()代替end()，而此时的“++”操作符会朝向后的方向遍历。 
const_iterator ——一个向前方向的游标，它返回一个常数值。你可以使用这种类型的游标来指向一个只读的值。
const_reverse_iterator ——一个朝反方向遍历的游标，它返回一个常数值。

Set和Map中的排序

除了类型和值外，模板含有其他的参数。你可以传递一个回调函数（通常所说的声明“predicate”——这是带有一个参数的函数返回一个布尔值）。例如，如果你想自动建立一个集合，集合中的元素按升序排列，你可以用简明的方法建立一个set类：

set <int, greater<int> > set1

greater 是另一个模板函数（范型函数），当值放置在容器中后，它用来为这些值排序。如果你想按降序排列这些值，你可以这样写：

set <int, less<int> > set1

在实现算法时，将声明（predicate）作为一个参数传递到一个STL模板类中时会遇到很多的其他情况，下面将会对这些情况进行详细描述。

STL 的烦恼之二——错误信息

这些模板的命名需要对编译器进行扩充，所以当编译器因某种原因发生故障时，它会列出一段很长的错误信息，并且这些错误信息晦涩难懂。我觉得处理这样的难题没有什么好办法。但最好的方法是去查找并仔细研究错误信息指明代码段的尾端。还有一个烦恼就是：当你双击错误信息时，它会将错误指向模版库的内部代码，而这些代码就更难读了。一般情况下，纠错的最好方法是重新检查一下你的代码，运行时忽略所有的警告信息。

算法（Algorithms）

算法是模板中使用的函数。这才真正开始体现STL的强大之处。你可以学习一些大多数模板容器中都会用到的一些算法函数，这样你可以通过最简便的方式进行排序、查找、交换等操作。STL中包含着一系列实现算法的函数。比如：sort(vec.begin()+1, vec.end()-1)可以实现对除第一个和最后一个元素的其他元素的排序操作。
容器自身不能使用算法，但两个容器中的游标可以限定容器中使用算法的元素。既然这样，算法不直接受到容器的限制，而是通过采用游标，算法才能够得到支持。此外，很多次你会遇到传递一个已经准备好了的函数（以前提到的声明：predicate）作为参数，你也可以传递以前的旧值。
下面的例子演示了怎样使用算法：

//程序：测试分数统计
//目的：通过对向量中保存的分数的操作说明怎样使用算法 

#include <algorithm>  //如果要使用算法函数，你必须要包含这个头文件。
#include <numeric>  // 包含accumulate（求和）函数的头文件
#include <vector>
#include <iostream>
using namespace std;

int testscore[] = {67, 56, 24, 78, 99, 87, 56};

//判断一个成绩是否通过了考试
bool passed_test(int n)
{
  return (n >= 60);
}

// 判断一个成绩是否不及格
bool failed_test(int n)
{
  return (n < 60);
}

int main(int argc, char* argv[])
{
  int total;
  // 初始化向量，使之能够装入testscore数组中的元素
  vector <int> vecTestScore(testscore, 
     testscore + sizeof(testscore) / sizeof(int));
  vector <int>::iterator vi;

  // 排序并显示向量中的数据
  sort(vecTestScore.begin(), vecTestScore.end());
  cout << "Sorted Test Scores:" << endl;
  for (vi=vecTestScore.begin(); vi != vecTestScore.end(); vi++)
  {  cout << *vi << ", ";  }
  cout << endl;

  // 显示统计信息

  // min_element 返回一个 _iterator_ 类型的对象，该对象指向值最小的那个元素。
  //“*”运算符提取元素中的值。
  vi = min_element(vecTestScore.begin(), vecTestScore.end());
  cout << "The lowest score was " << *vi << "." << endl;

  //与min_element类似，max_element是选出最大值。
  vi = max_element(vecTestScore.begin(), vecTestScore.end());
  cout << "The highest score was " << *vi << "." << endl;

  // 使用声明函数（predicate function，指vecTestScore.begin()和vecTestScore.end()）来确定通过考试的人数。
  cout << count_if(vecTestScore.begin(), vecTestScore.end(), passed_test) << 
    " out of " << vecTestScore.size() << 
    " students passed the test" << endl;

  // 确定有多少人考试挂了
  cout << count_if(vecTestScore.begin(), 
    vecTestScore.end(), failed_test) << 
    " out of " << vecTestScore.size() << 
    " students failed the test" << endl;

  //计算成绩总和
  total = accumulate(vecTestScore.begin(), 
     vecTestScore.end(), 0);
  // 计算显示平均成绩
  cout << "Average score was " << 
    (total / (int)(vecTestScore.size())) << endl;

  return 0;
}

Allocator（分配器）

Allocator用在模板的初始化阶段，是为对象和数组进行分配内存空间和释放空间操作的模板类。它在各种情况下扮演着很神秘的角色，它关心的是高层内存的优化，而且对黑盒测试来说，使用Allocator是最好的选择。通常，我们不需要明确指明它，因为它们通常是作为不用添加的缺省的参数出现的。如果在专业的测试工作中出现了Allocator，你最好搞清楚它是什么。

Embed Templates（嵌入式模版）和Derive Templates（基模板）

每当你使用一个普通的类的时候，你也可以在其中使用一个STL类。它是可以被嵌入的：

class CParam
{
  string name;
  string unit;
  vector <double> vecData;
};

或者将它作为一个基类：

class CParam : public vector <double>
{
  string name;
  string unit;
};

STL模版类作为基类时需要谨慎。这需要你适应这种编程方式。

模版中的模版

为构建一个复杂的数据结构，你可以将一个模板植入另一个模板中（即“模版嵌套”）。一般最好的方法是在程序前面使用typedef关键字来定义一个在另一个模板中使用的模版类型。

// 程序：在向量中嵌入向量的演示。
//目的：说明怎样使用嵌套的STL容器。

#include <iostream>
#include <vector>

using namespace std;

typedef vector <int> VEC_INT;

int inp[2][2] = {{1, 1}, {2, 0}};  
  // 要放入模板中的2x2的正则数组

int main(int argc, char* argv[])
{
  int i, j;
  vector <VEC_INT> vecvec;
  // 如果你想用一句话实现这样的嵌套，你可以这样写：
  // vector <vector <int> > vecvec;

  // 将数组填入向量
  VEC_INT v0(inp[0], inp[0]+2);  
    // 传递两个指针
    // 将数组中的值拷贝到向量中
  VEC_INT v1(inp[1], inp[1]+2);

  vecvec.push_back(v0);
  vecvec.push_back(v1);

  for (i=0; i<2; i++)
  {
    for (j=0; j<2; j++)
    {
      cout << vecvec[i][j] << "  ";
    }
    cout << endl;
  }
  return 0;
}

// 输出：
// 1 1
// 2 0

虽然在初始化时很麻烦，一旦你将数据填如向量中，你就实现了一个变长的可扩充的二维数组（大小可扩充直到使用完内存）。根据实际需要，可以使用各种容器的嵌套组合。

总结

STL是有用的，但是使用过程中的困难和麻烦是再所难免的。就像中国人所说的：“如果你掌握了它，便犹如虎添翼。”


**9、堆和栈**

堆：顺序随意
栈：先进后出
堆和栈的区别
一、预备知识—程序的内存分配
一个由c/C++编译的程序占用的内存分为以下几个部分
1）、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
2）、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3）、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
4）、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
5）、程序代码区—存放函数体的二进制代码。
二、例子程序
这是一个前辈写的，非常详细
//main.cpp 
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{    
      int b; 栈
      char s[] = "abc"; 栈 
      char *p2; 栈 
      char *p3 = "123456"; 123456/0在常量区，p3在栈上。 
      static int c =0； 全局（静态）初始化区 
      p1 = (char *)malloc(10); 
      p2 = (char *)malloc(20); 
      分配得来得10和20字节的区域就在堆区。 
      strcpy(p1, "123456"); 123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
} 
二、堆和栈的理论知识
2.1）申请方式
stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:需要程序员自己申请，并指明大小，在c中malloc函数如p1 = (char *)malloc(10);在C++中用new运算符如p2 = (char *)malloc(10);但是注意p1、p2本身是在栈中的
2.2）申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 
2.3）申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 
2.4）申请效率的比较：
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活 
2.5）堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
2.6）存取效率的比较 
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
比如：
#include
void main()
{    
      char a = 1;     
      char c[] = "1234567890";     
      char *p ="1234567890";    
      a = c[1];     
      a = p[1];     
      return;     
}
2.7）小结：
堆和栈的区别可以用如下的比喻来看出：使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 
堆和栈的区别主要分： 
操作系统方面的堆和栈，如上面说的那些，不多说了。还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。

10、C、C++的一些基本知识要点。


