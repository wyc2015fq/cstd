# 分布式系统架构之框架化服务 - 我相信...... - CSDN博客





2015年03月11日 07:51:27[半吊子全栈工匠](https://me.csdn.net/wireless_com)阅读数：2516










要使业务系统无极缩放，微服务架构方兴未艾。本质上，就是采用API（例如REST） 封装服务调用，形成服务框架。




既然是分布式API调用，必然涉及到网络IO常见的三种方式：

1）  BIO：Blocking IO，阻塞方式，一个socket用一个线程处理

2）  NIO: Non-blocking IO，事件驱动，采用reactor模式，一个线程中处理多个socket，JDK1.4以上版本支持

3）  AIO：Asynchronous IO，异步，采用Proactor模式，NIO在有通知时可以进行相关操作，AIO在有通知时表示相关操作已经完成，JDK1.7以上版本支持。




对服务的API调用而言，分为同步服务调用和异步服务调用。



**同步服务调用**


支持同步服务调用时，一般要有IO线程，数据队列，通信对象队列和定时任务。

1）  IO线程专门负责和socket连接，进行数据的收发。

2）  收发的数据进入数据队列

3）  通信对象队列保存了多个线程使用的通信对象，主要为了阻塞请求线程，请求线程把数据放入数据队列后会生成一个通信对象，进入通信对象队列并在通信对象队列上等待。

4）  通信对象用于唤醒请求线程。

5）  如果在远程调用超时前执行完毕并返回，那么IO线程就会通知通信对象，通信对象则会结束请求线程的等待，并把结果传给请求进程，以进行后续处理

6）  定时任务负责检查通信队列中的哪些通信对象已经超时，然后这些通信对象会通知请求线程超时。



**异步服务调用**


支持异步服务调用时，常见的有四种调用方式

1）  单向请求，基本等价于一个不保证可靠到达的通知

2）  回调，是一种被动的方式。请求者设置了回调对象，把数据写入数据队列后就继续自己处理了。回调的执行在IO线程中或定时任务（主要处理超时）的线程中，建议用新的线程来执行回调。

3）  Future，Java中的future非常便利，先把future放入队列，然后数据入队列，在线程中处理，等请求线程的其他处理结束后，就通过future来获取通信结果并直接控制超时。

4）  可靠异步，能保证异步请求在远程被执行。



服务端主要有两部分工作：

1）  本地服务的注册管理，服务需要注册到服务注册查找中心后才能被服务调用者发现。

2）  根据请求来定位服务并执行。启动时完成注册，监听端口，通信部分同样用NIO方式实现。IO线程进行通信的处理，一般是多个，完成协议解析。调用服务一般在工作线程进行，反序列化取决于具体实现。工作线程实际上是相互隔离的多个不同服务的线程池。



服务的升级有两种情况：

1)      接口不变，代码完善或功能完善，只是内部服务的实现有变化。

2)      需要修改原有的接口

a)        在接口中增加方法

b)        对接口的某些方法修改调用的参数列表。可以通过版本号来解决，或者在设计上考虑参数的扩展性，例如map传参



服务治理是在系统采用服务框架后，完成管理服务和查看服务的功能。管理服务需要控制、操作整个分布式系统中的服务，查看则是看运行时的状态或一些具体信息、历史数据等。查看服务的具体内容包括：服务信息，服务质量，容量，依赖，分布，统计，元数据，服务查询，报表和监视。 服务管理的内容内容包括：上下线，路由，限流降级，归组，线程池管理，机房规则，服务授权。




需要注意的是，在分布式系统中处理session存储问题的方式：

1）  Session Sticky：负责均衡需要根据每次请求的会话标识来进行请求转发

2）  Session Replication：web服务器之间增加了会话数据同步

3）  Session 数据的集中存储：在web服务器数量大，session 数多时最佳

4）  Cookie 使用，在客户端请求上使用session 数据



