# 中关于虚拟机复制与迁移（上） - 我相信...... - CSDN博客





2014年07月24日 08:59:26[半吊子全栈工匠](https://me.csdn.net/wireless_com)阅读数：1412
个人分类：[云计算](https://blog.csdn.net/wireless_com/article/category/1292302)

所属专栏：[云服务之旅](https://blog.csdn.net/column/details/13000.html)









**这是我曾经在 <<the architecture of open source applications>> 中的一篇文章试译。**

**SnowFlock**

[罗伊科比](http://www.aosabook.org/en/intro1.html#bryant-roy)和[安德烈斯](http://www.aosabook.org/en/intro1.html#lagar-cavilla-andres)

云计算提供了一个令人难以置信的计算平台。用户通过点击几下用户可以以每小时不到10美分的价格租用在云中的服务器，节约了使用物理设备的所有相关时间，精力和前期成本。云供应商提供虚拟机（虚拟机），而不是物理计算机来实现低成本运营。云计算的关键是虚拟化软件，被称为虚拟机监视器（虚拟机M），用来模拟一台物理机器。用户们非常安全地使用相互的客户虚拟机，而没有意识到他们通常与许多人共享物理机（“主机”）。

***18.1 SnowFlock简介***

云计算是敏捷组织的福音。对于使用物理服务器而言，用户需要焦急地等待着缓慢的审批流程，批准购买服务器，下订单，直至服务器出货，然后安装和配置操作系统（OS）和应用程序组。而云用户不需要等待数周的购买流程，只专注过程控制，并可以在几分钟内创建一个新的独立服务器。

不幸的是，云服务器很少是独立的。在快速实例化和按次使用模式的带动下，云服务器通常是在配置相似的服务器可变池中的一个实例，能够执行动态和可扩展的并行计算，数据挖掘，或web等任务。因为需要多次从相同的静态模板中启动新的实例，商业云还不能兑现真正的按需计算的承诺。服务器实例化后，云用户仍然必须管理群集成员及通过增加新的服务器来调整。

SnowFlock通过虚拟机克隆技术解决了这些问题，这就是我们所提出的云API调用。应用程序代码经常通过一个系统调用接口调用OS服务，它现在也可以以同样的方式通过类似的接口调用云服务。通过SnowFlock的虚拟机克隆技术，我们可以将资源分配，集群管理和应用程序逻辑可编程等诸多方面交织在一起，并作为一个单一的逻辑操作。

根据父虚拟机,虚拟机克隆技术实例化了云服务器的多个完全相同副本。从逻辑上讲，克隆的虚拟机继承了其父节点的所有状态，包括操作系统和应用程序级缓存。此外，虚拟机的克隆都将被自动添加到一个内部私有网络中，从而有效地加入了这个动态可扩展的群集。新的计算资源，被封装为相同的虚拟机，从而可以按需动态创建。

就实际使用而已，虚拟机克隆技术是可用，高效，而且快速的。在这一章中，我们将描述SnowFlock中对虚拟机克隆技术的实现，包括如何有效地在多个不同的编程模型和框架实现克隆，如何在应用程序运行时使服务器的开销最少，以及如何在5秒或更少的时间内来创造几十个新的虚拟机，等等。

SnowFlock非常灵活，能够使用C， C + +，Python和Java的API来实现虚拟机克隆的程序控制。我们已经成功地将SnowFlock移植到多个不同系统的原型实现中。在并行计算中，我们通过精确克隆技术有效地分担了在许多物理主机的负载，并取得了良好的效果。对于在一个专用的服务器集群上运行的使用了消息传递接口（MPI）的多个并行应用，需要修改MPI的启动管理器，从而提供了良好的性能和更少的开销，并且不需要修改应用就能够在每个新的克隆集群上运行。最后，在一些完全不同的应用案例中，我们使用SnowFlock来提高弹性服务器的效率和性能。今天，基于云服务的新业务一般需要启动新的服务器。而通过克隆运行中的虚拟机，SnowFlock带来了新的服务器功能。由于克隆的虚拟机继承他们的父节点的热缓冲区，从而使性能迅速达到峰值，使上线速度快了20倍。

***18.2 虚拟机克隆***

顾名思义，虚拟机克隆与父虚拟机几乎是相同的。实际上，还是有一些轻微且必要的差异的，例如避免MAC地址冲突等问题，但我们会稍后讨论。创建一个整个本地磁盘和内存状态的虚拟机克隆是必须的，这也是我们第一个主要的设计权衡：应该如何按需复制前端的状态？

实现虚拟机克隆最简单的方式是采用标准的虚拟机“迁移”能力。通常情况下，迁移是指将运行中的虚拟机服务移动到不同的主机上，例如如当主机超载或需要维修的情况下。但是，因为虚拟机是纯粹的软件，所以可以被封装在一个数据文件，然后将其复制到一个新的主机上，在短暂中断后重新执行。要做到这一点，现有的VMMS要包含一个“检查点”来创建文件，该文件包括本地文件系统，内存映像，虚拟CPU（VCPU）寄存器等等。在迁移过程中，新启动的副本替换原来的虚拟机，但这个过程是可以改变的，例如离开原来的虚拟机运行时可以产生一个虚拟机克隆。在这种所谓的“渴望”进程中，因为整个虚拟机处于状态转移前的执行状态，所以整个虚拟机提供了最好的初始性能。这种复制的缺点是在开始执行前必须费力地复制整个虚拟机，这严重地影响了实例化的过程。

SnowFlock采用了另一种极端方式，即是延迟状态复制。不再复制全部虚拟机，而是复制虚拟机转移时所需得重要数据，在虚拟机转移后，SnowFlock在复制克隆中所需的其他数据。这有两个好处，首先，它最大限度地减少了工作量，尽可能实例化延迟加载。其次，它只复制真正使用的状态数据，实际上是提高了虚拟机克隆的效率。当然，这样做的好处取决于克隆的行为，但少量的应用程序需要访问内存和在本地文件系统的每个文件的每一页时就效果不大了。

然而，延时复制的好处不是免费的。由于状态转移被推迟到最后，需要在状态到达时，才能继续执行克隆。在时间共享工作站内将内存交换到磁盘，而并行的应用程序从高延迟的数据源获取状态可能被阻塞。在SnowFlock的用例中，这些阻塞降低了克隆的性能，其严重程度取决于应用程序。对于高性能计算应用，我们已经发现这种退化的影响不大，但可能会首先克隆的数据库服务器性能。应当指出的是，这是一个瞬态影响：在几分钟之内，大多数必要的状态已被转移且性能父节点匹配。

顺便说一句，如果你熟悉虚拟机，你可能考虑在这里使用实时迁移的优化。实时迁移的优化，可以缩短原始虚拟机的暂停和恢复执行新副本之间的间隔。要做到这一点，虚拟机监视器（VMM）需要在父节点仍在运行时预拷贝它的状态，从而使只有最近更改过的页才迁移。这项技术不会影响之间的迁移要求和副本开始执行的时间间隔，因此不会降低虚拟机克隆的实例化延迟。






