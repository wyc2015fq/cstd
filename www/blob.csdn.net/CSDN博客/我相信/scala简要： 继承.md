# scala简要： 继承 - 我相信...... - CSDN博客





2015年01月01日 21:08:02[半吊子全栈工匠](https://me.csdn.net/wireless_com)阅读数：1140








                scala扩展类的方式同样是使用extends关键字，重写一个非抽象方法必须使用override修饰符，用isInstanceOf方法判断某个对象是否属于某个特定的类，只有主构造器可以调用超类的构造器。

字段重写时的限制：
-def 只能重写另一个def
-val只能重写另一个val或不带参数的def
-var只能重写另一个抽象的var

构造顺序问题的根本原因——java允许在超类的构造方法中调用子类的方法。因为在子类中正确的扩展相等性判断非常困难，所以将equals方法定义成final。除非万不得已，不要使用wait，notify和synchronized。

和java的接口不同，scala特质可以给出这些特质的缺省实现。让特质拥有具体行为存在一个弊端，当特质改变时，所有混入了该特质的类必须要重新编译。scala不支持多继承，可以用with关键字来添加额外的特质。当做富接口使用的特质将具体方法和抽象方法结合在了一起，特质中的字段同样既可以是具体的，又可以是抽象的。
混入特质的对象在构造时的执行顺序：
1）首先调用超类的构造器
2）特质构造器在超类构造器之后，类构造器之前执行
3）特质由左到右构造
4）每个特质中，父特质先被构造，
5）如果多个特质有一个父特质，若已被构造则不会再次构造
6）所有特质构造完毕，子类被构造。

缺少构造器参数是特质与类之间唯一的技术差别。            


