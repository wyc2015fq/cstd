# 算法导论--堆排序 - 勿在浮砂筑高台 - CSDN博客





2015年03月26日 19:45:05[勿在浮砂筑高台](https://me.csdn.net/luoshixian099)阅读数：2797
所属专栏：[算法导论--学习笔记](https://blog.csdn.net/column/details/lsx-099.html)









堆排序的时间复杂度为nlg(n),堆排序还有一个重要的用途在优先队列上！

![](https://img-blog.csdn.net/20150812103856614)![](https://img-blog.csdn.net/20150910145228836)


下面是最大堆排序的实现算法：

```cpp
#include <stdio.h>
int A[]={7,15,26,1,14,3,16,64,6,57};
int Heap_Size=sizeof(A)/4-1;
void Max_Heapify(int *A,int i);             //修复最大堆
void Build_Max_Heap(int *A);                //建立堆
void HeapSort(int * A);                    //堆排序
int main()
{   
int j;
int Length = Heap_Size;
    HeapSort(A);	
	for ( j=0 ;j<=Length;j++)
	{
		printf("%d\n",A[j]);		
	}
	return 0;
}
void Max_Heapify(int *A,int i)
{
	int Larger =i;
	int Left = 2*i+1;
	int Right =2*i+2;
	
	if (Left<=Heap_Size && A[Left]>A[i])              //判断是否小于其孩子的值
	{
		Larger =Left;
	}
	if (Right<=Heap_Size && A[Right]>A[Larger])         
	{
		Larger = Right;
	}
	if (Larger != i)                      //如果小于，就与其中最大的孩子调换位置
	{
		int temp =A[i];
		A[i]=A[Larger];
		A[Larger]=temp;
		Max_Heapify(A,Larger);
	}
}
void Build_Max_Heap(int *A)                             //建立堆
{
   int i;
   for( i=(int)(Heap_Size/2);i>=0;i--)
   {
        Max_Heapify(A,i);
   }
}
void HeapSort(int * A)            
{   
	Build_Max_Heap(A);
	while(Heap_Size>=0)                  //逐个输出
	{
   int temp=A[Heap_Size];
		A[Heap_Size]=A[0];
		A[0]=temp;
		Heap_Size--;
	   Max_Heapify(A,0);
	}
}
```





