# 算法导论--快速排序 - 勿在浮砂筑高台 - CSDN博客





2015年04月11日 16:05:33[勿在浮砂筑高台](https://me.csdn.net/luoshixian099)阅读数：2289
所属专栏：[算法导论--学习笔记](https://blog.csdn.net/column/details/lsx-099.html)









快速排序是目前最流行排序算法。文章最后附上随机化版本的快速排序。 
![这里写图片描述](https://img-blog.csdn.net/20150910160707218)![这里写图片描述](https://img-blog.csdn.net/20150910160728832)
```cpp
#include <stdio.h>
int A[]={5,2,7,12,55,3,21,15,1};
int Partition(int *A,int p,int r)
{
   int x=A[r];    //最后的元素作为主元，把它的位置先确定下来
   int i=p-1;
   int j;
   int temp;
   for (j=p;j<=r-1;j++)
   {
       if (A[j]<=x)
       {
           i=i+1;
           temp=A[i];
           A[i]=A[j];
           A[j]=temp;
       }
   }

   temp=A[i+1];
   A[i+1]=A[r];
   A[r]=temp;

   return i+1;
}
void QuickSort(int *A,int p,int r)
{
    int q;
    if (p < r)
    {
        q=Partition(A,p,r);
        QuickSort(A,p,q-1);
        QuickSort(A,q+1,r);
    }

}
int main()
{    
    int k=0;
    int Length=sizeof(A)/sizeof(A[0])-1;
    QuickSort(A,0,Length);
    for (k=0;k<=Length;k++)
    {
        printf("%2d\n",A[k]);
    }
    return 0;
}
```

下面是随机化版本，即不用最后的元素作为主元，从[p,r]中随机产生一个数，与最后一个元素交换位置，这样可以做到在大数据中有较好的期望性能。

```cpp
#include <stdio.h>
#include <STDLIB.H>
#include <TIME.H>

int A[]={5,2,7,12,55,3,21,15,1};


int Partition(int *A,int p,int r)
{
   int x=A[r];
   int i=p-1;
   int j;
   int temp;

   for (j=p;j<=r-1;j++)
   {
       if (A[j]<=x)
       {
           i=i+1;
           temp=A[i];
           A[i]=A[j];
           A[j]=temp;
       }
   }

   temp=A[i+1];
   A[i+1]=A[r];
   A[r]=temp;

   return i+1;
}
int Randomizem_Partition(int *A,int p,int r)   //产生随机数，做交换
{   
    int temp;
    int c=(int)(((int)rand()%(r-p+1))+ p);
    temp=A[r];
    A[r]=A[c];
    A[c]=temp;

    return Partition(A,p,r);
}
void QuickSort(int *A,int p,int r)
{
    int q;
    if (p < r)
    {
        q=Randomizem_Partition(A,p,r);
        QuickSort(A,p,q-1);
        QuickSort(A,q+1,r);
    }

}

int main()
{    
    int k=0;
    int Length=sizeof(A)/sizeof(A[0])-1;
    srand((int)time(NULL));   //随机种子
    QuickSort(A,0,Length);
    for (k=0;k<=Length;k++)
    {
        printf("%2d\n",A[k]);
    }
    return 0;
}
```




