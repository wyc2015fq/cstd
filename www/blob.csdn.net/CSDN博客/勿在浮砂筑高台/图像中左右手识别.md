# 图像中左右手识别 - 勿在浮砂筑高台 - CSDN博客





2015年04月10日 18:18:27[勿在浮砂筑高台](https://me.csdn.net/luoshixian099)阅读数：2033








这是在帮助学弟参加信息安全竞赛做的。

他的创意是在传统数字密码的基础上，加一个左右手绑定！如设置第一位密码必须用左手按，第二位密码必须用右手去按等等...




算法的过程是：首先对输入的视频帧图像转换为HSV空间，因为皮肤在饱和度上比较突出，这样可以容易切割。做一个模板匹配，再二值化图像，形态学处理。

最后对掩码图像分析，首先找到食指的位置，做一条基准线。计算基准线左右的积分图大小，从而判断左右手。

![](https://img-blog.csdn.net/20150410182824364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvc2hpeGlhbjA5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


这里我用自己的键盘做的测试，效果还算可以吧。正确率比较高

程序如下：



```cpp
#include "stdafx.h"
#include "cv.h"
#include "highgui.h"
#include "stdio.h"
#include <iostream>
#include "math.h"
using namespace std;

void Rcgntion_Hand(IplImage * m_imge);
int main(int argc, char **argv)
{

	/*************************计算模板直方图*****************************/
	IplImage * Temp = cvLoadImage("template.bmp");
	IplImage * Temp_hvs= cvCreateImage(cvGetSize(Temp),8,3);
	cvCvtColor(Temp,Temp_hvs,CV_BGR2HSV);
	IplImage * T_h_plane = cvCreateImage(cvGetSize(Temp),8,1);
	IplImage * T_s_plane = cvCreateImage(cvGetSize(Temp),8,1);
	IplImage * T_v_plane = cvCreateImage(cvGetSize(Temp),8,1);
	cvCvtPixToPlane(Temp_hvs,T_h_plane,T_s_plane,T_v_plane,0);
	IplImage *T_planes[]={T_h_plane};
	int h_bins  =30;
	CvHistogram * hist;
	{
		int his_size[] = {h_bins};
		float h_ranges[] = {0,255};
		float * ranges[] = {h_ranges};
		hist = cvCreateHist(1,his_size,CV_HIST_ARRAY,ranges,1);
	}
	cvCalcHist(T_planes,hist,0,0);

	/*********************************************************/
	CvCapture * capture = cvCreateCameraCapture(0);
	IplImage * src = cvQueryFrame(capture);
	cvNamedWindow("k");

	IplImage * src_hvs = cvCreateImage(cvGetSize(src),8,3);
	cvCvtColor(src,src_hvs,CV_BGR2HSV);
	IplImage * h_plane = cvCreateImage(cvGetSize(src),8,1);
	IplImage * s_plane = cvCreateImage(cvGetSize(src),8,1);
	IplImage * v_plane = cvCreateImage(cvGetSize(src),8,1);
	cvCvtPixToPlane(src_hvs,h_plane,s_plane,v_plane,0);
	IplImage * s_planes[] = {h_plane};

	IplImage * Result = cvCreateImage(cvSize(621,461),IPL_DEPTH_32F,1);
	int c;
	while (!(cvWaitKey(5)== 27))    //按ESC键后开始检测
	{
		src = cvQueryFrame(capture);
		cvCvtColor(src,src_hvs,CV_BGR2HSV);
		cvCvtPixToPlane(src_hvs,h_plane,s_plane,v_plane,0);
		c=cvWaitKey(5);
		
		if (c>=48 && c<= 57)
		{
		
		
			cvMatchTemplate(h_plane,T_h_plane,Result,CV_TM_CCORR);   //模板匹配
			cvNormalize(Result,Result,1,0,CV_MINMAX);                 //结果归一化
			cvSmooth(Result,Result,CV_GAUSSIAN);
			cvMorphologyEx(Result,Result,NULL,NULL,CV_MOP_OPEN);       //开运算
			cvThreshold(Result,Result,0.5,1,CV_THRESH_BINARY);  
		//	cvThreshold(Result,Result,100,200,CV_THRESH_BINARY);  
		
			
		///	
		
			Rcgntion_Hand(Result);
			cout<<"    数字："<<c-48<<endl;
			//cvWaitKey(0);
			//cout<<"请稍等.............";


		}

		
		//cvMorphologyEx(Result,Result,NULL,NULL,CV_MOP_OPEN);       //开运算

		cvShowImage("k",src);
	}


	//JudgeHand(frame_grey);                        	
	cvReleaseCapture(&capture);
	return 0;
}
void Rcgntion_Hand(IplImage * m_imge)
{
	unsigned int L_hand=0;
	unsigned int R_hand=0;
	double* ptr;
	unsigned int temp=0;
	unsigned int  Mid_line=0;

	unsigned int  ReferLine=0;



	/*     找中线  */                                      
	for (int n =0 ; n<8 ; n++)       //选取最高的连续柱状， 作为食指位置，然后计算食指左边和右边的面积大小。
	{	

		for (int j=0;j<m_imge->height/2;j++)
		{
			ptr =(double *)cvPtr2D(m_imge,m_imge->height/2+j,80*n,NULL);
			for (int i=0;i<=80;i++)
			{
				//temp+= *(ptr+i);
				if (*(ptr+i) == 0)
				{
					temp++;
				}
			}
		}
		if (temp > Mid_line)
		{
			Mid_line = temp;
			ReferLine = n+1;

		}
		temp =0; 
	}
	/* ***************调试输出*********************/	
	//cout<<ReferLine<<endl;
cvRectangle(m_imge,cvPoint(ReferLine*80,m_imge->height/2),cvPoint(ReferLine*80+80,m_imge->height),cvScalar(0),CV_FILLED);       

	
	///************判断左右区域大小***************/
	for ( int i =0 ; i< m_imge->height/2 ; i++)
	{
		for ( int j = 0;j<m_imge->width; j++)               //以ReferLine作为基准 ，比较区域大小
		{
			ptr =(double *)cvPtr2D(m_imge,i,j,NULL);
			if (*ptr == 0)
			{
				if ( j <(ReferLine *80 ) )	
					R_hand ++;
				else if ( j>(ReferLine *80 ) +80)
					L_hand++;
			}
			

		}
	}
	//cout<<"R_hand="<<R_hand<<endl;
	//cout<<"L_hand="<<L_hand<<endl;

	if (L_hand>R_hand)
		cout<<"左手";
	else
		cout<<"右手";
}
/***********************************/
```
效果图：



![](https://img-blog.csdn.net/20150410183203981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvc2hpeGlhbjA5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](https://img-blog.csdn.net/20150410183227444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvc2hpeGlhbjA5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)







