# 震惊的事实--数组与指针不相同？ - 勿在浮砂筑高台 - CSDN博客





2015年05月07日 21:54:35[勿在浮砂筑高台](https://me.csdn.net/luoshixian099)阅读数：871标签：[指针																[数组](https://so.csdn.net/so/search/s.do?q=数组&t=blog)](https://so.csdn.net/so/search/s.do?q=指针&t=blog)
个人分类：[C/C++](https://blog.csdn.net/luoshixian099/article/category/2751523)








# △两个问题




## 问题1：

分析：



```cpp
#include <stdio.h>
void main()
{
char a[]="happylife";
char * p = a;


printf(" a ----- %x \n",&a);
printf(" p ----- %x \n",&p);
}
```

输出的结果会相同吗？







运行结果：

![](https://img-blog.csdn.net/20150507203729739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvc2hpeGlhbjA5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


都是指向了数组首地址，结果为什么不一样呢？

这个问题足以说明数组和指针并不相同。







## 问题2：

假如文件1中定义了一个数组a：

/******文件1****/

char a[]="happylife";
      

/***************/

在文件2中想调用数组a,这个时候我们必须声明a



/******文件2****/

extern char * a;        

/***************/

这时候我们发现程序无法正常运行，但我们把声明改为extern
 char a[]；就可以正常运行了，为什么呢?

# 究其为什么不同？




△以下全部用问题1的程序解释：




当我们取a[4]与p[4]时都能得到‘y’字符，但编译器提取字符的方式不同




当我们定义数组a时，a的地址12ff3c的即为数组第一个元素的地址，当运行a[4]时，编译器知道a是一个数组名，就取(12ff3c+4)的内容;

   当我们定义指针变量p时，编译器开辟一个空间存变量p,空间首地址为12ff38,当运行p[4]时，先取其保存的内容12ff3c，然后取(12ff3c+4)的内容。多了一次提取内容的操作！

![](https://img-blog.csdn.net/20150910214656136)


如果上面看懂了，这样我们就不难解释问题2的疑惑了，当在文件1中定义了一个数组，在文件2中申明它是一个指针，如果运行a[4],按照上面的方法，它会把字符‘y’当做一个地址，再一次取其内容，这样错的很惨！




# 什么时候相同？



1.在表达式中，a[i]编译器都会解释为*(a+i)形式 （这也是我们容易把指针和数组混淆为相同的原因）

2.作为函数参数时，无论写成指针形式还是数组形式，编译器都会把他当做指向数组第一个元素的指针。

因为在函数内部，始终当成指针访问，不会管到底输入的是数组还是指针。







# ★重点总结★：

**1.  无论什么时候，我们定义成什么，就应该申明什么，不能混用，因为直接影响编译器解释！**

**2.  sizeof()使用：sizeof（a）得到 10**

**                  sizeof  (p)  得到 4    这也是数组名和指针的不同之处**

3.  **可以执行p++;**

**    但不能执行a++;因为a只是个数组名，它不能作为左值被赋值~！**


















