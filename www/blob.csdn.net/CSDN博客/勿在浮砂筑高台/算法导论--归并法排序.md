# 算法导论--归并法排序 - 勿在浮砂筑高台 - CSDN博客





2015年03月26日 20:07:54[勿在浮砂筑高台](https://me.csdn.net/luoshixian099)阅读数：2670标签：[算法导论																[分治法排序](https://so.csdn.net/so/search/s.do?q=分治法排序&t=blog)](https://so.csdn.net/so/search/s.do?q=算法导论&t=blog)
个人分类：[Algorithm](https://blog.csdn.net/luoshixian099/article/category/3055207)

所属专栏：[算法导论--学习笔记](https://blog.csdn.net/column/details/lsx-099.html)








归并排序采用分治法思想，算法平均时间复杂度n*log(n)：

![](https://img-blog.csdn.net/20150910144329872)![](https://img-blog.csdn.net/20150910144942743)


程序示例：

```cpp
#include <stdio.h>
#include <STDLIB.H>
#include <string.h>
int C[]={4,2,8,3,6,10,24,5,12};
void Merge_Sort(int *A,int p,int r);
int main()
{
   int *p=C,i=0;
   int Length=sizeof(C)/4-1;     //得到数组长度
   Merge_Sort(p,0,Length);       //分治法排序
   while (i<=Length)
   {
	   printf("%3d ",C[i++]);
   }
	return 0;
} 
void Merge(int *A ,int p ,int q ,int r) //合并两个有序数列成为一个
{ 
int k=0;
int q2=++q;
int p2=p;
int *B =(int *)malloc((r-p2+1)*sizeof(int));


    while ( p<q2 && q <= r)
    {
       if (A[p] < A[q])
       {
          B[k]=A[p];
		  p++;
       }
	   else
	   {
		  B[k]=A[q];
		  q++; 
	   }
	   k++;
    }
	while(p<q2)
	{
		B[k]=A[p];
		p++;
		k++;
	}
	while(q<=r)
	{
		B[k]=A[q];
		q++;
		k++;
	}
memcpy(A+p2,B,(r-p2+1)*sizeof(int));
free(B);
}
void Merge_Sort(int *A,int p,int r)  //递归分治排序
{
	int q = (int)((r+p)/2);
	if ( p < r)
	{
		Merge_Sort(A,p,q);         //左边
		Merge_Sort(A,q+1,r);       //右边
        Merge(A,p,q,r);            
	}
}
```





