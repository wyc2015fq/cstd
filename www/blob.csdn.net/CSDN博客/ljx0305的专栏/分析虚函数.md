# 分析虚函数 - ljx0305的专栏 - CSDN博客
2008年07月31日 09:48:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：549标签：[assembly																[编译器																[delete																[汇编																[class](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=汇编&t=blog)](https://so.csdn.net/so/search/s.do?q=delete&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=assembly&t=blog)
个人分类：[C++](https://blog.csdn.net/ljx0305/article/category/380566)
                 其实虚函数在编译器中的实现是非常简单的，直接翻vc2005编译出来的汇编便可以知道。 
比如下个程序： 
- C/C++ code 
#include <iostream>usingnamespace std;
class ABC
{
public:
    virtualvoid a(){ cout<<"ABC::a"<<endl;}
    virtualvoid b(){ cout<<"ABC::b"<<endl;}
};
class CDE
{
public:
    virtualvoid a(){ cout<<"CDE::a"<<endl;}
    virtualvoid b(){cout<<"CDE::b"<<endl;}
};
int main()
{
    CDE *p =new CDE;
    ABC *q = (ABC*)p;
    p->a();
    p->b();
    delete p;
    return0;
}
p->a() 
p->b()所对应的源代码是： 
- Assembly code 
    p->a();
00411573mov         eax,dword ptr [p] ;p开始的四个字节是存放虚函数表地址00411576mov         edx,dword ptr [eax] ;edx中存放虚函数表的第一项地址，就是a的地址00411578mov         esi,esp ;debug用，不管它0041157Amov         ecx,dword ptr [p] ;this指针放入ecx，作为参数传给成员函数0041157Dmov         eax,dword ptr [edx] ;将edx所指向的函数地址移动入eax0041157Fcall        eax  ;调用函数00411581cmp         esi,esp ;debug用的00411583call        @ILT+440(__RTC_CheckEsp) (4111BDh) 
    p->b();
00411588mov         eax,dword ptr [p] 
0041158Bmov         edx,dword ptr [eax] 
0041158Dmov         esi,esp           ;debug用0041158Fmov         ecx,dword ptr [p] ;this指针放入ecx，作为参数传给成员函数00411592mov         eax,dword ptr [edx+4] ;b是第二个声明的虚函数，因此相应的在虚函数表中[edx+4]是b的函数地址00411595call        eax  
00411597cmp         esi,esp 
00411599call        @ILT+440(__RTC_CheckEsp) (4111BDh) 
编译的时候便已经为每个类确定好了虚函数表，并且将其地址放在类的开头4个字节。 
因此，所谓的调用虚函数的开销即是指多了两次访问内存的操作：一次是访问虚函数表，第二次是从虚汗数表中得到实际函数的地址。 
