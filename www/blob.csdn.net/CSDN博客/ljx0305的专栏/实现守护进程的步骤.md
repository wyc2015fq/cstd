# 实现守护进程的步骤 - ljx0305的专栏 - CSDN博客
2009年04月04日 17:01:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：1065

调用进程的会话ID
−1
是
setsid函数将创建新的会话，并使得调用 setsid函数的进程成为新会话的领头进程。调用setsid函数的进程是新创建会话中的惟一的进程组，进程组ID为调用进程的进程号。setsid函数产生这一结果还有个条件，即调用进程不为一个进程的领头进程。由于在第一步中调用fork的父进程退出，使得子进程不可能是进程组的领头进程。该会话的领头进程没有控制终端与其相连。至此，满足了守护进程没有控制终端的要求。
#### 3．更改当前工作目录
使用fork函数产生的子进程将继承父进程的当前工作目录。当进程没有结束时，其工作目录是不能被卸载的。为了防止这种问题发生，守护进程一般会将其工作目录更改到根目录下（/目录）。更改工作目录使用的函数是chdir。
#### 4．关闭文件描述符，并重定向标准输入、输出和错误输出
新产生的进程从父进程继承了某些打开的文件描述符，如果不使用这些文件描述符，则需要关闭它们。守护进程是运行在系统后台的，不应该在终端有任何的输出信息。可以使用dup函数将标准输入、输出和错误输出重定向到/dev/null设备上（/dev/null是一个空设备，向其写入数据不会有任何输出）。下面给出具体的代码：
…
      int fd;
      //将标准输入输出重定向到空设备
      fd = open ("/dev/null", O_RDWR, 0);
      if (fd != -1)
    {
      dup2 (fd, STDIN_FILENO);
      dup2 (fd, STDOUT_FILENO);
      dup2 (fd, STDERR_FILENO);
      if (fd > 2)
        close (fd);
    }
…
#### 5．设置守护进程的文件权限创建掩码
很多情况下，守护进程会创建一些临时文件。出于安全性的考虑，往往不希望这些文件被别的用户查看。这时，可以使用umask函数修改文件权限，创建掩码的取值，以满足守护进程的要求。
### 8.2.2  守护进程具体实现
本节给出一个守护进程创建的实例。程序p8.1.c中定义了daemon函数，用于实现对守护进程的创建。其创建思想在8.2.1中有详细的介绍，程序的具体代码如下：
//p8.1.c 守护进程的实现
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
/* daemon函数用于将调用函数的进程转化为守护进程 */
int
daemon (int nochdir, int noclose)
{
  pid_t pid;
  pid = fork ();
  /* 如果创建进程失败 */
  if (pid < 0)
    {
      perror ("fork");
      return -1;
    }
  /* 父进程退出运行 */
  if (pid != 0)
    exit (0);
  /* 成为会话领头进程 */
  pid = setsid();
  if (pid < -1)
    {
      perror ("setsid");
      return -1;
    }
  /* 将工作目录修改成根目录 */
  if (! nochdir)
    chdir ("/");
  /* 将标准输入输出重定向到空设备 */
  if (! noclose)
    {
      int fd;
      fd = open ("/dev/null", O_RDWR, 0);
      if (fd != -1)
    {
      dup2 (fd, STDIN_FILENO);
      dup2 (fd, STDOUT_FILENO);
      dup2 (fd, STDERR_FILENO);
      if (fd > 2)
        close (fd);
    }
    }
  umask (0027);
  return 0;
}
int main(void)
{
      daemon(0,0);
      sleep(1000);
      return 0;
}   
使用gcc编译p8.1.c，得到名为p8.1的可执行文件。执行该程序，程序将以守护进程的状态运行，如图8.4所示。
![](http://book.csdn.net/BookFiles/545/img/image033.jpg)
图8.4  守护进程的实现
引用:http://blog.chinaunix.net/u2/62678/showart_516000.html
