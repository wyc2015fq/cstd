# 函数调用堆栈分析 - ljx0305的专栏 - CSDN博客
2009年02月20日 22:15:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：1228标签：[编译器																[存储																[语言																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=语言&t=blog)](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)
个人分类：[C++																[C](https://blog.csdn.net/ljx0305/article/category/394717)](https://blog.csdn.net/ljx0305/article/category/380566)
原文链接：[http://blog.csdn.net/liigo/archive/2006/12/23/1456938.aspx](http://blog.csdn.net/liigo/archive/2006/12/23/1456938.aspx)
转载请注明出处：[http://blog.csdn.net/liigo](http://blog.csdn.net/liigo)
昨天和[海洋](http://blog.csdn.net/uoyevoli/)一块研究了下函数调用栈，顺便写两句。不足或错误之处请包涵！
理解调用栈最重要的两点是：栈的结构，EBP寄存器的作用。
首先要认识到这样两个事实：
1、一个函数调用动作可分解为：零到多个PUSH指令（用于参数入栈），一个CALL指令。CALL指令内部其实还暗含了一个将返回地址（即CALL指令下一条指令的地址）压栈的动作。
2、几乎所有本地编译器都会在每个函数体之前插入类似如下指令：PUSH EBP; MOV EBP ESP;
即，在程序执行到一个函数的真正函数体时，已经有以下数据顺序入栈：参数，返回地址，EBP。
由此得到类似如下的栈结构（参数入栈顺序跟调用方式有关，这里以C语言默认的CDECL为例）：
+| (栈底方向，高位地址) |
 | .................... |
 | .................... |
 | 参数3                |
 | 参数2                |
 | 参数1                |
 | 返回地址             |
-| 上一层[EBP]          | <-------- [EBP]
“PUSH EBP”“MOV EBP ESP”这两条指令实在大有深意：首先将EBP入栈，然后将栈顶指针ESP赋值给EBP。“MOV EBP ESP”这条指令表面上看是用ESP把EBP原来的值覆盖了，其实不然——因为给EBP赋值之前，原EBP值已经被压栈（位于栈顶），而新的EBP又恰恰指向栈顶。
此时EBP寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原EBP入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的EBP值！
一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层EBP值。
由于EBP中的地址处总是“上一层函数调用时的EBP值”，而在每一层函数调用中，都能通过当时的EBP值“向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值”。
如此形成递归，直至到达栈底。这就是函数调用栈。
编译器对EBP的使用实在太精妙了。
从当前EBP出发，逐层向上找到所有的EBP是非常容易的：
unsigned int _ebp;
__asm _ebp, ebp;
while (not stack bottom)
{
    //...
    _ebp = *(unsigned int*)_ebp;
}
如果要写一个简单的调试器的话，注意需在被调试进程（而非当前进程——调试器进程）中读取内存数据
引用:http://blog.csdn.net/adcxf/archive/2009/01/16/3794138.aspx
