# 重载、覆盖、多态与函数隐藏 - ljx0305的专栏 - CSDN博客
2008年05月05日 19:27:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：884标签：[fun																[iostream																[basic																[parameters																[class																[delete](https://so.csdn.net/so/search/s.do?q=delete&t=blog)](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=parameters&t=blog)](https://so.csdn.net/so/search/s.do?q=basic&t=blog)](https://so.csdn.net/so/search/s.do?q=iostream&t=blog)](https://so.csdn.net/so/search/s.do?q=fun&t=blog)
个人分类：[C++](https://blog.csdn.net/ljx0305/article/category/380566)
重载、覆盖、多态与函数隐藏
经常看到C++的一些初学者对于重载、覆盖、多态与函数隐藏的模糊理解。在这里写一点自己的见解，希望能够C++初学者解惑。
要弄清楚重载、覆盖、多态与函数隐藏之间的复杂且微妙关系之前，我们首先要来回顾一下重载覆盖等基本概念。
首先，我们来看一个非常简单的例子，理解一下什么叫函数隐藏hide。
#include <iostream>
using namespace std;
class Base{
public:
    void fun() { cout << "Base::fun()" << endl; }
};
class Derive : public Base{
public:
    void fun(**int i**) { cout << "Derive::fun()" << endl; }
};
int main()
{
    Derive d;
         //下面一句错误，故屏蔽掉
//d.fun();error C2660: 'fun' : function does not take 0 parameters
    d.fun(1);
         Derive *pd =new Derive();
         //下面一句错误，故屏蔽掉
//pd->fun();error C2660: 'fun' : function does not take 0 parameters
         pd->fun(1);
         delete pd;
    return 0;
}
/*在不同的非命名空间作用域里的函数不构成重载,子类和父类是不同的两个作用域。
在本例中,两个函数在不同作用域中,故不够成重载,除非这个作用域是命名空间作用域。*/
在这个例子中，函数不是重载overload，也不是覆盖override，而是隐藏hide。
接下来的5个例子具体说明一下什么叫隐藏
例1
#include <iostream>
using namespace std;
class Basic{
public:
         void fun(){cout << "Base::fun()" << endl;}//overload
         void fun(int i){cout << "Base::fun(int i)" << endl;}//overload
};
class Derive :public Basic{
public:
         void fun**2**(){cout << "Derive::fun2()" << endl;}
};
int main()
{
         Derive d;
         d.fun();//正确，派生类没有与基类同名函数声明，则基类中的所有同名重载函数都会作为候选函数。
         d.fun(1);//正确，派生类没有与基类同名函数声明，则基类中的所有同名重载函数都会作为候选函数。
         return 0;
}
例2
#include <iostream>
using namespace std;
class Basic{
public:
         void fun(){cout << "Base::fun()" << endl;}//overload
         void fun(int i){cout << "Base::fun(int i)" << endl;}//overload
};
class Derive :public Basic{
public:
         //新的函数版本,基类所有的重载版本都被屏蔽,在这里,我们称之为函数隐藏hide
    //派生类中有基类的同名函数的声明，则基类中的同名函数不会作为候选函数，即使基类有不同的参数表的多个版本的重载函数。
         void fun(**int i,int j**){cout << "Derive::fun(int i,int j)" << endl;}
         void fun2(){cout << "Derive::fun2()" << endl;}
};
int main()
{
         Derive d;
         d.fun(1,2);
         //下面一句错误，故屏蔽掉
//d.fun();error C2660: 'fun' : function does not take 0 parameters
         return 0;
}
例3
#include <iostream>
using namespace std;
class Basic{
public:
         void fun(){cout << "Base::fun()" << endl;}//overload
         void fun(int i){cout << "Base::fun(int i)" << endl;}//overload
};
class Derive :public Basic{
public:
         //覆盖override基类的其中一个函数版本,同样基类所有的重载版本都被隐藏hide
    //派生类中有基类的同名函数的声明，则基类中的同名函数不会作为候选函数，即使基类有不同的参数表的多个版本的重载函数。
         void **fun()**{cout << "Derive::fun()" << endl;}
         void fun2(){cout << "Derive::fun2()" << endl;}
};
int main()
{
         Derive d;
         d.fun();
         //下面一句错误，故屏蔽掉
         //d.fun(1);error C2660: 'fun' : function does not take 1 parameters
         return 0;
}
例4
#include <iostream>
using namespace std;
class Basic{
public:
         void fun(){cout << "Base::fun()" << endl;}//overload
         void fun(int i){cout << "Base::fun(int i)" << endl;}//overload
};
class Derive :public Basic{
public:
**using Basic::fun;**
         void **fun()**{cout << "Derive::fun()" << endl;}
         void fun2(){cout << "Derive::fun2()" << endl;}
};
int main()
{
         Derive d;
         d.fun();//正确
         d.fun(1);//正确
         return 0;
}
/*
输出结果
Derive::fun()
Base::fun(int i)
Press any key to continue
*/
例5
#include <iostream>
using namespace std;
class Basic{
public:
         void fun(){cout << "Base::fun()" << endl;}//overload
         void fun(int i){cout << "Base::fun(int i)" << endl;}//overload
};
class Derive :public Basic{
public:
**using Basic::fun;**
         void fun(**int i,int j**){cout << "Derive::fun(int i,int j)" << endl;}
         void fun2(){cout << "Derive::fun2()" << endl;}
};
int main()
{
         Derive d;
         d.fun();//正确
         d.fun(1);//正确
         d.fun(1,2);//正确
         return 0;
}
/*
输出结果
Base::fun()
Base::fun(int i)
Derive::fun(int i,int j)
Press any key to continue
*/
好了，我们先来一个小小的总结重载与覆盖两者之间的特征
重载overload的特征：
n相同的范围(在同一个类中)；
n函数名相同参数不同；
nvirtual 关键字可有可无。
覆盖override是指派生类函数覆盖基类函数，覆盖的特征是：
n不同的范围(分别位于派生类与基类)；
n函数名和参数都相同；
n基类函数必须有virtual 关键字。(若没有virtual 关键字则称之为隐藏hide)
如果基类有某个函数的多个重载(overload)版本，而你在派生类中重写(override)了基类中的一个或多个函数版本，或是在派生类中重新添加了新的函数版本(函数名相同，参数不同)，则所有基类的重载版本都被屏蔽，在这里我们称之为隐藏hide。所以，在一般情况下，你想在派生类中使用新的函数版本又想使用基类的函数版本时，你应该在派生类中重写基类中的所有重载版本。你若是不想重写基类的重载的函数版本，则你应该使用例4或例5方式，显式声明基类名字空间作用域。
事实上，C++编译器认为，相同函数名不同参数的函数之间根本没有什么关系，它们根本就是两个毫不相关的函数。只是C++语言为了模拟现实世界，为了让程序员更直观的思维处理现实世界中的问题，才引入了重载和覆盖的概念。重载是在相同名字空间作用域下，而覆盖则是在不同的名字空间作用域下，比如基类和派生类即为两个不同的名字空间作用域。在继承过程中，若发生派生类与基类函数同名问题时，便会发生基类函数的隐藏。当然，这里讨论的情况是基类函数前面没有virtual 关键字。在有virtual 关键字关键字时的情形我们另做讨论。
继承类重写了基类的某一函数版本，以产生自己功能的接口。此时C++编绎器认为，你现在既然要使用派生类的自己重新改写的接口，那我基类的接口就不提供给你了(当然你可以用显式声明名字空间作用域的方法，见[C++基础]重载、覆盖、多态与函数隐藏(1))。而不会理会你基类的接口是有重载特性的。若是你要在派生类里继续保持重载的特性，那你就自己再给出接口重载的特性吧。所以在派生类里，只要函数名一样，基类的函数版本就会被无情地屏蔽。在编绎器中，屏蔽是通过名字空间作用域实现的。
所以，在派生类中要保持基类的函数重载版本，就应该重写所有基类的重载版本。重载只在当前类中有效，继承会失去函数重载的特性。也就是说，要把基类的重载函数放在继承的派生类里，就必须重写。
这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，具体规则我们也来做一小结：
n如果派生类的函数与基类的函数同名，但是参数不同。此时，若基类无virtual关键字，基类的函数将被隐藏。(注意别与重载混淆，虽然函数名相同参数不同应称之为重载，但这里不能理解为重载，因为派生类和基类不在同一名字空间作用域内。这里理解为隐藏)
n如果派生类的函数与基类的函数同名，但是参数不同。此时，若基类有virtual关键字，基类的函数将被隐式继承到派生类的vtable中。此时派生类vtable中的函数指向基类版本的函数地址。同时这个新的函数版本添加到派生类中，作为派生类的重载版本。但在基类指针实现多态调用函数方法时，这个新的派生类函数版本将会被隐藏。
n如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。(注意别与覆盖混淆，这里理解为隐藏)。
n如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数有virtual关键字。此时，基类的函数不会被“隐藏”。(在这里，你要理解为覆盖哦^_^)。
插曲：基类函数前没有virtual关键字时，我们要重写更为顺口些，在有virtual关键字时，我们叫覆盖更为合理些，戒此，我也希望大家能够更好的理解C++中一些微妙的东西。费话少说，我们举例说明吧。
例6
#include <iostream>
using namespace std;
class Base{
public:
**virtual** void fun() { cout << "Base::fun()" << endl; }//**overload**
**virtual** void fun(int i) { cout << "Base::fun(int i)" << endl; }//**overload**
};
class Derive : public Base{
public:
         void fun() { cout << "Derive::fun()" << endl; }**//override**
 void fun(int i) { cout << "Derive::fun(int i)" << endl; }**//override**
**         void fun(int i,int j){ cout<< "Derive::fun(int i,int j)" <<endl;}//overload**
};
int main()
{
**Base** *pb = new Derive();
 pb->fun();
 pb->fun(1);
 //下面一句错误，故屏蔽掉
 //pb->fun(1,2);virtual函数不能进行overload,error C2661: 'fun' : no overloaded function takes 2 parameters
 cout << endl;
**Derive** *pd = new Derive();
 pd->fun();
 pd->fun(1);
 pd->fun(1,2);//overload
 delete pb;
 delete pd;
 return 0;
}
/*
输出结果
Derive::fun()
Derive::fun(int i)
Derive::fun()
Derive::fun(int i)
Derive::fun(int i,int j)
Press any key to continue
*/
例7-1
#include <iostream> 
using namespace std;
class Base{
public:
**virtual** void fun(**int i**){ cout <<"Base::fun(int i)"<< endl; }
};
**class Derive : public Base{};**
int main()
{
         Base *pb = new Derive();
         pb->fun(1);//**Base::fun(int i)**
         delete pb;
         return 0;
}
例7-2
#include <iostream> 
using namespace std;
class Base{
public:
**virtual** void fun(**int****i**){ cout <<"Base::fun(int i)"<< endl; }
};
class Derive : public Base{
public:
    void fun(**double d**){ cout <<"Derive::fun(double d)"<< endl; } 
};
int main()
{
         Base *pb = new Derive();
         pb->fun(1);//**Base::fun(int i)**
         pb->fun((double)0.01);//**Base::fun(int i)**
         delete pb;
         return 0;
}
例8-1
#include <iostream> 
using namespace std;
class Base{
public:
**virtual** void fun(int i){ cout <<"Base::fun(int i)"<< endl; }
};
class Derive : public Base{
public:
**         void fun(int i){ cout <<"Derive::fun(int i)"<< endl; }**
};
int main()
{
         Base *pb = new Derive();
         pb->fun(1);//**Derive::fun(int i)**
         delete pb;
         return 0;
}
例8-2
#include <iostream> 
using namespace std;
class Base{
public:
**virtual** void fun(int i){ cout <<"Base::fun(int i)"<< endl; }
};
class Derive : public Base{
public:
**void fun(int i){ cout <<"Derive::fun(int i)"<< endl; }**
         void fun(**double****d**){ cout <<"Derive::fun(double d)"<< endl; }         
};
int main()
{
         Base *pb = new Derive();
         pb->fun(1);//**Derive::fun(int i)**
         pb->fun((double)0.01);//**Derive::fun(int i)**
         delete pb;
         return 0;
}
例9
#include <iostream> 
using namespace std;
class Base{
public:
**virtual** void fun(int i){ cout <<"Base::fun(int i)"<< endl; }
};
class Derive : public Base{
public:
        void fun(int i){ cout <<"Derive::fun(int i)"<< endl; }
        void fun(char c){ cout <<"Derive::fun(char c)"<< endl; } 
        void fun(double d){ cout <<"Derive::fun(double d)"<< endl; }         
};
int main()
{
         Base *pb = new Derive();
         pb->fun(1);//**Derive::fun(int i)**
         pb->fun('a');//**Derive::fun(int i)**
         pb->fun((double)0.01);//**Derive::fun(int i)**
         Derive *pd =new Derive();
pd->fun(1);//**Derive::fun(int i)**
**         //overload**
         pd->fun('a');//**Derive::fun(char c)          **
**         //overload**
         pd->fun(0.01);//**Derive::fun(double d)          **
         delete pb;
         delete pd;
         return 0;
}
例7-1和例8-1很好理解，我把这两个例子放在这里，是让大家作一个比较摆了，也是为了帮助大家更好的理解：本例的效果同例6，异曲同工。想必你理解了上面的这些例子后，这个也是小Kiss了。
n例7-1中，派生类没有覆盖基类的虚函数，此时派生类的vtable中的函数指针指向的地址就是基类的虚函数地址。
n例8-1中，派生类覆盖了基类的虚函数，此时派生类的vtable中的函数指针指向的地址就是派生类自己的重写的虚函数地址。
在例7-2和8-2看起来有点怪怪，其实，你按照上面的原则对比一下，答案也是明朗的：
n例7-2中，我们为派生类重载了一个函数版本：void fun(**double d**)其实，这只是一个障眼法。我们具体来分析一下，基类共有几个函数，派生类共有几个函数：
|类型|基类|派生类|
|----|----|----|
|Vtable部分|void fun(**int****i**)|指向基类版的虚函数void fun(**int****i**)|
|静态部分||void fun(**double d**)|
我们再来分析一下以下三句代码
Base *pb = new Derive();
pb->fun(1);//**Base::fun(int i)**
pb->fun((double)0.01);//**Base::fun(int i)**
这第一句是关键，基类指针指向派生类的对象，我们知道这是多态调用；接下来第二句，运行时基类指针根据运行时对象的类型，发现是派生类对象，所以首先到派生类的vtable中去查找派生类的虚函数版本，发现派生类没有覆盖基类的虚函数，派生类的vtable只是作了一个指向基类虚函数地址的一个指向，所以理所当然地去调用基类版本的虚函数。最后一句，程序运行仍然埋头去找派生类的vtable，发现根本没有这个版本的虚函数，只好回头调用自己的仅有一个虚函数。
这里还值得一提的是：如果此时基类有多个虚函数，此时程序编绎时会提示”调用不明确”。示例如下
#include <iostream> 
using namespace std;
class Base{
public:
         virtual void fun(int i){ cout <<"Base::fun(int i)"<< endl; }
                    virtual void fun(char c){ cout <<"Base::fun(char c)"<< endl; }
};
class Derive : public Base{
public:
    void fun(double d){ cout <<"Derive::fun(double d)"<< endl; } 
};
int main()
{
         Base *pb = new Derive();
                    pb->fun(0.01);//error C2668: 'fun' : ambiguous call to overloaded function
         delete pb;
         return 0;
}
好了，我们再来分析一下例8-2。
n例8-2中，我们也为派生类重载了一个函数版本：void fun(**double d**)，同时覆盖了基类的虚函数，我们再来具体来分析一下，基类共有几个函数，派生类共有几个函数：
|类型|基类|派生类|
|----|----|----|
|Vtable部分|void fun(**int****i**)|void fun(**int****i**)|
|静态部分||void fun(**double d**)|
从表中我们可以看到，派生类的vtable中函数指针指向的是自己的重写的虚函数地址。
我们再来分析一下以下三句代码
Base *pb = new Derive();
pb->fun(1);//**Derive::fun(int i)**
pb->fun((double)0.01);//**Derive::fun(int i)**
第一句不必多说了，第二句，理所当然调用派生类的虚函数版本，第三句，嘿，感觉又怪怪的，其实呀，C++程序很笨的了，在运行时，埋头闯进派生类的vtable表中，只眼一看，靠，竞然没有想要的版本，真是想不通，基类指针为什么不四处转转再找找呢?呵呵，原来是眼力有限，基类年纪这么老了，想必肯定是老花了，它那双眼睛看得到的仅是自己的非Vtable部分(即静态部分)和自己要管理的Vtable部分，派生类的void fun(**double d**)那么远，看不到呀!再说了，派生类什么都要管，难道派生类没有自己的一点权力吗?哎，不吵了，各自管自己的吧^_^
唉!你是不是要叹气了，基类指针能进行多态调用，但是始终不能进行派生类的重载调用啊(参考例6)~~~
再来看看例9，
小结：
重载**overload**是根据函数的参数列表来选择要调用的函数版本，而多态是根据运行时对象的实际类型来选择要调用的虚**virtual**函数版本，多态的实现是通过派生类对基类的虚**virtual**函数进行覆盖**override**来实现的，若派生类没有对基类的虚**virtual**函数进行覆盖**override**的话，则派生类会自动继承基类的虚**virtual**函数版本，此时无论基类指针指向的对象是基类型还是派生类型，都会调用基类版本的虚**virtual**函数；如果派生类对基类的虚**virtual**函数进行覆盖**override**的话，则会在运行时根据对象的实际类型来选择要调用的虚**virtual**函数版本，例如基类指针指向的对象类型为派生类型，则会调用派生类的虚**virtual**函数版本，从而实现多态。
使用多态的本意是要我们在基类中声明函数为**virtual**，并且是要在派生类中覆盖**override**基类的虚**virtual**函数版本，注意，此时的函数原型与基类保持一致，即同名同参数类型；如果你在派生类中新添加函数版本，你不能通过基类指针动态调用派生类的新的函数版本，这个新的函数版本只作为派生类的一个重载版本。还是同一句话，重载只有在当前类中有效，不管你是在基类重载的，还是在派生类中重载的，两者互不牵连。如果明白这一点的话，在例6、例9中，我们也会对其的输出结果顺利地理解。
重载是静态联编的，多态是动态联编的。进一步解释，重载与指针实际指向的对象类型无关，多态与指针实际指向的对象类型相关。若基类的指针调用派生类的重载版本，C++编绎认为是非法的，C++编绎器只认为基类指针只能调用基类的重载版本，重载只在当前类的名字空间作用域内有效，继承会失去重载的特性，当然，若此时的基类指针调用的是一个虚**virtual**函数，那么它还会进行动态选择基类的虚**virtual**函数版本还是派生类的虚**virtual**函数版本来进行具体的操作，这是通过基类指针实际指向的对象类型来做决定的，所以说重载与指针实际指向的对象类型无关，多态与指针实际指向的对象类型相关。
最后阐明一点，虚**virtual**函数同样可以进行重载，但是重载只能是在当前自己名字空间作用域内有效(请再次参考例6)。
 转自[http://blog.csdn.net/callzjy/archive/2004/01/04/20041.aspx](http://blog.csdn.net/callzjy/archive/2004/01/04/20041.aspx)
