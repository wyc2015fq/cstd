# 关于字节对齐的总结 - ljx0305的专栏 - CSDN博客
2011年05月04日 14:45:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：804标签：[float																[class																[存储](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=class&t=blog)](https://so.csdn.net/so/search/s.do?q=float&t=blog)
个人分类：[C++																[C](https://blog.csdn.net/ljx0305/article/category/394717)](https://blog.csdn.net/ljx0305/article/category/380566)
1、使用默认的字节对齐方式。
 规则1：各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。
注： 下面列出常用类型的对齐方式(vc6.0, 32位系统)。 
 类型  对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
 Char  偏移量必须为sizeof(char)即1的倍数 
 int  偏移量必须为sizeof(int)即4的倍数 
 float  偏移量必须为sizeof(float)即4的倍数 
 double  偏移量必须为sizeof(double)即8的倍数 
 Short   偏移量必须为sizeof(short)即2的倍数 
 规则2： 结构的总大小为结构的字节边界数（即该结构中占用最大空间的变量的类型所占用的字节数）的倍数。
2、使用自定义的字节对齐方式(即，使用“#pragma pack(n)”来设定变量以n字节对齐方式)。
 规则3：如果n大于等于当前变量的类型所占用的字节数，那么偏移量必须满足此变量默认的对齐方式（参照规则1）；如果n小于当前变量的类型所占用的字节数，那么偏移量为n的倍数，不用使用默认的对齐方式。
 规则4：如果n大于等于结构中任何的类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量的类型所占用的字节数的倍数（参照规则2）；否则结构的总大小必须为n的倍数。
3、结构中带有结构
 规则5：不必考虑整个子结构，只考虑子结构的基本类型并参照前面的规则来分配空间。
 规则6：空结构（即不带任何的方法和数据）占用的1字节的空间。
4、枚举中（enum）
 规则7：枚举始终占用4字节的空间。
5、联合中（union）
 规则8：其占用的空间为其中最大成员所占用字节数，此外联合总的大小还要考虑“规则2”和“规则4”。
6、类中（class）
 规则9：空类（即不带任何的方法和数据）占用的1字节的空间。
 规则10：结构或者类中的静态成员和成员函数不对结构或者类的大小产生影响，因为静态变量和成员函数的存储位置与结构或者类的实例地址无关。
本文来自CSDN博客，转载请标明出处：[http://blog.csdn.net/crearo/archive/2008/12/26/3610943.aspx](http://blog.csdn.net/crearo/archive/2008/12/26/3610943.aspx)
