# 宏与内联函数(面试常考） - ljx0305的专栏 - CSDN博客
2008年06月01日 21:13:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：529标签：[面试																[编译器																[function																[优化																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=优化&t=blog)](https://so.csdn.net/so/search/s.do?q=function&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=面试&t=blog)
个人分类：[C++](https://blog.csdn.net/ljx0305/article/category/380566)
[宏与内联函数(面试常考）](http://blog.csdn.net/fisher_jiang/archive/2008/05/23/2472210.aspx)
第一部分：宏
为什么要使用宏呢？
因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。
而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。
但是宏也有很多的不尽人意的地方。
1、宏不能访问对象的私有成员。
2、宏的定义很容易产生二意性。
我们举个例子：
#define square(x) (x*x)
我们用一个数字去调用它,square(5)，这样看上去没有什么错误，结果返回25,是正确的，但是如果我们用squre (5+5)去调用的话，我们期望的结果是100，而宏的调用结果是(5+5*5+5),结果是35，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号。
#define square(x) ((x)*(x))
第二部分：内联函数
从上面的阐述，可以看到宏有一些难以避免的问题，怎么解决呢？
内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。
内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
声明内联函数看上去和普通函数非常相似：
void f(int i, char c);
当你定义一个内联函数时，在函数定义前加上 inline 关键字，并且将定义放入头文件：
inline void f(int i, char c)
{
// ...
}
**内联函数必须是和函数体申明在一起，才有效。**
像这样的申明inline function(int i)是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体。
inline int function(int i) {return i*i;}
这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。
当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
有上面的两者的特性，我们可以用内联函数完全取代预处理宏。
