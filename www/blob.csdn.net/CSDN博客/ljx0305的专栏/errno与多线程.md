# errno与多线程 - ljx0305的专栏 - CSDN博客
2012年12月28日 17:52:25[ljx0305](https://me.csdn.net/ljx0305)阅读数：3226
http://docs.sun.com/app/docs/doc/819-7051?l=zh《多线程编程指南》
一、摘自《APUE》
POSIX和ISO C将errno定义为这样一个符号，它扩展成为一个可修改的整型左值（lvalue）。这可以是包含出错编号的一个整数，或者是一个返回出错编号指针的函数。以前使用的定义是:
![](http://book.csdn.net/BookFiles/418/img/image020.jpg)
但是在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。例如，Linux支持多线程存取errno，将其定义为：
![](http://book.csdn.net/BookFiles/418/img/image021.jpg)
对于errno应当知道两条规则。第一条规则是：如果没有出错，则其值不会被一个例程清除。因此，仅当函数的返回值指明出错时，才检验其值。第二条是：任一函数都不会将errno 值设置为0，在<errno.h>中定义的所有常量都不为0。
二、**对于可重入、线程安全、异步信号安全几个概念的理解**
http://blog.chinaunix.net/u/12592/showart_1871048.html
可重入与异步信号安全
一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误。
《多线程编程指南》中定义，可以被信号控制器安全调用的函数被称为"异步信号安全"函数。
因此，我认为可重入与异步信号安全是一个概念。
有人将可重入函数与线程安全函数混为一谈，我认为是不正确的。
这里引用CSAPP中的描述来说明一下：
--------------------------------------------------
CSAPP
13.7.1 线程安全
一个函数被称为线程安全的，当且仅当被多个并发线程反复的调用时，它会一直产生正确的结果。
13.7.2 可重入性
有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有一种属性：当它们被多个线程调用时，不会引用任何共享的数据。
尽管线程安全和可重入有时会（不正确的）被用做同义词，但是它们之间还是有清晰的技术差别的。可重入函数是线程安全函数的一个真子集。
--------------------------------------------------
重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。
可重入函数是线程安全函数，但是反过来，线程安全函数未必是可重入函数。
实际上，可重入函数很少，APUE 10.6节中描述了Single UNIX Specification说明的可重入的函数，只有115个；APUE 12.5节中描述了POSIX.1中不能保证线程安全的函数，只有89个。
信
号就像硬件中断一样，会打断正在执行的指令序列。信号处理函数无法判断捕获到信号的时候，进程在何处运行。如果信号处理函数中的操作与打断的函数的操作相
同，而且这个操作中有静态数据结构等，当信号处理函数返回的时候（当然这里讨论的是信号处理函数可以返回），恢复原先的执行序列，可能会导致信号处理函数
中的操作覆盖了之前正常操作中的数据。
不可重入函数的原因在于：
1> 已知它们使用静态数据结构
2> 它们调用malloc和free.
因为malloc通常会为所分配的存储区维护一个链接表，而插入执行信号处理函数的时候，进程可能正在修改此链接表。
3> 它们是标准IO函数.
因为标准IO库的很多实现都使用了全局数据结构
即
使对于可重入函数，在信号处理函数中使用也需要注意一个问题就是errno。一个线程中只有一个errno变量，信号处理函数中使用的可重入函数也有可能
会修改errno。例如，read函数是可重入的，但是它也有可能会修改errno。因此，正确的做法是在信号处理函数开始，先保存errno；在信号处
理函数退出的时候，再恢复errno。
例如，程序正在调用printf输出，但是在调用printf时，出现了信号，对应的信号处理函数也有printf语句，就会导致两个printf的输出混杂在一起。
如果是给printf加锁的话，同样是上面的情况就会导致死锁。对于这种情况，采用的方法一般是在特定的区域屏蔽一定的信号。
屏蔽信号的方法：
1> signal(SIGPIPE, SIG_IGN); //忽略一些信号
2> sigprocmask()
sigprocmask只为单线程定义的
3> pthread_sigmask()
pthread_sigmasks可以在多线程中使用
现在看来信号异步安全和可重入的限制似乎是一样的，所以这里把它们等同看待 ![;-)](http://static.blogcn.com/wp-includes/images/smilies/icon_wink.gif)
线程安全
线程安全：如果一个函数在同一时刻可以被多个线程安全的调用，就称该函数是线程安全的。
不需要共享时，请为每个线程提供一个专用的数据副本。如果共享非常重要，则提供显式同步，以确保程序以确定的方式操作。通过将过程包含在语句中来锁定和解除锁定互斥，可以使不安全过程变成线程安全过程，而且可以进行串行化。
很多函数并不是线程安全的，因为他们返回的数据是存放在静态的内存缓冲区中的。通过修改接口，由调用者自行提供缓冲区就可以使这些函数变为线程安全的。
操作系统实现支持线程安全函数的时候，会对POSIX.1中的一些非线程安全的函数提供一些可替换的线程安全版本。
例如,gethostbyname()是线程不安全的，在Linux中提供了gethostbyname_r()的线程安全实现。
函数名字后面加上"_r"，以表明这个版本是可重入的（对于线程可重入，也就是说是线程安全的，但并不是说对于信号处理函数也是可重入的，或者是异步信号安全的）。
多线程程序中常见的疏忽性问题
1> 将指针作为新线程的参数传递给调用方栈。
2> 在没有同步机制保护的情况下访问全局内存的共享可更改状态。
3> 两个线程尝试轮流获取对同一对全局资源的权限时导致死锁。其中一个线程控制第一种资源，另一个线程控制第二种资源。其中一个线程放弃之前，任何一个线程都无法继续
操作。
4> 尝试重新获取已持有的锁（递归死锁）。
5> 在同步保护中创建隐藏的间隔。如果受保护的代码段包含的函数释放了同步机制，而又在返回调用方之前重新获取了该同步机制，则将在保护中出现此间隔。结果具有误导性。对于调用方，表面上看全局数据已受到保护，而实际上未受到保护。
6> 将UNIX 信号与线程混合时，使用sigwait(2) 模型来处理异步信号。
7> 调用setjmp(3C) 和longjmp(3C)，然后长时间跳跃，而不释放互斥锁。
8> 从对*_cond_wait() 或*_cond_timedwait() 的调用中返回后无法重新评估条件。
总结
判断一个函数是不是可重入函数，在于判断其能否可以被打断，打断后恢复运行能够得到正确的结果。（打断执行的指令序列并不改变函数的数据）
判断一个函数是不是线程安全的，在于判断其能否在多个线程同时执行其指令序列的时候，保证每个线程都能够得到正确的结果。
如果一个函数对多个线程来说是可重入的，则说这个函数是线程安全的，但这并不能说明对信号处理程序来说该函数也是可重入的。
如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是"异步-信号安全"的。
参考：
CSAPP
13.7.1 线程安全
13.7.2 可重入性
《Advanced Programming in the UNIX Environment》2nd Editon
10.6 Reentrant Function
12.5 Reentrant
《多线程编程指南》
信号处理程序和异步信号安全
http://blog.chinaunix.net/u/25994/showart_369466.html
三、**可重入函数与不可重入函数**
http://blog.chinaunix.net/u/25994/showart_369466.html
主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。
也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。
编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。
 说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。
示例：假设Exam是int型全局变量，函数Squre_Exam返回Exam平方值。那么如下函数不具有可重入性。
unsigned int example( int para )
{
    unsigned int temp;
        Exam = para; // （**）
        temp = Square_Exam( );
        return temp;
    }
    此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此函数时，将使Exam赋与另一个不同的para值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。
    unsigned int example( int para ) {
        unsigned int temp;
        [申请信号量操作] //(1)
        Exam = para;
        temp = Square_Exam( );
        [释放信号量操作]
        return temp;
    }
    (1)若申请不到“信号量”，说明另外的进程正处于给Exam赋值并计算其平方过程中（即正在使用此信号）,本进程必须等待其释放信号后，才可继续执行。若申请到信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。
    保证函数的可重入性的方法：
    在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量），对于要使用的全局变量要加以保护（如采取关中断、信号量等方法），这样构成的函数就一定是一个可重入的函数。
    VxWorks中采取的可重入的技术有：
    * 动态堆栈变量（各子函数有自己独立的堆栈空间）
    * 受保护的全局变量和静态变量
    * 任务变量
--------------------------------------------------
    在
实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果这个函数不幸被设计成为不可重入的函数的话，那么不同任务调用这个函数时可能修改其他任
务调用这个函数的数据，从而导致不可预料的后果。那么什么是可重入函数呢？所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是
否会出错。不可重入函数在实时系统设计中被视为不安全函数。满足下列条件的函数多数是不可重入的：
    1) 函数体内使用了静态的数据结构；
    2) 函数体内调用了malloc()或者free()函数；
    3) 函数体内调用了标准I/O函数。
    下面举例加以说明。
    A. 可重入函数
    void strcpy(char *lpszDest, char *lpszSrc)
 {
        while(*lpszDest++=*lpszSrc++);
        *dest=0;
    }
    B. 不可重入函数1
    charcTemp;//全局变量
    void SwapChar1(char *lpcX, char *lpcY)
 {
        cTemp=*lpcX;
        *lpcX=*lpcY;
        lpcY=cTemp;//访问了全局变量
    }
    C. 不可重入函数2
    void SwapChar2(char *lpcX,char *lpcY)
 {
        static char cTemp;//静态局部变量
        cTemp=*lpcX;
        *lpcX=*lpcY;
        lpcY=cTemp;//使用了静态局部变量
    }
    问题1，如何编写可重入的函数？
    答：在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。
    问题2，如何将一个不可重入的函数改写成可重入的函数？
    答：把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的。
    1) 不要使用全局变量。因为别的代码很可能覆盖这些变量值。
    2) 在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”。
    3) 不能调用其它任何不可重入的函数。
    4) 谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。
    堆栈操作涉及内存分配，稍不留神就会造成益出导致覆盖其他任务的数据，所以，请谨慎使用堆栈！最好别用！很多黑客程序就利用了这一点以便系统执行非法代码从而轻松获得系统控制权。还有一些规则，总之，时刻记住一句话：保证中断是安全的！
    实例问题：曾经设计过如下一个函数，在代码检视的时候被提醒有bug，因为这个函数是不可重入的，为什么？
    unsigned int sum_int( unsigned int base )
{
        unsigned int index;
        static unsigned int sum = 0; // 注意，是static类型
        for (index = 1; index <= base; index++)
            sum += index;
        return sum;
    }
    分析：所谓的函数是可重入的（也可以说是可预测的），即只要输入数据相同就应产生相同的输出。这个函数之所以是不可预测的，就是因为函数中使用了static变量，因为static变量的特征，这样的函数被称为：带“内部存储器”功能的的函数。因此如果需要一个可重入的函数，一定要避免函数中使用static变量，这种函数中的static变量，使用原则是，能不用尽量不用。
    将上面的函数修改为可重入的函数，只要将声明sum变量中的static关键字去掉，变量sum即变为一个auto类型的变量，函数即变为一个可重入的函数。
    当然，有些时候，在函数中是必须要使用static变量的，比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。
引用:http://francislee.blogcn.com/articles/%E7%BD%91%E6%91%98errno%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html
