# 限制程序只运行一次 - ljx0305的专栏 - CSDN博客
2008年03月11日 22:08:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：934
1.使用互斥量来限制程序只运行一次
BOOL CExecInApp::InitInstance()
{
	//deny	running application  second  
/*	AfxEnableControlContainer();
	::CreateMutex(NULL, TRUE, m_pszExeName); 
    if(ERROR_ALREADY_EXISTS == GetLastError()) 
    { 
		try{
			::SetForegroundWindow(::FindWindow(NULL, "Main"));
		}
		catch(...)
		{
				AfxMessageBox("Application Error!Please close it!");
		}
		return false;
	}
*/ 
	AfxEnableControlContainer();
	::CreateMutex(NULL, TRUE, m_pszExeName); 
	if(ERROR_ALREADY_EXISTS == GetLastError()) 
	{
       CWnd* pPrevHwnd = CWnd::GetDesktopWindow()->GetWindow(GW_CHILD); 
		//CWnd* pPrevHwnd = CWnd::FindWindow(NULL,m_pszExeName);
		//AfxMessageBox(m_pszExeName);
       while(pPrevHwnd) 
        { 
			//AfxMessageBox("4");
           if(::GetProp(pPrevHwnd->m_hWnd , m_pszExeName)) 
           { 
				AfxMessageBox("3");
                if(pPrevHwnd->IsIconic()) 
                { 
					AfxMessageBox("3");
                    pPrevHwnd->ShowWindow(SW_RESTORE); 
                } 
				//pPrevHwnd->ShowWindow(SW_RESTORE);
               pPrevHwnd->SetForegroundWindow(); 
               pPrevHwnd->GetLastActivePopup()->SetForegroundWindow(); 
                return FALSE; 
            } 
            pPrevHwnd = pPrevHwnd->GetWindow(GW_HWNDNEXT); 
        } 
        TRACE("Could not fond frevious instance main window !"); 
        return FALSE; 
	}
::CreateMutex(NULL, TRUE, m_pszExeName); 创建一个互坼量
2.使用信号量来限制程序只运行一次 
BOOL CTestApp::InitInstance()
{
 // 用应用程序名创建信号量 
 hSem = CreateSemaphore(NULL, 1, 1, m_pszExeName); 
 // 信号量已存在？ 
 // 信号量存在，则程序已有一个实例运行 
 if (GetLastError() == ERROR_ALREADY_EXISTS) 
 { 
  // 关闭信号量句柄 
  CloseHandle(hSem); 
  // 寻找先前实例的主窗口 
  HWND hWndPrevious = ::GetWindow(::GetDesktopWindow(),GW_CHILD); 
  while (::IsWindow(hWndPrevious)) 
  { 
   // 检查窗口是否有预设的标记? 
   // 有，则是我们寻找的主窗 
   if (::GetProp(hWndPrevious, m_pszExeName)) 
   { 
    // 主窗口已最小化，则恢复其大小 
    // if (::IsIconic(hWndPrevious)) 
    ::ShowWindow(hWndPrevious,SW_RESTORE); 
    // 将主窗激活 
    ::SetForegroundWindow(hWndPrevious); 
    // 将主窗的对话框激活 
    ::SetForegroundWindow(::GetLastActivePopup(hWndPrevious)); 
    // 退出本实例 
    return FALSE; 
   } 
   // 继续寻找下一个窗口 
   hWndPrevious = ::GetWindow(hWndPrevious,GW_HWNDNEXT);
  } 
  // 前一实例已存在，但找不到其主窗 
  // 可能出错了 
  // 退出本实例 
  return FALSE; 
 }
 AfxEnableControlContainer();
 // Standard initialization
 // If you are not using these features and wish to reduce the size
 //  of your final executable, you should remove from the following
 //  the specific initialization routines you do not need.
#ifdef _AFXDLL
 Enable3dControls();   // Call this when using MFC in a shared DLL
#else
 Enable3dControlsStatic(); // Call this when linking to MFC statically
#endif
 // Change the registry key under which our settings are stored.
 // TODO: You should modify this string to be something appropriate
 // such as the name of your company or organization.
 SetRegistryKey(_T("Local AppWizard-Generated Applications"));
 LoadStdProfileSettings();  // Load standard INI file options (including MRU)
 // Register the application's document templates.  Document templates
 //  serve as the connection between documents, frame windows and views.
 CSingleDocTemplate* pDocTemplate;
 pDocTemplate = new CSingleDocTemplate(
  IDR_MAINFRAME,
  RUNTIME_CLASS(CTestDoc),
  RUNTIME_CLASS(CMainFrame),       // main SDI frame window
  RUNTIME_CLASS(CTestView));
 AddDocTemplate(pDocTemplate);
 // Parse command line for standard shell commands, DDE, file open
 CCommandLineInfo cmdInfo;
 ParseCommandLine(cmdInfo);
 // Dispatch commands specified on the command line
 if (!ProcessShellCommand(cmdInfo))
  return FALSE;
 // The one and only window has been initialized, so show and update it.
 m_pMainWnd->ShowWindow(SW_SHOW);
 m_pMainWnd->UpdateWindow();
 return TRUE;
}
