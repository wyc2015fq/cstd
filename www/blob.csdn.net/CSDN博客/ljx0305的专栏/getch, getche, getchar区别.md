# getch, getche, getchar区别 - ljx0305的专栏 - CSDN博客
2009年02月20日 22:13:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：511

首先不要忘了，要用getch()必须引入头文件conio.h，以前学C语言的时候，我们总喜欢用在程序的末尾加上它，利用它来实现程序运行完了暂停不退出的效果。如果不加这句话，在TC2.0的环境中我们用Ctrl+F9编译并运行后，程序一运行完了就退回到TC环境中，我们根本来不及看到结果，这时要看结果，我们就要按Alt+F5回到DOS环境中去看结果，这很麻烦。而如果在程序的结尾加上一行getch();语句，我们就可以省掉会DOS看结果这个步骤，因为程序运行完了并不退出，而是在程序最后把屏幕停住了，按任意键才退回到TC环境中去。那我们来看看getch()到底起的什么作用，getch()实际是一个输入命令，就像我们用cin>>的时候程序会停下来等你输入，和cin不同的是，getch()的作用是从键盘接收一个字符，而且并不把这个字符显示出来，就是说，你按了一个键后它并不在屏幕上显示你按的什么，而继续运行后面的代码，所以我们在C++中可以用它来实现“按任意键继续”的效果，即程序中遇到getch();这行语句，它就会把程序暂停下来，等你按任意键，它接收了这个字符键后再继续执行后面的代码。
　　你也许会问，为什么我们在C++中就没有在程序的末尾加上getch()，解释是，软件总是不断更新的，不好的地方当然要进行改正，getch()加在程序末尾，它又不赋值给任何变量，所以它在这个地方完全是垃圾代码，与程序无关。C++中考虑到这一点，于是在每次程序运行完了并不退出，而是自动把屏幕停下来，并显示“press any key...”叫你按任意键退出，这就好比C++在它的环境中运行程序，在程序的末尾自动加上了一行getch();语句，并且在这行语句前还添加了一行输出语句cout<<"press any key...";来提示你程序结束了，按任意键继续。实际上我们编译好的程序在程序结束了本身是不会停下来的，我们可以在编译产生的Debug目录中找到这个编译好的应用程序（扩展名exe），在文件夹中双击运行它，你会发现屏幕闪了一下MS-DOS窗口就关闭了，因为程序运行完就自动退出了，回到了windows环境，当然，如果我们在DOS环境中运行这个程序，我们就可以直接在看到DOS屏幕上看到程序运行结果，因为程序运行完后并不清屏。
　　还有一个语句，和getch()很相似，getche()，它也需要引入头文件conio.h，那它们之间的区别又在哪里呢？不同之处就在于getch()无返回显示，getche()有返回显示。怎么说呢？我举个例子你就明白了。
--------------------------------------
#include<stdio.h>
#include<conio.h>
void main()
{
    char ch;
    for(int i=0;i<5;i++)
    {
        ch=getch();
        printf("%c",ch);
    }
}
--------------------------------------
　　这里输入输出我用的是C的函数库，没有用C++的iostream.h，这个我等会再说。首先这是个连续5次的循环来实现5次停顿，等待我们输入，我们编译并运行这个程序，假设我们分别输入abcde，屏幕上显示的结果是abcde，这个abcde并不是在ch=getch();中输出的，我们把printf("%c",ch);这行语句去掉，就会发现我们按5次任意键程序就结束了，但屏幕上什么都没有显示。
　　然后我们在把代码中的getch()换成getche()看看有什么不同，我们还是分别输入abcde，这时屏幕上显示的结果是aabbccddee，我们把printf("%c",ch);这行语句再去掉看看，显示的结果就是abcde了，说明程序在执行ch=getche();这条语句的时候就把我们输入的键返回显示在屏幕上，有无回显就是它们的唯一区别。
　　好了，我们再来说说为什么不用C++函数库的原因。你可以试试把这个程序改成C++的形式：
--------------------------------------
#include<iostream.h>
#include<conio.h>
void main()
{
    char ch;
    for(int i=0;i<5;i++)
    {
        ch=getch();
        cout<<ch;
    }
}
--------------------------------------
　　你会发现运行结果是完全不同的，说实话我也搞不清它是怎么编译运行的，以前我在C++中用它来实现任意键继续的功能就发现了这个问题。如果在getch();后面有个cout<<"……";语句的话他会先执行下面的cout<<"……";然后再执行getch();实现停顿，有时再两个语句中间加上一个cout<<endl;可以解决这个问题，但如果用C中的printf()就从没有出现过这种问题。至于到底是为什么，我也不知道，只能猜想，可能是因为getch()是C的函数库中的函数，在C++中不怎么好用，就是说是编译系统本身的问题，与我们写的程序没有关系。不知道我分析是不是正确的，还希望高手能予以指点，谢谢！![](http://writeblog.csdn.net/Emoticons/QQ/15.gif)
　　有人会说，既然是C的函数库中的，那么就应该淘汰了，我们还研究它，还用它干嘛？但是我发现还是有用着它的地方，否则我也不会在这里说这么多来耽误大家的时间。我就举个例子吧，程序如下：
--------------------------------------
#include<stdio.h>
#include<conio.h>
void main()
{
    char ch='*';
    while(ch=='*')
    {
        printf("/n按 * 继续循环，按其他键退出！");
        ch=getch();
    }
    printf("/n退出程序！");
}
--------------------------------------
我们可以在这个循环体中添加我们想要的功能，程序中按*继续循环，其他任意键退出，而且利用getch()无回显的特性，我们不管按什么，都不会在屏幕上留下痕迹，使我们的界面达到美观效果，如果还有更好的办法实现这个功能，我可能就不会在这里提这么多了。如果你真的有更好的办法，请一定告诉我，谢谢！![](http://writeblog.csdn.net/Emoticons/QQ/15.gif)
　　下面我把别人网页上的几个例子转载如下：
--------------------------------------
//例一：这个例子是为了说明getch()和getche()的区别
#include<stdio.h>
#include<conio.h>
//这里讲个小故事：因为这个代码是在别人网页上的，别人用的C环境，可能是不需要conio.h头文件
//就可以用getch();（我就不清楚了），也可能是忘了写，网页上的源代码没有#include<conio.h>这一行，
//我让老婆去看这个网页，老婆把网页上的代码复制到C++环境中，不能编译就跟我哭，
//呵呵，我可爱的傻老婆！
void main()
{ 
    char c, ch;
    c=getch();     /*从键盘上读入一个字符不回显送给字符变量c*/
    putchar(c);    /*输出该字符*/
    ch=getche();   /*从键盘上带回显的读入一个字符送给字符变量ch*/
    putchar(ch);
    printf("/n/n");
}
--------------------------------------
//例二：这个例子是演示交互输入的过程中完成暂停功能
#include<stdio.h>
#include<conio.h>
void main()
{
    char c, s[20];
    printf("Name:");
    gets(s);
    printf("Press any key to continue.../n/n");
    getch();  /*等待输入任一键*/
    printf("/n/n");
}
--------------------------------------
//例三：getchar()函数也是从键盘上读入一个字符，并带回显。它与前面两个函数的区别在于：
//　　　getchar()函数等待输入直到按回车才结束，回车前的所有输入字符都会逐个显示在屏幕上。
//　　　但只有第一个字符作为函数的返回值。
#include<stdio.h>
#include<conio.h>
void main()
{
    char c;
    c=getchar();   /*从键盘读入字符直到回车结束*/
//getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c
    putchar(c);    /*显示输入的第一个字符*/
    printf("/n/n");
}
--------------------------------------
//例四：呵呵，这个程序你运行一下，相信你又会有疑问了
#include<stdio.h>
#include<conio.h>
void main()
{
    char c;
    while ((c=getchar())!='/n')    /*每个getchar()依次读入一个字符*/
        printf("%c",c);        /*按照原样输出*/
    printf("/n/n");
}
--------------------------------------
　　例四的程序运行时，首先停下来，等你输入一串字符串，输入完毕后，它把你输入的整个字符串都输出来了，咦，你不是说getchar()只返回第一个字符么，这里怎么？
　　不要急，我慢慢跟你解释，忍耐一下，马上就讲完了。因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。例子中循环条件里的'/n'实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而getchar()函数就是等待输入直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如while ((c=getchar())!='a')，什么意思呢，意思就是遇到字符'a'就停止循环。
　　明白了吗？^_^  好了，休息会去吧，别老在电脑面前盯着。
引用:http://blog.csdn.net/adcxf/archive/2009/01/15/3785680.aspx
