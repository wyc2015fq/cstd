# 条件变量 - ljx0305的专栏 - CSDN博客
2008年08月04日 09:35:00[ljx0305](https://me.csdn.net/ljx0305)阅读数：3798
条件变量   
  条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。   
  1．   创建和注销   
  条件变量和互斥锁一样，都有静态动态两种创建方式，静态方式使用PTHREAD_COND_INITIALIZER常量，如下：     
  pthread_cond_t   cond=PTHREAD_COND_INITIALIZER     
  动态方式调用pthread_cond_init()函数，API定义如下：     
  int   pthread_cond_init(pthread_cond_t   *cond,   pthread_condattr_t   *cond_attr)     
  尽管POSIX标准中为条件变量定义了属性，但在LinuxThreads中没有实现，因此cond_attr值通常为NULL，且被忽略。   
  注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候才能注销这个条件变量，否则返回EBUSY。因为Linux实现的条件变量没有分配什么资源，所以注销动作只包括检查是否有等待线程。API定义如下：     
  int   pthread_cond_destroy(pthread_cond_t   *cond)     
  2．   等待和激发   
  int   pthread_cond_wait(pthread_cond_t   *cond,   pthread_mutex_t   *mutex)   
  int   pthread_cond_timedwait(pthread_cond_t   *cond,   pthread_mutex_t   *mutex,   const   struct   timespec   *abstime)     
  等待条件有两种方式：无条件等待pthread_cond_wait()和计时等待pthread_cond_timedwait()，其中计时等待方式如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，其中abstime以与time()系统调用相同意义的绝对时间形式出现，0表示格林尼治时间1970年1月1日0时0分0秒。   
  无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race   Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。   
  激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。   
  3．   其他   
  pthread_cond_wait()和pthread_cond_timedwait()都被实现为取消点，因此，在该处等待的线程将立即重新运行，在重新锁定mutex后离开pthread_cond_wait()，然后执行取消动作。也就是说如果pthread_cond_wait()被取消，mutex是保持锁定状态的，因而需要定义退出回调函数来为其解锁。   
  以下示例集中演示了互斥锁和条件变量的结合使用，以及取消对于条件等待动作的影响。在例子中，有两个线程被启动，并等待同一个条件变量，如果不使用退出回调函数（见范例中的注释部分），则tid2将在pthread_mutex_lock()处永久等待。如果使用回调函数，则tid2的条件等待及主线程的条件激发都能正常工作。   
  #include   <stdio.h>   
  #include   <pthread.h>   
  #include   <unistd.h>   
  pthread_mutex_t   mutex;   
  pthread_cond_t     cond;   
  void   *   child1(void   *arg)   
  {   
                  pthread_cleanup_push(pthread_mutex_unlock,&mutex);     /*   comment   1   */   
                  while(1){   
                                  printf("thread   1   get   running   /n");   
                  printf("thread   1   pthread_mutex_lock   returns   %d/n",   
  pthread_mutex_lock(&mutex));   
                  pthread_cond_wait(&cond,&mutex);   
                                          printf("thread   1   condition   applied/n");   
                  pthread_mutex_unlock(&mutex);   
                                          sleep(5);   
          }   
                  pthread_cleanup_pop(0);           /*   comment   2   */   
  }   
  void   *child2(void   *arg)   
  {   
                  while(1){   
                                  sleep(3);                               /*   comment   3   */   
                                  printf("thread   2   get   running./n");   
                  printf("thread   2   pthread_mutex_lock   returns   %d/n",   
  pthread_mutex_lock(&mutex));   
                  pthread_cond_wait(&cond,&mutex);   
                  printf("thread   2   condition   applied/n");   
                  pthread_mutex_unlock(&mutex);   
                  sleep(1);   
                  }   
  }   
  int   main(void)   
  {   
                  int   tid1,tid2;   
                  printf("hello,   condition   variable   test/n");   
                  pthread_mutex_init(&mutex,NULL);   
                  pthread_cond_init(&cond,NULL);   
                  pthread_create(&tid1,NULL,child1,NULL);   
                  pthread_create(&tid2,NULL,child2,NULL);   
                  do{   
                  sleep(2);                                       /*   comment   4   */   
                                  pthread_cancel(tid1);               /*   comment   5   */   
                                  sleep(2);                                       /*   comment   6   */   
                  pthread_cond_signal(&cond);   
          }while(1);       
                  sleep(100);   
                  pthread_exit(0);   
  }     
  如果不做注释5的pthread_cancel()动作，即使没有那些sleep()延时操作，child1和child2都能正常工作。注释3和注释4的延迟使得child1有时间完成取消动作，从而使child2能在child1退出之后进入请求锁操作。如果没有注释1和注释2的回调函数定义，系统将挂起在child2请求锁的地方；而如果同时也不做注释3和注释4的延时，child2能在child1完成取消动作以前得到控制，从而顺利执行申请锁的操作，但却可能挂起在pthread_cond_wait()中，因为其中也有申请mutex的操作。child1函数给出的是标准的条件变量的使用方式：回调函数保护，等待条件前锁定，pthread_cond_wait()返回后解锁。   
  条件变量机制不是异步信号安全的，也就是说，在信号处理函数中调用pthread_cond_signal()或者pthread_cond_broadcast()很可能引起死锁   
引用:http://topic.csdn.net/t/20060706/11/4863663.html
