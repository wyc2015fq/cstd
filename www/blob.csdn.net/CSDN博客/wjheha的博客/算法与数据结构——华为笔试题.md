# 算法与数据结构——华为笔试题 - wjheha的博客 - CSDN博客
2018年01月28日 21:47:34[wjheha](https://me.csdn.net/wjheha)阅读数：386
个人分类：[数据结构和算法](https://blog.csdn.net/wjheha/article/category/6854909)
## 算法题 16：两个大数相乘（华为面试）
**题目**：请使用代码计算 
1234567891011121314151617181920 * 2019181716151413121110987654321
##### *****************************************************************************************************************
## 算法题 31：1分2分5分组成1角的组合（华为）
**题目**：1分2分5分的硬币，组成1角，共有多少种组合
##### *****************************************************************************************************************
## 算法题 49：字符集合（华为笔试）
**题目**：输入一个字符串，求出该字符串包含的字符集合
**输入描述**: 
每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。
**输出描述**: 
每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。
**输入例子**: 
abcqweracb
**输出例子**: 
abcqwer
##### *****************************************************************************************************************
## 算法题 57：删数（华为笔试题）
**题目**：有一个整型数组a[n]顺序存放0 ~ n-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。
以8个数(n=8)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。
##### *****************************************************************************************************************
## 算法题 72：最高分是多少（华为笔试题）
老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。
**输入描述**: 
输入包括多组测试数据。 
每组输入第一行是两个正整数N和M（0 < N <= 30000,0 < M < 5000）,分别代表学生的数目和操作的数目。
学生ID编号从1编到N。 
第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩 
接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为’Q’的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少 
当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。
**输出描述**: 
对于每一次询问操作，在一行里面输出最高成绩.
**输入例子**: 
5 7 
1 2 3 4 5 
Q 1 5 
U 3 6 
Q 3 4 
Q 4 5 
U 4 5 
U 2 9 
Q 1 5
**输出例子**: 
5 
6 
5 
9
##### *****************************************************************************************************************
## 算法题 91：代码的调用次数（华为笔试题）
题目：下面哪个选项正确地描述了代码运行的调度次数？
```matlab
n=10; 
for(i=1; i <n; i++) 
  for(j=1; j <n; j+=n/2) 
    for(k=1; k <n; k=2*k)
    x = x +1;
```
A、 O(n^3) 
B、 O(n2logn) 
C 、O(n(log n)2) 
D、 O(n log n)  
E、 O((logn)2) 
##### *****************************************************************************************************************
## 算法题 96：数独（华为笔试题）
**题目**：数独是一个我们都非常熟悉的经典游戏，运用计算机我们可以很快地解开数独难题，现在有一些简单的数独题目，请编写一个程序求解。
**输入描述**: 
输入9行，每行为空格隔开的9个数字，为0的地方就是需要填充的。
**输出描述**: 
输出九行，每行九个空格隔开的数字，为解出的答案。
##### *****************************************************************************************************************
## 算法题 124：排序算法（华为笔试题）
**题目**：下面说法正确的是？（） 
A、归并排序的平均复杂性为O(N*log(N))。 
B、快速排序最坏情况下时间复杂度是O(N^2)。 
C、堆排序在最好最坏情况下时间复杂度都是O(N*log(N))。 
D、快速排序会比归并排序消耗更多的交换空间。
##### *****************************************************************************************************************
## 算法题 166：8分钟写出代码（华为笔试题）
**题目**：
有两个数组a，b，大小都为n，数组元素的值任意，无序；
要求：
通过交换a，b中的元素，使数组a元素的和与数组b元素的和之间的差最小。8分钟写出代码！
##### *****************************************************************************************************************
## 华为2014年四道笔试算法题
##### *****************************************************************************************************************
# #
### 1、通过键盘输入一串小写字母(a~z)组成的字符串。
请编写一个字符串过滤程序，若字符串中出现多个相同的字符，将非首次出现的字符过滤掉。
比如字符串“abacacde”过滤结果为“abcde”。 
要求实现函数：void stringFilter(const char *pInputStr, long lInputLen, char *pOutputStr); 
【输入】 pInputStr：  输入字符串 
lInputLen：  输入字符串长度 
【输出】 pOutputStr： 输出字符串，空间已经开辟好，与输入字符串等长；  
【注意】只需要完成该函数功能算法，中间不需要有任何IO的输入输出
示例 
输入：“deefd”        输出：“def” 
输入：“afafafaf”     输出：“af” 
输入：“pppppppp”     输出：“p”
main函数已经隐藏，这里保留给用户的测试入口，在这里测试你的实现函数，可以调用printf打印输出 
当前你可以使用其他方法测试，只要保证最终程序能正确执行即可，该函数实现可以任意修改，但是不要改变函数原型。
一定要保证编译运行不受影响
```
//////////////////////////////////////////////////////////////////////////华为第一题 19:19-19:36  17分钟       
 #include <iostream>       
 #include <cassert>       
 using namespace std;       
 bool g_flag[26];       
 void stringFilter(const char *pInputStr, long lInputLen, char *pOutputStr)       
 {       
   assert(pInputStr != NULL);       
   int i = 0;       
   if (pInputStr == NULL || lInputLen <= 1)       
   {       
       return;       
   }       
   const char *p = pInputStr;       
   while(*p != '\0')       
   {       
      if (g_flag[(*p - 'a')])       
      {       
          p++;       
      }else{       
          pOutputStr[i++] = *p;       
          g_flag[*p - 'a'] = 1;       
          p++;       
      }       
   }       
   pOutputStr[i] = '\0';       
 }       
 int main()       
 {       
     memset(g_flag,0,sizeof(g_flag));       
     char input[] = "abacacde";       
     char *output = new char[strlen(input) + 1];       
     stringFilter(input,strlen(input),output);       
     cout<<output<<endl;       
     delete output;       
     return 0;       
 }
```
### 2、通过键盘输入一串小写字母(a~z)组成的字符串。
请编写一个字符串压缩程序，将字符串中连续出席的重复字母进行压缩，并输出压缩后的字符串。
压缩规则：
1、仅压缩连续重复出现的字符。比如字符串”abcbc”由于无连续重复字符，压缩后的字符串还是”abcbc”。 
2、压缩字段的格式为”字符重复的次数+字符”。例如：字符串”xxxyyyyyyz”压缩后就成为”3x6yz”。
要求实现函数： 
void stringZip(const char *pInputStr, long lInputLen, char *pOutputStr); 
【输入】 pInputStr：  输入字符串 
 lInputLen：  输入字符串长度 
【输出】 pOutputStr： 输出字符串，空间已经开辟好，与输入字符串等长； 
【注意】只需要完成该函数功能算法，中间不需要有任何IO的输入输出
示例 
输入：“c 
ccddecc”   输出：“3c2de2c” 
输入：“adef”     输出：“adef” 
输入：“pppppppp” 输出：“8p”
```
//////////////////////////////////////////////////////////////////////////华为第二题 19:40 - 20:10 中间耽误3分钟       
 #include <iostream>       
 #include <cassert>       
 using namespace std;       
 void stringZip(const char *pInputStr, long lInputLen, char *pOutputStr)       
 {       
   const char *p = pInputStr;       
   int num = 1;       
   int i = 0;       
   p++;       
   while(*p != NULL)       
   {       
       while(*p == *(p-1)&& *p != NULL)       
       {       
        num++;       
        p++;       
       }       
       if (num > 1)       
       {       
            int size = 0;       
            int temp = num;       
            while(num)             //计算位数       
            {       
              size++;       
              num /= 10;       
            }       
            num = 1;       
            for (int j = size; j > 0; j--)       
            {       
                pOutputStr[i+j-1] = '0'+ temp%10;       
                temp /= 10;       
            }       
            i +=size;       
            pOutputStr[i++] = *(p-1);       
            p++;       
       }else{       
           pOutputStr[i++] = *(p-1);       
           p++;       
       }       
   }       
   pOutputStr[i] = '\0';       
 }       
 int main()       
 {       
     char input[] = "cccddecc";       
     char *output = new char[strlen(input) + 1];       
     stringZip(input,strlen(input),output);       
     cout<<output<<endl;       
     return 0;       
 }
```
### 3、通过键盘输入100以内正整数的加、减运算式，
请编写一个程序输出运算结果字符串。
输入字符串的格式为：“操作数1 运算符 操作数2”，“操作数”与“运算符”之间以一个空格隔开。
补充说明：
1、操作数为正整数，不需要考虑计算结果溢出的情况。 
2、若输入算式格式错误，输出结果为“0”。
要求实现函数： 
void arithmetic(const char *pInputStr, long lInputLen, char *pOutputStr);
【输入】 pInputStr：  输入字符串 
lInputLen：  输入字符串长度 
【输出】 pOutputStr： 输出字符串，空间已经开辟好，与输入字符串等长；  
【注意】只需要完成该函数功能算法，中间不需要有任何IO的输入输出
示例 
输入：“4 + 7”  输出：“11” 
输入：“4 - 7”  输出：“-3” 
输入：“9 ++ 7”  输出：“0” 注：格式错误
```
//////////////////////////////////////////////////////////////////////////华为第三题 20:29 - 20:40       
 #include <iostream>       
 using namespace std;       
 void arithmetic(const char *pInputStr, long lInputLen, char *pOutputStr)       
 {       
  const char *input = pInputStr;       
        char *output = pOutputStr;       
  int sum = 0;       
  int operator1 = 0;       
  int operator2 = 0;       
  char *temp = new char[5];       
  char *ope = temp;       
  while(*input != ' ') //获得操作数1       
  {       
      sum = sum*10 + (*input++ - '0');       
  }       
  input++;       
  operator1 = sum;       
  sum = 0;       
  while(*input != ' ')       
  {       
      *temp++ = *input++;       
  }       
  input++;       
  *temp = '\0';       
  if (strlen(ope) > 1 )       
  {       
      *output++ = '0';       
      *output = '\0';       
      return;       
  }       
  while(*input != '\0') //获得操作数2       
  {       
      sum = sum*10 + (*input++ - '0');       
  }       
  operator2 = sum;       
  sum = 0;       
  switch (*ope)       
  {       
  case '+':itoa(operator1+operator2,pOutputStr,10);       
      break;       
  case '-':itoa(operator1-operator2,pOutputStr,10);       
     break;       
  default:       
      *output++ = '0';       
      *output = '\0';       
      return;       
  }       
 }       
 int main()       
 {       
     char input[] = "4 - 7";       
     char output[] = "    ";       
     arithmetic(input,strlen(input),output);       
     cout<<output<<endl;       
     return 0;       
 }
```
### 4、输入1–50个数字，求出最小数和最大数的和
```
//华为2014年机试题1：输入1--50个数字，求出最小数和最大数的和       
 //输入以逗号隔开       
 #include<stdio.h>       
 #define N 50       
 void sort(int a[],int n);       
 int main(void)       
 {       
     char str[100];       
     int a[N]={0};       
     gets(str);      //要点1：动态的输入1--50个整数，不能确定个数，只能用字符串输入，然后分离出来       
     int i=0;       
     int j=0;       
     int sign=1;       
     while(str[i]!='\0')       
     {       
         if(str[i]!=',')  //输入时要在半角输入       
         {       
             if(str[i] == '-')    //要点:2：有负整数的输入       
             {       
                // i++;   //易错点1       
                 sign=-1;       
             }       
             else if(str[i]!='\0') //不用else的话，负号也会减去‘0’       
            {       
                a[j]=a[j]*10 + str[i]-'0'; //要点3：输入的可以是多位数       
            }       
         }       
         i++;       
         if(str[i]==',' || str[i]=='\0')  //这个判断是在i自加以后       
         {       
              a[j]=a[j]*sign;  //易错点2       
              sign=1;   ////易错点3       
              j++;    //j就是a数组的个数 范围0到j-1       
         }       
     }       
     sort(a,j);       
     printf("Max number + Min number = %d",a[0]+a[j-1]);       
     return 0;       
 }       
 void sort(int a[],int n)  //选择排序       
 {       
     int i,j;       
     int k;       
     int temp;       
     for(i=0;i<n-1;i++)       
     {       
         k=i;       
         for(j=i+1;j<n;j++)       
         {       
             if(a[k]>a[j])       
                 k=j;       
         }       
         if(i!=k)       
         {       
             temp = a[k];       
             a[k] = a[i];       
             a[i] = temp;       
         }       
     }       
     for(i=0;i<n;i++)       
         printf("%-5d",a[i]);       
     puts("");       
 }
```
##### *****************************************************************************************************************
