# 从数组中找出最大的两个数 - wjheha的博客 - CSDN博客
2018年02月08日 16:10:57[wjheha](https://me.csdn.net/wjheha)阅读数：2657
## ***题目***：从数组区间A[lo, hi]中找出最大的两个整数A[x1]和A[x2],要求元素比较的次数，要求尽可能的少
### 迭代版1：
![这里写图片描述](https://img-blog.csdn.net/20180207214000256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2poZWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如图所示，当整个扫描一遍数组A，找出最大的数x1后，再扫描一次数组剩下的除去x1的元素，算法代码如上图所示。第一个for循环扫描得到x1，第二个和第三个for循环扫描得到x2，第一个for循环扫描次数为n-1，后两次扫描n-1-1,所以算法复杂度O（2n-3）
### 迭代版2：
![这里写图片描述](https://img-blog.csdn.net/20180207214300764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2poZWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
观察上一个迭代版1，容易发现在一遍扫描中，可以同时比较x1和x2，这样就减少了扫描的次数。针对A中的一个元素a，先比较a和x2，如果a > x2，则把a赋值给x2；如果a <= x2，就不需要任何操作。然后再比较x2和x1的大小，如果x2 > x1，则再把x2和x1的值进行交换，如果x2 < = x1，就不需要任何操作。很容易得到算法的复杂度（比较次数）最好为（n-1），最坏为2n-3
### 递归 + 分治版：
![这里写图片描述](https://img-blog.csdn.net/20180207220913864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2poZWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如图所示，这是一种分治策略，把数组不断地拆分，它的复杂度在图中已经写出来了，注意，图中写的是最坏的情况，都不会超过5n/3 - 2，较之上一个算法(最坏情况下为2n-3)，这是有改进的。采用的是递推方程分析法。图中提出的进一步优化，思路如下：
代码：
`这里写代码片`
