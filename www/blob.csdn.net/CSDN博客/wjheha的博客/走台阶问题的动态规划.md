# 走台阶问题的动态规划 - wjheha的博客 - CSDN博客
2017年09月15日 10:31:43[wjheha](https://me.csdn.net/wjheha)阅读数：451
***题目要求***：有一座高度为10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？ 
比如，每次走1级台阶，一共走10步，这是其中一种走法，我们可以简写成1,1,1,1,1, 1,1,1,1,1。、 
  这是一道典型的动态规划类题目。我们很容易想到，当站在第10个台阶时，会回想刚才最后一步是咋上来的，无外乎两种方式：一种是在第9个台阶上，然后轻松一步到第10个台阶；一种是在第8个台阶上，直接跨了两个台阶，一步到第10个台阶。 
  然后继续想要知道如何上到第9个或者第8个台阶呢？还是和前面思路一样，分成一次走1步和一次走2步。。。就这样层层递归，直到走到第1层和第0层台阶为止。所以： 
number（走到第10个台阶）= number（走到第9个台阶） +   number（走到第8个台阶） 
***对于这个公式，有一个很自然的想法，走的方法重复了？？？？？***
其实，并没有，尽管走到第9个台阶的方法中，确实包含有走到第8个台阶的方法，但是由于登上第10阶的最后一步不一样，所以从整个过程来看，number（走到第9个台阶） 和  number（走到第8个台阶）还是不一样的。这也就是说，按照一次走几步类分类，可以把解集合无重叠、无混淆的分为两个子集。
下面是自顶向下的递归实现，维护了一个HashMap来降低了时间复杂度
```
package others;
import java.util.HashMap;
public class StepProblem {
    public static void main(String[] args) {
        int n = 10;
        HashMap<Integer, Integer> h = new HashMap<Integer, Integer>();
        int number1 = step(n, h);
        int number2 = step(n);
        System.out.println("number1= " + number1 + "  number2= " + number2);
    }
    //方法一：自顶向下
    private static int step(int n, HashMap<Integer, Integer> h) {
        // TODO Auto-generated method stub
        if(n == 0) {
            return 1;
        }
        if( n < 0) {
            return 0;
        }
        if(h.containsKey(n)) {
            return h.get(n);
        } else {
            int value = step(n - 1, h) + step(n - 2, h);
            h.put(n, value);
            return value;
        }
    }
    //方法二，自底向上
    private static int step(int n) {
        int a = 1;
        int b = 2;
        int temp = 0;
        for(int i = 3; i <=  n; i++) {
            temp = a + b;
            a = b;
            b = temp;
        }
        return temp;
    }
}
```
逆转思维，从底部向上，代码效率更高！
