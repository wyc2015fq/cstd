# 1元，3元和5元的硬币若干枚，如何用最少的硬币凑够11元（Java实现） - wjheha的博客 - CSDN博客
2017年09月10日 20:15:32[wjheha](https://me.csdn.net/wjheha)阅读数：2094
***题目描述:如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？***
  这个问题很自然的想法是采用除数取余法，首先用总钱数除以5，得到硬币值为5的使用数量，然后再拿剩下的值除以3，得到硬币值为3的使用数量，剩下的就是硬币值为1的使用数量。这里我们采用另外两种方式来实现。代码实现如下，注释很清楚，就不解释了。
```
/* 
 * 代码一：暴力破解，采用自顶向下，用递归去实现，然后优化代码，降低时间复杂度。
 * 
 * 使用最少数目的硬币凑够11元(用函数F(11)表示)，有三种方案：
 *          1，先拿1元，然后凑够剩下10元，并让凑够10元使用的硬币数目最少，用函数F(10)表示；
 *          2，先拿3元，然后凑够剩下8元， 并让凑够8元使用的硬币数目最少，用函数F(8)表示；
 *          3，先拿5元，然后凑够剩下6元，并是凑够6元使用的硬币数目最少，用函数F(6)表示。
 *          三种方法使用的最少银币数目依次为1+F(10)、 1+F(8)、 1+F(6),比较三者大小，选取数目最少的那一种方案
 * 
 * 另外，注意一点：上述分解的三种方案，它门是完全独立的，这一点避免了迭代树出现重复的迭代分支， 大幅提高了效率。但是迭代的节点还是会重复，这可以通过维护一个HashMap来解决。
 * 上述方案中，F(10)、 F(8)、 F(6)位置，下一步就是在分别求解这三个函数，重复上面F(11)的做法。
 *  就这样，一步步递归下去，最后直到F(0)和F(1)为止。
 */
package others;
import java.util.HashMap;
public class CoinCoin {
    //测试用例
    public static void main(String[] args) {
        int m = 1100;
        int[] a = {1,3,5};
        //传入钱的总数目m和可用的币值a,接收一个数组，存储钱数小于等于m的所有凑钱结果
        int[] res = coinCoin(m, a);
        for(int i = 0; i <= m; i++) {  //打印结果
            System.out.println(i + "元最少需要" + res[i] + "个硬币！");
        }
    }
    //找出最少的钱的数目,这个函数起了一个过渡的作用。
    private static int[] coinCoin(int m, int[] a) {
        HashMap<Integer, Integer> h = new HashMap<Integer,Integer>();  //对代码进行优化
        int[] res = new int[m + 1];  //存储凑够0到N的所有硬币数目
        for(int i = 0; i < m + 1; i++) {  //初始化
            res[i] = i;
        }
        //调用min()函数，完成了对res[]所有元素的赋值，
        res[m] = min(m, a, res, h);  //对该函数返回值，可以接收也可以不接收
        return res;
    }
    //min(m,....)函数返回凑够m所需的最少硬币数目。
    private static int min(int m, int[] a, int[] res, 
            HashMap<Integer, Integer> h) {
        h.put(m, 0);   //把m存入h中，键所对应的值可以随意取。
        if(m == 0) {  //递归结束条件
            res[m] = 0;
            return res[m];
        }
        for (int i = 0; i < a.length; i++) {
                if (m >= a[i]) {  //对当前硬币值和1,3,5做比较，决定循环次数,不可省略。
                    if(h.containsKey(m - a[i])) {  
                        //h是为了提高效率，降低时间复杂度，如果m - a[i]已经存在于h中，那么min(m)就已知，
                        //就没有必要再次递归，重复求解min(m),但是这样牺牲了空间复杂度。在实际运用中选择合适的方案。
                        if(res[m] > res[m - a[i]] + 1) 
                            res[m] = res[m - a[i]] + 1;
                    } else {
                        //m - a[i]不存在于h中
                        if(res[m] > min(m - a[i], a, res, h) + 1) 
                            res[m] = min(m - a[i], a, res, h) + 1;
                    }
                }
        }
        return res[m];
    }
}
```
上面的实现浪费了空间，可以简化如下：
```
package others;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
/*
 * 上述代码同时使用了hashMap优化和数组存储来计算的最少硬币值，造成了空间浪费，
 * 可以只用一个HashMap来同时存储和优化,代码精简如下
 */
public class CoinCoin {
    //测试用例
    public static void main(String[] args) {
        int m = 1100;
        int[] a = {1,3,5};
        HashMap<Integer, Integer> h = coinCoin(m, a);
        Iterator iter = h.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            Object key = entry.getKey();
            Object val = entry.getValue();
            System.out.println(key + "元最少需要: " + val + " 个硬币！");
        }
    }
    //找出最少的钱的数目
    private static HashMap<Integer, Integer> coinCoin(int m, int[] a) {
        HashMap<Integer, Integer> h = new HashMap<Integer,Integer>();  //对代码进行优化
        h.put(m, min(m, a, h));
        return h;
    }
    //min(m,....)函数返回凑够m所需的最少硬币数目。
    private static int min(int m, int[] a, 
            HashMap<Integer, Integer> h) {
        h.put(m, m);
        if(m == 0) {  //递归结束条件
            h.put(m, 0);
            return h.get(m);
        }
        for (int i = 0; i < a.length; i++) {
            if(m >= a[i]) {
                if (h.containsKey(m - a[i])) {
                    // h是为了提高效率，降低时间复杂度，如果m - a[i]已经存在于h中，那么min(m)就已知，
                    // 就没有必要再次递归，重复求解min(m),但是这样牺牲了空间复杂度。在实际运用中选择合适的方案。
                    if (h.get(m) > h.get(m - a[i]) + 1)
                        h.put(m, h.get(m - a[i]) + 1);
                } else {
                    // m - a[i]不存在于h中
                    if (h.get(m) > min(m - a[i], a, h) + 1)
                        h.put(m, min(m - a[i], a, h) + 1);
                }
            }
        }
        return h.get(m);
    }
}
```
  上述代码实现，整个思路是采用***自顶向下的递归***策略。借用鲁迅先生的话，“不妨把思路逆转过来”,借用动态规划的套路，采用***自底向上***，用***迭代***的方式推导出结果。依次得出凑够0、1、2……….11所需的最少硬币数目。代码如下：
```
/*
 * 代码二：学习动态规划的思想，采用自底向上，用迭代去实现。
 * 
 * 硬币数目的最小单元是1、3、5，凑一次必须使用三个单元之一，假设
 * 钱的数目为m,则 m = 1 * x + 3 * y + 5 * z;
 * 
 * 如果要凑够0元，只有一种方案，使用0个硬币。
 * 如果要凑够1元，只有一种方案，先拿1元，再凑够剩下的1-1=0元，而由上一步凑0元方法已知。
 * 如果要凑够2元，只有一种方案，先拿1元，再凑够剩下的2-1=1元，而由上一步凑1元方法已知。
 * 如果要凑够3元，有两种方案，先拿1元，再凑够剩下的3-1=2元；或者先拿2元，再凑够剩下的3-2=1元。
 *             而由上一步凑1元和2元方法已知，比较两种方法，哪种方法使用硬币数目少。
 * 如果要凑够4元，有两种方案，先拿1元，再凑够剩下的4-1=3元；或者先拿3元，再凑够剩下的4-3=1元；
 *             而由上一步凑1元和3元方法已知，比较两种方法，哪种方法使用硬币数目少。
 * 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。
 * 如果要凑够10元，有三种方案，先拿1元，再凑够剩下的10-1=9元；或者先拿3元，再凑够剩下的10-3=7元；
 *             或者先拿5元，再凑够剩下的10-5=5元。
 *             而由上一步凑7元和9元方法已知，比较两种方法，哪种方法使用硬币数目少。
 * 如果要凑够11元，有三种方案，先拿1元，再凑够剩下的11-1=10元；或者先拿3元，再凑够剩下的11-3=8元；
 *             或者先拿5元，再凑够剩下的11-5=6元。
 *             而由上一步凑10元和8元方法已知，比较两种方法，哪种方法使用硬币数目少。
 * 把上述过程用代码实现，用两个for循环即可完成。
 */
package others;
public class CoinCoin {
    //测试用例
    public static void main(String[] args) {
        int m = 112;
        int[] temp = coinCoin(m);
        for(int i = 0; i <= m; i++) {
            System.out.println(i + "元最少需要" + temp[i] + "个硬币！");
        }
    }
    //找出最少的钱的数目
    private static int[] coinCoin(int m) {
        int[] a = {1, 3, 5};  //硬币面值
        int[] temp = new int[m + 1];  //存储所需硬币的数目
        for(int i = 0; i <= m; i++) {
            temp[i] = i;    //默认全部使用1元，则i元最多需要使用i个银币。
        }
        for(int i = 1; i <= m; i++) {
            //这个外层循坏，依次对1到m个钱数，进行凑数
            for(int j = 0; j < 3; j++) {
                //这个内层循环，每次都会固定执行3次
                if(a[j] <= i && temp[i - a[j]] + 1 < temp[i]) {
                    temp[i] = temp[i - a[j]] + 1; 
                    /* a[j] <= i依次判断i和1,3,5的相对大小，决定第一步有几种方案，
                     * temp[i - a[j]] + 1 < temp[i]这个不太容易理解，
                     * 我们将temp[i]初始值设为i,在三次内循环判断中，如果这一次temp[i - a[j]]
                     * 比上一次小，那么就将这一次的值赋给temp[i]
                     *
                     * 举例，i=6,此时前面循环执行完毕
                     * temp[0] = 0,temp[1] = 1
                     * temp[2] = 2,temp[3] = 1
                     * temp[4] = 2,temp[5] = 3
                     * 第一步就有三种方案，当前内循环执行三次
                     * j = 0 时，a[j]=1 <= i=6成立，temp[i - a[j]] + 1 = temp[6-1] + 1 = 4 < temp[i]=6成立
                     *      所以temp[6] = temp[i - a[j]] + 1 = 4
                     * j = 1 时，a[j]=3 <= i=6成立，temp[i - a[j]] + 1 = temp[6-3] + 1 = 2 < temp[i]=4成立
                     *      所以temp[6] = temp[i - a[j]] + 1 = 2
                     * j = 2 时，a[j]=5 <= i=6成立，temp[i - a[j]] + 1 = temp[6-5] + 1 = 2 < temp[i]=2不成立
                     *      所以temp[6] = temp[i - a[j]] + 1 = 2
                     * 这样，最终temp[6] = 2，就从三种方案中选择出最小的了
                     */
                }
            }
        }
        return temp;
    }
}
```
上述两个程序执行效果：
```
0元最少需要0个硬币！
1元最少需要1个硬币！
2元最少需要2个硬币！
3元最少需要1个硬币！
4元最少需要2个硬币！
5元最少需要1个硬币！
6元最少需要2个硬币！
7元最少需要3个硬币！
8元最少需要2个硬币！
9元最少需要3个硬币！
10元最少需要2个硬币！
11元最少需要3个硬币！
```
