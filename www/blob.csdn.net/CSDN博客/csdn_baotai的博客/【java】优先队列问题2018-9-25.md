# 【java】优先队列问题2018-9-25 - csdn_baotai的博客 - CSDN博客

2018年09月25日 13:08:20[csdn-[baotai]](https://me.csdn.net/csdn_baotai)阅读数：265


## 什么是优先队列？

提到优先队列我们首先想到的就是**队列**这个数据结构

## 队列的特点是什么？

**先进先出（FIFO）**。

**入队列：**

![在这里插入图片描述](https://img-blog.csdn.net/20180927235828805?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**出队列：**

![在这里插入图片描述](https://img-blog.csdn.net/20180927235846885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

那么，优先队列又是什么样子呢？

优先队列不再遵循先入先出的原则，而是分为两种情况：

**最大优先队列，无论入队顺序，当前最大的元素优先出队。**

**最小优先队列，无论入队顺序，当前最小的元素优先出队。**

比如有一个最大优先队列，它的最大元素是8，那么虽然元素8并不是队首元素，但出队的时候仍然让元素8首先出队：

![在这里插入图片描述](https://img-blog.csdn.net/20180928000158584?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

让我们回顾一下二叉堆的特性：

**1.最大堆的堆顶是整个堆中的最大元素**

**2.最小堆的堆顶是整个堆中的最小元素**

因此，我们可以用**最大堆来实现最大优先队列**，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。

**入队操作：**

1.插入新节点5

![在这里插入图片描述](https://img-blog.csdn.net/20180928000211419?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2.新节点5上浮到合适位置。

![在这里插入图片描述](https://img-blog.csdn.net/20180928000222970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**出队操作：**

1.把原堆顶节点10“出队”

![在这里插入图片描述](https://img-blog.csdn.net/20180928000329991?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2.最后一个节点1替换到堆顶位置

![在这里插入图片描述](https://img-blog.csdn.net/20180928000342779?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3.节点1下沉，节点9成为新堆顶
![在这里插入图片描述](https://img-blog.csdn.net/20180928000356391?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYmFvdGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 二叉堆节点上浮和下浮的时间复杂度都是logn，所以优先队列入队和出队的时间复杂度也都是logn！

# 代码实现

```java
```java
import java.util.Arrays;

public class PriorityQueue {
	private int[] array;
    private int size;
    public PriorityQueue() {
		// 队列初始长度32
		array = new int[32];
	}
    
    /**
     * 入队
     * @param key  入队元素
     */
	private void enQueue(int key){
		// 队列长度超出范围，扩容
		if (size >= array.length) {
			resize();
		}
		array[size++] = key;
		upAdjust();
	}

	/**
	 * 
	 * 出队
	 * 
	 */

	private int deQueue() throws Exception{
		if (size <=0) {
			throw new Exception("the queue is empty !");
		}
		// 获取堆顶元素
		int head = array[0];

		// 最后一个元素移动到堆顶
		array[0] = array[--size];
		downAdjust();
		return head;
	}

	/**
	 * 
	 * 上浮调整
	 * 
	 */
	private void upAdjust()
	{
		int childIndex = size - 1;
		int parentIndex = childIndex / 2;
		// temp保存插入的叶子节点值，用于最后的赋值
		int temp = array[childIndex];
		while (childIndex > 0 && temp > array[parentIndex]){
			// 无需真正交换，单向赋值即可
			array[childIndex] = array[parentIndex];
			childIndex = parentIndex;
			parentIndex = parentIndex / 2;
		}
		array[childIndex] = temp;
	}
    
	/**
	 * 
	 * 下沉调整
	 * 
	 */

	private void downAdjust()
	{
		// temp保存父节点值，用于最后的赋值
		int parentIndex = 0;
		int temp = array[parentIndex];
		int childIndex = 1;
		while(childIndex < size)
		{
			// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子

			if(childIndex + 1 < size && array[childIndex + 1] > array[childIndex]){
				childIndex++;
			}
			// 如果父节点大于任何一个孩子的值，直接跳出
			if(temp >= array[childIndex])
				break;
			// 无需真正交换，单向赋值即可
			array[parentIndex] = array[childIndex];
			parentIndex = childIndex;
			childIndex = 2 * childIndex + 1;
		}
		array[parentIndex] = temp;
	}

	/**
	 * 
	 * 扩容调整
	 * 
	 */

	private void resize()
	{
		// 队列容量翻倍
		int newSize = this.size * 2;

		this.array = Arrays.copyOf(this.array, newSize);
	}

	public static void main(String[] args) throws Exception{
		PriorityQueue priorityQueue = new PriorityQueue();
		priorityQueue.enQueue(3);
		priorityQueue.enQueue(5);
		priorityQueue.enQueue(10);
		priorityQueue.enQueue(2);
		priorityQueue.enQueue(7);
		System.out.println("出队元素：" + priorityQueue.deQueue());
		System.out.println("出队元素：" + priorityQueue.deQueue());
		System.out.println("出队元素：" + priorityQueue.deQueue());
		System.out.println("出队元素：" + priorityQueue.deQueue());
	}

	
}
```
```

}

代码中采用数组来存储二叉堆的元素，因此当元素超过数组范围的时候，需要进行resize来扩大数组长度。

