# 【优先队列】百度2018校招编程题—序列合并 - CD's Coding - CSDN博客





2017年09月27日 21:24:20[糖果天王](https://me.csdn.net/okcd00)阅读数：656








## 0x00 前言

又一次当枪手的经历，但是，说实话好久没敲C++了有些手生，一个是freopen传参是啥来着想半天没想起来，一个是居然忘记优先队列的pop是不return的了……

哦对了这题我也放在新搭建的主页上了，也可以去那儿看看~ [传送门](https://okcd00.github.io/articles/2017-09/%E3%80%90%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%91%E7%99%BE%E5%BA%A62018%E6%A0%A1%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%98%E2%80%94%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6.html)

此题为：
- 百度2018校招 
- 机器学习/数据挖掘/自然语言处理方向
- 编程题 第2题

## 0x01 题目描述

定义函数 


$ f(n)=a_7n^7+a_6n^6+a_5n^5+a_4n^4+a_3n^3+a_2n^2+a_1n+a_0 $

其中系数 $a_i$ 都是整数，满足 $ 0\le a_i \le 1000$ 且至少有两个系数严格大于0，分别将 $ n=1, n=2, n=3, ... $ 代入以上函数可以得到无穷长度的证书序列，即用8个系数 $a_7, a_6, ... a_0$可以唯一确定一个无穷长度的整数序列。现在给出k个通过以上方法定义的无穷序列，你需要求出将这些所有数字放在一起后，第n小的数字是多少。
## 0x02 解题思路

首先理解题意，有k个数列，找出其中第n小。 

那么每次定位从哪个数列要数字，是本题的时间限，那……就用最小堆就行了，找个在C++的STL里等价的，那就用优先队列吧。

于是我们先把每个 $f$ 函数的参数读进来，用一个a[a_idx]来存这8个数字，并且把n等于1时的状态放进优先队列里，这样我们读完就有了一个最小堆，堆顶是所有数列中最小的一个：

```cpp
for(int j=0; j<8; j++)
    scanf("%lld", &a[i][j]);
q.push(T(calc(a[i], 1), 1, i));
```

我们得到了数，但是还需要知道这个数是从哪个队列来的，以及这是当前数列的第几个数了，所以我们用一个结构体来记录这些事情：

```cpp
class T
{
public:
    ll value;
    int n;
    int a_idx;
    T(ll a, int b, int c):value(a),n(b),a_idx(c){}
};
```

于是，题目就演变成了：每次取数列中最小的那个，并且计算这个数列（第a_idx组参数对应的函数）下一个（n+=1）是什么数字（value），把他们包装好，再放进优先队列里（此处需要注意优先队列默认是大顶堆，需要小顶堆时需要如下定义）

```cpp
priority_queue<T, vector<T>, greater<T> > q;
```

## 0x03 Source Code

```cpp
#include<cmath>
#include<queue>
#include<vector>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long ll;

class T
{
public:
    ll value;
    int n;
    int a_idx;
    T(ll a, int b, int c):value(a),n(b),a_idx(c){}
};

bool operator > (const T &t1, const T &t2) 
{
     return t1.value > t2.value;
} 

ll calc(ll* a, int n)
{
    ll ret = 0LL;
    for(int i=0;i<8;i++)
        ret += a[i] * pow(ll(n), ll(7-i));
    return ret;
}

int main()
{
    freopen("./in.txt", "r", stdin);
    ll a[10001][8]={0};

    priority_queue<T, vector<T>, greater<T> > q;
    while(!q.empty()) q.pop();

    int n; scanf("%d", &n);
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<8; j++)
            scanf("%lld", &a[i][j]);
        q.push(T(calc(a[i], 1), 1, i));
        //cout<<q.top().value<<endl;
    }
    int k; scanf("%d", &k);
    ll ret = 0LL;
    for(int i=0; i<k; i++)
    {
        T cur = q.top();
        q.pop();
        int _n = cur.n;
        int _i = cur.a_idx;
        ret = cur.value;

        T inp = T( calc(a[_i], _n+1), _n+1, _i );
        q.push(inp);
    }
    cout<<ret<<endl;

    fclose(stdin);
    return 0;
}

/*
Sample input:
3
0 0 0 0 1 2 0 0
0 0 0 0 0 0 10 6
0 0 0 0 0 0 25 1
9

Sample output:
51
*/
```




