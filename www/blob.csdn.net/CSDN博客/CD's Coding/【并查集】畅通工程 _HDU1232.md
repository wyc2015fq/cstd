# 【并查集】畅通工程 _HDU1232 - CD's Coding - CSDN博客





2015年04月21日 14:13:56[糖果天王](https://me.csdn.net/okcd00)阅读数：454








老说这个算法懂了，那个算法理解了，什么什么的总感觉底气不足，以后一点点要把自己懂了的算法找个几题写一些，不仅是算法，代码的构造也要了解透彻才能算作会了。

今天就并查集好了，写个裸并查集，HDOJ1232 畅通工程



# 畅通工程
**Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 34734    Accepted Submission(s): 18365**



Problem Description


某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 






Input


测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 

注意:两个城市之间可以有多条道路相通,也就是说

3 3

1 2

1 2

2 1

这种输入也是合法的

当N为0时，输入结束，该用例不被处理。 






Output


对每个测试用例，在1行里输出最少还需要建设的道路数目。 






Sample Input


4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0






Sample Output


1
0
2
998



*Hint*
Hint

Huge input, scanf is recommended.






Source

[浙大计算机研究生复试上机考试-2005年](http://acm.hdu.edu.cn/search.php?field=problem&key=%D5%E3%B4%F3%BC%C6%CB%E3%BB%FA%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C9%CF%BB%FA%BF%BC%CA%D4-2005%C4%EA&source=1&searchmode=source)





Recommend


JGShining   |   We have carefully selected several similar problems for you:  [1233](http://acm.hdu.edu.cn/showproblem.php?pid=1233)[1272](http://acm.hdu.edu.cn/showproblem.php?pid=1272)[1875](http://acm.hdu.edu.cn/showproblem.php?pid=1875)[1879](http://acm.hdu.edu.cn/showproblem.php?pid=1879)[1213](http://acm.hdu.edu.cn/showproblem.php?pid=1213)






所谓并查集，就是要判断他们在不在同一个集合里（这里用STL的<set>会舒服些，但是为了熟手，还是敲一次的好），

pre[i]是指当前节点的上级。这题主要是看经过link之后有多少棵树（集合），集合与集合间的一条线就能让他俩合并为一个集合，所以要求输出的其实是（集合数-1），这道题的话我们只要遍历一遍，找头头有多少个（即自己没有上级），即总共有多少个集合。



```cpp
#include <cmath> 
#include <cctype>
#include <cstdio>
#include <string>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define Max(a,b) ((a)>(b)?(a):(b))
#define Min(a,b) ((a)<(b)?(a):(b))

bool cmp(const int a, const int b)
{
	return a > b;
}

#define MAXN 1024
int pre[MAXN]={0};	//pre[i] : No.father of Node[i]

void pre_init(int n)
{
	for(int i=0;i<=n;i++)
	{
		pre[i]=i;
	}
}

void join(int a, int b)
{
	int tmpa=a,tmpb=b;
	while(pre[tmpa]!=tmpa) tmpa=pre[tmpa];
	while(pre[tmpb]!=tmpb) tmpb=pre[tmpb];
	if(tmpa!=tmpb)	pre[tmpb]=tmpa;
}

int main()
{
	int n=0,m=0;
	while(scanf("%d",&n) && n)
	{
		int a,b;
		pre_init(n);
		scanf("%d",&m);
		for(int i=0;i<m;i++)
		{
			scanf("%d%d",&a,&b);
			join(a,b);
		}
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			if(pre[i]==i)ans++;
		}
		printf("%d\n",ans-1);
	}
	return 0;
}
```









// <备忘> 并查集有[路径压缩算法](http://blog.csdn.net/dellaserss/article/details/7724401)，意为上级即头头。暂存，日后更新。

<Done on Apr.21th 2015>

在Find的过程中，把路上捡起来的所有中间节点都前指到root即可。



```cpp
#include <cmath> 
#include <cctype>
#include <cstdio>
#include <string>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

int  pre[1050];	//pre 上司节点 
bool t[1050];	//t 用于标记独立块的根结点

int Find(int x)	//获得x所在树的根节点 
{
	int r=x, i=x, tmp;
	while(r!=pre[r]) r=pre[r];
	while(pre[i]!=r)	//一路向上，把路上的所有上司直接前指向root 
	{
		tmp=pre[i];
		pre[i]=r;
		i=tmp;
	}
	return r;
}

void mix(int x,int y)
{
	int fx=Find(x), fy=Find(y);
	if(fx!=fy)	pre[fy]=fx;
} 

int main()
{
	int n,m,a,b,i,j,ans;
	while(scanf("%d",&n) && n)
	{
		scanf("%d",&m); 
		for(i=1;i<=n;i++) pre[i]=i;
		for(i=1;i<=m;i++)          //吸收并整理数据 
		{
			scanf("%d%d",&a,&b);
			mix(a,b);
		}
		memset(t,0,sizeof(t));
		for(i=1;i<=n;i++)          //标记根结点
		{
			int tf=Find(i);
			//cout<<i<<":"<<tf<<endl;
			t[tf]=1;
		}
		for(ans=0,i=1;i<=n;i++)	if(t[i]) ans++;
		printf("%d\n",ans-1);
	}
	return 0;
}
```








