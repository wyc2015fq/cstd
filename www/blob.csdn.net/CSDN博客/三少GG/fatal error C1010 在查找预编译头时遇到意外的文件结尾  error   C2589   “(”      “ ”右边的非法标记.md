# fatal error C1010: 在查找预编译头时遇到意外的文件结尾 ||error     C2589:     “(”     :     “::”右边的非法标记 - 三少GG - CSDN博客
2013年03月05日 15:58:38[三少GG](https://me.csdn.net/scut1135)阅读数：1346

fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include "stdafx.h(2011-09-08 22:17:50)
错误描述：fatal
 error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include "stdafx.h"”?
错误分析：
此错误发生的原因是编译器在寻找预编译指示头文件（默认#include "stdafx.h"）时，文件未预期结束。没有找到预编译指示信息的头文件"stdafx.h"。
    (因为工程中的每个cpp文件属性默认都是使用预编译头（/YU）的，但是添加的第三方文件并没有 #include "stdafx.h" 预编译指示头，所以编译器在此cpp文件中一直到末尾都没有找到它)
 我的这个问题发生于我通过添加文件的方式，向MFC内添加现有的一大坨.h和.cpp文件。这些.h和.cpp文件是属于标准C++的开源源代码范畴，与MFC无更深层次的关系。
解决方式：
一.
1) 在解决方案资源管理器中，右击相应的**.cpp文件**，点击“属性”
2) 在左侧配置属性中，点开“C/C++”，单击“预编译头”
3) 更改右侧第一行的“创建/使用预编译头”，把选项从“使用预编译头（/Yu）”改成“不使用预编译头”
4) 注：每一个报错的.cpp都要如此更改哦~辛苦一下呗~
二.
（不推荐）
1）在解决方案右击**工程**，点击属性
2)在配置属性 -> c/c++ -> 预编译头 中 将 “使用预编译头（/YU）” 改为 “不适用预编译头”
这种做法会使每次编译过程非常缓慢
**注意.C 文件不能包含stdafx.h头文件，必须要去掉预编译头。**
备注：
1） 貌似也可以直接在.cpp头文件上include stdafx.h。但没尝试如此修改，因为不想破坏源代码的标准性^_^
2） 感慨一下VC在识别、编译这方面的迟滞-_-，或许是因为太强大了吧，就没考虑周全，竟然还需要手动修改~
3） 有点怀念Qt了……
补充的资料：
出处：[http://blog.csdn.net/hotandhot/archive/2006/10/23/1346195.aspx](http://blog.csdn.net/hotandhot/archive/2006/10/23/1346195.aspx)
一、概念：
1、预编译：就是编译器首先编译某个文件（称为预编译头文件），然后将这个编译结果保存起来，之后如果有其他源文件include了这个“预编译头文件”的时候，则自动从这个编译结果提取需要的信息进行编译。
2、预编译结果文件（Precompiled header file）：就是那个用来保存已经编译了的符号信息的文件（.PCH作为后缀）
3、生成预编译结果文件（Create Precompiled header file）：我们说源文件A通过文件B“生成预编译结果文件”是指编译A的时候将其中编译B的编译结果保存成预编译结果文件。一般使用向导的话，A文件就是“stdafx.cpp”，B文件是“stdafx.h”。stdafx.cpp中就一行语句：
#include “stdafx.h”
4、使用预编译头（Using precompiled header）：我们说某个源文件（a.cpp）通过“stdafx.h”来使用预编译结果是指编译a.cpp的时候，如果a.cpp第一行include语句是#include “stdafx.h”的话，那么直接取预编译结果文件的结果，不再重新编译”stdafx.h”
二、向导是怎么做的？
1、设置“stdafx.cpp”的预编译选项是通过“stdafx.h”文件来“生成预编译结果文件”。
2、其他源文件的预编译选项设置是通过“stdafx.h”来“使用预编译头”
三、使用原则？
1、将相对稳定的头文件（比如CRT，STL，第三方固定的库）全部写在stdafx.h中。（是否使用stdafx.h依赖个人喜好，不过使用stdafx.h可以和向导保持一致）
2、全部源文件第一行都加#include “stdafx.h”。
3、一些不能修改的源文件（如果公共的代码，不具备权限修改的代码），设置他的预编译选项是“不使用预编译头”。注意，一定不能是选择“自动生成预编译头”，因为这样会将stdafx.h的结果冲掉（这个不知道是BUG还是设计的问题了，.^_^。）。
四、Q&A
Q、为什么不全部使用“自动生成预编译头文件”？
A、“自动生成预编译头文件”和什么都不用没有什么两样，编译速度没有质的提高。
Q、手工添加一个新的源文件到项目的时候，经常出现类似错误：
fatal error C1010: unexpected end of file while looking for precompiled header directive
A、因为向导缺省的设置是“使用预编译头”，但是你新加的文件并没有在第一行包含“stdafx.h”。解决的方法要么修改成“不使用预编译头”，要么添加一行#include “stdafx.h”
Q、加stdafx.h和stdafx.cpp总觉得是和编译平台绑定了，不具备移植性？
A、其实，注意一下stdafx.h的写法就没有问题了。我的解决方案是(stdafx.h的内容)：
–begin of file stdafx.h
#ifdef _WIN32
#include “win.h”    // 泛指window下的公共头文件
#else
#include “linux.h”    // 泛指linux下的公共头文件
#endif
#include “crt.h”      //泛指c标准库
#include“stl.h”      //泛指STL库
–end of file
或者更加简单一点，如果不是VC编译器，那么stdafx.h就什么内容都不写！
有朋友在编译我提供的【Visual C++】游戏开发某一节笔记的源代码的时候，提到出现 “fatal error C1083: 
无法打开包括文件:“StdAfx.h”这个错误。这里我专门找了点资料，然后部分修改，写成了一篇博文发出来，希望能对出现这个问题的朋友们有所帮助。
这个错误大都是由于预编译头文件及#include<stdafx.h>这两者的关系纠缠不清引起的，呵呵。
这里我们采用vs2010讲解，其他版本其实操作方案也差不多。
1、如果在Visual C++工程的.cpp文件中包含了代码#include<stdafx.h>,则工程就需要将属性设置为：“使用预编译头”，具体方案是对“资源管理器”里的工程右击->【属性】->【配置属性】->【C/C++】->【预编译头】，然后【创建/使用预编译头】选择“使用”
具体操作可以看我截的图：
![](https://img-my.csdn.net/uploads/201204/11/1334149495_6460.jpg)
2、如果.cpp文件里包含了stdafx.h文件，设置为“不使用预编译头”，可能会编译就出现错误的，
fatal error C1083: 无法打开包括文件:“StdAfx.h”: No such file or directory，
所以设置为“创建预编译头”，或者设置为“使用预编译头”。
3、如果出现下面错误： fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include “stdafx.h””?
则表示没有包含stdafx.h文件，设置为”不使用预编译头“即可。
4、因为最近做了matlab与vc混编，所以，生成了.c文件，.c文件是不能使用预编译头的，如果让这样的文件“使用预编译头”，会出现下面错误的：
“Debug\SMMS.pch”预编译头文件来自编译器的早期版本，或者预编译头为 C++ 而在 C 中使用它(或相反)
所以，在.c文件右键->【属性】->"不使用预编译头“。注意只是此文件的属性。
**-----------------------------------------------------------------分割线----------------------------------------------------------------------------------**
**error     C2589:     “(”     :     “::”右边的非法标记 **
**error     C2059: 语法错误 : “::”**
google了一下，原来是需要把max用括号括起来避免和windows定义的宏混淆
or you can prevent macro invocation by using an extra set of parentheses:
```
column = **(std::max)(**1u, column + count);
```
`(std::numeric_limits<double>::max)()`
因为Windef.h中定义了
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
所以会产生编译错误
