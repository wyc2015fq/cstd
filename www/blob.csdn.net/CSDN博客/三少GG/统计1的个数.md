# 统计1的个数 - 三少GG - CSDN博客
2012年10月18日 21:31:30[三少GG](https://me.csdn.net/scut1135)阅读数：767标签：[算法																[面试																[微软																[n2](https://so.csdn.net/so/search/s.do?q=n2&t=blog)](https://so.csdn.net/so/search/s.do?q=微软&t=blog)](https://so.csdn.net/so/search/s.do?q=面试&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[重构C/C++																[技术面经](https://blog.csdn.net/scut1135/article/category/1104190)](https://blog.csdn.net/scut1135/article/category/621651)
# 统计整数二进制表示中1的个数
这是一个很有意思的问题，也是在面试中最容易被问到的问题之一。这个问题有个正式的名字叫[Hamming_weight](http://en.wikipedia.org.sixxs.org/wiki/Hamming_weight)，而且wikipedia上也提供了很好的位运算解决的方法，这个下面也会提到。
解决这个问题的第一想法是一位一位的观察，判断是否为1，是则计数器加一，否则跳到下一位，于是很容易有这样的程序。
[?](http://crane.is-programmer.com.sixxs.org/posts/17830.html#)
```
```cpp
int
```
```cpp
test(
```
```cpp
int
```
```cpp
n)
```
```cpp
{
```
```cpp
```
```cpp
int
```
```cpp
count=0;
```
```cpp
```
```cpp
while
```
```cpp
(n != 0){
```
```cpp
```
```cpp
if
```
```cpp
(n%2 ==1)
```
```cpp
```
```cpp
count++;
```
```cpp
```
```cpp
n /= 2;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
count;
```
```cpp
}
```
```
或者和其等价的位运算版本：
[?](http://crane.is-programmer.com.sixxs.org/posts/17830.html#)
```
```cpp
int
```
```cpp
test(
```
```cpp
int
```
```cpp
n)
```
```cpp
{
```
```cpp
```
```cpp
int
```
```cpp
count=0;
```
```cpp
```
```cpp
while
```
```cpp
(n != 0){
```
```cpp
```
```cpp
count += n&1;
```
```cpp
```
```cpp
n >>= 1;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
count;
```
```cpp
}
```
```
这样的方法复杂度为二进制的位数，即![](http://latex.codecogs.com/gif.latex?%5Clog_2n)，于是可是想一下，有没有只与二进制中1的位数相关的算法呢。
可以考虑每次找到从最低位开始遇到的第一个1，计数，再把它清零，清零的位运算操作是与一个零，但是在有1的这一位与零的操作要同时不影响未统计过的位数和已经统计过的位数，于是可以有这样一个操作 n&(n-1) ，这个操作对比当前操作位高的位没有影响，对低位则完全清零。拿6（110）来做例子，第一次 110&101=100，这次操作成功的把从低位起第一个1消掉了，同时计数器加1，第二次100&011=000，同理又统计了高位的一个1，此时n已变为0，不需要再继续了，于是110中有2个1。
代码如下：
[?](http://crane.is-programmer.com.sixxs.org/posts/17830.html#)
```
```cpp
int
```
```cpp
test(
```
```cpp
int
```
```cpp
n)
```
```cpp
{
```
```cpp
```
```cpp
int
```
```cpp
count=0;
```
```cpp
```
```cpp
while
```
```cpp
(n != 0){
```
```cpp
```
```cpp
n &= n-1;
```
```cpp
```
```cpp
count ++;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
count;
```
```cpp
}
```
```
这几个方法虽然也用到了位运算，但是并没有体现其神奇之处，下面这个版本则彰显位运算的强大能力，若不告诉这个函数的功能，一般一眼看上去是想不到这是做什么的，这也是wikipedia上给出的计算hamming_weight方法。
[?](http://crane.is-programmer.com.sixxs.org/posts/17830.html#)
```
```cpp
int
```
```cpp
test(
```
```cpp
int
```
```cpp
n)
```
```cpp
{
```
```cpp
```
```cpp
n = (n&0x55555555) + ((n>>1)&0x55555555);
```
```cpp
```
```cpp
n = (n&0x33333333) + ((n>>2)&0x33333333);
```
```cpp
```
```cpp
n = (n&0x0f0f0f0f) + ((n>>4)&0x0f0f0f0f);
```
```cpp
```
```cpp
n = (n&0x00ff00ff) + ((n>>8)&0x00ff00ff);
```
```cpp
```
```cpp
n = (n&0x0000ffff) + ((n>>16)&0x0000ffff);
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```
没有循环，5个位运算语句，一次搞定。
比如这个例子，143的二进制表示是10001111，这里只有8位，高位的0怎么进行与的位运算也是0，所以只考虑低位的运算，按照这个算法走一次
+---+---+---+---+---+---+---+---+
| 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | <---143
+---+---+---+---+---+---+---+---+
| 0 1 | 0 0 | 1 0 | 1 0 | <---第一次运算后
+-------+-------+-------+-------+
| 0 0 0 1 | 0 1 0 0 | <---第二次运算后
+---------------+---------------+
| 0 0 0 0 0 1 0 1 | <---第三次运算后，得数为5
+-------------------------------+
这里运用了分治的思想，先计算每对相邻的2位中有几个1，再计算每相邻的4位中有几个1，下来8位，16位，32位，因为2^5＝32，所以对于32位的机器，5条位运算语句就够了。
像这里第二行第一个格子中，01就表示前两位有1个1，00表示下来的两位中没有1，其实同理。再下来01+00=0001表示前四位中有1个1，同样的10+10=0100表示低四位中有4个1，最后一步0001+0100=00000101表示整个8位中有5个1。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
## x&(x-1)表达式的意义
求下面函数的返回值(微软) -- 统计1的个数
-------------------------------------
int func(int x)
{
    int countx = 0;
    while(x)
    {
        countx++;
        x = x&(x-1);
    }
    return countx;
} 
假定x = 9999
10011100001111
答案: 8
思路: 将x转化为2进制，看含有的1的个数。
注: 每执行一次x = x&(x-1)，会将x用二进制表示时最右边的一个1变为0，因为x-1将会将该位(x用二进制表示时最右边的一个1)变为0。
判断一个数(x)是否是2的n次方
-------------------------------------
#include <stdio.h>
int func(int x)
{
    if( (x&(x-1)) == 0 )
        return 1;
    else
        return 0;
}
int main()
{
    int x = 8;
    printf("%d\n", func(x));
}
注: 
(1) 如果一个数是2的n次方，那么这个数用二进制表示时其最高位为1，其余位为0。
(2) == 优先级高于 &
df

