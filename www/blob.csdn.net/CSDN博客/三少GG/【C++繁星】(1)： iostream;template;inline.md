# 【C++繁星】(1)： iostream;template;inline - 三少GG - CSDN博客
2010年09月20日 22:01:00[三少GG](https://me.csdn.net/scut1135)阅读数：1147标签：[iostream																[c++																[编译器																[语言																[stream																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=stream&t=blog)](https://so.csdn.net/so/search/s.do?q=语言&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)](https://so.csdn.net/so/search/s.do?q=c++&t=blog)](https://so.csdn.net/so/search/s.do?q=iostream&t=blog)
个人分类：[重构C/C++](https://blog.csdn.net/scut1135/article/category/621651)
1.**iostream**
　iostream 的意思是 输入输出流
　　直接点说就是in(输入) out(输出) stream(流)
　　取 in out 的首字母与 stream 合成
## C++语言中
　　#include<iostream>是标准的C++头文件，任何符合标准的C++
开发环境都有这个头文件。
　　在旧的标准C++中,使用#include<[iostream.h](http://baike.baidu.com/view/2878297.htm)
>
　　但在新标准中,用#include<iostream>，而且在VS中编程的同时
要注意要添加：
　　using namespace std;
　　在C++中，输入输出流被定义为类。C++的I/O库中的类称为流类(stream 
class)。用流类定义的对象称为流对象。
　　
**using namespace std详解**
　一 ：
　　<iostream>和<iostream.h>是不一样，前者没有
后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。 
　　后缀为.h的头文件[c++](http://baike.baidu.com/view/824.htm)
标准已经明确提出不支持了，早些的实现将标准库
功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 
　　因此，当使用<iostream.h>时，相当于在c中调用库函数，使用的是全局
命名空间，也就是早期的c++实现；当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace 
std；这样才能正确使用cout。
　
　二：
　　所谓namespace，是指标识符的各种可见范围。
　　C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。
　　由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：
　　1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下：
　　std::cout << std::hex << 3.4 
<< std::endl;
　　2、使用using关键字。
　　using std::cout;
　　using std::endl;
　　以上程序可以写成
　　cout << std::hex << 3.4 <<
 endl;
　　3、最方便的就是使用using namespace std;
　　例如：
　　#include <iostream>
　　#include <sstream>
　　#include <string>
　　using namespace std;
　　这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么
以上语句可以如下写:
　　cout << hex << 3.4 << 
endl;
　　在iostream文件头中定义的类有
ios,istream,ostream,iostream,istream_withassign,ostream_withassign,iostream_withassign
等。
　
　因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字
相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用
了多年的伪标准库中的功能，他们都是在全局空间下的。 
　　所以就有了<iostream.h>和<iostream>等等这样
的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。
　　命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不
加".h"
2.
C++ 模板基础谈 
1. 什么是模板 
模板定义：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参
数，从而实现了真正的代码可重用性。 
我们知道，C++ 
是一种“强类型”的语言，也就是说一个变量，编译器必须确切的知道它的类型，而模板就是构建在这个强类型语言基础上的泛型系统。 
2. 模板的语法 
模板函数 
template < typename {类型参数名称}, [ int 
{Name}=...][, ...] > 
{函数定义} 
模板类 
template < typename ... , [ int 
{Name}=...] > 
class ... 
模板的参数可以是类型，或者是一个 int 型的值（或者可以转换为int 型的，比如 
bool）。 
3. 模板的使用 
显式类型参数：对于模板函数，在函数名后添加 < {类型参数表} 
>。对于模板类，在类后添加 < {类型参数表} > 
隐式类型参数：对于模板函数，如果类型参数可以推导，那么可以省略类型参数表 
举个例子: 
template < typename T > 
T max( T a, T b ) 
{ 
return a < b ? b : a; 
} 
这个 max 函数就是一个模板函数，它可以传入一个 
“类型”的参数，以便实现任意类型求最大值的效果。假设我们这样使用它： 
int x=5, y=10; 
int z=max <int>( x, y ); 
这时候发生了什么呢？我们传入的“类型参数”是int，因此编译器在编译这段代码时会使用 
int 来构造一个新函数： 
int max( int a, int b ) 
{ 
return a < b ? b : a; 
} 
后面的事就和编译普通的函数一样了，C++编译器继续使用强类型系统编译这个函数，由强类型
系统来检查这个函数是否正确。 
这个过程叫做模板的“特化”，它发生在编译期，当编译器发现模板函数、模板类被使用（注意，
不是定义）的时候进行的。这个系统实际上比较像宏，但是比宏更为智能。 
很明显，编译器必须知道模板如何特化这个函数，因此模板函数的实现，必须在“使用点”之前，
因此模板库只能通过头文件库的形式来提供。 
6. 模板的偏特化 
如果我们打算给模板函数（类）的某个特定类型写一个函数，就需要用到模板的偏特化，比如我们
打算用 long 类型调用 max 的时候，返回小的值（原谅我举了不恰当的例子）： 
template <> // 这代表了下面是一个模板函数 
long max <long>( long a, long b ) // 
对于 vc 来说，这里的 <long> 是可以省略的 
{ 
return a > b ? b : a; 
} 
实际上，所谓偏特化，就是代替编译器完成了对指定类型的特化工作，现代的模板库中，大量的使
用了这个技巧。 
7. 仿函数 
仿函数这个词经常会出现在模板库里（比如 STL），那么什么是仿函数呢？ 
以上摘自： http://haofu123.blog.163.com/blog/static/1782949200910103422303/
**http://www.bianceng.cn/Programming/cplus/201006/17937.htm**
## C++中的模板(template)
---------------------------------------------------------------------------------------------------
# [关于inline函数的使用](http://blog.ednchina.com/xiaomifengxxxx/431137/message.aspx#)
一、inline函数(摘自C++ Primer的第三版)
　　避开函数调用开销：
　　函数调用需要时间和空间开销，调用函数实际上将程序执行流程转移到被调函数中，被调函数的代码执行完后，再返回到调用的地方。这种调用操作要求调用前保护好现场并记忆执行的地址，返回后恢复现场，并按原来保存的地址继续执行。对于较长的函数这种开销可以忽略不计，但对于一些函数体代码很短，又被频繁调用的函数，就不能忽视这种开销。引入内联函数正是为了解决这个问题，提高程序的运行效率。
　　在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。由于在编译时将内联函数体中的代码替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间开销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省
        总结：inline函数是提高运行时间效率，但却增加了空间开销。即inline函数目的是：为了提高函数的执行效率(速度)。
非内联函数调用有栈内存创建和释放的开销。
　　在C中可以用宏代码提高执行效率，宏代码不是函数但使用起来像函数，编译器用复制宏代码的方式取代函数调用，省去了参数压栈、生成汇编语言的CALL调用、返回参数、执行return等过程，从而提高速度。
        使用宏的缺点：
　　(1)容易出错(预处理器在复制宏代码时常常产生意想不到的边际效应)，例如：
　　#define MAX(a,b)    (a)>(b)?(a):(b)
　　语句result = MAX(i,j) + 2 却被扩展为
　　result = (i)>(j)?(i):(j)+2;
　　但意却为result = ((i)>(j)?(i):(j)) + 2;
　　(2)不可调试
　　(3)无法操作类的私有数据成员
　　如下所示，在函数声明或定义中函数返回类型前加上关键字inline即把min()指定为内联。
inline int min(int first, int secend) {/****/};
        inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。对于由两个文件compute.C和draw.C构成的程序来说，程序员不能定义这样的min()函数，它在compute.C中指一件事情，而在draw.C中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为。
        为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。
二、内联函数的编程风格(摘自高质量C++/C 编程指南)
　　关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。
　　如下风格的函数Foo不能成为内联函数：
inline void Foo(int x, int y); // inline 仅与函数声明放在一起
void Foo(int x, int y)
{
}
　　而如下风格的函数Foo 则成为内联函数：
void Foo(int x, int y);
inline void Foo(int x, int y) // inline 与函数定义体放在一起
{
}
　　所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。
定义在类声明之中的成员函数将自动地成为内联函数，例如
class A
{
public:
　　void Foo(int x, int y) {  } // 自动地成为内联函数
}
　　将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：
// 头文件
class A
{
public:
　　void Foo(int x, int y)；
}
// 定义文件
inline void A::Foo(int x, int y)
{
}
　　慎用内联
　　内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？
　　如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？
　　内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
　　(1)如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
　　(2)如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
　　类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。
　　一个好的编译器将会根据函数的定义体，自动地取消不值得的内联(这进一步说明了inline 不应该出现在函数的声明中)。
本文来自CSDN博客，转载请标明出处：
[http://blog.csdn.net/zlf0727/archive/2008/09/14/2848391.aspx](http://blog.csdn.net/zlf0727/archive/2008/09/14/2848391.aspx)
**C++ 语言支持函数内联****，其目的是为了提高函数的执行效率（速度）**
在C程序中，可以用宏代码提高执行效率。宏代码本身不是函数，但使用起来象函数。
预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的CALL调用、 
返回参数、执行return等过程，从而提高了速度。 
使用宏代码最大的缺点是容易出错，预处理器在复制宏代码时常常产生意想不到的边际效应。 
对于C++ 而言，使用宏代码还有另一种缺点：无法操作类的私有数据成员。 
让我们看看C++ 的"函数内联"是如何工作的。 
对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。 
如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。 
在调用一个内联函数时，编译器首先检查调用是否正确 
（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。 
如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。
这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。 
假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。 
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。 
所以在C++ 程序中，应该用内联函数取代所有宏代码，"断言assert"恐怕是唯一的例外。 
assert是仅在Debug版本起作用的宏，它用于检查"不应该"发生的情况。 
为了不在程序的Debug版本和Release版本引起差别，assert不应该产生任何副作用。 
如果assert是函数，由于函数调用会引起内存、代码的变动，那么将导致Debug版本与Release版本存在差异。 
所以assert不是函数，而是宏。
---------------------------------
作者：[cilluick](http://bbs.pfan.cn/member.asp?name=cilluick)      发表时间：2008-11-19 19:23:00
**第9楼  **
class A{
void show()//这个函数就是inline函数
{
...........
}
void printa();
};
void A::printa()//这个不叫inline函数
{
}
如果换成
inline void A::printa()//这时为inline函数
{
}
