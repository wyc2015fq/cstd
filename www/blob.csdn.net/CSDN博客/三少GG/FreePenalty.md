# FreePenalty - 三少GG - CSDN博客
2013年01月31日 14:44:35[三少GG](https://me.csdn.net/scut1135)阅读数：814
个人分类：[重构Java](https://blog.csdn.net/scut1135/article/category/621771)
                
Eclipse批量改包名
 1.在把eclipse的目录切换到Package Explorer，然后，在其中对应的包上右键，选择Refactor--->Rename，在打开的Rename对话框中，还可以进行选择一些选项，这样，就可以更改包名了。然后，使用同样的方法修改类名。感觉效果不错。
    2.另外，还有可能会替换一些名称，如果时整个项目替换，可以使用eclipse的Search----->file，然后在其中设置替换条件，感觉比较好的是有区分大小写和正则表达式的功能；如果对个文件替换，可以打开这个文件，然后，按<ctul>+F，这样弹出个对话框，我们可以选择区分大小写替换和全部替换，这样可以很快完成任务了。效果同样不错。
### [Eclipse 包视图折叠](http://lippeng.iteye.com/blog/632849)
在Eclipse中，如果包多了，包名前面又完全一样，找具体哪个包很慢，很累，很不方便。
     Eclipse当然有好的办法，那就是包视图折叠。
    首先，先确认，你现在用的是包视图Package Explorer。
![Package Explorer](http://dl.iteye.com/upload/attachment/229344/d47f6195-ddb4-3aae-ae4d-3e96ecc6912e.jpg)
       如果不是，Window =》Show View =》 Other =》Package Exporer 来打开包视图
    第二步，也是最后的一步，在包视图的右上角，有个倒三角号，点击它=>Package Presentation=》Hierarchical
    看下，现在是不是可以了
/////////////////////////////////////////////////////////////
## [正则表达式--笔记与实战(Eclipse文本替换）](http://blog.sina.com.cn/s/blog_4560e10e0101eckf.html)
## java替换注释正则表达式
由于公司软件要申请版权，要求去掉注释，写了两个个正则表达式
**去掉（eclipse）----------------/\*(.|[\r\n])*?\*/**
去掉//（eclipse）------------------ //.*$
去掉import（eclipse）------------ import.*$
去掉空行（ue） ------%[ ^t]++^p
第一个正则表达式参考这个
[http://ostermiller.org/findcomment.html](http://ostermiller.org/findcomment.html)
Finding Comments in Source Code Using Regular Expressions
## 入门
\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**。
如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。
假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。若要匹配"A
 B"，则使用A\sB或者A\b\s\bB等。表达式
 ".\b."
 在匹配 "@@@abc" 时，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。表达式"\bend\b"
 在匹配 "weekend,endfor,end" 时，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18。
这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。?匹配重复零次或一次。
## 元字符
\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。
对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。
和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。
## 分枝条件
\(?0\d{2}[) -]?\d{8}。
“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。
这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。
不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：
0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。
\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。
\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。
## 反义
|代码/语法|说明|
|----|----|
|\W|匹配任意不是字母，数字，下划线，汉字的字符|
|\S|匹配任意不是空白符的字符|
|\D|匹配任意非数字的字符|
|\B|匹配不是单词开头或结束的位置|
|[^x]|匹配除了x以外的任意字符|
|[^aeiou]|匹配除了aeiou这几个字母以外的任意字符|
例：]+>匹配用尖括号括起来的以a开头的字符串。
## 分组与后向引用
可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了。例如：描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，分组0对应整个正则表达式。后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go
 go, 或者kitty kitty。
实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号，你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。
你也可以自己指定子表达式的**组名**。(?\w+)(或者把尖括号换成'也行：(?'Word'\w+))，这样就把\w+的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用\k,所以上一个例子也可以写成这样：\b(?\w+)\b\s+\k\b。
使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：
|分类|代码/语法|说明|
|----|----|----|
|(exp)|匹配exp,并捕获文本到自动命名的组里| |
|(?exp)|匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)| |
|(?:exp)|匹配exp,不捕获匹配的文本，也不给此分组分配组号| |
|(?=exp)|匹配exp前面的位置| |
|(?<=exp)|匹配exp后面的位置| |
|(?!exp)|匹配后面跟的不是exp的位置| |
|(?|匹配前面不是exp的位置| |
|(?#comment)|这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读| |
## 零宽断言
断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm
 singing while you're dancing.时，它会匹配sing和danc。\b(?=\w{7}\b)\w*clip\w*\b，匹配包含clip的七个字符的单词。
(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading
 a book时，它匹配ading。
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。
下面的例子同时使用了这两种断言：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。
^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]$ 匹配 由数字和字母组成的字符串，不能全是字母或数字。
## 负向零宽断言
前面我们提到过怎么查找**不是某个字符或不在某个字符类里**的字符的方法(反义)。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：
\b\w*q[^u]\w*\b匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq**,**Benq**，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq
 fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
同理，我们可以用(?,零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?
分享：
