# 时间消耗分析-gprof - 三少GG - CSDN博客
2013年10月31日 23:22:25[三少GG](https://me.csdn.net/scut1135)阅读数：1823
程序分析工具gprof介绍
程序分析是以某种语言书写的程序为对象，对其内部的运作流程进行分析。程序分析的目的主要有三点：一是通过程序内部各个模块之间的调用关系，整体上把握程序的运行流程，从而更好地理解程序，从中汲取有价值的内容。二是以系统优化为目的，通过对程序中关键函数的跟踪或者运行时信息的统计，找到系统性能的瓶颈，从而采取进一步行动对程序进行优化。最后一点，程序分析也有可能用于系统测试和程序调试中。当系统跟踪起来比较复杂，而某个BUG又比较难找时，可以通过一些特殊的数据构造一个测试用例，然后将分析到的函数调用关系和运行时实际的函数调用关系进行对比，从而找出错误代码的位置。
程序分析工具不同于调试器，它只产生程序运行时某些函数的调用次数、执行时间等等宏观信息，而不是每条语句执行时的详细信息。Gprof是Linux下一个强有力的程序分析工具。对于C、Pascal或者Fortran77语言的程序，它能够以“日志”的形式记录程序运行时的统计信息：程序运行中各个函数消耗的时间和函数调用关系，以及每个函数被调用的次数等等。从而可以帮助程序员找出众多函数中耗时最多的函数，也可以帮助程序员分析程序的运行流程。相信这些功能对于分析开源代码的程序员来说，有着相当大的诱惑力。
## 用gprof分析程序
用gprof对程序进行分析主要分以下三个步骤：
l         用编译器对程序进行编译，加上-pg参数。
l         运行编译后的程序。
l         用gprof命令查看程序的运行时信息。
先以一个简单的例子演示一下吧。随便找一个能够运行的程序的源代码，比如下面的文件test.c：
 1
 2int IsEven(int x)
 3
 4{
 5
 6return0== x &1;
 7
 8}
 9
10int main(int argc, char*argv[]
11
12{
13
14int i =0;
15
16while(++i <1000) IsEven(i);
17
18}
首先，用以下命令进行编译：
       [root@localhost]#gcc –o test –pg test.c
然后，运行可执行文件test.
       [root@localhost]#./test
运行后，在当前目录下将生成一个文件gmon.out，这就是gprof生成的文件，保存有程序运行期间函数调用等信息。
最后，用gprof命令查看gmon.out保存的信息：
       [root@localhost]#gprof test gmon.out –b
这样就有一大堆信息输出到屏幕上，有函数执行单间，函数调用关系图等等，如下：
Flat profile:
Each sample counts as 0.01 seconds.
 no time accumulated
  %   cumulative   self              self     total          
 time   seconds   seconds    calls  Ts/call  Ts/call  name   
  0.00      0.00     0.00     1000     0.00     0.00  IsEven(int)
                     Call graph
granularity: each sample hit covers 2 byte(s) no time propagated
index % time    self  children    called     name
                0.00    0.00    1000/1000        main [7]
[8]      0.0    0.00    0.00    1000         IsEven(int) [8]
-----------------------------------------------
Index by function name
   [8] IsEven(int)
以上介绍了gprof最简单的使用方法，下面针对其使用过程中的三个步骤详细说明。
## 编译和链接
上面的例子中，程序比较简单，只有一个文件。如果源代码有多个文件，或者代码结构比较复杂，编译过程中先生成若干个目标文件，然后又由链接器将这些目标文件链接到一起，这时该怎么使用gprof呢？
对于由多个源文件组成的程序，编译时需要在生成每个.o文件的时候加上-pg参数，同时在链接的时候也要加上-pg参数。对于链接器不是GCC的情况，如ld，又有特殊的要求。
同时，-pg参数只能记录源代码中各个函数的调用关系，而不能记录库函数的调用情况。要想记录每个库函数的调用情况，链接的时候必须指定库函数的动态（或者静态）链接库libc_p.a，即加上-lc_p，而不是-lc。
还要说明的是，如果有一部分代码在编译时指定了-pg参数，而另一部分代码没有指定，则生成的gmon.out文件中将缺少一部分函数，也没有那些函数的调用关系。但是并不影响gprof对其它函数进行记录。
## 运行
编译好的程序运行时和运行一般的程序没有什么不同，只是比正常的程序多生成了一个文件gmon.out。注意，这个文件名是固定的，没法通过参数的设置进行改变。如果程序目录中已经有一个gmon.out，则它会被新的gmon.out覆盖掉。
关于生成的gmon.out文件所在的目录，也有以下约定：程序退出时所运行的文件所在目录就是生成的gmon.out文件所在的目录。如果一个程序执行过程中调用了另一个程序，并在另一个程序的运行中终止，则gmon.out会在另一个程序所在的目录中生成。
**还有一点要注意的就是当程序非正常终止时不会生成gmon.out文件，也因此就没法查看程序运行时的信息。只有当程序从main函数中正常退出，或者通过系统调用exit()函数而退出时，才会生成gmon.out文件。而通过底层调用如_exit()等退出时不会生成gmon.out。**
## 查看
查看程序运行信息的命令是gprof，它以gmon.out文件作为输入，也就是将gmon.out文件翻译成可读的形式展现给用户。其命令格式如下：
       gprof [可执行文件] [gmon.out文件] [其它参数]
方括号中的内容可以省略。如果省略了“可执行文件”，gprof会在当前目录下搜索a.out文件作为可执行文件，而如果省略了gmon.out文件，gprof也会在当前目录下寻找gmon.out。其它参数可以控制gprof输出内容的格式等信息。最常用的参数如下：
l         -b 不再输出统计图表中每个字段的详细描述。
l         -p 只输出函数的调用图（Call graph的那部分信息）。
l         -q 只输出函数的时间消耗列表。
l         -e Name 不再输出函数Name 及其子函数的调用图（除非它们有未被限制的其它父函数）。可以给定多个 -e 标志。一个 -e 标志只能指定一个函数。
l         -E Name 不再输出函数Name 及其子函数的调用图，此标志类似于 -e 标志，但它在总时间和百分比时间的计算中排除了由函数Name 及其子函数所用的时间。
l         -f Name 输出函数Name 及其子函数的调用图。可以指定多个 -f 标志。一个 -f 标志只能指定一个函数。
l         -F Name 输出函数Name 及其子函数的调用图，它类似于 -f 标志，但它在总时间和百分比时间计算中仅使用所打印的例程的时间。可以指定多个 -F 标志。一个 -F 标志只能指定一个函数。-F 标志覆盖 -E 标志。
l         -z 显示使用次数为零的例程（按照调用计数和累积时间计算）。
不过,gprof不能显示对象之间的继承关系,这也是它的弱点.
## C++的性能优化实践
作者: [大CC](http://blog.me115.com/author/me115wp) 日期:
 2013 年 6 月 1 日[发表评论](http://blog.me115.com/2013/06/312#respond)暂无评论[查看评论](http://blog.me115.com/2013/06/312#comments)
### 内容目录
- [1 Gprof](http://blog.me115.com/2013/06/312#h20)
- [2. gprof使用步骤](http://blog.me115.com/2013/06/312#h21)
- [1.初始化大对象耗时](http://blog.me115.com/2013/06/312#h22)
- [2.Map使用不当](http://blog.me115.com/2013/06/312#h23)
# 优化准则：
1. 二八法则：在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%的尽管是多数，却是次要的；在优化实践中，我们将精力集中在优化那20%最耗时的代码上，整体性能将有显著的提升；
这个很好理解。函数A虽然代码量大，但在一次正常执行流程中，只调用了一次。而另一个函数B代码量比A小很多，但被调用了1000次。显然，我们更应关注B的优化。
2. 编完代码，再优化；编码的时候总是考虑最佳性能未必总是好的；在强调最佳性能的编码方式的同时，可能就损失了代码的可读性和开发效率；
# 工具：
## 1 Gprof
工欲善其事，必先利其器。对于Linux平台下C++的优化，我们使用gprof工具。
gprof是GNU profile工具，可以运行于linux、AIX、Sun等操作系统进行C、C++、Pascal、Fortran程序的性能分析，用于程序的性能优化以及程序瓶颈问题的查找和解决。通过分析应用程序运行时产生的“flat profile”，可以得到每个函数的调用次数，消耗的CPU时间（只统计CPU时间，对IO瓶颈无能为力），也可以得到函数的“调用关系图”，包括函数调用的层次关系，每个函数调用花费了多少时间。
## 2. gprof使用步骤
1)    用gcc、g++、xlC编译程序时，使用-pg参数，如：g++ -pg -o test.exe test.cpp
编译器会自动在目标代码中插入用于性能测试的代码片断，这些代码在程序运行时采集并记录函数的调用关系和调用次数，并记录函数自身执行时间和被调用函数的执行时间。
2)    执行编译后的可执行程序，如：./test.exe。该步骤运行程序的时间会稍慢于正常编译的可执行程序的运行时间。程序运行结束后，会在程序所在路径下生成一个缺省文件名为gmon.out的文件，这个文件就是记录程序运行的性能、调用关系、调用次数等信息的数据文件。
3)    使用gprof命令来分析记录程序运行信息的gmon.out文件，如：gprof test.exe gmon.out则可以在显示器上看到函数调用相关的统计、分析信息。
上述信息也可以采用gprof test.exe gmon.out> gprofresult.txt重定向到文本文件以便于后续分析。
以上只是gpro的使用步骤简介，关于gprof使用实例详见附录1；
[](http://blog.chinaunix.net/uid-25194149-id-3215487.html)
# 实践
我们的程序遇到了性能瓶颈，在采用架构改造，改用内存数据库之前，我们考虑从代码级入手，先尝试代码级的优化；
通过使用gprof分析，我们发现以下2个最为突出的问题：
## 1.初始化大对象耗时
分析报告：307   6.5% VOBJ1::VOBJ1@240038
VOBJ1在整个执行流程中被调用307次，其对象初始化耗时占到6.5%。
这个对象很大，包含的属性多，属于基础数据结构；
　　在程序进入构造函数函数体之前，类的父类对象和所有子成员变量对象已经被生成和构造。如果在构造函数体内位其执行赋值操作，显示属于浪费。如果在构造函数时已经知道如何为类的子成员变量初始化，那么应该将这些初始化信息通过构造函数的初始化列表赋予子成员变量，而不是在构造函数函数体中进行这些初始化。因为进入构造函数函数体之前，这些子成员变量已经初始化过一次了。
　　在C++程序中，创建/销毁对象是影响性能的一个非常突出的操作。首先，如果是从全局堆中生成对象，则需要首先进行动态内存分配操作。众所周知，动态分配/回收在C/C++程序中一直都是非常耗时的。因为牵涉到寻找匹配大小的内存块，找到后可能还需要截断处理，然后还需要修改维护全局堆内存使用情况信息的链表等。
      解决方法：我们将大部分的初始化操作都移到初始化列表中，性能消耗降到1.8%。
## 2.Map使用不当
分析报告：89   6.8% Recordset::GetField
Recordset的getField被调用了89次，性能消耗占到6.8%;
Recordset是我们在在数据库层面的包装，对应取出数据的记录集；（用过ADO的朋友很熟悉）；
由于我们使用的是底层c++数据库接口，通过对数据库原始api进行一层包装，从而屏蔽开发人员对底层api的直接操作。这样的包装，带来的好处就是不用直接与底层数据库交互，在代码编写方面方便不少，代码可读性也很好；带来的问题就是性能的损失；
分析：（2点原因）
1）在GetField函数中，使用了map[“a”]来查询数据，如果找不到“a”，则map会自动插入key ”a”，并设value为0；而m.find(“a”)不会自动插入上述pair，执行效率更高；
原有逻辑：
```cpp
string Recordset::GetField(const string &strName)
{
    int nIndex;
    if (hasIndex==false)
    {
        nIndex = m_nPos;
    }
    else
    {
        nIndex = m_vSort[m_nPos].m_iorder;
    }
    if (m_fields[strName]==0)
    {
        LOG_ERR("Recordset::GetField:"<<strName<<" Not Find!!");
    }
    return m_records[nIndex].GetValue(m_fields[strName] - 1) ;
}
```
改造后的逻辑：
```cpp
string Recordset::GetField(const string &strName)
{
    unordered_map<string, int>::iterator iter = m_fields.find(strName);
    if (iter == m_fields.end())
    {
        LOG_ERR("[Recordset::GetField] "<< strName <<" Not Find!!");
    }
    int nIndex = hasIndex ? m_vSort[m_nPos].m_iorder : m_nPos;
    return m_records[nIndex].GetValue(iter->second - 1) ;
}
```
调整后的Recordset::GetField的执行时间约是之前的1/2；且易读性更高；
2）在Recordset中，对于每个字段的存储，使用的是map<string, int> m_fields;  g++中的stl标准库中默认使用的红黑树作为map的底层数据结构；
通过附录中的文档2，我们发现其实有更快的结构，
在效率上，unorder map优于hash map, hash map 优于 红黑树；
如果不要求map有序，unordered_map 是更好的选择；
解决方法：将map结构换成unordered_map，性能消耗降到1.4%；
# 总结
我们修改不到30行代码，整体性能提升10%左右，效果明显；
打蛇打七寸，性能优化的关键在于找准待优化的点，之后的事，也就水到渠成；
by the way，对于Linux平台使用C++工作的朋友，推荐一本好书：《[程序员的自我修养](http://www.me115.com/book/196.html)》。这本书介绍了运行库相关的各种技术。
 对装载、链接和库进行了深入浅出的剖析。看过真是大呼过瘾；
[《程序员的自我修养》](http://www.me115.com/book/196.html)
# 附录：
附1：[prof工具介绍及实践](http://blog.chinaunix.net/uid-25194149-id-3215487.html)
附2： [map
 hash_map unordered_map 性能测试](http://blog.chinaunix.net/uid-20384806-id-3055333.html)
