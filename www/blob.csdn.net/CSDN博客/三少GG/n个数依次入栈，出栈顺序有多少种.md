# n个数依次入栈，出栈顺序有多少种 - 三少GG - CSDN博客
2012年11月03日 15:45:20[三少GG](https://me.csdn.net/scut1135)阅读数：1336
个人分类：[重构C/C++](https://blog.csdn.net/scut1135/article/category/621651)
//Grant 推荐博客
- [2012百度笔试题](http://blog.csdn.net/lcytrl/article/category/1140974)(2)
- [杂文](http://blog.csdn.net/lcytrl/article/category/1141785)(3)
- [排序](http://blog.csdn.net/lcytrl/article/category/1143549)(2)
- [阅读](http://blog.csdn.net/lcytrl/article/category/1148407)(1)
- [C语言](http://blog.csdn.net/lcytrl/article/category/1149306)(18)
- [C/C++](http://blog.csdn.net/lcytrl/article/category/1217540)(23)
- [算法/数据结构](http://blog.csdn.net/lcytrl/article/category/1251576)(6)
n个数依次入栈，出栈顺序有多少种？ 
这个问题是卡特兰数的第n项结果。
卡特兰数
　　卡特兰数前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...
令h(0)=1,h(1)=1，catalan数满足递推式：　　h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
　　例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2 
　　h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5 
　　另类递推式：　　h(n)=h(n-1)*(4*n-2)/(n+1); 
　　递推关系的解为： 
　　h(n)=C(2n,n)/(n+1) (n=1,2,3,...) 
　　递推关系的另类解为： 
　　h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...) 
**      常规分析**
　　首先，我们设f（n）=序列个数为n的出栈序列种数。同时，我们假定第一个出栈的序数是k。 
　　第一个出栈的序数k将1~n的序列分成两个序列，其中一个是1~k-1，序列个数为k-1，另外一个是k+1~n，序列个数是n-k。 
　　此时，我们若把k视为确定一个序数，那么根据乘法原理，f（n）的问题就等价于——序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的f（n）=f（k-1）×f（n-k）。而k可以选1到n，所以再根据加法原理，将k取不同值的序列种数相加，得到的总序列种数为：f（n）=f（0）f（n-1）+f（1）f（n-2）+……+f（n-1）f（0）。
　　看到此处，再看看卡特兰数的递推式，答案不言而喻，即为f（n）=h（n）= C（2n,n）/（n+1）= c（2n,n）-c（2n,n+1）（n=1，2，3，……）。
　　最后，令f（0）=1，f（1）=1。 
**　　非常规分析 **
　　对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。
　　在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。
　　不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。
　　反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。
　　因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。 
　　显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n+1)。 
**类似问题 买票找零 **
　　有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈)
**最终结果：C(2n,n)-C(2n,n+1)**
