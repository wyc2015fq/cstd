# 关于堆、栈和堆栈 - 三少GG - CSDN博客
2012年02月22日 19:42:48[三少GG](https://me.csdn.net/scut1135)阅读数：687
初学者在看书的时候会经常看到堆、栈、堆栈这几个词，也许大概知道他们是用来表示变量或对象在内存中存储的一块区域。下面说说他们的含义和区别：
Java把内存划分成两种：一种是栈内存，一种是堆内存。
在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。
当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。
堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
栈（stack）
     JVM是基于栈（stack）的，程序中大量的局部变量都存储在栈中，以便快速地访问。学过数据结构的都知道， 栈是先进后出（FILO:First In,Last Out），我们只能访问最上面的数据。它在内存中是从高地址到低地址扩展的。
堆（heap）
    程序中的new出来的对象都是放在heap中的，但对象的引用是放在stack中的。它和栈的区别在于堆是先进先出，只能访问最下面的数据。它在内存中是从低地址到高地址扩展的。
而我们说“堆栈”的时候，一般就是指栈的意思。
**关于new、delete和堆的一些理解**
先看以下的两个简单的程序：
第一：
//////////Visula C++ 6.0环境
#include<iostream.h>
void main()
{
int a=3;
int *p=new int;
p=&a;
cout<<*p<<endl;
delete p; /////////有错误
}
第二：
//////////Visual C++ 6.0环境
#include<iostream.h>
void main()
{
int a=3;
int *p=new int;
*p=a;
cout<<*p<<endl;
delete p;
}
其中第一个程序存在错误（会生成.exe文件，但是运行有错误）
问题出在对new和delete、堆不是很了解。
而第二个程序是正确的。
现在我来分析一下：
int *p=new int;
是在heap分配一个int型的空间，而p是在stack里的一个指针，它指向heap里的那个int，
在程序结束的时候，p指针将释放掉，所以要在程序结束的时候delete p,这是为了释放在
heap里分配的那个int，否者会造成heap区空间的泄漏，这是很严重的。
第一个程序中的：
p=&a;
它把a的地址赋给p，这时p指的是a，而不是heap里的那个int了，后来
delete p;
这是想删除p指向的内容，**但是此时p指向的stack里的a了，而delete是不能用于stack的数据的，所以出现了错误。**
第二个程序中的：
*p=a;
这只是将a的值赋给p指向的那个int，此时p还是指向heap里的int，
所以这里的
delete p；
是合法的了，不会出现错误。 
++++++++++++++++++
　　一个由C/C++编译的程序占用的内存分为以下几个部分
　　1、栈区（stack）— 由[编译器](http://baike.baidu.com/view/487018.htm)自动分配释放
 ，存放[函数](http://baike.baidu.com/view/15061.htm)的参数值，[局部变量](http://baike.baidu.com/view/552847.htm)的值等。其操作方式类似于数据结构中的栈。
　　2、堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于[链表](http://baike.baidu.com/view/549479.htm)。
　　3、全局区（静态区）（static）— 全局变量和[静态变量](http://baike.baidu.com/view/675642.htm)的存储是放在一块的，初始化的[全局变量](http://baike.baidu.com/view/261041.htm)和静态变量在一块区域，
 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
　　4、文字常量区 — 常量字符串就是放在这里的，程序结束后由系统释放 。
　　5、程序代码区— 存放函数体的二进制代码。
**1.申请方式　**
　　stack:
　　由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
　　heap:
　　需要程序员自己申请，并指明大小，在c中[malloc函数](http://baike.baidu.com/view/1213621.htm)
　　如p1 = (char *)malloc(10);
　　在C++中用new运算符
　　如p2 = new char[20];//(char *)malloc(10);
　　但是注意p1、p2本身是在栈中的。
### 2.申请后系统的响应
　　栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
　　堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
5.堆和栈中的存储内容　
　　栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
　　当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶[指针](http://baike.baidu.com/view/159417.htm)指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
　堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
7.小结：　
　　堆和栈的区别可以用如下的比喻来看出：
　　使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
　　使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
　操作系统方面的堆和栈，如上面说的那些，不多说了。
　　还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先[队列](http://baike.baidu.com/view/38959.htm)的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足后进先出的性质的数学或数据结构。
　　虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。
