# 凸包及其在ACM算法中的应用 - 三少GG - CSDN博客
2012年10月16日 01:52:32[三少GG](https://me.csdn.net/scut1135)阅读数：2207
漫话二维凸包
[http://221.179.130.210:83/1Q2W3E4R5T6Y7U8I9O0P1Z2X3C4V5B/read.pudn.com/downloads48/ebook/164515/geometry.pdf](http://221.179.130.210:83/1Q2W3E4R5T6Y7U8I9O0P1Z2X3C4V5B/read.pudn.com/downloads48/ebook/164515/geometry.pdf)
**1.  Graham**
![](https://img-my.csdn.net/uploads/201210/16/1350323656_3360.jpg)
**2.  贾维斯的礼物**
1984 年，贾维斯（Jarvis）带来了一个求凸包的新算法，算法的执行过程就
是像在包礼物，在所有凸包算法中，这个算法似乎最容易理解。
![](https://img-my.csdn.net/uploads/201210/16/1350323554_5207.jpg)
**3. Melkman**
![](https://img-my.csdn.net/uploads/201210/16/1350323521_9443.jpg)
今天看了蓝点大牛的 "漫话二维凸包",真是受益匪浅! 
下面说说偶的收获: 
     "左转判定" :  这一思想在凸包算法里十分的重要. 而如何判断两个向量 p1=(x1,y1) 和 p2=(x2,y2) 是否左转,非常简单的只需判断 x1*y2-x2*y1 的正负值,为正说明 p1 到 p2 为左转. 其实就是判断一个向量到另一个向量是逆时针转还是顺时针转 ^_^ 
     凸包算法---留下两个印象深刻的算法: 
    (一) 格拉翰算法: 
           1. 将各点排序（按横坐标排序），为保证形成圈，把P0在次放在点表的尾部； 
           2. 准备堆栈：建立堆栈S，栈指针设为t，将0、1、2三个点压入堆栈S； 
           3. 对于下一个点 i 只要S[t-1]、S[t]、i 不做左转 就反复退栈；将i压入堆栈S 
           4. 堆栈中的点即为所求凸包； 
          补充说明下排序的方法: 1.找一个必在凸包上的点（这很容易^_^，通常『嶙昊蜃葑曜钚〉牡悖俏狿0   2.连结P0与其他点，分别计算这些线段与“竖直向下方向”的夹角，按照夹角由小到达的顺序将各线段的另一端（一端是P0）标号为P1、P2、P3…… 
          这个算法十分简练,(人懒没办法..只想看简单的方法^_^) 实现只需短短几段代码: 
   t=-1; 
   s[++t]=0; s[++t]=1; s[++t]=2; 
   for (i=3;i<n;i++) 
   { 
       while (!left(s[t-1],s[t],i)) 
           t--; 
       s[++t]=i; 
   } 
         算法的复杂度为O(nlogn+2*n) 
    (二)Melkman算法: 
         0. 初始化：排序各点，向双头表d中装入P2,P0,P1,P2；设双头表左右指针分别为b,t； 
         1.反复做i=i+1，直到d[t+1],d[t],Pi不做左转或d**,d[b+1],Pi不做左转          2.做以下这些直到d[t+1],d[t],Pi做左转 　           t=t-1；           　将Pi从右压入d；           　做以下这些直到d**,d[b+1],Pi做左转 　           b=b+1； 　           将Pi从左压入d          这个算法区别与其他的算法的地方是: 这个是个在线算法,这是其他算法无法达到的! 看了这么多,写了这么多...不知道能不能应用到PKU2519..SIGH好弱... 好像算法2还可以用... 愿上天保佑~~****
