# C++“读取位置 0x****** 时发生访问冲突”的可能原因 - 三少GG - CSDN博客
2010年12月10日 01:42:00[三少GG](https://me.csdn.net/scut1135)阅读数：19063标签：[c++																[byte																[null																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=byte&t=blog)](https://so.csdn.net/so/search/s.do?q=c++&t=blog)
个人分类：[重构C/C++](https://blog.csdn.net/scut1135/article/category/621651)
这种错误的意思一般是指访问了不属于自己的内存空间，出现这种错误有几种原因：
1、给一个数组分配了比较小的内存空间，然后又给该数组赋了一个比较大的值，举例说明：
Cpp代码 
- char buf[80];  
- buf = "C++“读取位置 0x****** 时发生访问冲突”的可能原因C++“读取位置 0x****** 时发生访问冲突”的可能原因";  
解决方法：给数组分配更大一些的内存空间，如char buf[1000];
2、句柄或指针在使用前被释放
解决方法：检查代码配合调试，揪出野指针
==========================================================================
0xC0000005: 读取位置 0x000df02d 时发生访问冲突
2009-04-08 17:17
    这个错误，我TM找了快一周，终于在今天找到了，原因很简单，但很不容易找，是因为我malloc了一块内存（1000byte），然后我去读文件用的是 ReadFile(hFile,pStr**,fileLength,**&dwByteRead,NULL);，这句话有错吗？咋一看上去没错呢，但仔细一看这地方就是有错，如果fileLength>1000,会有什么结果呢？ 总所周知，malloc是在堆上分配的空间，如果ReadFile读成功了，那么会在malloc（1000）以后的（fileLength-1000）的堆上写数据，下一回，如果你用malloc或new在堆上分配内存是他就会出错啦。
    就这一个小小的错误，郁闷了快一周，今天解决了，还算可以，没有太大的耽误项目工程的进展，还好还好。
    C和C++中的指针尤其优势，尤其劣势，优势很明显，灵活，方便，使用起来简单；劣势当然也很明显，就是容易导致系统崩溃，指针操作不当，或没有及时释放，或没有判断指针是否越界，或没有及时置空，这些都很容易导致系统崩溃，所以以后使用指针是一定要养成好的习惯，才能准确的使用指针。
