# 重温堆和拷贝构造函数 - SHINING的博客 - CSDN博客
2012年10月22日 09:49:59[snsn1984](https://me.csdn.net/snsn1984)阅读数：1752标签：[delete																[null																[测试																[存储																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=测试&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=delete&t=blog)
个人分类：[C++](https://blog.csdn.net/snsn1984/article/category/488621)
                
堆：
C++程序的内存格局通常分为四个区：
1.全局数据区(data area)
2.代码区(code area)
3.栈区(stack area)
4.堆区（即自由存储区）(heap area)
全局变量、静态数据、常量存放在全局数据区，所有类成员函数和非成员函数代码存放在代码区，为运行函数所分配的局部变量、函数参数、返回数据、返回地址等存放在栈区，余下的空间都被作为堆区。
C++的new\delete机制比malloc()/free()更加方便。运算符new分配堆内存，如果成功，则返回只向该内存的空间，如果失败，则返回NULL。所以每次使用运算符new动态分配内存时，都应测试new的返回指针值，以防分配失败。
从堆上分配对象数组，只能调用默认的构造函数，不能调用其他任何构造函数。
使用堆空间往往由于：
1.直到运行时才能直到需要多少对象空间；
2.不知道对象的生存期到底有多长；
3.直到运行时才知道一个对象需要多少内存空间。
拷贝构造函数：
当一个对象创建时，分配了资源，这时，就需要定义自己的拷贝构造函数，使之不但拷贝成员，也拷贝资源。也就是说，如果你的类需要析构函数来析构资源，则它也需要一个拷贝构造函数。这种情况下，对对象进行的是深拷贝。
默认拷贝构造函数对对象进行的是浅拷贝。
