# 图像旋转的原理与实现 - 李鑫o_O - CSDN博客

置顶2016年03月05日 18:25:59[hustlx](https://me.csdn.net/HUSTLX)阅读数：1985


一般图像的旋转是以图像的中心为原点，旋转一定的角度，也就是将图像上的所有像素都旋转一个相同的角度。旋转后图像的的大小一般会改变，即可以把转出显示区域的图像截去，或者扩大图像范围来显示所有的图像。图像的旋转变换也可以用矩阵变换来表示。设点![clip_image002[14]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170856862-917579321.png)逆时针旋转![clip_image004[14]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170857455-86272223.png)角后的对应点为![clip_image006[14]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170858190-1322027458.png)。那么，旋转前后点![clip_image002[15]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170858752-1025550588.png)、![clip_image006[15]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170859534-1550594331.png)的坐标分别是：

![clip_image009[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170900049-1943272216.png)                          (3-6)

![clip_image011[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170900659-1626536478.png)  (3-7)

写成矩阵表达式为

![clip_image013[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170901362-942897001.png)            (3-8)



其逆运算为

![clip_image015[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170901862-1926973201.png)            (3-9)

利用上述方法进行图像旋转时需要注意如下两点：

（1）图像旋转之前，为了避免信息的丢失，一定要有坐标平移。

（2）图像旋转之后，会出现许多空洞点。对这些空洞点必须进行填充处理，否则画面效果不好，一般也称这种操作为插值处理。

以上所讨论的旋转是绕坐标轴原点(0,0)进行的。如果图像旋转是绕一个指定点(a,b)旋转，则先要将坐标系平移到该点，再进行旋转，然后将旋转后的图象平移回原来的坐标原点，这实际上是图像的复合变换。如将一幅图像绕点(a,b)逆时针旋转![clip_image004[15]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170902502-1650151243.png)度，首先将原点平移到(a,b)，即

![clip_image018[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170903174-2020469961.png)                        (3-10)

然后旋转

![clip_image020[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170903752-1064163954.png)                 (3-11)

然后再平移回来

![clip_image022[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170904268-922718901.png)                        (3-12)

综上所述，变换矩阵为![clip_image024[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305170904862-1673447651.png)。

附录：

```
B=imread('image1.bmp');
%读取原图像
[m,n]=size(B); %获取原图尺寸w
%参数设置 
theta = pi/4;  %旋转角度
a = sin(theta);
b = cos(theta);
T = [cos(theta),sin(theta),;    %旋转矩阵
    -sin(theta),cos(theta)];
 
%建立存储空间
row=m+round((m)/2);
col=n+round((n)/2);
rotateima = zeros(row, col);  %存储旋转后图像的矩阵
 
%图像旋转         
for i=1:m                                       
    for j=1:n
        x=ceil(abs((i-round(m/2))*b-(j-round(n/2))*a+round(row/2)));  %坐标平移至中心
        y=ceil(abs((i-round(m/2))*a+(j-round(n/2))*b+round(col/2)));  %坐标平移至中心
        rotateima(x,y)=B(i,j);                   %未插值的图像
    end
end
nrotateima = uint8(rotateima);
imshow(nrotateima);
title('未插值的图像')
 
%图像插值（近邻插值法）
for i=1:row    
    for j=2:col-1       
              
            if(rotateima(i,j) == 0 && rotateima(i,j-1) ~= 0 && rotateima(i,j+1) ~= 0 )       
                rotateima(i,j) =rotateima(i,j-1) ;      
           
            end
    end
end
 
%图像显示
figure(1);
imshow(B)
title('原始图像');
% figure(2);
% imshow(nrotateima);
% title('未插值的图像');
figure(3);
imshow(rotateima/256);
imwrite(rotateima/256, '旋转后图像.jpg', 'jpg');
title('旋转图');
```


