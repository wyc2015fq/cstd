# 二叉树之中序遍历的递归和迭代实现 - 李鑫o_O - CSDN博客





2016年05月03日 13:02:16[hustlx](https://me.csdn.net/HUSTLX)阅读数：611









- 迭代 --- `O(n)` time and `O(n)` space;
- 递归 --- `O(n)` time and `O(n)` space
 ;
- Morris traversal --- `O(n)` time and `O(1)` space!!!




迭代算法：



```cpp
vector<int> inorderTraversal(TreeNode* root) {
	vector<int> res;
	std::stack<TreeNode*> stn;
	while (root || !stn.empty()) {
		while (root) {
			stn.push(root);
			root = root->left;
		}
		root = stn.top(); stn.pop();
		res.push_back(root->val);
		root = root->right;
	}
	return res;
}
```





递归实现：





```cpp
vector<int> res;
vector<int> inorderTraversal(TreeNode* root) {
	if (root) {
		inorderTraversal(root->left);
		res.push_back(root->val);
		inorderTraversal(root->right);
	}
	return res;
}
```
Morris traversal:




```cpp
vector<int> inorderTraversal(TreeNode* root) {
    TreeNode* curNode = root;
    vector<int> nodes;
    while (curNode) {
        if (curNode -> left) {
            TreeNode* predecessor = curNode -> left;
            while (predecessor -> right && predecessor -> right != curNode)
                predecessor = predecessor -> right;
            if (!(predecessor -> right)) {
                predecessor -> right = curNode;
                curNode = curNode -> left;
            }
            else {
                predecessor -> right = NULL;
                nodes.push_back(curNode -> val);
                curNode = curNode -> right;
            }
        }
        else {
            nodes.push_back(curNode -> val);
            curNode = curNode -> right;
        }
    }
    return nodes;
}
```








