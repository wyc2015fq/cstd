# c++面试常见160问 - 李鑫o_O - CSDN博客





置顶2016年03月09日 21:49:00[hustlx](https://me.csdn.net/HUSTLX)阅读数：1964








注：所有问题均来源于网络收集

1.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？

答：首先，extern是C/C++语言中表明函数和全局变量作用范围的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的。作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：void foo( int x, int y );该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。

所以，可以用一句话概括extern “C”这个声明的真实目的:解决名字匹配问题，实现C++与C的混合编程。

2.头文件中的ifndef/define/endif有什么作用？

答：这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。

3. ＃include<file.h> 与 ＃include "file.h"的区别？

答：前者是从标准库路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。

4.评价一下C/C++各自的特点

答：C语言是一种结构化语言，面向过程，基于算法和数据结构，所考虑的是如何通过一个过程或者函数从输入得到输出；

C++是面向对象，基于类、对象和继承，所考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题，通过获取对象的状态信息得到输出或实现过程控制。

5．const 有什么用途？

答：在C/C++中，a、可以定义const常量，b、修饰函数的返回值和形参；

在C++中，还可以修饰函数的定义体，定义类的const成员函数。被const修饰的东西受到强制保护，可以预防意外的变动，提高了程序的健壮性。

6．const和#define有什么区别？

答：a、const和#define都可以定义常量，但是const用途更广。

b、const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

c、 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

7．关于sizeof小结的。

答：sizeof计算的是在栈中分配的内存大小。

a、 sizeof不计算static变量占得内存；

b、 指针的大小一定是4个字节，而不管是什么类型的指针；

c、 char型占1个字节，int占4个字节，short int占2个字节

long int占4个字节，float占4字节，double占8字节，string占4字节

一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节

d、数组的长度：

若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）

若没有指定长度，则按实际元素个数类确定

Ps：若是字符数组，则应考虑末尾的空字符。

e、结构体对象的长度

在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。

f、unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4

g、 自定义类型的sizeof取值等于它的类型原型取sizeof

h、 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替

i、 sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符

j、 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸

8．sizeof与strlen的区别？

答： a、sizeof的返回值类型为size_t（unsigned int）；

b、sizeof是运算符，而strlen是函数；

c、sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；

d、数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；

e、sizeof是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小；

9．指针和引用的区别？

答：指针和引用都提供了间接操作对象的功能。

a、 指针定义时可以不初始化，而引用在定义时就要初始化，和一个对象绑定，而且一经绑定，只要引用存在，就会一直保持和该对象的绑定；

b、 赋值行为的差异：指针赋值是将指针重新指向另外一个对象，而引用赋值则是修改对象本身；

c、 指针之间存在类型转换，而引用分const引用和非const应用，非const引用只能和同类型的对象绑定，const引用可以绑定到不同但相关类型的对象或者右值

10．数组和指针的区别？

答：a、数组要么在全局数据区被创建，要么在栈上被创建；指针可以随时指向任意类型的内存块；

b、修改内容上的差别：

char a[] = “hello”;

a[0] = ‘X’;

char *p = “world”; // 注意p 指向常量字符串

p[0] = ‘X’; // 编译器不能发现该错误，运行时错误

c、用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

11.空指针和悬垂指针的区别？

答：空指针是指被赋值为NULL的指针；delete指向动态分配对象的指针将会产生悬垂指针。

a、 空指针可以被多次delete，而悬垂指针再次删除时程序会变得非常不稳定；

b、 使用空指针和悬垂指针都是非法的，而且有可能造成程序崩溃，如果指针是空指针，尽管同样是崩溃，但和悬垂指针相比是一种可预料的崩溃。

12.C++中有malloc/free，为什么还有new/delete？

答：malloc/free是C/C++标准库函数，new/delete是C++运算符。他们都可以用于动态申请和释放内存。

对于内置类型数据而言，二者没有多大区别。malloc申请内存的时候要制定分配内存的字节数，而且不会做初始化；new申请的时候有默认的初始化，同时可以指定初始化；

对于类类型的对象而言，用malloc/free无法满足要求的。对象在创建的时候要自动执行构造函数，消亡之前要调用析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制之内，不能把执行构造函数和析构函数的任务强加给它，因此，C++还需要new/delete。

13.什么是智能指针？

答：当类中有指针成员时，一般有两种方式来管理指针成员：一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。

　　智能指针的一种通用实现技术是使用引用计数。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。

　　每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

14.面向对象技术的基本概念是什么，三个基本特征是什么？

答：基本概念：类、对象、继承；基本特征：封装、继承、多态。

封装：将低层次的元素组合起来形成新的、更高实体的技术；

继承：广义的继承有三种实现形式：实现继承、可视继承、接口继承。

多态：允许将子类类型的指针赋值给父类类型的指针

15.C++空类默认有哪些成员函数？

答：默认构造函数、析构函数、复制构造函数、赋值函数

16.哪一种成员变量可以在一个类的实例之间共享？

答：static静态成员变量

17.继承层次中，为什么基类析构函数是虚函数？

答：编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

18.为什么构造函数不能为虚函数？

答：虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。

19.如果虚函数是有效的，那为什么不把所有函数设为虚函数？

答：不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。

20.构造函数可以是内联函数?

答：可以，但是一般不要使用内联，因为构造函数很多情况下会有隐含动作（比如调用基类成员对象构造函数等）。

21.什么是多态？多态有什么作用？

答：多态就是将基类类型的指针或者引用指向派生类型的对象。多态通过虚函数机制实现。

多态的作用是接口重用。

22.重载和覆盖有什么区别？

答：虚函数是基类希望派生类重新定义的函数，派生类重新定义基类虚函数的做法叫做覆盖；

重载就在允许在相同作用域中存在多个同名的函数，这些函数的参数表不同。重载的概念不属于面向对象编程，编译器根据函数不同的形参表对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。

重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。

23.公有继承、受保护继承、私有继承

答：a、公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；

b、私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；

c、保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。

d、公有继承时基类受保护的成员，可以通过派生类对象访问但不能修改。

25.有哪几种情况只能用构造函数初始化列表而不能用赋值初始化？

答：const成员，引用成员

26.什么是虚指针？

答：虚指针或虚函数指针是虚函数的实现细节。带有虚函数的每一个对象都有一个虚指针指向该类的虚函数表。

27.C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？

答：a、将类定义为抽象基类或者将构造函数声明为private；

b、不允许类外部创建类对象，只能在类内部创建对象

28.main函数执行之前会执行什么？执行之后还能执行代码吗？

答：a、全局对象的构造函数会在main函数之前执行；

b、可以，可以用_onexit 注册一个函数，它会在main 之后执行;

如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。

语法：

#include <stdlib.h>

#include <stdio.h>

int atexit(void (*function")(void));

void fn1( void ), fn2( void ), fn3( void );

int main( void )

{

atexit(fn1);

atexit( fn2 );

printf( "This is executed first.\n" );

}

void fn1()

{

printf( " This is\n" );

}

void fn2()

{

printf( " executed next." );

}

结果：

This is executed first.

This is executed next.

29.请描述进程和线程的区别？

答：a、进程是程序的一次执行，线程是进程中的执行单元；

b、进程间是独立的，这表现在内存空间、上下文环境上，线程运行在进程中；

c、一般来讲，进程无法突破进程边界存取其他进程内的存储空间；而同一进程所产生的线程共享内存空间；

d、同一进程中的两段代码不能同时执行，除非引入多线程。

30.进程间如何通信？

答：信号、信号量、消息队列、共享内存

31.在网络编程中涉及并发服务器，使用多进程与多线程的区别？

答：a、线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。

b、多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；

c、线程产生的速度快，线程间通信快、切换快；

d、线程的资源利用率比较好；

e、线程使用公共变量或者资源时需要同步机制。

32.说一下TCP 3次握手、4次挥手的全过程。

![](http://hi.csdn.net/attachment/201107/15/0_13107223150uUd.gif)

实例:

IP 192.168.1.116.3337 > 192.168.1.123.7788: S 3626544836:3626544836

IP 192.168.1.123.7788 > 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837

IP 192.168.1.116.3337 > 192.168.1.123.7788: ack 1739326487,ack 1

第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;

第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;

第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。

一个完整的三次握手也就是 请求---应答---再次确认

四次分手：

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

![](http://hi.csdn.net/attachment/201107/15/0_1310722321r7Un.gif)

33.TCP和UDP有什么区别。

答：

TCP——传输控制协议,提供的是面向连接、可靠的字节流服务。

当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。

UDP——用户数据报协议，是一个简单的面向数据报的传输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快.

TCP协议和UDP协议的一些特性区别如下：

a、.TCP协议在传送数据段的时候要给段标号；UDP 协议不需要。

b、TCP协议可靠；UDP协议不可靠。

c、TCP协议是面向连接；UDP协议采用无连接。

d、TCP协议负载较高,采用虚电路；UDP协议低负载。

e、TCP协议的发送方要确认接受方是否收到数据段(3次握手协议)。

f、TCP协议采用窗口技术和流控制。

34.如何编写套接字？

35.调用函数时要进行参数压栈，一般情况下顺序是从最右边参数往左压栈。

36.经常要操作的内存分为那几个类别？

答：a、栈区：由编译器自动分配和释放，存放函数的参数值、局部变量的值等；

b、堆：一般由程序员分配和释放，存放动态分配的变量；

c、全局区（静态区）：全局变量和静态变量存放在这一块，初始化的和未初始化的分开放；

d、文字常量区：常量字符串就放在这里，程序结束自动释放；

e、程序代码区：参访函数体的二进制代码。

37.请讲述堆和栈的区别。

答：a、申请方式不同。栈上有系统自动分配和释放；堆上有程序员自己申请并指明大小；

b、栈是向低地址扩展的数据结构，大小很有限；堆是向高地址扩展，是不连续的内存区域，空间相对大且灵活；

c、栈由系统分配和释放速度快；堆由程序员控制，一般较慢，且容易产生碎片；

38.全局变量放在数据段，内部变量static int count；放在数据段，内部变量char *p=“AAA”，p的位置在堆栈上，指向的空间的位置数据段，内部变量char *p=new char；p的位置堆，指向的空间的位置数据段

39.字符数组与字符串的比较：最明显的区别是字符串会在末尾自动添加空字符。

40.函数指针相关概念（C++学习笔记）

41.类使用static成员的优点，如何访问？

答：优点：

a、static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；

b、可以实施封装。static 成员可以是私有成员，而全局对象不可以；

c、 static 成员是与特定类关联的，可清晰地显示程序员的意图。

static 数据成员必须在类定义体的外部定义(正好一次)，static 关键字只能用于类定义体内部的声明中，定义不能标示为static. 不像普通数据成员，static成员不是通过类构造函数进行初始化，也不能在类的声明中初始化，而是应该在定义时进行初始化.保证对象正好定义一次的最好办法，就是将static 数据成员的定义放在包含类非内联成员函数定义的文件中。

静态数据成员初始化的格式为：

＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞

类的静态数据成员有两种访问形式：

＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞

42. static数据成员和static成员函数

答：（1）static数据成员：

static数据成员独立于该类的任意对象而存在；每个static数据成员是与类关联的对象，并不与该类的对象相关联。Static数据成员（const static数据成员除外）必须在类定义体的外部定义。不像普通数据成员，static成员不是通过类的构造函数进行初始化，而是应该在定义时进行初始化。

（2）static成员函数：

Static成员函数没有this形参，它可以直接访问所属类的static成员，不能直接使用非static成员。因为static成员不是任何对象的组成部分。同时，static成员函数也不能被声明为虚函数。

43.static成员变量定义放在cpp文件中，不能放在初始化列表中。Const static成员可就地初始化。

44.如何引用一个已经定义过的全局变量？

答：可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。

44.static关键字的作用。

答：static总是使得变量或对象的存储形式变成静态存储，连接方式变成内部连接，对于局部变量（已经是内部连接了），它仅改变其存储方式；对于全局变量（已经是静态存储了），它仅改变其连接类型。

45.奈奎斯特定理

46.香农定理

47．多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?

答案：虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。

48. 一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?

在子类的空间里，有没有父类的这个函数，或者父类的私有变量? (华为笔试题）

答案：只要基类在定义成员函数时已经声明了 virtue关键字，在派生类实现的时候覆盖该函数时，virtue关键字可加可不加，不影响多态的实现。子类的空间里有父类的所有变量(static除外)。

49. 完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别

，你喜欢使用哪个，为什么？

答案：这些函数的区别在于实现功能以及操作对象不同。

a、strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。

b、sprintf 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。

c、memcpy 函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy 的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy 函数等长拷贝的特点以及数据类型代表的物理意义，memcpy 函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。

对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：

• strcpy 无疑是最合适的选择：效率高且调用方便。

• sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。

• memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。

对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy 却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy 的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。

50. 应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？

答：对于一个进程的内存空间而言，可以在逻辑上分成 3个部份：代码区，静态数据区和动态数据区。

动态数据区一般就是“堆栈”。 栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”。

全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。

51. C++函数中值的传递方式有哪几种?

答：三种传递方式为：值传递、指针传递和引用传递。

52. C++里面是不是所有的动作都是main()引起的？如果不是，请举例.

比如全局变量的初始化，就不是由main函数引起的

举例： class A{};

A a; //a的构造函数限执行

int main() {}

53. 下列哪两个是等同的

int b;

A const int* a = &b;

B const* int a = &b;

C const int* const a = &b;

D int const* const a = &b;

54. 内联函数在编译时是否做参数类型检查？

答：内联函数要做参数类型检查, 这是内联函数跟宏相比的优势。

55. 全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？

a、生命周期不同：

全局变量随主程序创建和创建，随主程序销毁而销毁

局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；内存中

分配在全局数据区

b、使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区

操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。

56. static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答：static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

57. 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

58． 对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline

59. 面向对象的程序设计思想是什么?

答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象。

60. 什么是类?

答：把一些具有共性的对象归类后形成一个集合，也就是所谓的类。 

61 对象都具有的两方面特征是什么?分别是什么含义?

答：对象都具有的特征是：静态特征和动态特征。

静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）

62 在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义?

答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率。

63、 在类的内部定义成员函数的函数体，这种函数会具备那种属性?

答：种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换。

64. 成员函数通过什么来区分不同对象的成员数据?为什么它能够区分?

答：通过this指针指向对象的首地址来区分的。

65. C++编译器自动为类产生的四个缺省函数是什么?

答：默认构造函数，拷贝构造函数，析构函数，赋值函数。

66. 拷贝构造函数在哪几种情况下会被调用?

答：

a.当类的一个对象去初始化该类的另一个对象时；

b.如果函数的形参是类的对象，调用函数进行形参和实参结合时；

c.如果函数的返回值是类对象，函数调用完成返回时。

67. 构造函数与普通函数相比在形式上有什么不同?（构造函数的作用，它的声明形式来分析）

答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的。

构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。

68. 什么时候必须重写拷贝构造函数?

答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。

69. 构造函数的调用顺序是什么?

答：a.先调用基类构造函数

b.按声明顺序初始化数据成员

c、最后调用自己的构造函数。

70. 哪几种情况必须用到初始化成员列表?

答：类的成员是常量成员初始化；

类的成员是对象成员初始化，而该对象没有无参构造函数。

类的成员为引用时。

71. 什么是常对象?

答：常对象是指在任何场合都不能对其成员的值进行修改的对象。

72. 静态函数存在的意义?

答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；

当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数。

73. 在类外有什么办法可以访问类的非公有成员?

答：友元，继承，公有成员函数。

74. 什么叫抽象类?

答：不用来定义对象而只作为一种基本类型用作继承的类。

75. 运算符重载的意义?

答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致。

76. 不允许重载的5个运算符是哪些?

答：

a. .*（成员指针访问运算符号）

b. ：：域运算符

c. Sizeof 长度运算符号

d. ?：条件运算符号

e. .（成员访问符）

77. 运算符重载的三种方式?

答：普通函数，友元函数，类成员函数。

78. 流运算符为什么不能通过类的成员函数重载?一般怎么解决?

答：因为通过类的成员函数重载必须是运算符的第一个是自己，而对流运算的重载要求第一个参数是流对象。所以一般通过友元来解决。

79. 赋值运算符和拷贝构造函数的区别与联系?

答：相同点：都是将一个对象copy到另一个中去。

不同点：拷贝构造函数涉及到要新建立一个对象。

80. 在哪种情况下要调用该类的析构函数?

答：对象生命周期结束时。

81. 对象间是怎样实现数据的共享的?

答：通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有。

82. 友元关系有什么特性?

答：单向的，非传递的，不能继承的。

83. 对对象成员进行初始化的次序是什么?

答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的。

84. 类和对象之间的关系是什么?

答：类是对象的抽象，对象是类的实例。

85. 对类的成员的访问属性有什么?

答：public，protected，private。

86．const char *p和char * const p; 的区别

答：

如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

87. 是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?

答：

virtual修饰符会被隐形继承的。

virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态。

88. 函数重载是什么意思?它与虚函数的概念有什么区别?

答：函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。但是记住：不能仅仅通过函数返回值不同来实现函数重载。而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。它体现的是一个纵向的概念，也即在基类和派生类间实现。

89. 构造函数和析构函数是否可以被重载,为什么?

答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。

90. 如何定义和实现一个类的成员函数为回调函数?

答：

所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。

定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别

91. 虚函数是怎么实现的?

答：简单说来使用了虚函数表.

92. 抽象类不会产生实例，所以不需要有构造函数。错

93. 从一个模板类可以派生新的模板类，也可以派生非模板类。对

94. main 函数执行以前，还会执行什么代码?

答案：全局对象的构造函数会在main 函数之前执行。

95. 当一个类A 中没有任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）

答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。

96. delete与 delete []区别：

答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。

97．子类析构时要调用父类的析构函数吗?

答：会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了

98. 继承的优缺点。

a、类继承是在编译时刻静态定义的，且可直接使用，

b、类继承可以较方便地改变父类的实现。

缺点：

a、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现

b、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为

c、如继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

99. 解释堆和栈的区别。 

答：栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。

100. 一个类的构造函数和析构函数什么时候被调用,是否需要手工调用?

答：构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用。

101. 何时需要预编译：

答：总是使用不经常改动的大型代码体。

程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

102. 多态的作用?

答：主要是两个：

a. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；

b. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用

103. 虚拟函数与普通成员函数的区别?内联函数和构造函数能否为虚拟函数?

答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数。

104. 构造函数和析构函数的调用顺序? 析构函数为什么要虚拟?

答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏。

105. C++中类型为private的成员变量可以由哪些函数访问?

答：只可以由本类中的成员函数和友元函数访问

106. 请说出类中private，protect，public三种访问限制类型的区别

答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问.

107. 类中成员变量怎么进行初始化?

答：可以通过构造函数的初始化列表或构造函数的函数体实现。

108. 在什么时候需要使用“常引用”? 

答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

109.  引用与指针有什么区别?

答 、a、 引用必须被初始化，指针不必。

b、 引用初始化以后不能被改变，指针可以改变所指的对象。

c、 不存在指向空值的引用，但是存在指向空值的指针。

110.  描述实时系统的基本特性

答 、在特定时间内完成特定的任务，实时性与可靠性。

111.  全局变量和局部变量在内存中是否有区别?如果有，是什么区别?

答 、全局变量储存在静态数据区，局部变量在堆栈中。

112.  堆栈溢出一般是由什么原因导致的?

答 、没有回收垃圾资源

113.  什么函数不能声明为虚函数?

答 构造函数（constructor）

114.  IP地址的编码分为哪俩部分?

答 IP地址由两部分组成，网络号和主机号。

115.  不能做switch()的参数类型是：

答 、switch的参数不能为实型。

116.  C++是不是类型安全的?

答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)

117.  内存的分配方式

答：分配方式有三种，
a、 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量。

b、 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限。

c、 堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存。

118.  处理器标识#error的目的是什么?

答：编译时输出一条错误信息，并中止继续编译。

119. 在定义一个宏的时候要注意什么?

答：定义部分的每个形参和整个表达式都必须用括号括起来，以避免不可预料的错误发生

120.  数组在做函数实参的时候会转变为什么类型?

答：数组在做实参时会变成指针类型。

121.  .在Win32下 char, int, float, double各占多少位?

(1)   Char       占用8位

(2)   Int      占用32位

(3)   Float    占用32位

(4)   Double   占用64位

122.  strcpy()和memcpy()的区别?

答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以’\0’结束，但memcpy()必须指定拷贝的长度。

123.  说明define和const在语法和含义上有什么不同?

答：(1)   #define是C语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；

(2)   Const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度。

124.  简述全局变量的优缺点?

答：全局变量也称为外部变量，它是在函数外部定义的变量，它属于一个源程序文件，它保存上一次被修改后的值，便于数据共享，但不方便管理，易引起意想不到的错误。

125.  总结static的应用和作用?

答：a、函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

b、在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；

c、在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

d、在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

e、在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

126.  总结const的应用和作用?

答：a、欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了

b、对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；

c、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；

d、对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；

e、对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

127、  什么是指针?谈谈你对指针的理解?

答：指针是一个变量，该变量专门存放内存地址；

指针变量的类型取决于其指向的数据类型，在所指数据类型前加*

指针变量的特点是它可以访问所指向的内存。

128.  什么是常指针，什么是指向常变量的指针?

答：常指针的含义是该指针所指向的地址不能变，但该地址所指向的内容可以变化，使用常指针可以保证我们的指针不能指向其它的变量，

指向常变量的指针是指该指针的变量本身的地址可以变化，可以指向其它的变量，但是它所指的内容不可以被修改。指向长变量的指针定义，

129.  函数指针和指针函数的区别?

答：函数指针是指向一个函数入口的指针；

指针函数是函数的返回值是一个指针类型。

130.  简述Debug版本和Release版本的区别?

答：Debug版本是调试版本，Release版本是发布给用户的最终非调试的版本，

131.  指针的几种典型应用情况?

答：
int *p[n];—–指针数组，每个元素均为指向整型数据的指针。

int (*)p[n];—p为指向一维数组的指针，这个一维数组有n个整型数据。

int *p();——函数带回指针，指针指向返回的值。

int (*)p();—-p为指向函数的指针。

132.  static函数与普通函数有什么区别?

答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

133.  struct(结构) 和 union(联合)的区别?

答：a. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
b. 对于联合的不同成员赋值, 将会对其它成员重写,  原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

134.  class 和 struct 的区别?

答：struct 的成员默认是公有的，而类的成员默认是私有的。

135.  简述枚举类型?

答：枚举方便一次定义一组常量，使用起来很方便；

136.  assert()的作用?

答：ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。

137.  局部变量和全局变量是否可以同名?

答：能。局部会屏蔽全局。要用全局变量，需要使用”::”(域运算符)。

138.  类的声明和实现的分开的好处?

答：a.    起保护作用；

b.    提高编译的效率。

139.  windows消息系统由哪几部分构成?

答：由一下3部分组成：

a.    消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；

b.    消息循环：应用程序通过消息循环不断获取消息、处理消息。

c.    消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。

140.  什么是消息映射?

答：消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。

141、子类析构时要调用父类的析构函数吗？

析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

142、多态，虚函数，纯虚函数

多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；

在程序编译时多态性体现在函数和运算符的重载上；

虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在纯虚函数不具备函数的功能，一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

143、求下面函数的返回值（微软）

int func(x) 

{ 

int countx = 0; 

while(x) 

{ 

countx ++; 

x = x&(x-1); 

} 

return countx; 

} 

假定x = 9999。 答案：8

思路：将x转化为2进制，看含有的1的个数。

144.什么是“引用”？申明和使用“引用”要注意哪些问题？

答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

145.将“引用”作为函数参数有哪些特点？

a、传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

b、使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

c、使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

146.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?

格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }

好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!

注意事项：

a、不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

b、不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。

c、可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

d、流操作符重载返回值申明为“引用”的作用：

流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。

赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

＃include<iostream.h>

int &put(int n);

int vals[10];

int error=-1;

void main()

{

put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; 

put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; 

cout<<vals[0]; 

cout<<vals[9];

} 

int &put(int n)

{

if (n>=0 && n<=9 ) return vals[n]; 

else { cout<<"subscript error"; return error; }

}

e、在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b)
 == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。

147.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？

常考的题目。从定义上来说：

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

148.有哪几种情况只能用intialization list 而不能用assignment?

答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。

149.请说出const与#define 相比，有何优点？

答案：

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

a、 const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

b、 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

150、 int (*s[10])(int) 表示的是什么？

int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

151、将程序跳转到指定内存地址

要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？

*((void (*)( ))0x100000 ) ( );

　　首先要将0x100000强制转换成函数指针,即:

(void (*)())0x100000

　　然后再调用它:

*((void (*)())0x100000)();

　　用typedef可以看得更直观些:

typedef void(*)() voidFuncPtr;

*((voidFuncPtr)0x100000)();

152、int id[sizeof(unsigned long)];这个对吗？为什么？

答案:正确 这个 sizeof是编译时运算符，编译时就确定了 ,可以看成和机器有关的常量。

153、复杂声明

void * ( * (*fp1)(int))[10];

float (*(* fp2)(int,int,int))(int);

int (* ( * fp3)())[10]();

分别表示什么意思？

【标准答案】

a、.void * ( * (*fp1)(int))[10]; fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。

b、.float (*(* fp2)(int,int,int))(int); fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。

c、int (* ( * fp3)())[10](); fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。

154、基类的析构函数不是虚函数，会带来什么问题？

【参考答案】派生类的析构函数用不上，会造成资源的泄漏。

155. C中static有什么作用

　　a、隐藏。 当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，故使用static在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

　　b、static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量。

　　c、static的第三个作用是默认初始化为0.其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0×00,某些时候这一特点可以减少程序员的工作量。

156. 什么是动态特性？

　　在绝大多数情况下，程序的功能是在编译的时候就确定下来的， 我们称之为静态特性。 反之， 如果程序的功能是在运行时刻才能确定下来的， 则称之为动态特性。C++中， 虚函数，抽象基类， 动态绑定和多态构成了出色的动态特性。

157.什么是封装？C++中是如何实现的？

　　封装来源于信息隐藏的设计理念，是通过特性和行为的组合来创建新数据类型让接口与具体实现相隔离。C++中是通过类来实现的， 为了尽量避免某个模块的行为干扰同一系统中的其它模块，应该让模块仅仅公开必须让外界知道的接口。

158. 什么是RTTI?

RTTI事指运行时类型识别（Run-time type identification）在只有一个指向基类的指针或引用时确定一个对象的准确类型。

159. 什么是拷贝构造函数？

　　它是单个参数的构造函数，其参数是与它同属一类的对象的（常）引用；类定义中，如果未提供自己的拷贝构造函数，C++提供一个默认拷贝构造函数，该默认拷贝构造函数完成一个成员到一个成员的拷贝

160. 什么是深浅拷贝？

　　浅拷贝是创建了一个对象用一个现成的对象初始化它的时候只是复制了成员（简单赋值）而没有拷贝分配给成员的资源（如给其指针变量成员分配了动态内存）；深拷贝是当一个对象创建时，如果分配了资源，就需要定义自己的拷贝构造函数，使之不但拷贝成员也拷贝分配给它的资源。

161.面向对象程序设计的优点？

　　开发时间短，效率高， 可靠性高。面向对象编程的编码具有高可重用性，可以在应用程序中大量采用成熟的类库（如STL），从而虽短了开发时间，软件易于维护和升级。



