# 朴素贝叶斯改进及其应用 - 李鑫o_O - CSDN博客





置顶2016年03月10日 21:43:51[hustlx](https://me.csdn.net/HUSTLX)阅读数：2012








## 1、贝叶斯定理

设![clip_image002[30]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221342569-1199032425.png)是类标号未知的数据样本，![clip_image004[12]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221343647-2085597847.png)为某种假设，数据样本![clip_image002[31]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221344741-561368606.png)属于某特定的类 C ，对于该分类问题，期望确定![clip_image007[16]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221352975-317754474.png)，即给定观测数据样本![clip_image002[32]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221401460-1390095847.png)，假定![clip_image004[13]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221408116-1960397900.png)成立的概率，称为后验概率，或称条件![clip_image002[33]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221409554-1226728949.png)下![clip_image004[14]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221415319-1728261784.png)的后验概率。分类就是要确定![clip_image007[17]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221422819-762447600.png)。

例如，假定数据样本集由顾客组成，用他们的年龄和收入情况进行分类。假定![clip_image002[34]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221429257-149650446.png)表示顾客的年龄在31岁到40之间并且中等收入，![clip_image004[15]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221439225-1113080683.png)表示顾客将购买电脑，则![clip_image007[18]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221443038-972501811.png)反映的是观察到顾客![clip_image002[35]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221443835-197141981.png)的年龄在31岁到40之间并且中等收入时，![clip_image002[36]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221459288-2023215959.png)将购买电脑的确定程度。![clip_image013[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221500007-419798972.png)为先验概率，在无论顾客![clip_image002[37]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221500835-818144335.png)的年龄和收入情况而购买电脑的概率。后验概率![clip_image007[19]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221501554-992419500.png)比先验概率![clip_image013[11]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221502382-1465535588.png)基于更多的背景知识，而![clip_image013[12]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221506663-1570224628.png)是独立于![clip_image002[38]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221507366-1515434832.png)的。与之类似，![clip_image016[8]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221509725-1329099060.png)是在条件![clip_image004[16]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221520460-1130446335.png)下，![clip_image002[39]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221533054-435267485.png)的后验概率，即已知顾客![clip_image002[40]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221533960-383447714.png)购买电脑，其年龄在31岁到40岁之间并且中等收入的概率。由于通常情况下![clip_image007[20]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221534663-576859495.png)难以直接计算，我们可以利用贝叶斯定理，通过相对容易计算的![clip_image016[9]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221538679-1572333962.png)，来求解![clip_image007[21]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221557819-1648182264.png)。

贝叶斯定理提供了一种由![clip_image019[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221558725-477915407.png)，![clip_image013[13]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221602804-1799044538.png)和![clip_image016[10]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221605554-1982342331.png)计算![clip_image007[22]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221606335-684207782.png)的方法，具体是：

![clip_image021[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221607038-1459685341.png)

## 2、朴素的贝叶斯分类器

朴素贝叶斯分类就是假定一个属性值对给定类的影响独立于其他属性的值，该假定称作类条件独立，做此假定是为了简化计算，在此意义下称为“朴素的”。朴素贝叶斯分类的工作过程如下：

（1）每个数据样本用一个n维特征向量![clip_image023[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221608741-1233023216.png)表示，分别描述n个属性![clip_image025[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221615913-253081462.png)样本的n个度量。

（2）假定m个类![clip_image027[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221625382-1578389872.png)。给定一个未知的数据样本![clip_image023[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221638788-860516170.png)，朴素贝叶斯分类将未知的样本分配给类![clip_image029[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221639882-1758004456.png)，当且仅当

![clip_image031[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221640866-719128881.png)

根据贝叶斯定理![clip_image033[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221641585-770426722.png)，最大化![clip_image035[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221643569-1133583268.png)即可进行分类，其中令![clip_image035[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221650288-702439409.png)最大的类![clip_image038[16]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221655319-646268470.png)称为最大后验假设。

（3）其中![clip_image019[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221656460-1547509801.png)代表属性集![clip_image025[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221657069-2108885891.png)取值为![clip_image041[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221657710-199228982.png)时的联合概率，为常数，所以最大化时只需使![clip_image043[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221658788-1935890334.png)最大即可。类![clip_image038[17]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221702491-205168921.png)的先验概率可以用![clip_image046[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221703179-1796096224.png)计算，其中![clip_image048[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221705850-1657937796.png)是类![clip_image050[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221706538-476457778.png)中训练样本数，![clip_image052[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221707850-696600187.png)是训练样本总数。

（4）给定具有许多属性的数据集，计算![clip_image054[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221708647-1959757079.png)即![clip_image056[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221709413-167686334.png)的开销可能非常大。为降低计算![clip_image054[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221722866-932797775.png)的开销，可以做类条件独立的朴素假定。在此情况下有：

![clip_image058[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221724054-1177269359.png)概率![clip_image060[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221724850-1171682484.png)可以由训练样本估值，其中：

（a）如果![clip_image062[6]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221725897-1549827372.png)是离散属性，![clip_image064[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221726632-291329119.png),其中![clip_image066[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221727429-557335517.png)是样本集中属于类型![clip_image038[18]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221728132-2016561552.png)的样本个数。![clip_image068[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221728725-1780207087.png)是样本集中于类型![clip_image038[19]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221749757-935346164.png)且属性![clip_image062[7]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221751725-1632125804.png)取值为![clip_image071[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221757491-1136904807.png)的样本个数。

（b）若![clip_image073[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221758272-1742932051.png)是连续值属性，常用的处理方法有两种：一是对其离散化，然后按照离散值处理；另一种是假定这一属性服从某一分布。

对未知样本![clip_image002[41]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221759350-590190686.png)分类的时候，对每个类![clip_image038[20]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221802288-591897050.png)，计算![clip_image077[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221816054-18488.png)。样本![clip_image002[42]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221816944-1087877114.png)被指派到类![clip_image038[21]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221820054-1645317657.png)当且仅当![clip_image081[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221820710-71441985.png)时，![clip_image002[43]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221821725-2076984030.png)被指派到其![clip_image084[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221837319-156906164.png)最大的类![clip_image038[22]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221850304-629488161.png)。

# 二、实验过程

## 1、实验流程

本次实验采用RSS数据源采集网站数据，用到了下面两个数据源爬数据：

ny = feedparser.parse('http://newyork.craigslist.org/stp/index.rss')

sf = feedparser.parse('http://sfbay.craigslist.org/stp/index.rss')

得到每个网站的文章之后建立列表doclist，并且建立每篇文章相对应的类标签classlist，再生成一个所有单词出现的列表vocablist。接下来统计每个单词出现的次数，次数出现较多的单词一般是类似于and、the、for之类的并不能给分类带来帮助的无用单词，我们把这些高频词去掉。我们在doclist中随机取20个作为测试集，剩余的作为训练集，先计算某个类占的先验概率pAbusive，再计算每个类每个单词占总的这个单词出现的概率p0Vect,p1Vect，测试的时候把待测试的样本向量分别乘以p0Vect,p1Vect再每个元素加起来分别加先验概率取log。算出来哪个概率大就属于哪个类。

## 2、改进算法

我主要做了互信息特征选择，也就是用互信息选择所有出现单词中的一些做特征。互信息衡量的是某个特征词和类别之间的统计独立关系。某个特征词t 和某个类别ci 传统的互信息定义度量两个对象之间的相互性，在不良信息过滤问题中用于度量特征对于主题的区分度。则特征词 t 和类别 ci 的互信息公式定义为:

![clip_image087[5]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221906194-1181987815.jpg)

其中: P( t，ci) 表示训练集中既包含特征t 又属于类别ci 的文档概率，P( t) 表示在整个文本训练集中包含特征t 的文档概率，P( ci) 表示在训练集中属于类别ci 的文档概率，P( t
 | ci)表示在类别ci 中包含特征t 的文档概率。在某个类别ci 中出现的概率高，而在其他类别中出现的概率低的特征t 将获得较高的互信息，也就有可能被选择为类别ci 的特征。 在m 个类别的文本训练集上特征项t 的互信息定义为：

![clip_image089[5]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221907460-450599395.jpg)

互信息根据特征与类别共同出现的概率，度量特征和类别的相关性。 对于某一类别ci 来讲，特征词t 的互信息越大，说明该词与该类的共现概率越大。 下面利用一个简单的例子对传统互信息算法进行分析，设存在两类文本c1 ，c2 ，每类中包含5 篇文档，特征词集合中有t1 ，t2 ，t3 三个词，并且在类别c1 ，c2 的分布情况如表1 所示。

![clip_image091[5]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221909038-1835186411.jpg)

利用式( 2) 计算可得：

![clip_image093[5]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221911741-1852968579.jpg)

我用这样的计算方法到的每个单词的互信息，具体python实现如下：



```python
def chooseN(trainMatrix,trainCategory):
    numTrainDocs = len(trainMatrix)
    numWords = len(trainMatrix[0])
    pAbusive = sum(trainCategory)/float(numTrainDocs)
    MI=zeros(numWords)
    pCondition1=ones(numWords)
    pCondition0=ones(numWords)
    deleteN=[]
    for i in range(numWords):
        for j in range(numTrainDocs):
            if trainCategory[j]==1:
                pCondition1[i]=pCondition1[i]+trainMatrix[j][i]
            else:
                pCondition0[i]=pCondition0[i]+trainMatrix[j][i]
        MI[i]=pAbusive*log(pCondition1[i]/(pCondition1[i]+pCondition0[i]))+\
              (1-pAbusive)*log(pCondition0[i]/(pCondition1[i]+pCondition0[i]))
        if MI[i]>-0.8:
            deleteN.append(i)
    return deleteN
```


下图是在一次计算中得到的MI：

![clip_image095[5]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160310221913991-1440487129.jpg)

另外去高频词的时候发现去掉10个高频词的时候效果比较好。下面是实验数据：
|方法（错误率）|1|2|3|4|5|6|7|8|9|10|平均错误率|
|----|----|----|----|----|----|----|----|----|----|----|----|
|互信息去10|0|0.15|0|0.05|0|0.05|0.1|0.1|0.1|0.05|0.06|
|互信息|0.1|0.15|0|0.1|0|0.15|0.05|0|0.05|0.15|0.075|
|去10|0.25|0.35|0.35|0.4|0.4|0.35|0.3|0.35|0.25|0.35|0.335|
|去30|0.35|0.4|0.45|0.4|0.5|0.3|0.35|0.45|0.3|0.45|0.395|

# 三、实验小结

这次实验相对前两次比较难，首先要理解原来朴素贝叶斯的每个步骤的代码，对于改进还要看文献，改进的互信息又很难具体下手写代码，最后找见一篇中文的“文本分类中互信息特征选择方法的研究与算法改进”的论文按照论文当中的方法才用代码实现，不过很奇怪的是计算到互信息之后用互信息小的做特征词反而得到了很好的效果，这和传统的方法是相反的，而且对于实验的两个RSS源数据每天测试的结果不太一样，有可能是网站新闻有变动之类的





