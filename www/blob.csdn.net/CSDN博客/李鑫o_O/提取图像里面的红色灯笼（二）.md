# 提取图像里面的红色灯笼（二） - 李鑫o_O - CSDN博客

置顶2016年03月07日 11:15:22[hustlx](https://me.csdn.net/HUSTLX)阅读数：1397



首先对图像进行简单的阈值处理：

```
```cpp
/**************************************************************
```

```cpp
函数功能：对图像hsi空间红色灯笼的提取
```

```cpp
输入参数：源图像src；目标图像des；图像参数width,height,nChannels；
```

```cpp
输出参数：目标图像
```

```cpp
**************************************************************/
```

```cpp
void
```

```cpp
hsi_seg(unsigned
```

```cpp
char
```

```cpp
*
 des,
```

```cpp
const
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 src,
```

```cpp
int
```

```cpp
width,
```

```cpp
int
```

```cpp
height,
```

```cpp
int
```

```cpp
nChannels)
```

```cpp
{
```

```cpp
printf
```

```cpp
(
```

```cpp
"%d,%d,%d,"
```

```cpp
,nChannels,width,height);
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 ocl =
```

```cpp
new
```

```cpp
unsigned
```

```cpp
char
```

```cpp
[width
 * height * nChannels];
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 hsi =
```

```cpp
new
```

```cpp
unsigned
```

```cpp
char
```

```cpp
[width
 * height * nChannels];
```

```cpp
rgb_hsi(hsi,src,
 width, height, nChannels);
```

```cpp
//hsi分量提取
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y
 = 0; y < height; y++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x
 = 0; x < width; x++)
```

```cpp
{
```

```cpp
int
```

```cpp
img_H=
 hsi[y * width * nChannels + x * nChannels ] ;
```

```cpp
int
```

```cpp
img_S=
 hsi[y * width * nChannels + x * nChannels + 1] ;
```

```cpp
int
```

```cpp
img_I=
 hsi[y * width * nChannels + x * nChannels + 2] ;
```

```cpp
if
```

```cpp
((img_H<104)&&(img_H>102)&&(img_I>40)&&(img_S>60))
```

```cpp
{
```

```cpp
//printf("%d,
 ",img_S);
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] = src[y * width * nChannels + x * nChannels + n] ;
```

```cpp
}
```

```cpp
else
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] =255;
```

```cpp
}
```

```cpp
}
```

```cpp
ImageDilation(ocl,
 des, width, height, nChannels,3);
```

```cpp
//进行3*3的模板膨胀
```
```


提取红色分量如下图所示，再进行一次3*3模板的膨胀：

![clip_image002](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191654049-1901077330.jpg)![clip_image004](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191655018-1984366025.jpg)

再进行一次腐蚀和填充，效果如下：

![clip_image006](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191655721-1224328227.jpg)![clip_image008](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191656362-1380158555.jpg)

下面是图像填充的代码：

```
```cpp
void
```

```cpp
Imgfill(unsigned
```

```cpp
char
```

```cpp
*
 des,
```

```cpp
const
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 src,
```

```cpp
int
```

```cpp
width,
```

```cpp
int
```

```cpp
height,
```

```cpp
int
```

```cpp
nChannels)
```

```cpp
{
```

```cpp
memcpy
```

```cpp
(des,
 src, nChannels*width*height);
```

```cpp
//
 TODO: 在此添加命令处理程序代码
```

```cpp
//记录填充行的最左位置
```

```cpp
int
```

```cpp
left_X=0;
```

```cpp
//记录填充行的最右位置
```

```cpp
int
```

```cpp
right_X=0;
```

```cpp
//记录填充列的最上位置
```

```cpp
int
```

```cpp
top_Y=0;
```

```cpp
//记录填充列的最下位置
```

```cpp
int
```

```cpp
bottom_Y=0;
```

```cpp
//横向填充
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;y<height;y++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=0;x<width-61;x++)
```

```cpp
{
```

```cpp
int
```

```cpp
sl=src[y
 * width * nChannels + x * nChannels + 2];
```

```cpp
if
```

```cpp
(sl!=255)
```

```cpp
{
```

```cpp
left_X=x;
```

```cpp
//找到最左边的白色点
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
k=60;k>0;k--)
```

```cpp
{
```

```cpp
int
```

```cpp
sr=src[y
 * width * nChannels + (x+k) * nChannels + 2];
```

```cpp
if
```

```cpp
(sr!=255)
```

```cpp
{
```

```cpp
right_X=x+k;
```

```cpp
break
```

```cpp
;
```

```cpp
//跳出寻找最右边点的循环
```

```cpp
}
```

```cpp
}
```

```cpp
//将left_X与right_X之间的点设置为黑色
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=left_X;x<right_X-1;x++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n]=0;
```

```cpp
}
```

```cpp
//x=right_X;
```

```cpp
//printf("L%d
 ",left_X);
```

```cpp
}
```

```cpp
}
```

```cpp
}
```

```cpp
//纵向填充
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=0;x<width;x++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;y<height-61;y++)
```

```cpp
{
```

```cpp
int
```

```cpp
st=src[y
 * width * nChannels + x * nChannels + 2];
```

```cpp
if
```

```cpp
(255!=st)
```

```cpp
{
```

```cpp
top_Y=y;
```

```cpp
//y到最上边的非白色点
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
m=10;m>0;m--)
```

```cpp
{
```

```cpp
int
```

```cpp
sb=src[(y+m)
 * width * nChannels + x * nChannels + 2];
```

```cpp
if
```

```cpp
(sb!=255)
```

```cpp
{
```

```cpp
bottom_Y=m+y;
```

```cpp
break
```

```cpp
;
```

```cpp
//跳出寻找最下边点的循环
```

```cpp
}
```

```cpp
}
```

```cpp
//将top_Y与bottom_Y之间的点设置为黑色
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=top_Y;y<bottom_Y-1;y++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n]=0;
```

```cpp
}
```

```cpp
}
```

```cpp
}
```

```cpp
}
```

```cpp
}
```
```


再进行一次8*8的腐蚀和5*5的膨胀：

![clip_image010](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191657205-1705171233.jpg)![clip_image012](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191657909-58516602.jpg)

最后重建图像：

![clip_image014](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191658846-1271005374.jpg)

##### 二、对大窗户区阴影的增强

```
```cpp
/**************************************************************
```

```cpp
函数功能：对图像窗户里阴影进行直方图均衡
```

```cpp
输入参数：源图像src；目标图像des；图像参数width,height,nChannels；
```

```cpp
输出参数：目标图像
```

```cpp
**************************************************************/
```

```cpp
void
```

```cpp
win_enhance(unsigned
```

```cpp
char
```

```cpp
*
 des,
```

```cpp
const
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 src,
```

```cpp
int
```

```cpp
width,
```

```cpp
int
```

```cpp
height,
```

```cpp
int
```

```cpp
nChannels)
```

```cpp
{
```

```cpp
printf
```

```cpp
(
```

```cpp
"%d,%d,%d,"
```

```cpp
,nChannels,width,height);
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 ocl =
```

```cpp
new
```

```cpp
unsigned
```

```cpp
char
```

```cpp
[width
 * height * nChannels];
```

```cpp
unsigned
```

```cpp
char
```

```cpp
*
 flag =
```

```cpp
new
```

```cpp
unsigned
```

```cpp
char
```

```cpp
[width
 * height * nChannels];
```

```cpp
int
```

```cpp
r[256]
 = {0}, g[256] = {0}, b[256] = {0};
```

```cpp
int
```

```cpp
sum
 = 0;
```

```cpp
//图像中像素点的综合
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y
 = 0; y < height; y++)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x
 = 0; x < width; x++)
```

```cpp
{
```

```cpp
int
```

```cpp
B=
 src[y * width * nChannels + x * nChannels ] ;
```

```cpp
int
```

```cpp
G=
 src[y * width * nChannels + x * nChannels + 1] ;
```

```cpp
int
```

```cpp
R=
 src[y * width * nChannels + x * nChannels + 2] ;
```

```cpp
if
```

```cpp
((R+G+B<120)&&(y
 < height-240)&&(y >250))
```

```cpp
{
```

```cpp
//printf("%d,
 ",img_S);
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
{
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] = src[y * width * nChannels + x * nChannels + n] ;
```

```cpp
}
```

```cpp
}
```

```cpp
else
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
{
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] =255;
```

```cpp
}
```

```cpp
}
```

```cpp
}
```

```cpp
}
```

```cpp
ImageErosion(ocl,
 des, width, height, nChannels,9);
```

```cpp
ImageDilation(des,
 ocl, width, height, nChannels,10);
```
```


下图分别为简单的阈值处理后进行一次9*9的腐蚀和10*10膨胀之后的图：

![clip_image016](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191659674-1507426444.jpg)![clip_image018](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191700362-627529964.jpg)

下面进行对上图阴影区的直方图均衡：

```
```cpp
memcpy
```

```cpp
(ocl,
 des,nChannels*width*height);
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;
 y<height; y++)
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=0;
 x<width; x++)
```

```cpp
{
```

```cpp
if
```

```cpp
(
 des[y * width * nChannels + x * nChannels]!=255)
```

```cpp
{
```

```cpp
sum=sum+1;
```

```cpp
flag[y
 * width * nChannels + x * nChannels ]= 1;
```

```cpp
b[des[y
 * width * nChannels + x * nChannels + 0]]++;
```

```cpp
g[des[y
 * width * nChannels + x * nChannels + 1]]++;
```

```cpp
r[des[y
 * width * nChannels + x * nChannels + 2]]++;
```

```cpp
}
```

```cpp
else
```

```cpp
{
```

```cpp
flag[y
 * width * nChannels + x * nChannels ]= 0;
```

```cpp
}
```

```cpp
}
```

```cpp
double
```

```cpp
val[3]
 = {0};
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;
 y<255; y++)
```

```cpp
{
```

```cpp
val[0]
 += b[y];
```

```cpp
val[1]
 += g[y];
```

```cpp
val[2]
 += r[y];
```

```cpp
b[y]
 = val[0]*255/sum;
```

```cpp
g[y]
 = val[1]*255/sum;
```

```cpp
r[y]
 = val[2]*255/sum;
```

```cpp
}
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;
 y<height; y++)
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=0;
 x<width; x++)
```

```cpp
{
```

```cpp
if
```

```cpp
(flag[y
 * width * nChannels + x * nChannels]==1)
```

```cpp
{
```

```cpp
ocl[y
 * width * nChannels + x * nChannels + 0] = b[des[y * width * nChannels + x * nChannels + 0]] ;
```

```cpp
ocl[y
 * width * nChannels + x * nChannels + 1] = g[des[y * width * nChannels + x * nChannels + 1]] ;
```

```cpp
ocl[y
 * width * nChannels + x * nChannels + 2] = r[des[y * width * nChannels + x * nChannels + 2]] ;
```

```cpp
}
```

```cpp
}
```

```cpp
//memcpy(des,
 ocl, nChannels*width*height);
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
y=0;
 y<height; y++)
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
x=0;
 x<width; x++)
```

```cpp
{
```

```cpp
if
```

```cpp
(flag[y
 * width * nChannels + x * nChannels ]==1)
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] = ocl[y * width * nChannels + x * nChannels + n] ;
```

```cpp
}
```

```cpp
else
```

```cpp
{
```

```cpp
for
```

```cpp
(
```

```cpp
int
```

```cpp
n=0;n<nChannels;n++)
```

```cpp
des[y
 * width * nChannels + x * nChannels + n] = src[y * width * nChannels + x * nChannels + n] ;
```

```cpp
}
```

```cpp
}
```

```cpp
}
```
```


最后效果如下：

![image](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305191702893-188516465.png)

