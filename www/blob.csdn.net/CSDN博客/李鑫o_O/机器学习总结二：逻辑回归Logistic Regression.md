# 机器学习总结二：逻辑回归Logistic Regression - 李鑫o_O - CSDN博客

置顶2016年04月14日 17:01:31[hustlx](https://me.csdn.net/HUSTLX)阅读数：3772


# 机器学习总结之逻辑回归Logistic Regression

逻辑回归logistic regression，虽然名字是回归，但是实际上它是处理分类问题的算法。简单的说回归问题和分类问题如下：

回归问题：预测一个连续的输出。

分类问题：离散输出，比如二分类问题输出0或1.

逻辑回归常用于垃圾邮件分类，天气预测、疾病判断和广告投放。

**一、假设函数**

    因为是一个分类问题，所以我们希望有一个假设函数![clip_image002[10]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165652160-2106756515.png)，使得：

![clip_image004[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165653270-854653774.jpg)

而sigmoid 函数可以很好的满足这个性质：

![clip_image006[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165950848-1332210410.jpg)

故假设函数：

![clip_image007[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165655113-1501994980.png)

其实逻辑回归为什么要用sigmoid函数而不用其他是因为逻辑回归是采用的伯努利分布，伯努利分布的概率可以表示成

![clip_image008[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165656379-1898956730.png)

     其中

![clip_image009[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165657473-1404060351.png)

     得到

![clip_image010[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165658441-2085018387.png)

  这就解释了logistic回归时为了要用这个函数。

**二、代价函数**

好了，现在我们确定了假设函数，输入![clip_image012[10]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165659535-1473643404.png)，如果我们依旧用线性回归的代价函数：

![clip_image014[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165700441-884656451.jpg)

其中：

![clip_image016[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165701551-1273918003.jpg)

这样的话代价函数![clip_image018[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165702301-77753925.png)将会非常复杂，有多个局部最小值，也就是非凸的，如下所示：

![clip_image020[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165951988-1653698788.jpg)

然而这并不是我们想要的，我们想要代价函数是凸函数如下：这样我们就可以很容易的找出全局最优解。

![clip_image022[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165952957-1052109084.jpg)

我们回过头来看![clip_image002[11]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165705285-1961134559.png)：

![clip_image024[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165706004-1513763171.jpg)

由上式我们可得：

![clip_image026[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165706926-1828605259.png)

如果我们将![clip_image002[12]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165707910-837690137.png)视为样本![clip_image012[11]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165708660-1479395355.png)作为正例的可能性，![clip_image030[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165709488-49709792.png)则为反例的可能性，

两者的比值对数称为对数几率：

![clip_image032[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165710379-1522583719.png)

这也就是逻辑回归为什么也称作对数几率回归的原因，我们可以将![clip_image002[13]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165711129-619788714.png)视为类后验概率：![clip_image034[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165712145-102335981.png)，则由：

![clip_image036[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165713082-2025450466.png)

可得：

![clip_image038[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165713926-1143763181.png)



我们用“最大似然估计”来估计![clip_image040[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165715207-390346426.png)，逻辑回归模型的似然函数如下：

![clip_image042[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165716113-1930133662.png)

对数似然函数如下：

![clip_image044[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165717035-1648775151.png)

![clip_image046[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165718098-1022134760.png)

即令每个样本属于其真实标记的概率越大越好，![clip_image048[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165720004-84538729.png)是高阶连续可导的凸函数，由凸优化理论可以根据梯度下降法、牛顿法等求最优解![clip_image050[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165721004-4260874.png)。

实际上，上式即为逻辑回归的代价函数：

![clip_image052[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165722176-1859171450.png)

它是由极大似然得来的。

由梯度下降得：

![](https://img-blog.csdn.net/20160414220134085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

下图是《机器学习实战》中给出的部分实现代码。

![](https://img-blog.csdn.net/20131113202512453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG9uZ3Rpbmd6aGl6aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**三、过拟合问题**

对于线性回归或逻辑回归的损失函数构成的模型，可能会有些权重很大，有些权重很小，导致过拟合（就是过分拟合了训练数据），使得模型的复杂度提高，泛化能力较差（对未知数据的预测能力）。

下面左图即为欠拟合，中图为合适的拟合，右图为过拟合。

![](https://img-my.csdn.net/uploads/201407/17/1405590306_6011.png)

**问题的主因**

过拟合问题往往源自过多的特征。

**解决方法**

1）减少特征数量（减少特征会失去一些信息，即使特征选的很好）

- 可用人工选择要保留的特征；
- 模型选择算法；

2）正则化（特征较多时比较有效）

- 保留所有特征，但减少θ的大小

**正则化方法**

正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或惩罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化项就越大。

从房价预测问题开始，这次采用的是多项式回归。左图是适当拟合，右图是过拟合。

![](https://img-my.csdn.net/uploads/201407/17/1405590306_2443.png)

直观来看，如果我们想解决这个例子中的过拟合问题，最好能将![](https://img-my.csdn.net/uploads/201407/17/1405590307_8774.png)的影响消除，也就是让![](https://img-my.csdn.net/uploads/201407/17/1405590308_6412.png)。假设我们对![](https://img-my.csdn.net/uploads/201407/17/1405590338_4363.png)进行惩罚，并且令其很小，一个简单的办法就是给原有的Cost函数加上两个略大惩罚项，例如：

![](https://img-my.csdn.net/uploads/201407/17/1405590338_9255.png)

这样在最小化Cost函数的时候，![](https://img-my.csdn.net/uploads/201407/17/1405590308_6412.png)。

正则项可以取不同的形式，在回归问题中取平方损失，就是参数的L2范数，也可以取L1范数。取平方损失时，模型的损失函数变为：

![](https://img-my.csdn.net/uploads/201407/17/1405590339_4006.png)

lambda是正则项系数：

- 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；
- 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。

正则化后的梯度下降算法θ的更新变为：

![](https://img-my.csdn.net/uploads/201407/17/1405590339_8017.png)

正则化后的线性回归的Normal Equation的公式为：

![](https://img-my.csdn.net/uploads/201407/17/1405590340_5897.png)

**其他优化算法**

- Conjugate gradient method(共轭梯度法)
- Quasi-Newton method(拟牛顿法)
- BFGS method
- L-BFGS(Limited-memory BFGS)

后二者由拟牛顿法引申出来，与梯度下降算法相比，这些算法的优点是：

- 第一，不需要手动的选择步长；
- 第二，通常比梯度下降算法快；

但是缺点是更复杂。


**四、逻辑回归的优点**

1、它是直接对分类可能性建模，无需事先假设数据分布，这样就避免了假设分布不准确问题。

2、它不仅预测类别，而且可以得到近似概率预测，这对许多概率辅助决策的任务很有用。

3、对率函数是任意阶可导凸函数，有很好的数学性质，现有许多的数值优化算法都可以直接用于求解。

**五、多分类问题**

对于多分类问题常用的做法是分解为多个二分类问题，例如：

![clip_image054[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165723410-50535524.jpg)

分解为下面三个二分类逻辑回归问题：

![clip_image056[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165724488-1674330649.jpg)![clip_image058[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165725551-339013012.jpg)![clip_image060[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165726801-953826967.jpg)

对于一个新的样本![clip_image012[12]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165728004-1844598615.png)，如果第i类使得![clip_image063[4]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165729223-1050175709.png)最大，我们认为![clip_image012[13]](http://images2015.cnblogs.com/blog/904258/201604/904258-20160414165730207-2105081113.png)属于i类。

参考文献：

周志华《机器学习》

Andrew NG 机器学习公开课

