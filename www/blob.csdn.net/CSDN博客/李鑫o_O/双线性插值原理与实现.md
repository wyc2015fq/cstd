# 双线性插值原理与实现 - 李鑫o_O - CSDN博客





置顶2016年03月05日 18:24:16[hustlx](https://me.csdn.net/HUSTLX)阅读数：1943









       在对图像进行空间变换的过程中，典型的情况是在对图像进行放大处理的时候，图像会出现失真的现象。这是由于在变换之后的图像中，存在着一些变换之前的图像中没有的像素位置。为了说明这个问题，不妨假设有一副大小为64x64的灰度图像A，现在将图像放大到256x256，不妨令其为图像B，如图1所示。显然，根据简单的几何换算关系，可以知道B图像中(x,y)处的像素值应该对应着A图像中的(x/4,y/4)处的象素值，即


B(x,y) = A(x/4,y/4) （式1）


对于B中的(4,4),(4,8),(4,16)…(256,256)这些位置，通过式1就可以计算出其在A中的位置，从而可以得到灰度值。但是，对于B中的(1,1),(1,2),(1,3)…等等这些坐标点而言，如果按照式1计算的话，那么它们在A中对应的坐标不再是整数。比如，对于B中的坐标点(1,1)，其在A中的对应坐标就变成了(0.25,0.25)。对于数字图像而言，小数坐标是没有意义的。因此，必须考虑采用某种方法来得到B中像素点在A中对应位置上的灰度级。处理这一问题的方法被称为图像灰度级插值。常用的插值方式有三种：最近邻域插值、双线性插值、双三次插值。理论上来讲，最近邻域插值的效果最差，双三次插值的效果最好，双线性插值的效果介于两者之间。不过对于要求不是非常严格的图像插值而言，使用双线性插值通常就足够了。


本文中将采用matlab实现一个双线性插值的程序。双线性插值的原理如图2所示。图像之间坐标映射有两种方式：如果是从原图像的坐标映射到目标图像，称为前向映射，反之则称为后向映射。显然，双线性插值采用的是后向映射方式。下面对图2的具体含义进行说明。首先，根据几何关系，从B图像中的坐标(x,y)得到A图像中的坐标(x/4,y/4)，但是，映射得到的这个坐标(x/4,y/4)并没有刚好位于A图像中的整数坐标上，而是映射到了四个像素坐标(a,b)、(a+1,b)、(a,b+1)、(a+1,b+1)所围成的矩形之间，其中，a、b是A图像的整数坐标。现在的问题就是如何根据A(a,b)、A(a+1,b)、A(a,b+1)、A(a+1,b+1)这四个点上的灰度级求出A(x/4,y/4)处的灰度级。双线性插值技术采用的方法是：假设A图像的灰度级变化在纵向方向上是线性变化的，这样根据直线方程或者几何比例关系就能够求得(a,y/4)和(a+1,y/4)坐标处的灰度级A(a,y/4)和A(a+1,y/4)。然后，再假设在((a,y/4),A(a,y/4))和(a+1,y/4),A(a+1,y/4))这两点所确定的直线上，灰度级仍然是线性变化的。求出直线方程，于是就可以求得(x/4,y/4)处的灰度级A(x/4,y/4)。这就是双线性插值的基本思路。其中用到的两个基本假设是：首先灰度级在纵向方向上是线性变化的，然后假定灰度级在横向方向上也是线性变化的。

![clip_image002[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305181954987-372201263.jpg)


图1 图像缩放示意图

![clip_image004[4]](http://images2015.cnblogs.com/blog/904258/201603/904258-20160305181955940-828447558.jpg)


图2 双线性插值示意图


附录:


I=imread('image1.bmp');


[m,n]=size(I);


K=3;


width = K * m;


height = K * n;


J = uint8(zeros(width,height));


% width scale and height scale


widthScale = m/width;


heightScale = n/height;


% bilinear interplot


for x = 5:width - 5


for y = 5:height - 5


xx = x * widthScale;


yy = y * heightScale;


if (xx/double(uint16(xx)) == 1.0) & (xx/double(uint16(xx)) == 1.0)


J(x,y) = I(int16(xx),int16(yy));


else % a or b is not integer


a = double(uint16(xx)); % (a,b) is the base-dot


b = double(uint16(yy));


x11 = double(I(a,b)); % x11 <- I(a,b)


x12 = double(I(a,b+1)); % x12 <- I(a,b+1)


x21 = double(I(a+1,b)); % x21 <- I(a+1,b)


x22 = double(I(a+1,b+1)); % x22 <- I(a+1,b+1)


J(x,y) = uint8( (b+1-yy) * ((xx-a)*x21 + (a+1-xx)*x11) + (yy-b) * ((xx-a)*x22 +(a+1-xx) * x12)); % calculate J(x,y)


end


end


end


% 显示图像


imwrite(J, '放大的图像.jpg', 'jpg');


imshow(I),title('原图');


figure


imshow(J),title('放大图');



