# 位运算实现加减乘除 - 李鑫o_O - CSDN博客





2016年08月12日 21:22:37[hustlx](https://me.csdn.net/HUSTLX)阅读数：2188








加法运算：



**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- int AddWithoutArithmetic(int num1,int num2)  
- {  
- if(num2==0) return num1;//没有进位的时候完成运算
- int sum,carry;  
-     sum=num1^num2;//完成第一步没有进位的加法运算
-     carry=(num1&num2)<<1;//完成第二步进位并且左移运算
- return AddWithoutArithmetic(sum,carry);//进行递归，相加
- }  


简化一下：



**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- int Add(int a,int b)  
- {  
- return b ? Add(a^b,(a&b)<<1) : a;  
- /*if(b)
-         return Add(a^b,(a&b)<<1);
-     else
-         return a;*/
- }  


上面的思路就是先不计进位相加，然后再与进位相加，随着递归，进位会变为0，递归结束。 

非递归的版本如下：



**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- int Add(int a, int b)  
- {  
- int ans;  
- while(b)  
-     {   //直到没有进位
-         ans = a^b;        //不带进位加法
-         b = ((a&b)<<1);   //进位
-         a = ans;  
-     }  
- return a;  
- }   


减法运算：





**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- //这个和加法一样了，首先取减数的补码，然后相加。
- int negtive(int a)   //取补码
- {  
- return Add(~a, 1);  
- }  
- int Sub(int a, int b)  
- {  
- return Add(a, negtive(b));  
- }   


正数乘法运算：





**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- //正数乘法运算
- int Pos_Multiply(int a,int b)  
- {  
- int ans = 0;  
- while(b)  
-     {  
- if(b&1)  
-             ans = Add(ans, a);  
-         a = (a<<1);  
-         b = (b>>1);  
-     }  
- return ans;  
- }  




整数除法（正整数）





**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- //除法就是由乘法的过程逆推，依次减掉（如果x够减的）y^(2^31),y^(2^30),...y^8,y^4,y^2,y^1。减掉相应数量的y就在结果加上相应的数量。
- int Pos_Div(int x,int y)  
- {  
- int ans=0;  
- for(int i=31;i>=0;i--)  
-     {  
- //比较x是否大于y的(1<<i)次方，避免将x与(y<<i)比较，因为不确定y的(1<<i)次方是否溢出
- if((x>>i)>=y)  
-         {  
-             ans+=(1<<i);  
-             x-=(y<<i);  
-         }  
-     }  
- return ans;  
- }  


完整的实现：





**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- // 加减乘除位运算 
- // 程序中实现了比较大小、加减乘除运算。所有运算都用位操作实现 
- // 在实现除法运算时，用了从高位到低位的减法 
- // 具体如下，算法也比较简单，所以没有作注释
- #include<iostream>
- #include<cstdio>
- usingnamespace std;  
- 
- int Add(int a, int b)  
- {  
- int ans;  
- while(b)  
-     {  //直到没有进位
-         ans = a^b;        //不带进位加法
-         b = ((a&b)<<1);   //进位
-         a = ans;  
-     }  
- return a;  
- }  
- 
- //这个和加法一样了，首先取减数的补码，然后相加。
- int negtive(int a)   //取补码
- {  
- return Add(~a, 1);  
- }  
- int Sub(int a, int b)  
- {  
- return Add(a, negtive(b));  
- }  
- 
- // 判断正负 
- int ispos( int a )   
- { //正
- return (a&0xFFFF) && !(a&0x8000);  
- }  
- int isneg( int a )   
- { //负
- return a&0x8000;  
- }  
- int iszero( int a )  
- { //0
- return !(a&0xFFFF);  
- }  
- 
- //正数乘法运算
- int Pos_Multiply(int a,int b)  
- {  
- int ans = 0;  
- while(b)  
-     {  
- if(b&1)  
-             ans = Add(ans, a);  
-         a = (a<<1);  
-         b = (b>>1);  
-     }  
- return ans;  
- }  
- 
- //乘法运算
- int Multiply(int a,int b)  
- {  
- if( iszero(a) || iszero(b) )  
- return 0;  
- if( ispos(a) && ispos(b) )  
- return Pos_Multiply(a, b);  
- if( isneg(a) )  
-     {  
- if( isneg(b) )  
-         {  
- return Pos_Multiply( negtive(a), negtive(b) );  
-         }  
- return negtive( Pos_Multiply( negtive(a), b ) );  
-     }  
- return negtive( Pos_Multiply(a, negtive(b)) );  
- }  
- 
- //除法就是由乘法的过程逆推，依次减掉（如果x够减的）y^(2^31),y^(2^30),...y^8,y^4,y^2,y^1。减掉相应数量的y就在结果加上相应的数量。
- int Pos_Div(int x,int y)  
- {  
- int ans=0;  
- for(int i=31;i>=0;i--)  
-     {  
- //比较x是否大于y的(1<<i)次方，避免将x与(y<<i)比较，因为不确定y的(1<<i)次方是否溢出
- if((x>>i)>=y)  
-         {  
-             ans+=(1<<i);  
-             x-=(y<<i);  
-         }  
-     }  
- return ans;  
- }  
- 
- //除法运算
- int MyDiv( int a, int b )  
- {  
- if( iszero(b) )  
-     {  
-         cout << "Error" << endl;  
-         exit(1);  
-     }  
- if( iszero(a) )  
- return 0;  
- if( ispos(a) )  
-     {  
- if( ispos(b) )  
- return Pos_Div(a, b);  
- return negtive( Pos_Div( a, negtive(b)) );  
-     }  
- if( ispos(b) )  
- return negtive( Pos_Div( negtive(a), b ) );  
- return Pos_Div( negtive(a), negtive(b) );  
- }   
- 
- 
- // 比较两个正数的大小（非负也可） 
- int isbig_pos( int a, int b )   
- {  //a>b>0
- int c = 1;  
-     b = (a^b);  
- if( iszero(b) )  
- return 0;  
- while( b >>= 1 )  
-     {  
-         c <<= 1;  
-     }  
- return (c&a);  
- }   
- 
- // 比较两个数的大小 
- int isbig( int a, int b )   
- { //a>b
- if( isneg(a) )  
-     {  
- if( isneg(b) )  
-         {  
- return isbig_pos( negtive(b), negtive(a) );  
-         }  
- return 0;  
-     }  
- if( isneg(b) )  
- return 1;  
- return isbig_pos(a, b);  
- }  

扩展：在不使用*、/、+、-、%操作符的情况下，如何求一个数的1/3？（用C语言实现）

使用位操作符并实现“+”操作



**[cpp]**[view
 plain](http://blog.csdn.net/hackbuteer1/article/details/7390093#)[copy](http://blog.csdn.net/hackbuteer1/article/details/7390093#)



- // 替换加法运算符
- int add(int x , int y)  
- {  
- int res;  
- while(y)       // 直到没有进位
-     {  
-         res = x^y;       // 不带进位的加法
-         y = ((x&y)<<1);  // 进位
-         x = res;  
-     }  
- return x;  
- }  
- 
- int divideby3(int num)  
- {  
- int sum = 0;  
- while(num > 3)  
-     {  
-         sum = add(num>>2 , sum);  
-         num = add(num>>2 , num&3);  
-     }  
- if(num == 3)  
-         sum = add(sum , 1);  
- return sum;  
- }  


原理：n = 4 * a + b; n / 3 = a + (a + b) / 3; 然后 sum += a, n = a + b 并迭代; 当 a == 0 (n < 4)时，sum += floor(n / 3); i.e. 1, if n == 3, else 0


