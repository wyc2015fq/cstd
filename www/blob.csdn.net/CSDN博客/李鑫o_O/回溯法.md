# 回溯法 - 李鑫o_O - CSDN博客





2016年03月21日 21:08:06[hustlx](https://me.csdn.net/HUSTLX)阅读数：635
个人分类：[算法](https://blog.csdn.net/HUSTLX/article/category/6145896)









**回溯法**

1、有许多问题，当需要找出它的解集或者要求回答什么解是满足某些约束条件的最佳解时，往往要使用回溯法。

2、回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。

3、回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含（剪枝过程），则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。

**问题的解空间 **

问题的解向量：回溯法希望一个问题的解能够表示成一个n元式(x1,x2,…,xn)的形式。

显约束：对分量xi的取值限定。

隐约束：为满足问题的解而对不同分量之间施加的约束。

解空间：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间。

注意：同一个问题可以有多种表示，有些表示方法更简单，所需表示的状态空间更小（存储量少，搜索方法简单）。

下面是n=3时的0-1背包问题用完全二叉树表示的解空间：

![](http://pic002.cnblogs.com/images/2010/153357/2010102215594557.jpg)



**生成问题状态的基本方法 **

扩展结点:一个正在产生儿子的结点称为扩展结点

活结点:一个自身已生成但其儿子还没有全部生成的节点称做活结点

死结点:一个所有儿子已经产生的结点称做死结点

深度优先的问题状态生成法：如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）

宽度优先的问题状态生成法：在一个扩展结点变成死结点之前，它一直是扩展结点

回溯法：为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死(剪枝)那些实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法。（回溯法 = 穷举 +　剪枝）

**回溯法的基本思想 **

(1)针对所给问题，定义问题的解空间；

(2)确定易于搜索的解空间结构；

(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

两个常用的剪枝函数：

(1)约束函数：在扩展结点处减去不满足约束的子数

(2)限界函数：减去得不到最优解的子树

　　用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。而显式地存储整个解空间则需要O(2^h(n))或O(h(n)!)内存空间。

**递归回溯 **

回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。



```cpp
// 针对N叉树的递归回溯方法
void backtrack (int t)
{
    if (t > n) {
       // 到达叶子结点，将结果输出
       output (x);
    }
    else {
       // 遍历结点t的所有子结点
       for (int i = f(n,t); i <= g(n,t); i ++ ) {
           x[t] = h[i];
           // 如果不满足剪枝条件，则继续遍历
           if (constraint (t) && bound (t)) 
              backtrack (t + 1);
       }
    }
}
```





**迭代回溯 **

采用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。



```cpp
// 针对N叉树的迭代回溯方法
void iterativeBacktrack ()
{
    int t = 1;
    while (t > 0) {
       if (f(n,t) <= g(n,t)) {
           //  遍历结点t的所有子结点
           for (int i = f(n,t); i <= g(n,t); i ++) {
              x[t] = h(i);
              // 剪枝
              if (constraint(t) && bound(t)) {
                  // 找到问题的解，输出结果
                  if (solution(t)) {
                     output(x);
                  }
                  else // 未找到，向更深层次遍历
                     t ++;
              }
           }
       }
       else {
           t--;
       }
    }
}
```





**回溯法一般依赖的两种数据结构：子集树和排列树**

**子集树**（遍历子集树需O(2^n)计算时间）

![](http://pic002.cnblogs.com/images/2010/153357/2010102222020822.jpg)



```cpp
void backtrack (int t)
{
    if (t > n)
       // 到达叶子结点
       output (x);
    else
       for (int i = 0;i <= 1;i ++) {
           x[t] = i;
           // 约束函数
           if ( legal(t) )
              backtrack( t+1 );
       }
}
```





**排列树**（遍历排列树需要O(n!)计算时间）

**![](http://pic002.cnblogs.com/images/2010/153357/2010102222034229.jpg)**



```cpp
void backtrack (int t)
{
    if (t > n)
       output(x);
    else
       for (int i = t;i <= n;i++) {
           // 完成全排列
           swap(x[t], x[i]);
           if (legal(t))
              backtrack(t+1);
           swap(x[t], x[i]);
       }
}
```








## 1. 0-1背包问题
**        问题：**给定n种物品和一背包。物品i的重量是wi，其价值为pi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
**        分析：**问题是n个物品中选择部分物品，可知，问题的解空间是子集树。比如物品数目n=3时，其解空间树如下图，边为1代表选择该物品，边为0代表不选择该物品。使用x[i]表示物品i是否放入背包，x[i]=0表示不放，x[i]=1表示放入。回溯搜索过程，如果来到了叶子节点，表示一条搜索路径结束，如果该路径上存在更优的解，则保存下来。如果不是叶子节点，是中点的节点（如B），就遍历其子节点（D和E），如果子节点满足剪枝条件，就继续回溯搜索子节点。




![](https://img-blog.csdn.net/20131113214705750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFydmlzQ2h1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



```cpp
#include <stdio.h>
#define N 3         //物品的数量
#define C 16        //背包的容量
int w[N] = { 10,8,5 };  //每个物品的重量
int v[N] = { 5,4,1 };   //每个物品的价值
int x[N] = { 0,0,0 };   //x[i]=1代表物品i放入背包，0代表不放入
int CurWeight = 0;  //当前放入背包的物品总重量
int CurValue = 0;   //当前放入背包的物品总价值
int BestValue = 0;  //最优值；当前的最大价值，初始化为0
int BestX[N];       //最优解；BestX[i]=1代表物品i放入背包，0代表不放入
					//t = 0 to N-1
void backtrack(int t)
{
	//叶子节点，输出结果
	if (t>N - 1)
	{
		//如果找到了一个更优的解
		if (CurValue>BestValue)
		{
			//保存更优的值和解
			BestValue = CurValue;
			for (int i = 0;i<N;++i) BestX[i] = x[i];
		}
	}
	else
	{
		//遍历当前节点的子节点：0 不放入背包，1放入背包
		for (int i = 0;i <= 1;++i)
		{
			x[t] = i;
			if (i == 0) //不放入背包
			{
				backtrack(t + 1);
			}
			else //放入背包
			{
				//约束条件：放的下
					if ((CurWeight + w[t]) <= C)
					{
						CurWeight += w[t];
						CurValue += v[t];
						backtrack(t + 1);
						CurWeight -= w[t];
						CurValue -= v[t];
					}
			}
		}
		//PS:上述代码为了更符合递归回溯的范式，并不够简洁
	}
}
int main(int argc, char* argv[])
{
	backtrack(0);

	printf("最优值：%d\n", BestValue);

	for (int i = 0;i<N;i++)
	{
		printf("最优解：%-3d", BestX[i]);
	}
	return 0;
}
```



## 2. 旅行售货员问题
[回溯法----旅行售货员问题](http://blog.csdn.net/jarvischu/article/details/6058931)




```cpp
/****************************************************************
 *问  题：旅行售货员
 *算  法：回溯法
 *描  述：解空间为 排列树
 ****************************************************************/
#include <stdio.h>
#define N 4				   //城市数目
#define NO_PATH -1		   //没有通路
#define MAX_WEIGHT 4000
int City_Graph[N+1][N+1];  //保存图信息
int x[N+1];                //x[i]保存第i步遍历的城市
int isIn[N+1];             //保存 城市i是否已经加入路径
int bestw;                 //最优路径总权值
int cw;                    //当前路径总权值
int bestx[N+1];            //最优路径
//-----------------------------------------------------------------
void Travel_Backtrack(int t){        //递归法
	int i,j;
	if(t>N){                         //走完了，输出结果
		for(i=1;i<=N;i++)            //输出当前的路径
			printf("%d ",x[i]);
		printf("/n");
		if(cw < bestw){              //判断当前路径是否是更优解
			for (i=1;i<=N;i++){
				bestx[i] = x[i];
			}
			bestw = cw;
		}
		return;
	}
	else{
		for(j=1;j<=N;j++){           //找到第t步能走的城市
			if(City_Graph[x[t-1]][j] != NO_PATH && !isIn[j]){ //能到而且没有加入到路径中
				isIn[j] = 1;
				x[t] = j;
				cw += City_Graph[x[t-1]][j];
				Travel_Backtrack(t+1);
				isIn[j] = 0;
				x[t] = 0;
				cw -= City_Graph[x[t-1]][j];
			}
		}
	}
}
void main(){
	int i;
	City_Graph[1][1] = NO_PATH;
	City_Graph[1][2] = 30;
	City_Graph[1][3] = 6;
	City_Graph[1][4] = 4;
	
	City_Graph[2][1] = 30;
	City_Graph[2][2] = NO_PATH;
	City_Graph[2][3] = 5;
	City_Graph[2][4] = 10;
	City_Graph[3][1] = 6;
	City_Graph[3][2] = 5;
	City_Graph[3][3] = NO_PATH;
	City_Graph[3][4] = 20;
	
	City_Graph[4][1] = 4;
	City_Graph[4][2] = 10;
	City_Graph[4][3] = 20;
	City_Graph[4][4] = NO_PATH;
	//测试递归法
	for (i=1;i<=N;i++){
		x[i] = 0;               //表示第i步还没有解
		bestx[i] = 0;           //还没有最优解
		isIn[i] = 0;            //表示第i个城市还没有加入到路径中
	}
	 
	x[1] = 1;                   //第一步 走城市1
	isIn[1] = 1;                //第一个城市 加入路径
	bestw = MAX_WEIGHT;
	cw = 0;
	Travel_Backtrack(2);        //从第二步开始选择城市
	printf("最优值为%d/n",bestw);
	printf("最优解为:/n");
	for(i=1;i<=N;i++){
		printf("%d ",bestx[i]);
	}
	printf("/n");
}
```










## 3. 详细描述N皇后问题

**       问题：**在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

       N皇后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。

**      分析：**从n×n个格子中选择n个格子摆放皇后。可见解空间树为子集树。

      使用Board[N][N]来表示棋盘，Board[i][j]=0 表示(I,j)位置为空，Board[i][j]=1 表示(I,j)位置摆放有一个皇后。

      全局变量way表示总共的摆放方法数目。

      使用Queen(t)来摆放第t个皇后。Queen(t) 函数符合子集树时的递归回溯范式。当t>N时，说明所有皇后都已经摆   放完成，这是一个可行的摆放方法，输出结果；否则，遍历棋盘，找皇后t所有可行的摆放位置，Feasible(i,j)
 判断皇后t能否摆放在位置(i,j)处，如果可以摆放则继续递归摆放皇后t+1，如果不能摆放，则判断下一个位置。

       Feasible(row,col)函数首先判断位置(row,col)是否合法，继而判断(row,col)处是否已有皇后，有则冲突，返回0，无则继续判断行、列、斜方向是否冲突。斜方向分为左上角、左下角、右上角、右下角四个方向，每次从（row,col）向四个方向延伸一个格子，判断是否冲突。如果所有方向都没有冲突，则返回1，表示此位置可以摆放一个皇后。

![](https://img-blog.csdn.net/20131113215748734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFydmlzQ2h1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


**        代码：**




```cpp
/************************************************************************ 
 * 名  称：NQueen.cpp
 * 功  能：回溯算法实例：N皇后问题 
 * 作  者：JarvisChu 
 * 时  间：2013-11-13 
 ************************************************************************/ 
 
#include <stdio.h>
 
#define N 8
 
int Board[N][N];<span style="white-space:pre">	</span>//棋盘 0表示空白 1表示有皇后
int way;<span style="white-space:pre">		</span>//摆放的方法数
 
 
//判断能否在(x,y)的位置摆放一个皇后；0不可以，1可以
int Feasible(int row,int col)
{
	//位置不合法
	if(row>N || row<0 || col >N || col<0)
		return 0;
 
	//该位置已经有皇后了，不能
	if(Board[row][col] != 0)
	{	//在行列冲突判断中也包含了该判断，单独提出来为了提高效率
		return 0;
	}
 
	//////////////////////////////////////////////////
	//下面判断是否和已有的冲突
 
	//行和列是否冲突
	for(int i=0;i<N;++i)
	{
		if(Board[row][i] != 0 || Board[i][col]!=0)
			return 0;
	}
 
	//斜线方向冲突
 
	for(int i=1;i<N;++i)
	{
/* i表示从当前点(row,col)向四个斜方向扩展的长度
 
左上角 \  / 右上角   i=2
        \/           i=1
        /\           i=1
左下角 /  \ 右下角   i=2
*/
		//左上角
		if((row-i)>=0 && (col-i)>=0)    //位置合法
		{
			if(Board[row-i][col-i] != 0)//此处已有皇后，冲突
				return 0;
		}
 
		//左下角
		if((row+i)<N && (col-i)>=0)
		{
			if(Board[row+i][col-i] != 0)
				return 0;
		}
 
		//右上角
		if((row-i)>=0 && (col+i)<N)
		{
			if(Board[row-i][col+i] != 0)
				return 0;
		}
 
		//右下角
		if((row+i)<N && (col+i)<N)
		{
			if(Board[row+i][col+i] != 0)
				return 0;
		}
	}
 
	return 1; //不会发生冲突，返回1
}
 
 
//摆放第t个皇后 ；从1开始
void Queen(int t)
{
	//摆放完成，输出结果
	if(t>N)
	{
		way++;
		/*如果N较大，输出结果会很慢；N较小时，可以用下面代码输出结果
		for(int i=0;i<N;++i){
			for(int j=0;j<N;++j)
				printf("%-3d",Board[i][j]);
			printf("\n");
		}
		printf("\n------------------------\n\n");
		*/
	}
	else
	{
		for(int i=0;i<N;++i)
		{
			for(int j=0;j<N;++j)
			{
				//（i,j）位置可以摆放皇后，不冲突
				if(Feasible(i,j))
				{
					Board[i][j] = 1;  //摆放皇后t
					Queen(t+1);       //递归摆放皇后t+1
					Board[i][j] = 0;  //恢复
				}
			}
		}
	}
}
 
//返回num的阶乘,num!
int factorial(int num)
{
	if(num==0 || num==1)
		return 1;
	return num*factorial(num-1);
}
 
 
int main(int argc, char* argv[])
{
	//初始化
	for(int i=0;i<N;++i)
	{
		for(int j=0;j<N;++j)
		{
			Board[i][j]=0;
		}
	}
 
	way = 0;
 
	Queen(1);  //从第1个皇后开始摆放
 
	//如果每个皇后都不同
	printf("考虑每个皇后都不同，摆放方法：%d\n",way);//N=8时, way=3709440 种
 
	//如果每个皇后都一样，那么需要除以 N！出去重复的答案（因为相同，则每个皇后可任意调换位置）
	printf("考虑每个皇后都不同，摆放方法：%d\n",way/factorial(N));//N=8时, way=3709440/8! = 92种
 
	return 0;
}
```

**PS：**该问题还有更优的解法。充分利用问题隐藏的约束条件：每个皇后必然在不同的行(列)，每个行(列)必然也只有一个皇后。这样我们就可以把N个皇后放到N个行中，使用Pos[i]表示皇后i在i行中的位置（也就是列号）（i = 0 to
 N-1）。这样代码会大大的简洁，因为节点的子节点数目会减少，判断冲突也更简单。




## 4. 迷宫问题

**        问题：**给定一个迷宫，找到从入口到出口的所有可行路径，并给出其中最短的路径

**        分析：**用二维数组来表示迷宫，则走迷宫问题用回溯法解决的的思想类似于图的深度遍历。从入口开始，选择下一个可以走的位置，如果位置可走，则继续往前，如果位置不可走，则返回上一个位置，重新选择另一个位置作为下一步位置。

        N表示迷宫的大小，使用Maze[N][N]表示迷宫，值为0表示通道（可走），值为1表示不可走（墙或者已走过）；

        Point结构体用来记录路径中每一步的坐标(x,y)

       (ENTER_X,ENTER_Y) 是迷宫入口的坐标

       (EXIT_X, EXIT _Y)    是迷宫出口的坐标

       Path容器用来存放一条从入口到出口的通路路径

       BestPath用来存放所有路径中最短的那条路径




       Maze()函数用来递归走迷宫，具体步骤为：

       1. 首先将当前点加入路径，并设置为已走
       2. 判断当前点是否为出口，是则输出路径，保存结果；跳转到4
       3. 依次判断当前点的上、下、左、右四个点是否可走，如果可走则递归走该点
       4. 当前点推出路径，设置为可走

**       代码：**

```cpp
/************************************************************************ 
 * 名  称：Maze.cpp
 * 功  能：回溯算法实例：迷宫问题
 * 作  者：JarvisChu 
 * 时  间：2013-11-13 
 ************************************************************************/ 
#include <iostream>
#include <vector>
 
using namespace std;
 
typedef struct
{
	int x;
	int y;
}Point;
 
#define N 10         //迷宫的大小
#define ENTER_X 0    //入口的位置（0，0）
#define ENTER_Y 0
#define EXIT_X N-1   //出口的位置(N-1,N-1)
#define EXIT_Y N-1 
 
 
int Maze[N][N];<span style="white-space:pre">		</span>//定义一个迷宫，0表示通道，1表示不可走（墙或已走）
int paths;<span style="white-space:pre">		</span>//路径条数
vector<Point> Path;<span style="white-space:pre">	</span>//保存一条可通的路径
vector<Point> BestPath;<span style="white-space:pre">	</span>//保存最短的路径
 
bool First = true;<span style="white-space:pre">	</span>//标志，找到第一条路径
 
//初始化迷宫
void InitMaze()
{
<span style="white-space:pre">	</span>//简单起见，本题定义一个固定大小10*10的迷宫
<span style="white-space:pre">	</span>//定义一个迷宫，0表示通道，1表示墙(或不可走)
	int mz[10][10]={
	{0,0,1,1,1,1,1,1,1,1}, //0
	{1,0,0,1,1,0,0,1,0,1}, //1
	{1,0,0,1,0,0,0,1,0,1}, //2
	{1,0,0,0,0,1,1,0,0,1}, //3
	{1,0,1,1,1,0,0,0,0,1}, //4
	{1,0,0,0,1,0,0,0,0,1}, //5
	{1,0,1,0,0,0,1,0,0,1}, //6
	{1,0,1,1,1,0,1,1,0,1}, //7
	{1,1,0,0,0,0,0,0,0,0}, //8
	{1,1,1,1,1,1,1,1,1,0}  //9
    //   0 1 2 3 4 5 6 7 8 9
	}; 
 
	//复制到迷宫
	memcpy(Maze,mz,sizeof(mz));
 
	paths = 0;
}
 
//从(x,y)位置开始走；初始为(0,0)
void MazeTrack(int x,int y)
{
	///////////////////////////////////////
	//当前点加入到路径
	Point p={x,y};
	Path.push_back(p);
	Maze[x][y] = 1;         //设置为已走，不可走
 
	//cout<<"来到("<<x<<","<<y<<")"<<endl;
 
	///////////////////////////////////////
	//如果该位置是出口，输出结果
	if(x == EXIT_X && y== EXIT_Y)
	{
		cout<<"找到一条道路"<<endl;
		paths++;
		
		//输出路径
		vector<Point>::iterator it;
		for(it=Path.begin();it!=Path.end();++it)
		{
			cout<<"("<<it->x<<","<<it->y<<") ";
		}
		cout<<endl;
 
		//判断是否更优
		if(First)//如果是找到的第一条路径，直接复制到最优路径
		{
			for(it=Path.begin();it!=Path.end();++it)
			{
				BestPath.push_back(*it);
			}
			First = false;
		}
		else //不是第一条，则判断是否更短
		{
			//更短，复制到最优路径
			if(Path.size()<BestPath.size())
			{
				BestPath.clear();
				for(it=Path.begin();it!=Path.end();++it)
				{
					BestPath.push_back(*it);
				}
			}
		}
	}
 
	///////////////////////////////////////
	//判断(x,y)位置的上、下、左、右是否可走
 
	if((x-1)>=0 && Maze[x-1][y]==0)//上(x-1,y)；存在且可走
	{
		MazeTrack(x-1,y);
	}
 
	if((x+1)<N && Maze[x+1][y]==0)//下(x+1,y)；存在且可走
	{
		MazeTrack(x+1,y);
	}
 
	if((y-1)>=0 && Maze[x][y-1]==0)//左(x,y-1)；存在且可走
	{
		MazeTrack(x,y-1);
	}
 
	if((y+1)<N && Maze[x][y+1]==0)//右(x,y+1)；存在且可走
	{
		MazeTrack(x,y+1);
	}
 
	///////////////////////////////////////
	//返回上一步
	Path.pop_back();
	Maze[x][y] = 0;         //设置为未走
}
 
 
int main(int argc, char* argv[])
{
	//初始化迷宫
	InitMaze();
		
/*	//显示迷宫
	for(int i=0;i<N;++i){
		for(int j=0;j<N;++j)
			cout<<Maze[i][j]<<"  ";
		cout<<endl;
	}*/
 
	//回溯法走迷宫
	MazeTrack(ENTER_X,ENTER_Y);
 
	//显示最优的路径
	cout<<"可行路径总条数为"<<paths<<"；最优路径为"<<endl;
	vector<Point>::iterator it;
	for(it=BestPath.begin();it!=BestPath.end();++it)
	{
		cout<<"("<<it->x<<","<<it->y<<") ";
	}
	cout<<endl;
	return 0;
}
```


作者 ：JarvisChu

[出处：http://blog.csdn.net/jarvischu](http://blog.csdn.net/jarvischu)





