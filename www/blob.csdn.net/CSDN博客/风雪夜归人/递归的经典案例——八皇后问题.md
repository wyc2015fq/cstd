# 递归的经典案例——八皇后问题 - 风雪夜归人 - CSDN博客
2018年05月08日 20:17:25[cdjccio](https://me.csdn.net/qq_34624951)阅读数：95
解决方案：
    算法是逐行安排皇后的，其参数row为现在正执行到第几行。n是皇后数，在八皇后问题里当然就是8啦。
        第2行好理解，如果程序当前能正常执行到第8行，那自然是找到了一种解法，于是八皇后问题解法数加1。
如果当前还没排到第八行，则进入else语句。遍历所有列col，将当前col存储在数组c里，然后使用is_ok()检查row行col列能不能摆皇后，若能摆皇后，则递归调用queen去安排下一列摆皇后的问题。
        还不太清楚？再慢点来，刚开始的时候row=0，意思是要对第0行摆皇后了。
　　 If判断失败，进入else，进入for循环，col初始化为0
　　 显然，0行0列的位置一定可以摆皇后的，因为这是第一个皇后啊，后宫空荡她想怎么折腾就怎么折腾，于是is_ok(0)测试成功，递归调用queen(1)安排第1行的皇后问题。
　　 第1行时row=1，进来if依然测试失败，进入for循环，col初始化为0。1行0列显然是不能摆皇后的，因为0行0列已经有一个圣母皇太后在那搁着了，于是is_ok()测试失败，循环什么也不做空转一圈，col变为1。1行1列依然is_ok()测试失败，一直到1行2列，发现可以摆皇后，于是继续递归queen(2)去安排第二个皇后位置。
　　如果在某种情况下问题无解呢？例如前面在4皇后问题中，0行0列摆皇后是无解的。假设前面递归到queen(2)时候，发现第2行没有地方可以摆皇后，那怎么办呢？要注意queen(2)的调用是在queen(1)的for循环框架内的，queen(2)若无解，则自然而然queen(1)的for循环col自加1，即将第1行的皇后从1行2列改为1行3列的位置，检查可否放皇后后继续安排下一行的皇后。如此递归，当queen(0)的col自加到7，说明第一列的皇后已经遍历了从0行1列到0行7列，此时for循环结束，程序退出。
　　 在主函数中调用queen(0)，得到正确结果，8皇后问题一共有92种解法。
```cpp
#include<iostream>
#include<math.h>
using namespace std;
int n=8;
int total=0;
int *c=new int(n);
bool is_ok(int row){
    for(int j = 0; j < row; j ++){
        // 既然是逐行放置的，则皇后肯定不会横向攻击，
        // 因此只需检查是否纵向和斜向攻击即可
        // row-c[row] == j-c[j] || row+c[row] == j+c[j]
        // 用来判断皇后(row,c[row])和(j,c[j])是否在同一条对角线上
        if(c[row] == c[j] || row-c[row] == j-c[j] || row+c[row] == j+c[j])
            return false;
    }
    return true;
}
void queen(int row){
    if(row == n)
    {
        total ++;
    }
    else
    {
        for(int col = 0; col < n;col ++)
        {
            c[row] = col;  // 尝试把第row行的皇后放在第col列
            if(is_ok(row)) // 检查是否和前面的皇后冲突
                queen(row + 1);
        }
    }
}
int main(){
    queen(0);
    cout << total;
    return 1;
}
```
