# 普通排序算法和高效排序算法 - 风雪夜归人 - CSDN博客
2018年08月12日 21:40:59[cdjccio](https://me.csdn.net/qq_34624951)阅读数：125
```cpp
#include <iostream>
#include <time.h>
#include <algorithm>
using namespace std;
//---------------------------------------------
//                   普通排序算法
//---------------------------------------------
// 插入排序
void insertSort(int data[], int len)
{
    int i = 0;
    int j = 0;
    clock_t start, finish;
    double totaltime;
    start = clock();
    // 排序
    for(; i<len; i++)
    {
        int tmp = data[i]; // 将当前的元素提取出来
        for(j = i; data[j-1] > tmp && j > 0; j--) // tmp小于前面的元素时进入循环
        {
            data[j] = data[j - 1]; // 将所有大于tmp的元素都向后移动一个位置
        }
        data[j] = tmp;
    }
    finish = clock();
    totaltime = (double)(finish - start)/CLOCKS_PER_SEC;
    cout << "插入排序的运行时间：" << totaltime <<  "秒" << endl;
}
//选择排序
void selectSort(int data[], int len)
{
    int i = 0;
    int j = 0;
    int least = 0;
    for(; i < len - 1; i++) // 最后一次比较时结果已经出来
    {
        least = i;
        for(j = i + 1; j < len; j++)
        {
            if(data[j] < data[least])
                least = j;
        }
        swap(data[i], data[least]);
    }
}
//冒泡排序
void bubbleSort(int data[], int len)
{
    for(int i = 0; i < len; i++)
    {
        for(int j = len - 1; j > 0; j--)
        {
            if(data[j] < data[j - 1])
                swap(data[j], data[j - 1]);
        }
    }
}
//---------------------------------------------
//                   高效排序算法
//---------------------------------------------
// 希尔排序
void shellSort(int data[], int len)
{
    int increment = len/3 + 1;
    while(increment > 0)
    {
        for(int i = increment; i < len; i++)
        {
            //每个增量间隔内，实现插入排序，两个for循环和插入排序一样，只不过第二个for循环里参数略有调整而已，和h有关
            for(int j = i; j < len; j += increment)
            {
                for(int k = j; (k - increment >= 0) && data[k] < data[k - increment]; k -= increment)
                {
                    swap(data[k], data[k-increment]);
                }
            }
        }
        increment = (increment-1) / 3;
    }
}
// 堆排序
void moveDown(int data[], int first, int last)
{
    int largest = 2 * first + 1;
    while(largest <= last)
    {
        // first有两个孩子，分别是2*first+1 和2*first+2 并且第二个孩子大于第一个孩子
        if(largest < last && data[largest] < data[largest + 1])
            largest ++;
        if(data[first] < data[largest])
        {
            swap(data[first], data[largest]);
            first = largest;
            largest = 2 * first + 1;
        }
        else
        {
            largest = last + 1;
        }
    }
}
void heapSort(int data[], int len)
{
    for(int i = len/2 - 1; i >= 0; --i)
    {
        moveDown(data, i, len - 1); // 创建堆
    }
    for(int i = len - 1; i >= 1; --i)
    {
        swap(data[0], data[i]);
        moveDown(data, 0, i - 1);   // 重建堆
    }
}
// 快速排序
void _quickSort(int data[], int first, int last)
{
    swap(data[(first + last) / 2], data[first]);
    int bound = data[first];
    int lower = first + 1;
    int upper = last;
    while(lower < upper)
    {
        while(data[lower] < bound)        // 寻找大于边界值的值
            lower ++;
        while(data[upper] > bound)        // 寻找小于边界值的值
            upper --;
        if(lower < upper)
        {
            swap(data[lower ++], data[upper --]); // 交换寻找到的两个值
        }
        else
        {
            lower ++;
        }
    }
    swap(data[upper], data[first]);      // 将边界值与upper交换，目的是将边界值放在左边数组的最右位置
    if(first < upper - 1)
        _quickSort(data, first, upper - 1);
    if(upper + 1 < last)
        _quickSort(data, upper + 1, last);
}
void quickSort(int data[], int len)
{
    if(len < 2)
    {
        return;
    }
    int max = 0;
    int i = 0;
    for(; i < len; i++)             // 寻找数组中最大的数
    {
        if(data[i] > data[max])
            max = i;
    }
    swap(data[max], data[len- 1]); //将最大的数放在数组的末尾
    _quickSort(data, 0, len - 2);
}
// 归并排序
void mergeSort(int data[], int len)
{
}
int main()
{
    int data[14] = {2,1,4,6,99,45,23,5,22,0,13,44,101,100};
    //insertSort(data, 10);
    //selectSort(data, 10);
    //bubbleSort(data, 10);
    //shellSort(data, 14);
    //heapSort(data, 14);
    quickSort(data, 14);
    for(int i = 0; i<14; i++)
    {
        cout << data[i] << " ";
    }
    cout << endl;
    return 0;
}
```
