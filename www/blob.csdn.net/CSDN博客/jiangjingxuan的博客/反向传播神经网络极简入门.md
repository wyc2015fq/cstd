# 反向传播神经网络极简入门 - jiangjingxuan的博客 - CSDN博客





2017年02月03日 15:24:40[jiangjingxuan](https://me.csdn.net/jiangjingxuan)阅读数：402








我一直在找一份简明的神经网络入门，然而在中文圈里并没有找到。直到我看到了这份162行的Python实现，以及对应的油管视频之后，我才觉得这就是我需要的极简入门资料。这份极简入门笔记不需要突触的图片做装饰，也不需要赘述神经网络的发展历史；要推导有推导，要代码有代码，关键是，它们还对得上。对于欠缺的背景知识，利用斯坦福大学的神经网络wiki进行了补全。

## 单个神经元

神经网络是多个“神经元”（感知机）的带权级联，神经网络算法可以提供非线性的复杂模型，它有两个参数：权值矩阵{Wl}和偏置向量{bl}，不同于感知机的单一向量形式，{Wl}是复数个矩阵，{bl}是复数个向量，其中的元素分别属于单个层，而每个层的组成单元，就是神经元。

### 神经元

神经网络是由多个“神经元”（感知机）组成的，每个神经元图示如下：

![神经元.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsm4yho09j208c044t8o.jpg)

这其实就是一个单层感知机，其输入是由![神经网络2.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsm87f1juj202200da9t.jpg)和+1组成的向量，其输出为![神经网络3.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsm8wslcqj209200nwec.jpg)，其中f是一个激活函数，模拟的是生物神经元在接受一定的刺激之后产生兴奋信号，否则刺激不够的话，神经元保持抑制状态这种现象。这种由一个阈值决定两个极端的函数有点像示性函数，然而这里采用的是Sigmoid函数，其优点是连续可导。

### Sigmoid函数

常用的Sigmoid有两种——

**单极性Sigmoid函数**

![单极性Sigmoid.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsmi0qapmj204v01awea.jpg)

或者写成

![神经网络5.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsmk9h09aj204s01st8k.jpg)

其图像如下


![sigmoid及tanh的函数图像.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsmps4xz7j20b408cmx8.jpg)

**双极性Sigmoid函数**

![双曲正切函数.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsmlquru2j206e0173yc.jpg)

或者写成

![神经网络6.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsmnqs1p6j204o02bwee.jpg)

把第一个式子分子分母同时除以ez，令x=-2z就得到第二个式子了，换汤不换药。

其图像如下

![tanh的函数图像.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsmq4drggj20b408ct8r.jpg)

从它们两个的值域来看，两者名称里的极性应该指的是正负号。从导数来看，它们的导数都非常便于计算：

对于![单极性Sigmoid.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsmi0qapmj204v01awea.jpg)有![神经网络7.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsmwdv9bmj205900lwea.jpg)，对于tanh，有![神经网络8.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsmwrhefuj204g00ma9u.jpg)。

视频作者Ryan还担心观众微积分学的不好，细心地给出了1/(1+e^-x)求导的过程：

![神经网络20.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exspyed1nrj20bz094js7.jpg)

一旦知道了f(z)，就可以直接求f'(z)，所以说很方便。

本Python实现使用的就是1/(1+e^-x)

```python

```
- def sigmoid(x):
- """
-     sigmoid 函数，1/(1+e^-x)
-     :param x:
-     :return:
-     """
- return1.0/(1.0+math.exp(-x))
- 
- 
- def dsigmoid(y):
- """
-     sigmoid 函数的导数
-     :param y:
-     :return:
-     """
- return y *(1- y)

也可以使用双曲正切函数tanh
- def sigmoid(x):
- """
-     sigmoid 函数，tanh 
-     :param x:
-     :return:
-     """
- return math.tanh(x)

其导数对应于：

```python

```
- def dsigmoid(y):
- """
-     sigmoid 函数的导数
-     :param y:
-     :return:
-     """
- return1.0- y **2

## 神经网络模型

神经网络就是多个神经元的级联，上一级神经元的输出是下一级神经元的输入，而且信号在两级的两个神经元之间传播的时候需要乘上这两个神经元对应的权值。例如，下图就是一个简单的神经网络：

![简单的神经网络.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsoi5cumdj20m80fo40r.jpg)

其中，一共有一个输入层，一个隐藏层和一个输出层。输入层有3个输入节点，标注为+1的那个节点是偏置节点，偏置节点不接受输入，输出总是+1。

定义上标为层的标号，下标为节点的标号，则本神经网络模型的参数是：![神经网络9.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsosba5igj206x00nweb.jpg)，其中![神经网络10.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsotb63nhj200z00s3y9.jpg)是第l层的第j个节点与第l+1层第i个节点之间的连接参数（或称权值）；![神经网络11.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsouvrte5j200n00q0lm.jpg)表示第l层第i个偏置节点。这些符号在接下来的前向传播将要用到。

### 前向传播

虽然标题是《（误差）后向传播神经网络入门》，但这并不意味着可以跳过前向传播的学习。因为如果后向传播对应训练的话，那么前向传播就对应预测（分类），并且训练的时候计算误差也要用到预测的输出值来计算误差。

定义![神经网络12.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsp0odbm6j200p00q0l3.jpg)为第l层第i个节点的激活值（输出值）。当l=1时，![神经网络13.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsp1go028j201z00q741.jpg)。前向传播的目的就是在给定模型参数![神经网络14.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsp2mk4wlj200y00i0of.jpg)的情况下，计算l=2,3,4…层的输出值，直到最后一层就得到最终的输出值。具体怎么算呢，以上图的神经网络模型为例：

![神经网络15.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsp4xmrvqj20d603k74q.jpg)

这没什么稀奇的，核心思想是这一层的输出乘上相应的权值加上偏置量代入激活函数等于下一层的输入，一句大白话，所谓中文伪码。

另外，追求好看的话可以把括号里面那个老长老长的加权和定义为一个参数：![2.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exspbukq8ej200o00q0k5.jpg)表示第l层第i个节点的输入加权和，比如![神经网络16.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exspcjjj7lj205s00tq2r.jpg)。那么该节点的输出可以写作![神经网络17.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exspdeueyrj202w00q0si.jpg)。

于是就得到一个好看的形式：

![神经网络18.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exspefrfuhj205p03d749.jpg)

在这个好看的形式下，前向传播可以简明扼要地表示为：

![神经网络19.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exspfctszuj205101jmx0.jpg)

在Python实现中，对应如下方法：
- def runNN(self, inputs):
- """
-         前向传播进行分类
-         :param inputs:输入
-         :return:类别
-         """
- if len(inputs)!=self.ni -1:
- print'incorrect number of inputs'
- 
- for i in range(self.ni -1):
- self.ai[i]= inputs[i]
- 
- for j in range(self.nh):
-             sum =0.0
- for i in range(self.ni):
-                 sum +=(self.ai[i]*self.wi[i][j])
- self.ah[j]= sigmoid(sum)
- 
- for k in range(self.no):
-             sum =0.0
- for j in range(self.nh):
-                 sum +=(self.ah[j]*self.wo[j][k])
- self.ao[k]= sigmoid(sum)
- 
- returnself.ao

其中，ai、ah、ao分别是输入层、隐藏层、输出层，而wi、wo则分别是输入层到隐藏层、隐藏层到输出层的权值矩阵。在本Python实现中，将偏置量一并放入了矩阵，这样进行线性代数运算就会方便一些。

## 后向传播

后向传播指的是在训练的时候，根据最终输出的误差来调整倒数第二层、倒数第三层……第一层的参数的过程。

### **符号定义**

在Ryan的讲义中，符号定义与斯坦福前向传播讲义相似但略有不同：

![神经网络21.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsq90t0ybj200q00ya9t.jpg)：第l层第j个节点的输入。

![神经网络22.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsq9w0bcqj200z010mwx.jpg)：从第l-1层第i个节点到第l层第j个节点的权值。

![神经网络23.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsqe99voqj203k012q2r.jpg)：Sigmoid函数。

![神经网络24.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsqex83qwj200m00xdfl.jpg)：第l层第j个节点的偏置。

![神经网络25.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsqfm5snbj200u00ymwx.jpg)：第l层第j个节点的输出。

![神经网络26.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsqgfwe3yj200k00s0sh.jpg)：输出层第j个节点的目标值（Target value）。

### **输出层权值调整**

给定训练集![神经网络28.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsqlx21auj200o00s0sh.jpg)和模型输出![神经网络29.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsqm82b38j200v00sdfl.jpg)（这里没有上标l是因为这里在讨论输出层，l是固定的），输出层的输出误差（或称损失函数吧）定义为：


![神经网络27.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsqjlngfcj205v01zwef.jpg)

其实就是所有实例对应的误差的平方和的一半，训练的目标就是最小化该误差。怎么最小化呢？看损失函数对参数的导数![神经网络30.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsqpht3ewj2018015gle.jpg)呗。


将E的定义代入该导数：


![神经网络31.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsqquiqx6j208e0200st.jpg)

无关变量拿出来：


![神经网络32.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsqrn32fyj207a01tjre.jpg)

看到这里大概明白为什么非要把误差定义为误差平方和的**一半**了吧，就是为了好看，数学家都是外貌协会的。

将![神经网络37.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5u28rsj200v00qgld.jpg)=![神经网络36.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5xd70dj201f00va9u.jpg)（输出层的输出等于输入代入Sigmoid函数）这个关系代入有：


![神经网络34.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsqxalhvzj207y01ot8q.jpg)

对Sigmoid求导有：

![神经网络35.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsqy7sxpdj20bb01sjrj.jpg)

要开始耍小把戏了，由于输出层第k个节点的输入![神经网络38.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsr8ldc7pj200m00l3y9.jpg)等于上一层第j个节点的输出![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)乘上![神经网络100.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exybssl393j201000tq2p.jpg)，即![神经网络38.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsr8ldc7pj200m00l3y9.jpg)=![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)![神经网络100.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exybssl393j201000tq2p.jpg)，而上一层的输出![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)是与到输出层的权值变量![神经网络100.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exybssl393j201000tq2p.jpg)无关的，可以看做一个常量，是线性关系。所以对![神经网络38.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsr8ldc7pj200m00l3y9.jpg)求权值变量![神经网络40.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsrbf9eb8j200y00rq2p.jpg)的偏导数直接等于![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)，也就是说：![神经网络41.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsrc0j0sej202301mt8j.jpg)=![神经网络42.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrck860ij201l01k3yb.jpg)(![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)![神经网络100.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exybssl393j201000tq2p.jpg))=![神经网络39.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr8zvgs9j200r00udfl.jpg)。

然后将上面用过的![神经网络36.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5xd70dj201f00va9u.jpg)=![神经网络37.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5u28rsj200v00qgld.jpg)代进去就得到最终的：

![神经网络43.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrdpbx8wj208n01m74b.jpg)

为了表述方便将上式记作：

![神经网络44.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsrhazaatj203p01pmx1.jpg)



其中：

![神经网络45.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsrhmncrij2072013747.jpg)



### 隐藏层权值调整

依然采用类似的方法求导，只不过求的是关于隐藏层和前一层的权值参数的偏导数：

![神经网络46.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsriy1k53j207w01st8s.jpg)



老样子：

![神经网络47.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsrkolivjj208301sjrg.jpg)



还是老样子：

![神经网络48.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsrlg3532j208n01xdfx.jpg)



还是把Sigmoid弄进去：

![神经网络49.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrmd3orij20bo01yjrl.jpg)



把![神经网络36.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5xd70dj201f00va9u.jpg)=![神经网络37.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5u28rsj200v00qgld.jpg)代进去，并且将导数部分拆开：

![神经网络51.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsro5phb2j20bx01xglv.jpg)



又要耍把戏了，输出层的输入等于上一层的输出乘以相应的权值，亦即![神经网络38.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsr8ldc7pj200m00l3y9.jpg)=![神经网络52.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrqg0a66j200x00vgld.jpg)![神经网络53.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrr1tkgbj200n00q741.jpg)，于是得到：

![神经网络54.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrs2dsbyj20bk01tglt.jpg)



把最后面的导数挪到前面去，接下来要对它动刀了：

![神经网络55.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsrtm5d94j20ba021gls.jpg)



再次利用![神经网络37.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5u28rsj200v00qgld.jpg)=![神经网络36.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsr5xd70dj201f00va9u.jpg)，这对j也成立，代进去：

![神经网络56.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsrw4irm6j20e401ujro.jpg)



再次利用![神经网络38.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exsr8ldc7pj200m00l3y9.jpg)=![神经网络52.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrqg0a66j200x00vgld.jpg)![神经网络53.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrr1tkgbj200n00q741.jpg)，j换成i，k换成j也成立，代进去：

![神经网络57.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsrxh5uixj20dc01udg2.jpg)



利用刚才定义的![神经网络58.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsry8kcjuj200q00u3y9.jpg)，最终得到：

![神经网络59.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsryo2orzj208i01z0st.jpg)





其中：

![神经网络45.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsrhmncrij2072013747.jpg)

我们还可以仿照![神经网络58.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exsry8kcjuj200q00u3y9.jpg)的定义来定义一个![神经网络60.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exss0egjsuj200j00z0sh.jpg)，得到：

![神经网络61.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exss0rhdxhj203c01nglh.jpg)

其中

![神经网络70.png](http://ww2.sinaimg.cn/large/6cbb8645gw1exstgaf8arj207g01oq2x.jpg)



### 偏置的调整

因为没有任何节点的输出流向偏置节点，所以偏置节点不存在上层节点到它所对应的权值参数，也就是说不存在关于权值变量的偏导数。虽然没有流入，但是偏置节点依然有输出（总是+1），该输出到下一层某个节点的时候还是会有权值的，对这个权值依然需要更新。

我们可以直接对偏置求导，发现：

![神经网络63.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exssgpc4k9j205d01mdfs.jpg)

原视频中说∂O/∂θ=1，这是不对的，作者也在讲义中修正了这个错误，∂O/∂θ=O(1–O)。

然后再求![神经网络66.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exst2opwizj201001odfm.jpg)，![神经网络68.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exst9vfd76j208301s74b.jpg)，后面的导数等于![神经网络69.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exstak8kjuj204d01ia9y.jpg)，代进去有

![神经网络65.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exssrzue19j202c01lq2r.jpg)

其中，

![神经网络45.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exsrhmncrij2072013747.jpg)

。

### 后向传播算法步骤
- 
随机初始化参数，对输入利用前向传播计算输出。

- 
对每个输出节点按照下式计算delta：![神经网络71.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exsthnw9ugj2074015747.jpg)

- 
对每个隐藏节点按照下式计算delta：![神经网络72.png](http://ww1.sinaimg.cn/large/6cbb8645gw1exstiabhljj207501nmx5.jpg)

- 
计算梯度![神经网络73.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exstiwvh5rj204x01st8n.jpg)，并更新权值参数和偏置参数：![神经网络74.png](http://ww4.sinaimg.cn/large/6cbb8645gw1exstjsxzobj204k01tjrb.jpg)。这里的![神经网络75.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exstkm7wu0j200d00j0ng.jpg)是学习率，影响训练速度。



### 后向传播算法实现

```python

```
- def backPropagate(self, targets, N, M):
- """
-         后向传播算法
-         :param targets: 实例的类别 
-         :param N: 本次学习率
-         :param M: 上次学习率
-         :return: 最终的误差平方和的一半
-         """
- # http://www.youtube.com/watch?v=aVId8KMsdUU&feature=BFa&list=LLldMCkmXl4j9_v0HeKdNcRA
- 
- # 计算输出层 deltas
- # dE/dw[j][k] = (t[k] - ao[k]) * s'( SUM( w[j][k]*ah[j] ) ) * ah[j]
-         output_deltas =[0.0]*self.no
- for k in range(self.no):
-             error = targets[k]-self.ao[k]
-             output_deltas[k]= error * dsigmoid(self.ao[k])
- 
- # 更新输出层权值
- for j in range(self.nh):
- for k in range(self.no):
- # output_deltas[k] * self.ah[j] 才是 dError/dweight[j][k]
-                 change = output_deltas[k]*self.ah[j]
- self.wo[j][k]+= N * change + M *self.co[j][k]
- self.co[j][k]= change
- 
- # 计算隐藏层 deltas
-         hidden_deltas =[0.0]*self.nh
- for j in range(self.nh):
-             error =0.0
- for k in range(self.no):
-                 error += output_deltas[k]*self.wo[j][k]
-             hidden_deltas[j]= error * dsigmoid(self.ah[j])
- 
- # 更新输入层权值
- for i in range(self.ni):
- for j in range(self.nh):
-                 change = hidden_deltas[j]*self.ai[i]
- # print 'activation',self.ai[i],'synapse',i,j,'change',change
- self.wi[i][j]+= N * change + M *self.ci[i][j]
- self.ci[i][j]= change
- 
- # 计算误差平方和
- # 1/2 是为了好看，**2 是平方
-         error =0.0
- for k in range(len(targets)):
-             error =0.5*(targets[k]-self.ao[k])**2
- return error

注意不同于上文的单一学习率![神经网络75.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exstkm7wu0j200d00j0ng.jpg)，这里有两个学习率N和M。N相当于上文的![神经网络75.png](http://ww3.sinaimg.cn/large/6cbb8645gw1exstkm7wu0j200d00j0ng.jpg)，而M则是在用上次训练的梯度更新权值时的学习率。这种同时考虑最近两次迭代得到的梯度的方法，可以看做是对单一学习率的改进。

另外，这里并没有出现任何更新偏置的操作，为什么？

因为这里的偏置是单独作为一个偏置节点放到输入层里的，它的值（输出，没有输入）固定为1，它的权值已经自动包含在上述权值调整中了。

如果将偏置作为分别绑定到所有神经元的许多值，那么则需要进行偏置调整，而不需要权值调整（此时没有偏置节点）。

哪个方便，当然是前者了，这也导致了大部分神经网络实现都采用前一种做法。

## 完整的实现

已开源到了Github上：[https://github.com/hankcs/neural_net](https://github.com/hankcs/neural_net)

这一模块的原作者是Neil Schemenauer，我做了些注释。

直接运行bpnn.py即可得到输出：
- Combined error 0.171204877501
- Combined error 0.190866985872
- Combined error 0.126126875154
- Combined error 0.0658488960415
- Combined error 0.0353249077599
- Combined error 0.0214428399072
- Combined error 0.0144886807614
- Combined error 0.0105787745309
- Combined error 0.00816264126944
- Combined error 0.00655731212209
- Combined error 0.00542964723539
- Combined error 0.00460235328667
- Combined error 0.00397407912435
- Combined error 0.00348339081276
- Combined error 0.00309120476889
- Combined error 0.00277163178862
- Combined error 0.00250692771135
- Combined error 0.00228457151714
- Combined error 0.00209550313514
- Combined error 0.00193302192499
- Inputs:[0,0]-->[0.9982333356008245]Target[1]
- Inputs:[0,1]-->[0.9647325217906978]Target[1]
- Inputs:[1,0]-->[0.9627966274767186]Target[1]
- Inputs:[1,1]-->[0.05966109502803293]Target[0]

IBM利用Neil Schemenauer的这一模块（旧版）做了一个识别代码语言的例子，我将其更新到新版，已经整合到了项目中。

要运行测试的话，执行命令
- code_recognizer.py testdata.200

即可得到输出：
- ERROR_CUTOFF =0.01
- INPUTS =20
- ITERATIONS =1000
- MOMENTUM =0.1
- TESTSIZE =500
- OUTPUTS =3
- TRAINSIZE =500
- LEARNRATE =0.5
- HIDDEN =8
- Targets:[1,0,0]--Errors:(0.000 OK)(0.001 OK)(0.000 OK)-- SUCCESS!

值得一提的是，这里的HIDDEN = 8指的是隐藏层的节点个数，不是层数，层数多了就变成DeepLearning了。

## Reference

[http://arctrix.com/nas/python/bpnn.py](http://arctrix.com/nas/python/bpnn.py)

[http://code.activestate.com/recipes/578148-simple-back-propagation-neural-network-in-python-s/](http://code.activestate.com/recipes/578148-simple-back-propagation-neural-network-in-python-s/)

[https://www.youtube.com/watch?v=aVId8KMsdUU&feature=BFa&list=LLldMCkmXl4j9_v0HeKdNcRA](https://www.youtube.com/watch?v=aVId8KMsdUU&feature=BFa&list=LLldMCkmXl4j9_v0HeKdNcRA)

![](http://www.hankcs.com/wp-content/plugins/wp-ueditor/ueditor/dialogs/attachment/fileTypeImages/icon_pdf.gif)[The
 back-propagation algorithm.pdf](http://www.hankcs.com/wp-content/plugins/wp-ueditor/ueditor/php/pcs/f.php?p=uploads/2015/11/The%20back-propagation%20algorithm.pdf)

[http://ufldl.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C](http://ufldl.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C)




