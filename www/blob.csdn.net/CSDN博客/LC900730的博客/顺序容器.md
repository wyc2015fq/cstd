# 顺序容器 - LC900730的博客 - CSDN博客
2017年06月05日 17:38:03[lc900730](https://me.csdn.net/LC900730)阅读数：167标签：[迭代器](https://so.csdn.net/so/search/s.do?q=迭代器&t=blog)
个人分类：[c语言](https://blog.csdn.net/LC900730/article/category/6901419)
vector：可变大小数组； 
deque：双端队列 
list:双向链表 
forward_list:单向链表 
array:固定大小数组 
string:与vector相似的容器，但专门用于保存字符。 
除了固定大小的array外，其他容器都提供高效、灵活的内存管理。
## 迭代器
与容器类似，迭代器有着公共的接口； 
迭代器范围概念是标准库的基础； 
一个迭代器范围由一对迭代器表示，两个迭代器分表指向同一个容器中的元素或者是尾部之后的位置。这两个迭代器通常被称为begin和end(end指向的是尾部元素之后的位置)
当auto与begin或end结合使用时候，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但是以c开头的版本还是可以获得const_iterator的，而不管容器类型是什么。当不需要写访问时候，应该使用cbegin和cend
## 容器定义和初始化
每个容器类型都定义了一个默认构造函数。除了array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。
|C c|默认构造函数，如果C是一个array，则c中元素按照默认方式初始化；否则c为空|
|----|----|
|C c1(c2)|c1初始化为c2的拷贝，c1、c2必须是相同的容器类型，且保存的是相同的元素类型；对于array还必须相同大小|
|C c{a,b,c…}|c初始化成初始化列表中元素的拷贝|
|C c={a,b,c}|与上述类似|
|C c{b,e}|c初始化为迭代器b和e指定范围的元素的拷贝。范围中元素的类型必须与c元素类型相容|
只有顺序容器的构造函数才能接受大小参数
- C seq(n):seq包含n个元素，这些元素进行了值初始化。此构造函数是explict的
- C seq(n,t):seq包含n个初始值为t的元素
#### 拷贝元素初始化
由于2个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。 
deque authList(authors.begin(),it); //拷贝autors中开始元素，一直到it
在一个vector或string的尾部之外的任何位置，或是一个deque的首尾之外的任何位置添加元素都需要移动元素，而且向一个vector或string添加元素可能引起整个对象存储空间的重新分配。
## 容器适配器
标准库定义了3个顺序容器适配器：stack queue priority_queue。适配器是标准库中的一个通用概念，容器、迭代器和函数都有适配器，本质上一个适配器是一种机制，能使得某种事物行为看起来像另外一种事物一样。 
如stack适配器接受一个顺序容器(array或者forward_list外)，并且使得其操作起来像一个stack一样。
- stack
- 
- queue
- priority_queue
## 定义适配器
每个适配器都定义2个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器，如假设deq是一个deque，可以用deq来初始化新的stack 
stack stk(deq);//从deq拷贝元素到stk。 
默认情况下stack和qeue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时候将一个命名顺序容器作为第二个类型参数，来重载默认容器类型。 
//在vector上实现的空栈 
stack
