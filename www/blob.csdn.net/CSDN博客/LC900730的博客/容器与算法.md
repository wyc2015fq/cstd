# 容器与算法 - LC900730的博客 - CSDN博客
2017年06月18日 16:48:59[lc900730](https://me.csdn.net/LC900730)阅读数：218
operator ():重载小括号
## 模板偏特化
模板中const：对类型进行严格检测 
const T*指向一个常量的指针 
1.类模板显示特化 
2.默认模板参数 
3.成员模板 
4.模板类的成员函数可以是一个模板 
已结有了vector添加成员，就需要成员函数
关键字typename：作为类型前的标识符 
template  
class MyClass 
    typename T::SubType * ptr; 
    指出subType是T中定义的一个类型，因此ptr是一个指向T::SubType的指针，如果不加tynename那么表达式被认为是T中的静态成员SubType和ptr的乘积 
除了typename修饰以为，template内的任何标识符都可以被视为一个值，而非一个类型。 
typename的第二个作用：在模板中替换关键字class 
template class Test 
容器： 
序列式容器 
vector deque list 
关联式容器： 
set multiset map multimap 
vector 
pushback分配内存 
relloc：拷贝到新的内存，释放原来的内存
Vectors：将元素置于一个动态数组加以管理； 
可以随机存取元素； 
数组尾部添加或者移除元素非常快速，但是在中部或头部安插元素比较费时。 
Deques:
不需要变长，容量较小可用到array； 
需要变长，容量较大用到vector；
```cpp
#include<iostream>
#include<list>
#include<stdio.h>
using namespace std;
int main() {
    list<int> mylist;
    mylist.push_back(1);
    mylist.push_back(2);
    mylist.push_back(3);
    mylist.push_back(4);
    auto ibegin = mylist.begin();    //指针，指向了一个迭代器，迭代器存储了一个位置
    auto iend = mylist.end();
    for (; ibegin != iend; ibegin++) {
        cout << *ibegin << endl;
        printf("%p\n", ibegin);
    }
    cin.get();
    return 0;
}
```
list中的删除erase() 
mylist.erase(mylist.begin);
```cpp
#include<iostream>
#include<list>
#include<stdio.h>
using namespace std;
int main() {
    list<int> mylist;
    mylist.push_back(1);
    mylist.push_back(2);
    mylist.push_back(3);
    mylist.push_back(4);
    auto ibegin = mylist.begin();    //指针，指向了一个迭代器，迭代器存储了一个位置
    auto iend = mylist.end();
    for (; ibegin != iend; ibegin++) {
    if((*ibegin)==3){
        mylist.erase(ibegin);
                break;         //删除后，迭代器的begin和end发生了变化，不break的话会发生中断异常
    }
    auto ibegin = mylist.begin();    //指针，指向了一个迭代器，迭代器存储了一个位置
    auto iend = mylist.end();
    for(;ibegin!=iend;ibegin++){
        cout << *ibegin << endl;
        printf("%p\n", ibegin);
    }
    }
    cin.get();
    return 0;
}
```
链式存储，不允许下标访问，只允许迭代器，链表迭代器只能使用++ – 
如mylist[1]就是错误的，只能使用迭代器访问 
clear：清空链表 
push_back; 
push_front; 
mylist.insert(ibegin,30);//  位置，值 
mylist.remove();   //remove是直接根据元素的值删除，如remove(30)就是删除值为30的元素。 
删除或者插入跌代器的时候，begin和end都发生了变化，所以需要break；
mylist.rbegin(); 
mylist.rend(); 
mylist.merge(mylist2);//将链表合并   (合并之前必须要有序，mylist1.sort()   mylist2.sort(),然后在merge)，merge之后的list也是有序的。 
mylist.unique();unique也依赖于排序 
如果没排好序，那么仅会删除最后一个重复。如果sort了，那么会删除所有重复的。
## set
myset.insert(); 
myset.find();
## 迭代器
迭代器本质是个指针，但是是经过优化的；ib类内部有个指针p，每次打印ib的值都是一样的，但是ib内部的值是拒绝访问的。
printf(“%p,%p\n”,ib, ib._Ptr);     0x1234564   0000000; 
printf(“%p,%p\n”,ib._Ptr,ib);      每次的ib._Ptr值不一样，ib的值都是一样
```cpp
struct print{
    void operator()(int x){
        std::cout<<x<<std::endl;
    }
};
```
for_each(a,a+5,print());//遍历每一个元素，用结构体封装了这个方法，然后进行重载 
类模板需要实例化； 
printf()是怎么发生作用的？ 
    //等于调用print的()函数，for_each第三个参数是一个函数 
    //第三个参数是函数指针 
    //加上()，把类名当做函数名来使用 
    //类名当做函数名，重载了(),直接调用();
## multiset
multiset.insert; 
bind1st仿函数：可以实现一定的算法策略
auto ifind = find_if(mylist.begin(),mylist.end(),bind1st(greater(),3 ));  //过滤>3的数
