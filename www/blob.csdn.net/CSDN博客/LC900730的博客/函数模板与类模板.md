# 函数模板与类模板 - LC900730的博客 - CSDN博客
2017年06月16日 11:10:55[lc900730](https://me.csdn.net/LC900730)阅读数：185
个人分类：[c++](https://blog.csdn.net/LC900730/article/category/6933816)
## 函数模板
函数模板在调用会严格匹配参数类型； 
当调用函数模板(本质是类型参数化)，将严格按照类型进行匹配，不会进行自动类型转换 
普通函数可以进行隐式的类型转换；
```
void myswap(T &a,T &b){
    T c=0;
    c=a;
    a=b;
    b=c;
    std::cout<<a<<b<<std::endl;
    std::cout<<"我是模板函数，欢迎来调"<<std::endl;
}
void myswap(int a,char c){
    std::cout <<"a:"<<a<<"c:"<<c<<std::endl;
    std::cout<<"我是普通函数，欢迎来访"<<std::endl;
}
int main(){
    int a=10;
    char c='z';
    myswap(a,c);          //普通函数
    myswap(a,a);          //模板函数
    myswap(c,a);          //普通函数
    return 0;
}
```
1.函数模板可以被重载 
2.C++编译器首先选用普通函数 
3.如果函数模板可以产生一个更好的匹配，那么选择函数模板 
4.可以通过空模板实参列表的语法限定编译器只通过模板匹配
```cpp
#include<iostream>
using namespace std;
int Max(int a,int b){
    return a>b?a:b;
}
template<typename T>
T Max(T a,T b){
    cout<<"T Max(T a,T b)"<<endl;
    return a>b?a:b;
}
template<typename T>
T Max(T a,T b,T c){
    cout<<"T Max(T a,T b,T c)"<<endl;
    return Max(Max(a,b),c);
}
void main(){
    int a=1;
    int b=2;
    cout<<Max(a,b)<<endl; //普通函数与函数模板都符号调用，优先选择普通函数
    cout<<Max<>(a,b)<<endl;//如显式使用函数模板，则需要<>参数列表
    cout<<Max(3.0,4.0)<<endl;//函数模板可以产生更好的匹配，选择模板
    cout<<Max(5.0,6.0,7.0)<<endl;  //重载
    cout<<Max('a',100)<<endl;   //调用普通函数，可以隐式类型转换
    system("pause");
}
```
|选项|作用|
|----|----|
|-o|产生目标(i,s,o,可执行文件)|
|-c|通知gcc取消链接步骤，即编译源码并在最后生成目标文件|
|-E|只运行C预编译器|
|-S|告诉编译器产生汇编语言后停止编译，产生的汇编语言文件扩展名为.s|
|-Wall|使得gcc对源文件的代码有问题的地方发出警告|
|-ldir|将dir目录加入搜索头文件的目录路径|
|-Ldir|将dir目录加入搜索库的目录路径|
|-llib|链接lib库|
|-g|在目标文件嵌入调试信息，以便gdb之类的调试程序运行|
#### 函数模板两次编译
编译器从函数模板通过具体类型产生不同的函数； 
编译器会对函数模板进行两次编译， 
在声明的地方对模板代码本身进行编译； 
在调用的地方对参数替换后的代码进行编译
## 类模板
类模板用于实现类所需数据的类型参数化； 
类模板在表示数组、表、图等数据结构显得特别重要； 
这些数据结构的表示和算法不受所包含的元素类型的影响；
所有的类模板函数写在类的外部
