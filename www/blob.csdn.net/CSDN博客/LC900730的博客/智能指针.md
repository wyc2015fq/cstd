# 智能指针 - LC900730的博客 - CSDN博客
2017年09月26日 14:36:23[lc900730](https://me.csdn.net/LC900730)阅读数：124标签：[c++](https://so.csdn.net/so/search/s.do?q=c++&t=blog)
个人分类：[c++](https://blog.csdn.net/LC900730/article/category/6933816)
## shared_ptr和unique_ptr
shared_ptr允许多个指针指向同一个对象； 
unique_ptr则独占所指向的对象。
### 1.shared_ptr初始化
模板，因此创建的时候必须提供额外信息，指针可以指向的类型。 
如：
```cpp
shared_ptr<string> p1;              //可以指向string 
shared_ptr<list<int>> p2;           //可以指向int的list
```
默认初始化的智能指针中保存着一个空指针。 
与普通指针类似：解引用得到指向的对象
- 接受指针参数的智能指针构造函数是explicit的，因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化。
不能将一个指针赋予shared_ptr
```cpp
//new int 返回的是int *,不能进行内置类型到智能指针的隐式转换
shared_ptr<int> p1=new  int(1024);  //error必须使用直接初始化
shared_ptr<int> p2(new  int(1024));  //ok,使用了直接初始化形式
```
- 必须将shared_ptr显式绑定到一个想要返回的指针上。
```cpp
shared_ptr<int> clone(int p){
    return shared_ptr<int>(new int(p));
}
```
#### make_shared函数
> 
shared_ptr可以协调对象的析构，但是这仅限于其自身的拷贝(也是shared_ptr)之间，这也是推荐使用make_shared而不是new的原因。这样我们能够在分配对象同时将shared_ptr与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的shared_ptr上。 
  用参数来构造给定类型的对象。
```cpp
//指向一个值为42的int的shared_ptr
shared_ptr<int> p3=make_shared<int> (42); 
//指向一个值为"9999999999"的string
shared_ptr<string> p4=make_shared<string>(10,'9');
//指向一个值初始化的int，即为0
shared_ptr<int> p5=make_shared<int>();
```
#### 使用auto定义一个对象保存make_shared结果
```cpp
auto p6=make_shared<vector<string>>();
```
### shared_ptr的拷贝和赋值
当进行拷贝或者赋值时候，每个shared_ptr都会记录有多少个其他的shared_ptr指向相同的对象。
### shared_ptr和new结合使用
接受指针参数的智能指针构造函数是explicit的。因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化。
```cpp
//隐式要求new返回的int *来创建一个shared_ptr
//由于不能进行内置指针到智能指针间的隐士转换，因此错误。
shared_ptr<int> p1=new int(1024);       //错误，必须使用直接初始化形式
shared_ptr<int> p2( new int(1024)) ;    //正确：使用了直接初始化
//同理：返回shared_ptr的函数不能在返回语句中隐式转换一个普通指针：
shared_ptr<int> clone(int p){
    return new int(p);      //错误：隐式转换为shared_ptr<int>
}
我们必须将shared_ptr显式绑定到一个想要返回的指针上
shared_ptr<int> clone（int p）{
    //显式使用int *创建
    return shared_ptr<int> (new int(p))
}
```
