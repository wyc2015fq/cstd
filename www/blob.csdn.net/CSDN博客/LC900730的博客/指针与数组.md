# 指针与数组 - LC900730的博客 - CSDN博客
2017年05月04日 22:18:39[lc900730](https://me.csdn.net/LC900730)阅读数：211标签：[指针																[c语言](https://so.csdn.net/so/search/s.do?q=c语言&t=blog)](https://so.csdn.net/so/search/s.do?q=指针&t=blog)
个人分类：[c语言](https://blog.csdn.net/LC900730/article/category/6901419)
## 数组指针与函数指针
### typedef
typedef char (*PTR_TO_ARR)[30]; 
表示PTR_TO_ARR是类型int *[4]的别名，它是一个二维数组指针类型；接着可以使用PTR_TO_ARR定义二维数组指针； 
PTR_TO_ARR p1,p2; 
按照类似写法，可以为函数指针定义别名； 
typedef int (*PTR_TO_FUNC)（int,int）;
typedef char(*PTR_TO_ARR)[30]; 
typedef int(*PTR_TO_FUNC)(int, int);
```
#include <stdlib.h>
    #include<stdio.h>
    int max(int a, int b) {
            return a > b ? a : b;
    }
    char str[3][30] = {
    "http://baidu.com",
    "http://google.com",
    "http://yu.com"
    };
    int main() {
    PTR_TO_ARR parr = str;
    PTR_TO_FUNC pfunc = max;
    int i;
    printf("max:%d\n", (*pfunc)(10, 20));
    for (i = 0; i < 3; i++) {
        printf("str[%d]:%s\n", i, *(parr + i));
    }
    getchar();
    return 0;
    }
```
### 一级指针
函数的副本机制，使得函数内部无法改变外部变量(数组是一个例外，拒绝副本机制，结构体是副本)，因此数组名字当做参数时候是地址 
同时数组作为参数，改变数组等于直接操作外部数组
```cpp
void test(int a[10]){
    printf("test=%d\n", sizeof(a)); //8(数组名，是个指针)
    int b[10]={1,2,3,4,5,6,7,8,9,0};
    printf("\n test b=%d", sizeof(b));   //40
}
void main(){
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    printf("main a=%d", sizeof(a));   //40
    printf("\n%d\n", sizeof(a)/ sizeof(int));  //10
    test(a);
}
```
作用：
```
1.函数内部改变外部变量(间接修改一个数据)；
        2.跨进程改变变量(外挂)；
        3.数组作为参数（数组会退化为一个指针），一级指针可以作为函数的形式参数，接受数组首地址；
        4.一级指针可以存储一个数组首地址；
        5.函数的返回值无法取地址；
        6.作为函数返回值，返回地址，但是不能返回指向栈的地址；
```
函数执行完成后内存被回收，但是还没有使用，是原来的值 
    数组名编译器作了特殊处理，因此
```
int *p=a；
sizeof(p);//8
sizeof(a);//40
p[i]=a[i]=*(p+i);
&p[i]=p+i;
```
```
int go(){
    int a=3;
    return a;
}
int *go(){
    int a=3;
    return &a;
}
//return也有副本机制，存储在寄存器里面
int main(){
    printf("%d,%p",go(),&go());//错误，没有办法&go()
    int *p=go1();
    //*p此时还是3（其实此时内存已经被回收，但是由于中间没有插入其他代码，所以此时内存中的值还是3；如果加入了printf("\n\n\n"),那么*p就不是3了）
    //但是go1()加入static int a=3；此时a就不能栈区了，*p还是3
    printf("%d,%p\n",*p , p); 
}
```
```
void main(){
        //p存储的是这个字符串首地址
    char *p="tasklist & pause"; //指针存储地址
    system(p);//先打印出进程，然后出现暂停窗口
    *p='a'；  //编译没有问题，但是执行的时候内存冲突；
    //常量字符串不可以修改
}
```
