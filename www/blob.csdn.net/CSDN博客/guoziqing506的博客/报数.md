# 报数 - guoziqing506的博客 - CSDN博客





2016年05月26日 17:38:44[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1341标签：[字符串](https://so.csdn.net/so/search/s.do?q=字符串&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：报数指的是，按照其中的整数的顺序进行报数，然后得到下一个数。如下所示：

1, 11, 21, 1211, 111221, ...

1 读作 "one 1" -> 11.

11 读作 "two 1s" -> 21.

21 读作 "one 2, then one 1" -> 1211.

给定一个整数 n, 返回 第 n 个顺序。

样例：给定 n = 5, 返回 "111221".

先来观察一下，要我们干嘛。给出了第一个数1（当然是字符串形式的），我们将它读出来，因为只有一个1，所以，叫做“one 1”，由此，得到第二个数11（字符串形式）。。。以此类推。

其实，这个形式从逻辑上讲，似乎和“斐波那契数列”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51057987)）有点相似，都是依赖于之前的结果，得到之后的结果，所以，和“斐波那契数列”的做法一样，我们可以用递归，也可以用迭代，考虑到效率因素，我们是用迭代的方法。

其实，就是这样一种形式，对前一个结果进行分析，把相邻的，且相同的数计数（记为count），然后把这个count的字符串形式和它所对应的值的字符串形式连接起来，然后再分析之后的字符。那样例中的“1211”来说，前面的1,2都是单独的，所以是“11”（表示1个1），“12”（表示1个2），最后两个1相邻，所以是“21”（2个1），整个连起来，就是“111221”，也就是第五个结果。

所以，可以先设计一个函数next_seq()，根据前一个序列，求得下一个序列，然后我们通过主函数迭代的调用这个next_seq()即可。

代码如下：



```python
class Solution:
    # @param {int} n the nth
    # @return {string} the nth sequence
    def countAndSay(self, n):
        if n == 1:
            return '1'
        i = 1
        result = '1'
        while i != n:
            result = self.next_seq(result)
            i += 1
        return result

    def next_seq(self, s):
        value, count = int(s[0]), 0
        n = len(s)
        cur = 0
        result = ''
        while cur != n:
            if int(s[cur]) == value:
                count += 1
            else:
                result += (str(count) + str(value))
                value = int(s[cur])
                count = 1
            cur += 1
        result += (str(count) + str(value))
        return result
        # Write your code here
```





