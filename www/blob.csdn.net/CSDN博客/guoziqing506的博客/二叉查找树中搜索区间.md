# 二叉查找树中搜索区间 - guoziqing506的博客 - CSDN博客





2016年08月13日 10:40:32[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1927
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定两个值 k1 和 k2（k1 < k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 <= x <= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。

样例：如果有 k1 = 10 和 k2 = 22, 你的程序应该返回 [12, 20, 22].

![](https://img-blog.csdn.net/20160813094832529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


递归+深搜的思路。之前，像类似于“二叉树的所有路径”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51178917)）这样的问题用的也是这种思路。应该不会陌生了。




用一个结果列表result存储节点值，因为result中需要不断添加新元素，所以，为了方便，干脆再建立一个辅助函数helper()，helper()中，result作为一个参数存在，接收符合条件的节点值。




从根节点开始向叶子搜索，分三种情况：

1. 如果当前节点值在区间内，那么先别着急加入result，而是递归对这个节点的左孩子做同样的事，也就是处理这个节点的左子树，处理完毕后，再将这个节点值加入result，之后，递归处理这个节点的右子树。这样做的目的是要保证result按升序排列

2. 如果当前节点值大于k2（给出区间的上限），那就不用考虑这个节点的右子树了，递归处理左子树，当然，这个节点是不符合条件的，不用加入result

3. 如果当前节点值小于k1（给出区间的下限），与2中类似，自己脑补吧。




于是按照上面的思路，给出代码：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    """
    @param root: The root of the binary search tree.
    @param k1 and k2: range k1 to k2.
    @return: Return all keys that k1<=key<=k2 in ascending order.
    """
    def searchRange(self, root, k1, k2):
        result = []
        self.helper(root, k1, k2, result)
        return result

    def helper(self, root, k1, k2, result):
        if root is None:
            return

        elif root.val >= k1 and root.val <= k2:
            self.helper(root.left, k1, k2, result)
            result.append(root.val)
            self.helper(root.right, k1, k2, result)

        elif root.val > k2:
            self.helper(root.left, k1, k2, result)

        else:
            self.helper(root.right, k1, k2, result)
        # write your code here
```





