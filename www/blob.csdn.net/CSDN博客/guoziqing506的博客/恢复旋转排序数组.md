# 恢复旋转排序数组 - guoziqing506的博客 - CSDN博客





2016年05月13日 15:28:48[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1188
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个旋转排序数组，在原地恢复其排序。

样例：[4, 5, 1, 2, 3] -> [1, 2, 3, 4, 5]

数组这一部分，很多题目是非常简单的，更多是考察对语言编写的能力，所以，我会在接下来好几节里，简洁快速地将这些题目过一遍，而不对算法细节做过多讲解（因为简单）。

先看这道题目，旋转排序数组的问题，之前已经讲过（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51058549)）那个时候，是要寻找旋转排序数组的最小值，我们用的是二分法。

再看这道题目，要恢复，那很容易了，还是寻找到最小值，从最小值开始依次删除元素，插入数组前端。

比如样例：

1. [4, 5, 1, 2, 3] -> [1,
4, 5, 2, 3]

2. [1, 4, 5, 2, 3] -> [1, 2, 4,
 5, 3]

2. [1, 2, 4,
 5, 3] -> [1, 2, 3, 4, 5]


由于，题目的要求时间复杂度O(n)，所以，没必要二分法查找那么麻烦了。写出代码：



```python
class Solution:
    """
    @param nums: The rotated sorted array
    @return: nothing
    """
    def recoverRotatedSortedArray(self, nums):
        n = len(nums)
        i, left = 0, 0
        while i < n - 1 and nums[i] <= nums[i + 1]:
            i += 1
        i += 1
        while i < n:
            temp = nums.pop(i)
            nums.insert(left, temp)
            left += 1
            i += 1
        return nums
        # write your code here
```
第一个while循环是寻找最小值，第二个while循环是从最小值起，依次删，插。




