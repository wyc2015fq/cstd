# 数组剔除元素后的乘积 - guoziqing506的博客 - CSDN博客





2016年06月05日 21:16:57[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：913
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个整数数组A。定义B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]， 计算B的时候请不要使用除法。

样例：给出A=[1, 2, 3]，返回 B为[6, 3, 2]




最直观的方法就是写两层循环，第一层遍历n个位置（n是数组长度），第二层遍历除了这个位置的元素之外的所有元素，计算乘积。这样做的时间复杂度为O(n^2);

这样当然是能实现的。不过如果就是这样，我在这里也就没必要专门讲解这个问题了。这道题还有一种时间复杂度为O(n)的算法，那就是通过牺牲空间复杂度换取时间上的高效。

求的是数组除了i位之外所有元素的乘积，那么可以将数组看成两个部分：一部分是在i之前的，一部分是在i之后的。这两个部分各自的乘积再乘起来就是最终的答案。

所以，可以开辟两个数组的空间，一部分存每个i位左边的所有元素的乘积，一个存i位右边的。这样的两个数组通过遍历原数组两边就可以得到。最后再将这两个数组对应位乘起来，得到最终的结果。

代码如下：



```python
class Solution:
    """
    @param A: Given an integers array A
    @return: An integer array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
    """
    def productExcludeItself(self, A):
        left, right = [1], [1]
        result = []
        for i in A[:-1]:
            left.append(left[-1] * i)
        for i in A[-1:0:-1]:
            right.append(right[-1] * i)
        index = 0
        n = len(A)
        while index < n:
            result.append(left[index] * right[n - 1 - index])
            index += 1
        return result
        # write your code here
```







