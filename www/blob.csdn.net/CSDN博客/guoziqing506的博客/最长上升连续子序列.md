# 最长上升连续子序列 - guoziqing506的博客 - CSDN博客





2016年06月14日 16:53:39[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1612
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）

样例：给定 [5, 4, 2, 1, 3], 其最长上升连续子序列（LICS）为 [5, 4, 2, 1], 返回 4. 给定 [5, 1, 2, 3, 4], 其最长上升连续子序列（LICS）为 [1, 2, 3, 4], 返回 4.




其实是很简单的数组处理，不过，既然最近几篇都用了动态规划，那此处我们就来看看用动态规划怎么解决。

我们尝试用一个数组record记录最长连续子序列的情况，record[i]表示以元素A[i]为结尾元素的最长连续子序列的长度。因为根据题目的定义，所谓“最长上升连续子序列”可以分为递增和递减两种情况，所以我们也就设置两个数组分别存储递增的上升连续子序列，以及递减的上升连续子序列，记为record_inc和record_dec.

然后，观察一下状态转移方程，如果A[i] > A[i - 1]，则record_inc[i] = record_inc[i - 1] + 1, record_dec[i] = 1（因为数组处于递增的过程中，所以，以当前元素为结尾的，递减的，最长上升连续序列的长度当然是1）；同理，如果A[i] < A[i - 1]，那么record_dec[i]
 = record_dec[i - 1] + 1, record_inc[i] = 1.

那就不难得到代码了：



```python
class Solution:
    # @param {int[]} A an array of Integer
    # @return {int}  an integer
    def longestIncreasingContinuousSubsequence(self, A):
        if len(A) == 0:
            return 0

        # record_inc[i]用来记录以元素A[i]为结尾元素的递增连续上升子序列的长度
        # record_dec[i]用来记录以元素A[i]为结尾元素的递减连续下降子序列的长度
        record_inc, record_dec = [1], [1]
        cur, n = 1, len(A)
        
        while cur < n:
            if A[cur] > A[cur - 1]:
                record_inc.append(record_inc[-1] + 1)
                record_dec.append(1)
            else:
                record_dec.append(record_dec[-1] + 1)
                record_inc.append(1)
            cur += 1
        t1 = max(record_inc)
        t2 = max(record_dec)
        return max(t1, t2)
        # Write your code here
```







