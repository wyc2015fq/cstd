# 尾部的零 - guoziqing506的博客 - CSDN博客





2016年06月09日 11:09:50[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：726
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：设计一个算法，计算出n阶乘中尾部零的个数

样例：11! = 39916800，因此应该返回 2




如果直接计算阶乘的结果，再计算结果中尾部0的个数，那显然效率太低了，也当然不是这道题想表达的意思。

我们再来看题目，求的是尾部0的个数，那其实就是计算1 * 2 *......*n这个数中，能分解出多少2和5构成的数对。而我们根据常识又知道，2的数目一定是大于5的数目的，所以，关键就是看这些数中能分解出多少个5

拿11!举例吧，11! = 1 * 2*......*11，其中，乘数5,10中各能分解出一个5，一共就是2个5，所以最后阶乘的结果有2个0，而如果是26!，那么，5, 10, 15, 20中各能分解出一个5，而25中，能分解出2个5，最后结果一共6个0。

那现在问题就是判断这些乘数中，能分解出几个5.

我们发现一个规律，就是如果计算n!中因子5的个数，就是对整数n循环做“地板除5”（取小于真实商的最大整数），直到结果小于或等于1退出，将每次的结果加和即可。比如26!，26 // 5 = 5, 5 // 5 = 1，5 + 1 = 6.这是个数学规律。

代码如下：



```python
class Solution:
    # @param n a integer
    # @return ans a integer
    def trailingZeros(self, n):
        count = 0
        while n > 1:
            n = n // 5
            count += n
        return count
```







