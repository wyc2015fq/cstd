# 二叉树的所有路径 - guoziqing506的博客 - CSDN博客





2016年04月18日 13:29:32[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：3963
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给一棵二叉树，找出从根节点到叶子节点的所有路径。

样例：

![](https://img-blog.csdn.net/20160418133043160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





递归 + 深搜的思路。还记得之前学过的用递归的方法解决二叉树的前序遍历的问题吗？[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51058024)，用的就是深搜的策略，递归实现。我们在这里，依然用这种逻辑


基本解法可以这样描述：从根节点出发找叶子，找到叶子之后，所有这条“找寻之路”上的所有节点构成了我们要打印出来的一条路径。所以，我们需要建立一个全局变量path，存储未到达当前节点时扫描过的路径中有哪些节点，作为从当前节点起，往叶子遍历所经过的路径的前缀。同理，最后的结果列表也是一个全局变量了。


所以，当LintCode中给出的函数形参只有一个root时，我们就需要再设定一个辅助函数，包含刚才说的path和result，让他们两个成为全局变量。



总结一下思路：


1. 建立一个字符串变量path和结果列表result，初始化为空


2. 从根节点开始访问，之后访问其左子树，再访问其右子树


3. 每访问一个节点，将节点的值加入path，例如，访问完根节点后，path = "1 ->"，并将这里的path作为新的变量加入左右子树的遍历函数


4. 递归“触底”的条件：访问的节点为空





讲的不是很清楚，对照代码看一下吧


```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    # @param {TreeNode} root the root of the binary tree
    # @return {List[str]} all root-to-leaf paths
    def binaryTreePaths(self, root):
        # 建立两个全局变量
        path = ""
        result = []
        # 另建一个helper函数，方便对全局变量path,result的使用
        self.helper(root, path, result)
        return result
        
    # void型函数，给结果列表result中添加由path为前缀的所有路径
    def helper(self, root, path, result):
        
        if root is None:
            return
        path = path + str(root.val)
        
        # 递归对左孩子求路径
        if root.left:
            self.helper(root.left, path + "->", result)
        # 递归对右孩子求路径
        if root.right:
            self.helper(root.right, path + "->", result)
        # 如果是叶子，加入result
        if root.left is None and root.right is None:
            result.append(path)
        # Write your code here
```
需要注意的是第33行，当当前访问的节点为叶子的时候，才将path加入结果列表。


这里是典型的递归，helper函数求的就是以参量root为根节点，path为路径前缀（也就是到达这个节点之前经过的路径）的子树的所有路径，我们只需要考虑递归“触底”的条件（root为空）和递归“升级”的条件（先用path加，再加左子树所有路径，再加右子树所有路径，如果左右子树都为空，也就是叶子了，就直接加入结果列表）









