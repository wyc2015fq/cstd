# 字符串查找 - guoziqing506的博客 - CSDN博客





2016年08月12日 18:39:29[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1147
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。

样例：如果 source = "source" 和 target = "target"，返回 -1。如果 source = "abcdabcdefg" 和 target = "bcd"，返回 1。




字符串查找的算法有不止一种，一般情况下，面试官会只让你写出最简单的朴素算法，而不要求写出效率更高的KMP算法。所以我解决这道题用的也将是朴素算法，至于KMP算法，详情可以参照我的另一篇博文：[](http://blog.csdn.net/guoziqing506/article/details/52155233)[简单理解KMP算法](http://blog.csdn.net/guoziqing506/article/details/52155233)




朴素算法的思路很简单了，就是将模式逐字符与母串（文本）匹配，匹配成功，则返回这个位置；匹配不成功，则将模式向右移动一位，继续逐字符与母串相应的字符匹配。




思路太简单，不用多说了，所以这道题的难度主要在于实现。代码是这样的：



```python
class Solution:
    def strStr(self, source, target):
        if source is None or target is None:
            return -1
        cur, index = 0, 0
        s_len = len(source)
        t_len = len(target)

        # cur为当前target与source尝试匹配时，source的起始位置
        while cur <= s_len - t_len:

            # 记录一个临时值
            temp = cur

            # 扫描target
            while index != t_len:
                # 匹配失败
                if target[index] != source[cur]:
                    break
                # 当前字符匹配成功
                else:
                    index += 1
                    cur += 1

            # index == t_len证明整个模式匹配成功
            if index == t_len:
                return cur - t_len

            # 若target没有匹配成功，向右移动一位，接着来
            cur = temp + 1

            # 负责扫描target的指针归零
            index = 0
        return -1
```


其实就是有些繁复，不过只要按照思路来写，倒是没什么难理解的。





