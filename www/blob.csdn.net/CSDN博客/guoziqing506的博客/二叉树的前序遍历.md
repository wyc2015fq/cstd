# 二叉树的前序遍历 - guoziqing506的博客 - CSDN博客





2016年04月14日 20:17:11[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1009
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出一棵二叉树，返回其节点值的前序遍历。要求不能用递归。

什么是前序遍历应该已经很清楚了，样例我就省略了。




关于二叉树的前序遍历，我之前已经详细讲过，当时是用的最简单的递归解决这个问题的，详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51058024)，但是递归是有它的天然缺陷的，那就是效率低。所以，有人试图用一种更高效的办法替代递归。就这个问题来说，由于二叉树的前序遍历用的是“深搜”的策略（中序遍历，后序遍历也都是“深搜”），而“深搜”其实一般情况下可以用栈来实现。

回忆一下，前序遍历就是一个“根-左-右”的过程

![](https://img-blog.csdn.net/20160414203138529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


拿上面这幅图来说，前序遍历的结果应该是：ABDECFG，对于到达的每一个节点都按照先扫描这个节点本身，再扫描左孩子，最后右孩子的过程。所以，我不妨建立这样一个栈--stack

1. stack存储当前节点，一开始，当然是根节点A，stack = [A]

2. 删除stack的栈顶元素，将栈顶元素所存储的值加入到最后我们要的结果列表里面

3. 如果被删除的元素有右孩子，将右孩子加入stack，stack = [C]

4. 如果被删除的元素有左孩子，将左孩子加入stack，stack = [C,B]

可以看出，由于右孩子先加入，所以再把这个新的栈从第一步开始迭代时，就会先处理左孩子（图中的B），以此类推，处理左孩子时，又会先删除该节点（B），再加入该节点（B）的右孩子：stack = [C,E]，最后加入左孩子：stack = [C,E,D]...

很明显，我在这里通过栈的特殊结构实现了深搜的策略

看代码吧：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param root: The root of binary tree.
    @return: Preorder in ArrayList which contains node values.
    """
    def preorderTraversal(self, root):
        result = []
        stack = []
        # 也可写成 if root:
        if root != None:
            stack.append(root)
        while len(stack) != 0:
            cur = stack.pop()
            result.append(cur.val)
            if cur.right != None:
                stack.append(cur.right)
            if cur.left != None:
                stack.append(cur.left)
        return result
        # write your code here
```







需要注意的是第19行的简洁写法可以是if root:，24,26行也都该这样写，但是我现在这样，更容易让大家理解。









