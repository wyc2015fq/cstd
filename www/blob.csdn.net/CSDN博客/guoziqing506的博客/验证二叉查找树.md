# 验证二叉查找树 - guoziqing506的博客 - CSDN博客





2016年06月03日 16:56:14[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1643
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个二叉树，判断它是否是合法的二叉查找树(BST)

一棵BST定义为：

1. 节点的左子树中的值要严格小于该节点的值。

2. 节点的右子树中的值要严格大于该节点的值。

3. 左右子树也必须是二叉查找树。

4. 一个节点的树也是二叉查找树。




之前，有一道验证平衡二叉树的问题（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51057873)），现在回过头看，那道题真的很值得好好学习借鉴，他既是典型的递归算法的应用，同时，也向我们展示了“树”的验证问题比较普遍的解法，而且很简单，总共就5行代码。

那么现在又遇到了一个树的验证问题，验证二叉查找树。基本逻辑与之前“平衡二叉树”是一致的，还是用递归，我们需要做的就是将题目中给出的四个条件放在递归的函数里面。

这里有一点需要注意，那就是1,2两个条件，为了满足，我们还需要两个函数分别取出二叉查找树的最大，最小值，方便同根节点的比较。

代码如下：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    """
    @param root: The root of binary tree.
    @return: True if the binary tree is BST, or false
    """  
    def isValidBST(self, root):

        if root is None:
            return True
        if root.left is None and root.right is None:
            return True

        if root.left:
            if not self.isValidBST(root.left):
                return False
            elif self.max_val(root.left) >= root.val:
                return False
            
        if root.right:
            if not self.isValidBST(root.right):
                return False
            elif self.min_val(root.right) <= root.val:
                return False

        return True

    def min_val(self, root):
        result = root.val
        while root.left:
             result = root.left.val
             root = root.left
        return result

    def max_val(self, root):
        result = root.val
        while root.right:
             result = root.right.val
             root = root.right
        return result
        # write your code here
```
后面两个函数是求取以root为根节点的二叉查找树的最大，最小值的。所以，调用的条件当然是先判断这棵树是二叉查找树。



不过个人感觉这样写还是效率不够高，不知道诸位有没有更高效的做法？





