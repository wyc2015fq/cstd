# 复制带随机指针的链表 - guoziqing506的博客 - CSDN博客





2016年05月11日 18:52:09[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：2804
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。返回一个深拷贝的链表。 

首先，我先解释一下题目的意思。就是完全按照给出的链表的关系复制链表，比如，原链表中值为1的节点的next指向的是值为2的节点，随机指针指向值为3的节点，那么，复制之后，还是应该满足这样的指向关系，但是，因为是复制的链表，所以，存储在内存空间中的位置当然和原先不同。

我们当然第一想法就是一个个复制节点，但是难度在于什么呢？复制前面节点的时候并不知道他要指向的节点（不论是随机还是next）在哪个地址。所以，直接简单粗暴复制是肯定不行的。

为了能够准确复制每个节点的指针，就必须要建立原链表与新链表对应节点的关系。但是因为每个节点只有一个next指针，所以，我们还需对新链表的next指针做处理，让节点之前的前后关系保持住。就如下图所示：




![](https://img-blog.csdn.net/20160511183943780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





其中，上面的一个是原链表，我们发现，只要对两个链表的next指针做出如上图所示处理，就不难复制随机指针了。

思路可以这样：

1. 遍历原链表，建立如图所示的结构

2. 根据这个结构，复制随机指针

3. 处理复制链表的next指针

代码如下：



```python
# Definition for singly-linked list with a random pointer.
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None
class Solution:
    # @param head: A RandomListNode
    # @return: A RandomListNode
    def copyRandomList(self, head):
    	if head is None:
    		return head

    	# 建立关联结构
    	cur = head
    	while cur:
    		temp = cur
    		cur = cur.next
    		copy_node = RandomListNode(temp.label)
    		copy_node.next = temp.next
    		temp.next = copy_node

    	# 复制随机指针
    	cur = head
    	while cur:
    		temp = cur.random
    		cur.next.random = cur.random.next if temp else None
    		cur = cur.next.next

    	# 复制next指针
    	copy_cur, copy_head = head.next, head.next
    	while copy_cur and copy_cur.next:
    		copy_cur.next = copy_cur.next.next
    		copy_cur = copy_cur.next
    	copy_cur.next = None
    	return copy_head
        # write your code here
```
这个结构的构造很有技巧，充分利用了新旧两个链表节点的next指针，一方面，令原链表next指针负责保持节点之间的对应关系，这个逻辑有点“哈希表”的味道；另一方面，由于原链表中每个节点都被孤立，所以令新链表的next指针负责保持前后关系，不至于让新生成的节点“找不着”。










