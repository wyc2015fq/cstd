# Python--元组 - guoziqing506的博客 - CSDN博客





2016年07月27日 09:19:04[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：858
个人分类：[Python](https://blog.csdn.net/guoziqing506/article/category/6296589)

所属专栏：[Python--基础](https://blog.csdn.net/column/details/guoziqing-python.html)









元组是一种和列表非常相近的容器，它由圆括号括起来的一系列元素构成，元素中间也是用 “,” 隔开，所以，从表面上看，它和列表“长的”几乎是一模一样的（从形式上看，只是括元素的括号不同罢了）。性质上讲，元组和列表也有很多相同之处，所以，我不打算用很详尽的篇幅来讲解元组，那些元组和列表相同的地方，我会省略，如果有读者不清楚，请翻看我的上一篇博文（[Python–列表](http://blog.csdn.net/guoziqing506/article/details/51966025)）我会着重说明元组与列表的不同之处，其实，也就是元组的“不可变性”。

## 创建和访问

### 1. 创建

与列表和字符串类似，元组的创建也是两种方法：需要注意的是元组是由圆括号 “()” 括起来的

```
# 直接赋值，构造元组
a = (1, [2.3, (1, 2)], "we") # >>> 元素可以是任何类型的

# 传递一个序列给tuple()函数，构造元组
b = tuple([1, 2, 3]) # >>> （1, 2, 3） 
c = tuple("asdf") # >>> ("a", "s", "d", "f")
```

### 2. 访问

通过下标和切片两种方法可以访问元组的单个元素或者元组的一部分，这一点与列表一模一样，我只是给出例子

```
a = (0, 1, 2, 3, 5)
print(a[1]) # >>> 1
print(a[0: 4: 2]) # >>> (0, 2)
```

## 不可变性

不可变性是元组同列表相比，最本质的区别。也就是说对元组的任何修改函数都是新建了一个元组对象，而并没有改变元组本身。这一点有点类似于字符串（详见： [Python–字符串](http://blog.csdn.net/guoziqing506/article/details/51945838)），但是元组可以存储任意类型的元素，比起字符串只能存储字符，确实有更多的用武之地。

### 1. 元组的拓展

元组的拓展和列表，字符串一样，可以通过 `+` 操作符实现

```
a = (1, 2)
a += (3, 4) # 新建了一个对象，新对象的元素是拓展后的
print(a) # >>> (1, 2, 3, 4)
```

### 2. 删除和替换

至于删除和替换，很遗憾，没有相关的函数可以做这件事，我们只能通过切片，实现这样的效果，这一点与字符串的切片操作是一样的，但是元组没有字符串那么丰富的内建函数

```
a = (1, 2, 3)
a = a[0:2] + (4,) # 新建了一个元组对象，将3替换成4了
print(a) # >>> (1, 2, 4)
```

这里，需要注意的一点是：单个元素构成的元组需要在元素尾加上一个 `,` 表示这是个元组，否则，Python会以为你只是写了个整数，然后给整数加了个数学意义的小括号运算符而已

此外，和字符串，列表一样，通过 `*` 操作符表示重复操作

```
a = (1, 2, 3)
b = a * 3 # 新建对象
print(b) # >>> (1, 2, 3, 1, 2, 3, 1, 2, 3)
```

### 3. 成员判断和类型转换

和字符串，列表一样，通过成员操作符 `in, not in` 实现成员的判断

```
a = (1, 2, 3)
print(1 in a) # >>> True
print(2 not in a) # >>> False
```

当然，元组也可以转变成别的形式

```php
a = (1, 2, "we")
b = str(a) # 转变成字符串
print(b) # >>> (1, 2, "we") 元组中的所有组成部分，包括圆括号都转变为字符串的一个字符
c = list(a) # 转变成列表
print(c) # >>> [1, 2, "we"]
```

这种类型的转变之前已经提过多次，实际上是新建了对象，这里不再赘述。

## 元组，也不是那么“不可变”

元组从某种程度上讲，也是“可变”的。我在这里将“可变”两个字打了引号，原因就是元组确实是不可变的，但是元组的元素本身的内容，却有可能发生变化，从而间接地改变了元组，比如当元组有一个元素是列表时：

```
a = (1, 2.3, [3, 4])
a[2][1] = 0
print(a) # >>> (1, 2.3, [3, 0])
```

元组变了吗，没变，还是之前的元组，他的第二个位置的元素还是之前的那个列表，这些都没变。变的只是元组的第2个位置的列表的第2个元素，列表的可变性导致了元组a的第二个元素的内容改变了，从而，看上去，好像是元组发生了变化。

可以想这样一个问题，元组和列表在数据的存储方面是如此接近，而元组又远不如列表操作方便，不仅没有很多的内建函数供我们使用，而且还通过不可变性处处“难为”我们，那为什么还有这么个结构存在呢？

其实，既然存在就一定是有用的。元组的不可变性有些时候就会给我们提供帮助，说的更确切一些，是提供保护。当我们自己设计的算法逻辑结构过于复杂，有可能对一个数据序列的操作会改变这个序列本身，破坏源数据，或者当我们令数据进入一个我们不了解的API时，元组的存在也会数据本身提供保护。再说了，因为各种类型转换函数的存在，可以很容易将元组转换为列表进行修改，再转换为元组，保证安全的存储。可见，元组绝对不是一个“糟糕”的东西。

## 默认集合类型

所有多对象的，逗号分隔的，没有明确符号定义的，这些集合的默认类型都是元组。

比如，我们在命令行中运行以下代码

```python
>>> x, y = 1, 2
>>> x, y
(1, 2)
```

再比如，函数返回多对象的情况，也被默认是返回了一个元组

```python
def fun1():
    return 1, 2

print(fun1()) # >>> (1, 2)

def fun2():
    return (1, 2)

print(fun2()) # >>> (1, 2)
```

上面的例子中 `fun1()` 和 `fun2()` 返回的其实是一样的东西，只不过一个是隐式的元组，一个是显式的。



