# 链表划分 - guoziqing506的博客 - CSDN博客





2016年05月01日 22:12:58[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1339
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。你应该保留两部分内链表节点原有的相对顺序。

样例：给定链表 1->4->3->2->5->2->null，并且 x=3，返回 1->2->2->4->3->5->null

我们可以发现，许多关于数组的操作也会用到链表上，因为数组和链表从本质上讲存储的都是“一列有顺序的元素”。但是由于链表的结构特性，对于链表的操作总会比对于数组要复杂一些。

这道题也是一样，想一想在划分数组的时候，是通过遍历+交换的方法实现的，而交换节点这个事一向比较费事，很考验编程技巧。

所以，仅仅就解决这道题而言，我们可以用另外一种更简单地方法：我给它起名叫做“摘除法”。什么意思呢，就是设定一个或多个新的节点，然后对给出的链表扫描，将符合相应特征的节点从给出的链表中“摘除”出来，连在新建的节点上。之前，我们做过的“链表的插入排序”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51254593)），“合并两个排序链表”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51281780)）其实用的都是这种方法。

放到这道题呢，可以建立两个节点，一个后面跟进值小于x的节点，另一个后面跟进大于x的。然后整个原始链表遍历完之后，再将现在新建的两个链表合并，划分就完成了。

代码如下：



```python
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    """
    @param head: The first node of linked list.
    @param x: an integer
    @return: a ListNode 
    """
    def partition(self, head, x):
        if head is None:
            return head
        # 新建两个节点
        first = ListNode(-1)
        second = ListNode(-1)
        cur1, cur2 = first, second
        # 遍历原始链表
        while head:
            if head.val < x:
                cur1.next = head
                head = head.next
                cur1 = cur1.next
            else:
                cur2.next = head
                head = head.next
                cur2 = cur2.next
        # 合并
        cur1.next = second.next
        cur2.next = None
        return first.next
        # write your code here
```






