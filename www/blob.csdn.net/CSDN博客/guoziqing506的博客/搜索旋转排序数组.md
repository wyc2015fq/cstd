# 搜索旋转排序数组 - guoziqing506的博客 - CSDN博客





2016年04月13日 08:32:59[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：2199标签：[二分查找](https://so.csdn.net/so/search/s.do?q=二分查找&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：假设有一个排序的按未知的旋转轴旋转的数组(比如，0 1 2 4 5 6 7 可能成为4 5 6 7 0 1 2)。给定一个目标值进行搜索，如果在数组中找到目标值返回数组中的索引位置，否则返回-1。你可以假设数组中不存在重复的元素。

样例：

给出[4, 5, 1, 2, 3]和target=1，返回 2

给出[4, 5, 1, 2, 3]和target=0，返回 -1




回忆一下，之前有一道寻找旋转排序数组中最小值的问题，[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51058549)，我们当时使用num[left]和num[mid]的大小关系来判断此时mid指向的元素是在数组的前半段还是后半段。这道题和上一道稍微有点不一样，因为在上道题中，我们可以控制left与right始终分别指向左右两段数组。而这里，显然是不适合的。因此，我们可以先判断经过二分之后的两段数组哪个是排好序的，再判断target是否在这段排好序的数组当中，是的话，就简单了，简单二分搜索即可，不在的话，继续分析上回没排好序的数组，递归的按照以上的逻辑继续查找即可。




可以分以下三种情况讨论：

1. num[mid] = target,那么找到了，不用继续找了




2. num[mid] >= num[left] 那么此时mid左端，一直到left的数组是排好序的。可以继续细分为两种情况：

    （1）num[mid] > target && target >= num[left],说明此时target在mid左侧排好序的数组内。用二分查找处理这段数组即可

    （2）如果不符合（1）中的条件，处理mid右侧的数组（还是按照先寻找排序数组，再二分查找的逻辑）








3. 2中的条件不成立，那么此时mid右端，一直到right的数组是排好序的。可以继续细分为两种情况：

    （1）num[mid] < target && target <= num[right],说明此时target在mid右侧排好序的数组内。用二分查找处理这段数组即可

    （2）如果不符合（1）中的条件，处理mid左侧的数组（还是按照先寻找排序数组，再二分查找的逻辑）




思路上稍微有点复杂，其实你只需要把握一点：就是先寻找排序数组，再分情况查找。代码如下：



```python
class Solution:
    """
    @param A : a list of integers
    @param target : an integer to be searched
    @return : an integer
    """
    def search(self, A, target):
        left, right = 0, len(A) - 1
        while left <= right:
            mid = (left + right) // 2
            if A[mid] == target:
                return mid
            # mid左端是排好序的
            if A[mid] >= A[left]:
                # 因为前面第11行的判断已经说明A[mid] != target了，所以不再考虑A[mid] = target的情况
                if A[mid] > target and A[left] <= target:
                    right = mid - 1
                else:
                    left = mid + 1
            # 下面的else等同于elif A[mid] <= A[right]
            else:
                if A[mid] < target and A[right] >= target:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
        # write your code here
```










