# 索引压缩 - guoziqing506的博客 - CSDN博客





2017年08月10日 16:59:27[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1820
所属专栏：[信息检索学习笔记](https://blog.csdn.net/column/details/16835.html)









当待搜索的数据量极为庞大时，数据所对应的索引的数据量也会非常大。就拿最常见的倒排索引来说，特别是当用户查询的关键词是常用词时，这些词所对应的倒排列表可以达到几百兆，而将这样庞大的索引由磁盘读入内存，势必会严重增加检索响应时间，影响用户的搜索体验。为了解决这样的问题，学者们提出了一系列的索引压缩技术。

实际上，我们所要处理的数据类型多如牛毛，根据不同的要求，为这些数据设计的索引更是千变万化，最常见的有倒排索引，复杂一点的还有各种树形索引等等。要想总结出一种万能的索引压缩技术，实在是很难。但是压缩方法的基本原理却是相通的。本文，我将以倒排索引为例，介绍几种简单的索引压缩技术。之所以选择倒排索引，除了它通用性强之外，也是由于其具有普遍性：倒排索引由以下两部分构成：
- 词典，其实就是由字符串构成的列表；
- 倒排列表，其实就是由一系列数字；

其他类型索引，不过都是由字符以及数字构成的，所以说从倒排索引的压缩也就能延伸出对于其他索引的压缩方法。

## 词典压缩

下表是一个典型的倒排索引，由单词；文档频率(DF)；倒排列表指针；3个部分组成



![](https://img-blog.csdn.net/20170810164526705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvemlxaW5nNTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


其中，词典部分的存储会浪费空间的根本原因在于分配给单词的空间是统一的，也就是说不论你的单词是像”we”这样短的，还是像”confidentiality”这样长的，都必须分配能够容纳最长单词的空间。所以比较直接的压缩方法是将这些单词连续地存储在一个区域中，而倒排列表中只是存储这些单词出现的起始位置。如下图所示：



![](https://img-blog.csdn.net/20170810164554836?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvemlxaW5nNTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


显然，这种做法使得词典中不存在冗余的空间了，所有的单词相当于被合成为一个整的字符串。当然，当单词数量极大的时候，还可以通过存储单词位置之间的差值来替代真实的单词位置，以降低存储单词位置的空间消耗。比如原本单词位置应该是”1,5,10,13,20…”，可以存储为”1,4,5,3,7…”。

更进一步，我们可以将上述词典压缩技术改进。还是把单词连成一个整体存储，只不过存储前，对单词分组，比如两两一组。只在倒排索引中，为每两个单词存储他们的起始位置，如下：



![](https://img-blog.csdn.net/20170810165600511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvemlxaW5nNTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


实际操作时，可以根据单词的长度动态对单词分组。查找倒排索引时，先根据位置信息读取这个单词分组，再进一步读取每个单词。从而实现对单词索引的进一步压缩。这里面存在的问题是：如何区分一个单词分组中的所有单词，一般的做法是在每个单词结尾处标记一个终止符，比如上图中，我用’$’号分割这些单词。

## 倒排列表压缩

倒排列表一般的内容包括：文档编号、词频、词位置。一个3部分信息。而这3部分信息基本都是（或者说可以转化为）整数。所以对于这部分数据的压缩，基本上是根据以下2个原则进行：
- 
对于递增整数序列，我们一般存储其数值之间的差值，而不是数值本身（这一点在上面词典压缩时已经用到了）。比如倒排列表中，文档编号和词位置一般都是递增的整数序列。

- 
对于整数，采用合适的压缩算法，编码数据。


第一点不再赘述，我在这里主要谈一下第二点。首先介绍一下在压缩算法中常用的编码技术，一般是两种：一元编码和二进制编码，这两类编码是压缩算法的基础构件，因为本文中我们涉及的压缩算法，无论其内部工作原理如何，都最终将数字表示成这两类编码的混合。
- 
一元编码(Unary Code)：一般是对于大于0的整数使用。对于整数$X > 1$，编码结果由$X - 1$个二进制数字1和最末尾的二进制数字0构成。例如对于3，编码为`110`；对于5，编码为`11110`。显然这种编码方式适用于小整数，对于大整数，实在是相当不经济。

- 
二进制编码(Binary Code)：这个大家很熟悉了，就是将整数转化为二进制字符串。


了解这两种编码之后，可以看一些经典的压缩算法了。由于压缩算法实在很多，其基本思想又都比较相似。所以我只介绍下面两类。

### 1. Elias-$\gamma$算法 和 Elias-$\delta$算法

Elias提出了两种压缩算法，通过分解函数将待压缩的数字分解成2个因子，之后分别利用一元编码和二进制编码表示这2个因子。

#### (1) Elias-$\gamma$算法

Elias-$\gamma$压缩算法的分解函数为：



$\begin{equation}x = 2^e + d\end{equation}$

其中，$x$为待压缩数字，$e,d$为分解因子。分解之后，对于数字$e + 1$用一元编码表示，而对于数字$d$采用比特宽度为$e$的二进制编码表示。比如数字9，分解为 $9 = 2^3 + 1$，那么$e + 1 = 4$，一元编码后为`1110`，$d = 1$的宽度为3的二进制编码为`001`，两个编码之间，以`:`分隔，最后得到数字9的Elias-$\gamma$压缩结果为`1110:001`

#### (2) Elias-$\delta$算法

Elias-$\delta$算法与Elias-$\gamma$相似，可以看做是Elias-$\gamma$进一步的延伸。第一步，对于待压缩整数按照与Elias-$\gamma$相同的分解函数分解成$e,d$两个因子，对于因子$d$同样采用长度为$e$的二进制编码表示。不同之处在于，对于$e + 1$采用Elias-$\gamma$算法压缩，将压缩后的编码形式与$d$的二进制编码再用`:`结合起来。比如，还是以数字9为例，对于$e + 1 = 4$通过Elias-$\gamma$压缩后得到`110:00`，$d = 1$宽度为3的二进制编码为`001`，结合起来，得到最终结果`110:00:001`。

根据这两种算法的计算过程，其实不用通过论证我们也能看出Elias-$\delta$算法比Elias-$\gamma$算法在对于大整数的压缩上更具优势。

### 2. Golomb算法 和 Rice算法

Golomb和Rice算法在原理上与Elias提出的两个算法一致，都是通过分解函数将大整数分解成2个因子，再对这两个因子编码，区别在于分解函数的不同。对于待压缩整数$x$，Golomb和Rice算法的分解函数如下：



$\begin{equation}f_1 = (x - 1) / b\\f_2 = (x - 1)\mod b\end{equation}$

其中$b$为一个小于$x$的整数。$f_1, f_2$为分解后的因子。说白了，就是$(x - 1)$除$b$的商和余数。经过这样的分解之后，对$f_1 + 1$进行一元编码，对$f_2$进行二进制编码。需要注意的是此处对于$f_2$的宽度控制：因为$f_2$的取值一定在 0~b-1 之间，所以，宽度为$\log(b)$的二进制编码足够表示$f_2$。下面具体看一下这两个算法的细节。

#### (1) Golomb算法
- 
参数$b$的选择：Golomb和Rice算法的不同在于对参数$b$的选择。Golomb算法对于$b$的选择为：$b = \ln(2) \times Avg$，其中$Avg$为待压缩数值序列的平均数，也就是说Golomb和Rice算法不仅仅考虑压缩数值本身，而是考虑整个待压缩的数值序列；$\ln(2)$是一个经验参数（一般取0.69），当然计算得到的$b$应该取整数。举个例子，一个待压缩序列`{14,144,113,182}`平均值为113（取整之后），此时，计算得到$b = 0.69 \times 113 = 77$.

- 
二进制编码长度的选择：这是Golomb算法中1相对复杂的部分了。因为我们要对$f_2 \in {0, 1, \dots, b - 1}$进行二进制编码，所以$f_2$的编码长度一定不会超过$\lceil log(b) \rceil$. 因此，Golomb算法按如下规则编码$f_2$：
- 
If $f_2 < 2^{\lfloor \log(b) - 1 \rfloor}$，设定$f_2$的编码长度为$\lfloor \log(b) \rfloor$，不足位补0；

- 
If $f_2 \geq 2^{\lfloor \log(b) - 1 \rfloor}$，设定$f_2$的编码长度为$\lceil \log(b) \rceil$，其中，第一位置为1，其他位正常二进制编码成$\lfloor \log(b) \rfloor$长；


- 
压缩实例：还是上面的待压缩序列`{14,144,113,182}`，其平均值为113，$b = 77$，根据分解函数，得到:




$\begin{equation}f_1 = (14 - 1) / 77 = 0\\f_2 = (14 - 1) \mod 77 = 14\end{equation}$

根据$b = 77$，可以得到对于$f_2$的二进制编码长度为6或7.

对$f_1 + 1 = 0 + 1 = 1$进行一元编码，得到$0$；对$f_2 = 14$进行二进制编码，因为$f_2 < 2^{6 - 1} = 32$，所以$f_2 = 14$的编码长度为6，编码为`001110`。最后压缩得到的14的编码结果为`0:001110`.

同理，编码这个序列中的144的步骤如下：



$\begin{equation}f_1 = (144 - 1) / 77 = 1\\f_2 = (144 - 1) \mod 77 = 66\end{equation}$

因为$f_2 \geq 2^{6 - 1} = 32$，所以$f_2 = 66$的编码长度为7，编码为`1100010`。综上，对144压缩的结果为`10:1100010`。

注：此处，对Golomb算法的介绍，我参考了张俊林《这就是搜索引擎》，以及Ricardo《Modern Information Retrieval》，他们两者对Golomb算法的具体细节方面有些出入，我以后者为准。其实具体细节没有必要太过于纠结，重点还是在于理解这种通过分解后编码压缩数据的思路。

#### (2) Rice算法

Rice算法与Golomb算法操作基本一致，唯一一点不同在于对$b$值的选取。Rice算法中，对参数$b$的选取原则如下：
- 
$b$为2的整数次幂

- 
$b$为小于Avg的数中最大的


还是上面Golomb算法算法中的例子，此时选取$b = 64 = 2^6$。之所以要这样取值，原因在于可以在具体运算中采用掩码操作或者比特位操作等快速运算，从而提高计算效率。

Golomb算法（Rice算法）的缺点在于无法通过对文档的一次遍历就获得压缩之后的索引。因为我们在压缩前必须提前知道待压缩序列的平均值。而其优点也是很明显的，动态处理编码长度的方式使得压缩效果更好。

## 压缩算法评估

最后，看看对压缩算法的优劣我们根据什么样的指标评估。一般来讲，有以下3方面：
- 
压缩率：压缩前大小与压缩后大小的比例关系，这个意义很明显。

- 
压缩速度：压缩算法的运行时间。这个指标其实不算很重要了，原因很明显，因为压缩索引是一次性的预计算，它不影响对用户查询的即时响应。即使时间较长，也不要紧。

- 
解压速度：将压缩后的数据恢复成原始数据所消耗的时间。这是3个指标中最重要的。因为在实际查询发生时，需要从磁盘将压缩数据读入内存，解压，搜索，最后返回结果，它直接关乎查询响应时间。




