# 在O(1)时间复杂度删除链表节点 - guoziqing506的博客 - CSDN博客





2016年04月28日 21:01:42[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1467
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个单链表中的表头和一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。并在删除该节点后，返回表头。

样例：给定 1->2->3->4，和节点 3，返回 1->2->4。

还是在删链表的节点。正常的删除前面已经提过（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51273818)），现在增加了难度，要求在O(1)的时间复杂度内删除。

时间复杂度的要求使得我们不能通过遍历的方法找到相关节点，而由上一道题可知，链表的删除还要知道要删除节点的前驱，这也不知道。

不过，能知道什么呢？知道要删除节点的后继！这个直接就知道，不需要任何遍历。

所以，如果我们把要删除的节点值以及地址都改成他的后继的，这事情就妥了。为什么呢？用我上一节讲的住房子的例子可以很好理解：相当于把要删除的“房间”（节点）里面的人（值）变了，人拿的“字条”（地址）也变了，而这个新生成节点的后继不会改变，正好相当于是删除了。

代码很简单，但是思路特别值得注意，算法的设计就是不断追求效率极限的过程。



```python
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    # @param node: the node in the list should be deleted
    # @return: nothing
    def deleteNode(self, node):
        temp = node.next
        node.val = temp.val
        node.next = temp.next
        # write your code here
```









