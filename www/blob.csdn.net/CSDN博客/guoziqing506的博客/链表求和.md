# 链表求和 - guoziqing506的博客 - CSDN博客





2016年05月01日 11:46:13[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1358标签：[链表](https://so.csdn.net/so/search/s.do?q=链表&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。

样例：给出两个链表 3->1->5->null 和 5->9->2->null，返回 8->0->8->null

首先，解释一下题意，拿样例来说，其实是295+513，然后，将结果保存在一个链表中，保存时，应先保存这个数值的个位数，再十位数，。。。

这其实和数组求和（用数组保存加数，求和）的问题是一样的，都是对应位加和，如果大于10，向后（因为是倒序保存，所以向后）进1位，为了避免链表复杂的操作，我们采取完全新建一个链表的方法，也就是新建一个链表，然后对给出的两个链表对应位处理，用处理结果生成一个新的节点，跟在新建的链表后面。

那样例来说，我们首先新建一个节点dummy，dummy->None，再用一个整型变量add1来保存是否向后进位。add1初始化为0

1. 3 + 5 + add1 = 8, dummy->8->None，add1 = 0

2. 1 + 9 + add1 = 10, 
dummy->8->0->None, add1 = 1

3. 5 + 2 + add1 =8,  dummy->8->0-8->None, add1 = 0

当两个链表全都遍历完时，还要看add1是否为1，若为1，再生成一个值为1的节点，跟在新生成的链表后面。

这里面需要特别注意两个问题：

1. 加和的两个链表长度不一定相等，如果不等，我们要先按对应位处理，完毕后再根据add1的值和没处理完的链表的部分构建节点，添加

2. add1的作用很重要，要始终存在于加和过程中，最后“都不能放过”

看代码：



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param l1: the first list
    # @param l2: the second list
    # @return: the sum list of l1 and l2 
    def addLists(self, l1, l2):
        cur1, cur2 = l1, l2
        dummy = ListNode(-1)
        pre = dummy
        add1 = 0
        while cur1 or cur2:
        	if cur1 and cur2:
        		temp = (cur1.val + cur2.val + add1)
        		cur1 = cur1.next
        		cur2 = cur2.next
        	elif cur1:
        		temp = (cur1.val + add1)
        		cur1 = cur1.next
        	else:
        		temp = (cur2.val + add1)
        		cur2 = cur2.next
        	add1 = temp // 10
        	pre.next = ListNode(temp % 10)
        	pre = pre.next
        if add1 == 1:
        	pre.next = ListNode(1)
        return dummy.next

        # write your code here
```





