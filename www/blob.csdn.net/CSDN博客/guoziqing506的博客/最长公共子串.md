# 最长公共子串 - guoziqing506的博客 - CSDN博客





2016年06月21日 11:30:57[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：444
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)








题目描述：给出两个字符串，找到最长公共子串，并返回其长度。

样例：给出A=“ABCD”，B=“CBCE”，返回 2




首先得明白子串和子序列的区别，子序列是要保持顺序不变的元素组成的序列，也就是说，不一定要连续，但是子串是要顺序不变，同时还必须连续。

如果你已经学习过之前我讲的对“两个字符串”这种动态规划问题的解法（例如：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51694388)，[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51685066)等等），那么这道题就一点都不难，将最优子结构（也就是状态转移方程）变换即可。

现在用一个二维表格record记录结果，，record[i][j]表示B的前 j 项与A的前 i 项中以B[j]为结尾元素的子序列的长度。那样例来说，record[2][1]就是"ABC"和"CB"中以字符"B"为结尾的子串的长度，这个值显然就是0.

自然，有这样的规律，如果A[i] == B[j]，那么record[i][j] = record[i - 1][j - 1] + 1，这样，就不难通过迭代计算出整个二维数组，最后，数组的最大值也就是我们要求的最终结果。

如果你没有做前面的几道题，这个逻辑理解起来可能有困难，所以建议你先去学习前面的东西（也就是上面链接给出的）。

代码如下：



```python
class Solution:
    # @param A, B: Two string.
    # @return: the length of the longest common substring.
    def longestCommonSubstring(self, A, B):
        m = len(A)
        n = len(B)
        if m == 0 or n == 0:
            return 0
        record = [[0 for j in range(n + 1)] for i in range(m + 1)]
        i = 1
        temp = 0
        while i <= m:
            j = 1
            while j <= n:
                if A[i - 1] == B[j - 1]:
                    record[i][j] = record[i - 1][j - 1] + 1
                j += 1
            temp = max(max(record[i]), temp)
            i += 1
        return temp
        # write your code here
```
还可以通过滚动数组，节约空间。




