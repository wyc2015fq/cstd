# 加一 - guoziqing506的博客 - CSDN博客





2016年05月12日 19:19:09[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：420标签：[数组](https://so.csdn.net/so/search/s.do?q=数组&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。该数字按照大小进行排列，最大的数在列表的最前面。

样例：给定 [1,2,3] 表示 123, 返回 [1,2,4].给定 [9,9,9] 表示 999, 返回 [1,0,0,0].




其实是两个链表求和的简单版（链表求和详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51289887)）。简单表现在两个方面：

1. 是数组，不是链表。数组的操作比链表简单太多了（因为有天然的下标，同时，不存在“摘链”，“链接”这些繁琐的操作）

2. 只是加1，而不是两个数组相加

思路和链表求和是一样的了。用一个整型变量add1记录是否应该进位，每一位的处理：为这一位加add1的和，再对10取余。这个思路比链表求和简单太多，不仔细讲了，有不明白的地方，可以回看上边的链接。

给出代码：



```python
class Solution:
    # @param {int[]} digits a number represented as an array of digits
    # @return {int[]} the result
    def plusOne(self, digits):
    	result = []
    	n = len(digits) - 1
    	add1 = 1
    	while n >= 0:
    		temp = digits[n] + add1
    		result.insert(0, temp % 10)
    		add1 = temp / 10
    		n -= 1
    	if add1 == 1:
    		result.insert(0, 1)
    	return result
        # Write your code here
```


需要注意第13行，最后若add1不为0，还要向前进一位。








