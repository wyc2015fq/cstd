# 乱序字符串 - guoziqing506的博客 - CSDN博客





2016年06月06日 15:07:04[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：2179
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。

样例：对于字符串数组 ["lint","intl","inlt","code"]，返回 ["lint","inlt","intl"]




还是使用哈希表。对于每个字符串出现的字符构成键，所在的索引构成值。这样，所有值中不止一个的，就构成了乱序字符串。

上面话说的不是很清楚。我们来看样例，首先设计键的结构：键的要求是要能表达清楚这个字符串中所有的字符，同时还要能与其他的乱序字符串直接对比。很容易想到set，但是set有两个问题，一来他无法存储重复的字符，二来，set也不可哈希。同理，list也是不可哈希的。直接对排序后的字符串做键呢？C++里面可以，此处也不行（因为Python中string是不可改变的）。所以，这里对键的设计比较麻烦。

不过，可以用这样一个办法：先将字符串转换成列表，队列表排序，再将排好序的列表转换成字符串，这个字符串当做哈希表的键就没问题了，每次遍历到的字符串都做这样的处理，自然可以比较。而哈希表的值可以用字符串列表中字符串位置的索引。比如样例中，键为："ilnt"，值为"[0, 1, 2]"。 最后，哈希表建立完毕后，对哈希表中的元素遍历，找到值（也就是位置的列表）的长度大于1的，根据值，找到原数组中相应元素，加入结果列表即可。

代码如下：



```python
class Solution:
    # @param strs: A list of strings
    # @return: A list of strings
    def anagrams(self, strs):
        hash_table = {}
        result = []
        index, n = 0, len(strs)
        while index < n:
            temp = list(strs[index])
            temp.sort()
            # 下面这行代码是将list转换成string
            temp = "".join(temp)
            if temp not in hash_table:
                hash_table[temp] = [index]
            else:
                hash_table[temp].append(index)
            index += 1
        for value in hash_table.values():
            if len(value) > 1:
                for i in value:
                    result.append(strs[i])
        return result
        # write your code here
```










