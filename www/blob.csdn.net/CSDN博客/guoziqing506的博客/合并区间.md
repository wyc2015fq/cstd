# 合并区间 - guoziqing506的博客 - CSDN博客





2016年07月18日 15:52:47[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：952标签：[lintcode																[数组](https://so.csdn.net/so/search/s.do?q=数组&t=blog)](https://so.csdn.net/so/search/s.do?q=lintcode&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)








题目描述：给出若干闭合区间，合并所有重叠的部分。

样例：给出的区间列表 => 合并后的区间列表：


[                     [

  [1, 3],               [1, 6],

  [2, 6],      =>       [8, 10],

  [8, 10],              [15, 18]

  [15, 18]            ]

]




首先看一下对于区间类型的定义：



```python
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
```


每个区间都有两个属性：start和end，我们需要做的工作，就是处理这些start和end的值，生成新的Interval类的对象，使得这些对象所代表的区间都没有重合部分。



那么当然很容易想到排序了，我们可以先按照每个区间的start作为关键字进行排序，这样，排序后的结果中，每个区间的start就是以升序排列的。

排好序后，我们设置两个值：left和right，作为要生成的新区间的两端。当然，初始时，left就是排序完的区间列表中，第一个区间的start，而right则是第一个区间的end，那么接下来我们需要做的，就是更新right的值。可以分以下两种情况讨论;

1. 下一个区间的start小于或者等于当前的right，那也就是说下一个区间可以和当前的这个以left和right为两端的区间合并。我们就令right = max(intervals[i].end, right). 比如[1, 3]和[2, 6]就是这种情况，合并之后，变为[1, 6]

2. 下一个区间的start大于当前的right，那也就是说不能合并这两个区间了，需要构成新的区间。那么我们将现在由left和right构成的区间加入结果列表，然后令left 和 right为下一个区间的strat 和 end. 比如[1, 3]和[2, 6]合并变为[1, 6]后，再处理[8, 10]，发现8 > 6，所以此时将[1,
 6]加入结果列表（其实是以left = 1, right = 6生成一个新的Interval型的对象，并加入结果列表），再令left = 8, right = 10

反复进行以上两步，直到整个区间列表处理完毕。

代码如下：



```python
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    # @param intervals, a list of Interval
    # @return a list of Interval
    def merge(self, intervals):
        n = len(intervals)
        if n <= 1:
            return intervals
        result = []
        intervals.sort(key=lambda d: d.start)
        index = 1
        left, right = intervals[0].start, intervals[0].end
        while index < n:
            # 下一个区间的起始位置小于或等于当前的right值，说明可以合并
            if intervals[index].start <= right:
                right = max(intervals[index].end, right)
            # 下一个区间的起始位置大于当前的right值，说明应该重新生成区间
            else:
                # 实际上是以left, right为初始变量生成一个Interval型的对象，并加入结果列表
                result.append(Interval(left, right))
                left = intervals[index].start
                right = intervals[index].end
            index += 1
        result.append(Interval(left, right))
        return result
        # write your code here
```








