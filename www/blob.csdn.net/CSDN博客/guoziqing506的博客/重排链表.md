# 重排链表 - guoziqing506的博客 - CSDN博客





2016年05月09日 23:23:34[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：4322
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个单链表L： L0→L1→…→Ln-1→Ln, 重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作

样例：给出链表1->2->3->4->null，重新排列后为1->4->2->3->null。


将L0,L1; L1,Ln-1;...排在一起，其实和回文链表（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51340547)）的逻辑是一样的，不同的是，回文链表是比较值，这里是通过“摘链”和“链接”的方法调整位置。

那思路就比较清楚了：和回文链表的做法一致，首先，通过“快慢指针法”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51212234)）找到中间节点，将中间节点之后的部分翻转（也就是单链表逆置，详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51295722)），最后，依次将被逆置部分的链表的节点插入相应位置。

其实还是以前的东西，不过综合在一起罢了。

那么代码并不难：



```python
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    """
    @param head: The first node of the linked list.
    @return: nothing
    """
    def reorderList(self, head):
        if head is None or head.next is None:
            return head
        slow, fast = head, head.next
        # 找到中间节点
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        # 以中间节点为界，将链表断开，分成前后两部分
        # 断开的目的是方便链表翻转操作
        cur = slow.next
        slow.next = None
        # 单链表逆置
        while cur:
            temp = cur
            cur = cur.next
            temp.next = slow.next
            slow.next = temp
        # 再次断开成两个链表，合并
        second = slow.next
        slow.next = None
        pre = head
        while second:
            temp = second
            second = second.next
            temp.next = pre.next
            pre.next = temp
            pre = temp.next
        return head
        # write your code here
```
需要注意的是，两次将链表断开都是为了方便对节点的操作。第一次是方便了单链表逆置，第二次是方便了链表合并。这种先断开，再链接的方法我们之前用过很多了。






