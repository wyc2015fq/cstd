# 组合 - guoziqing506的博客 - CSDN博客





2016年07月10日 21:32:51[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1275
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出两个整数n和k，返回从1......n中选出的k个数的组合。

样例：例如 n = 4 且 k = 2，返回的解为：[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]




深搜+递归的思路。与之前求取“二叉树的所有路径”如出一辙（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51178917)）。可以这样理解：拿样例来说：

1. 先将1放入组合：[1] 那么剩下的数只能在2, 3, 4中选择，因为k = 2，所以，我们只需要在2, 3, 4中选择一个就行，也就是[1, 2], [1, 3], [1, 4]；

2. 将2放入组合：[2]，因为1已经处理过，所以在3, 4中选择一个：[2, 3], [2, 4]

3. 将3放入组合：[3]，因为1, 2已经处理过，所以只能选择4：[3, 4]




所以，根据这个思路，我们可以写一个辅助函数helper()，helper()有4个参数做，做2件事情：

4个参数：

(1) begin：开始的位置。从这个位置开始，处理之后部分数组的可能的组合

(2) path：组合的“半成品”，例如样例中，我们先把1加入，形成了数组[1]，这个数组[1]显然是未来加入列表的一个“半成品”

(3) result：结果列表，存储“成型”（也就是长度为k）的组合

(4) k

做2件事情：

(1) 当path的长度等于k时，将这个path加入result

(2) 当path的长度小于k时，为path依次加入（从begin位置开始一直到最后）数组中的元素，每加入一个元素，就带着这个更新过的“半成品”path递归执行helper()函数，只不过，此时，begin变为begin + 1，比如样例中，先将1加入，带着“半成品”[1]进入以2为起点的helper()函数，形成结果[1, 2], [1, 3], [1, 4]；再以[2]为“半成品”，进入以3为起点的helper()函数......以此类推。

这就像是一棵多叉树的深搜一般，找出所有的路径。




代码如下：



```python
class Solution:
    """
    @param n: Given the range of numbers
    @param k: Given the numbers of combinations
    @return: All the combinations of k numbers out of 1..n
    """
    def combine(self, n, k):
        path = []
        result = []
        begin = 1
        self.helper(k, begin, n, path, result)
        return result

    def helper(self, k, begin, n, path, result):
        if len(path) == k:
            # 复制数组
            temp = path[:]
            result.append(temp)
            return
        # 遍历从cur到最后的数字
        for i in range(begin, n + 1):
            path.append(i)
            # 从下一位开始到最后的组合情况
            self.helper(k, i + 1, n, path, result)
            path.remove(i)
        # write your code here
```










