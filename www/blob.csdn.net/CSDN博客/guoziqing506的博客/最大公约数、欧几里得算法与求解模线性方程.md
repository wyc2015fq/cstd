# 最大公约数、欧几里得算法与求解模线性方程 - guoziqing506的博客 - CSDN博客





2016年10月10日 11:47:54[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1544








最大公约数是指两个或多个整数的约数中最大的一个。这个概念在小学时代，我们就已经知道了。但是今天依然把这个问题拿出来，是因为由最大公约数引发的一系列问题，成为了公钥密码学的基础，所以有必要对此类问题的来龙去脉再做一个了解。

## 欧几里得算法

### 步骤与实现

求解两个自然数的最大公约数时，我们最常用的一种方法就是辗转相除法，也叫欧几里得算法。

先简单回顾一下算法的步骤：求解两个自然数$a, b$的最大公约数$gcd(a, b)$，可以通过求解$gcd(b, a$ mod $b)$的最大公约数实现，以此迭代，循环向前，直到函数成为$gcd(x, 0)$时（x为正整数）返回x.

代码如下：

```python
def euclid(a, b):

    while b != 0:
        temp = a
        a = b
        b = temp % b

    return a
```

### 原理解析

这个算法本身非常简单，大家也非常熟悉。但是为什么可以这样做呢？首先，我们需要理解GCD递归定理。

**GCD递归定理**：对任意非负整数$a, b$，等式$gcd(a, b) = gcd(b, a$ mod $b)$成立。

证明：

先证$gcd(a, b)$能整除$gcd(b, a$ mod $b)$
- 
设$d = gcd(a, b)$，那么有$d|a$和$d|b$成立。

- 
再假设$a$ mod $b = x$，也就是说，$a = nb + x$，从而$x = a - nb$

- 
由以上两点可知，$d|b$且$d|x$，则说明$d$是$b$和$a$ mod $b$的约数

- 
所以，$d|gcd(b, a$ mod $b) $，也就是$gcd(a, b)|gcd(b, a$ mod $b)$


上面最后一点的原因是：两个整数的公约数可以整除这两个整数的最大公约数。证明略。

再证$gcd(a, b)$能被$gcd(b, a$ mod $b)$整除。和上面的证明几乎是一模一样的道理
- 
设$d = gcd(b, a$ mod $b)$，那么有$d|a$和$d|b$成立。因为$a$ mod $b$可以写成$a$与$b$的线性关系式。

- 
也就是说$d$是$a$与$b$的公约数，显然，有$d|gcd(a, b)$成立


好了，到此，由以上两点的证明可知，$gcd(a, b)|gcd(b, a$ mod $b)$ 且 $gcd(b, a$ mod $b)|gcd(a, b)$。也就是说$gcd(a, b)=gcd(b, a$ mod $b)$. 

证明完毕。

了解了GCD递归定理，不妨再往下思考，倘若有那么一个时刻，gcd函数中的第二个参数为0了，也就是说，经过迭代，最终有$gcd(a, b) = gcd(x, 0)$存在，而$gcd(x, 0) = x$，所以，当gcd函数的第二个参数为0时，可以结束迭代，返回此时函数的第一个参数的值。因为算法中的两个参数始终是单调递减且非负，所以不可能一直进行下去。这也就证明了“辗转相除法”（欧几里得算法）的正确性。

## 欧几里得拓展算法

### 欧几里得拓展算法是做什么的

明确了欧几里得算法的基本逻辑，我们现在将这个算法拓展一下，就发现它可以做一些别的事情。

首先，还是看一个定理：

**定理**：如果任意整数$a, b$不都为0，那么$gcd(a, b)$是$a, b$的线性组合集$\{ax + by, ~ (x, y \in Z )\}$中的最小正元素。

证明：设$s = ax + by$是$a, b$的线性组合集中最小的正元素。现在要证明的是$s = gcd(a, b)$
- 
首先，因为$gcd(a, b)|a$且$gcd(a, b)|b$，所以，$gcd(a, b)|s$，也就可以推出：$gcd(a, b) \leq s$

- 
其次，计算一下$a$ mod $s$的值： 


$\begin{equation} a~mod~s = a - ns = a - n(ax + by) = a(1 - nx) + b(-ny) \end{equation}$

可见，$a$ mod $s$也是$a, b$的线性组合之一，且$s > a$ mod $s \geq 0$- 
前面假设了$s = ax + by$是$a, b$的线性组合集中最小的正元素，所以只能是$a$ mod $s = 0$，也就是说$s|a$，同理得到$s|b$，说明$s$是$a, b$的公约数。

- 
由上面第3条可知，$s \leq gcd(a, b)$；由上面第1条可知$s \geq gcd(a, b)$，综上，$s = gcd(a, b)$


了解了这个定理，再思考一个问题，既然$gcd(a, b)$一定可以写成$ax + by$的形式，其中$x, y$可能为0或负数。那么，问题来了，怎样求解这里的x和y呢？这就是欧几里得拓展算法要解决的问题。

解决这个问题有什么用，他能帮助我们求解模线性方程，而求解模线性方程又是著名的RSA公钥密码算法中寻找密钥的关键步骤。这里先大概提一下。

### 欧几里得拓展算法

现在已知的是：$d = gcd(a, b) = ax + by$，求解的是$(d, x, y)$ 3个数组成的三元组

分两种情况讨论：
- 若$b = 0$，那么简单了，$d, x, y = (a, 1, 0)$
- 若$b \neq 0$，那么，此时不妨设存在一个三元组$(d', x', y')$，使得$d' = gcd(b, a$ mod $b) = bx' + (a$ mod $b)y' = d$成立

因为$a$ mod $b = a - nb$，所以，由2中的等式可知：$d = ay' + b(x' - ny')$

综上，可以得到这样一个结论：对于使得式子$d = gcd(a, b) = ax + by$成立的三元组$(d, x, y)$，有关系$(x, y) = (y', x' - ny')$成立。其中，$n = a // b$，就是$a \div b $的整数商。

通过上面的分析，可以发现这是个典型的递归算法，递归触底的条件是函数的第二个参数为0. 

写出代码，如下：

```python
def extensiveEuclid(a, b):

    if b == 0:
        return a, 1, 0

    temp = extensiveEuclid(b, a % b)

    return temp[0], temp[2], temp[1] - (a // b) * temp[2]
```

## 求解模线性方程

前面的只是学习完毕后，算是为求解模线性方程做好了铺垫。模线性方程是这样一类问题：求解满足条件$ax \equiv b($mod $n)$的所有$x$的值。

上面这个式子的意思简单说一下，就是对于一个整数$n$，$ax$的值对$n$取余，与$b$对$n$取余的结果是一样的。

给出2个定理，证明我省略了。有兴趣的话自己可以查阅《算法导论》

**定理1**：当且仅当$d|b$时，方程$ax \equiv b($mod $n)$有解，其中，$d = gcd(a, n)$

**定理2**：方程$ax \equiv b($mod $n)$有$d$个不同的解，或者无解。

根据上面讲解的欧几里得拓展算法可知，当$d = gcd(a, n)$时，$d = ax' + ny'$；而要方程$ax \equiv b($mod $n)$有解，则$d|b$。所以，可以得到这样一个结论：

假设方程$ax_0 \equiv b$ mod $n$有解$x_0$，则$x_0 = x'(b/d)$ mod $n$

证明如下： 


$\begin{equation}ax_0  \equiv ax'(b / d)~(mod~n) \equiv d(b / d)~(mod~n) \equiv b~(mod~n)\end{equation}$

而根据前面的定理1、定理2，以及上面证明的式子，可知，

模线性方程的解为：$x = x_0 + i(n / d)$，其中$i = (0, 1, 2, ...d - 1)$

到此，总算把如何求解模线性方程大致说完了。这个东西的用处我目前只知道是在RSA算法中寻找密钥，具体如何应用，在讲解RSA算法的时候再说。如果还有什么别的用途，还望知道的读者不吝告知。

## 完整代码

给出刚才说的：欧几里得算法，欧几里得拓展算法，以及求解模线性方程的完整Python代码：

```python
def euclid(a, b):
    """return the greatest common divisor(gcd)"""

    while b != 0:
        temp = a
        a = b
        b = temp % b

    return a


def extensiveEuclid(a, b):
    """return a 3-tuple (d, x, y)"""

    if b == 0:
        return a, 1, 0

    temp = extensiveEuclid(b, a % b)

    return temp[0], temp[2], temp[1] - (a // b) * temp[2]


def initialSolution(d, x, b, n):
    """get the initial solution x0 of mod linear function if it exists"""

    return x * (b / d) % n


def solutions(a, b, n):
    """return all solutions of the mod linear function"""

    tempList = extensiveEuclid(a, n)

    d = tempList[0]
    x = tempList[1]

    # the case of no solution
    if b % d != 0:
        print("No solution")
        return None

    x0 = initialSolution(d, x, b, n)

    result = []

    for i in range(d):
        new_solution = (x0 + i * (n / d)) % n
        result.append(new_solution)

    return result

print(solutions(14, 30, 100)) # >>> 95, 45
```





