# 两个链表的交叉 - guoziqing506的博客 - CSDN博客





2016年05月09日 19:50:42[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：2442
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：请写一个程序，找到两个单链表最开始的交叉节点。注意事项如果两个链表没有交叉，返回null；在返回结果后，两个链表仍须保持原有的结构；可假定整个链表结构中没有循环。

![](https://img-blog.csdn.net/20160509193936169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


两个链表交叉，其实就是在某一时刻，两个链表指向了同一个节点。那么，如果两个链表等长，这道题就毫无难度了，我们直接分别遍历两个链表，看在哪个节点处，两个链表的指向的节点是一样的。

但是这道题并没有说链表等长，那也好办，我把他们变成等长的。具体思路可以这样描述：

1. 统计两个链表的长度，得到长度差

2. 设置两个指针，分别指向两个链表的头结点

3. 令较长的链表的指针先走与长度差相等的步数，这样一来，如果从现在走到的这个节点开始，同时遍历两个链表，他们第一次指向同一节点时，就是最开始交叉的位置。

那样例来说，令b链表先走一步，到达b2处，从b2开始，同时遍历两个链表，知道两个链表都指向c1时，停止循环，返回c1.

所以，直接写出代码就行：



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param headA: the first list
    # @param headB: the second list
    # @return: a ListNode
    def getIntersectionNode(self, headA, headB):
        curA, curB = headA, headB
        countA, countB = 0, 0
        # 两个循环，统计两个链表的长度
        while curA:
        	countA += 1
        	curA = curA.next
        while curB:
        	countB += 1
        	curB = curB.next
        # 计算长度差
        gap = abs(countA - countB)
        # 令长的链表先走gap长
        if countA >= countB:
        	while gap != 0:
        		headA = headA.next
        		gap -= 1
        else:
        	while gap != 0:
        		headB = headB.next
        		gap -= 1
        # 开始遍历，看是否能指向同一节点
        curA, curB = headA, headB
        while curA:
        	if curA == curB:
        		return curA
        	curA = curA.next
        	curB = curB.next
        return None
        # Write your code here
```








