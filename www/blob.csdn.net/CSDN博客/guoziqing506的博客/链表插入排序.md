# 链表插入排序 - guoziqing506的博客 - CSDN博客





2016年04月26日 22:11:16[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1140
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：用插入排序对链表排序

样例：Given 1->3->2->0->null, return 0->1->2->3->null


之前，在我的博文“将排序链表转换为二分查找树”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51212234)）中已经介绍了链表的快慢指针法，以及“摘链”和“链接”的基本操作，现在，我们以这道题为例，继续熟悉链表的基本操作。

插入排序的原理我就不多解释了（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50949772)），简单说就是往一个已经排好序的数组中不断按照大小关系添加新的元素，对于数组，当然是简单的，可对于链表，当使用插入排序的时候，会出现一个问题：我们不能从排好序的链表中从后往前遍历链表，只能是从前往后。

所以，我们可以这样来设计算法：初始时，将链表头结点和头结点之后的部分断开，头结点的那一段当做是排好序的，然后将后面的链表依次往头结点的这一部分添加，举例来说：

链表：1->3->2->4->null，将头结点和后面的部分断开，变成1->null和3->2->4->null，1->null看做是排好序的部分，添加的时候依次取后面的那部分的节点，比如在这里，先取3，然后对前面排好序的链表从前往后遍历，找到应该插入的位置即可。

这就是基本的解决方法了。不过有一点，那就是如果新取出的这个节点的值比排好序的链表的尾节点还大，那么就没必要再费事重新遍历了，直接添加在排好序的链表后面就行。

所以代码如下：



```python
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    """
    @param head: The first node of linked list.
    @return: The head of linked list.
    """ 
    def insertionSortList(self, head):
        if head == None:
            return head
        # first为未排序链表的头结点
        first = head.next
        head.next = None
        # 设置一个dummy连在head前面
        dummy = ListNode(-1)
        dummy.next = head
        # 设置一个尾节点，用于和新值比较
        tail = head
        while first:
            # 新值比排好序链表的尾巴大，直接跟后面
            if tail.val < first.val:
                # 摘下first，连在tail后面
                temp = first
                tail.next = temp
                first = first.next
                tail = tail.next
                tail.next = None
            # 新值比排好序链表的尾巴小，只能从头搜索
            else:
                # 从前往后遍历排好序的链表
                pre = dummy
                cur = dummy.next
                while cur:
                    if cur.val < first.val:
                        cur = cur.next
                        pre = pre.next
                    else:
                        # 插入first节点
                        temp = first
                        first = first.next
                        temp.next = cur
                        pre.next = temp
                        break
        return dummy.next
        # write your code here
```
里面有着多次“摘链”和“链接”的操作，不熟悉的话好好体会。另外，链表的东西最好结合代码看，所以我把详细的过程写在了注释里面。




