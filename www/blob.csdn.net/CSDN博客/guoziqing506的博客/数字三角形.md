# 数字三角形 - guoziqing506的博客 - CSDN博客





2016年06月12日 19:51:44[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：831
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。

样例：比如，给出下列数字三角形：
[

     [2],

    [3,4],

   [6,5,7],

  [4,1,8,3]

]

从顶到底部的最小路径和为11 ( 2 + 3 + 5 + 1 = 11)。

按照之前讲的动态规划的解法，还是分两步，1. 找转移方程，2. 处理边界及初始的条件

1. 根据规律，到达其中某一层的最小路径为到达这一层的所有位置的最小路径的最小值。所以，可以用一个数组record保存第i - 1层中到达所有位置所需要的最小路径，用一个临时数组temp保存当前处理的层的每个位置的最小路径。比如，当我们处理第二层时，temp[0] 就表示到达样例中数字3那个位置的最小路径。

显然，当前层，第j个位置的最小路径是由上一层每个位置的最小路径得到的。根据题意，只能在相邻的数字间走动，所以，可得状态转移方程：temp[j] = min(record[j - 1], record[j]) + triangle[i][j]，其中，triangle为表示数字三角形的二维数组。

2. 初始条件肯定是要令temp = [triangle[0][0]]；边界上，要注意，当求取temp[0]时，record[-1]是不存在的，而当求取temp[i]时（i为行数，也就是每层的最后一个位置），record[i]也是不存在的。

给出代码：



```python
class Solution:
    """
    @param triangle: a list of lists of integers.
    @return: An integer, minimum path sum.
    """
    def minimumTotal(self, triangle):
        m = len(triangle)
        if m == 0:
            return 0
        record, temp = [triangle[0][0]], []
        i, j = 1, 0
        while i < m:
            while j < i + 1:
                if j - 1 >= 0 and j <= i - 1:
                    temp.append(min(record[j - 1], record[j]) + triangle[i][j])
                elif j - 1 < 0:
                    temp.append(record[j] + triangle[i][j])
                else:
                    temp.append(record[j - 1] + triangle[i][j])
                j += 1
            record = temp
            temp = []
            j = 0
            i += 1
        return min(record)
        # write your code here
```
需要注意的是，我们没有整个建立一个二维数组来存储结果，而是通过record和temp两个数组的交换完成了动态规划记录的任务。





