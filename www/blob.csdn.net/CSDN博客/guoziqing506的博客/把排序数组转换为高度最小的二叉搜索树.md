# 把排序数组转换为高度最小的二叉搜索树 - guoziqing506的博客 - CSDN博客





2016年04月18日 22:49:04[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：2180
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给一个排序数组（从小到大），将其转换为一棵高度最小的二叉搜索树。

样例：给出数组 [1,2,3,4,5,6,7], 返回

![](https://img-blog.csdn.net/20160418225039635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


首先，先来看一下二叉搜索树（也称为二叉排序树）的定义：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

这么一看，建树的思路就很明确了。因为我们现在拿到的是一个排序数组，那么首先应该找的是这个数组的中值，找的方法很容易想到之前“二分查找”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50957775)）中常用的left和right两个指针的套路。将这个中值赋值给根节点，这个时候，显然中值以左的数据就都比中值小了，可以用这段数组构建根节点的左子树，中值以右的数据都比中值大，则用来构建右子树，构建的方法与刚才讲的一样（再分别找中值即可），这是典型的递归思路。

拿这个例子看一下：

1. 找到中值4，生成根节点，数组被分成[1, 2, 3], [5, 6, 7]两段

2. 对[1, 2, 3], [5, 6, 7]两段分别找中值，找到了2和6，生成根节点的左右孩子。。。以此类推

需要注意的是：递归“触底”的条件是数组为空

对于这种牵涉数组首尾位置的运算，最好能令首尾位置作为形参参与运算。例如之前我们见到的“搜索区间”的问题（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51137688)）就是在求左右两侧的界限时，将数组一分为二，分别令首尾位置作为形参。这是一种标准的解决办法！

那么，这道题就不难了，也采取定义新的辅助函数的方法，将首尾位置作为形参。代码如下：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    """
    @param A: a list of integer
    @return: a tree node
    """
    def sortedArrayToBST(self, A):
        if len(A) == 0:
            return None
        left, right = 0, len(A) - 1
        return self.helper(A, left, right)
        
        
    def helper(self, A, left, right):
        if left <= right:
            mid = (left + right) // 2
            root = TreeNode(A[mid])
            root.left = self.helper(A, left, mid - 1)
            root.right = self.helper(A, mid + 1, right)
        else:
            return None
        return root
        # write your code here
```
辅助函数的“触底”条件是left > right，也就是说这部分数组已经处理完毕了




