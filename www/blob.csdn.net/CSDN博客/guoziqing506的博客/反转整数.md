# 反转整数 - guoziqing506的博客 - CSDN博客





2016年06月02日 10:20:58[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：993
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)。

样例：给定 x = 123，返回 321；给定 x = -123，返回 -321

从末尾起，依次输出整数的每个位，组成一个新的整数——这就是这道题所需要做的工作。

所以我们可以采用经典的”先取余，再求商“的循环，依次输出数字，再将这些数字组合起来。需要注意的是整数溢出的问题，32位int型的整数取值范围是：-2147483648(-2^31)~2147483647(2^31 - 1). 考虑到给出的整数有可能是负数，而对负数做取余，结果并不是我们想要的最后一位数字（例如：-123 % 10 = 7）

所以，可以先对整数求取绝对值，再对这个绝对值处理，最后输出结果时，若整数一开始就是负数，则再加个“-”号即可。

代码如下：



```python
class Solution:
    # @param {int} n the integer to be reversed
    # @return {int} the reversed integer
    def reverseInteger(self, n):
        max_int = 2147483647
        temp = abs(n)
        result = 0
        while temp > 0:
            result *= 10
            result += temp % 10
            if result > max_int:
                return 0
            temp = temp // 10
        return result if n >= 0 else -result
        # Write your code here
```






这里顺带说一下，为什么整数的取值范围是-2147483648(-2^31)~2147483647(2^31 - 1)，首先，可以确定的是，32位的二进制字符串可以表示的数一共有2^32个，除去整数0，因为是要表达有符号的整数，所以正负数应该平分剩下的（2^32 - 1）个“名额”，无奈是个奇数，所以只能一个占2^31 - 1个，另一个占2^31个。又因为负数的二进制表示是相应的正数二进制先取反码，再取补码，为了使负数的二进制形式不溢出，就只能(-2^31)~(2^31
 - 1)了。试想，如果-(2^31 - 1)和2^31同时存在，则-(2^31 - 1)的码字为(1000...000)，而2^31的码字也是(1000...000)，（求取负数的二进制表示，详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51548511)）所以范围只能是：-2147483648(-2^31)~2147483647(2^31
 - 1)




