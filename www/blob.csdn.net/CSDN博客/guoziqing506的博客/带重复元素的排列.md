# 带重复元素的排列 - guoziqing506的博客 - CSDN博客





2016年07月03日 13:03:20[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1912
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出一个具有重复数字的列表，找出列表所有不同的排列。

样例：给出列表 [1,2,2]，不同的排列有：
[

  [1,2,2],

  [2,1,2],

  [2,2,1]

]




与不带重复元素求取全排列的思路是一样的（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51804111)），当时我们先讲了递归的思路，简单来说是这样的：

1. 先抽取一个元素出来，对剩下的元素做全排列

2. 将抽取出的元素依次插入剩下元素所生成的全排列的首位

3. 再抽取一个元素出来，重复1~2步，直到所有的元素都被抽取过

其中，生成全排列的算法也是对要进行全排列的元素进行1~3步。函数内部调用自身，构成递归。




此处，不同的是，因为有了重复元素的存在。我们当然可以先按之前求全排列的方法，将所有的结果得出，再去重。但是，在这，我要介绍的是另一种方法。

重复元素的存在导致在抽取元素的时候，我们不能按之前那样，依次抽取了，比如1, 2, 2三个元素，如果依次抽取的话，会出现这样的情况：

抽取2，剩下的元素构成全排列：[[1, 2], [2, 1]]，再将2插入，得到[[2, 1, 2], [2, 2, 1]]

但是有两个2啊，所以，正常情况下，再抽取一个2，一样的道理，得到[[2, 1, 2], [2, 2, 1]]，这就重复了。

所以，我们可以怎么办呢，可以先将这几个数构成的数组排序，然后用一个while循环筛除重复的元素，也就是重复的元素中，只抽取一个。

看代码吧：



```python
class Solution:
    """
    @param nums: A list of integers.
    @return: A list of unique permutations.
    """
    def permuteUnique(self, nums):
        result = []
        if nums is None:
            return result
        n = len(nums)
        if n == 0:
            result.append([])
        nums.sort()
        i = 0
        
        # 遍历整个数组
        while i < n:
            # while循环筛除重复
            while i < n - 1 and nums[i] == nums[i + 1]:
                i += 1
            # 抽取元素，记为x
            x = nums[i]
            # 复制列表，并将列表中去除x
            temp_nums = nums[:]
            temp_nums.remove(x)
            # 剩余元素全排列后，在所有排列的首位添加之前抽取的元素
            for ele in self.permuteUnique(temp_nums):
                ele.insert(0, x)
                result.append(ele)
            i += 1
        return result
        # write your code here
```




这就是递归的方法了，当然你也可以仿照“全排列”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51804111)）中的非递归的方法写出代码，我在这里略过了。




