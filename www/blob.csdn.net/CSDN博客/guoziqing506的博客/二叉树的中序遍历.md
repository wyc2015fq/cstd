# 二叉树的中序遍历 - guoziqing506的博客 - CSDN博客





2016年04月15日 09:40:36[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：800
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









之前讲了非递归的二叉树的前序遍历，我们用的是栈的方法，本节看看如何通过栈实现二叉树的中序遍历。

![](https://img-blog.csdn.net/20160415094138320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


还是先看这幅图，因为中序遍历的策略是“左-根-右”，所以，就这幅图而言，结果应该是DBEAFCG

在之前做前序遍历的时候，我建立了一个栈，通过先加入根节点，再删除后加入右节点，左节点的逻辑关系，合理的控制了数据运行的流程，详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51154630)

在中序遍历这里，比前序遍历要难一点，难在什么地方呢？因为是“左-根-右”，所以我们在探测到最左端叶子节点之前，不能对栈中的节点做访问。

所以，基本思路可以是这样的，先建立一个栈stack

1. 从根节点A开始，只要当前节点非空，将当前节点加入stack，stack = [A]

2. 只要当前节点有左孩子，就令当前节点为他的左孩子，并加入stack，直到没有左孩子为止。此时，stack = [A,B,D]

3. 一旦当前节点没有左孩子了，就取出栈顶元素，访问，并令当前节点为这个元素的右孩子

将上面的步骤迭代，就可以最终得到中序遍历的结果。因为逻辑上始终执行的是“左-根-右”




代码如下：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param root: The root of binary tree.
    @return: Inorder in ArrayList which contains node values.
    """
    def inorderTraversal(self, root):
        result = []
        stack = []
        cur = root
        while cur or len(stack) != 0:
            # 不处理，一直向左深入
            if cur:
                stack.append(cur)
                cur = cur.left
            # 深入到头了，回溯，输出值，再遍历右侧
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
        return result
        # write your code here
```








