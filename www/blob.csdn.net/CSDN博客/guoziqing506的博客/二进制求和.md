# 二进制求和 - guoziqing506的博客 - CSDN博客





2016年06月01日 14:39:16[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：3667
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定两个二进制字符串，返回他们的和（用二进制表示）。

样例：a = 11；b = 1。返回 100




和之前链表求和（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51289887)）的逻辑一样，都是对于整数“序列化”的求和，主要考察的是对于序列（数组，字符串等）的操作的熟悉程度。

我们可以新建一个结果字符串——result，初始化为空，然后从后往前遍历两个给出的二进制字符串，对应位做二进制加法（当然要处理好进位的问题），然后依次将相加的结果添加到result中即可。

但是这个里面有个问题，就是两个二进制串的长度不一定相同，如果要对长度进行判断和处理的话，代码量显然太多。所以可以采取这样一种方法，如果说其中一个二进制字符串已经遍历完，我们再往下遍历时，就把这个二进制字符串的位看做0（其实已经没有了，但是看做0不会影响），相当于本来是11 + 1，现在变成了11 + 01，结果是不受影响的，但是写循环的时候则节省了代码量。

代码如下：



```python
class Solution:
    # @param {string} a a number
    # @param {string} b a number
    # @return {string} the result
    def addBinary(self, a, b):
        index1, index2 = len(a) - 1, len(b) - 1
        result = ""
        # 进位的值，0表示不进位（进位0），1表示进位1
        add1 = 0
        while index1 >= 0 or index2 >= 0:
            t1 = int(a[index1]) if index1 >= 0 else 0
            t2 = int(b[index2]) if index2 >= 0 else 0
            temp = t1 + t2 + add1
            result = str(temp % 2) + result
            add1 = temp // 2
            index1 -= 1
            index2 -= 1
        if add1 == 1:
            result = "1" + result
        return result
        # Write your code here
```
注意一下，不要忘了18行对最后进位的处理。代码很简单，但是需要细心。






