# 线段树的修改 - guoziqing506的博客 - CSDN博客





2016年07月31日 11:58:29[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：393标签：[lintcode																[递归](https://so.csdn.net/so/search/s.do?q=递归&t=blog)](https://so.csdn.net/so/search/s.do?q=lintcode&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)








题目描述：对于一棵 最大线段树, 每个节点包含一个额外的 max 属性，用于存储该节点所代表区间的最大值。

设计一个 modify 的方法，接受三个参数 root、 index 和 value。该方法将 root 为跟的线段树中 [start, end] = [index, index] 的节点修改为了新的 value ，并确保在修改后，线段树的每个节点的 max 属性仍然具有正确的值。




样例：对于线段树:

![](https://img-blog.csdn.net/20160731115309698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



如果调用 modify(root, 2, 4), 返回:

![](https://img-blog.csdn.net/20160731115333448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


或 调用 modify(root, 4, 0), 返回:

![](https://img-blog.csdn.net/20160731115358698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





在做这道题之前，请先完成“线段树的构造”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/52066168)），“线段树的查询”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/52074586)）。因为这道题跟前面的两题用的思路是一模一样的。

还是采取搜索的方法，除非搜索到相应的叶子节点，修改值，否则，就递归地搜索当前节点的左右孩子。

代码如下：



```python
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end, max):
        self.start, self.end, self.max = start, end, max
        self.left, self.right = None, None
"""

class Solution: 
    """
    @param root, index, value: The root of segment tree and 
    @ change the node's value with [index, index] to the new given value
    @return: nothing
    """
    def modify(self, root, index, value):
        # 查询与节点没有交集，剪枝
        if root is None or root.start > index or root.end < index:
            return
        # 搜索到叶子节点，修改
        elif root.end == root.start == index:
            root.max = value
        # 递归的过程
        else:
            self.modify(root.left, index, value)
            self.modify(root.right, index, value)
            root.max = max(root.left.max, root.right.max)
        # write your code here
```






