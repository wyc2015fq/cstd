# 搜索二维矩阵 - guoziqing506的博客 - CSDN博客





2016年04月01日 20:27:28[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：630
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









写出一个高效的算法来搜索 m × n矩阵中的值。

这个矩阵具有以下特性：
- 每行中的整数从左到右是排序的。


- 每行的第一个数大于上一行的最后一个整数

样例：


考虑下列矩阵：



```
[
  [1, 3, 5, 7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
```


给出 `target = 3`，返回 `true`



这个题其实说了个什么事呢，就是把一个排好序的数列分段后放在一个二维矩阵当中，在矩阵中搜索。如样例所示，其实是把一个12长的排序数列分成了三段，每段成为二维矩阵的一行，一共三行。




明白了这一点，就不难了。我们可以用最简单的思路：先搜索行，确定target所在的行，再搜索target所在的列，两次都用二分查找。




既然思路上没什么难的了，可以直接上代码：





```python
class Solution:
    """
    @param matrix, a list of lists of integers
    @param target, an integer
    @return a boolean, indicate whether matrix contains target
    """
    def searchMatrix(self, matrix, target):
        row = len(matrix)
        if row == 0:
            return False
        col = len(matrix[0])
        # left,right代表列数
        left, right = 0, col - 1
        # high,low代表行数
        high, low = row - 1, 0
        while low <= high:
            mid1 = (low + high) // 2
            if matrix[mid1][0] == target:
                return True
            if matrix[mid1][0] > target:
                high = mid1 - 1
            if matrix[mid1][0] < target:
                low = mid1 + 1
        # 上面的循环结束后，low-1为target所在的行
        while left <= right:
            mid2 = (left + right) // 2
            if matrix[low - 1][mid2] == target:
                return True
            if matrix[low - 1][mid2] > target:
                right = mid2 - 1
            if matrix[low - 1][mid2] < target:
                left = mid2 + 1
        return False
        # write your code here
```


从代码看出，我们每次搜索都是按二分查找的“标配”来的（有关二分法最基本的使用：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50957775)），不同之处，仅在于搜索行的代码块结束后，我们搜到的是target所在行的下一行，因为每次处理的是某一行的第一个元素，也就是最小的那个，按照程序要求，比这个大，则 low = mid + 1。如果你真的明白了在上一篇“搜索插入的位置”中最后为什么要return
 left，[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50960280)，就很容易理解这里为什么low - 1是target所在行。





