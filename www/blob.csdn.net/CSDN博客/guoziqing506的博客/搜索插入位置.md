# 搜索插入位置 - guoziqing506的博客 - CSDN博客





2016年03月23日 09:01:20[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：656
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。


你可以假设在数组中无重复元素。

样例：

[1,3,5,6]，5 → 2

[1,3,5,6]，2 → 1

[1,3,5,6]， 7 → 4

[1,3,5,6]，0 → 0

解题的思路跟上一节的二分查找是一模一样的，在介绍二分查找的时候，还记得我们首先写了一个数组无重复元素时的查找程序（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50957775)），这与此题是几乎一样的，不同之处仅在此题中要求若查不到，返回一个插入的位置。所以代码可以在上一节的基础上略作修改：



```python
class Solution:
    """
    @param A : a list of integers
    @param target : an integer to be inserted
    @return : an integer
    """
    def searchInsert(self, A, target):
        
        left, right = 0, len(A) - 1
        # while循环解决的问题是：搜到返回，搜不到则只是改变了两个指针
        while left <= right:
            mid = (left + right) // 2
            if A[mid] == target:
                return mid
            if A[mid] > target:
                right = mid - 1
            if A[mid] < target:
                left = mid + 1
        # 经过上面的循环，left的位置其实就是应该插入的位置了
        return left
        # write your code here
```




程序一直到第18行都与无重复元素的二分查找一致，不同的只在第20行，返回的是left指针。



程序运行完第18行，会产生什么效用呢？如果数组中有查找的目标，那么目标的索引就已经返回了；而如果没有，那么left和right两个指针就会一直“逼近”目标应该被插入的位置，但是因为数组中根本不存在这个目标元素，所以，我们可以想象：当left与right重合（也就是都指向一个元素了），那么此时可以分两种情况讨论：



1. 例如：[1, 3, 5, 6]中查找2，最后left与right都指向元素1了，1 < 2，所以执行left = mid + 1;

2.例如：[1,
 3, 5, 6]中查找0，最后left与right都指向元素1了，1 > 2，所以执行right =
 mid - 1;

不论那种情况，毫无疑问，left代表的索引就是应该插入的位置，所以程序最后return left



