# 最长无重复字符的子串 - guoziqing506的博客 - CSDN博客





2016年05月31日 09:51:19[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：923
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个字符串，请找出其中无重复字符的最长子字符串。

样例：例如，在"abcabcbb"中，其无重复字符的最长子字符串是"abc"，其长度为 3。对于，"bbbbb"，其无重复字符的最长子字符串为"b"，长度为1。

从头开始扫描字符串，通过一个哈希表来记录每个字符以及字符所在的位置，若新扫描的字符不在哈希表中，则继续向前；若在哈希表中（记为cur），则证明此时已经不是无重复字符的子串了，所以，找到这个字符在哈希表中的位置，清空哈希表，从这个位置+1的位置（记为index）开始，再实施同样的操作（当然，其实此时从index到cur没有必要再重新扫描一遍，他一定是无重复字符的），比较每次进行这样的操作生成的哈希表的长度，返回最长的长度。

哈希表很典型的应用，当然，也可以看作是两个指针的应用。

我根据这两种方法，分别给出两段代码：



```python
class Solution:
    # @param s: a string
    # @return: an integer
    def lengthOfLongestSubstring(self, s):
        hash_table = []
        i, n = 0, len(s)
        max_value = 0
        temp = 0
        while i != n:
            if s[i] not in hash_table:
                hash_table.append((s[i], i))
                temp += 1
                i += 1
                max_value = max(max_value, temp)
            else:
                i = hash_table[s[i]] + 1
                temp = 0
                hash_table.clear()
        return max_value
        # write your code here




class Solution:
    # @param s: a string
    # @return: an integer
    def lengthOfLongestSubstring(self, s):
        begin, end, cur = 0, 0, 0
        n = len(s)
        max_len, temp = 0, 0
        while cur < n:
            if s[cur] not in s[begin: end]:
                temp += 1
            else:
                # 寻找重复位的下一位
                # 实际上，这里将s[begin: end]看作是天然的哈希表
                begin = s[begin: end].index(s[cur]) + 1 + begin
                temp = end - begin + 1
            max_len = max(max_len, temp)
            cur += 1
            end += 1
        return max_len
        # write your code here
```

第一段代码用的是哈希表，思路清晰简单，但是每次查到重复之后，需要从重复位的下一位开始，进行计算，所以可能计算量上不是最佳；第二段用的是两根指针，一次遍历解决问题，但是相对更难写一点。






