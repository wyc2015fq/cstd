# 不同的二叉查找树 - guoziqing506的博客 - CSDN博客





2016年06月26日 12:29:53[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：652
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给出 n，问由 1...n 为节点组成的不同的二叉查找树有多少种？

样例：给出n = 3，有5种不同形态的二叉查找树：

![](https://img-blog.csdn.net/20160626111348304)





二叉查找树的特点是任何一个节点左子树的节点值都小于这个节点，右子树的节点值都大于这个节点。根据这个规律，我们来分析：

设置一个一维数组record来保存n在不同的值时，不同的BST（二叉查找树）的数量

1. n = 0，没有节点，只有空树一种情况，record[0] = 1

2. n = 1，record[0] = 1

3. n = 2，若以1为根节点，则根节点的左子树只能为空，右子树中只有2一个节点，所以，根据排列组合原理，record[2] = record[0] * record[1]

4. 再写一步，n = 3, record[3] = record[0] * record[2]（以1为根节点），record[3] = record[1] * record[1]（以2为根节点），record[3] = record[2] * record[0]（以3为根节点）




这样，能得到动态规划的最优子结构了：record[i] = record[0] * record[i - 1] + record[1] * record[i - 2] + ......+ record[i - 1] * record[0] 

这是一个数列的求和，数列的每一项为record[j] * record[i - 1 - j]，其中j ∈[0, 1, 2 ,..., j - 1]

写出代码即可：



```python
class Solution:
    # @paramn n: An integer
    # @return: An integer
    def numTrees(self, n):
        record = [0 for i in range(n + 1)]
        record[0] = 1
        i = 1
        while i <= n:
            j = 0
            while j < i:
                record[i] += record[j] * record[i - 1 - j]
                j += 1
            i += 1
        return record[n]
        # write your code here
```








