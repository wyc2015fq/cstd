# 二分查找 - guoziqing506的博客 - CSDN博客





2016年03月22日 19:43:21[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1296
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个排序的整数数组（升序）和一个要查找的整数`target`，用`O(logn)`的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回`-1`。

样例：在数组 
```
[1,
 2, 3, 3, 4, 5, 10]
```
 中二分查找`3`，返回`2`。




二分查找是算法中非常重要的思想。正常情况下，我们在一个数组中查找一个数是否存在，该怎么做呢？当然是与数组中的元素一个个对照，那这样一来，查找一个数的时间复杂度就变成了O(n)，这也似乎是一个不可能再优化的算法了。但是，不能优化的前提是我们并不知道这个数组的任何规律，或者说这个数组本身就是没有规律的。而如果这个数组是一个排好序的，那情况就不一样了。




例如下面这个数组：[1, 2, 3, 4, 5,
 6, 7, 8]，我们现在想确定2在不在其中：




（1）找到数组的中间数（规定在数组为偶数时，取索引为数组长度除2的数；数组长度为奇数时，取索引为不大于数组长度除2的最大整数，说的有点多，其实举例就是：数组为[1,
 2]时取1，数组为[1, 2, 3]时取2）。在这里，我们取4为中间数




（2）如果中间数>目标，那么只需要在中间数之前的部分数组中查找（排好序的）；如果中间数<目标，在中间数以后的数组中查找；如果中间数等于目标，直接输出。此处，我们发现中间数4大于目标，于是，在[1,
 2, 3]中查找




（3）反复前两步，直到找到为止

上面这个例子就是二分查找的基本思想了，实际上是通过“二分”的办法逐步逼近目标。写程序时，我们一般使用两个指针left,right分别指向查找范围的第一个和最后一个数（这种两个指针的使用，也可以看做是“二分法”的标配），那么，像上面这样没有重复元素的二分查找程序就很简单了：






```python
def binary_search(nums, target):
    # 设置两个指针
    left, right = 0, len(nums) - 1
    # 为了完成彻底的“逼近”，只要left<=right就继续查找
    # 这样的循环条件，也被看作是二分法的“标配”
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        if nums[mid] > target:
            right = mid - 1
    # 没有找到，返回-1
```



反过来，再来看lintcode中这道题，难点其实就在有重复的数据，而题目要求查找的是第一个出现的位置，也就是说，当我们查到某一个nums[mid]
 == target，还不能直接将mid返回，而要继续查找mid之前的部分数组，所以，可以将程序略作修改：






```python
class Solution:
    # @param nums: The integer array
    # @param target: Target number to find
    # @return the first position of target in nums, position start from 0 
    def binarySearch(self, nums, target):
        
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            # 即便nums[mid] == target，也要继续查左边的部分
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        
        if left <= len(nums) and nums[left] == target:
            return left
            
        return -1
        # write your code here
```






需要特别注意的是17行：我们现在考虑数组中能查到的情况，只要能查到，那么while循环结束后，必将令left指向的元素为目标；而如果查不到，要么left越界，比如target值大于数组最大值（也就是数组最后一个元素）；要么nums[left] != target，比如target值小于数组最小值。只有left
 <= len(nums) 与 nums[left] == target两个条件同时满足，才能证明是找到了。


下面，我们就来看看另外一个及其相似的例子--搜索插入位置



