# 删除链表中的元素 - guoziqing506的博客 - CSDN博客





2016年04月28日 14:17:58[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：3786
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：删除链表中等于给定值val的所有节点。

样例：给出链表 1->2->3->3->4->5->3, 和 val = 3, 你需要返回删除3之后的链表：1->2->4->5。

最基本的删除操作，主要学习的是“摘链”的过程。

由链表的结构特性可知（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51273528)），单链表（简称链表，若无特别说明，链表都是单链表）是不能回溯的，就是说找不到这个节点的前一个节点，而所谓删除一个元素实际上是令这个节点的前一个元素直接指向这个节点的后一个元素（python特性是当一块内存无引用时，自动清空）。那么删除单链表节点就需要考虑到一种特殊情况，就是如果删除的是头结点呢？

为了方便操作，我们可以使用一种特殊的方法，那就是在头结点之前建立一个dummy节点，dummy的后一个节点是头结点，再做删除操作就方便多了。我个人将这种方法简称为dummy法。

代码很容易写出：



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param head, a ListNode
    # @param val, an integer
    # @return a ListNode
    def removeElements(self, head, val):
        dummy = ListNode(-1)
        dummy.next = head
        cur = head
        pre = dummy
        while cur:
        	if cur.val == val:
        		pre.next = cur.next
        	else:
        		pre = pre.next
        	cur = cur.next
        return dummy.next
        # Write your code here
```
第12行新建dummy时，随意给dummy一个赋值即可（我个人习惯用-1）。pre指向当前节点的前驱，将cur指向的节点中的值与要删除的值比较，即知该不该将cur指向的节点删除。若还没找到要删除的节点，则同时将pre和cur后移即可。






