# O(1)时间检测2的幂次 - guoziqing506的博客 - CSDN博客





2016年06月07日 11:58:10[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：771
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：用 O(1) 时间检测整数 n 是否是 2 的幂次。

样例：n=4，返回 true; n=5，返回 false.




乍一看，好像没什么思路，最笨的思路就是一直除2，看最后能否等于1，但是显然不符合时间复杂度的要求。

不过在之前学习位运算的过程中，我们了解过整数n与n - 1的关系（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51548511)）：当n是偶数，n -1是奇数，二进制形式中，那么n - 1就是偶数n 的尾巴上的所有0（直到倒数第一个1为止），全部变为1，且倒数第一个1变为0. 例如：142：10100000；141：10011111. 

根据上面的理论，如果一个数为2^n，那么它的二进制形式为10000...000这种形式，而2^n - 1一定是0111...111这种形式，这两个数做“与”运算就一定会导致结果是0。所以，我们需要做的工作就是判断一个数n, n & (n-1)是不是等于0.

需要注意的是整数0, 0 - 1 = -1，负数的二进制会有点麻烦，而0本身不是2的幂次，所以将这种特殊情况排除就行了。

代码如下：



```python
class Solution:
    """
    @param n: An integer
    @return: True or false
    """
    def checkPowerOf2(self, n):
        return not n & (n - 1) and n != 0
        # write your code here
```






