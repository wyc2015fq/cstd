# 两数组的交 - guoziqing506的博客 - CSDN博客





2016年06月02日 11:56:14[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1579
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：返回两个数组的交

样例：nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2].

这个题的意思是返回两个数组中相同的数，但是不包含重复。

题目本身太简单了，但是方法有很多，其实题目的挑战也就在于用多种方法实现这个功能，在这里，我为大家介绍3种方法;

1. 集合

2. 哈希表

3. 排序+两根指针




先说使用集合数据类型，这是最简单的方法，直接求取两个数组元素的集合，再对两个集合求交。总共就两行代码：



```python
class Solution:
    # @param {int[]} nums1 an integer array
    # @param {int[]} nums2 an integer array
    # @return {int[]} an integer array
    def intersection(self, nums1, nums2):
        return list(set(s1) & set(s2))
        # Write your code here
```


再说第二种方法，使用哈希表，先遍历第一个数组，用哈希表存储他的所有元素（这当然是去重之后的了），再遍历第二个数组，与哈希表比对，若在哈希表中，则添加到结果列表，同时删除哈希表的对应键值对（以免二次重复添加到结果列表），代码如下：





```python
class Solution:
    # @param {int[]} nums1 an integer array
    # @param {int[]} nums2 an integer array
    # @return {int[]} an integer array
    def intersection(self, nums1, nums2):
        hash_table = {}
        result = []
        hash_table.fromkeys(nums1)
        for i in nums2:
            if len(hash_table) == 0:
                break
            if i in hash_table:
                result.append(i)
                hash_table.pop(i)
        return result
        # Write your code here
```






第三种方法最麻烦，然而也最考编程能力，就是先对两个数组排序，然后同时用两个指针遍历两个数组，查找到相同的元素，则添加到结果列表，需要注意的是可以通过while循环去重。代码如下：



```python
class Solution:
    # @param {int[]} nums1 an integer array
    # @param {int[]} nums2 an integer array
    # @return {int[]} an integer array
    def intersection(self, nums1, nums2):
        result = []
        nums1.sort()
        nums2.sort()
        index1, index2 = 0, 0
        n1, n2 = len(nums1), len(nums2)

        if n1 == 0 or n2 == 0:
            return []

        while index1 < n1 and index2 < n2:
            if nums1[index1] == nums2[index2]:
                temp = nums1[index1]
                result.append(temp)
                while index1 < n1 and nums1[index1] == temp:
                    index1 += 1
                while index2 < n2 and nums2[index2] == temp:
                    index2 += 1
            elif nums1[index1] > nums2[index2]:
                index2 += 1
            else:
                index1 += 1
        return result
        # Write your code here
```
需要注意的是，19-22行的两个循环是查找下一个不同的元素








