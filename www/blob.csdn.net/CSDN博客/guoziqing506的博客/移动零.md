# 移动零 - guoziqing506的博客 - CSDN博客





2016年07月21日 10:09:47[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1887
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给一个数组 nums 写一个函数将 0 移动到数组的最后面，非零元素保持原数组的顺序

样例：给出 nums = [0, 1, 0, 3, 12], 调用函数之后, nums = [1, 3, 12, 0, 0].




其实，仅就实现这个功能来说，我们当然可以选择先把所有的0统计出来，然后删除这些0，再在数组后面添加这些0.

不过，这并不是这道题的本意，此题的本意是要我们熟悉数组中对于元素交换和指针移动的操作。所以，我们可以这样考虑：




1. 数组从开头部分如果不是0，那这一部分元素就不需要动了，比如[1, 1, 2, 0, 3]，我们显然不需要对前面的1, 1, 2做什么

2. 找到数组第一个为0的元素，为了保证非0元素的相对位置不变，我们再去寻找这个0元素之后的第一个非0元素，并将二者交换。

3. 为了方便叙述，我在这里设定指向第一个0元的指针为left，left之后，指向第一个非0的指针为right，第2步做的，实际上就是交换两个指针指向的元素，交换完成后，我们令left 和 right 各自向前移动一位，那么此时left指向的还是当前数组的第一个0元素，而right指向的不一定是非0元。比如下面这个例子：

(1) [1, 1, 2, 0, 0, 3, 0, 4]，left = 3, right = 5, 交换后-> [1, 1, 2, 3, 0, 0, 0, 4]

(2) left += 1, right += 1, 此时，left = 4, right = 6，可见left指向的还是当前数组的第一个0，而right指向的却不是非0元素

4. 所以，为了能继续上面第2步的操作，只要right指向的不是0，我们就令right += 1，直到是0为止。

代码如下：



```python
class Solution:
    # @param {int[]} nums an integer array
    # @return nothing, do this in-place
    def moveZeroes(self, nums):
        if nums is None:
            return nums
        left, n = 0, len(nums)

        # 下面的循环使得left指向数组的第一个0
        while left < n:
            if nums[left] == 0:
                break
            left += 1
        right = left + 1

        # 下面的循环使得right指向left之后数组的第一个非0数
        while right < n:
            if nums[right] != 0:
                break
            right += 1

        while right < n:

            # 如果nums[right]非0，则与nums[left]交换
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                # 令left与right各向前移动一位，这样做保证了left始终指向数组的第一个0
                right += 1
                left += 1

            # 如果nums[right]为0，则令right向前移动，找非0的元素
            else:
                right += 1
        return nums
        # Write your code here
```





