# 旋转链表 - guoziqing506的博客 - CSDN博客





2016年05月10日 19:53:26[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1562
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数

样例：给出链表1->2->3->4->5->null和k=2；返回4->5->1->2->3->null

首先，观察一下这个题目要达到的目的，其实，换一种说法，可以这样来描述：给出一个k值，将链表从倒数第k个节点处起之后的部分移动到链表前面，就样例来说，其实是将4->5这一部分移动到整个链表前面，变成4->5->1->2->3->null。不过，需要注意的是，题中没有给出k的大小，当k比链表的长度还大的时候，我们就需要先用k对链表的长度求余，比如，如果k
 = 7，那么上面的例子还是将4->5移动到整个链表前面。

所以说，这个题的思路可以这样来总结：

1. 先求出整个链表的长度

2. 根据k值找到需要移动的部分链表的前驱（样例中的3）

3. 在前驱之后将链表断开，移动后半部分

代码如下：



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param head: the list
    # @param k: rotate to the right k places
    # @return: the list after rotation
    def rotateRight(self, head, k):
        if head is None:
            return head
        cur = head
        count = 1
        # 计算链表长度
        while cur.next:
        	cur = cur.next
        	count += 1
        # 为节省代码量，这里是一个很有技巧的处理：用尾节点链接头结点
        cur.next = head
        # 此处，k为cur从尾节点到要断开部分的前驱需走的步数
        k = count - k % count
        # 找到前驱
        while k != 0:
        	cur = cur.next
        	k -= 1
        # 断开
        head = cur.next
        cur.next = None
        # 因为首尾已经相连，所以直接返回前驱后面的那个节点即可，此处引用为head
        return head
        # write your code here
```
需要注意的是21行首尾相连的技巧，这大大节省了我们的代码量，其实，就按之前思路中所描述的一步步来，也没问题。但是这个技巧确实很棒，值得学习。具体的细节我写在了代码注释里。




