# 哈希函数 - guoziqing506的博客 - CSDN博客





2016年06月06日 16:33:04[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：972
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)








题目描述：在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一个大整数，比如：



hashcode("abcd") = (ascii(a) * 33^3 + ascii(b) * 33^2 + ascii(c) *33 + ascii(d)) % HASH_SIZE 



                              = (97* 33^3 + 98 * 33^2 + 99 * 33 +100) % HASH_SIZE



                              = 3595978 % HASH_SIZE


其中HASH_SIZE表示哈希表的大小(可以假设一个哈希表就是一个索引0 ~ HASH_SIZE-1的数组)。给出一个字符串作为key和一个哈希表的大小，返回这个字符串的哈希值。

样例：对于key="abcd" 并且 size=100， 返回 78




很简单，直接照着这个算法写就行。但是如果整个先计算和，再对HASH_SIZE取模，会出现问题（比如溢出，时间超过限制等），所以，我们可以写一个n级的循环，每一步都对当时的计算结果mod(HASH_SIZE)以释放内存。因为从数学上讲，以下两个式子是成立的：

1. (a + b) mod p = (a mod p + b mod p) mod p

2. (a*b) mod p = ((a mod p) * (b mod p)) mod p

因此，拿样例来说，可以这样迭代：

1. temp = ascii(a) % HASH_SIZE

2. temp = (temp * 33 + ascii(b)) % HASH_SIZE
 = (ascii(a) * 33 + ascii(b)) % HASH_SIZE

......

按照这种迭代，写出代码即可：



```python
class Solution:
    """
    @param key: A String you should hash
    @param HASH_SIZE: An integer
    @return an integer
    """
    def hashCode(self, key, HASH_SIZE):
        temp = 0
        i, n = 0, len(key)
        while i < n:
            temp = (temp * 33) % HASH_SIZE
            temp = (temp + ord(key[i])) % HASH_SIZE
            i += 1
        return temp
        # write your code here
```


这样，每一步都通过mod HASH_SIZE，防止了溢出，也提高了运算效率。
需要注意的是，第12行的ord函数是python中将字符转换成asc码的函数，相应的，也有一个将asc码转换成字符的函数，chr().



