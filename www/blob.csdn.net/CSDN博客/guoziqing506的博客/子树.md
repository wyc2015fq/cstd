# 子树 - guoziqing506的博客 - CSDN博客





2016年04月20日 17:04:57[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：524标签：[递归																[二叉树](https://so.csdn.net/so/search/s.do?q=二叉树&t=blog)](https://so.csdn.net/so/search/s.do?q=递归&t=blog)
个人分类：[lintcode](https://blog.csdn.net/guoziqing506/article/category/6289140)

所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)








题目描述：有两个不同大小的二进制树： T1 有上百万的节点； T2 有好几百的节点。请设计一种算法，判定 T2 是否为 T1的子树。

子树的判断，当然很容易想到递归。因为可以这样来考虑：如果树A是树B的子树，那么有三种可能性：

1. 只要B是空，那B一定是A的子树

2. 当B不空时，A若空，那么一定不是

3. 当A和B都不空时，要么A和B完全一样（我在这里说的是同样位置的节点所包含的值一样），要么A是B的左子树的子树，要么A是B的右子树的子树。

所以还需要一个函数来判断两棵树是否完全一样，这个判断的逻辑也是递归。两棵树完全一样可以用这样的规则判断：

1. 根节点的值一样

2. 左右子树都完全一样

而递归“触底”的条件是两棵树都为空，那个时候，两棵树也是完全一样的。

那就不难写出代码了：



```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    # @param T1, T2: The roots of binary tree.
    # @return: True if T2 is a subtree of T1, or false.
    def isSubtree(self, T1, T2):
        if T2 is None:
            return True
        if T1 is None:
            return False
        return self.isSametree(T1, T2) or self.isSubtree(T1.left, T2) or self.isSubtree(T1.right, T2)
    
    
    def isSametree(self, T1, T2):
        if T1 == T2 == None:
            return True
        if T1 and T2:
            return T1.val == T2.val and self.isSametree(T1.left, T2.left) and self.isSametree(T1.right, T2.right)
        return False
        
        # write your code here
```
需要注意的是两个函数中前四行的有关于T1,T2空的判断语句，逻辑不能错。



所以说，判断树的问题时，一定要对他的节点是否为空的情况做缜密的分析。






