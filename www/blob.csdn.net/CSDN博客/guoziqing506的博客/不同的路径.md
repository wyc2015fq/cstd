# 不同的路径 - guoziqing506的博客 - CSDN博客





2016年06月12日 20:21:44[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：918
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：有一个机器人的位于一个M×N个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？




跟之前的那道“最小路径和”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51647609)）是一模一样的逻辑，而且比之前还要简单。

1. 看状态如何转移：到达网格的i行j列可能的路径为到达i - 1行，j列的路径数加上到达i行，j - 1列的路径数，因为机器人只有这两条途径能到达目的地[i][j]。用二维数组record存储到达每个位置可能的路径数，则record[i][j] = record[i - 1][j] + record[i][j - 1]

2. 处理边界：record第一行和第一列的所有值都是1（直观上理解也很容易，因为只能向下或向右走，所以到达这些位置只可能有一条路径）. 你也可以看做因为状态转移方程中有一项不存在了。

给出代码：



```python
# method_1

class Solution:
    """
    @param n and m: positive integer(1 <= n , m <= 100)
    @return an integer
    """ 
    def uniquePaths(self, m, n):
        if m < 1 or n < 1:
            return 0
        # 方便起见，令表格初始化为全部是1
        record = [[1 for i in range(n)] for j in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                record[i][j] = record[i - 1][j] + record[i][j - 1]
        return record[m - 1][n - 1]
        # write your code here


# method_2

class Solution:
    """
    @param n and m: positive integer(1 <= n , m <= 100)
    @return an integer
    """ 
    def uniquePaths(self, m, n):
        if m < 1 or n < 1:
            return 0
        if m == 1 and n == 1:
            return 1
        else:
            return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)
        # write your code here
```


我给出了两段代码，方法2是用递归做的，大家可以感受一下动态规划和递归的不同（我在上一篇博客中讲过，一个是“从小到大”，一个是“从大到小”）





