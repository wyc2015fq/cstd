# 决策树归纳 - guoziqing506的博客 - CSDN博客





2017年03月26日 10:16:04[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：5002标签：[机器学习																[数据挖掘																[分类](https://so.csdn.net/so/search/s.do?q=分类&t=blog)
个人分类：[数据挖掘																[机器学习](https://blog.csdn.net/guoziqing506/article/category/6776278)](https://blog.csdn.net/guoziqing506/article/category/6289196)

所属专栏：[机器学习经典算法研究](https://blog.csdn.net/column/details/25189.html)





## 分类与监督学习

现实中，我们经常会遇到这样的问题：银行收到用户的信用卡申请表。当然，这是一张带有用户丰富信息的申请表，比如年龄，学历，收入，信用记录等等。那么银行的工作人员如何根据这些信息判别这个用户是否是诚信的，是否应该通过他的信用卡申请呢？人工的判断显然耗时耗力，且不一定准确，比较靠谱的办法是通过已有的，大量用户的使用记录，分析得到一个模型（或一个方程，一种工具），利用这个模型，可以判别出大量用户属性与用户是否诚信的关联关系。从而用一种科学的计算方式，得到一个相对准确的判断。而获得这种模型的方法，就是分类问题的核心。

形式化的，分类是这样一种数据分析的形式：现在有大量的数据对象，构成了一个数据集，数据集用$D = \{obj_1, obj_2, \dots, obj_n\}$来表示，每个数据对象$obj_i$都是由1个类标号和多个属性构成的。比如上面说的信用卡的例子中，每个已经申请过信用卡的用户就是一个数据对象，他们的年龄，学历，收入等等就是他们的属性，而他们对于信用卡的使用情况（也就是是否诚信）构成了他们的类标号“诚信”或者“不诚信”。也就是说，分类实际上由两个过程组成：
- 通过对已有类标号的数据集（也称为“训练集”）进行学习，构建分类器；
- 利用分类器，对未分类的数据（也称为“测试集”）分类；

我们工作的核心，在于使用某种算法，通过大量的训练集，“学习”出一种分类器。之后，通过分类器，对新的未分类的数据做分类预测。这里插一句闲话，预测问题大致上分为两类：
- 数值预测。比如商店通过顾客信息预测他大概能消费多少钱，这涉及到了具体的数值，常见的方法有“回归分析”。
- 分类。常见的方法有今天要说的决策树，朴素贝叶斯，支持向量机等等

信用卡的例子中，一旦完成了这种分类器的学习，就可以根据新用户的属性处理新的用户申请，做出这个用户可能“诚信”或“不诚信”的判别。可见，分类需要给出一定量的有类标号的训练集，这不同于之前我曾经提到的聚类（详见：[聚类分析: k-means算法](http://blog.csdn.net/guoziqing506/article/details/59057427)）。聚类没有类标号，完全是只有属性的原始数据，甚至连分成几类也是不确定的。而分类的过程则似乎更“靠谱”一些。这种先给出训练集的学习模式，在机器学习中也叫“监督学习”，它与聚类所代表的“无监督学习”有着本质区别。

## 决策树的结构

本篇博客中，我将介绍分类中最基础，也是最简单的学习过程：**决策树（Decision Tree）归纳**。它从有类标号的训练元组中学习得到决策树。决策树是一种树形结构，一个典型的决策树如下图所示，这张图也是《数据挖掘》中的一个例子，根据顾客信息，对是否会”buys_computer”做判别。



![](https://img-blog.csdn.net/20170324173309735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvemlxaW5nNTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


下面对决策树做几点说明：
- 
每个内部节点代表一个属性上的测试，而他的每个分支代表这种属性测试的结果，比如上图中，根节点代表的就是对”age”这个属性的测试，三个分支”youth”, “middle_aged”,”senior”，分别代表测试的结果

- 
每个叶子节点代表一个类标号，这里，只有”yes”和”no”两种，即买计算机或者不买

- 
做分类预测时，将新的数据对象自根节点向下遍历决策树，比如现在有这样的数据对象：{age: youth; student: yes; …}无论省略号所代表的属性如何，都可以判断出，这个用户买计算机的概率很大。


需要注意的是，决策树的分类大多是对新的数据对象的类做概率性的判断，当然，也有些时候做的是确定性的判断，这需要根据具体问题做具体分析。

## 决策树归纳

### 1. 树节点

当前，主流的决策树归纳算法有三种：ID3, C4.5, CART，虽然这3种算法在细节上有所差异，但主要的思想都是自顶向下，采用贪心方法，递归地分治构造决策树。算法将整个训练集同时读入，随着构造的决策树深度的增加，训练集被每个分支分裂成更多更小的子集，在讲解具体的算法之前，先给出对一个决策树节点类的定义，如下：（注意：本文所有函数及类的定义均用Python实现）

```python
class DecisionTreeNode(object):

    def __init__(self):

        # tag is the class name
        self.tag = None

        self.isLeaf = True

        # pointers is a dictionary, {attributeValue: child, ...}
        self.pointers = {}

        # the best attribute that used to split dataset
        self.splitCriterion = None
```

我们设定一个决策树节点应该有上面所示的四个属性，下面具体说一下：
- 
splitCriterion：分裂准则。即这个节点是按照哪个属性对数据集划分的，比如上面图中根节点的分裂准则是”age”。splitCriterion是只有内部节点才拥有的属性，叶子节点的splitCriterion设为None;

- 
tag：叶子节点所对应的类标号，比如上图中，从左至右，叶子节点的tag值分别为”no”,”yes”,”yes”,”no”,”yes”，所有内部节点的tag值为None

- 
isLeaf：节点是否为叶子，是叶子，设为True；不是，设为False

- 
pointers：内部节点的指针集合。在后面的代码实现中，我将pointers以字典的形式表示，这个字典的键值对为{attribute_value: child, …}，表示内部节点的每个孩子是有分裂准则下的哪个属性值分裂而成的，比如上图中，根节点的pointers为{“youth”: 最左的孩子, “middle_aged”: 中间的孩子, “senior”: 最右的孩子}。这样设计的目的是为了决策树生成之后，方便于对新的数据分类。


### 2. 学习步骤

决策树构造的步骤如下：

输入：数据集（每个数据对象都有一个或多个属性）；属性列表（所有出现在数据集中的属性） 

输出：一棵决策树
- 
新建一个决策树节点$u$。初始时生成的节点就是决策树的根节点，根节点对应的是全体数据集。

- 
根据当前节点所对应的数据集，选择一个“最好的”属性作为数据集的分裂准则，按照这个属性的不同属性值（简单起见，这里我假设属性值都是离散的，连续的情况后面单另说），对数据进行分割。这里，所谓“最好的”属性，是指按照这个属性分割数据集之后，生成的每个数据子集都尽可能地“纯”。也就是说，最好每个子集都属于同一类（拥有相同的类标号）。

- 
在属性列表中，删除当前使用为分裂准则的属性。

- 
根据数据分割后的数据子集，以及删除了一个属性的属性列表，递归地执行决策树算法。新生成的决策树（实际上是子树）的根节点被$u$对应的指针指向。


当然，这里面有三种“触底”生成叶子节点的情况：
- 
如果此时对应节点的数据集全部属于同一类C，那么此时的这个节点就是叶子节点，其tag为C；

- 
如果此时属性列表为空，那么此时的这个节点就是叶子节点。然后采用“多数投票”的方法为这个叶子节点选择tag。即此时节点所对应的数据集中，拥有最多数据对象的类为这个叶子节点的tag；

- 
如果此时对应节点的数据集为空，那么此时的这个节点就是叶子节点。且采用数据分割前（也就是其父亲节点）所对应的数据集中“多数投票”的结果作为其tag；


从上面的过程可以看出，这是一个思路非常清晰的递归算法。先将全体数据集读入，选择“最好的”属性，按照这个属性，对数据分割。同时，将已经“用过”的属性删除出列表，再对于每个数据子集和此时剩余的属性集合再做类似的过程。最终，遇到上面三个“触底”的条件时，形成叶子，结束这一分支的分裂过程。

这里插一句闲话，如果读者属于Kd-tree构建索引的过程（详见：[Kd-tree原理与实现](http://blog.csdn.net/guoziqing506/article/details/54692392)），会发现，决策树这种分裂的思路和Kd-tree非常类似，只不过用途上就大相近庭了：Kd-tree是为了能实现对于多维数据库的快速查询，而决策树，是在学习数据的特征和类别之间的关系。

在给出实现代码之前，先解决一个棘手的问题：怎样选择“最好的”属性作为分裂准则，让分裂的结果尽可能地**“纯”**呢？（其实就是构建一棵平衡或者相对平衡的决策树）这样做的目的有两个，一来， 相关文献表明平衡或者相对平衡的决策树在预测分类结果时会有更好的效果；二来，显然平衡的决策树无论是在构建还是在构建完成后对于数据分类的预测都更加高效。

目前，有三种比较主流的方法解决这个问题，这三种方法恰好也对应了上面说的三种决策树归纳的算法：1. 信息增益（ID3）；2. 增益率（C4.5）；3. 基尼指数（CART）。本文，我只介绍前两种方法，至于基尼指数，读者们可参考《数据挖掘》，那里面有着详细的介绍。

### 3. 分裂准则的选择

#### （1）信息增益

信息增益的基本思想来自于香农的信息理论，当中有一个非常重要的公式，就是信息熵的计算。信息熵表示的是一条消息所含信息量的多少，我这里简单说说，比如现在两条信息：
- 明天早上太阳从东边升起
- 抛掷一枚硬币，正面朝上

对于第一条消息来说，其信息量为0，因为这是必然事件，不用说，我们也知道的；但是对于事件2来说，就有点信息量了，因为发生的概率只有1/2。概率上的不确定性，才能给信息带来了信息量。此外，如果一个事件有$n$个结果，发生这些结果的概率分布越均匀，关于这个事件的信息量也就越大。比如“巴萨踢赢了皇马”比“巴萨踢赢了北邮校队”的信息量要大，因为前者的概率更加均等；而后者，几乎是必然事件。

为了定量的刻画这种信息量的多少（计算信息熵），就出现了下面这个著名的公式：



$\begin{equation}Info(D) = - \sum_{i = 1}^{m}{p_i \log_{2}(p_i)} \end{equation}\tag{1}$

其中，$p_i$表示出现第$i$个结果的概率。可以证明，在所有$p_i$都相等时，$Info(D)$达到最大值。这个公式其实计算的是一个平均意义上的信息量（信息期望）。

把信息熵的概念用在决策树算法的最佳分裂准则（属性）的选择上，也能发挥作用。可以这样理解，如果按照一个属性分割数据集，那么可以针对每个数据集都按照信息熵的公式计算信息量，如果分得越“纯”，那显然每个数据子集的信息熵就越小，当然，每个子集根据其大小不同，在原数据集上占据的权重也就不同，我们可以依照下式计算出，经过属性$A$的分割后，数据子集全体的信息熵，记为$Info_{A}(D)$：



$\begin{equation}Info_{A}(D) = \sum_{i = 1}^{v}{\frac{|D_i|}{|D|} \times Info(D_j)}\end{equation}\tag{2}$

其中，$v$表示属性值的个数，比如上面的决策树的图示中，属性`age`有3个属性值。而$\frac{|D_i|}{|D|}$很明显在这里表示数据子集$D_j$的权重了。

根据信息论的原理，信息的作用是消除事件的不确定性，决策树归纳中，每一次按照属性对数据集的分割，都相当于是我们借助了一些信息，最终到每个叶子节点归为了同一类，则是完成了对这种不确定性的彻底消除。所以，$Info_{A}(D)$实际上表示的是经过属性$A$的划分后，距离对数据集$D$完全分类还需要的信息期望。这个期望越低，则说明越接近最终的分类结果。而之前的$Info(D)$也是这个意思，表示数据集还未经$A$分割时，距离完全分类的信息量，这个量肯定比$Info_{A}(D)$大一些。他们两个之间的差值，就叫做“信息增益”，用如下公式计算得到：



$\begin{equation}Gain(A) = Info(D) - Info_{A}(D)\end{equation}\tag{3}$

显然，应该选择信息增益最大的属性作为分裂准则，这样，就能使分裂后的数据集都尽可能地“纯”。下面，我们以《数据挖掘》中的例子来说明选择最佳分裂属性的计算过程，首先我们给出数据集的形式：
|RID|student|income|age|credit_rating|class|
|----|----|----|----|----|----|
|1|no|high|youth|fair|no|
|2|no|high|youth|excellent|no|
|3|no|high|middle_aged|fair|yes|
|4|no|medium|senior|fair|yes|
|5|yes|low|senior|fair|yes|
|6|yes|low|senior|excellent|no|
|7|yes|low|middle_aged|excellent|yes|
|8|no|medium|youth|fair|no|
|9|yes|low|youth|fair|yes|
|10|yes|medium|senior|fair|yes|
|11|yes|medium|youth|excellent|yes|
|12|no|medium|middle_aged|excellent|yes|
|13|yes|high|middle_aged|fair|yes|
|14|no|low|senior|excellent|no|

$~$

按照上面的公式(1)，可以先计算出整个数据集$D$的信息量：$Info(D) = 0.940$

接下来，根据公式(2),(3)分别计算以属性`age`，`income`，`student`，`credit_rating`分割数据集所产生的信息期望，以及信息增益。先看属性`age`的：



$\begin{equation}Info_{age}(D) = 0.694\\Gain(age) = 0.940 - 0.694 = 0.246\end{equation}$

同理，可得：



$\begin{equation}Gain(income) = 0.029\\Gain(student) = 0.151\\Gain(credit\_rating) = 0.048\end{equation}$

不难发现，属性`age`的信息增益最大，因此，对于根节点（原始全体数据集）的分割应该首先以`age`为分割属性。我们就得到了下面这张图：



![](https://img-blog.csdn.net/20170325222112108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvemlxaW5nNTA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


这时候，middle_aged属性值所对应的数据子集都是属于同一类，那么根据上面讲的递归的“触底”条件，这个节点直接变成叶子，并且拥有类标记`tag = yes`。之后，将属性`age`从属性列表中删除，对于此时`youth`所对的节点及数据子集再次进行类似的决策树学习，只不过用的数据集是`age`属性为`youth`的数据子集，且属性列表少了一个`age`，对于`senior`所对的节点及数据子集也进行这样的过程，最终得到的决策树如本文最上面的图所示。

当然，上面所展示的方法，都是应对这种最简单的离散属性值的情况，对于连续属性值的处理，会稍微复杂一点，步骤如下:
- 
将数据集中出现的属性$A$的值按递增序排列，每个相邻值得中点看做是可能的分裂点。假设数据集中，属性$A$一共出现了$v$个值，那么需要比较的是这$v - 1$个分裂点。

- 
比较的方法是计算$Info_{A}{D}$，按照分裂点将数据集分成两部分，一部分属性$A$的值大于分裂点，另一部分小于或等于分裂点。对于每个分裂点都做如此计算，找到信息增益最大的分裂点。


其实，只要解决了最佳属性的选择问题，决策树归纳算法就算是完成了一大半的工作了。我们在本文的最后给出了决策树归纳的完整代码。然而，这种信息增益的方法选择分裂属性在某些时候，也有它的问题，所以，虽然早期的ID3算法使用了信息增益技术，但是在随后更加成熟的C4.5算法中，则采用了“增益率”的方法，具体如下。

#### （2）增益率

使用“信息增益”的算法会面临这样一个问题，就是有些属性会导致一些毫无意义的数据分割。比如上面的例子中，我们将数据对象的属性”RID”排除在外了，如果没有排除，那么”RID”一定会是第一个最佳的分裂属性。他把大小为$n$的数据集分裂成$n$个数据子集，每个子集都只有一个对象，绝对够“纯”。但是这样的分割是没有什么意义的。所以，也就出现了对“增益率”的计算，实际上，就是将“信息增益”做规范化处理。

首先计算分裂后的数据子集的信息量，这实际上跟计算信息熵的公式是一样的：



$\begin{equation}SplitInfo_{A}(D) = - \sum_{j = 1}^{v}{\frac{|D_i|}{|D|}} \times \log_2{(\frac{|D_i|}{|D|})}\end{equation}$

上式的计算结果可以当做归一化因子处理信息增益，也就得到了增益率：



$\begin{equation}GainRate(A) = \frac{Gain(A)}{SplitInfo_{A}(D)}\end{equation}$

实际上就是一个简单的比率计算，但是却克服了之前按”RID”划分时产生的问题。

## 程序设计

### 1. 数据类型

首先，设计一下读入的数据形式。我用的是Python中的字典。将上面表格中所示的数据对象读成一个字典，再将所有的字典构成一个元组，这个元组的所有元素如下：

```
{'RID': '1', 'student': 'no', 'class': 'no', 'income': 'high', 'age': 'youth', 'credit_rating': 'fair'}, 
{'RID': '2', 'student': 'no', 'class': 'no', 'income': 'high', 'age': 'youth', 'credit_rating': 'excellent'}, 
{'RID': '3', 'student': 'no', 'class': 'yes', 'income': 'high', 'age': 'middle_aged', 'credit_rating': 'fair'}, 
...
```

我不写全了，总之，每个数据对象被读成一个字典，数据的每个特征（包括RID和class，这两个不算数据属性）都作为键，其对应的特征值作为键对应的值。

### 2. 分裂准则（属性）选择

现在，根据前面说的信息增益的原理，我们将分裂属性选择的过程（select Attribute）的代码表示如下（非主要函数只是给出汉语的功能说明）：

```python
def classCount(data):
    对数据集data中的数据对象做类别统计，得到一个字典{class_name: number, ...}

def getAttributeList(data):
    得到数据集data的所有属性的列表


def info(data):
    """
    calculate the entropy of dataset
    :param data: dataset that contains data objects, is a tuple: (obj_1, ..., obj_n)
    :return: the entropy of dataset
    """

    classRecord = classCount(data)

    n = len(data)
    result = 0
    for classTag in classRecord:
        pi = classRecord[classTag] / n
        result += (-pi * math.log(pi, 2))

    return result


def infoForAttribute(dataSize, attributeValue_subset):
    """
    calculate the expectation of information if we split data with the attribute
    :param dataSize: the number of objects in dataset
    :param attributeValue_subset: a dictionary, as form as {attributeValue_1: subset_1,... }
    :return: the sum of weight x entropy
    """

    result = 0

    for subset in attributeValue_subset.values():

        weight = len(subset) / dataSize
        result += weight * info(subset)

    return result


def dataPartition(data, attribute):
    """
    Partitioning the data according to an attribute
    :param data: dataset that contains data objects, is a tuple: (obj_1, ..., obj_n)
    :param attribute: an attribute
    :return: a dictionary attributeValue_subset, as form as {attributeValue_1: subset_1,... }
    """

    attributeValue_subset = {}

    for obj in data:

        attributeValue = obj[attribute]

        if attributeValue not in attributeValue_subset:
            attributeValue_subset[attributeValue] = [obj]
        else:
            attributeValue_subset[attributeValue].append(obj)

    for key in attributeValue_subset:
        attributeValue_subset[key] = tuple(attributeValue_subset[key])

    return attributeValue_subset


def selectAttribute(data, attributeList):
    """

    :param data:
    :param attributeList:
    :return: the attribute that denotes the split criterion
    """

    attributeValue_subset = dataPartition(data, attributeList[0])
    dataSize = len(data)

    maxGain = info(data) - infoForAttribute(dataSize, attributeValue_subset)
    result = attributeList[0]

    for attribute in attributeList[1:]:

        attributeValue_subset = dataPartition(data, attribute)
        temp = info(data) - infoForAttribute(dataSize, attributeValue_subset)

        if temp > maxGain:
            maxGain = temp
            result = attribute

    return result
```

### 3. 决策树构建

到此，解决了属性选择的问题，那就可以着手完成整个决策树的构建了，代码如下，同样的，我省略了有些简单函数的代码，只是给出汉语的功能说明。具体详细的决策树代码请参考我的github主页：[Decision_Tree](https://github.com/guoziqingbupt/Decision_Tree)

```python
def isSameClass(data):
    判断data中的数据对象是否属于同一类

def majorityVoting(data):
    多数投票。返回data中，对象数量最多的类


def genDecisionTree(data, attributeList):
    """

    :param data: dataset that contains data objects, is a tuple: (obj_1, ..., obj_n)
    :param attributeList: a list that contains all attributes occurred in data
    :return: the root of decision tree
    """

    root = DecisionTreeNode()

    if isSameClass(data):

        root.tag = data[0]["class"]
        return root

    # majority voting
    if len(attributeList) == 0:

        root.tag = majorityVoting(data)
        return root

    # find the split criterion of root
    root.splitCriterion = selectAttribute(data, attributeList)
    root.isLeaf = False

    # Partitioning the data for several blocks
    # attributeValue_subset: a dictionary, {attributeValue: (data_object_1, data_object_2...)},
    # where data_object_i is also a dictionary: {attribute_1: value, attribute_2: value...}
    attributeValue_subset = dataPartition(data, root.splitCriterion)
    attributeList.remove(root.splitCriterion)

    for attributeValue in attributeValue_subset:

        child = DecisionTreeNode()
        subset = attributeValue_subset[attributeValue]

        if len(subset) == 0:
            child.tag = majorityVoting(data)
        else:
            attributeList_ForThisChild = copy.deepcopy(attributeList)
            child = genDecisionTree(subset, attributeList_ForThisChild)

        # pointers: a dictionary, as form as:
        # {"youth": child_1, "middle_aged": child_2, "senior": child_3}
        root.pointers[attributeValue] = child

    return root
```

以上，就是决策树构建的全过程了，也是ID3算法的实现过程。C4.5算法原理与之类似，不同点在于对最佳分裂属性的选择上。它使用了“增益率”来替代“信息增益”。

有关本文的详细代码请参考我的github：[Decision_Tree](https://github.com/guoziqingbupt/Decision_Tree)](https://so.csdn.net/so/search/s.do?q=数据挖掘&t=blog)](https://so.csdn.net/so/search/s.do?q=机器学习&t=blog)




