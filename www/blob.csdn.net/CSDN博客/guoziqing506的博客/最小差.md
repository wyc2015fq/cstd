# 最小差 - guoziqing506的博客 - CSDN博客





2016年04月27日 09:36:59[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：987
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定两个整数数组（第一个是数组 A，第二个是数组 B），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。

样例：给定数组 A = [3,4,6,7]， B = [2,3,8,9]，返回 0。

还记得之前做过一道“合并排序数组”的问题（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/50949830)）。当时是选用了两个指针，分别指向两个数组，然后按照大小关系，合并数组。这道题求最小差，也可以用这种思路。

我们先将两个数组排序，此处，A和B都是排好的。用两个指针 i 和 j 分别指向这两个数组，初始时，都指向第一个元素，在这个例子里面，一个指3，一个指2. 差值是1

接下来，可以这样思考，既然指向的元素一个大，一个小，那么保持大的元素不变，小的元素向前增加，那就有可能缩减这个差，计算出新的差之后，再和旧的差比较，比旧的差小，则替换旧的差，成为暂时的最小值，直到其中有一个遍历完（因为当有一个遍历完时，再遍历另一个数组，得到的差只能更大）

那就很简单了：



```python
class Solution:
    # @param A, B: Two lists of integer
    # @return: An integer
    def smallestDifference(self, A, B):
        A.sort()
        B.sort()
        i, j = 0, 0
        nA, nB = len(A), len(B)
        min_num = abs(A[0] - B[0])
        while i != nA and j != nB:
            min_num = min(abs(A[i] - B[j]), min_num)
            if A[i] > B[j]:
                j += 1
            else:
                i += 1
        return min_num
        # write your code here
```





