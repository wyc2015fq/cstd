# 最小路径和 - guoziqing506的博客 - CSDN博客





2016年06月12日 17:31:05[guoziqing506](https://me.csdn.net/guoziqing506)阅读数：1133
所属专栏：[LintCode-Python题解](https://blog.csdn.net/column/details/guoziqing-blog.html)









题目描述：给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。

注意事项：你在同一时间只能向下或者向右移动一步




典型的动态规划解决最优化问题。对于这类问题，解决思路可分为以下两步：

1. 找到最优化问题与其子问题之间的关系，也就是写出状态转移方程（比如，我们在“爬楼梯”（详见：[点击打开链接](http://blog.csdn.net/guoziqing506/article/details/51646800)）问题中的f[i] = f[i
 - 1] + f[i - 2]）。

2. 找出一些特殊的边界情况以及递归的“触底”条件。




好了，看问题，状态怎么转移呢？那就是，若想要走到网格的i行，j列，最小路径为走到i - 1行，j列的值（路过的网格的值加和），与走到i行，j - 1列的值，二者的最小值加上网格的i行，j列本身存储的值。

所以，用一个表格record记录走到网格（记为grid）的每个位置的最小路径的话，状态转移方程为：record[i][j] = min(record[i - 1][j] + record[i][j - 1]) + grid[i][j]

然后就需要处理一些边界情况了，比如在这道题当中，record的第一行和第一列的每个值都是由grid[i][j] + record[i - 1][j] 或 grid[i][j] + record[i][j - 1]得到（因为只能往下走或往右走）

给出代码：



```python
class Solution:
    """
    @param grid: a list of lists of integers.
    @return: An integer, minimizes the sum of all numbers along its path
    """

    def minPathSum(self, grid):

        m = len(grid)
        if m == 0:
            return 0
        n = len(grid[0])
        record = [[0 for j in range(n)] for i in range(m)]
        for i in range(m):
            for j in range(n):
                if j == 0 and i == 0:
                    record[i][j] = grid[i][j]
                elif j >= 1 and i >= 1:
                    record[i][j] = min(record[i][j - 1], record[i - 1][j]) + grid[i][j]
                elif j >= 1:
                    record[i][j] = record[i][j - 1] + grid[i][j]
                else:
                    record[i][j] = record[i - 1][j] + grid[i][j]
        return record[m - 1][n - 1]
        # write your code here
```





