# 当今世界最为经典的十大算法--投票进行时 - 结构之法 算法之道 - CSDN博客





2011年03月07日 10:03:00[v_JULY_v](https://me.csdn.net/v_JULY_v)阅读数：91925








**当今世界最为经典的十大算法--投票进行时**



作者：July、
时间：二零一一年三月七日。
参考：[**十三个经典算法研究与总结、目录+索引**](http://blog.csdn.net/v_JULY_v/archive/2011/04/06/6305212.aspx)，本人第一大原创作品。

内容说明：
I、 本文原名为：***当今世界最受人们重视的十大经典算法***，后改为如上题目。
II、本文分为俩部分：
    第一部分、来自圣经的十大算法：为某网友票选出来的十个来自圣经的算法。
    第二部分、当今世界最为经典的十大算法--投票进行时：是恳请**本文的读者为您心目中当今世界最为经典的算法投上一票**，最终在本BLOG内票选产生当今世界最为经典的十大算法（投票截止日期，三年后的此刻，即二零一四年三月七日）。非常感谢大家。
----------------------------------------





**第一部分、来自圣经的十大算法**

    当今世界，已经被发现或创造的经典算法数不胜数。如果，一定要投票选出你最看重的十大算法，你会作何选择列?有国外网友在StackExchange上发起过投票，让人们投票选出心目中最为经典的算法，最终产生了下面得票数最高的十大经典算法（投票数统计截止到2011年3月7日）：

第十名：Huffman coding（霍夫曼编码）
    霍夫曼编码(Huffman Coding)是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）算法。1952年，David A. Huffman在麻省理工攻读博士时所发明的，并发表于《一种构建极小多余编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）一文。


**第九名：Binary Search （二分查找）**    在一个有序的集合中查找元素，可以使用二分查找算法，也叫二分搜索。二分查找算法先比较位于集合中间位置的元素与键的大小，有三种情况（假设集合是从小到大排列的）：
    1.键小于中间位置的元素，则匹配元素必在左边（如果有的话），于是对左边的区域应用二分搜索。
    2.键等于中间位置的元素，所以元素找到。
    3.键大于中间位置的元素，则匹配元素必在右边（如果有的话），于是对右边的区域应用二分搜索。
另外，当集合为空，则代表找不到。


第八名：Miller-Rabin作的类似的试验测试
    这个想法是利用素数的性质(如使用费马大定理)的小概率寻找见证不数素数。如果没有证据是足够的随机检验后发现,这一数字为素数。


**第七名：Depth First Search、Breadth First Search**（深度、广度优先搜索）
    它们是许多其他算法的基础。关于深度、广度优先搜索算法的具体介绍，请参考此文：[**教你通透彻底理解：BFS和DFS优先搜索算法**](http://blog.csdn.net/v_JULY_v/archive/2011/01/01/6111353.aspx)。


第六名：Gentry's Fully Homomorphic Encryption Scheme（绅士完全同态加密机制）算法。
    此算法很漂亮，它允许第三方执行任意加密数据运算得不到私钥（不是很了解）。


第五名：Floyd-Warshall all-pairs最短路径算法
    关于此算法的介绍，可参考我写的此文：几个最短路径算法比较（[http://blog.csdn.net/v_JULY_v/archive/2011/02/12/6181485.aspx](http://blog.csdn.net/v_JULY_v/archive/2011/02/12/6181485.aspx)）。
d[]: 二维数组. d[i,j]最小花费、或最短路径的邻边。

for k from 1 to n:
  for i from 1 to n:
    for j from 1 to n:
      d[i,j] = min(d[i,j], d[i,k] + d[k,j])



**第四名：Quicksort（快速排序）**    快速排序算法几乎涵盖了所有经典算法的所有榜单。它曾获选二十世纪最伟大的十大算法（参考这：[细数二十世纪最伟大的10大算法](http://blog.csdn.net/v_JULY_v/archive/2011/01/10/6127953.aspx)）。关于快速排序算法的具体介绍，请参考我写的这篇文章：[**一之续、快速排序算法的深入分析**](http://blog.csdn.net/v_JULY_v/archive/2011/02/27/6211155.aspx)，及[**十二、一之再续：快速排序算法之所有版本的c/c++实现**](http://blog.csdn.net/v_JULY_v/archive/2011/03/20/6262915.aspx)。


第三名：BFPRT 算法
    1973 年，Blum、Floyd、Pratt、Rivest、Tarjan一起发布了一篇名为 “Time bounds for selection” 的论文，给出了一种在数组中选出第k大元素平均复杂度为O（N）的算法，俗称"中位数之中位数算法"。这个算法依靠一种精心设计的 pivot 选取方法，即选取中位数的中位数作为枢纽元，从而保证了在最情况下的也能做到线性时间的复杂度，打败了平均O（N*logN）、最坏 O(n^2) 复杂度的快速排序算法。

    事实上，这个所谓的BFPRT，就是本blog中阐述过的快速选择SELECT算法，详情请参考下列博文：[**第三章、寻找最小的k个数**](http://blog.csdn.net/v_JULY_v/archive/2011/04/28/6370650.aspx)、[**十四、快速选择SELECT算法的深入分析与实现**](http://blog.csdn.net/v_JULY_v/archive/2011/05/19/6431001.aspx)。在我的这两篇文章中，给出了此快速选择SELECT算法，借助选取数组中中位数的中位数作为枢纽元，能做到最坏情况下运行时间为O（N）的复杂度的证明。

    我在这里简单介绍下在数组中选出第k大元素的时间复杂度为O（N）的算法：
    类似快排中的分割算法：

每次分割后都能返回枢纽点在数组中的位置s,然后比较s与k的大小
若大的话，则再次递归划分array[s..n]，
小的话，就递归array[left...s-1] //s为中间枢纽点元素。
否则返回array[s]，就是partition中返回的值。 //就是要找到这个s。

找到符合要求的s值后，再遍历输出比s小的那一边的元素。

    各位还可参考在：算法导论上，第九章中，以期望线性时间做选择，有寻找数组中第k小的元素的，平均时间复杂度为O（N）的证明。原程序随机选取数组中某一元素作为枢纽元，最后可证得程序的期望运行时间为O(n)，且假定元素是不同的。


**第二名：Knuth-Morris-Pratt字符串匹配算法**    关于此算法的介绍，请参考此文：[**六、教你从头到尾彻底理解KMP算**](http://blog.csdn.net/v_JULY_v/archive/2011/01/01/6111565.aspx)**法**。KMP算法曾经落选于二十世纪最伟大的十大算法，但人们显然不能接受，如此漂亮、高效的KMP算法竟然会落选。所以，此次最终投票产出生，KMP算法排到了第二名。


第一名：Union-find

并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。集就是让每个元素构成一个单元素的集合，并就是按一定顺序将属于同一组的元素所在的集合合并。并行查找，最终占据了此份榜单的第一名。

    补充：前三名的投票数，只相差4票，8票。所以这个排名日后还会不断有所变化。但不管最终结果怎样，这前十名的算法已经基本敲定了。
***原投票网址***：[**http://cstheory.stackexchange.com/questions/189/algorithms-from-the-book**](http://cstheory.stackexchange.com/questions/189/algorithms-from-the-book)。





**第二部分、当今世界最为经典的十大算法--投票进行时**
    怎么样，上文那些投票产生出来的来自圣经的算法，你是否熟悉?或者，如果要您选出您心目中，当今世界最为经典的十大算法，您肯定也、绝对不一定认同上述十个所谓来自圣经的算法便是当今世界最为经典的十大算法，对吧?ok，那么，现在，我给你一个投票权，你会把票投给哪一个算法列?好的，咱们也来一次投票吧，请把你的意见，决定权写在本文下面的评论里。

    我把已经产生的前十名的算法，再写在下面，方便投票（**投票截止日期：三**年后的今天，即**二零一四年三月七日**）：

**一**、Huffman coding（霍夫曼编码）。
**二**、Binary Search （二分查找）。
**三**、Miller-Rabin作的类似的试验测试。
**四**、Depth First Search（深度优先搜索）。
**五**、绅士完全同态加密机制
**六**、Floyd-Warshall all-pairs最短路径算法。
**七**、Quicksort（快速排序）。
**八**、BFPRT 算法。
**九**、Knuth-Morris-Pratt字符串匹配算法。
**十**、Union-find。

为了让大家有更多的选择，我再贴出其它几种同样经典但暂时未能排进上述榜单前十名的候选算法：

十一、Cooley-Tukey **FFT**算法。快速傅里叶变换算法。关于傅里叶变换算法的介绍，请参考此文：[**十、从头到尾彻底理解傅里叶变换算法、上**](http://blog.csdn.net/v_JULY_v/archive/2011/02/20/6196862.aspx)，及[**十、从头到尾彻底理解傅里叶变换算法、下**](http://blog.csdn.net/v_JULY_v/archive/2011/02/22/6200945.aspx)。

**十二**、**linear programming**，线性规划。

**十三**、**Dijkstra **算法。与上第五一样，又一种最短路径算法。具体介绍，请参考：[**二之续、彻底理解Dijkstra算法**](http://blog.csdn.net/v_JULY_v/archive/2011/02/13/6182419.aspx)，和[**二之再续、Dijkstra 算法+fibonacci堆的逐步c实现**](http://blog.csdn.net/v_JULY_v/archive/2011/03/18/6259576.aspx)，及[**二之三续、Dijkstra 算法+Heap堆的完整c实现源码**](http://blog.csdn.net/v_JULY_v/archive/2011/03/24/6274836.aspx)**。**

**十四**、**Merge Sort**。归并排序。
**十五**、**Ford–Fulkerson**算法。网络最大流算法。
**十六**、**辗转相除法**。
      在数学中，辗转相除法，又称欧几里得算法，是求最大公约数的算法，即求两个正整数之最大公因子的算法。此算法作为TAOCP第一个算法被阐述，足见此算法被重视的程度。它是已知最古老的算法, 其可追溯至3000年前。辗转相除法首次出现于欧几里得的《几何原本》（第VII卷，命题i和ii）中，而在中国则可以追溯至东汉出现的《九章算术》。扩展的辗转相除法则构造性地证明了，对任意整数a和b ，存在一对x、y使得 ax + by = gcd(a, b) 。

**十七**、**RSA加密演算法**。一种加密算法，日后再做详细介绍。
**十八**、**遗传算法**。可参考本人写的关于GA 算法的这篇文章：[**七、遗传算法 透析GA本质**](http://blog.csdn.net/v_JULY_v/archive/2011/01/12/6132775.aspx)。

**十九**、**最大期望（EM）算法**。
    此算法入选[**数据挖掘领域十大经典算法**](http://blog.csdn.net/v_JULY_v/archive/2011/01/15/6142146.aspx)。在统计计算中，最大期望（EM）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variable）。最大期望经常用在机器学习和计算机视觉的数据聚类（Data Clustering）领域。最大期望算法经过两个步骤交替进行计算，第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；第二步是最大化（M），最大化在 E 步上求得的最大似然值来计算参数的值。M 步上找到的参数估计值被用于下一个 E 步计算中，这个过程不断交替进行。

**二十、数据压缩**    数据压缩是通过减少计算机中所存储数据或者通信传播中数据的冗余度，达到增大数据密度，最终使数据的存储空间减少的技术。数据压缩在文件存储和分布式系统领域有着十分广泛的应用。数据压缩也代表着尺寸媒介容量的增大和网络带宽的扩展。

**二十一、Hash函数**    Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。关于hash表的详细阐述，请参考此篇文章：[**十一、从头到尾彻底解析Hash表**](http://blog.csdn.net/v_JULY_v/archive/2011/03/17/6256463.aspx)**算法**。

**二十二、Dynamic Programming**（动态规划）。关于动态规划的粗略介绍，请参考此文：[**三、dynamic programming**](http://blog.csdn.net/v_JULY_v/archive/2010/12/31/6110269.aspx)。

**二十三、堆排序算法**。
    堆排序算法作为一种快速稳定的算法，其平均时间复杂度（最坏也为）O（n*lgn）。当然，在实际应用中，一个实现的好的快速排序算法仍然要优于堆排序算法。不过，堆数据结构还可以作为高效的优先级队列。对堆排序算法作简单了解，可参考这：[**堆排序算法**](http://blog.csdn.net/v_JULY_v/archive/2011/02/21/6198644.aspx)。

**二十四**、**递归与回溯算法**。此俩个算法，相信各位比较熟悉，在此不做赘述。   

**二十五**、**最长公共子序列**    最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个数列 S ，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
动态规划的一个计算最长公共子序列的方法如下：
    以两个序列 X、Y 为例子：
设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：

      f[1][1] = same(1,1)
      f[i][j] = max{f[i-1][j-1]+same(i,j)，f[i-1][j]，f[i][j-1]}

    其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。
此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。

    该算法的空间、时间复杂度均为O(n2)，经过优化后，空间复杂度可为O(n)，时间复杂度为O(nlogn)。更多详情，参见之前写的一篇拙文（不过，鉴于写的糟，日后会重写）：[**三、dynamic programming**](http://blog.csdn.net/v_JULY_v/archive/2010/12/31/6110269.aspx)。

**二十六、红黑树的算法与实现**    关于红黑树，linux内核中有实现，本BLOG内也已经写了6篇红黑树系列的文章。且，本BLOG内的此红黑树系列，总计六篇文章，是整个国内有史以来有关红黑树的最具代表性，最具完整性，最具参考价值的资料。详情，请参考：[**五（续）、教你透彻了解红黑树**](http://blog.csdn.net/v_JULY_v/archive/2010/12/29/6105630.aspx)，及[**红黑树的c++完整实现源码**](http://blog.csdn.net/v_JULY_v/archive/2011/03/29/6285620.aspx)。

**二十七、A*搜寻算法**。
    相对于BFS、Dijkstra 等算法，A*搜寻算法作为一种高效的最短路径搜索算法，如今，已得到日益广泛的应用。初步了解A*搜寻算法的高效及与其它最短路径算法的比较，请参考此文：[**一（续）、A*，Dijkstra，BFS算法性能比较及A*算法的应用**](http://blog.csdn.net/v_JULY_v/archive/2011/03/10/6238029.aspx)。

**二十八、图像特征提取与匹配之SIFT算法**    sift，尺度不变特征转换，是一种电脑视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由 David Lowe 在1999年所发表，2004年完善总结。关于此算法，请参考如下，粗略介绍：[**九、图像特征提取与匹配之SIFT算**](http://blog.csdn.net/v_JULY_v/archive/2011/02/15/6186942.aspx)**法**，利用第三方库编译过程：[**九（续）、sift算法的编译与实现**](http://blog.csdn.net/v_JULY_v/archive/2011/03/05/6225117.aspx)，c语言一步一步实现sift算法：[**九之再续：一步一步用c语言实现sift算法、上**](http://blog.csdn.net/v_JULY_v/archive/2011/03/13/6245939.aspx)**，**及[**九之再续：教你一步一步用c语言实现sift算法、下**](http://blog.csdn.net/v_JULY_v/archive/2011/03/13/6246213.aspx)。

候选经典算法一直在不断增补中，估计最后能达到上100种。...

     还犹豫什么列?快投上您宝贵的一票吧。**每人可投多次票，只要您认为哪个算法是最为经典的算法，您就在下面的评论里写上它的序号，及算法名称。**    当然，如果上文中不曾出现你认为最经典的算法，你也可以写在评论里，为你钟爱的它投上一票。而后我将考虑您的意见，把您钟爱的算法也作为一种候选算法，添补上去。:D。

最后，我们自己来做一份十大经典算法的排名榜单，也让世界各地的人看看我们中国人的意见。怎么样，还犹豫什么列，赶紧评论、赶紧投票吧...
    更新：
- 由于诸多事情，未能抽空给各位投了票的朋友传送本博客全部博文集锦的文件，若各位等不及日后待我一一传送的话，还望各位移步至本人的资源下载处：[**http://v_july_v.download.csdn.net/**](/)，下载。那里有本博客所有任何一期的博文集锦文件。见谅，多谢。 July、二零一一年十月二十四日凌晨。
- 本blog最新博文集锦第7期CHM文件免积分下载：[](http://d.download.csdn.net/detail/v_july_v/4020172)[http://download.csdn.net/detail/v_july_v/4463100](http://download.csdn.net/detail/v_july_v/4463100)。July、二零一二年一月十八日。





**本BLOG版权声明、即日生效**：
**1、**本人和CSDN对本BLOG内所有任何一切内容和文章，享有版权。如需转载，请注明出处及作者本人。 
**2、**凡是转载本BLOG内任何文章和内容的个人，或网站，一律不注明出处者，本人将**永久追踪、永久谴责、永久追究法律责任的一切权利。**谢谢。July、二零一一年三月七日，即日起生效。



