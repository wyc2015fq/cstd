# 公交车线路查询系统 - 逍遥剑客 - CSDN博客
2006年12月01日 00:44:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：8441
内容：
经过站
1路汽车：a,b,c,d..........
2路汽车：e,f,c,g.........
则从a-g需要在c站换车
怎么算？
＄a = array('a','b','c','d');
＄b = array('e','f','c','g');
print_r(array_intersect(＄a, ＄b));
数据库中保存每个线路经过的站名
检索出包含起点或终点的所有线路
则同时包含起点和终点的线路不需换乘
否则逐一检查两线路的交集
若还未找到，则沿经过起点的线路和经过终点的线路检查线路相交情况
一般城市都成承诺换乘次数小于等于3。所以计算到这里也就足够了
还可以一次性计算出任意两站间的换乘情况，将结果保存到库中。以后直接检索就行了
其实不用什么复杂的算法，只用SQL就可以完成了。可能你会担心效率问题，但是可以提前把结果计算出来存到数据库当中，甚至生成静态页面直接调用，这样速度比再好的算法也要快！呵呵
下面是从网上找来的例子:
-------------------------------------------------------------------
简单的东西，我不考虑怎么弄个好算法了，只是解决一下问题，能够得出结果即可： 
三个表（最简单化，不考虑模糊查询，单行线等其他东西）： 
1，站点表 stop(stop_id,stop_name) 
2，路线表 line(line_id,line_name) 
3，路线站点表 linestops( line_id, stop_id, seq ) 此处的seq指某站点在某线路中的顺序。 
现在分析算法： 
1，直达。 
首先根据两个站点名获取两个站点各自的id，这里定义为id1,id2 
然后查询 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)select line_id from
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(select line_id from linestops where stop_id = id1) A, 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(select line_id from linestops where stop_id = id2) B 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)where A.line_id = B.line_id 
即得到科直达的线路列表 
2,一次换乘 
首先根据两个站点名获取两个站点各自的id，这里定义为id1,id2 
然后搜寻两个站点通过直达方式各自能够到达的站点集合，最后他们的交集就是我们所需要的换乘站点。 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)select stop_id from
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)( 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id1) 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif))A, 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)( 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id1) 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif))B 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)where A.stop_id = B.stop_id 
 得到换乘站（可能有多个或0个）后，剩下的就是显示能够到达换乘站的两边线路，这通过前面的直达查询即可。 
3，二次换乘 
首先根据两个站点名获取两个站点各自的id，这里定义为id1,id2 
算法的中心思想是：站点1能够通过直达到达的所有站点集合A，站点2能够通过直达到达的所有站点集合B，A和B之间有直达的线路。 
一步一步来： 
站点1能够通过直达到达的所有站点集合A： 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id1) 
站点2能够通过直达到达的所有站点集合B： 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id2)
而直达的查询是 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)select line_id from
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(select line_id from linestops where stop_id = id1) C, 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(select line_id from linestops where stop_id = id2) D 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)where C.line_id = D.line_id 
我们把=id1和=id2换成 in (select ....)A 和 in (select ...)B 
这样最后我们的查询是 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)select line_id from
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(selectdistinct line_id from linestops where stop_id in 【A】) C, 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(selectdistinct line_id from linestops where stop_id in 【B】) D 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)where C.line_id = D.line_id 
其中【A】是 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)（selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id1))
 其中【B】是 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)（selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id2)) 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)
这样子我们找到了作为中间换乘的线路（可能有多条或者0条），对列举的的每一条假设命名为X线，下一步就是找出可以从站点1到达X任意一个站点的直达线路、和可以从站点2到达X任意一个站点的直达线路即可。 
那么与前面的算法相似，我们在站点1所有能够到达的站点中去寻找和线路X相交的站点，然后再去找这两个点的线路 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)select stop_id from
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(selectdistinct stop_id from linestops where line_id in
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif) (select line_id from linestops where stop_id = id1))A, 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)(select stop_id from linestops where line_id = X ) B 
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)where A.stop_id = B.stop_id
 找到站点了，下面就是根据已经解决的直达查询找线路了。 
站点2类似。 
关于直达车，我是把整条线路存入一个字段，然后
![](http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif)SELECT*FROM Line WHERE (UpStops LIKE'%'+@StopName+'%') OR  (DownStops LIKE'%'+@StopName+'%')
虽然有点XX，不过当时我数据库还没有把站点分离出来，是后来自己写了一个程序把这100多条线路分成Stop和LineStop表的，最后一看，妈啊，1000多个站点。幸亏当初脑子没发热，手工输入数据库            
