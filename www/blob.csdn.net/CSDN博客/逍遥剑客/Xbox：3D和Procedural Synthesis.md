# Xbox：3D和Procedural Synthesis - 逍遥剑客 - CSDN博客
2008年12月29日 09:16:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：1672标签：[游戏																[微软																[工作																[360																[ibm																[存储](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=ibm&t=blog)](https://so.csdn.net/so/search/s.do?q=360&t=blog)](https://so.csdn.net/so/search/s.do?q=工作&t=blog)](https://so.csdn.net/so/search/s.do?q=微软&t=blog)](https://so.csdn.net/so/search/s.do?q=游戏&t=blog)
个人分类：[图形技术](https://blog.csdn.net/xoyojank/article/category/337624)
2005-07-25 19:03 作者： 包涵 出处： 天极网 责任编辑：>寒冬
**前言：**
　　数年以前，当微软宣布要进入家用游戏机领域后，曾有无数的观察家对此持怀疑态度。不过XBOX却取得了成功，在全世界销售量仅次于PS2，名列第二。到底是什么法宝能够让“初入江湖”的微软快速崭露头角？后来大多数分析家都认为，微软为XBOX游戏开发人员制定了一套行之有效的快速开发体系。这套体系不仅能够缩短游戏开发时间，而且还能够减轻程序员的工作负担，从而让厂商和玩家都得到实惠。由此可见，微软在软件开发领域的雄厚实力，的确不是索尼能够企及的。
　　而新一轮的主机大战即将拉开序幕，Xbox 360和PS3的处理器都是采用IBM所提供的PowerPC Element（后文简称PPE），作为多核心处理器。显然在两款主机架构相似的情况下，微软要再次利用它娴熟的软件开发能力，来提升Xbox 360在游戏开发厂商中的竞争力。那么微软又会为这款配备了三核心处理器，1MB L2缓存，深度管线，并缺乏指令窗口的主机带来什么样的特殊技术呢？
**3D世界—实际开发中遇到的难题**
　　在3D游戏中，会使用到大量的3D动态场景，比如说：一个角色模型或者是一些诸如树木、地形、建筑等环境对象。通常这些模型都是由游戏美工来手绘出，然后再由多边形来填充而成。而这些模型本身在计算机内存中，则用一系列的顶点数据来表示。一旦计算机在游戏中开始实时的渲染场景，模型就会按照主内存中所存储的顶点数据所描述的那样，被显示在屏幕上。如果是在传统的桌面电脑上，此过程中，顶点数据将会从主内存传输到GPU中，在那里3D影像被渲染，然后用连续帧输出到显示器上。
![8a3737mp80g2.jpg](http://myhard.yesky.com/imagelist/05/07/8a3737mp80g2.jpg)
**用传统方法渲染迎风的树木**
　　在游戏中，每一个我们所能够看到的对象，都必须是先由游戏美工手绘出来，再经过上述过程得以实现。光点，树木，小山，河流，这些场景的构建需要花费大量的时间和金钱，才能够为每一位玩家呈现出广大的，丰富的，逼真的3D世界。不过碍于预算有限，人手不足等原因所致，我们很容易发现，3D世界中的很多物体都是一模一样的。比如说一大片森林，其实仅仅是由少数几棵树的模型所复制而成。这在很大程度上影响了游戏场景的真实性，给人的整体感觉打了不小的折扣。
　　那么既要创建规模巨大，对象丰富，场景细腻，现实逼真的3D场景，又要让场景中的每一个对象都彼此不同。很多人直接想到的就是，增加游戏开发预算，雇佣更多的游戏美工，不过仔细分析，这样做似乎也有不妥之处。首先太过于精细的场景，会导致数据文件体积扩展，如果一款游戏需要10GB的空间来存放游戏资料，这显然是很多玩家所不愿意的吧。接下来是投入产出比率，开发商想要盈利，就要将开发预算控制到一个能够承受的范围内，而且现在的游戏开发预算已经高达2000万美元，几乎和某些电影制作成本相当。因此投入过多，会造成入不敷出，血本无归的局面。
　　即使抛开这一切，单从技术的角度来探讨这个问题，其实也会遇到诸多障碍。就算让美工手绘出10000棵树所构成的森林，但这势必会产生大量的顶点数据，在游戏运行而进行的实时渲染，需要将所有的顶点数据都放在主内存中，然后传输到GPU里进行处理。在传输的过程中，会占用大量的总线带宽，那么主内存的容量和总线带宽的大小就成为新的限制因素。再加上游戏开发的过程中，美工和程序员的工作比重失调，从而延迟了游戏开发的速度。为了让美工和程序员的工作比重更加趋于合理，开发过程需要作出一些调整，将一部分美工的工作，转嫁到程序员身上，然后再转嫁到底层硬件上，从而让更多的工作由硬件自己来完成，这就是Xbox 360中改革的重点。
**解决方案—Procedural Synthesis粉墨登场**
　　其实早在2003年末，微软的一些相关技术开发人员在接受访问的时候，就曾经透露过这个技术的一些细节。不过直到最近，这项将被运用到Xbox 360中的重要技术才被微软公开确认。Procedural Synthesis，从字面意思来翻译就是：程序化合成（后文简称：PS）。它的主要功能也尽在这5字的包括之内，PS的目标是将有限的系统总线带宽尽可能的利用地更有效率，同时降低美工和程序员的工作量，让一部分工作由处理器自己来完成，解决现阶段3D游戏开发中所遇到的困难。正如我们上文中所提到的一些，开发中可能会遇到的困难，而PS的出现也正是为了解决这些问题。
**　　“压缩”数据，让系统总线带宽更有效率：**在Xbox 360中，放入主内存的将不再是顶点数据，而是对对象的详细描述，然后CPU再依据这个描述自动产生出对象的几何模型（如：顶点数据）。因此回到上文中构建森林的例子中，主内存中存储的仅是关于树本身的种类，大小，每一片叶子的位置和风向的描述，然后通过系统总线，将这些描述信息传送到Xenon中，用一个或多个线程依照描述信息自动生成多边形的顶点数据。
　　注意了，在Xbox 360中，顶点数据是由处理器内部自己生成的，它没有放入主内存中，也就不会占用系统总线带宽。而描述信息和顶点数据相比，前者只是某种指定格式的文字描述，而不是包含有几何运算的顶点数据，因此体积要小很多。处理器将线程所生成的顶点数据放入L2缓存中，再通过CPU和GPU之间的总线通道，供GPU随时使用。由于CPU和GPU之间的带宽要比系统总线大的多，因此大量的顶点数据能够被流畅的传输。
![a6914i74z9se.jpg](http://myhard.yesky.com/imagelist/05/07/a6914i74z9se.jpg)
**在Xbox 360中渲染迎风树木**
　　微软将放在主内存中的描述信息的大小和处理器自动生成的顶点数据的大小的比值，称之为顶点数据的压缩率。因此可以将放在主内存中的场景描述信息看作是被“压缩”了的顶点数据，而GPU所渲染的场景数据，则是已经由处理器“解压”之后的顶点数据。由于要在下一代的游戏中，提供更加逼真的画面，其几何对象就会数倍增加。
　　按照传统的方式，将所有的几何对象资料都放置在主内存中，那么在游戏中进行实时渲染时，就会让系统总线带宽难堪重负，从而影响到游戏的流畅度。同时PS技术中所需要游戏美工所绘制的图形大大减少，取而代之的是撰写对对象特征的详细描述文件，这将极大的减少美工的工作量。
　　撰写后的描述信息被发送到处理器中，再由处理器自动生成几何模型，这一过程是不需要程序员来进行干预的。因此PS在Xbox 360中的运用，其意义并不局限于解决系统瓶颈一点上，更多的则是对开发过程和处理方式所做出的进一步改革。
**　　Real-time tessellation（实时棋盘式镶嵌）**：我们在游戏中所看到的是3D模型的表面，而不是其内部。模型的表面可以用高阶曲线来描述，如b-splines，bezier curves等等。不过GPU却不能够直接渲染曲线，只能够处理顶点数据，因此需要使用近似圆的多边形来代替圆曲线。多边形的边数越多，那么就越接近一个平滑的圆。同样用网状将高阶曲面分割成很小的平滑表面，这一过程称之为棋盘式镶嵌。和下图中，多边形近似表示圆的道理相同。对高阶曲面采用镶嵌所分割出来的平滑表面越多，那么就越接近一个平滑的曲面。
![wzsejkqhgbcl.jpg](http://myhard.yesky.com/imagelist/05/07/wzsejkqhgbcl.jpg)
　　要想在游戏中表现出平滑的表面，主要有两种方法：第一种方法是增加构成此模型的多边形数量，多边形的数量越多效果越好；另一种方法就是采用镶嵌高阶曲面，两者都有其优缺点。第一种方法其实生成的平滑曲面效果更好，不过这需要填充和渲染大量的多边形，多边形又要产生大量的顶点数据，占用大量的内存空间和总线带宽。
　　而镶嵌高阶曲面只产生一个顶点列表，这个顶点列表占用的空间相对较少，将列表发送到Xbox 360的处理器中，处理器会自动根据顶点列表来产生出几何模型，是前面所说的PS技术的另外一个方面的应用。虽然最终效果赶不上增加多边形数量来得好，但是却节约了大量的系统总线带宽和主内存容量。
![943ihdopcr59.jpg](http://myhard.yesky.com/imagelist/05/07/943ihdopcr59.jpg)
　　实时镶嵌高阶曲线的第二个好处在于，能够让程序员控制模型的细节程度。通过动态的调整镶嵌所分割出的区域数量，可以减少或增加被渲染的多边形个数。当3D模型在场景的远端，可以采用减少渲染多边形数量，降低对象的细节程度来达到加快场景渲染速度的效果。如对象被拉近放大，增加渲染的多边形数量，也可以使对象表现的更为精细。根据景深不同来控制场景的细节程度，可以减轻GPU的负担。
**　　Real-time skinning：**在3D游戏中，通常角色模型会有一些预先设定好的一系列的动作，比如说：跑、跳、走、停等等。传统的做法是，游戏美工使用标准运动捕捉工具或3D渲染工具，来为角色模型自动生成一系列的关键姿势，一旦这些关键姿势连贯起来播放，就产生了角色的动作变化。一般来说，第一个关键姿势和最后一个关键姿势之间，插入越多的新姿势结点，那么人物的动作就会越平滑自然。不过所有的关键姿势都将放置到系统内存中，如果关键姿势太多了，势必将占用大量的内存容量和总线带宽。解决的办法同样是运用PS技术。
　　Xenon将关键姿势放在系统内存中，不过不是全部，仅仅是首尾两个姿势。然后通过PS来自动在首尾姿势之间，插入新姿势的代码，直到整个角色的动作看起来自然为止。听起来和Flash制作有点相似，指定关键帧就能够自动生成动画。而且运用PS技术，只使用了少量的总线带宽，同时降低了美工的工作量。
**procedural synthesis的运行原理**
　　Xbox 360的Xenon处理器由三个一模一样的PowerPC核心所组成，三个核心之间共享一个1MB的L2缓存。每一个核心都是一个处理单元，具备一个64KB的L1缓存（32KB指令/32KB数据）。由于采用了SMT技术，因此每一个核心能够同步执行两个线程，这也意味着Xenon可以同步执行最多6个线程。当然不是所有的线程都用来自动生成顶点数据或代码，微软将线程分为两个部分：
**·主线程**
　　游戏的主线程包括游戏的执行线程，这个线程能够处理游戏3D引擎，并控制数据产生线程。
**·数据产生线程**
　　自动为对象产生各种几何数据的动作，其实就是该线程来处理。这个线程为游戏中需要显示的对象输出顶点列表，同时传送到GPU中。
![306pqyx1xm54.jpg](http://myhard.yesky.com/imagelist/05/07/306pqyx1xm54.jpg)
**Xenon处理器**
　　其中主线程是唯一的，而数据产生线程的数量可以有多个。这两个级别的线程既可以运行在相同的PPE上，也可以在不同的PPE上分开运行。除此之外，Xenon剩下的线程则用来处理物理运算，人工智能和玩家输入等等。数据产生线程是Xbox 360中PS技术的核心部分。在前文中提到，放在内存中的是“压缩”过的对象描述信息，经过PPE“解压”，生成体积巨大的几何数据，两者的比为压缩率，不过这个压缩率是可变的。其中有一个暗尺度来限制这个压缩率，这个尺度是系统带宽和GPU渲染速度之间取得的平衡点。如果压缩率过大，则解压处理的时间增长，显卡渲染的速度快于处理器解压的速度，GPU资源会部分闲置；如果压缩率过小，则系统带宽会被占用过大，达不到节省系统带宽的目的。
另外数据产生线程所产生的顶点列表输出有两种可能。第一种是，当产生的顶点列表，GPU不会马上用到。则将其放置在主内存中，等GPU以后调用；第二种更为普遍的情况则是，直接将顶点数据放置到L2缓存中，供GPU随时调用。很明显，这里有另外一个问题浮现出来……
**Xenon的缓存特点—供求关系和缓冲器的使用**
　　按照传统的实时渲染应用，主内存和GPU之间是供求关系：主内存产生顶点数据，而GPU来执行它。在Xbox 360里，主内存换成了CPU，它和GPU还是供求关系。既然是这种关系，就有可能会发生：供大于求或求大于供的两种情况。其实仔细分析，不难看出，处理器的运算速度远远超过了GPU的渲染能力，因此最有可能发生的情况是供大于求。
　　当数据产生线程超速产生的顶点数据，这个数据为了要等待GPU的处理，首先要将数据临时存放到一个地方，这个地方就是Xenon的L2缓存。当一个新的顶点数据被写入L2缓存中，缓存会首先认为这个顶点数据可能马上就会被用到，因而将它存放在一块区域中。其实缓存没有办法知道，这个顶点数据到底什么时候才被GPU处理，所以只能够将它存储起来。循环往复，当数据产生线程不断的，持续输出顶点数据流的时候，1MB的L2缓存空间很快就会被填满。由于L2本身是由6个线程所共享的，那么其它线程的相关数据就会被挤出缓存，造成主线程性能降低。
　　在处理器和主内存之间，通常会使用L1和L2高速缓存来降低CPU等待代码和数据的时间。数据从内存传到不同级别缓存中这一过程很复杂，而且程序员不能够控制，全部由底层硬件完成，确保所有的信息都能够被存储和复制到正确的位置。因此传统“缓存”所具备的特点，概括起来就是两点：1、位于处理器附近的临时信息存放点；2、缓存由CPU自行管理，程序员无法干预。不过为了解决上文中所提到的问题，Xbox 360赋予了程序员操作L2缓存的能力，微软将这种专门的操作叫做“锁定”。
![6290casd1ne9.jpg](http://myhard.yesky.com/imagelist/05/07/6290casd1ne9.jpg)
**采用“锁定”方式划分L2缓存模型图**
　　由于Xenon的L2是多路结合性缓存，因此程序员可以采用“锁定”方式，从整个L2缓存中，划出一部分被锁定的空间来放置写入流模式线程所写入的信息。线程不断的将产生的顶点数据输出到这个被划出锁定的缓冲器里面，缓冲器则作为一个先入先出队列，来存放指定线程的写入资料。GPU采用DMA协议，从缓存中读取顶点数据。因此FIFO（先入先出）队列就如同数据产生线程向GPU输送顶点数据的管道。在锁定区域中，数据不会溢出，不会影响到其他线程的数据安全。
　　在Xenon的L2缓存中，可以有任意多个FIFO队列和锁定区域。每一个锁定区域都对应着一个单独的数据产生线程。没有锁定的L2和普通的L2缓存没有区别，非写入流模式的线程能够正常的利用到锁定的L2缓存的其他部分。一个写入流模式的数据产生线程，除了访问自己专有的锁定区域外，也可以像其他线程一样，访问没有被锁定的其他部分。
　　不过为了确保其他线程的正常运行，写入流线程不允许占用太多的非锁定区域。划分锁定区域，将其作为一个FIFO队列是Xenon L2缓存的最大特点，而且划分的锁定区域可以视需求而动态调配，在保证缓存中其他数据的安全方面，有着不可替代的作用。
　　虽然说这项技术是微软的最新专利，不过IBM已经将相似的技术应用到了任天堂的Camecube主机的Gekko处理器中，在这款处理器中，能够锁定一半的L1缓存容量（32KB，8路结合性），避免L1中数据发生溢出，影响到其他数据的安全。在锁定区域中的数据，能够绕过L2缓存，直接通过Gekko的总线，传输到内存中。当然，由于Gekko是基于单线程和单处理器设计，因此L1缓存锁定体系看起来并没有Xenon那样复杂，不过道理都是相同的。
　　除了有写入流模式之外，还有读取流模式。两者原理都相近，读取流模式的线程，能够绕过L2缓存，直接通过系统总线读取L1缓存和寄存器中的数据。换句话说，就是程序员有两种选择：1、绕开L2，直接读取L1中的数据；2、绕开整个缓存，直接读取寄存器中的数据。总而言之，读取流模式和写入流模式的结合，赋予了程序员一种前所未有的能力，来全面控制Xenon中的缓存级别。也就是说，程序员只要将读/写流模式和数据预取指令适当的结合，就可以充分开发出内存总线的全部潜力。
**总结：**
　　通过上文的介绍，很显然Xbox 360的新技术Procedural Synthesis给人很多想象的空间。这项技术会对第一波到来的游戏产生什么样的影响？处理器在实时运算中，生成的多边形数量又有多少？或许现在回答这些问题还显得言之过早。不过至少这项技术让人们看到了微软对于游戏开发过程的关注，以及在减轻程序人员工作负担方面所做的努力。
　　下部分将会详细介绍Xenon的微处理架构。包括PPE的特点和神秘的128寄存器的VMX的详细情况。及Xenon的实现方式和设计哲学等相关信息……
