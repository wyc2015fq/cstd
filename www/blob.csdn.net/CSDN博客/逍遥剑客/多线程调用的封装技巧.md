# 多线程调用的封装技巧 - 逍遥剑客 - CSDN博客
2014年02月27日 00:33:21[xoyojank](https://me.csdn.net/xoyojank)阅读数：3838
个人分类：[基础知识](https://blog.csdn.net/xoyojank/article/category/259553)

很多时候, 我们想把一项操作放入后台线程去执行, 可能是为了提高操作体验(UI表现的流畅), 或者是性能(充分利用多核的计算能力)等
为了方便, 我在这里先定义一个简化的线程模型:
- 所有的操作都定义为命令(Command)
- 后台线程监听一个命令队列, 如果有命令就执行, 没有就等待
- 如果收到结束通知, 则结束该线程
比如我们有两种操作:
```cpp
void PrintA()
{
    printf("thread[%x]: aaa\n", this_thread::get_id().hash());
}
void PrintB()
{
    printf("thread[%x]: bbb\n", this_thread::get_id().hash());
}
```
这两种操作会在后台线程去执行, 用代码表示如下:
```cpp
enum CommandType
{
    CommandA,
    CommandB
};
atomic_int8_t IsOver = 0;
concurrent_queue<CommandType> CommandQueue;
void SendCommand(CommandType cmd)
{
    CommandQueue.push(cmd);
}
atomic_int8_t IsOver = 0;
concurrent_queue<CommandType> CommandQueue;
void CommandThreadProc()
{
    printf("thread[%x]: start\n", this_thread::get_id().hash());
    chrono::seconds time(1);
    CommandType command;
    while (IsOver == 0)
    {
        if (CommandQueue.try_pop(command))
        {
            switch (command)
            {
            case CommandA:
                PrintA();
                break;
            case CommandB:
                PrintB();
                break;
            }
        }
        this_thread::sleep_for(time);
    }
    printf("thread[%x]: end\n", this_thread::get_id().hash());
}
```
运行:
```cpp
int _tmain(int argc, _TCHAR* argv[])
{
    printf("thread[%x]: start\n", this_thread::get_id().hash());
    thread t(CommandThreadProc);
    SendCommand(CommandA);
    SendCommand(CommandB);
    this_thread::sleep_for(chrono::seconds(10));
    IsOver = true;
    t.join();
    printf("thread[%x]: end\n", this_thread::get_id().hash());
    system("pause");
    return 0;
}
```
Nebula3中使用的就是类似这样的模型, 把各种参数封装成Command, 发到后台线程去执行, 然后写一堆的swith-case去判断是什么命令, 再执行相应的操作
这种方式的好处就是简单, 而且也把操作细节隐藏在内部线程里了, 不过从编码的角度来看, 相当烦琐
改进一下, 把操作定义在外部, 然后把Command进行抽象, 这样可以免掉很多的条件判断和重复性编码:
```cpp
struct Command
{
    virtual void DoCommand() = 0;
};
atomic_int8_t IsOver = 0;
concurrent_queue<Command*> CommandQueue;
void SendCommand(Command* cmd)
{
    CommandQueue.push(cmd);
}
void CommandThreadProc()
{
    printf("thread[%x]: start\n", this_thread::get_id().hash());
    chrono::seconds time(1);
    Command* command = nullptr;
    while (IsOver == 0)
    {
        if (CommandQueue.try_pop(command))
        {
           command->DoCommand();
           delete command;
           command = nullptr;
        }
        this_thread::sleep_for(time);
    }
    printf("thread[%x]: end\n", this_thread::get_id().hash());
}
```
这样定义后只需要派生抽象Command就好, 增加新的操作后台线程的代码无需变动:
```cpp
struct CommandA : public Command
{
    virtual void DoCommand() override
    {
        PrintA();
        printf("\t%s\n", __FUNCTION__);
    }
};
struct CommandB : public Command
{
    virtual void DoCommand() override
    {
        PrintB();
        printf("\t%s\n", __FUNCTION__);
    }
};
/****************main****************/
    SendCommand(new CommandA());
    SendCommand(new CommandB());
/************************************/
```
但是这样还要是重复去定义很多个Command的子类. 在学习WPF时, 发现他们可以直接使用Dispatcher.BeginInvoke把某个函数发到后台去执行, 后来想了想, 其实就是把函数封装成对象发过去了. C++借助成员函数指针什么的也可以实现类似的机制:
```cpp
struct FunctionCommand : public Command
{
    function<void()> fun;
    FunctionCommand(function<void()> f) : fun(f) {}
    virtual void DoCommand() override
    {
        fun();
        printf("\t%s\n", __FUNCTION__);
    }
};
/****************main****************/
    SendCommand(new FunctionCommand(PrintA));
    SendCommand(new FunctionCommand(PrintB));
/************************************/
```
这个方案看起来已经挺完美了, 但是, 还是不够灵活, 因为如果是在现有代码上重构, 一样需要封装很多函数出来. 在阅读Unreal代码时发现, 里面用了几个很巧妙的宏, 可以把代码片段封装成对象, 这样就免去了定义函数的代码量. 简化一下代码就是这样:
```cpp
#define SEND_COMMAND(TypeName, Code) \
    { \
        struct TypeName##Command : public Command \
        { \
            virtual void DoCommand() override \
            { \
                Code; \
                printf("\t%s\n", __FUNCTION__); \
            } \
        }; \
        SendCommand(new TypeName##Command()); \
    }
/****************main****************/
    SEND_COMMAND(Print,
    {
        PrintA();
    });
    SEND_COMMAND(Print,
    {
        PrintB();
    });
    SEND_COMMAND(Print,
    {
        PrintB();
        PrintA();
    });
/************************************/
```
可以看到宏参数可以是多行的, 所以一段代码可以当成宏的一个参数传入, 然后封装成对象, 真是让人想不到的办法!
完整的main函数和执行结果如下:
```cpp
int _tmain(int argc, _TCHAR* argv[])
{
    printf("thread[%x]: start\n", this_thread::get_id().hash());
    thread t(CommandThreadProc);
    SendCommand(new CommandA());
    SendCommand(new CommandB());
    SendCommand(new FunctionCommand(PrintA));
    SendCommand(new FunctionCommand(PrintB));
    SEND_COMMAND(Print,
    {
        PrintA();
    });
    SEND_COMMAND(Print,
    {
        PrintB();
    });
    SEND_COMMAND(Print,
    {
        PrintB();
        PrintA();
    });
    this_thread::sleep_for(chrono::seconds(10));
    IsOver = true;
    t.join();
    printf("thread[%x]: end\n", this_thread::get_id().hash());
    system("pause");
	return 0;
}
```
![](https://img-blog.csdn.net/20140227003259765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveG95b2phbms=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

