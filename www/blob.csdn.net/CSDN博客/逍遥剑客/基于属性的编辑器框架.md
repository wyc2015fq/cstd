# 基于属性的编辑器框架 - 逍遥剑客 - CSDN博客
2010年09月17日 00:18:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：2795
看了Ogitor的代码后, 自己又实践了一把, 结合N3中学到的一些技巧, 在编辑器中得到了验证.
虽说做的是场景编辑器, 但是其它编辑器也可以用的, 毕竟思想都差不多.
对于一个编辑器, 通常是由一个个的"实体"组成, 或者叫"对象". 而"对象"又是由各种"属性"所组成.
以场景编辑器为例, 我们通常会涉及以下操作:
- 刷地形, 刷纹理
- 摆模型, 设置模型参数
- 摆光源, 设置光源参数
- 摆特效/音效, 设置参数
- 摆NPC, 设置相应参数
- ...
可以看到, 除了地形之外, 其它的操作都差不多. 如果把地形把块对待, 每个地形块做为一个"对象", 高度和纹理编辑当成属性编辑, 那么上面都可以看成是同一种编辑方式了. 还有"摆"的这个操作, 其实本质上了也是对象的位置变换这个属性的变化.
由此可以得出: **编辑器的一切操作都是属性编辑**
实体不用说了, 相信每个引擎都有Model/Light/Sound之类的对象类. 
那么怎么去定义一个属性呢?
简单的来说, 一个属性是一个<名称, 值>的配对, 对象就是这些属性的一个集合体. 以点光源为例, 它一般有这么几个属性:
- 名称. Light0
- 类型. PointLight
- 位置. (100, 100, 100)
- 范围. 15
- 衰减. 1.0
- 颜色. 0xff00ff00
- .....
实际应用中我使用了FourCC代替String来索引属性, 这样可以用map<FourCC, Variant>做快速的访问. 更高级的实现可以参见N3的Attribute模块.
下面说说使用属性抽象的好处:
- 编辑操作- 因为对象都是由属性组成的, 所以所有的编辑对象都可以抽象成一种, 那么只需要实现一种编辑方式就可以适用于所有的对象
- 因为操作是与具体对象相关性不大, 所以扩展新的对象类型对结构的影响很小
- 文件读写- 对象是属性组成, 那么只需要把属性保存下来即可. 
- 增删属性不用改动文件格式, 连版本号都省了
- Undo/Redo- 对于创建/删除操作, 备份该对象所有属性.
- 对于属性更改操作, 备份当前编辑属性.
- Undo/Redo只不过是把属性进行还原而已
- 界面显示- 属性可以与PropertyGrid良好的结合. 对于MFC的PropertyGrid正好可以用FourCC的uint值做为id. 扩展一下很容易把属性显示做成自适应的, 而不依赖于具体代码实现. 
- 考虑与.net的property反射机制相结合(待验证)
再考查一下WPF下的绑定机制与属性相结合会产生什么效果~
