# 径向模糊效果 - 逍遥剑客 - CSDN博客
2010年01月06日 22:28:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：9974
最先在这里看到:http://www.gamerendering.com/2008/12/20/radial-blur-filter/
这效果在鬼泣4中切换场景时见过, 极品飞车12的运动模糊也有这种感觉.
原理:
    确定一个中心点(如0.5, 0.5), 跟当前像素连一条线. 以当前像素为中心, 在线上的附近像素进行采样, 最后取一下平均值.
![](https://p-blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20100107/radial-blur.gif)
代码翻译成HLSL:
// This texture should hold the image to blur.
sampler2D Texture0;
// some const, tweak for best look
const float fSampleDist;
const float fSampleStrength; 
// some sample positions
float samples[10] = 
{
   -0.08,
   -0.05,
   -0.03,
   -0.02,
   -0.01,
   0.01,
   0.02,
   0.03,
   0.05,
   0.08
};
float4 ps_main( float2 texCoord  : TEXCOORD0 ) : COLOR
{
   // 0.5,0.5 is the center of the screen
   // so substracting uv from it will result in
   // a vector pointing to the middle of the screen
   float2 dir = 0.5 - texCoord;
   // calculate the distance to the center of the screen
   float dist = length(dir);
   // normalize the direction (reuse the distance)
   dir /= dist;
   
   // this is the original colour of this pixel
   // using only this would result in a nonblurred version
   float4 color = tex2D(Texture0, texCoord);
   
   float4 sum = color;
   // take 10 additional blur samples in the direction towards
   // the center of the screen
   for (int i = 0; i < 10; ++i)
   {
      sum += tex2D(Texture0, texCoord + dir * samples[i] * fSampleDist);
   }
   // we have taken eleven samples
   sum /= 11.0;
   
   // weighten the blur effect with the distance to the
   // center of the screen ( further out is blurred more)
   float t = saturate(dist * fSampleStrength);
   
   //Blend the original color with the averaged pixels
   return lerp(color, sum, t);
}
两个参数, 动态调整的话可以产生极品飞车12那种速度感(也算是第一人称运动模糊的简单实现吧).
这是RM里的效果:
![](https://p-blog.csdn.net/images/p_blog_csdn_net/xoyojank/EntryImages/20100106/RadialBlur.jpg)
