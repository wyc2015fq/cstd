# 有向无环图的自动布局算法 - 逍遥剑客 - CSDN博客
2012年12月02日 23:14:48[xoyojank](https://me.csdn.net/xoyojank)阅读数：14278
最近业余在做一个基于结点的编辑工具玩, 遇到一个问题, 就是结点和连线多了, 经常会出现重叠交叉的问题, 导致图看不清楚:
![](https://img-my.csdn.net/uploads/201212/02/1354458723_4681.png)
要是这个样子, 还不如不用图清楚呢, 所心就需要找一个方法来进行自动布局, 理想情况是这样的(手动整理结果):
![](https://img-my.csdn.net/uploads/201212/02/1354458728_3663.png)
当然, 手动整理的话, 每个人弄出来的结果都不一样. 自动的算法肯定没有100%完美的, 但是总是能方便不少的
在google了一会儿后, 发现这种结点-线组成的图是一有个学名的: [directed acyclic graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph), 例如这样:
![](https://img-my.csdn.net/uploads/201212/02/1354459040_3401.png)
无非我这个图结点上的连接点是有限制的, 但这个对于布局算法来说, 影响不大. 因为布局只需要大体考虑每个结点的位置
那么, 这个算法需要满足几个条件: 
- 结点之间不能有重叠
- 连线之间尽量减少交差
- 结点之间是有基本的层次关系对齐的
基于这些限制条件, google到一个比较有名的算法[Sugiyama's layout algorithm](http://improbable-emancipation.blogspot.com/2011/09/sugiyama-layout-algorithm-hierarchical.html)
初步看了一上, 这个算法比较复杂, 是多种算法的集合
自己不是很熟悉这方面的理论知识, 所以还是决定采用第三的算法库
C++可以使用的图绘制算法库, 比较常见的有Graphviz, OGDF, Boost Graph
根据这个问题(http://stackoverflow.com/questions/2751826/which-c-graph-library-should-i-use)的推荐, 尝试了OGDF, 效果还不错(可惜是GPL协议)
```cpp
//------------------------------------------------------------------------------
void
QNodesEditor::autoLayout()
{
	using namespace ogdf;
	Graph graph;
	// setup graph
	QMap<NodeElement*, QNEBlock*> nodeMap;
	foreach(QGraphicsItem * item, scene->items())
	{
		if (item->type() == QNEBlock::Type)
		{
			NodeElement* node = graph.newNode();
			item->setData(QNEBlock::Type, qVariantFromValue((void*)node));
			nodeMap[node] = (QNEBlock*)item;
		}
	}
	foreach(QGraphicsItem * item, scene->items())
	{
		if (item->type() == QNEConnection::Type)
		{
			QNEConnection* connection = (QNEConnection*)item;
			NodeElement* node1 = (NodeElement*)connection->port1()->block()->data(QNEBlock::Type).value<void*>();
			NodeElement* node2 = (NodeElement*)connection->port2()->block()->data(QNEBlock::Type).value<void*>();
			graph.newEdge(node1, node2);
		}
	}
	// node size
	GraphAttributes graphAttr(graph,
	                          GraphAttributes::nodeGraphics | GraphAttributes::edgeGraphics |
	                          GraphAttributes::nodeLabel | GraphAttributes::nodeColor |
	                          GraphAttributes::edgeColor | GraphAttributes::edgeStyle |
	                          GraphAttributes::nodeStyle | GraphAttributes::nodeTemplate);
	NodeElement* node;
	forall_nodes(node, graph)
	{
		QNEBlock* item = nodeMap[node];
		graphAttr.width(node) = item->getHeight();
		graphAttr.height(node) = item->getWidth();
	}
	// compute layout
	SugiyamaLayout layout;
	FastHierarchyLayout* ohl = new FastHierarchyLayout;
	ohl->layerDistance(30);
	ohl->nodeDistance(25);
	layout.setLayout(ohl);
	layout.call(graphAttr);
	// update node position
	forall_nodes(node, graph)
	{
		double x = graphAttr.x(node);
		double y = graphAttr.y(node);
		QNEBlock* item = nodeMap[node];
		item->setPos(y, x);
	}
}
```
最终效果:
![](https://img-my.csdn.net/uploads/201212/02/1354461537_7144.png)
