# 是不我也应该写点自己的想法 - 逍遥剑客 - CSDN博客
2008年09月21日 03:37:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：1639标签：[算法																[crash																[processing																[设计模式																[shader																[blog](https://so.csdn.net/so/search/s.do?q=blog&t=blog)](https://so.csdn.net/so/search/s.do?q=shader&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)](https://so.csdn.net/so/search/s.do?q=processing&t=blog)](https://so.csdn.net/so/search/s.do?q=crash&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[乱七八糟](https://blog.csdn.net/xoyojank/article/category/259560)
一直以来这个blog不是转载的就是学习笔记啥的, 没多自己真正思考的东西
可能因为自己还有另一个写生活的blog, 劳骚全发那上面了
不过看各位业内大牛在博客上写的一些自己思考的东西, 看了很有感触.
自己也应该写点自己的想法吧, 起码有些朋友看了会留个评论, 呵呵
今天在读A Shader Appoach, 算是巩固一下基础知识吧
看到一个函数:**D3DXVec3Hermite**. 突然想到不是有个Hermit Curve吗? 呵呵, 这下做来画曲线方便大了. 想想自己上次写的那个B-样条曲线的算法老是担心效率问题, 呵呵.
看到平面相关时, 有个判断点面关系的函数:**D3DXPlaneDotCoord**. google了一下, 发现一个Frustum Cull用到了它. 看了一下Nebula3的做法, 是直接把点乘了view-projection矩阵, 再判断是不是在[-1, 1]范围内. 到底哪种方法好呢? 我想应该是后者. 一来更好理解一些(就是屏幕上能看到的才在Frustum内), 二来矩阵乘法是很快的, 很多库也对它做过优化(比如**D3DXVec3Transform**). 
另一个问题就是Pure Device.书上说这样效率会提高, 不过那些device->GetXXX()的函数就没用了. 还有它必须用Hardware Vertex Processing, 这样有些显卡就不支持了(如intel那些@_@). 而且pure device不会对重复的状态设置进行过滤, 这样如果设计不好反而会影响效率. 虽然速度快, 但不太实用, 呵呵.
再就是Device Lost了, 可能用DirectX的人都对这东西感到不爽. 一般都是用**TestCooperativeLevel()**判断的吧.不过在Nebula3里试了一下, 竟然Crash了,囧. 改了一下Present, 不Crash了,但是不画东西了-_-. 开DEBUG版的DirectX, 原来是RenderTarget没有释放, 导致**Reset**()一直失败. 看来作者还没有把这块儿资源管理整合进去, **RenderEventHandler**还没有进行处理. 
顺便关注了一下Nebula3的官网, 代码竟然更新了, 晕. 有空从SVN check个新的. 
还有就是RenderQueue的问题. 一直没找到nebula3里相应的部分, 那么它做shadow map是咋做的呢? 看了一下, 是PSSM算法. GameDev上搜到算法的出处, 是香港中文大学. 去年看TSM算法时搜到作者是新加坡大学的,  一看照片很眼熟, 仔细一看, 这不是我们外教吗? 汗, 华人都怎么跟影子算法搞上关系了, 还一个比一个牛. 不过PSSM有例子程序, 哈哈. ogre好像也是用的这个. 看例子阴影质量还不错, 再弄个高斯模糊就完美了^_^. 记录一下链接: [http://appsrv.cse.cuhk.edu.hk/~fzhang/pssm_vrcia/](http://appsrv.cse.cuhk.edu.hk/~fzhang/pssm_vrcia/)
shader approach里的input是用的DirectInput. nebula3里的鼠标也是用的这个. 为什么呢? 一直没想明白. 可能DirectInput可以支持手柄? 还有就是可以处理更灵活的消息. 原来在激战里那个摄像机移动就可以把鼠标往一个方向一直拖, 不会停下. 而如果用Windows MsgProc的话拖到屏幕边缘就拖不动了. 反正也不复杂, 这东西还是要抽时间学学.
到底有没有必要写一个自己的引擎呢? 可能自己太懒了, 所以一直以来也没什么代码积累. 但是写了又觉得跟这些开源的差别太大, 觉得没意义, 不如直接用开源的. 先写个像DXUT那样的框架吧, 至少自己写DEMO用. 参考一下这些优秀引擎的设计, 嘿嘿. 设计模式也该认真学学, 唉, 前面的路还很长.........
