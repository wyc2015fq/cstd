# 关于中文文本的截取  - 逍遥剑客 - CSDN博客
2008年03月04日 12:57:00[xoyojank](https://me.csdn.net/xoyojank)阅读数：1652
                从Java转到C++后,对于它的字符串处理能力抱怨了好久
这不,非Unicode下对字符串进行截取有时会出现乱码,因为把一个汉字是两个字节,如果拆开了就显示不正确了
# IsDBCSLeadByte
The **IsDBCSLeadByte** function uses the ANSI code page to determine whether a specified byte is potentially a lead byte that is, the first byte of a two-byte character in a double-byte character set (DBCS). 
To use a different code page, use the **IsDBCSLeadByteEx** function. 
**BOOL IsDBCSLeadByte(BYTE***[](http://writeblog.csdn.net/Editor/FCKeditor/editor/)*   // character to test
**);**
MSDN里有这个函数,可以判断一个char是不是一个双字节字的开始. 
但是,对于汉字来说,第一个字节肯定大于0x80,第二个字节就不一定了,所以,要判断一个字节是不是汉字的一部分,只能从字符串的开头进行扫描:
![](http://www.cnblogs.com/Images/OutliningIndicators/None.gif)for (int i =0; i < text.length(); i++)
![](http://www.cnblogs.com/Images/dot.gif){
![](http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif)if (IsDBCSLeadByte(text[i])
![](http://www.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cnblogs.com/Images/OutliningIndicators/ContractedSubBlock.gif)![](http://www.cnblogs.com/Images/dot.gif){
![](http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif)        i++;
![](http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif)//TODO:
![](http://www.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif)    }
![](http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)}
这样就可以在遇到汉字的时候一次跳过两个字节了              
