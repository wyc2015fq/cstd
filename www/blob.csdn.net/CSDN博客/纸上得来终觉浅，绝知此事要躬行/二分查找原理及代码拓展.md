# 二分查找原理及代码拓展 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客





2016年05月19日 11:21:32[boonya](https://me.csdn.net/boonya)阅读数：1716








### 概念

   二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其[缺点](http://baike.baidu.com/subview/686845/9049570.htm)是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的[关键字](http://baike.baidu.com/view/390935.htm)与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置[记录](http://baike.baidu.com/subview/101813/14121028.htm)将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的[记录](http://baike.baidu.com/subview/101813/14121028.htm)，使查找成功，或直到子表不存在为止，此时查找不成功。



### 算法要求

 1.必须采用有序存储数据结构


  2.必须按关键字大小有序排列

### 算法复杂度

   二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x<a[n/2],则只要在数组a的左半部分继续搜索x,如果x>a[n/2],则只要在数组a的右半部搜索x，时间复杂度无非就是while循环的次数！


   总共有n个元素，渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数；

   由于你n/2^k取整后>=1，即令n/2^k=1，可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn)。



### 算法Java代码

```java
public static int binarySearch(Integer[] srcArray, int des) {
    int low = 0;
    int high = srcArray.length - 1;
 
    while ((low <= high) && (low <= srcArray.length - 1)
            && (high <= srcArray.length - 1)) {
        int middle = (high + low) >> 1;
        if (des == srcArray[middle]) {
            return middle;
        } else if (des < srcArray[middle]) {
            high = middle - 1;
        } else {
            low = middle + 1;
        }
    }
    return -1;
}
```

### 二分查找拓展（泛型实现）

```java
package com.boonya.utils.algorithm;

/**
 * Java泛型 二分查找
 * 
 * @packge com.boonya.utils.algorithm.BinarySearch
 * @date 2016年5月19日 上午10:04:00
 * @author pengjunlin
 * @comment
 * @update
 */
public class BinarySearch {

	/**
	 * 二分查找循环查找
	 * 
	 * @MethodName: binarySearch
	 * @Description:
	 * @param a
	 *            : is object array
	 * @param x
	 *            : need to search object
	 * @return
	 * @throws
	 */
	public static <T extends Comparable<? super T>> int binarySearch(T[] a, T d) {
		int start = 0, end = a.length - 1;
		while (start <= end) {
			int mid = (start + end) / 2;
			if (a[mid].compareTo(d) < 0) {
				start = mid + 1;
			} else if (a[mid].compareTo(d) > 0) {
				end = mid - 1;
			} else {
				return mid;
			}
		}
		return -1;
	}

	/**
	 * 二分查找递归实现
	 * 
	 * @MethodName: binSearch
	 * @Description:
	 * @param t
	 * @param start
	 * @param end
	 * @param key
	 * @return
	 * @throws
	 */
	public static <T extends Comparable<? super T>> int binarySearch(T a[],
			int start, int end, T d) {
		int mid = (end - start) / 2 + start;
		if (a[mid] == d) {
			return mid;
		}
		if (start >= end) {
			return -1;
		} else if (a[mid].compareTo(d) < 0) {
			return binarySearch(a, mid + 1, end, d);
		} else if (a[mid].compareTo(d) > 0) {
			return binarySearch(a, start, mid - 1, d);
		}
		return -1;
	}

}
```


参考资料：http://baike.baidu.com/link?url=8Og5BzwTH2g9cXRkCnsGycz3QqFFP5W2pfJR0UJMRc5uotVAlRpR6UzBwYzqzpWQaIViS5Tra99mpRQwIN5Hpa











