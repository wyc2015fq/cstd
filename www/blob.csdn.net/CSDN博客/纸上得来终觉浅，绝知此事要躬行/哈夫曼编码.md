# 哈夫曼编码 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客





2016年05月20日 18:25:26[boonya](https://me.csdn.net/boonya)阅读数：7438








[**哈夫曼**](http://baike.baidu.com/view/1436260.htm)编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变[字长](http://baike.baidu.com/view/731.htm)编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据[字符](http://baike.baidu.com/view/263416.htm)出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。



### 原理

设某信源产生有五种符号u1、u2、u3、u4和u5，对应概率P1=0．4，P2=0．1，P3=P4=0．2，P5=0．1。首先，将符号按照概率由大到小排队，如图所示。编码时，从最小概率的两个符号开始，可选其中一个支 路为0，另一支路为1。这里，我们选上支路为0，下支路为1。再将已编码的两支路的概率合并，并重新排队。多次重复使用上述方法直至合并概率归一时为止。从图（a）和（b）可以看出，两者虽平均码长相等，但同一符号可以有不同的码长，即编码方法并不唯一，其原因是两支路概率合并后重新排队时，可能出现几个支路概率相等，造成排队方法不唯一。一般，若将新合并后的支路排到等概率的最上支路，将有利于缩短码长方差，且编出的码更接近于等长码。这里图（a）的编码比（b）好。

![图1 赫夫曼编码原理](http://c.hiphotos.baidu.com/baike/s%3D220/sign=5b1270565aee3d6d26c680c973176d41/c75c10385343fbf2b83ec5d2b37eca8065388f34.jpg)图1
 赫夫曼编码原理


赫夫曼码的码字（各符号的代码是异前置码字，即任一码字不会是另一码字的前面部分，这使各码字可以连在一起传送，中间不需另加隔离符号，只要传送时不出错，收端仍可分离各个码字，不致混淆。

实际应用中，除采用定时清洗以消除误差扩散和采用缓冲存储以解决速率匹配以外，主要问题是解决小符号集合的统计匹配，例如黑（1）、白（0）传真信源的统计匹配，采用0和1不同长度游程组成扩大的符号集合信源。游程，指相同码元的长度（如二进码中连续的一串0或一串1的长度或个数）。按照CCITT标准，需要统计2×1728种游程（长度），这样，实现时的存储量太大。事实上长游程的概率很小，故CCITT还规定：若l表示游程长度，则l=64q+r。其中q称主码，r为基码。编码时，不小于64的游程长度由主码和基码组成。而当l为64的整数倍时，只用主码的代码，已不存在基码的代码。

长游程的主码和基码均用赫夫曼规则进行编码，这称为修正赫夫曼码，其结果有表可查。该方法已广泛应用于文件传真机中。

















### 定理

在变[字长](http://baike.baidu.com/view/731.htm)编码中，如果码字长度严格按照对应符号出现的概率大小逆序排列，则其平 均码字长度为最小。

现在通过一个实例来说明上述定理的实现过程。设将信源符号按出现的概率大小顺序排列为 ：

U： ( a1 a2 a3 a4 a5 a6 a7 ) [1] 

0.20 0.19 0.18 0.17 0.15 0.10 0.01

给概率最小的两个符号a6与a7分别指定为“1”与“0”，然后将它们的概率相加再与原来的 a1~a5组合并重新排序成新的原为：

U′： ( a1 a2 a3 a4 a5 a6′ )

0.20 0.19 0.18 0.17 0.15 0.11

对a5与a′6分别指定“1”与“0”后，再作概率相加并重新按概率排序得

U″：（0.26 0.20 0.19 0.18 0.17）…

直到最后得 U″″：（0.61 0.39）

赫夫曼编码的具体方法：先按出现的概率大小排队，把两个最小的概率相加，作为新的概率 和剩余的概率重新排队，再把最小的两个概率相加，再重新排队，直到最后变成1。每次相 加时都将“0”和“1”赋与相加的两个概率，读出时由该符号开始一直走到最后的“1”， 将路线上所遇到的“0”和“1”按最低位到最高位的顺序排好，就是该符号的赫夫曼编码。

例如a7从左至右，由U至U″″，其码字为0000；

a6按路线将所遇到的“0”和“1”按最低位到最高位的顺序排好，其码字为0001…

用赫夫曼编码所得的平均[比特率](http://baike.baidu.com/view/56355.htm)为：Σ码长×出现概率

上例为：0.2×2+0.19×2+0.18×3+0.17×3+0.15×3+0.1×4+0.01×4=2.72 bit

可以算出本例的信源熵为2.61bit，二者已经是很接近了。


### 哈夫曼树
![](https://img-blog.csdn.net/20160520182240793)

#### 如何构造

然而怎样构造一棵[哈夫曼树](http://baike.baidu.com/view/127820.htm)呢？最具有一般规律的[构造方法](http://baike.baidu.com/subview/595732/595732.htm)就是[哈夫曼算法](http://baike.baidu.com/subview/1679065/1679065.htm)。一般的数据结构的书中都可以找到其描述：


### 构成初始集合


对给定的n个[权值](http://baike.baidu.com/subview/2109980/2109980.htm){W1,W2,W3,...,Wi,...,Wn}构成n棵[二叉树](http://baike.baidu.com/view/88806.htm)的初始集合F={T1,T2,T3,...,Ti,...,Tn}，其中每棵二叉树Ti中只有一个权值为Wi的[根结点](http://baike.baidu.com/subview/549553/549553.htm)，它的左右子树均为空。（为方便在计算机上实现算法，一般还要求以Ti的权值Wi的升序排列。）


### 选取左右子树


在F中选取两棵[根结点](http://baike.baidu.com/subview/549553/549553.htm)[权值](http://baike.baidu.com/subview/2109980/2109980.htm)最小的树作为新构造的[二叉树](http://baike.baidu.com/view/88806.htm)的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。


### 删除左右子树


从F中删除这两棵树，并把这棵新的[二叉树](http://baike.baidu.com/view/88806.htm)同样以升序排列加入到集合F中。


### 重复二和三两步


重复二和三两步，直到集合F中只有一棵[二叉树](http://baike.baidu.com/view/88806.htm)为止。

用C语言实现上述算法，可用静态的二叉树或动态的二叉树。若用动态的二叉树可用以下数据结构： struct tree{

float weight; /*[权值](http://baike.baidu.com/subview/2109980/2109980.htm)*/

union{

char leaf; /*叶结点信息[字符](http://baike.baidu.com/view/263416.htm)*/

struct tree *left; /*树的左结点*/

};

struct tree *right; /*树的右结点*/

};

struct forest{ /*F集合，以[链表](http://baike.baidu.com/view/549479.htm)形式表示*/

struct tree *ti; /* F中的树*/

struct forest *next; /* 下一个结点*/

};

例：若字母A，B，C，D出现的概率为：0.75,0.54,0.28,0.43；则相应的[权值](http://baike.baidu.com/subview/2109980/2109980.htm)为：75，54，28，43。

构造好[哈夫曼树](http://baike.baidu.com/view/127820.htm)后，就可根据哈夫曼树进行编码。例如：上面的[字符](http://baike.baidu.com/view/263416.htm)根据其出现的概率作为权值构造一棵哈夫曼树后，经[哈夫曼编码](http://baike.baidu.com/view/95311.htm)得到的对应的码值。只要使用同一棵哈夫曼树，就可把编码还原成原来那组字符。显然哈夫曼编码是[前缀编码](http://baike.baidu.com/subview/4513851/4513851.htm)，即任一个字符的编码都不是另一个字符的编码的前缀，否则，编码就不能进行翻译。例如：a,b,c,d的编码为：0，10，110，111，对于编码串：1010就翻译为bb。刚才进行哈夫曼编码的规则是从[根结点](http://baike.baidu.com/subview/549553/549553.htm)到[叶结点](http://baike.baidu.com/subview/549557/549557.htm)（包含原信息）的路径，向左孩子前进编码为0，向右孩子前进编码为1，当然你也可以反过来规定。


### 哈夫曼编码实现


参看不同语言的实现：[http://rosettacode.org/wiki/Huffman_coding](http://rosettacode.org/wiki/Huffman_coding)


wiki算法和动态图展示：[https://en.wikipedia.org/wiki/Huffman_coding](https://en.wikipedia.org/wiki/Huffman_coding)




**参考资料：**

http://baike.baidu.com/subview/1436260/1436260.htm

http://baike.baidu.com/link?url=Jx9c-rCmycy8AyRCFN3cvnakRZPrwhlzgdXheQF9ySM_KtfCAyHEKvrs4hwsJKJg_LKWsBGlQfeDVeliCEWKCK









