# 算法复杂度：算法时间复杂度和空间复杂度表示法 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客
2019年04月18日 17:10:48[boonya](https://me.csdn.net/boonya)阅读数：15标签：[计算机领域																[算法																[复杂度																[时间复杂度																[空间复杂度](https://so.csdn.net/so/search/s.do?q=空间复杂度&t=blog)](https://so.csdn.net/so/search/s.do?q=时间复杂度&t=blog)](https://so.csdn.net/so/search/s.do?q=复杂度&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)](https://so.csdn.net/so/search/s.do?q=计算机领域&t=blog)
个人分类：[计算机基础](https://blog.csdn.net/boonya/article/category/8871168)
文章地址：[http://lzw.me/a/algorithm-complexity.html](http://lzw.me/a/algorithm-complexity.html)
算法复杂度分为时间复杂度和空间复杂度。
时间复杂度用于度量算法执行的时间长短；而空间复杂度则是用于度量算法所需存储空间的大小。
**目录**
[时间复杂度](#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%C2%A0)
[1.时间频度](#1.%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6%C2%A0)
[2.计算方法](#2.%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95)
[3.分类](#3.%E5%88%86%E7%B1%BB)
[空间复杂度](#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
[算法的时间复杂度（计算实例）](#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B%EF%BC%89%C2%A0)
[算法复杂度的渐近表示法](#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%B8%90%E8%BF%91%E8%A1%A8%E7%A4%BA%E6%B3%95)
[一  大O记号](#%E4%B8%80%C2%A0%20%E5%A4%A7O%E8%AE%B0%E5%8F%B7)
[二  Ω记号](#%E4%BA%8C%C2%A0%20%E2%84%A6%E8%AE%B0%E5%8F%B7)
[三  Θ记号](#%E4%B8%89%C2%A0%20%CE%98%E8%AE%B0%E5%8F%B7)
[四  小o记号](#%E5%9B%9B%C2%A0%20%E5%B0%8Fo%E8%AE%B0%E5%8F%B7)
[五  例子](#%E4%BA%94%C2%A0%20%E4%BE%8B%E5%AD%90)
[常见排序算法时空复杂度](#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6)
# 时间复杂度 
## 1.时间频度 
　　一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
## 2.计算方法
　　1. 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n））
　　分析：随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。
　　2. 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））
　　例：算法：
> 
　　for（i=1;i<=n;++i）
　　{
　　for(j=1;j<=n;++j)
　　{
　　c[ i ][ j ]=0; //该步骤属于基本操作执行次数：n的平方 次
　　for(k=1;k<=n;++k)
　　c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ]; //该步骤属于基本操作 执行次数：n的三次方 次
　　}
　　}
　　则有 T（n）= n的平方+n的三次方，根据上面括号里的同数量级，我们可以确定 n的三次方 为T（n）的同数量级
　　则有f（n）= n的三次方，然后根据T（n）/f（n）求极限可得到常数c
　　则该算法的 时间复杂度：T（n）=O（n的三次方）
## 3.分类
　　按数量级递增排列，常见的时间复杂度有：
　　常数阶O(1),对数阶O(log2n),线性阶O(n),
　　线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…，
　　k次方阶O(nk), 指数阶O(2n) 。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。
# 空间复杂度
　　与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作:
　　S(n)=O(f(n))
　　我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。
# 算法的时间复杂度（计算实例） 
**算法的时间复杂度**
定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。
当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。
我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。
此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。
“大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。
这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。
**O(1)**
Temp=i;i=j;j=temp;
以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。
**O(n^2)**
2.1. 交换i和j的内容
> 
sum=0； （一次）
for(i=1;i<=n;i++) （n次）
for(j=1;j<=n;j++) （n^2次）
sum++； （n^2次）
解：T(n)=2n^2+n+1 =O(n^2)
2.2.
> 
for (i=1;i<n;i++)
{
y=y+1; ① 
for (j=0;j<=(2*n);j++) 
x++; ② 
}
解：语句1的频度是n-1
语句2的频度是(n-1)*(2n+1)=2n^2-n-1
f(n)=2n^2-n-1+(n-1)=2n^2-2
该程序的时间复杂度T(n)=O(n^2).
**O(n) **
> 
2.3.
a=0;
b=1; ①
for (i=1;i<=n;i++) ②
{ 
s=a+b;　　　　③
b=a;　　　　　④ 
a=s;　　　　　⑤
}
解：语句1的频度：2, 
语句2的频度： n, 
语句3的频度： n-1, 
语句4的频度：n-1, 
语句5的频度：n-1, 
T(n)=2+n+3(n-1)=4n-1=O(n).
**O(log2n )**
2.4.
> 
i=1; ①
while (i<=n)
i=i*2; ②
解： 语句1的频度是1, 
设语句2的频度是f(n), 则：2^f(n)<=n;f(n)<=log2n 
取最大值f(n)= log2n,
T(n)=O(log2n )
**O(n^3)**
2.5.
> 
for(i=0;i<n;i++)
{ 
for(j=0;j<i;j++) 
{
for(k=0;k<j;k++)
x=x+2; 
}
}
解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).
我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。
下面是一些常用的记法：
访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如 果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。
指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况，通常应该用寻找近似最佳结果的算法替代之。
# 算法复杂度的渐近表示法
一个算法的时间复杂度，指算法运行的时间。
假设数据输入规模是n，算法的复杂度可以表示为f(n)的函数
## 一  大O记号
假设f(n)和g(n)的定义域是非负整数，存在两个正整数c和n0，使得n>n0的时候，f(n)≤c*g(n),则f(n)=O(g(n))。可见O(g(n))可以表示算法运行时间的上界。O(g(n))表示的函数集合的函数是阶数不超过g(n)的函数。
例如：f(n)=2*n+2=O(n)
证明：当n>3的时候，2*n +2<3n，所以可选n0=3,c=3，则n>n0的时候，f(n)<c*(n)，所以f(n)=O(n)。
现在再证明f(n)=2*n+2=O(n^2)
证明：当n>2的时候，2*n+2<2*n^2，所以可选n0=2,c=2,则n>n0的时候，f(n)<c*(n^2)，所以f(n)=O(n^2)。
同理可证f(n)=O(n^a)，a>1
## 二  Ω记号
Ω记号与大O记号相反，他可以表示算法运行时间的下界。Ω（g（n））表示的函数集合的函数是所有阶数超过g(n)的函数。
例如：f(n)=2*n^2+3*n+2=Ω(n^2)
证明：当n>4的时候，2*n^2+3*n+2>n^2，所以可选n0=4,c=1,则n>n0的时候，f(n)>c*(n^2)，所以f(n)=Ω(n^2)。
同理可证f(n)=Ω(n),f(n)=Ω(1)
## 三  Θ记号
Θ记号介于大O记号和Ω记号之间。他表示，存在正常数c1,c2,n0，当n>n0的时候，c1*g(n)≤f(n)≤c2*g(n)，则f(n)=Θ(g(n))。他表示所有阶数与g(n)相同的函数集合。
## 四  小o记号
f(n)=o(g(n))当且仅当f(n)=O(g(n))且f(n)≠Ω(g(n))。也就是说小o记号可以表示时间复杂度的上界，但是一定不等于下界。
## 五  例子
假设f(n)=2n^2+3n+5，
则f(n)=O(n^2)或者f(n) = O(n^3)或者f(n)=O(n^4)或者……
f(n)=Ω(n^2)或者f(n)=Ω(n)或者f(n)=Ω(1)
f(n)=Θ(n^2)
f(n) = o(n^3)或者f(n)=o(n^4)或者f(n)=o(n^5)或者……
注：n^2表示n的平方，以此类推。
# 常见排序算法时空复杂度
|排序法|最差时间分析|平均时间复杂度|稳定度|空间复杂度|
|----|----|----|----|----|
|冒泡排序|O(n2)|O(n2)|稳定|O(1)|
|快速排序|O(n2)|O(n*log2n)|不稳定|O(log2n)~O(n)|
|选择排序|O(n2)|O(n2)|稳定|O(1)|
|二叉树排序|O(n2)|O(n*log2n)|不一顶|O(n)|
|插入排序|O(n2)|O(n2)|稳定|O(1)|
|堆排序|O(n*log2n)|O(n*log2n)|不稳定|O(1)|
|希尔排序|O|O|不稳定|O(1)|
