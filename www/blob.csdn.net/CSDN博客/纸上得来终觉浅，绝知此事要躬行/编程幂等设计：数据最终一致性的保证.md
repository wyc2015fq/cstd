# 编程幂等设计：数据最终一致性的保证 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客





2017年03月22日 14:59:16[boonya](https://me.csdn.net/boonya)阅读数：2993








## 幂等定义




幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。

在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.




## 什么是幂等性




幂等性的数学表达：f(f(x)) = f(x)。

幂等性是系统接口对外的一种承诺。

幂等性指的是，使用相同参数对同一资源重复调用某个接口的结果与调用一次的结果相同。

幂等性的一个实现是，使你的接口必须返回 0（成功），即使这时资源或动作已经停止并且无工作要完成。


理解：幂等性是系统的接口对外一种承诺(而不是实现)，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的接口会认为外部调用失败是常态，并且失败之后必然会有重试。接口幂等性，只要保证接口内的逻辑不涉及接口外的对象状态累积或变迁即可。




## HTTP幂等理解




基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。HTTP协议是一种分布式的面向资源的网络应用层协议，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web
 API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。

### 幂等性定义

HTTP幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：

    Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.

从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。

### 分布式事务 vs 幂等设计

为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：




```java
boolean withdraw(account_id, amount);//非幂等取款操作
```


withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：



![](https://img-blog.csdn.net/20170322141504541)


图1


这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。


另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：



```java
int create_ticket();// 获取请求序列ticket_id（实际上是一个请求序列号Sequence），由服务端提供

boolean idempotent_withdraw(ticket_id, account_id, amount);//实现了幂等性的取款操作，使用服务端提供的ticket_id，实际上是一个请求序列号Sequence
```


create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。



基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：

![](https://img-blog.csdn.net/20170322141415583)

图2


和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。

### HTTP幂等性

HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP
 GET、DELETE、PUT、POST四种主要方法的语义和幂等性。

**HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。**

比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

**HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。**


比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：


The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response
 SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.


The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If
 the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.


**POST所对应的URI并非创建的资源本身，而是资源的接收者，POST方法不具备幂等性。**

比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。

**PUT所对应的URI是要创建或更新的资源本身，PUT方法具有幂等性。**

比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。


在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。

用POST /tickets来实现create_ticket；

用PUT /accounts/account_id/ticket_id&amount=xxx来实现idempotent_withdraw。

值得注意的是：严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。

理解：非幂等操作的副作用问题处理一般采用服务器端生成一个请求序列号Sequence，客户端使用序列号Sequence作为幂等操作的凭据去实现方法内幂等操作。图1和图2描述的就是这么一个过程。另外对于HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性做了相应的说明和纠正。




## 实现幂等设计的方法




### 查询操作

查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作。


### 删除操作

删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)。



### 唯一索引，防止新增脏数据

比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。


要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。



### Token机制，防止页面重复提交

**业务要求：**

页面的数据只能被点击提交一次
**发生原因：**

由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
**解决办法：**

集群环境：采用token加redis（redis单线程的，处理需要排队）

单JVM环境：采用token加redis或token加jvm内存
**处理流程：**

1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间

2. 提交后后台校验token，同时删除token，生成新的token返回
**Token特点：**

要申请，一次有效性，可以限流。

注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用.

### 悲观锁

获取数据的时候加锁获取

select * from table_xxx where id='xxx' for update;

注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的，悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。



### 乐观锁

乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。


乐观锁的实现方式多种多样可以通过version或者其他状态条件：
**1. 通过版本号实现**

`update table_xxx set name=#name#,version=version+1 where version=#version#`
**2. 通过条件限制**
`update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0`


要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。

注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好


```
update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#
update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# a
```



### 分布式锁

还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。

要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)。



### select + insert

并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了
注意：核心高并发流程不要用这种方法。



### 状态机幂等

在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。

注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。


### 对外提供接口的api如何保证幂等

如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)

重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。


### SOA重复消息幂等设计

重复消息是SOA服务实现中非常常见的问题，你永远不要指望调用方每次请求消息不一样，对于读操作，重复消息可能无害，可对于写操作很可能就是灾难。可以通过幂等(Idempotent)模式处理重复的消息，基本处理思路是：

1、调用者给消息一个唯一请求ID标识。ID标识一个工作单元，这个工作单元只应执行一次，工作单元ID可以是Schema的一部分，也可以是一个定制的SOAP Header，服务的Contract 可以说明这个唯一请求ID标识是必须的；

2、接收者在执行一个工作单元必须先检验该工作单元是否已经执行过。检查是否执行的逻辑通常是根据唯一请求ID ，在服务端查询请求是否有记录，是否有对应的响应信息，如果有，直接把响应信息查询后返回；如果没有，那么就当做新请求去处理。



## 参考资料




百度百科-幂等：[http://baike.baidu.com/link?url=LL3VHg4dEBkgOF9yBbOs_TSYPNIHypc9-6uC3JBvelFAW8_gdkm5U1Z6A0HY9xi15Yc0S6rG5_aYhOX6fPN0horHULDvNnsBr5Q6DCPaWl7](http://baike.baidu.com/link?url=LL3VHg4dEBkgOF9yBbOs_TSYPNIHypc9-6uC3JBvelFAW8_gdkm5U1Z6A0HY9xi15Yc0S6rG5_aYhOX6fPN0horHULDvNnsBr5Q6DCPaWl7)


[](http://blog.csdn.net/rnzuozuo/article/details/40383293)


理解HTTP幂等性：[http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html](http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html)

[](http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html)

分布式系统接口幂等性：[http://blog.brucefeng.info/post/api-idempotent](http://blog.brucefeng.info/post/api-idempotent)或：[http://www.360doc.com/content/16/0428/09/21340737_554437264.shtml](http://www.360doc.com/content/16/0428/09/21340737_554437264.shtml)




高并发的核心技术-幂等的实现方案：[http://825635381.iteye.com/blog/2276077](http://825635381.iteye.com/blog/2276077)




