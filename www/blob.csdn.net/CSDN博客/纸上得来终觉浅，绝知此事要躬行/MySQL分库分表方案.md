# MySQL分库分表方案 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客





2019年01月26日 23:29:16[boonya](https://me.csdn.net/boonya)阅读数：902








**目录**

[一、Mysql分库分表方案](#%E4%B8%80%E3%80%81Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88)

[1.为什么要分表：](#1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%A1%A8%EF%BC%9A)

[2. mysql proxy：amoeba](#2.%C2%A0mysql%C2%A0proxy%EF%BC%9Aamoeba)

[3.大数据量并且访问频繁的表，将其分为若干个表](#3.%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B9%B6%E4%B8%94%E8%AE%BF%E9%97%AE%E9%A2%91%E7%B9%81%E7%9A%84%E8%A1%A8%EF%BC%8C%E5%B0%86%E5%85%B6%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E4%B8%AA%E8%A1%A8)

[4. 利用merge存储引擎来实现分表](#4.%C2%A0%E5%88%A9%E7%94%A8merge%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E8%A1%A8)

[二、数据库架构](#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84)

[1、简单的MySQL主从复制:](#1%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%3A)

[2、MySQL垂直分区](#2%E3%80%81MySQL%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA)

[3、MySQL水平分片（Sharding）](#3%E3%80%81MySQL%E6%B0%B4%E5%B9%B3%E5%88%86%E7%89%87%EF%BC%88Sharding%EF%BC%89)

[①单库单表](#%E2%91%A0%E5%8D%95%E5%BA%93%E5%8D%95%E8%A1%A8%C2%A0)

[②单库多表](#%E2%91%A1%E5%8D%95%E5%BA%93%E5%A4%9A%E8%A1%A8%C2%A0)

[③多库多表](#%E2%91%A2%E5%A4%9A%E5%BA%93%E5%A4%9A%E8%A1%A8)

[四、分库分表规则](#%E5%9B%9B%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%84%E5%88%99%C2%A0)

[1.   分库分表维度的问题](#1.%C2%A0%C2%A0%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%BB%B4%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0)

[2.   联合查询的问题](#2.%C2%A0%C2%A0%20%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0)

[3.   避免跨库事务](#3.%C2%A0%C2%A0%20%E9%81%BF%E5%85%8D%E8%B7%A8%E5%BA%93%E4%BA%8B%E5%8A%A1)

[4.   尽量把同一组数据放到同一DB服务器上](#4.%C2%A0%C2%A0%20%E5%B0%BD%E9%87%8F%E6%8A%8A%E5%90%8C%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E6%94%BE%E5%88%B0%E5%90%8C%E4%B8%80DB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A)

[5.一主多备](#5.%E4%B8%80%E4%B8%BB%E5%A4%9A%E5%A4%87)

[五、MySQL使用为什么要分库分表](#%E4%BA%94%E3%80%81MySQL%E4%BD%BF%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8)

[六、最近研究分布式数据库架构，发现排序、分组及分页让着实人有点头疼。现把问题及解决思路整理如下。](#%E5%85%AD%E3%80%81%E6%9C%80%E8%BF%91%E7%A0%94%E7%A9%B6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%88%86%E7%BB%84%E5%8F%8A%E5%88%86%E9%A1%B5%E8%AE%A9%E7%9D%80%E5%AE%9E%E4%BA%BA%E6%9C%89%E7%82%B9%E5%A4%B4%E7%96%BC%E3%80%82%E7%8E%B0%E6%8A%8A%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86%E5%A6%82%E4%B8%8B%E3%80%82)

[1.多分片（水平切分）返回结果合并（排序）](#1.%E5%A4%9A%E5%88%86%E7%89%87%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%EF%BC%89%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89)

[①Select + None Aggregate Function的有序记录合并排序](#%E2%91%A0Select%20%2B%20None%20Aggregate%20Function%E7%9A%84%E6%9C%89%E5%BA%8F%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%C2%A0)

[②Select + None Aggregate Function的无序记录合并](#%E2%91%A1Select%20%2B%20None%20Aggregate%20Function%E7%9A%84%E6%97%A0%E5%BA%8F%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6)

[③Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。](#%E2%91%A2Select%20%2B%20Aggregate%20Function%E7%9A%84%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89Oracle%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%9ACount%E3%80%81Max%E3%80%81Min%E3%80%81Avg%E3%80%81Sum%E3%80%82)

[2.多分片（水平切分）返回结果分页](#2.%E5%A4%9A%E5%88%86%E7%89%87%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%EF%BC%89%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%88%86%E9%A1%B5)

[3.多分片（水平切分）查询有分组语法的合并](#3.%E5%A4%9A%E5%88%86%E7%89%87%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%9C%89%E5%88%86%E7%BB%84%E8%AF%AD%E6%B3%95%E7%9A%84%E5%90%88%E5%B9%B6)

[①Group By Having + None Aggregate Function时](#%E2%91%A0Group%20By%20Having%20%2B%20None%20Aggregate%20Function%E6%97%B6)

[②Group By Having + Aggregate Function时](#%E2%91%A1Group%20By%20Having%20%2B%20Aggregate%20Function%E6%97%B6)

[4.分布式数据库架构--排序分组分页参考解决方案](#4.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84--%E6%8E%92%E5%BA%8F%E5%88%86%E7%BB%84%E5%88%86%E9%A1%B5%E5%8F%82%E8%80%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)

[5.小结](#5.%E5%B0%8F%E7%BB%93)

# 一、Mysql分库分表方案

## 1.为什么要分表：

当一张表的数据达到几千万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。

mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。

## 2. mysql proxy：amoeba

做mysql集群,利用amoeba。

从上层的java程序来讲，不需要知道主[服务器](https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)和从服务器的来源，即主从数据库服务器对于上层来讲是透明的。可以通过amoeba来配置。

## 3.大数据量并且访问频繁的表，将其分为若干个表

比如对于某网站平台的数据库表-公司表，数据量很大，这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。

     某网站现在的数据量至多是5000万条，可以设计每张表容纳的数据量是500万条，也就是拆分成10张表，

那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当<500万条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作。

## 4. 利用merge存储引擎来实现分表

如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了。用merge存储引擎来实现分表, 这种方法比较适合.

举例子：

![](http://static.oschina.net/uploads/img/201402/13104102_slb1.jpg)

# 二、数据库架构

## 1、简单的MySQL主从复制:

MySQL的主从复制解决了数据库的读写分离，并很好的提升了读的性能，其图如下：

![](http://static.oschina.net/uploads/img/201402/13104102_nxBO.jpg)

其主从复制的过程如下图所示：

![](http://static.oschina.net/uploads/img/201402/13104103_7YzJ.jpg)

但是，主从复制也带来其他一系列性能瓶颈问题：
- 写入无法扩展
- 写入无法缓存
- 复制延时
- 锁表率上升
- 表变大，缓存率下降

那问题产生总得解决的，这就产生下面的优化方案，一起来看看。

## 2、MySQL垂直分区

   如果把业务切割得足够独立，那把不同业务的数据放到不同的数据库服务器将是一个不错的方案，而且万一其中一个业务崩溃了也不会影响其他业务的正常进行，并且也起到了负载分流的作用，大大提升了数据库的吞吐能力。经过垂直分区后的数据库架构图如下：

![](http://static.oschina.net/uploads/img/201402/13104103_CHZw.jpg)

然而，尽管业务之间已经足够独立了，但是有些业务之间或多或少总会有点联系，如用户，基本上都会和每个业务相关联，况且这种分区方式，也不能解决单张表数据量暴涨的问题，因此为何不试试水平分割呢？

## 3、MySQL水平分片（Sharding）

这是一个非常好的思路，将用户按一定规则（按id哈希）分组，并把该组用户的数据存储到一个数据库分片中，即一个sharding，这样随着用户数量的增加，只要简单地配置一台服务器即可，原理图如下：

![](http://static.oschina.net/uploads/img/201402/13104104_2qZP.jpg)

如何来确定某个用户所在的shard呢，可以建一张用户和shard对应的数据表，每次请求先从这张表找用户的shard id，再从对应shard中查询相关数据，如下图所示：

![](http://static.oschina.net/uploads/img/201402/13104105_7oa0.jpg)

### ①单库单表 

单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。 

### ②单库多表 

随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 


可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 

### ③多库多表

随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 



# 四、分库分表规则 

设计表的时候需要确定此表按照什么样的规则进行分库分表。例如，当有新用户时，程序得确定将此用户信息添加到哪个表中；同理，当登录的时候我们得通过用户的账号找到数据库中对应的记录，所有的这些都需要按照某一规则进行。 

路由 


通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id mod 4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id mod 4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 mod 4后确定记录在User_0003中。 

分库分表产生的问题，及注意事项 

## 1.   分库分表维度的问题 

假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的 购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找 到买人的交易记录比较麻烦。 


所以常见的解决方式有： 
- 通过扫表的方式解决，此方法基本不可能，效率太低了。
- 记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。
- 通过搜索引擎解决，但如果实时性要求很高，又得关系到实时搜索。 

## 2.   联合查询的问题 

联合查询基本不可能，因为关联的表有可能不在同一数据库中。 

## 3.   避免跨库事务

避免在一个事务中修改db0中的表的时候同时修改db1中的表，一个是操作起来更复杂，效率也会有一定影响。 

## 4.   尽量把同一组数据放到同一DB服务器上

例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。 

## 5.一主多备

在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.                                                       


所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 

此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。 

所以
- 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。
- 当写压力很大的时候，就必须得进行分库操作。 



# 五、MySQL使用为什么要分库分表

可以用说用到MySQL的地方,只要数据量一大, 马上就会遇到一个问题,要分库分表. 这里引用一个问题为什么要分库分表呢?MySQL处理不了大的表吗? 其实是可以处理的大表的.我所经历的项目中单表物理上文件大小在80G多,单表记录数在5亿以上,而且这个表 属于一个非常核用的表:朋友关系表. 


但这种方式可以说不是一个最佳方式. 因为面临文件系统如[Ext3文件](https://www.baidu.com/s?wd=Ext3%E6%96%87%E4%BB%B6&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)系统对大于大文件处理上也有许多问题. 这个层面可以用xfs文件系统进行替换.但MySQL单表太大后有一个问题是不好解决: 表结构调整相关的操作基 

本不在可能.所以大项在使用中都会面监着分库分表的应用. 


从Innodb本身来讲数据文件的Btree上只有两个锁, 叶子节点锁和子节点锁,可以想而知道,当发生页拆分或是添加新叶时都会造成表里不能写入数据.所以分库分表还就是一个比较好的选择了. 

**那么分库分表多少合适呢? **

经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数据字型的保持在800万条记录以下, 有字符型的单表保持在500万以下. 


如果按 100库100表来规划,如用户业务: 500万*100*100 = 50000000万 = 5000亿记录. 


心里有一个数了,按业务做规划还是比较容易的.

分布式数据库架构--排序、分页、分组、实现



# 六、最近研究分布式数据库架构，发现排序、分组及分页让着实人有点头疼。现把问题及解决思路整理如下。

## 1.多分片（水平切分）返回结果合并（排序）

### ①Select + None Aggregate Function的有序记录合并排序 

解决思路：对各分片返回的有序记录，进行排序去重合并。此处主要是编写排序去重合并算法。

### ②Select + None Aggregate Function的无序记录合并

解决思路：对各分片返回的无序记录，进行去重合并。
- 优点：实现比较简单。
-  缺点：数据量越大，字段越多，去重处理就会越耗时。

### ③Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。
- AF：Max、Min
	- 思路：通过算法对各分片返回结果再求max、min值。

- AF：Avg、Sum、Count
	- 思路：分片间无重复记录或字段时，通过算法对各分片返回结果再求avg、sum、count值。分片间有重复记录或字段时，先对各分片记录去重合并，再通过算法求avg、sum、count值。


比如：

```
select count(*) from user

select count(deptno) from user;

select count(distinct deptno) from user;
```

## 2.多分片（水平切分）返回结果分页

解决思路：合并各分片返回结果，逻辑分页。

        优点：  实现简单。

        缺点：  数据量越大，缓存压力就越大。

                     分片数据量越大，查询也会越慢。

## 3.多分片（水平切分）查询有分组语法的合并

### ①Group By Having + None Aggregate Function时
- Select + None Aggregate Function
	- 比如：select job user group by job;
- 思路：直接去重（排序）合并。

- Select + Aggregate Function
	- 比如：select max(sal),job user group by job;
- 思路：同Select + Aggregate Function的记录合并（排序）。


### ②Group By Having + Aggregate Function时

解决思路：去掉having AF条件查询各分片，然后把数据放到一张表里。再用group by having 聚合函数查询。

## 4.分布式数据库架构--排序分组分页参考解决方案
- 解决方案1：Hadoop + Hive。
	- 思路：使用Hadoop HDFS来存储数据，通过Hdoop MapReduce完成数据计算，通过Hive HQL语言使用部分与RDBBS一样的表格查询特性和分布式存储计算特性。
- 优点：

- - 可以解决问题
- 具有并发处理能力
- 可以离线处理

- - 缺点： 

- - 实时性不能保证
- 网络延迟会增加
- 异常捕获难度增加
- Web应用起来比较复杂

- 解决方案2：总库集中查询。
	- 优点：

- - 可以解决问题
- 实现简单

- - 缺点：

- - 总库数据不能太大
- 并发压力大


## 5.小结

对 于分布式数据库架构来说，排序、分页、分组一直就是一个比较复杂的问题。避免此问题需要好好地设计分库、分表策略。同时根据特定的场景来解决问题。也可以 充分利用[海量数据](https://www.baidu.com/s?wd=%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)存储（Hadoop-HDFS|Hive|HBse）、搜索引擎（Lucene|Solr）及分布式计算（MapReduce）等技术来 解决问题。

别外，也可以用NoSQL技术替代关系性数据库来解决问题，比如MogonDB\redis。



