# Hash散列存储 - 纸上得来终觉浅，绝知此事要躬行 - CSDN博客





2015年02月11日 15:04:58[boonya](https://me.csdn.net/boonya)阅读数：1277








#### 什么是散列存储

散列存储，又称hash存储，是一种力图将[数据元素](http://baike.baidu.com/view/38785.htm)的存储

![hash](http://e.hiphotos.baidu.com/baike/s%3D250/sign=b7d0c6c7d462853596e0d524a0ef76f2/fc1f4134970a304e099f1ccfd0c8a786c9175c41.jpg)hash
位置与关键码之间建立确定对应关系的查找技术。[散列法](http://baike.baidu.com/view/2010063.htm)存储的基本思想是：由[节点](http://baike.baidu.com/view/47398.htm)的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。





#### 散列存储的特点

散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为O(1)，而数组遍历的时间复杂度为O(n)。

散列是能一种快速实现访问的存储方式。通常作为检索部分的数据项是整形或者字符串，当是字符串时，字符串的数量要远远大于数组的长度，这时候就会有多个字符串映射到一个存储位置的情况，这就是所谓的冲突问题，而且冲突时肯定存在的，这时候如何实现数据的存储又是需要解决的。




#### 散列存储的分类



##### 采用链表的形式



目前主要的解决方式有两大类，第一种采用链表的形式，将所有冲突的数据项采用链表的形式链接起来，这样搜索数据的复杂度就包含了链表的遍历问题，特别是当所有的项都链接到一个链表下时，这时候实际上就是遍历链表，复杂度并不一定有很大的进步，但是这种链表链接的方式有很高的填充率。


#####    探测法探测空闲的空间


第二种就是充分利用没有实现的存储空间，利用探测法探测空闲的空间，进而实现数据的存储，目前有三种探测方式：线性探测法、平方探测法，以及双散列法，三种方式中平方探测法运用比较多，但是都存在各种各样的优缺点，这时候的散列搜索优势就没有理想情况下那么明显。有时候甚至比遍历数组更加的慢。但是确实不失为一种处理方式。

#### Hash存储中的冲突解决

映射函数可选择的比较多，其实完全可以定义自己的映射函数，但是有时候为了降低冲突的概率设置了一些比较好的映射函数，比如求和取余，或者乘以一定的系数再求和取余等。（具体代码可以参见原文）
以上内容来自：[http://baike.baidu.com/link?url=qWw3WByeUEhcXX7Y0zj7JRRlHBeKLRdwK7Somq7fkbDLDS-W1nLzfYZ-Ecq0omaeCQ_gCiLPORa_JD6InIKuDK](http://baike.baidu.com/link?url=qWw3WByeUEhcXX7Y0zj7JRRlHBeKLRdwK7Somq7fkbDLDS-W1nLzfYZ-Ecq0omaeCQ_gCiLPORa_JD6InIKuDK)


#### Hash的生成演示

设要存储对象的个数为num, 那么我们就用len个内存单元来存储它们(len>=num); 以每个对象ki的关键字为自变量，用一个函数h(ki)来映射出ki的内存地址，也就是ki的下标，将ki对象的元素内容全部存入这个地址中就行了。这个就是Hash的基本思路。

Hash为什么这么想呢？换言之，为什么要用一个函数来映射出它们的地址单元呢？

This is a good question.明白了这个问题，Hash不再是问题。下面我就通俗易懂地向你来解答一下这个问题。

现在我要存储4个元素 13 7 14 11

显然，我们可以用数组来存。也就是：a[1] = 13; a[2] = 7; a[3] = 14; a[4] = 11;

当然，我们也可以用Hash来存。下面给出一个简单的Hash存储：

先来确定那个函数。我们就用h(ki) = ki%5;(这个函数不用纠结，我们现在的目的是了解为什么要有这么一个函数)。

对于第一个元素 h(13) = 13%5 = 3; 也就是说13的下标为3；即Hash[3] = 13;

对于第二个元素 h(7) = 7 % 5 = 2; 也就是说7的下标为2; 即Hash[2] = 7;

同理，Hash[4] = 14; Hash[1] = 11;

好了，存现在是存好了。但是，这并没有体现出Hash的妙处，也没有回答刚才的问题。下面就来揭开它神秘的面纱吧。

现在我要你查找11这个元素是否存在。你会怎么做呢？当然，对于数组来说，那是相当的简单，一个for循环就可以了。

也就是说我们要找4次。

下面我们来用Hash找一下。

首先，我们将要找的元素11代入刚才的函数中来映射出它所在的地址单元。也就是h(11) = 11%5 = 1 了。下面我们来比较一下Hash[1]?=11, 这个问题就很简单了。也就是说我们就找了1次。这个就是Hash的妙处了。至此，刚才的问题也就得到了解答。至此，你也就彻底的明白了Hash了。

以上内容来自：[http://www.nowamagic.net/librarys/veda/detail/799](http://www.nowamagic.net/librarys/veda/detail/799)






