# 递归算法转换为非递归算法的技巧 - 算法与数学之美 - CSDN博客
2017年11月22日 00:00:00[算法与数学之美](https://me.csdn.net/FnqTyr45)阅读数：940
递归函数具有很好的可读性和可维护性，但是大部分情况下程序效率不如非递归函数，所以在程序设计中一般喜欢先用递归解决问题，在保证方法正确的前提下再转换为非递归函数以提高效率。
函数调用时，需要在栈中分配新的帧，将返回地址，调用参数和局部变量入栈。所以递归调用越深，占用的栈空间越多。如果层数过深，肯定会导致栈溢出，这也是消除递归的必要性之一。递归函数又可以分为尾递归和非尾递归函数，前者往往具有很好的优化效率，下面我们分别加以讨论。
**尾递归函数**
尾递归函数是指函数的最后一个动作是调用函数本身的递归函数，是递归的一种特殊情形。尾递归具有两个主要的特征：
> 
  1. 调用自身函数(Self-called)；
  2. 计算仅占用常量栈空间(Stack Space)。
为什么尾递归可以做到常量栈空间，我们用著名的fibonacci数列作为例子来说明。
fibonacci数列实现方法一般是这样的，
![640?wx_fmt=png&wxfrom=5&wx_lazy=1](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuRtSOYicLJCorYZqBHsQ5kqBg5k3UH1kJV2h1RlOFgZM32myhudic6DBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1)
不过需要注意的是这种实现方法并不是尾递归，因为尾递归的最后一个动作必须是调用自身，这里最后的动作是加法运算，所以我们要修改一下，
![640?wx_fmt=png&wxfrom=5&wx_lazy=1](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuQF4boHMDln8k5icAiaBAP2vRLUSo4X4STg0p7AHoF1ghsJbwKo8LEJJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1)
好了，现在符合尾递归的定义了，用gcc分别加-O和-O2选项编译，下面是部分汇编代码，
**-O2汇编代码**
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuVZ8IWV5amwltN3zMicnJAXOK56TjJSwfYQyIjibwv1zTYibvmPo0C64tQ/0?wx_fmt=png)
**-O汇编代码**
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuujRiaUQ6ZuGX3TLOJJ2loDibHamTHmJOGe1VPN7npOmdGgdP4W0e6sc4g/0?wx_fmt=png)
可以看到-O2时用了jne命令，每次调用下层递归并没有申请新的栈空间，而是更新当前帧的局部数据，重复使用当前帧，所以不管有多少层尾递归调用都不会栈溢出，这也是使用尾递归的意义所在。
而-O使用的是call命令，这会申请新的栈空间，也就是说gcc默认状态下并没有优化尾递归，这么做的一个主要原因是有时候我们需要保留帧信息用于调试，而加-O2优化后，不管多少层尾递归调用，使用的都是第一层帧，是得不到当前帧的信息的，大家可以用gdb调试下就知道了。
**除了尾递归，Fibonacci数列很容易推导出循环实现方式，**
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuu6PRvQk6hXIvESHcaqnvboXKUCVAVTzqyibuHC8POtw3w8DIhQWcPC2A/0?wx_fmt=png)
 在我的机器上，全部加-O2选项优化编译，运行时间如下（单位微秒）
|n|fibonacciNonRecur|FibonacciTailRecur|FibonacciRecur|
|----|----|----|----|
|20|1|1|123|
|30|1|1|14144|
将fibonacci函数的迭代，尾递归和递归函数性能比较，可以发现迭代和尾递归时间几乎一致，n的大小对迭代和尾递归运行时间影响很小，因为只是多执行O（n）条机器指令而已。但是n对递归函数影响非常大，这是由于递归需要频繁分配回收栈空间所致。正是由于尾递归的高效率，在一些语言如lua中就明确建议使用尾递归（参照《lua程序设计第二版》第6章）。
**非尾递归函数**
编译器无法自动优化一般的递归函数，不过通过模拟递归函数的过程，我们可以借助于栈将任何递归函数转换为迭代函数。直观点，递归的过程其实是编译器帮我们处理了压栈和出栈的操作，转换为迭代函数就需要手动地处理压栈和出栈。
下面我们以经典的快速排序为例子。
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuudbSgnp606YOzUJBibaUtOticZpJOC2cljMZKgVKRLCzMMqwE6UM9ExcA/0?wx_fmt=png)
其实不难看出快速排序的递归算法就是一个二叉树的先序遍历过程，先处理当前根节点，然后依次处理左子树和右子树。将快速排序递归算法转换为非递归相当于将二叉树先序遍历递归算法转为非递归算法。
**二叉树先序遍历递归算法伪码**
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuwIp7btVg5mdgZEROdrHXcOibvT2SCXicJB3oxdUDyuNG537fQLxvpPxw/0?wx_fmt=png)
**二叉树先序遍历非递归伪码**
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuqF5U5rpTpib5BYpp2nOqCibFBFqUjkiaakJMBBR2rbZC5Nta6lGKLDlyw/0?wx_fmt=png)
每次处理完当前节点后将右子树和左子树分别入栈，类似地，我们也很容易得到快速排序的非递归算法实现。partition将数组分为左右两部分，相当与处理当前节点，接下来要做的就是将左右子树入栈，那么左右子树需要保存什么信息呢？这个是处理非递归函数的关键，因为被调用函数信息需要压入栈中。快速排序只需要保存子数组的边界即可。
![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkz2OQMFIL9QKpfOibJ3dQibuuoEwF1bjkLSa2CRZic6IzhaicfBPIicAdx3ejyICDeWWbpCqYWN6dP4FPA/0?wx_fmt=png)
**总结**
虽然将递归函数转换为迭代函数可以提高程序效率，但是转换后的迭代函数往往可读性差，难以理解，不易维护。所以只有在特殊情况下，比如对栈空间有严格要求的嵌入式系统，才需要转换递归函数。大部分情况下，递归并不会成为系统的性能瓶颈，一个代码简单易读的递归函数常常比迭代函数更易维护。
Reference：
https://secweb.cs.odu.edu/~zeil/cs361/web/website/Lectures/recursionConversion/page/recursionConversion.html
http://en.wikipedia.org/wiki/Tail_Recursion
http://c2.com/cgi/wiki?TailRecursion
http://c2.com/cgi/wiki?RecursionVsLoop
> 
作者：coderkian
来源：http://www.cnblogs.com/coderkian/
**---****------**
**等的就是你，真的超有趣！高能金融抱团群发车啦~******加我拉你进群呦****
**![640?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkyJCDnjGtGFUOmOAE2SZY1zvIueyhic76aNgYN38xwV6XE9y6tSzCTFYianCf1YgCrfeNqconWV5RhQ/640?wx_fmt=png)**
**算法数学之美微信公众号欢迎赐稿**
**稿件涉及数学、物理、算法、计算机、编程等相关领域。**
**稿件一经采用，我们将奉上稿酬。**
**投稿邮箱：math_alg@163.com商务合作：联系微信号hengzi5809**
