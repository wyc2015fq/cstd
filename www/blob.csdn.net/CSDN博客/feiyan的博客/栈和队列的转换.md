# 栈和队列的转换 - feiyan的博客 - CSDN博客












2018年02月08日 22:02:43[feiyanaffection](https://me.csdn.net/feiyanaffection)阅读数：93








## 1. 用两个栈实现队列

（1）问题分析：用栈实现队列等价于用**后进先出**的特性实现**先进先出**的特性！ 

（2）实现思路：准备两个栈用于实现队列**stack_in**和**stack_out**,当有新元素时，将其压入stack_in；当需要出队列时，将stack_in中的元素逐一弹出压入stack_out中，然后将stack_out的栈顶元素弹出。 

（3）解决方案： 
![这里写图片描述](https://img-blog.csdn.net/20180208205307403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpeWFuYWZmZWN0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（4）代码实现：
```cpp
#include <iostream>
#include "LinkStack.h"

using namespace std;
using namespace MyLib;

template <typename T>
class StackToQueue : public Queue<T>
{
protected:
    mutable LinkStack<T> m_stack_in;
    mutable LinkStack<T> m_stack_out;
    // move()函数用于将stack_in中的元素移动到stack_out中去
    void move() const
    {
        if(m_stack_out.size() == 0)
        {
            while(m_stack_in.size() > 0)
            {
                m_stack_out.push(m_stack_in.top());
                m_stack_in.pop();
            }
        }
    }

public:
    void add(const T& e)
    {
        m_stack_in.push(e);
    }

    void remove()
    {
        move();

        if(m_stack_out.size() > 0)
        {
            m_stack_out.pop();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue...");
        }
    }

    T front() const
    {
        move();

        if(m_stack_out.size() > 0)
        {
            return m_stack_out.top();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue...");
        }
    }

    void clear()
    {
        m_stack_in.clear();
        m_stack_out.clear();
    }

    int length() const
    {
        return m_stack_in.size() + m_stack_out.size();
    }
};

int main(int argc, char* const argv[])
{
    StackToQueue<int> sq;

    for(int i=0; i<10; i++)
    {
        sq.add(i);
    }

    while(sq.length() > 0)
    {
        cout << sq.front() << endl;

        sq.remove();
    }

    return 0;
}
```

（5）实现结果：实现了将栈的**后进先出**特性转换为**先进先出**特性。 
![这里写图片描述](https://img-blog.csdn.net/20180208212151543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpeWFuYWZmZWN0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
## 2. 用两个队列实现栈

（1）问题分析：用队列实现栈等价于用**先进先出**特性实现**后进先出**特性。 

（2）实现思路：准备两个队列，进队列queue_1和出队列queue_2,当有新元素入栈时，将其加入进队列queue_1;当需要出栈时，将进队列queue_1中的前n-1个元素出去到出队列queue_2中，然后将进队列queue_1中的最后一个元素出去（即出栈），最后交换两个队列的角色，进队列变成出队列，出队列变成进队列，重复循环，实现栈的模拟。 

（3）解决方案： 
![这里写图片描述](https://img-blog.csdn.net/20180208213624746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpeWFuYWZmZWN0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（4）代码实现：
```cpp
#include <iostream>
#include "LinkQueue"

using namespace std;
using namespace MyLib;

template <typename T>
class QueueToStack : public Stack<T>
{
protected:
    LinkQueue<T> m_queue_1;
    LinkQueue<T> m_queue_2;
    LinkQueue<T>* m_pIn;
    LinkQueue<T>* m_pOut;

    // 将进队列里面的前n-1个元素移动到出队列里面去，然后进队列里面剩下了1个元素
    void move() const
    {
        int n = m_pIn->length() - 1;

        for(int i=0; i<n; i++)
        {
            m_pOut->add(m_pIn->front());
            m_pIn->remove();
        }
    }
    // 交换两个队列的角色，即为交换两个指针的值
    void swap()
    {
        LinkQueue<T>* temp = NULL;
        temp = m_pIn;
        m_pIn = m_pOut;
        m_pOut = temp;
    }

public:
    QueueToStack()
    {
        m_pIn = &m_queue_1;
        m_pOut = &m_queue_2;
    }

    void push(const T &e)
    {
        m_pIn->add(e);
    }

    void pop()
    {
        if(m_pIn->length() > 0)
        {
            move();

            m_pIn->remove();

            swap();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current stack...");
        }
    }

    T top() const
    {
        if(m_pIn->length() > 0)
        {
            move();

            return m_pIn->front();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current stack...");
        }
    }

    void clear()
    {
        m_queue_1.clear();
        m_queue_2.clear();
    }

    int size() const
    {
        return m_queue_1.length() +m_queue_2.length();
    }
};

int main(int argc, char* const argv[])
{
    QueueToStack<int> qs;

    for(int i=0; i<10; i++)
    {
        qs.push(i);
    }

    while(qs.size() > 0)
    {
        cout << qs.top() << endl;

        qs.pop();
    }

    return 0;
}
```

（5）实现结果：用两个队列实现了将**先进先出**特性转换为**后进先出**特性. 
![这里写图片描述](https://img-blog.csdn.net/20180208220125360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpeWFuYWZmZWN0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)







