# 各种基本排序算法全方面比较 - 一个跳popping的quant的博客 - CSDN博客





2018年10月29日 19:38:02[敲代码的quant](https://me.csdn.net/FrankieHello)阅读数：708







||时间复杂度           （平均 最好 最坏）|空间复杂度|稳定性|一趟排序能否使待排序元素达到最后位置|排序趟数和原始序列是否有关|比较次数和原始序列是否有关| | |
|----|----|----|----|----|----|----|----|----|
|直接插入排序|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(n)](https://private.codecogs.com/gif.latex?O%28n%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|稳定|否|无关|有关|
|折半插入排序|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|稳定|否|无关|无关|
|希尔排序|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|不稳定|否|无关|有关|
|冒泡排序|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(n)](https://private.codecogs.com/gif.latex?O%28n%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|稳定|能|有关|有关|
|快速排序|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(log_{2}n)](https://private.codecogs.com/gif.latex?O%28log_%7B2%7Dn%29)|不稳定|能|有关|有关|
|简单选择排序|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|不稳定|能|无关|无关|
|堆排序|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(1)](https://private.codecogs.com/gif.latex?O%281%29)|不稳定|能|无关|有关|
|二路归并排序|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)|![O(n)](https://private.codecogs.com/gif.latex?O%28n%29)|稳定|否|无关|有关|
|基数排序|![O(d(n+r_{d}))](https://private.codecogs.com/gif.latex?O%28d%28n&plus;r_%7Bd%7D%29%29)|![O(d(n+r_{d}))](https://private.codecogs.com/gif.latex?O%28d%28n&plus;r_%7Bd%7D%29%29)|![O(d(n+r_{d}))](https://private.codecogs.com/gif.latex?O%28d%28n&plus;r_%7Bd%7D%29%29)|![O(r_{d})](https://private.codecogs.com/gif.latex?O%28r_%7Bd%7D%29)|稳定|否|无关|有关|

以上排序方法每种颜色分别对应一类排序。

**时间复杂度**

从平均时间复杂度的角度来看，希尔排序、快速排序、堆排序和二路归并排序的时间复杂度最低，都是![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)，其余除了基数排序比较特殊是![O(d(n+r_{d}))](https://private.codecogs.com/gif.latex?O%28d%28n&plus;r_%7Bd%7D%29%29)之外，其他的都是![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)。

时间复杂度最坏的情况下，除了快速排序是![O(n^{2})](https://private.codecogs.com/gif.latex?O%28n%5E%7B2%7D%29)之外，其余的都和它们的平均时间复杂度一样。

时间复杂度最好的情况下，直接插入排序和冒泡排序变为![O(n)](https://private.codecogs.com/gif.latex?O%28n%29)，前提是**初始序列是已经有序**。

**空间复杂度**

空间复杂度几个特殊的情况，快速排序是![O(log_{2}n)](https://private.codecogs.com/gif.latex?O%28log_%7B2%7Dn%29)，归并排序是![O(n)](https://private.codecogs.com/gif.latex?O%28n%29)，基数排序是![O(r_{d})](https://private.codecogs.com/gif.latex?O%28r_%7Bd%7D%29)，其他的都是![O(1)](https://private.codecogs.com/gif.latex?O%281%29)。

**稳定性**

快速排序、希尔排序、简单选择排序、堆排序是不稳定的。

**一趟排序能否使待排序元素达到最后位置**

冒泡排序经过一轮的排序，可以将待排序的元素通过不断的交换，冒泡至其最终位置。

同样作为交换类排序的快速排序，每一轮的排序将待排序的元素左右边分别交换调整为比它大或者小的元素，从而使待排序元素达到最后位置。

简单选择排序一轮排序可以确定待排序元素最终所处的位置的下标，所以可以一趟排序就可以确定待排序元素的位置。

堆排序通过建立最大堆或者最小堆，之后交换根节点与最后一个叶节点，得到的就是待排序元素的最终位置。

**排序趟数和原始序列是否有关**

注意排序趟数和时间复杂度是不一样的。排序趟数可以理解为**最外层的大循环**。排序趟数和原始序列有关的只有交换类排序的冒泡排序和快速排序。

冒泡排序中如果原始序列在一轮排序中达到了flag==1的条件，也就是一轮排序中没有发生交换，那么排序就将结束。

快速排序的排序趟数和初始序列有关（待填）。

**比较次数和原始序列是否有关**

比较次数和原始序列无关的有简单选择排序和折半插入排序。

简单选择排序算法从代码中可以看出是两层循环，内层循环作用是比较，而无论初始序列如何，都是外层执行n次，内层执行n-1次，所以简单选择排序和原始序列无关。

折半插入排序在查找插入位置的时候用到了折半查找，折半查找每进行一次折半就需要进行一次比较，而且折半次数是一定的（low>high时结束），所以折半插入排序比较次数和原始序列无关。

**其他**

纵向比较，堆排序的最好和最坏的情况下时间复杂度都是![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)，而且在所有![O(nlog_{2}n)](https://private.codecogs.com/gif.latex?O%28nlog_%7B2%7Dn%29)时间复杂度下，堆排序的空间复杂度是最低的。另外，堆排序比较适用于待排序元素很多的情况下，如从10000元素中找出前10个最大的，而待排序元素较少的时候则不适用。



ref:《2019数据结构高分笔记》（天勤版本）



