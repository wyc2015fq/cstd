# 时间序列分析之相关性 - 一个跳popping的quant的博客 - CSDN博客





2019年02月20日 17:27:27[敲代码的quant](https://me.csdn.net/FrankieHello)阅读数：584
所属专栏：[时间序列分析](https://blog.csdn.net/column/details/34308.html)









**目录**

[方差 (Variance)](#%E6%96%B9%E5%B7%AE%20(Variance))

[相关系数 （Correlation）](#%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%20%EF%BC%88Correlation%EF%BC%89)

[自相关/序列相关 (Autocorrelation or Serial Correlation)](#%E8%87%AA%E7%9B%B8%E5%85%B3%2F%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3%20(Autocorrelation%20or%20Serial%20Correlation))

[两种时间序列的相关性](#%E4%B8%A4%E7%A7%8D%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7)

### 方差 (Variance)

设随机变量X的均值 E(X) = m，则描述 X 的取值和它的均值 m 之间的偏差程度大小的数字特征就是方差。

但是不能直接用 E(X - m) 来表示方差，因为 E(X - m) = E(X) - m = 0，X 的正负偏离彼此抵消了。所以先将 X - m 平方后再取其均值，也就是偏差的平方

![:\begin{center}Var(X) = E[X - E(X)]^{2}\end{center}](https://private.codecogs.com/gif.latex?%3A%5Cbegin%7Bcenter%7DVar%28X%29%20%3D%20E%5BX%20-%20E%28X%29%5D%5E%7B2%7D%5Cend%7Bcenter%7D)

协方差 (Covariance)

根据方差的定义，Var(X) = E[(X - E(X)) × (X - E(X))]，将其中的一个 X 和 E(X) 用另一个 变量Y表示，Var(X) = E[(X - E(X)) × (X - E(X))]，也就是

![:\begin{center} Cov(X, Y) = E[(X - E(X))(Y - E(Y))]\end{center}](https://private.codecogs.com/gif.latex?%3A%5Cbegin%7Bcenter%7D%20Cov%28X%2C%20Y%29%20%3D%20E%5B%28X%20-%20E%28X%29%29%28Y%20-%20E%28Y%29%29%5D%5Cend%7Bcenter%7D)

为了方便表示， ![\small E(X) = m_{1} , E(Y) = m_{2}, Var(X) = \sigma_{1}^{2},Var(Y) = \sigma_{2}^{2}](https://private.codecogs.com/gif.latex?%5Csmall%20E%28X%29%20%3D%20m_%7B1%7D%20%2C%20E%28Y%29%20%3D%20m_%7B2%7D%2C%20Var%28X%29%20%3D%20%5Csigma_%7B1%7D%5E%7B2%7D%2CVar%28Y%29%20%3D%20%5Csigma_%7B2%7D%5E%7B2%7D)

关于协方差有几个重要的定理：

1. 如果 X, Y相互独立，则 Cov(X, Y) = 0

2. ![\small [Cov(X, Y)]^{2}\leqslant \sigma_{1}^{2} \sigma_{2}^{2}](https://private.codecogs.com/gif.latex?%5Csmall%20%5BCov%28X%2C%20Y%29%5D%5E%7B2%7D%5Cleqslant%20%5Csigma_%7B1%7D%5E%7B2%7D%20%5Csigma_%7B2%7D%5E%7B2%7D)，当且仅当 X,Y 之间有严格线性关系的时候等号成立。



### 相关系数 （Correlation）

相关系数也就是经常提到的皮尔逊（Pearson）相关系数，常用 Corr 或者 r 来表示相关系数。相关系数可以看作是标准尺度下的协方差

![:\begin{center} Corr(X, Y) = Cov(X, Y) / \sigma_{1}\sigma_{2} \end{center}](https://private.codecogs.com/gif.latex?%3A%5Cbegin%7Bcenter%7D%20Corr%28X%2C%20Y%29%20%3D%20Cov%28X%2C%20Y%29%20/%20%5Csigma_%7B1%7D%5Csigma_%7B2%7D%20%5Cend%7Bcenter%7D)

相关系数有有个定理：

1. 如果X, Y相互独立，则 Corr(X, Y) = 0

2. ![-1\leq Corr(X, Y) \leq 1](https://private.codecogs.com/gif.latex?-1%5Cleq%20Corr%28X%2C%20Y%29%20%5Cleq%201)，当且仅当 X,Y 之间有严格线性关系时候，等号成立。



### 自相关/序列相关 (Autocorrelation or Serial Correlation)

模型**随机项**之间存在相关性称为自相关或者序列相关。

对于模型

![\large X_{t} = \beta_{1}X_{t-1} + \beta_{2}X_{t-2} +... + u_{t}](https://private.codecogs.com/gif.latex?%5Clarge%20X_%7Bt%7D%20%3D%20%5Cbeta_%7B1%7DX_%7Bt-1%7D%20&plus;%20%5Cbeta_%7B2%7DX_%7Bt-2%7D%20&plus;...%20&plus;%20u_%7Bt%7D)

随机项存在序列相关是：![Corr(u_{i},u_{j}) \neq 0](https://private.codecogs.com/gif.latex?Corr%28u_%7Bi%7D%2Cu_%7Bj%7D%29%20%5Cneq%200)，最简单的**一阶序列相关**也就是 ![Corr(u_{i},u_{i+1}) \neq 0](https://private.codecogs.com/gif.latex?Corr%28u_%7Bi%7D%2Cu_%7Bi&plus;1%7D%29%20%5Cneq%200)

下面用 python 中的statsmodel 模块来分析一下时间序列的自相关性：

生成一段高斯白噪声，然后画出它的ACF (AutoCorrelation Function)和PACF(Partial AutoCorrelation Function)。

补充一点关于 ACF 和 PACF的作用：根据ACF和PACF可以直观看出序列的自相关性，并且还可以作为一种判断序列是否平稳的手段，从而选择合适的模型来拟合数据。

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import gridspec
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

def ts_plot():
    fig = plt.figure()
    gs = gridspec.GridSpec(2,2)

    data = np.random.normal(size=1000)

    ax_ts = fig.add_subplot(gs[0, 0:2])
    ax_acf = fig.add_subplot(gs[1, 0])
    ax_pacf = fig.add_subplot(gs[1, 1])

    ax_ts.plot(range(len(data)), data)
    plot_acf(data, ax=ax_acf, lags=30)
    plot_pacf(data, ax=ax_pacf, lags=30)

    plt.show()
```

![](https://img-blog.csdnimg.cn/20190213103618280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyYW5raWVIZWxsbw==,size_16,color_FFFFFF,t_70)

可以看出白噪声过程的ACF和PACF中并没有什么明显的相关性。

下面模拟一段 AR(1) 的过程。

```python
def ts_plot():
    fig = plt.figure()
    gs = gridspec.GridSpec(2,2)
    u = np.random.normal(size=1000)
    data = u
    a = 0.6
    for t in range(1000):
        data[t] = a * data[t-1] + u[t]
    ax_ts = fig.add_subplot(gs[0, 0:2])
    ax_acf = fig.add_subplot(gs[1, 0])
    ax_pacf = fig.add_subplot(gs[1, 1])

    ax_ts.plot(range(len(data)), data)
    plot_acf(data, ax=ax_acf, lags=30)
    plot_pacf(data, ax=ax_pacf, lags=30)

    ax_ts.set_title('AR(1)')
    plt.show()
```

![](https://img-blog.csdnimg.cn/2019021311032082.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyYW5raWVIZWxsbw==,size_16,color_FFFFFF,t_70)

ACF拖尾，PACF一阶截尾 ，所以很明显是一个AR(1)过程。



### 两种时间序列的相关性

时间序列的自相关性可以理解为时间序列自己与自己（不同滞后项）之间的相关性，有时需要研究不同时间序列之间的相关性，例如配对交易时选择具有相似走势的股票对。

选出相同板块的几只股票，相同板块受到的政策市场等影响类似，所以它们的价格走势的相关性也应该比较高。通过 tushare 爬取这几只股票的收盘价数据：

```python
def calSim():
    symbols = ['600831', '603000', '603888', '300431', '002238', '600037']
    used_cols = ['code', 'close']
    df = ts.get_hists(symbols, start='2018-12-01', end='2018-12-30')
    df = df[used_cols]
    df_Close = pd.DataFrame()
    
    pos = [321,322,323,324,325,326,327,328]
    i = 0
    fig = plt.figure()
    for symbol in symbols:
        ax = fig.add_subplot(pos[i])
        ax.plot(range(len(df_Close[symbol])), df_Close[symbol])
        ax.set_title(symbol)
        i += 1
    plt.tight_layout()    # change the distance of subplots
    plt.show()
```

![](https://img-blog.csdnimg.cn/20190220171534393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyYW5raWVIZWxsbw==,size_16,color_FFFFFF,t_70)

 从图中可以看出60300和603888以及603000和60037这两组之间的相似性比较高，而600831与其它股票的差别较大。下面通过画出它们之间的相关图来量化一下这种相关性。

```python
for symbol in symbols:
        value = df.loc[df['code'] == symbol, 'close'].values
        df_Close[symbol] = value
    print(df_Close)
    fig = plt.figure()
    ax = fig.add_subplot(111)
    sns.heatmap(df_Close.corr(), ax=ax, annot=True)
    plt.show()
```

![](https://img-blog.csdnimg.cn/20190220172033342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZyYW5raWVIZWxsbw==,size_16,color_FFFFFF,t_70)

 结果跟我们观察的一样，看出60300和603888以及603000和60037这两组之间的相关性高，而600831与其他的之间的相关性较低。其中两两之间的相关性矩阵就是通过 df.corr() 得到的，df.corr() 函数默认计算相关系数就是通过皮尔逊相关系数计算得到的。





