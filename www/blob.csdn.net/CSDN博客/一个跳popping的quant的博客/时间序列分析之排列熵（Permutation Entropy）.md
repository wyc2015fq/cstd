# 时间序列分析之排列熵（Permutation Entropy） - 一个跳popping的quant的博客 - CSDN博客





2019年03月06日 19:50:59[敲代码的quant](https://me.csdn.net/FrankieHello)阅读数：547








#### 排列熵（Permutation Entropy，PeEn）

#### 概念

排列熵同样和前面提到的近似熵、样本熵以及模糊熵一样，都是用于衡量时间序列复杂程度而的指标。只不过，它在计算重构子序列之间的复杂程度时，引入了排列的思想。

#### 排列熵求法

1、设有长度为$N$的时间序列$u(1),u(2),u(3),...,u(N)$，规定一个**嵌入维度**$m$ (embedding dimension)和一个**时间延迟**$L$ (delay time)。

2、通过将原序列进行重构，将每个子序列以$X(i)$表示，其中$X(i)=u(i),u(i+L),...,u(i+(m-1)L)$。

3、然后对每个$X(i)$内部进行**递增**排序，也就是 $u(i+(j_{1}-1)L)\leq u(i+(j_{2}-1)L)\leq ... \leq u(i+(j_{m}-1)L)$，其中，如果两个值相等，就按照它们中 $j_{i}$ 的下标$i$进行排序。这样的话，一个 $X_{i}$ 就被映射到了 $(j_{1},j_{2},...,j_{m})$，这正是 $m!$ 个排列中的一种。也就是说，每一个 $m$ 维的子序列 $X(i)$ 都被映射到了 $m!$ 种排列中的其中之一。

4、通过上面的步骤，就将连续的 $m$ 维子空间用一个这样的符号序列表示了，其中这些符号的个数有 $m!$。将所有符号的概率分布用$P_{1},P_{2},...,P_{K}$表示，其中$K\leq m!$。

5、计算 Shannon Entropy ，则时间序列$u(1),u(2),u(3),...,u(N)$的排列熵为：$$H(m) = -\sum_{j=1}^{K}P_{j}lnP_{j}$$
注：

当$P_{j} = 1/m!$，也就是每种符号都有且它们的概率都相等，此时时间序列的复杂程度最高，所以排列熵最大，为$ln(m!)$。另外，为了方便表示，通常会将$H(m)$除以一个$ln(m!)$来归一化，这样$$0\leq H(m)/ln(m!) \leq 1 $$

#### 思考

排列熵作为衡量时间序列复杂程度的指标，**越规则的时间序列，它对应的排列熵越小；越复杂的时间序列，它对应的排列熵越大**。但是这样的结果是建立在合适的 $m$ 的选择的基础上的，如果 $m$ 的选取很小，如1或者2的话，那么它的排列空间就会很小（1!、2!）。经过研究表明，这个 $m$ 的选取还是要根据实际情况来决定，一般而言，Bandt and Pompe 建议的取值是$m=3,...,7$。

另外，通过排序和排列的思想在计算概率分布的时候，个人感觉会对内部序列中的异常点不敏感，如{1,2,3,4,5,6}和｛1,2,3,4,5,99｝在被映射的时候是一样的，但是其中5->6和5->99的性质却差别很大。

#### ref:

《Detecting dynamical changes in time series using the permutation entropy》




