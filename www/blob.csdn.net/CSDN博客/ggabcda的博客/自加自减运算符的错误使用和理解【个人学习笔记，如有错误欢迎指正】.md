# 自加自减运算符的错误使用和理解【个人学习笔记，如有错误欢迎指正】 - ggabcda的博客 - CSDN博客





2017年08月30日 18:09:33[ggabcda](https://me.csdn.net/ggabcda)阅读数：231








## 自加自减运算符的错误使用

```
int a = 1;
printf("%d %d %d\n",a,a++,++a);
```

输出结果为：3 2 3

```
int a = 1;
printf("%d ",a);
printf("%d ",a++);
printf("%d\n",++a);
```

输出结果为：1 1 3

由此可见，将多个自加自减运算符放入同一语句中是不合适的（**不同编译器可能输出结果不同**）。因为这是一种C语言中未定义的行为，即C语言并没有规定多个表达式的运算（求值）顺序，所以在不同编译器中得到的结果是不同的。故最好只在**一条语句中只使用一次**自加自减运算符。

另外，对常量（constant）使用自加自减运算符是不合法的，因为常量的值是不能改变的。假设X+Y=3，即便（X+Y）++后等于4，但由于（X+Y）++没有L-value，则结果还是无处可放。【**自加自减运算符要求操作数（operant）必须具有L-value**】

## 自加自减过程的错误理解
`b = a++; （1）`
如这样一条语句，可能会错误的理解为**先把a的值赋给b，然后a再自加。**但这样的理解是错误的。最简单的一条证据就是++的运算符优先级（Operator Precedence）比赋值运算符要高。

### 对自加自减过程（后置）的正确理解

标准C规定，表达式a++的R-value是等于a的R-value。为了保存a++后的R-value，系统将**自动生成一个临时变量**暂存i的R-value。在执行完a=a+1后，返回保存在临时变量里的a的R-value作为a++的R-value，**随即释放**临时变量存储单元。因此对与语句（1）的执行过程相当于：

```
temp = a;
a = a+1;
return temp;

b = temp
```

**注意：赋值过程依然在a自加以后。**

### 对自加自减过程（前置）的理解

类似于前者，标准C规定，表达式++a的R-value是等于a+1后的值，即先做a=a+1,然后再返回a+1的值。过程相当于

```
a = a+1;
return a;
```



