# 编码格式简介：ASCII码、ANSI、GBK、GB2312、GB18030和Unicode、UTF-8，BOM头 - ggabcda的博客 - CSDN博客





2017年09月02日 12:17:42[ggabcda](https://me.csdn.net/ggabcda)阅读数：160








**编码格式简介：ASCII码、ANSI、GBK、GB2312、GB18030和Unicode、UTF-8，BOM头**



**二进制：**

只有0和1。



**十进制、十六进制、八进制：**

计算机其实挺笨的，它只认识0101这样的字符串（二进制）,当然了我们看这样的01串时肯定会比较头晕的。

所以很多时候为了描述简单都用十进制,十六进制,八进制表示。实际上都是等价的，没啥太多不一样。



**位（bit）**

计算机中存储一个0，或者一个1的位置空间，叫做位。



**字节（byte）**

计算机中，我们把连续的8个位空间，叫做一个字节。



**ASCII码：**

128一版本ASCII码（7bits）。0-128-255二版本ASCII码（8bits。首位0，仍为一版本；首位1，为补充字符）

是American Standard Code for Information Interchange的缩写，美国信息交换标准代码。

那么ASCII码到底是什么呢？

我们知道其他啥文字图片之类的其他东东计算机不认识。那为了在计算机上表示这些信息就必须转换成一些数字。

你肯定不能想怎么转换就怎么转，必须得有定些规则。

于是刚开始的时候就有ASCII字符集，它使用7 bits来表示一个字符，总共表示128个字符。

我们一般都是用字节(byte,即8个01串)来作为基本单位。

那么怎么当用一个字节来表示字符时第一个bit总是0，剩下的七个字节就来表示实际内容。

后来IBM公司在此基础上进行了扩展，用8bit来表示一个字符，总共可以表示256个字符。也就是当第一个bit是0时仍表示之前那些常用的字符。当为1时就表示其他补充的字符。

ASCII码是单字节的字符编码方案，获得了国际标准化组织的认可，适用于所有拉丁文字字母。



**ANSI **

ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x80-0xFF（十进制为128-255） 范围的 2 个字节来表示 1 个字符。1.6万个字符空间。

不同的国家和地区制定了不同的标准，由此产生了各自的编码标准。

中国使用 2 个字节来代表一个字符的各种汉字，延伸编码方式的 ANSI 编码有GB2312 GBK GB18030。

不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。 

在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表JIS 编码。



**GB系列**

是国家标准代号，就是简体标准字库，包括GB2312、GBK、GB18030、Big5（繁体，台湾和香港使用）。

**GB2312 **

中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。

**GBK **

汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。

**GB18030 **

中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。

**Big5**

又称为大五码或者五大码，是通行于台湾、香港地区的一个繁体字编码方案。地区标准号为：CNS11643，这就是人们讲的BIG-5码。



**UCS（统一字符集。宏观）、Unicode、UTF-x微观**

由于不同地区，使用了不同的ANSI字符代码。终于，有个叫ISO的组织看不下去了。他们一起创造了一种编码UNICODE，这种编码非常大，大到可以容纳世界上任何一个字符。

ISO取的名字叫UCS(Universal Character Set)，UCS对应的编码格式就叫Unicode。

unicode和ansi都是字符代码的一种表示形式。unicode是国际标准，ANSI（也就是对美国的ASCII码的扩展，多字节）是各国标准。例如中国的ANSI代表GB系列，日本的ANSI代表JIS系列。美国直接用ASCII码（单字节）。

总结起来为啥需要Unicode，就是为了适应全球化的发展，便于不同语言之间的兼容交互，而ASCII不再能胜任此任务了。



**unicode的第一个版本**

Unicode是用0至65535（2^16）之间的数字来表示所有字符。

是用两个字节(16bit)来表示所有字符。实际上这么说容易让人产生歧义，我们总觉得两个字节就代表保存在计算机中时是两个字节。于是任何字符如果用unicode表示的话保存下来都占两个字节。其实这种说法是错误的。



其实Unicode涉及到两个步骤：

首先是定义一个规范，给所有的字符指定一个唯一对应的数字，65536是2的16次方，这完全是数学问题，可以跟计算机没半毛钱关系。

第二步才是怎么把字符对应的数字保存在计算机中，这才涉及到实际在计算机中占多少字节空间。怎么把0至65535这些数字转化成01串保存到计算机中。其中0至127这128个数字表示的字符仍然跟ASCII完全一样。这肯定就有不同的保存方式了。于是出现了UTF(unicode transformation format)，有UTF-16，UTF-8。



中文多，优先用UTF-16。（在中国，优先用gbk）

英文多，优先用UTF-8。

**小结：中文多，用gbk；英文多，用utf-8。**



**UTF-16：固定两个字节**

UTF-16比较好理解，就是任何字符对应的数字都用两个字节来保存。我们通常对Unicode的误解就是把Unicode与UTF-16等同了。但是很显然如果都是英文字母这做有点浪费。明明用一个字节能表示一个字符为啥整两个啊。



**UTF-8：可变字节。一个两个三个都可以。**

于是又有个UTF-8，这里的8非常容易误导人，8不是指一个字节，难道一个字节表示一个字符？实际上不是。当用UTF-8时表示一个字符是可变的，有可能是用一个字节表示一个字符，也可能是两个，三个。当然最多不能超过3个字节了。反正是根据字符对应的数字大小来确定。



于是UTF-8和UTF-16的优劣很容易就看出来了。如果全部英文或英文与其他文字混合，但英文占绝大部分，用UTF-8就比UTF-16节省了很多空间。而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数。UTF-16就占优势了，可以节省很多空间。另外还有个容错问题，等会再讲。





**BOM头**

看的有点晕了吧，举个例子。

假如中文字"汉"对应的unicode是6C49(这是十六进制，换成十进制27721)。你可能会问当用程序打开一个文件时我们怎么知道那是用的UTF-8还是UTF-16啊。自然会有点啥标志，在文件的开头几个字节就是标志，叫做BOM头。



EF BB BF 表示UTF-8

FE FF 表示UTF-16



用UTF-16表示"汉"



假如用UTF-16表示的话就是01101100   01001001(共16 bit，两个字节，换成十进制27721)。程序解析的时候知道是UTF-16就把两个字节当成一个单元来解析。这个很简单。



用UTF-8表示"汉"



用UTF-8就有复杂点。因为此时程序是把一个字节一个字节的来读取，然后再根据字节中开头的bit标志来识别是该把一个还是两个或三个字节做为一个单元来处理。



0xxxxxxx，如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit。就表示把一个字节做为一个单元。就跟ASCII完全一样。



110xxxxx 10xxxxxx。如果是这样的格式，则把两个字节当一个单元。



1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元。



这是约定的规则。你用UTF-8来表示时必须遵守这样的规则。我们知道UTF-16不需要用啥字符来做标志。所以两字节也就是2的16次能表示65536个字符.



而UTF-8由于里面有额外的标志信息。所有一个字节只能表示2的7次方128个字符,两个字节只能表示2的11次方2048个字符。而三个字节能表示2的16次方，65536个字符。



由于"汉"的编码27721大于2048了所有两个字节还不够，只能用三个字节来表示。



所有要用1110xxxx 10xxxxxx 10xxxxxx这种格式，把27721对应的二进制从左到右填充XXX符号（实际上不一定从左到右，也可以从右到左，这是涉及到另外一个问题。等会说。）



刚说到填充方式可以不一样，于是就出现了Big-Endian，Little-Endian的术语。Big-Endian就是从左到右（大尾），Little-Endian是从右到左（小尾）。



由上面我们可以看出UTF-8需要判断每个字节中的开头标志信息，所以如果一当某个字节在传送过程中出错了，就会导致后面的字节也会解析出错。而UTF-16不会判断开头标志,即使错也只会错一个字符，所以容错能力强。





**Unicode第二个版本**

增加了UTF-32，局部重构了Unicode版本1的原样UTF-8、UTF-16。



前面说的都是unicode的第一个版本，但65536显然不算太多的数字，用它来表示常用的字符是没一点问题，足够了。

但如果加上很多特殊的就也不够了。于是从1996年开始又来了第二个版本，用四个字节表示所有字符。这样就出现了UTF-8，UTF16，UTF-32。

原理和之前肯定是完全一样的，UTF-32就是把所有的字符都用32bit也就是4个字节来表示。

然后UTF-8，UTF-16就视情况而定了。

UTF-8可以选择1至8个字节中的任一个来表示，而UTF-16只能是选两字节或四字节。

由于unicode版本2的原理完全是一样的，就不多说了。



前面说了要知道具体是哪种编码方式，需要判断文本开头的标志，下面是所有编码对应的开头标志：



EF BB BF　　　 UTF-8

FE FF　　　　　UTF-16/UCS-2, little endian

FF FE　　　　　UTF-16/UCS-2, big endian

FF FE 00 00　　UTF-32/UCS-4, little endian

00 00 FE FF　　UTF-32/UCS-4, big endian



其中的UCS就是前面说的ISO制定的标准，和Unicode是完全一样的，只不过名字不一样。

ucs-2对应UTF-16；（固定两个字节）记：宏观说字节，微观说位。

ucs-4对应UTF-32；（固定四个字节）

UTF-8是没有对应的UCS



