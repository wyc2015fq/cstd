# 正则表达式和Java编程语言1zz - weixin_33985507的博客 - CSDN博客
2005年10月03日 10:24:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：2
正则表达式（Regular Expression）简介：
正则表达式具有两种标准：基本的正则表达式(BRE)，扩展的正则表达式(ERE)。ERE包括BRE功能和另外其它的概念。
应用程序常常需要有文本处理功能，比如单词查找、电子邮件确认或XML文档 集成。这通常会涉及到模式匹配。Perl、sed或awk等语言通过使用正则表达式来 改善模式匹配，正则表达式是一串字符，它所定义的模式可用来查找匹配的文本。 为了使用JavaTM编程语言进行模式匹配，需要使用带有许多charAt子字串的StringTokenizer 类，读取字母或符号以便处理文本。这常常导致复杂或凌乱的代码。
现在不一样了：
JAVA2平台标准版（J2SE）1.4版包含一个名为 java.util.regex 的新软件包，使得使用正则表达式成为可能。 目前的功能包括元字符的使用，它赋予正则表达式极大的灵活性。
//--------------------------------------------------------------------------
正则表达式常见应用：
1：简单的单词替换 
2：电子邮件确认 
3：从文件中删除控制字符 
4：查找文件 
正则表达式JAVA类：
1：Pattern类
2：Matcher类
什么是模式？
在正则表达式的上下文中，模式是字符序列的文本表示法。例如，如果您想知道一个字符序列中是否存在 car 这个词，您会使用模式 car，因为这是精确地表示该字符串的方法。对于更复杂的模式，您可以使用特殊字符作为占位符。如果您不是要搜索 car，而是想搜索以字母 c 开头并以字母 r 结尾的任何文本字符串，您会使用 c*r 模式，其中 * 代表第一个 r 前的任意多个字符。c*r 模式将匹配任何以 c 开头并以 r 结尾的字符串，如cougar、cavalier 或 chrysler。
如何指定模式表达式
模式匹配的主要部分是关于要使用什么样的表达式。Pattern 先保存要使用的表达式，然后将其传递给 Matcher 类以便在字符序列的上下文中检查其匹配情况。例如，如果您想验证一个电子邮件地址，您可能要检查用户输入是否与这样一个模式匹配 — 它包含一个字母数字序列，后跟一个 @ 符号，@ 后又跟两组用句点隔开的字符。这可以用表达式 \p{Alnum}+@\w+\.\p{Alpha}{2,3} 来表示。（这显然过于简化了电子邮件地址的结构，可能会排除某些有效的电子邮件地址，但它作为示例已经足够了。）
在讨论模式语言的具体细节之前，我们来仔细看一下 \p{Alnum}+@\w+\.\p{Alpha}{2,3}。\p{Alnum} 序列表示单个字母数字字符（A 到 Z、a 到 z 或 0 到 9）。\p{Alnum} 后面的加号（+）被称为量词（quantifier）。它被应用在表达式的前面部分，表示 \p{Alnum} 必须出现一次或更多次。使用星号（*）表示要出现零次或一次以上（含一次）。@ 就是意味着它必须出现在至少一个字母数字字符之后，这样整个模式匹配才能成功。\w+ 与 \p{Alnum}+ 类似，但添加了下划线（_）。某些序列有多个表达式。反斜杠（\ .）代表句点。如果前面没有反斜杠，单独一个句点代表任意字符。最后的 \p{Alpha}{2, 3} 表示两个或三个字母字符。
//-------------------------------------------------------------------------
只要学会了规范语言，您就能掌握模式的所有秘密。我们来看一些更常用的表达式的种类：
文字（Literal）：表达式内任何不具有特殊意义的字符都被看作是一个文字，并与自身匹配。
量词（Quantifier）：某些字符或表达式，它们被用来计算一个文字或分组可以在字符序列中出现的次数，以便该序列与表达式匹配。分组是由圆括号内的一组字符指定的。 
? 表示出现一次或根本不出现 
* 表示出现零次或一次以上（含一次） 
+ 表示出现一次或多次
字符类（Character class）：一个字符类就是方括号内的一个字符集，其中，匹配可以是括号内的任意一个字符。您可以把字符类与量词结合在一起，例如，[acegikmoqsuwy]* 将是只包含字母表中奇数字母的任意字符序列。某些字符类是预先定义的：
\d — 数字（0 到 9） 
\D -- 非数字 
\s -- 空白字符，如制表符或换行符 
\S -- 非空白字符 
\w -- 单字字符（a 到 z、A 到 Z、0 到 9 以及下划线） 
\W -- 非单字字符（其它任意字符）
Posix 字符类（Posix character class）：某些字符类仅在用于 US-ASCII 比较时才有效。例如： 
\p{Lower} — 小写字符 
\p{Upper} — 大写字符 
\p{ASCII} — 所有 ASCII 字符 
\p{Alpha} — 字母字符（\p{Lower} 与 \p{Upper} 相结合） 
\p{Digit} — 从 0 到 9 的数字 
\p{Alnum} — 字母数字字符
范围（Range）：使用短线（dash）来指定包括一定范围字符的字符类。例如，[A-J] 表示从 A 到 J 的大写字母。
否定（Negation）：脱字符（^）否定字符类的内容。例如，[^A-J] 表示除 A 到 J 之外的任何字符。 
//------------------------------------------------------------------------
如何有效地使用模式？
既然您已经了解了如何指定模式，我们就来使用它们吧。您需要让 Pattern 类编译它们，如下所示。注意，反斜杠字符（\）在 String 常量中需要转义。
Pattern pattern = Pattern.compile(
"\\p{Alnum}+@\\w+\\.\\p{Alpha}{2,3}");
有了一个编译好的模式后，您可以使用 Pattern 类根据模式把一个输入行分割为一系列单字，或者使用 Matcher 类执行一些更复杂的任务。下面说明了如何分割输入字符序列，其中使用的模式指定了分隔符，而不是字：
String words[] = pattern.split(input);
如果您想在一个字符序列中多次匹配一个模式，上面的代码片段是一个很好的起点。但如果您想获取特定的输入，您将需要 Pattern 的 matcher() 方法。在给定某个输入时，这个方法将返回适当的 Matcher 类。接着，您使用 Matcher 实例遍历整个结果在输入序列中查找不同的模式匹配，或者使用 Matcher 实例作为查找-替换工具（后一种方法更好）：
Matcher matcher = pattern.matcher(input);
要根据整个序列匹配模式，请使用 matches()。要确定是否只有序列的一部分匹配，请使用 find()：
if (matcher.find()) {
// Found some string within input sequence
// That matched the compiled pattern
String match = matcher.group();
// Process matching pattern
}
这两个类（Pattern 与 Matcher）就是整个模式匹配库。提出正确的正则表达式，然后使用 Matcher 类的结果，这就是这个模式匹配库要做的全部工作。
在Java编程中，可以在任何需要模式匹配的地方使用正则表达式。
