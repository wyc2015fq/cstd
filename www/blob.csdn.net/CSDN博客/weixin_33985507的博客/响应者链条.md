# 响应者链条 - weixin_33985507的博客 - CSDN博客
2017年10月16日 00:31:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：5
**什么是事件?**
iOS中事件分为3大类 : **触摸事件, 加速计事件和远程控制事件.**
当你的手指在手机屏幕上触摸时, 产生了一个事件.
当你拿起手机摇一摇时, 产生了一个事件…
那么, 什么对象能够响应, 处理这些事件?
#### 一: 响应者
在iOS中不是任何对象都能处理事件, 只有继承自`UIResponder`的对象才能接收并处理事件, `UIResponder`是所有响应对象的基类，在`UIResponder`类中定义了处理上述各种事件的接口。我们熟悉的 `UIApplication`、 `UIViewController`、 `UIWindow`和所有继承自`UIView`的`UIKit`类都直接或间接的继承自`UIResponder`，所以它们的实例都是可以构成响应者链的响应者对象。
响应者对象`(Responder Object)` 指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象 构成的一个层次结构。
`UIResponder`内部提供处理事件的方法有 :
```
触摸事件
当一个手指或者多个手指触摸view的时候，系统会自动调用view
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
如果用户的手指在当前view上面一直移动，那么这个方法会一直调用
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
一个或者多个手指离开view的时候，系统会自动调用
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
在触摸结束之前，比如有系统事件要处理的时候，那么会打断触摸过程，系统就会调用这个方法
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
加速计事件
- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;
- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;
远程控制事件
- (void)remoteControlReceivedWithEvent:(UIEvent *)event;
```
除了以上方法, 现在还有一个类(`UIGestureRecognizer`), 它是一个抽象类，使用它的子类能帮助我们轻松识别view上的各种手势.
```
UITapGestureRecognizer(敲击)
UIPinchGestureRecognizer(捏合，用于缩放)
UIPanGestureRecognizer(拖拽)
UISwipeGestureRecognizer(轻扫)
UIRotationGestureRecognizer(旋转)
UILongPressGestureRecognizer(长按)
```
#### 二: UITouch
当你用一根手指触摸屏幕时, 会创建一个与之关联的UITouch对象, 一个UITouch对象对应一根手指. 在事件中可以根据`NSSet`中`UITouch`对象的数量得出此次触摸事件是单指触摸还是双指多指等等.
那么UITouch有什么作用呢？
UITouch的作用就是它会保存着这个手指相关的一些信息，触摸时间，位置，阶段等之类的信息。
当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置
当手指头离开屏幕的时候，那么与之对应的UITouch对象就会销毁了。
UITouch几个重要的属性 :
```
触摸产生时所处的窗口
@property(nonatomic,readonly,retain) UIWindow *window;
触摸产生时所处的视图
@property(nonatomic,readonly,retain) UIView   *view;
短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击
@property(nonatomic,readonly) NSUInteger      tapCount;
记录了触摸事件产生或变化时的时间，单位是秒
@property(nonatomic,readonly) NSTimeInterval  timestamp;
当前触摸事件所处的状态
@property(nonatomic,readonly) UITouchPhase    phase;
```
UITouch的两个方法 (可用于view的拖拽)
```
- (CGPoint)locationInView:(UIView *)view;
/*
  返回值表示触摸在view上的位置
  这里返回的位置是针对传入的view的坐标系（以view的左上角为原点(0, 0)）
  调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置
*/
- (CGPoint)previousLocationInView:(UIView *)view;
// 该方法记录了前一个触摸点的位置
```
#### 三: UIEvent
每产生一个事件, 就对应产生一个UIEvent. UIEvent记录着该事件产生的时间, 事件的类型等等.
UIEvent几个重要的属性 :
```
事件类型
@property(nonatomic,readonly) UIEventType     type;
@property(nonatomic,readonly) UIEventSubtype  subtype;
事件产生的时间
@property(nonatomic,readonly) NSTimeInterval  timestamp;
```
#### 四: 事件的产生与传递
![2092929-377f6388cbd45c21.png](https://upload-images.jianshu.io/upload_images/2092929-377f6388cbd45c21.png)
触摸4这个view
当用户的手指触摸屏幕的某一个view的时候，此时就发生了触摸事件，系统会把该事件加入UIApplication管理的事件队列中去，这个队列是先进先出的，然后UIApplication会从事件队列中去除最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow），主窗口会在视图层次结构上面找到一个最合适的视图来处理触摸事件，这是整个事件处理的第一步，找到合适的视图控件之后，他就会调用试图的touches方法来处理事件，
**触摸事件的传递是由父控件传递到子控件的，**
由于触摸事件的传递方向是由父控件传递到子控件, 那何为最合适呢?
- 自己能响应触摸事件
- 触摸点在自己身上
- 从后往前遍历子控件, 重复上两步
- 如果没有符合条件的子控件, 那么就自己最合适处理
根据上图来说明的话
```
点击了绿色的view：
UIApplication -> UIWindow -> 白色 -> 绿色
点击了蓝色的view：
UIApplication -> UIWindow -> 白色 -> 橙色 -> 蓝色
点击了黄色的view：
UIApplication -> UIWindow -> 白色 -> 橙色 -> 蓝色 -> 黄色
```
**UIView不接受触摸事件的三种情况**
- 用户交互关闭(userInteractionEnabled = NO)
- 控件隐藏(hidden = YES)
- 透明度太小(alpha = 0.0 ~ 0.01)
**hitTest:withEvent:方法的处理流程如下:**
- 首先调用当前视图的`pointInside:withEvent:`方法判断触摸点是否在当前视图内；
- 若返回NO,则hitTest:withEvent:返回nil;
- 若返回YES,则向当前视图的所有子视图(subviews)发送`hitTest:withEvent:`消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从`subviews`数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；
- 若第一次有子视图返回非空对象，则`hitTest:withEvent:`方法返回此对象，处理结束；
- 如所有子视图都返回非，则`hitTest:withEvent:`方法返回自身(self)。
**上面我们说主窗口会在视图层次结构上面找到一个最合适的视图来处理触摸事件，那么到底是怎么找到最合适的控件来处理这个触摸事件的呢？其实步骤是这样的：**
- 首先它会判断它自己是否能接受触摸事件，如果它不能接收触摸事件，那么它肯定不是最合适的，
- 然后再判断用户手指的触摸点是否在它自己的身上，如果不在，那么他就不是最合适的
- 执行完上面两个操作，然后从后往前遍历子控件（意思是先遍历后加入的子控件），然后重复上面的两个步骤
- 如果没有找到复合条件的子控件，那么它自己就是最适合处理事件的控件
当用户手指触摸到屏幕中的某一块区域时，UIWindow查找其子控件，然后通过调用所有自控件的方法：
```
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)
event
```
来通过指定的触摸点获取最合适的UIView来处理该触摸事件。如何通过触摸点获取UIView原理其实非常简单，只需要检查该触摸点是否在该控件所在的矩形区域内就可以了,其实`hitTest:withEvent`方法内部也是调用方法:
``
如果检测到传入的控件包含该触摸点就返回YES。
**在响应方法内部，我们也可以将这个触摸事件继续传递给父控件的对应方法处理。然后父控件还可以将该事件继续向上传递，直到传递给UIApplication对象。这一系列的响应者对象就构成了一个响应者链条。**
```
底层实现如下 :
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    NSLog(@"点击了%@",[super hitTest:point withEvent:event]);
    // 1.判断下自己能否接收事件
    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha <= 0.01) return nil;
    // 2.判断下点在不在当前控件上
    if ([self pointInside:point withEvent:event] == NO) return  nil; // 点不在当前控件
    // 3.从后往前遍历自己的子控件
    // 1 0
    int count = (int)self.subviews.count;
    for (int i = count - 1; i >= 0; i--) {
        // 获取子控件
        UIView *childView = self.subviews[i];
        // 把当前坐标系上的点转换成子控件上的点
        CGPoint childP =  [self convertPoint:point toView:childView];
        UIView *fitView = [childView hitTest:childP withEvent:event];
        if (fitView) {
            return fitView;
        }
    }
    // 4.如果没有比自己合适的子控件,最合适的view就是自己
    return self;
}
```
###### 4.2:作用
- 指鹿为马(明明点击的是B视图, 却由A视图来响应事件)
- 穿透某控件点击被覆盖的下一层控件
- 让父控件frame之外的子控件响应触摸事件
#### 五: 响应者链条
###### 5.1: 触摸事件处理的详细过程：
当用户点击屏幕后产生一个触摸事件，经过经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件，找到最合适的视图之后，就会调用空间的touches那三个方法，这些方法的默认做法是把事件顺着响应者链条向上传递，将事件传递给上一个响应者进行处理
什么是响应者链条：
响应者链条就是由多个响应者对象连接起来的链条，它的作用就是让我们能够清楚的看见每个响应者之间的联系，并且可以让一个时间多个对象处理
响应者链条是怎么个样子呢，我们可以看下这两个图
当找到最合适的响应者之后, 便会调用控件相应的touches方法来作具体处理. 然而这些方法默认是不处理, 并将该事件随着响应者链条往回传递, 交给上一个响应者来处理. (即调用super的touches方法)
![2092929-40e032090b3e1211](https://upload-images.jianshu.io/upload_images/2092929-40e032090b3e1211)
响应者链条.png
首先initial view会把事件传递给橘黄色的view，橘黄色view又把事件给时间传递给了蓝绿色view，蓝绿色view把时间传递给了控制器view，控制器view把事件传递给了窗口，窗口把事件传递给了Application对象。
**事件传递的完整过程**
- 先将事件对象由上往下传递(由父控件传递给子控件)，找到最合适的控件来处理这个事件。
- 调用最合适控件的`touches….`方法
- 如果调用了`[super touches….]`;就会将事件顺着响应者链条往上传递，传递给上一个响应者
- 接着就会调用上一个响应者的`touches….`方法
**如何判断上一个响应者**
- 如果当前这个view是控制器的view,那么控制器就是上一个响应者
- 如果当前这个view不是控制器的view,那么父控件就是上一个响应者
**响应者链条的时间传递过程**
```
1. 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图
2. 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件传递给window对象进行处理
3. 如果window对象也不处理，则其将事件或消息传递给UIApplication对象
4. 如果UIApplication也不能处理该事件或消息，则将其丢弃
```
**使用响应者链条找到当前view所属的控制器**
```
- (UIViewController *)parentController
{
    UIResponder *responder = [self nextResponder];
    while (responder) {
        if ([responder isKindOfClass:[UIViewController class]]) {
            return (UIViewController *)responder;
        }
        responder = [responder nextResponder];
    }
    return nil;
}
```
**为什么用队列管理事件,而不用栈？**
```
队列先进先出,能保证先产生的事件先处理。栈先进后出。
```
###### 六: Hit-Test View 与 Hit-Testing
![2092929-c9c822774b8d9e5d.png](https://upload-images.jianshu.io/upload_images/2092929-c9c822774b8d9e5d.png)
Hit-Test View 与 Hit-Testing
响应者链通常是由 `initial view` 开始;
- 
`UIView`的`nextResponder`是`superview`;如果`UIView`已经是其所在的`UIViewController`的`top view`，那么`UIView`的`nextResponder`就是`UIViewController`;
- 
`UIViewController`如果有`Super ViewController`，那么它的`nextResponder`为其`Super ViewController`最表层的`View`; 如果没有，那么它的`nextResponder`就是`UIWindow`;
- 
`UIWindow`的`contentView`指向`UIApplication`，将其作为`nextResponder`;
- 
`UIApplication`响应者链的终点，它的`nextResponder`指向nil，整个`responder chain`结束。
![2092929-942d13787c19fb3c.png](https://upload-images.jianshu.io/upload_images/2092929-942d13787c19fb3c.png)
Hit-Test View 与 Hit-Testing
**假设用户触摸了上图的`View E`区域，那么 iOS 将会按下面的顺序反复检测`subview`来寻找`Hit-Test View`**
- 
1、A是UIWindow的根视图，因此，UIWindwo对象会首相对A进行`hit-test`
- 
2、显然用户点击的范围是在A的范围内，因此，`pointInside:withEvent:`返回了YES，这时会继续检查A的子视图；
- 
3、这时候会有两个分支，**B和C**
- 点击的范围不再B内，因此B分支的 `pointInside:withEvent:返回NO`，对应的 hitTest:withEvent:返回nil；
- 点击的范围在C内，即C的 `pointInside:withEvent:返回YES`；
- 
4、这时候有D和E两个分支：
- 点击的范围不再D内，因此D 的 pointInside:withEvent:返回NO，对应的`hitTest:withEvent:返回nil`；
- 点击的范围在E内，即E的`pointInside:withEvent:`返回YES，由于E没有子视图（也可以理解成对E的子视图进行hit-test时返回了nil），因此，E的 `hitTest:withEvent:`会将E返回，再往回回溯，就是C的 `hitTest:withEvent:`返回E--->>A的`hitTest:withEvent:返回E`
不难看出，这个处理流程有点类似二分搜索的思想，这样能以最快的速度，最精确地定位出能响应触摸事件的UIView。
**至此，本次点击事件的第一响应者就通过响应者链的事件分发逻辑成功的找到了。**
**事件的链有两条:事件的响应链;Hit-Testing时事件的传递链。**
- **响应链**:由离 户最近的view向系统传递。 `initial view` –> `super view` –> `.....`–> `view controller` –> `window` –> `Application` –> `AppDelegate`
- **Hit-Testing 链** :由系统向离户最近的view传递。 `UIKit` –> `active app's event queue` –> `window` –> `root view` –>`......`–>`lowest view`
**说明**
- 1、如果最终`hit-test`没有找到第一响应者，或者第一响应者没有处理该事件，则该事件会沿着响应者链向上回溯，如果`UIWindow`实例和`UIApplication`实例都不能处理该事件，则该事件会被丢弃；
- 2、`hitTest:withEvent:`方法将会忽略 **隐藏(hidden=YES)的视图，禁止用户操作(userInteractionEnabled=YES)的视图，以及alpha级别小于0.01(alpha<0.01)的视图**。如果一个子视图的区域超过父视图的bound区域(父视图的clipsToBounds 属性为NO，这样超过父视图bound区域的子视图内容也会显示)，那么正常情况下对子视图在父视图之外区域的触摸操作不会被识别,因为父视图的`pointInside:withEvent:`方法会返回`NO`,这样就不会继续向下遍历子视图了。当然，也可以重写`pointInside:withEvent:`方法来处理这种情况。
- 3、我们可以重写`hitTest:withEvent:`来达到某些特定的目的
[iOS开发-事件传递以及响应者链条](https://www.jianshu.com/p/77a1b6e5194d)
[史上最详细的iOS之事件的传递和响应机制](https://link.jianshu.com?t=http://www.cnblogs.com/machao/p/5471094.html)
[ios中事件的响应链(Responder chain)和传递链](https://link.jianshu.com?t=http://www.cnblogs.com/wangliang2015/p/7061933.html)
[IOS - 响应者链条](https://link.jianshu.com?t=http://www.cnblogs.com/mcj-coding/p/3569908.html)
[一篇搞定事件传递、响应者链条、hitTest和pointInside的使用](https://www.jianshu.com/p/2f664e71c527)
