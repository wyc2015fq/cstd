# Linux守护进程的编程实现 - weixin_33985507的博客 - CSDN博客
2014年06月29日 21:31:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3

Linux 守护进程的编程方法 
守护进程（Daemon）是执行在后台的一种特殊进程。它独立于控制终端而且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种非常实用的进程。Linux的大多数server就是用守护进程实现的。比方，Internetserverinetd，Webserverhttpd等。同一时候，守护进程完毕很多系统任务。比方，作业规划进程crond，打印进程lpd等。 
守护进程的编程本身并不复杂，复杂的是各种版本号的Unix的实现机制不尽同样，造成不同Unix环境下守护进程的编程规则并不一致。这须要读者注意，照搬某些书上的规则（特别是BSD4.3和低版本号的System V）到Linux会出现错误的。以下将全面介绍Linux下守护进程的编程要点并给出具体实例。 
一． 守护进程及其特性 
守护进程最重要的特性是后台执行。在这一点上DOS下的常驻内存程序TSR与之类似。其次，守护进程必须与其执行前的环境隔离开来。这些环境包含未关闭的文件描写叙述符，控制终端，会话和进程组，工作文件夹以及文件创建掩模等。这些环境一般是守护进程从执行它的父进程（特别是shell）中继承下来的。最后，守护进程的启动方式有其特殊之处。它能够在Linux系统启动时从启动脚本/etc/rc.d中启动，能够由作业规划进程crond启动，还能够由用户终端（一般是shell）执行。 
总之，除开这些特殊性以外，守护进程与普通进程基本上没有什么差别。因此，编写守护进程实际上是把一个普通进程依照上述的守护进程的特性改造成为守护进程。假设读者对进程有比較深入的认识就更easy理解和编程了。 
二． 守护进程的编程要点 
前面讲过，不同Unix环境下守护进程的编程规则并不一致。所幸的是守护进程的编程原则事实上都一样，差别在于具体的实现细节不同。这个原则就是要满足守护进程的特性。同一时候，Linux是基于Syetem V的SVR4并遵循Posix标准，实现起来与BSD4相比更方便。编程要点例如以下； 
1. 在后台执行。 
为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。 
if(pid=fork()) 
exit(0);//是父进程，结束父进程，子进程继续 
2. 脱离控制终端，登录会话和进程组 
有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话能够包含多个进程组。这些进程组共享一个控制终端。这个控制终端一般是创建进程的登录终端。 
控制终端，登录会话和进程组一般是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长： 
setsid(); 
说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。因为会话过程对控制终端的独占性，进程同一时候与控制终端脱离。 
3. 禁止进程又一次打开控制终端 
如今，进程已经成为无终端的会话组长。但它能够又一次申请打开一个控制终端。能够通过使进程不再成为会话组长来禁止进程又一次打开控制终端： 
if(pid=fork()) 
exit(0);//结束第一子进程，第二子进程继续（第二子进程不再是会话组长） 
4. 关闭打开的文件描写叙述符 
进程从创建它的父进程那里继承了打开的文件描写叙述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按例如以下方法关闭它们： 
for(i=0;i 关闭打开的文件描写叙述符close(i);> 
5. 改变当前工作文件夹 
进程活动时，其工作文件夹所在的文件系统不能卸下。一般须要将工作文件夹改变到根文件夹。对于须要转储核心，写执行日志的进程将工作文件夹改变到特定文件夹如/tmpchdir("/") 
6. 重设文件创建掩模 
进程从创建它的父进程那里继承了文件创建掩模。它可能改动守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0); 
7. 处理SIGCHLD信号 
处理SIGCHLD信号并非必须的。但对于某些进程，特别是server进程往往在请求到来时生成子进程处理请求。假设父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。假设父进程等待子进程结束，将添加�父进程的负担，影响server进程的并发性能。在Linux下能够简单地将SIGCHLD信号的操作设为SIG_IGN。 
signal(SIGCHLD,SIG_IGN); 
这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才干释放僵尸进程。 
三． 守护进程实例 
守护进程实例包含两部分：主程序test.c和初始化程序init.c。主程序每隔一分钟向/tmp文件夹中的日志test.log报告执行状态。初始化程序中的init_daemon函数负责生成守护进程。读者能够利用init_daemon函数生成自己的守护进程。 
1． init.c清单 
#include < unistd.h > 
#include < signal.h > 
#include < sys/param.h > 
#include < sys/types.h > 
#include < sys/stat.h > 
void init_daemon(void) 
{ 
int pid; 
int i; 
if(pid=fork()) 
exit(0);//是父进程，结束父进程 
else if(pid< 0) 
exit(1);//fork失败，退出 
//是第一子进程，后台继续执行 
setsid();//第一子进程成为新的会话组长和进程组长 
//并与控制终端分离 
if(pid=fork()) 
exit(0);//是第一子进程，结束第一子进程 
else if(pid< 0) 
exit(1);//fork失败，退出 
//是第二子进程，继续 
//第二子进程不再是会话组长 
for(i=0;i< NOFILE;++i)//关闭打开的文件描写叙述符 
close(i); 
chdir("/tmp");//改变工作文件夹到/tmp 
umask(0);//重设文件创建掩模 
return; 
} 
2． test.c清单 
#include < stdio.h > 
#include < time.h > 
void init_daemon(void);//守护进程初始化函数 
main() 
{ 
FILE *fp; 
time_t t; 
init_daemon();//初始化为Daemon 
while(1)//每隔一分钟向test.log报告执行状态 
{ 
sleep(60);//睡眠一分钟 
if((fp=fopen("test.log","a")) >=0) 
{ 
t=time(0); 
fprintf(fp,"Im here at %s/n",asctime(localtime(&t)) ); 
fclose(fp); 
} 
} 
} 
以上程序在RedHat Linux6.0下编译通过。过程例如以下： 
编译：gcc -g -o test init.c test.c 
执行：./test 
查看进程：ps -ef 
从输出能够发现test守护进程的各种特性满足上面的要求。
