# [原]关于phycis集成到osgearth的（瞎写写） - weixin_33985507的博客 - CSDN博客
2017年11月06日 16:12:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：12
**基于全球的物理系统集成技术**
引言
         随着·····
概述
         基于osgEarth渲染引擎，引入先进的物理引擎physics。
本篇主要讲述：原理和解决思路。
原理要点：
- 空间坐标转换
- 物理引擎与渲染引擎同步
- 无限动态大地形在物理引擎中的实现
**技术要点1****空间坐标转换**
         常用的物理引擎都是基于直角坐标系为运算基础的，重力都是以某个轴的负方向为向量，如：
         Phscis  重力矢量为  （0,0,-1）
而基于全球化的物理引擎在不同的经纬度，重力的矢量是变化的。
         例如（以直角坐标系为例）
|地球位置|经度|纬度|重力矢量趋近|
|----|----|----|----|
|北极|0|90|0,   0,   -1|
|南极|0|-90|0,   0,   1|
|非洲几内亚|0|0|-1,   0,   0|
|印尼（赤道）|90|0|-1,   -1,   0|
|太平洋|180|0|0,   -1,   0|
|北京|116|40|-0.8,  -1,  -0.9|
         全球范围内使用物理引擎，需要实时修改重力矢量。
         但是，仅仅改变重力矢量是不够的。由于数据原因，物理引擎使用的直角坐标系不能直接用于全球计算。
         目前在地理信息系统中常用的有：
北京54坐标系
西安80坐标系
2000国家大地坐标系
                   WGS84坐标系
         以最常用的WGS84举例：
                   它的坐标系原点位于地球质心，Z轴指向BIH1984.0定义的协议地球极方向（CTP）,X轴指向BIH1984.0的零度子午面和CTP的赤道交点，Y轴通过右手规则确定。
                   基于地球的长半轴为：6378137.0
                   基于地球的扁率为：1/298.257223565
经过常规直角坐标系到WGS84的转换后，场景的数值飞的非常大，而物理引擎计算都是小数值的计算，过大的数值在引擎中使用有精度影响。在地球上使用物理引擎都是某个小区域内使用（几十公里），当需要使用时，先取附近的一个点为基准点K，然后将这小区域所有的数值N减去当前基准点K的位置放入物理引擎中计算，得到结果Z后，再将结果Z加上基准点K就得到结果M
         如下所示：
                   N值--->物理引擎--->结果m有误差
                   N值--->减去基准点--->物理引擎--->结果Z--->加上基准点K--->结果M无误差
**技术要点2****物理引擎与渲染引擎同步**
         物理引擎将空间数据通过物理定律运算返回结果，能模拟出在现实中物体的状态。
         渲染引擎将空间数据通过计算机模拟出视觉形态。
         两个引擎用的虽然使用的数据相同，但计算和加载的方式不一样，所以，要同步两个引擎中的数据。一般情况下的做法是：将所有数据先经过物理引擎处理，再将处理后的数据放入渲染引擎中显示，这样做数据一直是同步的。不过，在处理全球范围的数据时，数据量太大，物理引擎太慢，渲染帧数又有高要求，就不能采用线性的处理方式。
         在实际使用中，我们用了多线程技术和时间同步技术。数据有两份，在物理引擎中一份，渲染引擎中一份。物理引擎每次返回结果后就修改数据的状态机，而渲染引擎每帧都会去遍历数据状态并刷新场景。这样物理引擎的计算时间并不影响渲染时间，提高效率。在时间同步上，渲染引擎因为是读取状态机而不进行计算，所以使用的是物理引擎的时间，不会出现位置和时间偏差。
**技术要点3****无限动态大地形在物理引擎中的实现**
         将全球的数据全加入物理引擎，在目前的硬件条件下还达不到。目前只能动态的加载和卸载地形数据。
         当前的全球渲染引擎，将地球划分为一个一个的小瓦片。物理引擎也使用相同的数据。
         首先，创建九个地形瓦片：
1  2  3
4  5  6
7  8  9
         以当前经纬度所在的瓦片为5，并将周围的8个瓦片用渲染引擎中的数据或其他高程数据填充就得到了一块小的物理地形，可以进行物理计算。
         当物理场景需要移动时，如向右移动，见下图下：
1x  2x  3x          3y
4x  5x  6x  -->   6y
7x  8x  9x          9y
         先将新的三个瓦片加入物理引擎中，变成12个瓦片
1x  2x  3x  3y
4x  5x  6x  6y
7x  8x  9x  9y
         再将最左边的三个瓦片卸载，变成9个瓦片
2x  3x  3y
5x  6x  6y
8x  9x  9y
         修改索引编号，回到原点
2x  3x  3y      　　  1x  2x  3x
5x  6x  6y   --> 　　4x  5x  6x
8x  9x  9y                7x  8x  9x
         往其他方向的移动使用相同原理。
以上的技术，已经实现
