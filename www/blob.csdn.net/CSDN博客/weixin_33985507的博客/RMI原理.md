# RMI原理 - weixin_33985507的博客 - CSDN博客
2015年11月11日 22:09:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3
**一、分布式对象**
    在学习 RMI 之前，先来分布式对象（Distributed Object）：分布式对象是指一个对象可以被远程系统所调用。对于 Java 而言，即对象不仅可以被**同一虚拟机中的其他客户程序**（Client）调用，也可以被运行于**其他虚拟机中的客户程序调用**，甚至可以**通过网络被其他远程主机之上的客户程序调用**。
    下面的图示说明了客户程序是如何调用分布式对象的：
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111213722853-1511205773.png)
     从图上我们可以看到，分布式对象被调用的过程是这样的：
1. 客户程序调用一个被称为 Stub （***存根***）的***客户端代理对象***。**该代理对象负责对客户端隐藏网络通讯的细节**。Stub 知道如何通过网络套接字（Socket）发送调用，包括如何将调用参数转换为适当的形式以便传输等。
2. Stub 通过网络将调用传递到服务器端，也就是分布对象一端的一个被称为 Skeleton（**骨干**） 的**代理对象**。同样，该代理对象负责对分布式对象隐藏网络通讯的细节。Skeleton 知道如何从网络套接字（Socket）中接受调用，包括如何将调用参数从网络传输形式转换为 Java 形式等。
3. Skeleton 将调用传递给分布式对象。分布式对象执行相应的调用，之后将返回值传递给 Skeleton，进而传递到 Stub，最终返回给客户程序。
      这个场景基于一个基本的法则，即行为的定义和行为的具体实现相分离。如图所示，***客户端代理对象 Stub 和分布式对象都实现了相同的接口，该接口称为远程接口（Remote Interface）。***正是该接口定义了行为，而分布式对象本身则提供具体的实现。对于 Java RMI 而言，我们用接口（interface）定义行为，用类（class）定义实现。
**二、RMI架构**
     RMI（Remote Method Invoke**远程方法调用**）。*在Java中，只要一个类extends了java.rmi.Remote接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。**同时，远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。*
  RMI框架如下图所示：
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111215911181-720755649.png)
1. Stub/Skeleton 层：该层提供了客户程序和服务程序彼此交互的接口。
2. 远程引用（Remote Reference）层：这一层相当于在其之上的 Stub/Skeleton 层和在其之下的传输协议层之前的中间件，负责处理远程对象引用的创建和管理。
3. 传输协议（Transport Protocol） 层：该层提供了数据协议，用以通过线路传输客户程序和远程对象间的请求和应答。
Java RMI 的客户程序使用客户端的 Stub 向远程对象请求方法调用；服务器对象则通过服务器端的 Skeleton 接受请求。
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220127431-1562528693.png)
整个调用过程如下：客户端从服务器端下载stub到本地，stub把客户端的参数序列化后，传至远程引用层；远程引用层根据RMI协议转换为传输层数据，通过传输层把数据传到服务器端；服务器端接收到从传输层传过来的数据，通过远程引用层通过RMI协议进行转换，Skeleton 把参数反序列化后传递给服务器端的方法调用。如果方法调用产生异常或返回值再经由Skeleton 序列化给客户端，客户端再反序列化
**Stub和Skeleton在什么位置产生**
从JDK5.0以后，这两个类就不需要rmic来产生了 ，而是有JVM自动处理，实际上他们还是存在的。Stub存在于客户端，作为客户端的代理，让我们总是认为客户端产生了stub，接口没有作用。**实际上stub类是通过Java动态类下载机制下载的，它是由服务端产生，然后根据需要动态的加载到客户端**，如果下次再运行这个客户端该存根类存在于classpath中，它就不需要再下载了，而是直接加载。（具体的内部细节，需要参考Sun 的Rmi - Java Remote Method Invocation – Specification）。总的来说，stub是在服务端产生的，如果服务端的stub内容改变，那么客户端的也是需要同步更新。
**Stub和公共接口interface（远程对象的功能）的关系**
一个服务如果没有合适的存根类，客户就没有办法去调用远程的接口，RMI使用存根来返 回引用远程对象接口的参数。在类的关系中，接口是不能实例化的，但是它可以指向一个实现该接口的实例。存根和接口就是这种关系，而存根类的实例就是在：lookup （）方法 调用时加载、实例的。接口只是告诉JVM，内存中这片的字节码中，这几个方法我可以调用。
**创建RMI流程**
建立RMI的流程如下：
1. 通过分析需求定义远程接口(客户端和服务器端公用的)，此接口必须扩展java.rmi.Remote，且远程方法必须声明抛出 java.rmi.RemoteException 异常，或者该异常的超类（Superclass）。
2. 服务器端实现远程接口，为了不手动生成stub需要继承UnicastRemoteObject类，并调用其构造器；
3. 服务器端注册服务并启动；
4. 客户端查询服务并调用远程方法；
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220313728-2010344596.png)
**三、代码示例**
分别建立三个项目：服务器端(DemoRMI.Server)、客户端(DemoRMI.Client)和远程接口(DemoRMI.RmoteInterface)，如下图：
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220443587-1049608482.png)
DemoRMI.RmoteInterface中的IHello.java
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220534619-1138807297.png)
DemoRMI.Server中的HelloImpl.java
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220619447-2091143204.png)
DemoRMI.Server中的App.java
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220709634-1917144078.png)
DemoRMI.Client中的App.java:
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111220757025-594930795.png)
![](https://images2015.cnblogs.com/blog/37237/201511/37237-20151111221306978-1282500361.png)
