# 使用泛型实现返回不同类型的对象 - weixin_33985507的博客 - CSDN博客
2018年11月08日 13:54:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：29

> 
本次功能的实现场景：读取Yaml配置文件，然后将其中的信息转换成指定的对象。 
  在这里定义了一个Yaml的工具类，希望工具类的返回对象类型可以根据调用方法时传入的对象类型来定义。
### 通过泛型实现
**工具类：**
```
public class YamlUtil {
    public <T> T readNodeFromYml(Class<T> type) throws YamlException, FileNotFoundException{
        File dumpFile = new File(System.getProperty("user.dir") + "/src/main/conf/searchNode.yml");
        YamlReader reader = new YamlReader(new FileReader(dumpFile));
        return reader.read(type);
    }
}
```
**调用工具类**
```
public static void main(String[] args) throws Exception {
        YamlUtil util=new YamlUtil();
        //读取yaml文件
        SearchNode searchNode = util.readNodeFromYml(SearchNode.class);
        TestStrategy strategy = searchNode.getTestStrategy();
        int num=strategy.add(2, 3);
        System.out.println(num);
    }
```
通过<T> 声明告诉JVM返回值定义一个泛型 T 
这里的T只是个占位符的效果，26个字母随便写哪个字母都可以，但一定要是和< >里面相同的字母，这里使用T。 
工具类传入的参数也是T类型的，通过`Class<T> type`定义一个T类型的参数，最终此方法的作用就成了：传入一个指定类型的对象，然后读取Yaml配置文件后再返回一个此类型的对象。
### 使用泛型和使用Object有何不同
**在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的[强制类型转换](http://baike.baidu.com/view/2886403.htm)，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。**
**泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。**
由此可见，使用泛型，有2个好处：
- 
不需要做强制类型转换
- 
编译时更安全。
