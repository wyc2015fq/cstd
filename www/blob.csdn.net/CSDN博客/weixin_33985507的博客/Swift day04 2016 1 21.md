# Swift day04 2016/1/21 - weixin_33985507的博客 - CSDN博客
2016年01月21日 19:35:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3
今天去面试 ,没听课 ,根据上课讲得做下笔记.
#### 1. 闭包,(类似 OC 中的 Block) 是将一段代码封装起来,变成一个类型变量的东西,可以作为参数传递,类似一个没有名字的函数.  swift 中闭包就是函数,但比函数更加灵活.
```
//输入输出参数  (相当于地址传递)  选择
func selectSort(inout data : [Int], function : (Int,Int)->Bool ) {
    for var i = 0; i < data.count - 1;i++ {
        //记录最小下标
        var k = i  //假设 i 位置最小
        for var j = i + 1; j < data.count; j++ {
//            if data[j] > data[k] {
            if function(data[j], data[k]) {
                k = j
            }
        } //循环是找到最小的值的下标
        if k != i { //如果假设对了,不用交换
            swap(&data[k], &data[i])
        }
    }
}
//func rule(a : Int,_ b : Int) ->Bool {
//    return a > b
//}
//func rule2(a : Int,_ b : Int) ->Bool {
//    return a < b
//}
var data = [9, 3, 5, 1, 2, 6, 8, 7, 4, 3]
//selectSort(&data,function: rule2)
/*
语法:
    {
        (parameters 参数列表)->returnType返回值类型  in 
            code
        return xxxx
    }
*/
selectSort(&data, function:
    {
        (a : Int, b : Int)->Bool in
            return a > b
})
data
//闭包可以缩写 或 省略
//参数类型可以省略
selectSort(&data, function:
    {
        (a, b)->Bool in
        return a > b
})
//返回值类型可以省略
selectSort(&data, function:
    {
        (a, b) in
        return a > b
})
//如果只有一条语句  return 可以省略
selectSort(&data, function:{(a, b) in a > b })
//参数名可以省略  $0是传入的第一个参数  $1是传入的第二参数
selectSort(&data, function:{ $0 < $1 })
//甚至可以直接省略掉参数
selectSort(&data, function:>)
```
//map 方法, 把数组每个元素取出放到闭包函数中执行, 把所有的执行结果放到一个新的数组
```
var newNums = numbers.map({
    (number : Int) ->Int in
        var n = number + 20
    return n
})
//拖尾闭包, 如果一个函数的最后一个参数传入的是闭包函数,可以写在()外面,如果只有个一个参数() 可以省略
var newNums2 = numbers.map{
    (number : Int) ->Int in
    var n = number + 20
    return n
}
```
### 2.enum
枚举中可以有方法
```
enum ConpassPoint {
     case North
     case South
     case East
     case West
     func show(){
       print(self)
     }
}
var p = CompassPoint.North
p.show()
enum CompassPoint2{
    case North, South, East, West
}
//声明一个枚举变量
var point : CompassPoint
//给一个枚举变量初始化
point = CompassPoint.North
point = .South //没有枚举的名字,通过上下文环境找到对应的枚举
//原始值 (裸值)
enum Week : Int{
    case Sun = 0, Mon, Tur, Wen, Thu, Fri, Sat
}
// C 中可以 int week = Sun
//Swift 中 枚举值不能直接当做Int使用, 如果需要当做Int使用,可以使用枚举的原始值(裸值)
var week : Int = Week.Sun.rawValue //用原始值给 Int 赋值
var week2 : Week? = Week(rawValue: 0)
//关联值
enum Barcode {
    case UPCA(Int,Int,Int)  //条形码
    case QRCode(String)   //二维码
}
var barcode = Barcode.UPCA(690, 690740102, 2)
barcode = Barcode.QRCode("ajkdlsjflkdsjf")
switch barcode {
case Barcode.UPCA(let(num, id, check)):
    print("这是一个条形码\(num)-\(id)-\(check)")
case Barcode.QRCode(let string):
    print("这是一个二维码 对应的字符串是 \(string)")
}
```
### 3.类和结构体
相同点:
1.类和结构体都是在定义一种类型
2.都可以在内部定义属性和方法
3.都可以定义下标运算符
4.都可以定义初始化方法(初始化器, 构造器, init)
5.都可以扩展现有功能 (类似OC中Category 分类, swift中没有分类)
6.都可以遵守指定的协议
不同点:
1.类可以继承, 结构体不可以继承
2.类有多态, 结构体没有多态
3.类的内存管理支持自动引用计数器,而结构体的内存不使用引用计数器, 结构体的变量都是在栈中分配的,出了作用域会自动释放,栈中的空间不需要我们管理
4.类是引用类型, 结构体是值类型
```
//类中的属性声明时必须初始化, 除非它是可选值
class VideoMode {
    var resolution = Resolution()
    var interloaced = false
    var frameRate = 0.0
    var name : String? //可选值
}
//结构是值类型,类是引用类型
var res = Resolution() //值类型
var res2 = res
res.width = 500
res.width
res2.width
var vmode = VideoMode() //引用类型
var vmode2 = vmode
vmode.name = "张三"
vmode.name
vmode2.name
//实际上是比地址 === 相等 !== 不等
if vmode !== vmode2 {
    print("两个引用 引用了不是同一块地址")
}
var rect = Rect(origin: Point(x: 100, y: 100), size: Size(w: 500, h: 500))
print("矩形的原点x是\(rect.origin.x), y是\(rect.origin.y)")
//结构体是用来封装少量简单的数据
//最简单的像  几何图形  CGPoint CGRect CGSize
let cgPoint = CGPoint(x: 100, y: 200)
```
### 4.Properties属性
Swift属性 有两个分类方式
第一种分类方式 :
存储属性 (Stored Properties)
用变量或常量保存属性的值
计算属性 (Calculate Properties)
不用变量或常量保存属性值, 值是通过计算的出的
出生日期 : 储存属性
年龄 :  计算属性   是通过 当前日期 - 出生日期计算出来的
第二种分类方式:
实例属性 和 类型属性
属性的附加: 属性监视器 (properties observer)
用于探知属性的值是否发生了变化
```
struct FixedLengthRange {
    //存储属性  用一个变量或常量保存属性的值
    var firstValue : Int
    let length : Int //逐一初始化器 也可以给常量初始化
}
var flr = FixedLengthRange(firstValue: 0, length: 3)
class DataManager {
    //延迟属性  类似OC 中的懒加载 或 延迟加载的功能
    lazy var dataImporter = DataImporter()
    var data = [String]()
}
```
计算属性
```
/******* 计算属性  ***************/
struct Point{
    var x = 0.0, y = 0.0
}
struct Size {
    var w = 0.0, h = 0.0
}
struct Rect {
    //存储属性
    var origin = Point()
    var size = Size()
    //计算属性
    //只有get 是只读计算属性,  如果有get set 是可读写计算属性
    var center : Point {
        get{
            let centerX = origin.x + size.w * 0.5
            let centerY = origin.y + size.h * 0.5
            return Point(x : centerX,y : centerY)
        }
        set /*(newCenter) 如果这里没有任何接收 默认使用 newValue*/ {
            let newOriginx = newValue.x - size.w * 0.5
            let newOriginy = newValue.y - size.h * 0.5
            origin = Point(x: newOriginx, y: newOriginy)
        }
    }
    
    //计算属性 只读计算属性如果只有一行代码 get 可以省略
    var center2 : Point {
        /*get {*/
            return Point(x: 500 + 100, y: 500 + 100)
        /*}*/
    }
}
var rect = Rect(origin: Point(x: 0, y: 0), size: Size(w: 300, h: 300))
rect.center.x
rect.center.y
rect.center = Point(x :200, y : 200)
rect.origin.x
rect.origin.y
```
