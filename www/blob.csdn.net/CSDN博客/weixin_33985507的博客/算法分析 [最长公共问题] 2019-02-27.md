# 算法分析 [最长公共问题] 2019-02-27 - weixin_33985507的博客 - CSDN博客
2019年02月27日 16:31:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：2
#### 1 最长公共子序列 LCS（相对顺序一致）
用二维数组记录**每次遍历的状态**，数组**最后一个值**是**最长公共子序列长度**
由于是**相对顺序**，只要出现过一次，后续
如果值相等，取`nums[i-1][j-1]+1`
否则，`Math.max(nums[i][j-1], nums[i-1][j])`
**列是被组合的值**
`nums[i][j-1]`是`加入`新值后**重新排列的值**
`nums[i-1][j]`是`不加`入新值，原有的**最大排列值**
![7423808-8b7d30a2a4eadaf1.png](https://upload-images.jianshu.io/upload_images/7423808-8b7d30a2a4eadaf1.png)
LCS公式.png
[583. 两个字符串的删除操作(删除字符串中公共子序列，需要多少步骤) Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
**法1.**`动态归纳法`，时间复杂度O(n*m)，空间复杂度(n*m)
**使用LCS公式**，**二维数组**
此提求解的是**找到使得 word1 和 word2 `相同`所需的`最小步数`**
**法2.**`动态归纳法`，时间复杂度O(n*m)，空间复杂度(n)**使用LCS公式**，**一维数组**，每行遍历都独立**创建一个临时一维数组**
[712. 两个字符串的最小ASCII删除和 Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)
#### 2 最长公共子串 DP（绝对顺序一致）
用二维数组记录**每次遍历的状态**
可以有化成**一维数组**，因为**不需要**记录**以前的状态**
由于是**相对顺序**，只要出现过一次，后续都在**前一个值上+1**
[718. 最长连续重复子数组(两个数组) Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/) medium
**法1.****动态规划** 矩阵 时间复杂度O(m*n) 时间复杂度`O(m*n)`
因为**输入**的是**两个数组**，因此要**保存状态**需要**二维数组**
数组，多一行, 一列，保存初始值
二维数组如果连续子串，在**二维矩阵**表示是**自左上角向右下角**有值
保存的值是，当前**所在位置**`最长`的**重复子数个数**
`row`是`第一个数组`，`列`是`第二个数组`
**法2.****动态规划** 矩阵 时间复杂度O(m*n) 时间复杂度`O(n)`
使用一位数组保存状态，特性是每次值匹配时会`dp[i-1][j-1] + 1`
那么我们**一维数组**保存的**上一个数组连续重复的值**，为了使用`dp[j-1]+1`，我们从后往前遍历
[53. 最大子序和(存在负数) Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) easy
**法1.**`动态归纳法`，时间复杂度O(n)，空间复杂度O(n)
使用dp[]记录第n个数组下标出现的最大子序和
> - 这里要理解，`dp[i]=nums[i] + (dp[i-1]<0?0:dp[i-1])`
- `dp[i-1]`就是**子集的最大值**，只有子集>=0才能增大现集，否则直接用当前值
- 用一个max记录
#### 3 最长公共前缀
##### 3.1 传入二维数组，处理逻辑，返回字符串
[14. 最长公共前缀 Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/) easy
从第一个字符串开始**逐字符遍历**，第 i 个字符，与所有剩下字符串的第 i 个做对比，全部相等，往存储增加入第 i 个字符，否则，返回存储的字符串
#### 4 最长递增
[3. 无重复字符的最长子串 Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/submissions/) medium
**法1.**`动态归纳法`，时间复杂度O(n^2)，空间复杂度O(n)
使用dp[]记录第n个数组下标出现连续最多未重复的次数
并且用一个**变量**保存**上一个数组**最后一次**重复的字符下标**
n+1数组可以直接和n数组值进行比较取最大值
**法2.**`滑动窗口`，时间复杂度O(n)，空间复杂度O(m)
利用一个Set<>保存最新的连续不重复子串，使用2个计数器，一个是窗口头，一个是窗口尾
每次存在**重复字符**时，开始**缩小**窗口，直到**不存在重复字符**时，开始**增大**窗口
[300. 最长上升子序列 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) medium
**法1.**`动态归纳法`，时间复杂度O(n^2)，空间复杂度O(n)
相对连续
使用dp[]记录第n个数组下标出现的上升子序列
n+1数组每次从0~n都做一次比较（因为新增的值可能比第0个值小）
[209. 值相加等于目标值，长度最小的子数组 Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/) medium
**法1**. `动态归纳法`**O(n^2), O(1)**，dp，**2层遍历实现连续子集**，由于是连续的，可以使用一个**状态变量**来记录**前一次的结果**，减少第三层循环
**法2**. `滑动窗口`**O(n), O(1)**，双指针，使用`第一个指针`**从左往右扫描**, 找到**大于**目标值, 再用`第二个指针`从**左往右缩小**区间, 直到区间**小于**目标值(对比最小子集进行替换)，再用`第一个指针`继续**向右扫描**，依次类推
[594. 最长和谐子序列（最大值和最小值差1） Longest Harmonious Subsequence](https://leetcode.com/problems/longest-harmonious-subsequence/)
**法1.** 时间复杂度O(n)，空间复杂度O(n)
使用Map记录所有key对应**出现的次数**，然后使用 key和key+1来统计最大值
[521. 最长特殊序列 Ⅰ Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/)
首先，字符串相等不行，然后选长的字符串，一定不会是短的子集
