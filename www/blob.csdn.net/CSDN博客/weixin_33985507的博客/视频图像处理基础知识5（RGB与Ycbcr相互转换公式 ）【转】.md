# 视频图像处理基础知识5（RGB与Ycbcr相互转换公式 ）【转】 - weixin_33985507的博客 - CSDN博客
2017年07月21日 14:35:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：5
转自：[http://blog.csdn.net/Times_poem/article/details/51471438](http://blog.csdn.net/Times_poem/article/details/51471438)
版权声明：本文为博主原创文章，未经博主允许不得转载。
**需求说明：视频处理[算法](http://lib.csdn.net/base/datastructure)基本知识**
**      第一部分：有参考出处的RGB与Ycbcr相互转换**
**      第二部分：简单直接的**RGB与Ycbcr相互转换****
第三部分：优化乘法的RGB与Ycbcr相互转换
**第一部分**
**来自：http://blog.chinaunix[.NET](http://lib.csdn.net/base/dotnet)/uid-215617-id-2212957.html**
在人脸检测中会用到YCbCr颜色空间，因此就要进行RGB与YCbCr颜色空间的转换，刚开始以为这个很简单，只不是加减乘除的问题，根据公式就可以了，但事实是有很多的公式，我在Baidu上找的，几乎没有什么可以能用的，一般的只有RGB转YCbCr，但是反过来就不行了，算不到正确的结果。
    我在图书馆找到一篇文章《数字RGB与YCbCr颜色空间转换的精度》作者：张懿,刘旭,李海峰，在这篇文章中找到了一个正确的相互转换的公式(也可能有误的)。在下面的公式中RGB和YCbCr各分量的值的范围均为0-255。
公式如下：
//数字RGB与YCbCr颜色空间转换的精度 
//在这两个公式中RGB和YCbCr各分量的值的范围均为0-255。
// RGB转换为YCbCr
// 这个公式来自：Genesis Microchip. gm6010/gm6015 Programming Guide[M]. California US: Genesis Microchip Company, 2002:85-90
// |Y   |    |16  |                    |65.738   129.057  25.06 |   |R|
// |Cb| = |128| + (1/256)*|-37.945  -74.494  112.43| *|G|
// |Cr |    |128|                   |112.439  -94.154  -18.28|   |B|
// YCbCr转换为RGB
// 这个公式来自：Genesis Microchip. gm6015 Preliminary Data Sheet[M]. California US: Genesis Microchip Company, 2001:33-34
//|R|                   |298.082  0               408.58 |   |Y   -16  |
//|G| = (1/256)*|298.082  -100.291 -208.12|* |Cb-128|
//|B|                   |298.082  516.411   0           |   |Cr -128|
加一点我的代码，为什么要加我的代码呢，不是因为写的代码好，只不过是我把上面公式中的矩阵/256算成小数了，这样子我们可以省点时间：
```
//
 RGB转换为YCbCr
```
```
for(i =0 ; i < dest->dwSize; )
{
 UCHAR r,g,b;
 r = sBuf[i+0];
 g = sBuf[i+1];
 b = sBuf[i+2];
 dBuf[i+0]= (unsigned char)(r * 0.256789 + g * 0.504129 + b * 0.097906)+ 16; 
 dBuf[i+1]= (unsigned char)(r *-0.148223 + g * -0.290992 + b * 0.439215)+ 128;
 dBuf[i+2]= (unsigned char)(r * 0.439215 + g * -0.367789 + b *-0.071426)+ 128; 
 i += 3;
}
```
`// YCbCr转换为RGB`
```
for(i =0 ; i < dest->dwSize; )
{
 UCHAR y,u,v;
 y = sBuf[i+0];
 u = sBuf[i+1];
 v = sBuf[i+2];
 dBuf[i+0]= (unsigned char)(1.164383*(y- 16) + 0 + 1.596027*(v - 128)); 
 dBuf[i+1]= (unsigned char)(1.164383*(y- 16) - 0.391762*(u - 128) - 0.812969*(v - 128)); 
 dBuf[i+2]= (unsigned char)(1.164383*(y- 16) + 2.017230*(u - 128) + 0 );
 i += 3;
}
```
**第二部分**
**来自：http://blog.csdn[.net](http://lib.csdn.net/base/dotnet)/a14730497/article/details/17886127**
Y：明亮度（Luminance或Luma），也就是灰阶值。“亮度”是透过RGB输入信号来建立的，方法是将RGB信号的特定部分叠加到一起。
Cb：反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。
Cr：反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。
在以下两个公式中RGB和YCbCr各分量的值的范围均为0-255。
RGB转换为YCbCr
Y   = 0.257*R+0.564*G+0.098*B+16
Cb = -0.148*R-0.291*G+0.439*B+128
Cr  = 0.439*R-0.368*G-0.071*B+128
等效为：
Y = (1/8192)[(135168 + 4129G) + (2015R + 803B)]     其他的Cb ，Cr 类似过程
//-------------------------------------------------------------------------------------------------------------------------------
YCbCr转换为RGB
R = 1.164*(Y-16)+1.596*(Cr-128)
G = 1.164*(Y-16)-0.392*(Cb-128)-0.813*(Cr-128)
B = 1.164*(Y-16)+2.017*(Cb-128)
或者
R = 1.164Y                + 1.596Cr - 222.912
G = 1.164Y - 0.391Cb - 0.813Cr + 135.488
B = 1.164Y + 2.018Cb                - 276.928
等效为：
R >> 9 = 596Y          + 817Cr - 114131
G >> 9 = 596Y - 200Cb  - 416Cr + 69370
B >> 9 = 596Y + 1033Cb         - 141787
**第三部分**
**来自： http://www.cnblogs.com/qiweiwang/archive/2011/07/07/2099731.html**
**YCbCr转RGB的公式如下：R = 1.164(Y-16) + 1.596(Cr-128);G = 1.164(Y-16) - 0.391(Cb-128) - 0.813(Cr-128);B = 1.164(Y-16) + 2.018(Cb-128);**
**其中的系数可以表示成**
**1.164  = 1 + 1/2^3 + 1/2^5 + 1/2^7;1.596  = 1 +1/2+ 1/2^4 + 1/2^5;0.391  = 1/2^2 + 1/2^3 + 1/2^6;0.813  = 1/2 + 1/2^2 + 1/2^4;2.018  = 2 + 1/2^6;故而，上述公式可以转化成没有乘法的公式，大大提高了运算的效率。**
**整理来自：时间的诗**
