# IOS内存管理 - weixin_33985507的博客 - CSDN博客
2019年02月15日 16:24:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：1
## 1 内存管理
1》需要理解什么是内存管理: 指软件运行时对计算机内存资源的分配和使用的技术 (达到 高效、快速、回收的目的).
2》内存分配: 数据是存在堆和栈中, 对与iOS(OC对象)是存在**堆中**这里需要我们进行内存管里而**栈中**的数据不需要我们处理. 举例如下:
![7785539-f11166396b34de32.png](https://upload-images.jianshu.io/upload_images/7785539-f11166396b34de32.png)
存储位置
## 栈内的基本数据类型:
![7785539-6b1e4621d41e22f1.png](https://upload-images.jianshu.io/upload_images/7785539-6b1e4621d41e22f1.png)
基本数据类型
浮点型: 分单精度(float)与双精度(double)   再说下区别: 
1.〉在内存中占有的字节数不同,  float 在手机内存占 4个字节 8位有效数字  
double 在手机内存占 8个字节 16位有效数字  
2〉float  表示数的范围 -3.40E +38  ~ +3.40E +38  
双精度范围: -1.79E +308 ~ +1.79E +308  
3〉程序处理速度 float > double
## 2 引用计数
1》**引用计数**是计算机编程语言中的一种内存**管理技术**.是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来.
2》创建一个对象的实例并在堆上申请内存时，对象的**引用计数**就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放.
3》之前内存管理是手动处理引用计数，在合适的地方使引用计数-1，直到减为0，内存释放.现在内存管理使用的是ARC(自动管理引用计数).而自动管理引用计数实现方式是在编译时期自动在已有代码中插入合适的内存管理代码(release和autorelease)以及在 Runtime 做一些优化。这几点要很清楚.
## 3 具体说明
在MRC的内存管理模式下，与对变量的管理相关的方法有：retain,release和autorelease。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease 调用）的变量进行管理，当drain时回收内存。对于**自动释放池**,系统有一个现成的自动内存管理池(看main方法)，他会随着每一个mainRunloop的结束而释放其中的对像；自动释放池也可以手动创建，他可以让pool中的对象在执行完代码后马上被释放，可以起到优化内存，防止内存溢出的效果（如视频针图片的切换时、创建大量临时对象时等）。
（1）retain，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;
（2）release，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;
（3）autorelease，该方法是将该对象内存的管理放到autoreleasepool中。
![7785539-51669204849c192e.png](https://upload-images.jianshu.io/upload_images/7785539-51669204849c192e.png)
释放图例
2. block 的ARC和MRC中的区别 (细节)
Block属性的声明，首先需要用copy修饰符，因为只有copy后的Block才会在堆中，栈中的Block的生命周期是和栈绑定的, 声明一个block 这里ARC和非ARC声明都是一样的,但在非ARC下则需要手动retain一下，否则如果属性被置空. MRC下__block修饰的变量，并不改变引用计数,同时block内部并不对引入的外部对象，更改引用计数。ARC下block会被修改为**__NSMallocBlock__** ,同时引用计数增加了。
