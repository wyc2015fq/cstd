# 70-483.C2O1-4.Create and use types - weixin_33985507的博客 - CSDN博客
2018年05月25日 11:16:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3
[Note Links](https://www.jianshu.com/p/aabf3cfe3700)
## Objective 2.1: Create types
### Choosing a type to create
#### Types in C#
The C# typing system contains three different categories:
- Value types
- Reference types
- Pointer types
Pointer types are rarely used. You use them only when working with unsafe code and when you need to use pointer arithmetic.
[MORE INFO ABOUT POINTERS AND UNSAFE CODE](http://msdn.microsoft.com/en-us/library/chfa2zb8.aspx)
#### Creating enums
An enum is a special kind of value type.
By default, the first element has the value 0, and each successive element is increased by 1, but you can change the starting index and the underlying type.
```
enum Days : byte { Sat = 1, Sun, Mon, Tue, Wed, Thu, Fri };
```
If you want to compare the Days enum to the underlying byte value, you have to cast it to a byte:
```
Days day = Days.Sat; 
if ((byte)day == 1) { }
```
Enumerations can also be used with a special `Flags` attribute; you can use one enum to set multiple combinations of values.
*LISTING 2-1  Using the FlagAttribute for an enum*
```
[Flags] 
enum Days 
{ 
    None = 0x0, 
    Sunday = 0x1, 
    Monday = 0x2, 
    Tuesday = 0x4, 
    Wednesday = 0x8, 
    Thursday = 0x10, 
    Friday = 0x20, 
    Saturday = 0x40 
} 
Days readingDays = Days.Monday | Days.Saturday;
```
#### Value and reference types
A reference type, as the name suggests, contains a reference to the real value; a value type contains the value directly.
The value of a reference type is stored on the heap, and the address to this value is stored on the stack.
A value type is normally stored on the stack, but there are exceptions (for example, a class that contains a value type as one of its fields, a lambda expression that closes over a value type, or a value type that is boxed).
The benefit of storing data on the stack is that it's faster, smaller, and doesn't need the attention of the garbage collector.
As a rule of thumb, you can check the following three criteria to determine whether you want to create a value type:
- The object is small.
- The object is logically immutable.
- There are a lot of objects.
In C#, all objects inherit from `System.Object`. Value types inherit from `System.ValueType`(which inherits from `System.Object`).
You cannot directly inherit from `System.ValueType`. Instead, you can use the `struct` keyword to create a new value type.
*LISTING 2-2  Creating a custom struct*
```
public struct Point  
{ 
    public int x, y; 
 
    public Point(int p1, int p2)  
    { 
        x = p1; 
        y = p2;     
   } 
}
```
You cannot, however, declare your own empty constructor for a struct. Also, structs cannot be used in an inheritance hierarchy (which saves you some memory bytes!).
### Giving your types some body
#### Adding behaviors
> 
**"FUNCTION" VERSUS "METHOD"**
A function's meaning implies that it returns a value and doesn't modify anything in the system. You can say a function is the "read" part of the system.
A method does enable data modification and doesn't return any data. This is the "write" part of the system.
In C#, the preferred term is "method".
When deciding on which arguments to take, it's important to think about what you will do with the data. Look at the examples shown in Listing 2-5 and Listing 2-6.
*LISTING 2-5  Passing a complete customer to a method*
```
public Distance CalculateDistanceTo(Customer customer) 
{ 
    Distance result =  … // Some difficult calculation that uses customer.Address  
    return result; 
}
```
*LISTING 2-6  Passing only an address to a method*
```
public Distance CalculateDistanceTo(Address address) 
{ 
    Distance result = … // Some difficult calculation that uses address 
    return result; 
}
```
Which method should you choose? The problem with the one in Listing 2-5 is that the Customer object is only used to retrieve the address. Suddenly the distance calculation algorithm is coupled to a Customer. Changes in the Customer class, such as adding a shipping address and a billing address, will ripple through to this class.
Listing 2-6 asks for only the data it needs. This is a clearer and simpler design that improves maintainability.
This pattern is called the **Law of Demeter**.
#### Named arguments, optional arguments, and overloading visibility
*LISTING 2-7  Using named and optional arguments*
```
void MyMethod(int firstArgument, string secondArgument = "default value",  
    bool thirdArgument = false) { }
void CallingMethod() 
{ 
    MyMethod(1, thirdArgument: true); 
}
```
*LISTING 2-8  Returning data from a method*
```
public void MethodWithoutAnyReturnValue() 
{ /* Don't return any value to the caller */ }
public int MethodWithReturnValue() 
{ 
    return 42; 
}
```
#### Adding some data
*LISTING 2-9  Declaring and using a field*
```
public class MyClass 
{ 
     public string MyInstanceField; 
 
     public string Concatenate(string valueToAppend) 
     { 
         return MyInstanceField + valueToAppend; 
     } 
}
MyClass instance = new MyClass(); 
instance.MyInstanceField = "Some New Value";
```
A field can be marked as `read-only`, which allows the field to be set only once during construction of the object. You can do this in the constructor or as a part of declaring your variable. After this, the field's value cannot be changed.
If the fields value is set at compile time, you can also mark it as `const`. That way, the compiler knows for sure that the value will never change and it can perform some optimization. This also ensures that you don't accidentally overwrite the value of the field.
*LISTING 2-10  Creating a collection such as a Deck class*
```
class Card {} 
 
class Deck 
{ 
    public ICollection<Card> Cards { get; private set; } 
}
```
An `indexer` property allows your class to be accessed with an index, just like a regular array.
```
public Card this[int index] 
{ 
    get { return Cards.ElementAt(index); } 
}
```
```
class MyClass 
{ 
    public static int MyStaticField = 42; 
}
```
A static field or property is shared with all code that has access to it. This can have some dangerous side effects because if you change a static value in one place, it will change for all code that has access to the field.
Static can also be used for methods. The same idea applies that you don't have to create an instance of a class to access a static method. If all methods in a class are static, the whole class can be declared static.
#### Using a blueprint
*LISTING 2-11  Adding a constructor to your type*
```
class Deck 
{ 
    private int _maximumNumberOfCards; 
 
    public List<Card> Cards { get; set; }
    public Deck(int maximumNumberOfCards) 
    { 
        this.maximumNumberOfCards = maximumNumberOfCards; 
        Cards = new List<Card>(); 
    } 
     
    // Rest of the class 
}
```
Some good practices when designing your constructors are these:
- Explicitly declare the public default construct in classes if such a constructor is required.
- Ensure that your constructor takes as few parameters as possible.
- Map constructor parameters to properties in your class.
- Throw exceptions from instance constructors if appropriate.
- Do not call virtual members from an object inside its constructor.
[MORE INFO ABOUT BEST PRACTICES FOR DESIGNING CONSTRUCTORS](https://msdn.microsoft.com/en-us/library/ms229060(v=vs.100).aspx)
*LISTING 2-12  Chaining constructors*
```
class ConstructorChaining 
{ 
    private int _p; 
 
    public ConstructorChaining() : this(3) { } 
    public ConstructorChaining(int p) 
    { 
        this._p = p; 
    } 
}
```
**In production code it's important that you make clear which constructor users of your class should use.**
### Designing classes
Two characteristics：
- High cohesion
- Low coupling
*TABLE 2-1  SOLID design principles*
|Initial|Stands for|Description|
|----|----|----|
|S|Single responsibility principle|A class should have only one responsibility. For example, a class shouldn't be both responsible for saving itself to the database and for displaying to the user.|
|O|Open/closed principle|An object should be open for extension but closed for modification. For example, by using a common interface, new objects can integrate with existing code without modifying the existing code.|
|L|Liskov substitution principle|A base type should be replaceable with subtypes in each and every situation. For example, a Duck that can swim and an inherited ElectricDuck that can swim only if the batteries are full. Suddenly, code needs to check whether the Duck is an ElectricDuck to replace empty batteries.|
|I|Interface segregation principle|Use client-specific interfaces instead of one general interface. A user of an interface should not have to implement all kinds of methods that he doesn't use.|
|D|Dependency Inversion principle|Depend upon abstractions, not concretions. For example, when you use SomeServiceType inside your class, you shouldn't depend on the actual implementation of SomeServiceType. Instead you should depend on an interface or abstract class. This way, you are less coupled to the actual implementation.|
MORE INFO ABOUT DESIGN PRINCIPLES
- [The Big Ball of Mud and Other Architectural Disasters](http://www.codinghorror.com/blog/2007/11/the-big-ball-of-mud-and-other-architectural-disasters.html)
- [The Principles of OOD - Uncle Bob](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)
### Using generic types
A `Nullable` is a wrapper around a value type with a Boolean flag that it stores if the Nullable has a value set.
*LISTING 2-13  Generic `Nullable<T>` implementation*
```
struct Nullable<T> where T : struct 
{ 
  private bool hasValue; 
  private T value; 
 
  public Nullable(T value) 
  { 
    this.hasValue = true; 
    this.value = value; 
  }
  public bool HasValue { get { return this.hasValue; } } 
 
  public T Value 
  { 
    get 
    { 
      if (!this.HasValue) throw new ArgumentException(); 
         return this.value; 
    } 
  } 
 
  public T GetValueOrDefault()  
  { 
    return this.value;  
  } 
}
```
*TABLE 2-2  Possible constraints for a generic type parameter*
|Constraint|Description|
|----|----|
|where T: struct|The type argument must be a value type (only Nullable is not allowed).|
|where T : class|The type argument must be a reference type: for example, a class, interface, delegate, or array.|
|where T : new()|The type must have a public default constructor.|
|where T : <base class name>|The type argument must be or derive from the specified base class.|
|where T : <interface name>|The type argument must be or implement the specified interface. Multiple interface constraints can be specified. The constraining interface can also be generic.|
|where T : U|The type argument supplied for T must be or derive from the argument supplied for U.|
*LISTING 2-14  Using a where clause on a class definition*
```
class MyClass<T>  
    where T : class, new() 
{ 
    public MyClass() 
    { 
        MyProperty = new T(); 
    } 
 
    T MyProperty { get; set; } 
}
```
The `default(T)` keyword gives you the default value for the specific type of T.
*LISTING 2-15  Using default(T) with a generic type parameter*
```
public void MyGenericMethod<T>() 
{ 
    T defaultValue = default(T); 
}
```
### Extending existing types
#### Extension methods
`Extension methods` enable you to add new capabilities to an existing type.
Extension methods need to be declared in a nongeneric, non-nested, static class.
*LISTING 2-16  Creating an extension method*
```
public class Product 
{ 
    public decimal Price { get; set; } 
} 
 
public static class MyExtensions 
{ 
    public static decimal Discount(this Product product) 
    { 
        return product.Price * .9M; 
    } 
} 
 
public class Calculator 
{ 
    public decimal CalculateDiscount(Product p) 
    { 
        return p.Discount(); 
    } 
}
```
The special `this` keyword makes this method an extension method.
The nice thing is that an extension method cannot only be declared on a class or struct. It can also be declared on an interface (such as `IEnumerable<T>`). LINQ is one of the best examples of how you can use this technique to enhance existing code.
#### Overriding Methods
*LISTING 2-17  Overriding a virtual method*
```
class Base 
{ 
    public virtual int MyMethod() 
    { 
        return 42; 
    } 
} 
 
class Derived : Base 
{ 
    public override int MyMethod() 
    { 
        return base.MyMethod() * 2; 
    } 
}
```
When `sealed` keyword is used on a class, you can't derive other classes from it. When used on a method, derived classes can't override the method.
*LISTING 2-18  Using the sealed keyword on a method*
```
class Base 
{ 
    public virtual int MyMethod() 
    { 
        return 42; 
    } 
} 
 
class Derived : Base 
{ 
    public sealed override int MyMethod() 
    { 
        return base.MyMethod() * 2; 
    } 
} 
 
class Derived2 : Derived 
{ 
    // This line would give a compile error 
    // public override int MyMethod() { return 1;} 
}
```
## Objective summary
- Types in C# can be a value or a reference type.
- Generic types use a type parameter to make the code more flexible.
- Constructors, methods, properties, fields, and indexer properties can be used to create a type.
- Optional and named parameters can be used when creating and calling methods.
- Overloading methods enable a method to accept different parameters.
- Extension methods can be used to add new functionality to an existing type.
- Overriding enables you to redefine functionality from a base class in a derived class.
## Objective 2.2: Consume types
### Boxing and unboxing
*LISTING 2-19  Boxing an integer value*
```
int i = 42; 
object o = i; 
int x = (int)o;
```
`Boxing` is the process of taking a value type, putting it inside a new object on the heap, and storing a reference to it on the stack. `Unboxing` is the exact opposite: It takes the item from the heap and returns a value type that contains the value from the heap.
If you execute an invalid unbox operation, the runtime will throw an `InvalidCastException`. You won't see the error at compile time because the compiler trusts you in making the right call.
Calling `GetType` always boxes your value type because GetType is defined only on an object and can't be overridden.
A value type is boxed when you use it as an interface. This snippet boxes the value 3 so you can use it as an interface.
```
IFormattable  x = 3;
```
The boxing and unboxing operations can hurt performance.
### Converting between different types
The process of converting one type to another is called type conversion.
#### Implicit conversions
*LISTING 2-20  Implicitly converting an integer to a double*
```
int i = 42; 
double d = i;
```
*LISTING 2-21  Implicitly converting an object to a base type*
```
HttpClient client = new HttpClient(); 
object o = client; 
IDisposable d = client;
```
#### Explicit conversions
*LISTING 2-22  Casting a double to an int*
```
double x = 1234.7; 
int a; 
// Cast double to int 
a = (int)x; // a = 1234
```
*LISTING 2-23  Explicitly casting a base type to a derived type*
```
Object stream = new MemoryStream(); 
MemoryStream memoryStream = (MemoryStream)stream;
```
#### User-defined conversions
*LISTING 2-24  Implementing an implicit and explicit conversion operator*
```
class Money 
{ 
    public Money(decimal amount) 
    { 
        Amount = amount; 
    } 
 
    public decimal Amount { get; set; } 
    public static implicit operator decimal(Money money) 
    { 
        return money.Amount; 
    } 
 
    public static explicit operator int(Money money) 
    { 
        return (int)money.Amount; 
    } 
}
```
*LISTING 2-25  Using an implicit and explicit cast operator on a custom type*
```
Money m = new Money(42.42M); 
decimal amount = m; 
int truncatedAmount = (int)m;
```
#### Conversions with a helper class
For converting between noncompatible types, you can use `System.BitConverter`. For conversion between compatible types, you can use `System.Convert` and the `Parse` or `TryParse` methods on various
types.
*LISTING 2-26  Using the built-in Convert and Parse methods*
```
int value = Convert.ToInt32("42"); 
value = int.Parse("42"); 
bool success = int.TryParse("42", out value);
```
Implementing the `IFormattable` interface is required so that your object can be used by the Convert class.
#### Confirming that a conversion is valid
The `is` operator returns true or false, depending on whether the conversion is allowed.
The `as` operator returns the converted value or null if the conversion is not possible.
*LISTING 2-27  Using the is and as operators*
```
void OpenConnection(DbConnection connection) 
{ 
    if (connection is SqlConnection) 
    { 
        // run some special code 
    } 
} 
 
void LogStream(Stream stream) 
{ 
    MemoryStream memoryStream = stream as MemoryStream; 
    if (memoryStream != null) 
    {  
      // .... 
    } 
}
```
### Using dynamic types
When the C# compiler encounters the `dynamic` keyword, it stops with statically type checking (for example, checking whether a method exists on a type or if it has certain arguments). Instead, the compiler saves the intent of the code so that it can be later executed at runtime. This is why using dynamic types won't generate any compile-time errors, although it can certainly generate runtime errors.
#### Office automation APIs
PIAs are .NET assemblies that bridge the gap between .NET and COM.
> 
PIA, Primary Interop Assembly
*LISTING 2-28  Exporting some data to Excel*
```
static void DisplayInExcel(IEnumerable<dynamic> entities) 
{ 
    var excelApp = new Excel.Application(); 
    excelApp.Visible = true; 
 
    excelApp.Workbooks.Add(); 
 
    dynamic workSheet = excelApp.ActiveSheet; 
 
    workSheet.Cells[1, "A"] = "Header A"; 
    workSheet.Cells[1, "B"] = "Header B"; 
 
    var row = 1; 
    foreach (var entity in entities) 
    { 
        row++; 
        workSheet.Cells[row, "A"] = entity.ColumnA; 
        workSheet.Cells[row, "B"] = entity.ColumnB; 
    } 
 
    workSheet.Columns[1].AutoFit(); 
    workSheet.Columns[2].AutoFit(); 
}
var entities = new List<dynamic> { 
                new  
                {  
                    ColumnA = 1, 
                    ColumnB = "Foo" 
                }, 
                new  
                { 
                    ColumnA= 2, 
                    ColumnB= "Bar" 
                } 
    }; 
 
DisplayInExcel(entities);
```
In this example, the type of workSheet is dynamic. The statements that use the worksheet variable are evaluated at runtime and dispatched to the Office application programming interfaces (APIs). All the type checking and necessary conversions take place at runtime.
#### DynamicObject and ExpandoObject
The .NET Framework offers two special classes when working with dynamic types: `DynamicObject` and `ExpandoObject`.
DynamicObject is the most flexible. By using DynamicObject, you can create truly dynamic objects and have full control over how they operate at runtime.
*LISTING 2-29  Creating a custom DynamicObject*
```
public class SampleObject : DynamicObject 
{ 
    public override bool TryGetMember(GetMemberBinder binder, out object result) 
    { 
        result = binder.Name; 
        return true; 
    } 
}
dynamic obj = new SampleObject(); 
Console.WriteLine(obj.SomeProperty); // Displays 'SomeProperty'
```
ExpandoObject is a sealed implementation that enables you to get and set properties on a type.
In ASP.NET Model-View-Controller (MVC), for example, there is a `ViewBag` that can be used to pass data from the Controller to the View. `ViewBag` is an ExpandoObject.
*LISTING 2-30  The dynamic keyword in ASP.NET MVC*
```
public ActionResult Index() 
{ 
    ViewBag.MyDynamicValue = "This property is not statically typed"; 
    return View(); 
}
```
## Objective summary
- Boxing occurs when a value type is treated as a reference type.
- When converting between types, you can have an implicit or an explicit conversion.
- An explicit conversion is called casting and requires special syntax.
- You can create your own implicit and explicit user-defined conversions.
- The .NET Framework offers several helper methods for converting types.
- The dynamic keyword can be used to ease the static typing of C# and to improve interoperability with other languages.
## Objective 2.3: Enforce encapsulation
### Using access modifiers
*TABLE 2-3  Access modifiers in C#*
|Access modifier|Description|
|----|----|
|public|None; restricted access|
|internal|Limited to the current assembly|
|protected|Limited to the containing class and derived classes|
|protected internal|Limited to the current assembly or derived types|
|private|Limited to the containing type|
#### Hiding with private
*LISTING 2-32  Using the private access modifier*
```
public class Accessibility 
{ 
    private string _myField; 
 
    public string MyProperty 
    { 
        get { return _myField;  } 
        set { _myField = value; } 
    } 
}
```
*LISTING 2-33  Changing a private field without outside users noticing*
```
public class Accessibility 
{ 
    // initialization code and error checking omitted 
    private string[] _myField;
    public string MyProperty 
    { 
        get { return _myField[0]; } 
        set { _myField[0] = value; } 
    } 
}
```
#### Protecting accessibility in inheritance hierarchies
`Protected` restricts accessibility to members of the type and all classes that derive from it. It can be used on all members of a class.
*LISTING 2-34  Using the protected access modifier with inheritance*
```
public class Base 
{ 
    private int _privateField = 42; 
    protected int _protectedField = 42; 
 
    private void MyPrivateMethod() { } 
    protected void MyProtectedMethod() { } 
}
public class Derived : Base 
{ 
    public void MyDerivedMethod() 
    { 
        // _privateField = 41; // Not OK, this will generate a compile error 
        _protectedField = 43; // OK, protected fields can be accessed 
        // MyPrivateMethod(); // Not OK, this will generate a compile error 
        MyProtectedMethod(); // OK, protected methods can be accessed 
    } 
}
```
#### Keeping types internal to your assembly
`Internal` restricts access to a type or a type member to the same assembly.
When using the `protected internal` access modifier, keep in mind that it is or, not and.
You can use `InternalsVisibleToAttribute` attribute to specify another assembly that can also access the internal types.
```
[assembly:InternalsVisibleTo("Friend1a")] 
[assembly:InternalsVisibleTo("Friend1b")]
```
*TABLE 2-4  Allowed access modifiers on nested types*
|Members of|Default member accessibility|Allowed declared accessibility of the member|
|----|----|----|
|enum|public|None|
|class|private|public, protected, internal, private, protected, internal|
|interface|public|None|
|struct|private|public, internal, private|
The access modifier of the enclosing type is always taken into account. For example, a public method inside an internal class has an accessibility of internal. There are exceptions to this (for example, when an internal class implements a public interface or when a class overrides a public virtual member of a base class).
It's a good practice to always explicitly choose for the lowest visibility possible because you want to hide as much information as possible.
### Using properties
*LISTING 2-37  Creating a property*
```
class Person 
{ 
    private string _firstName; 
 
    public string FirstName 
    { 
        get { return _firstName; } 
        set 
        { 
            if (string.IsNullOrWhiteSpace(value))  
                throw new ArgumentException(); 
            _firstName = value; 
        } 
    } 
}
```
C# has a shorthand notation for property called an `auto-implemented property`.
```
public int Value { get; set; }
```
The get and set accessor can have different access modifiers.
**Always favor properties over fields for public members. An automatically implemented property looks like a field to the outside world, but you can always add extra behavior when necessary.**
### Using explicit interface implementations
Example: In Entity Framework, `DbContext` implements the interface `IObjectContextAdapter` explicitly.
*LISTING 2-38  The IObjectContextAdapter interface*
```
public interface IObjectContextAdapter 
{ 
    ObjectContext ObjectContext { get; } 
}
```
The following code won't compile:
```
DbContext ctx = …; // create a new context 
var context = ctx.ObjectContext;
```
The following will compile:
```
var adaptedContext = ((IObjectContextAdapter)ctx).ObjectContext;
```
*LISTING 2-39  Implementing an interface explicitly*
```
interface IInterfaceA 
{ 
    void MyMethod(); 
}
class Implementation : IInterfaceA 
{ 
    void IInterfaceA.MyMethod() { } 
}
```
With explicit interface implementation, interfaces have their own implementation.
*LISTING 2-40  Implementing an interface explicitly*
```
interface ILeft 
{ 
    void Move(); 
}
interface IRight 
{ 
    void Move(); 
}
class MoveableOject : ILeft, IRight 
{ 
    void ILeft.Move() { } 
    void IRight.Move() { } 
}
```
## Objective 2.4: Create and implement a class hierarchy
### Designing and implementing interfaces
*LISTING 2-41  Creating and implementing an interface*
```
interface IExample 
{ 
    string GetResult(); 
    int Value { get; set; } 
    event EventHandler ResultRetrieved; 
    int this[string index] { get; set; } 
}
class ExampleImplementation : IExample 
{ 
    public string GetResult() 
    { 
        return "result"; 
    }
    public int Value { get; set; } 
 
    public event EventHandler CalculationPerformed;
    public event EventHandler ResultRetrieved; 
 
    public int this[string index] 
    { 
        get 
        { 
            return 42; 
        } 
        set { } 
    } 
}
```
*LISTING 2-42  Adding a set accessor to an implemented interface property*
```
interface IReadOnlyInterface 
{ 
    int Value { get; } 
}
struct ReadAndWriteImplementation:IReadOnlyInterface 
{ 
    public int Value { get;  set; } 
}
```
The advantage of using this pattern is that if a user accesses your class through its interface, it will see only the get accessor. Direct users of the class will see both the get and the set accessor.
*LISTING 2-43  Creating an interface with a generic type parameter*
```
interface IRepository<T> 
{ 
    T FindById(int id); 
    IEnumerable<T> All(); 
}
```
Interfaces can also inherit from other interfaces.
#### Using interfaces
*LISTING 2-44  Instantiating a concrete type that implements an interface*
```
interface IAnimal 
{ 
    void Move(); 
}
class Dog : IAnimal 
{ 
    public void Move() {} 
    public void Bark() {} 
} 
 
IAnimal animal = new Dog();
```
Interfaces can also be used as parameters in a method.
```
void MoveAnimimal(IAnimal animal) 
{ 
    animal.Move(); 
}
```
One of the important concepts of object-oriented development is programming against a contract, not an implementation. The interface guarantees you that certain functionality is available (the contract).
> 
NO MULTIPLE INHERITANCE
The creators of C# decided against implementing multiple inheritance because of the associated difficulties it can have. When using multiple inheritance, you can get conflicts when both base classes have a method with the same signature. C# does offer multiple interface inheritance with the option of explicitly implementing an interface to separate the different implementations. Multiple class inheritance is not supported.
### Creating and using base classes
*LISTING 2-45  Creating a base class*
```
interface IEntity 
{ 
    int Id { get; } 
}
class Repository<T> 
    where T : IEntity 
{ 
    protected IEnumerable<T> _elements; 
 
    public Repository(IEnumerable<T> elements) 
    { 
        _elements = elements; 
    } 
 
    public T FindById(int id) 
    { 
        return _elements.SingleOrDefault(e => e.Id == id); 
    } 
}
```
*LISTING 2-46  Inheriting from a base class*
```
class Order : IEntity 
{ 
    public int Id { get; } 
    // Other implementation details omitted 
    // …      
} 
 
class OrderRepository : Repository<Order> 
{ 
    public OrderRepository(IEnumerable<Order> orders) 
        : base(orders) { } 
 
    public IEnumerable<Order> FilterOrdersOnAmount(decimal amount) 
    { 
        List<Order> result = null; 
        // Some filtering code 
        return result; 
    } 
}
```
You can use the base keyword to call the constructor of the base class. The base keyword can also be used when you want to call methods or other members on a base class.
> 
CHILD AND PARENT OR BASE AND DERIVED
Instead of using Parent and Child when defining an inheritance relation, you can better use the terms base and derived class to avoid any confusion with inheritance in the real world.
#### Changing behavior
Marking a method `virtual` allows derived classes to `override` the method. The derived class can choose to completely replace or to extend the behavior of the base class.
*LISTING 2-47  Overriding a virtual method*
```
class Base 
{ 
    protected virtual void Execute() 
    {} 
}
class Derived : Base 
{ 
    protected override void Execute() 
    { 
        Log("Before executing"); 
        base.Execute(); 
        Log("After executing"); 
    } 
    private void Log(string message) { /* some logging code */ } 
}
```
By prefixing a method name with base, a derived class can execute the method on the base class. By skipping the call to base, the derived class completely replaces the functionality.
*LISTING 2-48  Hiding a method with the new keyword*
```
class Base 
{ 
    public void Execute() { Console.WriteLine("Base.Execute"); } 
}
class Derived : Base 
{ 
    public new void Execute() { Console.WriteLine("Derived.Execute"); } 
} 
class Program  
{ 
    static void Main(string[] args) 
    { 
         Base b = new Base(); 
         b.Execute(); 
         b = new Derived(); 
         b.Execute(); 
    } 
}
```
Running this code will output Base.Execute twice. You should try to avoid hiding methods with the `new` keyword.
#### Abstract and sealed base classes
If you don't want to allow a base class to be instantiated, you can declare it as an `abstract` class.
*LISTING 2-49  Creating an abstract class*
```
abstract class Base 
{ 
    public virtual void MethodWithImplementation() {/*Method with implementation*/} 
 
    public abstract void AbstractMethod(); 
}
class Derived : Base 
{ 
    public override void AbstractMethod() { } 
}
```
A concrete derived type is required to implement all abstract members ( just as with an interface). Abstract classes can be a nice way to share both an interface and some implementation details, especially when only derived types should be instantiable.
`override` can be used on abstract or virtual methods, properties, indexers, and events to extend or modify the implementation.
A `sealed` class cannot be derived from. Structs are implicitly sealed in C#. It's never possible to inherit from a struct.
Marking a class as sealed is a good practice. If you don't do this, others can start inheriting from your class without you having thought about this.
> 
DIFFERENCE BETWEEN INTERFACE AND ABSTRACT CLASS
An interface has no implementation code. An abstract class can choose to implement methods or leave it to the derived class.
#### Liskov substitution principle
Inheritance should be used only when you are dealing with a "is-a-kind-of" relationship.
The `Liskov substitution principle` states that a subclass should be usable in each place you can use one of the base classes.
It's easy to violate this principle.
*LISTING 2-50  A Rectangle class with an Area calculation*
```
class Rectangle 
{ 
    public Rectangle(int width, int height) 
    { 
        Width = width; 
        Height = height; 
    }
    public int Height { get; set; } 
 
    public int Width { get; set; }
    public int Area 
    { 
        get 
        { 
            return Height * Width; 
        } 
    } 
}
```
*LISTING 2-51  A Square class that inherits from Rectangle*
```
class Square : Rectangle 
{ 
    public override int Width 
    { 
        get 
        { 
            return base.Width; 
        } 
        set 
        { 
            base.Width = value; 
            base.Height= value; 
        } 
    }
    public override int Height 
    { 
        get 
        { 
            return base.Height; 
        } 
        set 
        { 
            base.Height = value; 
            base.Width = value; 
        } 
    } 
}
```
*LISTING 2-52  Using the Square class*
```
Rectangle rectangle = new Square(); 
rectangle.Width = 10; 
rectangle.Height = 5; 
 
Console.WriteLine(rectangle.Area);
```
This code will output 25. The user thinks he's dealing with a Rectangle with a calculated Area, but because the Rectangle is pointing to a Square, only the latest value of Height is stored.
This is a typical example of violating the Liskov substitution principle. The Square class cannot be used in all places where you would normally use a Rectangle.
### Implementing standard .NET Framework interfaces
#### IComparable
This interface is used to sort elements.
*LISTING 2-53  IComparable interface*
```
public interface IComparable 
{ 
    int CompareTo(object obj); 
}
```
*TABLE 2-5  Return values of CompareTo*
|Value|Meaning|
|----|----|
|Less than zero|The current instance precedes the object specified by the CompareTo method in the sort order.|
|Zero|This current instance occurs in the same position in the sort order as the object specified by the CompareTo method.|
|Greater than zero|This current instance follows the object specified by the CompareTo method in the sort order.|
*LISTING 2-54  Implementing the IComparable interface*
```
class Order : IComparable 
{ 
     public DateTime Created { get; set; } 
 
     public int CompareTo(object obj) 
     { 
         if (obj == null) return 1; 
 
         Order o = obj as Order; 
 
         if (o == null) 
         { 
             throw new ArgumentException("Object is not an Order"); 
         } 
         return this.Created.CompareTo(o.Created); 
     } 
}
List<Order> orders = new List<Order> 
{ 
    new Order { Created = new DateTime(2012, 12, 1 )}, 
    new Order { Created = new DateTime(2012, 1, 6 )}, 
    new Order { Created = new DateTime(2012, 7, 8 )}, 
    new Order { Created = new DateTime(2012, 2, 20 )}, 
}; 
 
orders.Sort();
```
The call to `orders.Sort()` calls the CompareTo method to sort the items. After sorting, the list contains the ordered Orders.
Especially when dealing with methods from the .NET Framework, it's a good idea to implement both `IComparable` and `IComparable<T>`.
#### IEnumerable
The `IEnumerable` and `IEnumerator` interface in .NET helps you to implement the `iterator pattern`, which enables you to access all elements in a collection without caring about how it's exactly implemented.
*LISTING 2-55  Syntactic sugar of the foreach statement*
```
List<int> numbers = new List<int> { 1, 2, 3, 5, 7, 9 }; 
using (List<int>.Enumerator enumerator = numbers.GetEnumerator()) 
{ 
    while (enumerator.MoveNext()) Console.WriteLine(enumerator.Current); 
}
```
The `GetEnumerator` function on an `IEnumerable` returns an `IEnumerator`.
*LISTING 2-56  Implementing `IEnumerable<T>` on a custom type*
```
class Person 
{ 
    public Person(string firstName, string lastName) 
    { 
        FirstName = firstName; 
        LastName = lastName; 
    }
    public string FirstName { get; set; } 
    public string LastName { get; set; } 
 
    public override string ToString() 
    { 
        return FirstName + " " + LastName; 
    } 
}
class People : IEnumerable<Person> 
{ 
    public People(Person[] people) 
    { 
        this.people = people; 
    }
    Person[] people;
    public IEnumerator<Person> GetEnumerator() 
    { 
        for (int index = 0; index < people.Length; index++) 
        { 
            yield return people[index]; 
        } 
    } 
    IEnumerator IEnumerable.GetEnumerator() 
    { 
        return GetEnumerator(); 
    } 
}
```
`Yield` is a special keyword that can be used only in the context of iterators. It instructs the compiler to convert this regular code to a state machine. The generated code keeps track of where you are in the collection and it implements methods such as `MoveNext` and `Current`.
#### IDisposable
`IDisposable` is used to facilitate working with external, unmanaged resources.
*LISTING 2-57  The IDisposable interface*
```
public interface IDisposable  
{ 
        void Dispose();  
}
```
`Dispose()` is used to free any unmanaged resources.
#### IUnknown
Normally, you just add a reference to a COM object and the compiler generates the necessary wrapper classes called COM Interop classes. If this fails for some reason, you have to create the wrapper class; this is where the IUnknown interface is used.
[Using and Implementing IUnknown](https://msdn.microsoft.com/en-us/library/windows/desktop/ms693423(v=vs.85).aspx)
## Objective summary
- Inheritance is the process in which a class is derived from another class or from an interface.
- An interface specifies the public elements that a type must implement.
- A class can implement multiple interfaces.
- A base class can mark methods as virtual; a derived class can then override those methods to add or replace behavior.
- A class can be marked as abstract so it can't be instantiated and can function only as a base class.
- A class can be marked as sealed so it can't be inherited.
- The .NET Framework offers default interfaces such as IComparable, IEnumerable, IDisposable and IUnknown.
[Note Links](https://www.jianshu.com/p/aabf3cfe3700)
