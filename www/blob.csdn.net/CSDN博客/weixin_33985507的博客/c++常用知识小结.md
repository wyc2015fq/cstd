# c++常用知识小结 - weixin_33985507的博客 - CSDN博客
2010年09月01日 08:04:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：2
1、输入输出：ifstream、ofstream、fstream这些类的完整定义在标准库文件fstream.h中，所以凡有关文件的操作要在程序中使用：#include<fstream.h>语句以包含进这个文件。输入是要注意（1）从键盘上输入数据的个数、类型及顺序，必须与cin中列举的变量一一对应；（2）cin不能将输入的空格、回车键赋给字符变量，若要把从键盘上输入的每一个字符赋给变量，必须使用函数cin.get()其格式为：cin.get(字符变量)或字符变量=cin.get()也可以为cin.get(str,100,'a')。(3)当结束输入时，输入流中的换行符‘\n’或其他结束字符不会被自动丢弃，仍留在输入流中，作为下次输入的第一个字符，所以经常用成员函数ignore()来丢弃这个字符，用来清空输入流。十六进制八进制数据的输入输出：hex表示十六进制oct表示八进制dec表示十进制如cin>>hex>>i;cin>>oct>>j;cin>>dec>>m;值得注意的是（1）八进制或十六进制数输入只能适用于整型变量（2）当在cin中指明使用的数制输入后，则所指明的数制一直有效，直到重新指明输入数制；输出与输入相同，如果在输出时要指明输出项的宽度如cout.width(5);或cout<<setw(6)<<i<<set(10)<<j;(setw指明其后紧跟项的输出宽度,并向右对齐)则在程序的开始位置必须包含头文件iomainip.h，科学表示法输出实数：cout.setf(ios::scientific);cout<<x<<'\n';(x为实数);设置左右对齐：cout.setf(ios::left)和cout.setf(ios::right);设置输出实数的有效位数：可以使用cout.precision(3)或c++的操纵函数setprecision()不过此时要在程序中包含库文件iomanip.h，如：cout<<setprecision(3)。设置输出域的填充字符：方法1是使用ios的成员函数fill()，如：cout.fill('*'),方法2是使用c++操纵函数setfill(),此时需要在程序中包含库文件iomanip.h,如：cout<<stefill('#')。可以使用函数cin.getline(char *s,int length)来实现字符串的输入，当输入的长度小于length时，将实际输入的字符串送给s,当输入字符串的长度大于length时，只取length个字符送给s，且自动加‘\0’。istream的成员函数read（）可以从输入流读取指定数量的字符，如cin.read(str,5)。输出：put()用于输出一个字符，由于函数的返回类型为ostream类的对象引用，所以可以串联使用,如：cout.put('y').put('e').('s');write()用于输出一个指定长度的字符串，如：cout.write(str,3)。文件的打开方式有两种方法：（1）调用文件流类的构造函数：类名  文件流对象名（“磁盘文件名”，打开方式）；如ifstream  infile("a.txt",ios::binary)在当前目录打开一个二进制文件,ofstream outfile("b.txt")在当前目录打开一个文本文件;（2）调用文件流类成员函数open()：文件流对象名.open("磁盘文件名"，打开方式)，如：ifstream inflie; infile.open("a.dat",ios::binary)；两种方法的结果是一样的，文件打开成功，则文件流对象为非0值，否则为0，可用此来判断文件的操作是否成功。关闭文件：文件流对象名.close()，如inflie.close()。判断文件是否结束：一是用文件流成员函数eof()，如infile.eof(),若结束返回非0值，否则返回0；二是判断输入表达式的返回值，如infile>>a[i]或infile.get(),若文件结束返回0值，否则返回非0值。对二进制文件的操作：读入二进制文件的成员函数read()：文件流对象名：read((char *)内存地址，读入的字节数)，如：int a[40];infile.read((char *)a,40);输出二进制文件成员函数wrie：文件流对象名.write((char *)内存地址，输出的字节数)，如：int a[10]={0,1,2,3,4,5,6,7,8,9};outfile.write((char *)a,5*sizeof(int))。控制文件读指针函数格式为：文件流对象名.seekg(<偏移量>,<参照位置>)；控制文件写指针的函数格式为：文件流对象名.seekp(<偏移量>,<参照位置>)；参照位置只能是ios::beg//文件头,ios::cur//当前位置,ios::end()//文件结尾三者之一。与文件指针有关的函数：gcount()//返回最后一次输入所读入的字节数，tellg()//返回输入文件指针的当前位置，tellp()//返回输出文件指针的当前位置。
2、switch（常量）语句中常量只能是整型常量或字符型常量。
3、函数形参的作用：（1）表示将从主调函数中接收那些类型的数据；（2）形参可以在函数体中被引用，可以输入、输出、赋值或参与运算。参数传递：（1）值传递：函数调用时仅将其值赋给形参，在函数中对形参的任何操作都不会影响到实参的值；（2）引用传递：其本质是给一个已经定义的变量起一个别名，系统不为引用变量分配存储空间，而是规定引用变量和与其关联的变量使用同一个内存空间，在函数中对形参的任何操作都将影响到实参的值。内敛函数：将函数的代码直接插入到函数调用处，将调用函数的方式改为顺序执行插入的程序代码，以此来节省调用函数的时间开销，定义一个内敛函数，只需在定义函数时在函数类型前增加关键字inline修饰即可。使用带有默认参数的函数时应该注意：（1）默认参数的声明必须出现在函数调用之前；（2）默认参数个数不限，但所有的默认参数均须放在参数表的最后，如float v(foat a,float b=10,float c) float v(float a=10,float b,float c=20)都是不允许的。寄存器变量（register int i）采用动态存储方式，使用时应注意以下几点：（1）只有局部自动变量和形式参数可以作为寄存器变量；（2）一个计算机中的寄存器数目有限，不能定义任意多个寄存器变量；（3）静态局部变量不能定义为寄存器变量。extern型变量：用关键字extern修饰的变量称为外部类型变量，一定是全局变量，用extern修饰全局变量的作用是扩展全局变量的作用域。内部函数和外部函数：在有多个源程序文件的程序中，若一个源程序文件中定义的函数只能在本源程序文件中使用，这种函数称为内部函数，定义内部函数的方法是在函数类型标示符前加修饰词static；若一个源程序文件中定义的函数不仅能在本源程序文件中使用，而且可以在其他源程序文件中使用，这种函数称为外部函数，定义方法是在函数类型表示符前加修饰词extern，若省略extern约定为外部函数。
4、宏定义说明：（1）宏展开只是一个简单的“机械”替换，不做任何语法检查，不是一个语句，其后不用加分号";"（2）#define命令出现在函数的外部，其有效范围为定义处至本源文件结素，可以用#undef命令终止宏定义的作用域（3）在进行宏定义中，可以用已经定义的宏名进行层层置换（4）对程序中用双引号括起来的字符串内容，即使与宏名相同，也不进行置换。
5、new说明：（1）new运算符分配完空间后，返回这个空间的首地址，这个首地址必须用一个指针保存下来才不会丢失，且只能用该指针引用这个空间的值；（2）可以使用语句:p=new int;分配一个整型变量空间，此时该空间未被初始化（初始化为：p=new int(2),2是初值）；（3）分配连续空间格式为：p=new int[n],n为空间个数，连续空间不能初始化；（4）动态分配失败会返回一个空指针（NULL），所以分配后要检查返回值来防止程序出现异常；（5）使用new分配的空间，要使用delete显示的释放，否则该空间会一直保留（delete 指针名，释放连续空间为：delete []指针名）。
6、结构体和共用体:除了在定义的时候初始化，结构体变量不可以整体赋值，在输入输出或运算的时候只能对其成员进行引用，不能作为一个整体参与运算，但是可以将一个结构体变量的值赋给另一个具有相同类型的结构体变量，即两个类型相同的结构体变量可以相互赋值。共用体：（1）共用体变量的各个成员共享同一块存储空间，所以在任一时刻只能有一个成员起作用，共用体变量中的内容是其最后一次赋值的成员成员内容；（2）共用体变量的地址和它的各个成员的地址都是同一地址；（3）共用体变量的长度是它最长的成员的长度；（4）不能对共用体变量名赋值，也不能在定义共用体变量的时候对其初始化；（5）不能把共用体变量作为函数的参数，但是可以使用指向共用体变量的指针。
枚举：（1）枚举常量不可赋值运算；（2）在声明枚举类型的同时，编译程序按顺序给每个枚举常量一个对应的序号，序号从0开始，后续元素依次加1；（3）可以在声明时指定枚举常量的序号值，如：enum weekday{sun=9,mon=2,tue,wed,thu,fir,sat}此时，tue未指定，仍然是前一序号值加一，其值为3，wed值为4等；（4）只能给枚举变量赋枚举常量值，若赋序号值必须进行强制类型转换，如：day=(weekday)1;(5)枚举变量可以相互比较，也可以和枚举常量及整型数据进行比较，实际上比较的是其序号值；（6）枚举值可以按整型输出其序号值。typedef说明：（1）typedef只可以声明类型，但不能定义变量；（2）typedef只能对已经存在的类型名重新定义一个类型名，而不能创建一个新的类型名；（3）typedef与#define有相似之处，但二者是不同的，主要区别是：#define是编译预处理命令，只能做简单的字符替换，typedef是编译时处理的，声明一个类型替代原有的类型。
7、构造函数和析构函数：构造函数说明：（1）如果定义类时没有为类提供任何构造函数，系统会为该类自动提供一个无参的函数体为空的构造函数；（2）如果定义类时已经定义了构造函数，那么系统不再自动提供默认的构造函数；（3）参数全部缺省的构造函数只能有一个，即可以不提供参数而调用的构造函数只能有一个；（4）构造函数可以重载，但每个对象调用的构造函数必须唯一。复制构造函数：同样满足构造函数的规则，即函数名为类名，没有函数类型，没有返回值，只不过其参数是同类对象的引用，如：定义复制构造函数tri（tri &t）{a=t.a;b=t.b;c=t.c}，调用为:tri tria(3,4,5); tri trib(tria)。
8、静态数据成员相当于是类中的“公用数据”它的值对所有的对象都是一样的，所有的对象都可以引用它，静态数据成员的空间是公共的、唯一的；静态数据成员必须在类体外初始化，默认的初值为0，初始化格式为：数据类型 类名：：静态成员数据名=初值；静态数据成员受类的访问权限限制；静态成员数据属于类，被所有的对象共享，定义了类以后，即使还没有创建对象，类的静态成员数据也已经存在，别且可以被访问。
9、静态成员函数说明：（1）静态成员函数是专门操作静态成员数据的成员函数，与具体的对象无关，没有this指针，只能直接引用静态成员数据；（2）静态成员函数可以用对象名调用，如：tria.show()，也可以直接用类名调用，如:tri::show（）；（3）静态成员函数属于类，在定义了类以后，即使号没有创建对象，类的静态成员函数也可以被访问。
10、友缘函数：友缘函数可以访问类中保护或私有的成员，将一个普通函数声明为一个类的友缘函数的方法是：在类的定义中加入该函数的函数原型，并将关键字friend放到函数原型前面；注意：友缘函数是类外的函数，不是相应类的成员函数，没有类体中的this指针，需要用对象名.成员名的形式访问类中的成员数据，同时，其形参一般是对象的引用形式，友缘函数在类中声明的位置可以是public、private和protectd区域中的任一个，它不受类的访问权限的影响。
11、友缘类说明：（1）友缘的关系是单向的而不是双向的；（2）友缘关系不能传递。
12、C++为了区分重载运算符前置++、--和后置++、--在运算符函数的参数列表上做了特殊的规定：前置时，参数列表不变，即成员函数没有参数，如：fra operator ++();后置时，成员函数要带一个整型参数（这是一个伪参数，不参与运算，其唯一的作用就是将该函数与前置运算符函数分开），如：fra operator ++(int)。
13、继承和派生：公有继承：基类的公有成员和保护成员在派生类中的访问权限不变，仍为公有成员和保护成员，而基类的私有成员在派生类中的访问权限成为不可访问；私有继承：基类的公有成员和保护成员在派生类中的访问权限全部成为私有成员，而基类的私有成员的访问权限仍为不可访问，当定义派生类时省略基类的继承方式时，默认的继承方式是私有继承；保护继承：基类的公有成员和保护成员在派生类中的访问权限全部成为保护成员，而基类的私有成员在派生类中的访问权限仍为不可访问。派生类构造函数：派生类构造函数名（总参数列表）：基类1构造函数名（参数列表1），基类构造函数名2（参数列表2），···，基类构造函数名n（参数列表n）{派生类中新增成员初始化语句}；有子对象的派生类的构造函数：派生类构造函数名（总参数列表）：基类构造函数名（参数列表），子对象名（参数列表）{派生类中新增数据成员初始化语句}。执行派生类构造函数的顺序是：（1）调用基类构造函数，调用顺序按照他们继承时说明的顺序；（2）调用子对象类的构造函数，调用顺序按照他们在类中说明的顺序；（3）执行派生类构造函数体中的内容。继承的冲突与支配：当多个基类存在同名成员的时候，要使用类限定符进行区分（如类stu和类emp中都有成员show()当派生类stu_emp调用show时，若要输出学生信息则表示为s.stu::show()若要输出职工信息则表示为s.semp::show()），当基类和派生类中出现了同名成员，那么，在派生类中定义的成员具有支配地位，即覆盖基类中成员。赋值兼容：在公有继承情况下派生类对象和基类对象间的赋值关系有以下三种情况：（1）派生类对象可以赋值给基类对象（der d;base b;b=d;）;(2)派生类对象可以初始化基类引用（der d;base &br=d;）;(3)派生类对象的地址可以赋给基类的指针（der d;base *pb=&d）。
14、虚函数：语句重定位即动态联编：进入不同的类对象时，语句定位到相应的代码段，要实现动态联编，需要将为实现多态性而运行的函数定义为虚函数。关于虚函数的说明：（1）派生类中的虚函数必须与基类中的虚函数具有相同的函数名，相同的参数列表，相同或相似的返回类型；（2）派生类中与基类中虚函数同原型的成员函数，也一定是虚函数，在其定义中，关键字virtual可以被省略，即虚函数是可以继承的；（3）虚函数是实现动态联编的必要条件，动态多态性的实现需要满足三个条件：1是类之间满足赋值兼容规则，2是要在基类中声明虚函数，3是要通过基类指针或基类引用调用虚函数；（4）虚函数必须是类的非静态成员函数；（5）构造函数不能是虚函数，析构函数可以是虚函数；（6）虚函数的执行速度要稍慢一些，为了实现多态性，每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现的。纯虚函数：在基类中没有实现部分的函数称为纯虚函数，声明形式一般为：virtual 函数类型 函数名（参数列表）=0；说明：（1）纯虚函数没有函数体，只是一个声明语句，后面带有分号；（2）最后的“=0”表示该虚函数没有任何具体实现，只是一个形式，可以被派生类继承和改写。抽象类：如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类，说明：（1）抽象类中的虚函数可能是在抽象类中定义的，也可能是从它的抽象基类中继承下来且重定义的；（2）抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例，但可以定义抽象类的指针或引用以实现运行时的多态性；（3）抽象类不能用作函数参数类型、函数返回值类型或显示转换类型；（4）抽象类不可以用来创建对象，只能用来为派生类提供一个接口规范，派生类中必须重载抽象类中的纯虚函数，否则它仍将被看作一个抽象类。
15、模板：（1）函数模板：template<模板参数表>                            如：template<class t>
                     函数类型  函数名（函数参数表）                         void swap(t &a,t &b)
                     { 函数体 }                                         {t temp=a;a=b;b=temp;}
函数模板不是一个真正的函数，如果要使其发生作用，必须在程序中用具体的数据类型对模板参数机型调用，即将其实例化，成为模板函数。如 int a=2,b=3; swap(a,b);//直接调用。
（2）类模板：template<模板参数表>
           class<类名>
           {类体说明};
           template<模板参数表>
           <函数类型><类名><模板参数名表>：：<成员函数1>(函数形参表)
           {成员函数1定义体}
             .
             .
             .
           template<模板参数表>
           <函数类型><类名><模板参数名表>：：<成员函数n>(函数形参表)
           {成员函数n定义体}
