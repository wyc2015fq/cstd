# JVM内存模型（上） - weixin_33985507的博客 - CSDN博客
2017年08月10日 22:42:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：9
### JVM简介
内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象，不同架构下的物理机拥有不一样的内存模型，Java虚拟机也有自己的内存模型，即Java内存模型（Java Memory Model，JMM）。
Java虚拟机（JVM）是Java应用的运行环境，从一般意义上来讲，JVM是通过规范来定义的一个虚拟的计算机，被设计用来解释执行从Java源码编译而来的字节码。更通俗地说，JVM是指对这个规范的具体实现。这种实现基于严格的指令集和全面的内存模型。
### JVM数据类型
Java虚拟机中，数据类型可以分为两类：基本类型和引用类型。基本类型的变量保存原始值，即：它代表的值就是数值本身；而引用类型的变量保存引用值。“引用值”代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。
- 基本类型包括：byte,short,int,long,char,float,double,Boolean,returnAddress
- 引用类型包括：类类型，接口类型和数组。
### JVM内存模型
在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区。
![4444657-fe6dd9acf4a4b1bf.png](https://upload-images.jianshu.io/upload_images/4444657-fe6dd9acf4a4b1bf.png)
栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
  在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的，包括局部变量、程序运行状态、方法返回值等等。而堆则是所有线程共享的，只负责存储对象信息。
**为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？**
第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
第三，由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂。
**堆中存什么？栈中存什么？**
- **基本类型和对象的引用都是存放在栈中**，因为原始类型占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的，还会浪费空间。因为栈是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的，包括局部变量、程序运行状态、方法返回值等等
- **对象都是存放在堆中**，因为一个对象的大小是不可估计的，或者说是可以动态变化的。
堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
**Java内存模型在JVM中的逻辑视图**
![4444657-ecb197d8baf16f63.jpg](https://upload-images.jianshu.io/upload_images/4444657-ecb197d8baf16f63.jpg)
**Java中的参数传递时传值呢？还是传引用？**
首先要明确两点：
- 不要试图与C进行类比，Java中没有指针的概念
- 程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。
所以，Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。
对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。
**设置堆栈大小**
Java中，栈的大小通过-Xss来设置，当栈中存储数据比较多时，需要适当调大这个值，否则会出现java.lang.StackOverflowError异常。常见的出现这个异常的是无法返回的递归，因为此时栈中保存的信息都是方法返回的记录点。
#### Java内存模型和硬件架构之间的桥接
从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，当然一部分栈和堆的数据也有可能会存到CPU寄存器中，如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：
![4444657-b113e7e416517945.jpg](https://upload-images.jianshu.io/upload_images/4444657-b113e7e416517945.jpg)
#### 内存交互操作
**内存交互简介**
不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示：
![4444657-bd3382fce97b97e6.jpg](https://upload-images.jianshu.io/upload_images/4444657-bd3382fce97b97e6.jpg)
> 
注意：这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分，这两者基本上没有关系。
由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：
- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
这8种内存访问操作很繁琐，后文会使用一个等效判断原则，即先行发生（happens-before）原则来确定一个内存访问在并发环境下是否安全。
**先行发生原则（happens-before）**
前面所述的内存交互操作必须要满足一定的规则，而happens-before就是定义这些规则的一个等效判断原则。happens-before是JMM定义的2个操作之间的偏序关系：
- 如果操作A线性发生于操作B，则A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。
- 如果两个操作满足happens-before原则，那么不需要进行同步操作，JMM能够保证操作具有顺序性。
- 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。
happens-before原则主要包括：
- 程序次序规则：在同一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。
- 管理锁定规则：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。
- volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。 通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。
- 线程终止规则：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。
- 传递性：如果操作A 先行发生于操作B，操作B先行发生于操作C，那么可以得出A先行发生于操作C。
> 
注意：不同操作时间先后顺序与先行发生原则之间没有关系，二者不能相互推断，衡量并发安全问题不能受到时间顺序的干扰，一切都要以happens-before原则为准。
#### 重排序及内存屏障
**重排序**
在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序指的是代码书写的顺序与实际执行的顺序不同。从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：
![4444657-8f1d91ddc2f3d374.png](https://upload-images.jianshu.io/upload_images/4444657-8f1d91ddc2f3d374.png)
  重排序可能会导致这样的结果：
```
//代码顺序                            //执行顺序
int number= 1;                       int result = 0;
int result = 0;                      int number = 1;
```
|名称|代码示例|说明|
|----|----|----|
|写后读|a = 1;b = a;|写一个变量之后，再读这个位置|
|写后写|a = 1;a = 2;|写一个变量之后，再写这个变量|
|读后写|a = b;b = 1;|读一个变量之后，再写这个变量|
但是**无论如何重排序，程序执行的结果应该与代码执行的结果一致(as-if-serial语义)**。但是并不是所有的语句的执行顺序都可以重排，有数级依赖关系不能进行重排序，如下面所示：
|名称|代码示例|说明|
|----|----|----|
|写后读|a = 1;b = a;|写一个变量之后，再读这个位置|
|写后写|a = 1;a = 2;|写一个变量之后，再写这个变量|
|读后写|a = b;b = 1;|读一个变量之后，再写这个变量|
上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。所以，编译器和处理器在重排序时，必须遵守as-if-serial语义。
**重排序对多线程的影响**
在单线程程序中，由于as-ifserial语义的存在，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果，破坏了多线程程序的语义。
```
class ReorderExample {
    int a = 0;
    //flag变量是个标记，用来标识变量a是否已被写入。
    boolean flag = false;
    public void writer() {
        a = 1;          // 1
        flag = true;    // 2
    }
    public void reader() {
        if (flag) {            // 3
            int i = a * a;     // 4
        }
    }
}
```
这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：
![4444657-754396dc4a878af4.png](https://upload-images.jianshu.io/upload_images/4444657-754396dc4a878af4.png)
如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，**多个线程对相同变量的修改相互不可见，导致某部分操作被覆盖**，在这里多线程程序的语义被重排序破坏了！
**内存屏障**
从Java源代码到最终实际执行的指令序列，会经过三种重排序。但是，为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。
内存屏障(Memory Barrier)，又称内存栅栏，是一个CPU指令。内存屏障有两个功能：
- 通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。
- 强制刷出各种CPU cache，如一个`Write-Barrier`（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。
volatile是基于Memory Barrier实现的。如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个`Write-Barrier`指令，并在读这个字段之前插入一个`Read-Barrier`指令。这意味着，如果写入一个volatile变量，就可以保证其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。
