# 判断树是否平衡 - weixin_33985507的博客 - CSDN博客
2016年03月20日 21:46:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：10
其实关于树的好多题都是递归的。。
首先复习一下什么是平衡树：
![1704608-563126e00d2699c0.png](https://upload-images.jianshu.io/upload_images/1704608-563126e00d2699c0.png)
平衡二叉树
即：所有节点的左右子树的高度差不超过1
思路之一：
求每个节点的高度
假设我们有一个`getTreeDepth(TreeNode* tree )`的函数
然后这样：
```
bool IsBalanced(TreeNode* tree)
{
    if (tree == NULL)
        return 1;
    
    int leftHigh = getTreeDepth(tree->left);
    int rightHigh = getTreeDepth(tree->right);
    if (leftHigh - rightHigh > 1 || leftHigh - rightHigh < -1)
        return false;
    return IsBalanced(tree->left) && IsBalanced(tree->right);
}
```
但是呢，这个方法有一个老问题，就是普通的递归求Fibnacci数列的直接调用`f(n)=f(n-1)+f(n-2)`这个函数会导致大量的重复计算，上面这个函数也是这样，我们从根节点开始算depth也是遍历了很多次，所以我们稍稍改进一下：
```
bool IsBalanced(TreeNode* tree, int* depth)
{
    if (tree == NULL)
    {
        *depth = 0;
        return true;
    }
    int left, right;
    if (IsBalanced(tree->left, &left) && IsBalanced(tree->right, &right))
    {
        int diff = left - right;
        if (diff >= -1 && diff <= 1)
        {
            *depth = (left > right ? left : right) + 1;
            return true;
        }
    }
    return false;
}
bool IsBalanced(TreeNode* tree)
{
    int depth = 0;
    return IsBalanced(tree, &depth);
}
```
其实思路是差不多的，只是通过递归的方法，从最下面开始计算。
同样的思路也可以求路径长呢。
文章参考[何海涛大神文章](https://link.jianshu.com?t=http://zhedahht.blog.163.com/)
