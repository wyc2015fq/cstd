# 代理模式 - weixin_33985507的博客 - CSDN博客
2017年06月26日 16:37:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：9
### 一.代理模式概念
> 
代理（Proxy）是一种设计模式， 提供了对目标对象另外的访问方式；即通过代理访问目标对象。 这样好处： 可以在目标对象实现的基础上，增强额外的功能操作。(扩展目标对象的功能)。
![1616232-328c3b6f7b6e9b17.png](https://upload-images.jianshu.io/upload_images/1616232-328c3b6f7b6e9b17.png)
### 二.静态代理
> 
代理对象，要实现与目标对象一样的接口
1.可以做到在不修改目标对象的功能前提下，对目标对象功能扩展。
2.缺点：
- a.因为代理对象，需要与目标对象实现一样的接口。所以会有很多代理类，类太多。
- b.一旦接口增加方法，目标对象与代理对象都要维护。
接口类：StudentDao .java
```
package com.huan.a_static;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public interface StudentDao {
    void delect();
}
```
目标对象：StudentDaoImpl.java
```
package com.huan.a_static;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class StudentDaoImpl implements StudentDao {
    public void delect() {
        System.out.println("删除数据成功");
    }
}
```
代理对象：StudentDaoProxy.java
```
package com.huan.a_static;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class StudentDaoProxy implements StudentDao {
    //接收保存目标对象
    private StudentDao target;
    public StudentDaoProxy(StudentDao target){
        this.target=target;
    }
    public void delect() {
        System.out.println("开始事务");
        target.delect();//执行目标对象的方法
        System.out.println("结束事务");
    }
}
```
测试用例：
```
package com.huan.a_static;
import com.huan.BeanTest.UserDao;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class Test {
    public static void main(String[] args){
        //目标对象
        StudentDao studentDao = new StudentDaoImpl();
        //代理
        StudentDao proxy = new StudentDaoProxy(studentDao);
        proxy.delect();
    }
}
```
![1616232-b00f2f280726a6b4.png](https://upload-images.jianshu.io/upload_images/1616232-b00f2f280726a6b4.png)
### 三.动态代理
> 
1）代理对象，不需要实现接口；
2）代理对象的生成，是利用JDKAPI， 动态的在内存中构建代理对象(需要我们指定创建 代理对象/目标对象 实现的接口的类型);
- 动态代理， JDK代理， 接口代理；
###### 动态代理总结：
` 代理对象不需要实现接口，但是目标对象一定要实现接口；否则不能用动态代理！
接口类：StudentDao .java
```
package com.huan.b_dynameic;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public interface StudentDao {
    void delect();
}
```
目标对象：StudentDaoImpl.java
```
package com.huan.b_dynameic;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class StudentDaoImpl implements StudentDao {
    public void delect() {
        System.out.println("删除数据成功");
    }
}
```
代理对象：StudentDaoProxy.java
```
package com.huan.b_dynameic;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class ProxyFactory  {
    //接收保存目标对象
    private Object target;
    public ProxyFactory(Object target){
        this.target = target;
    }
    //给目标对象生成代理对象
    public  Object getProxyFactory() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开启事务");
                        //执行目标对象
                        Object returnValue = method.invoke(target,args);
                        System.out.println("提交事务");
                        return returnValue;
                    }
                });
    }
}
```
测试用例：
```
package com.huan.b_dynameic;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class Test {
    public static void main(String[] args){
        //目标对象
       StudentDao studentDao =new StudentDaoImpl();
        //代理
        StudentDao proxy = (StudentDao) new ProxyFactory(studentDao).getProxyFactory();
        //执行方法
        proxy.delect();
    }
}
```
![1616232-1afd491056b0967a.png](https://upload-images.jianshu.io/upload_images/1616232-1afd491056b0967a.png)
### 四.Cglib代理
> 
Cglib代理，也叫做子类代理。在内存中构建一个子类对象从而实现对目标对象功能的扩展。
###### Cglib子类代理：
- 需要引入cglib – jar文件， 但是spring的核心包中已经包括了cglib功能，所以直接引入spring-core-3.2.5.jar即可。
2）引入功能包后，就可以在内存中动态构建子类
3）代理的类不能为final， 否则报错。
4） 目标对象的方法如果为final/static, 那么就不会被拦截，即不会执行目标对象额外的业务方法。
目标对象：StudentDaoImpl.java
```
package com.huan.c_cglib;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class StudentDaoImpl  {
    public void delect() {
        System.out.println("删除数据成功");
    }
}
```
Cglib子类对象 ProxyFactory .java
```
package com.huan.c_cglib;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class ProxyFactory implements MethodInterceptor {
    /**
     * Cglib子类对象
     * 对UserDao 在内存中构建一个子类对象
     */
    //接收保存目标对象
    private Object target;
    public ProxyFactory(Object target){
        this.target = target;
    }
    //给目标对象创建代理对象
    public Object getProxyInstance(){
        //工具类
        Enhancer en = new Enhancer();
        //设置父类
        en.setSuperclass(target.getClass());
        //设置回调函数
        en.setCallback(this);
        // 创建子类：代理对象对象
        return en.create();
    }
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("开始事务---");
        method.invoke(target,objects);
        System.out.println("结束事务----");
        return null;
    }
}
```
测试用例：
```
package com.huan.c_cglib;
/**
 * Created by 马欢欢 on 2017/6/25.
 */
public class Test {
    public static void main(String[] args){
       StudentDaoImpl studentDao = new StudentDaoImpl();
       StudentDaoImpl proxy = (StudentDaoImpl) new ProxyFactory(studentDao).getProxyInstance();
       proxy.delect();
    }
}
```
![1616232-d9a16b3b875d888b.png](https://upload-images.jianshu.io/upload_images/1616232-d9a16b3b875d888b.png)
> 
#### 上一篇：[Spring--IOC容器——对象依赖关系（注解）](https://www.jianshu.com/p/9024c049396e)
#### 文集：[Spring框架学习](https://www.jianshu.com/nb/13696397)
