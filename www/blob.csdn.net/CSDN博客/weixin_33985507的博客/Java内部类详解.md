# Java内部类详解 - weixin_33985507的博客 - CSDN博客
2016年02月15日 11:09:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：2
　　说起内部类这个词，想必很多人都不陌生，但是又会觉得不熟悉。原因是平时编写代码时可能用到的场景不多，用得最多的是在有事件监听的情况下，并且即使用到也很少去总结内部类的用法。今天我们就来一探究竟。下面是本文的目录大纲：
　　一.内部类基础
　　二.深入理解内部类
　　三.内部类的使用场景和好处
　　四.常见的与内部类相关的笔试面试题
　　若有不正之处，请多谅解并欢迎批评指正。
　　请尊重作者劳动成果，转载请标明原文链接：
　　http://www.cnblogs.com/dolphin0520/p/3811445.html
## 一.内部类基础
　　在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。
　　1.成员内部类
　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：
```
```java
class
```
```java
Circle {
```
```java
```
```java
double
```
```java
radius =
```
```java
0
```
```java
;
```
```java
```
```java
```
```java
public
```
```java
Circle(
```
```java
double
```
```java
radius) {
```
```java
```
```java
this
```
```java
.radius = radius;
```
```java
```
```java
}
```
```java
```
```java
```
```java
class
```
```java
Draw {
```
```java
//内部类
```
```java
```
```java
public
```
```java
void
```
```java
drawSahpe() {
```
```java
```
```java
System.out.println(
```
```java
"drawshape"
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
　　这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
```
```java
class
```
```java
Circle {
```
```java
```
```java
private
```
```java
double
```
```java
radius =
```
```java
0
```
```java
;
```
```java
```
```java
public
```
```java
static
```
```java
int
```
```java
count =
```
```java
1
```
```java
;
```
```java
```
```java
public
```
```java
Circle(
```
```java
double
```
```java
radius) {
```
```java
```
```java
this
```
```java
.radius = radius;
```
```java
```
```java
}
```
```java
```
```java
```
```java
class
```
```java
Draw {
```
```java
//内部类
```
```java
```
```java
public
```
```java
void
```
```java
drawSahpe() {
```
```java
```
```java
System.out.println(radius);
```
```java
//外部类的private成员
```
```java
```
```java
System.out.println(count);
```
```java
//外部类的静态成员
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
　　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
```
```java
外部类.
```
```java
this
```
```java
.成员变量
```
```java
外部类.
```
```java
this
```
```java
.成员方法
```
```
　　虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：
```
```java
class
```
```java
Circle {
```
```java
```
```java
private
```
```java
double
```
```java
radius =
```
```java
0
```
```java
;
```
```java
```
```java
public
```
```java
Circle(
```
```java
double
```
```java
radius) {
```
```java
```
```java
this
```
```java
.radius = radius;
```
```java
```
```java
getDrawInstance().drawSahpe();
```
```java
//必须先创建成员内部类的对象，再进行访问
```
```java
```
```java
}
```
```java
```
```java
```
```java
private
```
```java
Draw getDrawInstance() {
```
```java
```
```java
return
```
```java
new
```
```java
Draw();
```
```java
```
```java
}
```
```java
```
```java
```
```java
class
```
```java
Draw {
```
```java
//内部类
```
```java
```
```java
public
```
```java
void
```
```java
drawSahpe() {
```
```java
```
```java
System.out.println(radius);
```
```java
//外部类的private成员
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
　　成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：
```
```java
public
```
```java
class
```
```java
Test {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)  {
```
```java
```
```java
//第一种方式：
```
```java
```
```java
Outter outter =
```
```java
new
```
```java
Outter();
```
```java
```
```java
Outter.Inner inner = outter.
```
```java
new
```
```java
Inner();
```
```java
//必须通过Outter对象来创建
```
```java
```
```java
```
```java
//第二种方式：
```
```java
```
```java
Outter.Inner inner1 = outter.getInnerInstance();
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Outter {
```
```java
```
```java
private
```
```java
Inner inner =
```
```java
null
```
```java
;
```
```java
```
```java
public
```
```java
Outter() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
Inner getInnerInstance() {
```
```java
```
```java
if
```
```java
(inner ==
```
```java
null
```
```java
)
```
```java
```
```java
inner =
```
```java
new
```
```java
Inner();
```
```java
```
```java
return
```
```java
inner;
```
```java
```
```java
}
```
```java
```
```java
```
```java
class
```
```java
Inner {
```
```java
```
```java
public
```
```java
Inner() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
　　内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一 个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权 限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。
　　2.局部内部类
　　局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
```
```java
class
```
```java
People{
```
```java
```
```java
public
```
```java
People() {
```
```java
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Man{
```
```java
```
```java
public
```
```java
Man(){
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
People getWoman(){
```
```java
```
```java
class
```
```java
Woman
```
```java
extends
```
```java
People{
```
```java
//局部内部类
```
```java
```
```java
int
```
```java
age =
```
```java
0
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
new
```
```java
Woman();
```
```java
```
```java
}
```
```java
}
```
```
　　注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
　　3.匿名内部类
　　匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：
```
```java
scan_bt.setOnClickListener(
```
```java
new
```
```java
OnClickListener() {
```
```java
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
onClick(View v) {
```
```java
```
```java
// TODO Auto-generated method stub
```
```java
```
```java
```
```java
}
```
```java
```
```java
});
```
```java
```
```java
```
```java
history_bt.setOnClickListener(
```
```java
new
```
```java
OnClickListener() {
```
```java
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
onClick(View v) {
```
```java
```
```java
// TODO Auto-generated method stub
```
```java
```
```java
```
```java
}
```
```java
```
```java
});
```
```
　　这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：
```
```java
new
```
```java
OnClickListener() {
```
```java
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
onClick(View v) {
```
```java
```
```java
// TODO Auto-generated method stub
```
```java
```
```java
```
```java
}
```
```java
```
```java
}
```
```
　　就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。
```
```java
private
```
```java
void
```
```java
setListener()
```
```java
{
```
```java
```
```java
scan_bt.setOnClickListener(
```
```java
new
```
```java
Listener1());
```
```java
```
```java
history_bt.setOnClickListener(
```
```java
new
```
```java
Listener2());
```
```java
}
```
```java
class
```
```java
Listener1
```
```java
implements
```
```java
View.OnClickListener{
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
onClick(View v) {
```
```java
```
```java
// TODO Auto-generated method stub
```
```java
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Listener2
```
```java
implements
```
```java
View.OnClickListener{
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
onClick(View v) {
```
```java
```
```java
// TODO Auto-generated method stub
```
```java
```
```java
```
```java
}
```
```java
}
```
```
　　这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。
　　匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编 译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实 现或是重写。
　　4.静态内部类
　　静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。 静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有 外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体 的对象。
```
```java
public
```
```java
class
```
```java
Test {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)  {
```
```java
```
```java
Outter.Inner inner =
```
```java
new
```
```java
Outter.Inner();
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Outter {
```
```java
```
```java
public
```
```java
Outter() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
static
```
```java
class
```
```java
Inner {
```
```java
```
```java
public
```
```java
Inner() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
![](https://images0.cnblogs.com/i/288799/201407/021558444183591.jpg)
## 二.深入理解内部类
　　1.为什么成员内部类可以无条件访问外部类的成员？
　　在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：
```
```java
public
```
```java
class
```
```java
Outter {
```
```java
```
```java
private
```
```java
Inner inner =
```
```java
null
```
```java
;
```
```java
```
```java
public
```
```java
Outter() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
Inner getInnerInstance() {
```
```java
```
```java
if
```
```java
(inner ==
```
```java
null
```
```java
)
```
```java
```
```java
inner =
```
```java
new
```
```java
Inner();
```
```java
```
```java
return
```
```java
inner;
```
```java
```
```java
}
```
```java
```
```java
```
```java
protected
```
```java
class
```
```java
Inner {
```
```java
```
```java
public
```
```java
Inner() {
```
```java
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
　　编译之后，出现了两个字节码文件：
![](https://images0.cnblogs.com/i/288799/201407/021630063402064.jpg)
　　反编译Outter$Inner.class文件得到下面信息：
```
```java
E:\Workspace\Test\bin\com\cxh\test2>javap -v Outter$Inner
```
```java
Compiled from
```
```java
"Outter.java"
```
```java
public
```
```java
class
```
```java
com.cxh.test2.Outter$Inner
```
```java
extends
```
```java
java.lang.Object
```
```java
```
```java
SourceFile:
```
```java
"Outter.java"
```
```java
```
```java
InnerClass:
```
```java
```
```java
#
```
```java
24
```
```java
= #
```
```java
1
```
```java
of #
```
```java
22
```
```java
;
```
```java
//Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes
```
```java
t2/Outter
```
```java
```
```java
minor version:
```
```java
0
```
```java
```
```java
major version:
```
```java
50
```
```java
```
```java
Constant pool:
```
```java
const
```
```java
#
```
```java
1
```
```java
=
```
```java
class
```
```java
#
```
```java
2
```
```java
;
```
```java
//  com/cxh/test2/Outter$Inner
```
```java
const
```
```java
#
```
```java
2
```
```java
= Asciz        com/cxh/test2/Outter$Inner;
```
```java
const
```
```java
#
```
```java
3
```
```java
=
```
```java
class
```
```java
#
```
```java
4
```
```java
;
```
```java
//  java/lang/Object
```
```java
const
```
```java
#
```
```java
4
```
```java
= Asciz        java/lang/Object;
```
```java
const
```
```java
#
```
```java
5
```
```java
= Asciz
```
```java
this
```
```java
$
```
```java
0
```
```java
;
```
```java
const
```
```java
#
```
```java
6
```
```java
= Asciz        Lcom/cxh/test2/Outter;;
```
```java
const
```
```java
#
```
```java
7
```
```java
= Asciz        <init>;
```
```java
const
```
```java
#
```
```java
8
```
```java
= Asciz        (Lcom/cxh/test2/Outter;)V;
```
```java
const
```
```java
#
```
```java
9
```
```java
= Asciz        Code;
```
```java
const
```
```java
#
```
```java
10
```
```java
= Field       #
```
```java
1
```
```java
.#
```
```java
11
```
```java
;
```
```java
//  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t
```
```java
est2/Outter;
```
```java
const
```
```java
#
```
```java
11
```
```java
= NameAndType #
```
```java
5
```
```java
:#
```
```java
6
```
```java
;
```
```java
//  this$0:Lcom/cxh/test2/Outter;
```
```java
const
```
```java
#
```
```java
12
```
```java
= Method      #
```
```java
3
```
```java
.#
```
```java
13
```
```java
;
```
```java
//  java/lang/Object."<init>":()V
```
```java
const
```
```java
#
```
```java
13
```
```java
= NameAndType #
```
```java
7
```
```java
:#
```
```java
14
```
```java
;
```
```java
//  "<init>":()V
```
```java
const
```
```java
#
```
```java
14
```
```java
= Asciz       ()V;
```
```java
const
```
```java
#
```
```java
15
```
```java
= Asciz       LineNumberTable;
```
```java
const
```
```java
#
```
```java
16
```
```java
= Asciz       LocalVariableTable;
```
```java
const
```
```java
#
```
```java
17
```
```java
= Asciz
```
```java
this
```
```java
;
```
```java
const
```
```java
#
```
```java
18
```
```java
= Asciz       Lcom/cxh/test2/Outter$Inner;;
```
```java
const
```
```java
#
```
```java
19
```
```java
= Asciz       SourceFile;
```
```java
const
```
```java
#
```
```java
20
```
```java
= Asciz       Outter.java;
```
```java
const
```
```java
#
```
```java
21
```
```java
= Asciz       InnerClasses;
```
```java
const
```
```java
#
```
```java
22
```
```java
=
```
```java
class
```
```java
#
```
```java
23
```
```java
;
```
```java
//  com/cxh/test2/Outter
```
```java
const
```
```java
#
```
```java
23
```
```java
= Asciz       com/cxh/test2/Outter;
```
```java
const
```
```java
#
```
```java
24
```
```java
= Asciz       Inner;
```
```java
{
```
```java
final
```
```java
com.cxh.test2.Outter
```
```java
this
```
```java
$
```
```java
0
```
```java
;
```
```java
public
```
```java
com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);
```
```java
```
```java
Code:
```
```java
```
```java
Stack=
```
```java
2
```
```java
, Locals=
```
```java
2
```
```java
, Args_size=
```
```java
2
```
```java
```
```java
0
```
```java
:   aload_0
```
```java
```
```java
1
```
```java
:   aload_1
```
```java
```
```java
2
```
```java
:   putfield        #
```
```java
10
```
```java
;
```
```java
//Field this$0:Lcom/cxh/test2/Outter;
```
```java
```
```java
5
```
```java
:   aload_0
```
```java
```
```java
6
```
```java
:   invokespecial   #
```
```java
12
```
```java
;
```
```java
//Method java/lang/Object."<init>":()V
```
```java
```
```java
9
```
```java
:
```
```java
return
```
```java
```
```java
LineNumberTable:
```
```java
```
```java
line
```
```java
16
```
```java
:
```
```java
0
```
```java
```
```java
line
```
```java
18
```
```java
:
```
```java
9
```
```java
```
```java
LocalVariableTable:
```
```java
```
```java
Start  Length  Slot  Name   Signature
```
```java
```
```java
0
```
```java
10
```
```java
0
```
```java
this
```
```java
Lcom/cxh/test2/Outter$Inner;
```
```java
}
```
```
　　第11行到35行是常量池的内容，下面逐一第38行的内容：
```
final com.cxh.test2.Outter this$0;
```
　　这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：
```
public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);
```
　　从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以 成员内部类中的Outter this&0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无 法对Outter this&0引用进行初始化赋值，也就无法创建成员内部类的对象了。
　　2.为什么局部内部类和匿名内部类只能访问局部final变量？
　　想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：
```
```java
public
```
```java
class
```
```java
Test {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)  {
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
void
```
```java
test(
```
```java
final
```
```java
int
```
```java
b) {
```
```java
```
```java
final
```
```java
int
```
```java
a =
```
```java
10
```
```java
;
```
```java
```
```java
new
```
```java
Thread(){
```
```java
```
```java
public
```
```java
void
```
```java
run() {
```
```java
```
```java
System.out.println(a);
```
```java
```
```java
System.out.println(b);
```
```java
```
```java
};
```
```java
```
```java
}.start();
```
```java
```
```java
}
```
```java
}
```
```
　　这段代码会被编译成两个class文件：Test.class和Testx.class（x为正整数）。
![](https://images0.cnblogs.com/i/288799/201407/021900556994393.jpg)
　　根据上图可知，test方法中的匿名内部类的名字被起为 Test$1。
　　上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：
　　当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制  的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：
![](https://images0.cnblogs.com/i/288799/201407/021939271846598.jpg)
　　我们看到在run方法中有一条指令：
```
bipush 10
```
　　这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定， 则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量 是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。
　　下面再看一个例子：
```
```java
public
```
```java
class
```
```java
Test {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)  {
```
```java
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
void
```
```java
test(
```
```java
final
```
```java
int
```
```java
a) {
```
```java
```
```java
new
```
```java
Thread(){
```
```java
```
```java
public
```
```java
void
```
```java
run() {
```
```java
```
```java
System.out.println(a);
```
```java
```
```java
};
```
```java
```
```java
}.start();
```
```java
```
```java
}
```
```java
}
```
```
　　反编译得到：
![](https://images0.cnblogs.com/i/288799/201407/021950384493440.jpg)
　　我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。
也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。
　　从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的 话，会出现什么情况？
对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。
　　到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。
　　3.静态内部类有特殊的地方吗？
　　从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&0引用的。
## 三.内部类的使用场景和好处
　　为什么在Java中需要内部类？总结一下主要有以下四点：
　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，
　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。
　　3.方便编写事件驱动程序
　　4.方便编写线程代码
　　个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。
四.常见的与内部类相关的笔试面试题
 1.根据注释填写(1)，(2)，(3)处的代码
```
```java
public
```
```java
class
```
```java
Test{
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args){
```
```java
```
```java
// 初始化Bean1
```
```java
```
```java
(
```
```java
1
```
```java
)
```
```java
```
```java
bean1.I++;
```
```java
```
```java
// 初始化Bean2
```
```java
```
```java
(
```
```java
2
```
```java
)
```
```java
```
```java
bean2.J++;
```
```java
```
```java
//初始化Bean3
```
```java
```
```java
(
```
```java
3
```
```java
)
```
```java
```
```java
bean3.k++;
```
```java
```
```java
}
```
```java
```
```java
class
```
```java
Bean1{
```
```java
```
```java
public
```
```java
int
```
```java
I =
```
```java
0
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
static
```
```java
class
```
```java
Bean2{
```
```java
```
```java
public
```
```java
int
```
```java
J =
```
```java
0
```
```java
;
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Bean{
```
```java
```
```java
class
```
```java
Bean3{
```
```java
```
```java
public
```
```java
int
```
```java
k =
```
```java
0
```
```java
;
```
```java
```
```java
}
```
```java
}
```
```
　　从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。
　　创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()
　　创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()
因此，（1），（2），（3）处的代码分别为：
`![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)View Code`
`![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)View Code`
`![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)View Code`
2.下面这段代码的输出结果是什么？
```
```java
public
```
```java
class
```
```java
Test {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)  {
```
```java
```
```java
Outter outter =
```
```java
new
```
```java
Outter();
```
```java
```
```java
outter.
```
```java
new
```
```java
Inner().print();
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
Outter
```
```java
{
```
```java
```
```java
private
```
```java
int
```
```java
a =
```
```java
1
```
```java
;
```
```java
```
```java
class
```
```java
Inner {
```
```java
```
```java
private
```
```java
int
```
```java
a =
```
```java
2
```
```java
;
```
```java
```
```java
public
```
```java
void
```
```java
print() {
```
```java
```
```java
int
```
```java
a =
```
```java
3
```
```java
;
```
```java
```
```java
System.out.println(
```
```java
"局部变量："
```
```java
+ a);
```
```java
```
```java
System.out.println(
```
```java
"内部类变量："
```
```java
+
```
```java
this
```
```java
.a);
```
```java
```
```java
System.out.println(
```
```java
"外部类变量："
```
```java
+ Outter.
```
```java
this
```
```java
.a);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
`![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)View Code`
　　最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：
　　1）成员内部类的引用方式必须为 Outter.Inner.
　　2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》
```
```java
class
```
```java
WithInner {
```
```java
```
```java
class
```
```java
Inner{
```
```java
```
```java
```
```java
}
```
```java
}
```
```java
class
```
```java
InheritInner
```
```java
extends
```
```java
WithInner.Inner {
```
```java
```
```java
```
```java
// InheritInner() 是不能通过编译的，一定要加上形参
```
```java
```
```java
InheritInner(WithInner wi) {
```
```java
```
```java
wi.
```
```java
super
```
```java
();
```
```java
//必须有这句调用
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args) {
```
```java
```
```java
WithInner wi =
```
```java
new
```
```java
WithInner();
```
```java
```
```java
InheritInner obj =
```
```java
new
```
```java
InheritInner(wi);
```
```java
```
```java
}
```
```java
}
```
```
 参考资料：
　　《java编程思想》
[http://www.cnblogs.com/chenssy/p/3388487.html](http://www.cnblogs.com/chenssy/p/3388487.html)
[http://blog.csdn.net/zhangjg_blog/article/details/20000769](http://blog.csdn.net/zhangjg_blog/article/details/20000769)
[http://blog.csdn.net/zhangjg_blog/article/details/19996629](http://blog.csdn.net/zhangjg_blog/article/details/19996629)
[http://blog.csdn.net/zhaoqianjava/article/details/6849812](http://blog.csdn.net/zhaoqianjava/article/details/6849812)
[http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html](http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html)
