# 洛谷P3254 圆桌问题(最大流) - weixin_33985507的博客 - CSDN博客
2018年07月25日 14:35:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3
## 题意
$m$个不同单位代表参加会议，第$i$个单位有$r_i$个人
$n$张餐桌，第$i$张可容纳$c_i$个代表就餐
同一个单位的代表需要在不同的餐桌就餐
问是否可行，要求输出方案
## Sol
比较zz的最大流
从$S$向$1-m$连流量为$r_i$的边
从$m + 1$向$m + n$连流量为$c_i$的边
从$1-m$向$m + 1$到$m + n$中的每个点连流量为$1$的边
跑最大流即可
```
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int MAXN = 1e5 + 10, INF = 1e9 + 10;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int M, N, S, T;
int r[MAXN], c[MAXN];
struct Edge {
    int u, v, f, nxt;
}E[MAXN];
int head[MAXN], cur[MAXN], num;
inline void add_edge(int x, int y, int f) {
    E[num] = (Edge){x, y, f, head[x]};
    head[x] = num++;
}
inline void AddEdge(int x, int y, int z) {
    add_edge(x, y, z);
    add_edge(y, x, 0);
}
int sum = 0, deep[MAXN];
bool BFS() {
    queue<int> q; q.push(S);
    memset(deep, 0, sizeof(deep)); deep[S] = 1;
    while(!q.empty()) {
        int p = q.front(); q.pop();
        for(int i = head[p]; i != -1; i = E[i].nxt) {
            int to = E[i].v;
            if(!deep[to] && E[i].f) {
                deep[to] = deep[p] + 1;
                q.push(to);
            }
        }
    }
    return deep[T] > 0;
}
int DFS(int x, int flow) {
    if(x == T) return flow;
    int ansflow = 0;
    for(int &i = cur[x]; i != -1; i = E[i].nxt) {
        int to = E[i].v;
        if(deep[to] == deep[x] + 1 && E[i].f) {
            int nowflow = DFS(to, min(flow, E[i].f));
            E[i].f -= nowflow; E[i ^ 1].f += nowflow;
            ansflow += nowflow; flow -= nowflow;
            if(flow <= 0) break;
        }
    }
    return ansflow;
}
int Dinic() {
    int ans = 0;
    while(BFS()) {
        memcpy(cur, head, sizeof(head));
        ans += DFS(S, INF);
    }
    return ans;
}
int main() {
    memset(head, -1, sizeof(head));
    M = read(); N = read(); S = 0; T = M + N + 1;
    for(int i = 1; i <= M; i++) r[i] = read(), AddEdge(S, i, r[i]), sum += r[i];
    for(int i = 1; i <= N; i++) c[i] = read(), AddEdge(i + M, T, c[i]);
    for(int i = 1; i <= M; i++)
        for(int j = 1; j <= N; j++)
            AddEdge(i, j + M, 1);
    if(Dinic() >= sum) printf("1\n");
    else {printf("0"); return 0;} 
    for(int x = 1; x <= M; x++) {
        for(int i = head[x]; i != -1; i = E[i].nxt) 
            if(E[i].f == 0)
                printf("%d ", E[i].v - M);
        puts("");
    }
    return 0;
}
```
