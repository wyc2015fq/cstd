# 指纹解锁方法的封装 - weixin_33985507的博客 - CSDN博客
2016年11月30日 13:40:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：7
由于最近在项目中很多处都需要使用指纹验证  最好的办法就是封装起来  以下是我用block封装的类方法
Appledelegate.h
@interface AppDelegate : UIResponder
+(void)sureUserWith:(void (^)())successBlock failBlock:(void (^)(NSString *errorMessage,BOOL isAlt))failBlock;
@end
Appledelegate.m
+(void)sureUserWith:(void (^)())successBlock failBlock:(void (^)(NSString *errorMessage,BOOL isAlt))failBlock;
{
[SVProgressHUD show];
//初始化上下文对象
LAContext* context = [[LAContext alloc] init];
context.localizedFallbackTitle = @"";
//错误对象
NSError* error = nil;
NSString* result = @"通过Home键验证已有手机指纹";
//首先使用canEvaluatePolicy 判断设备支持状态
if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&error]) {
//支持指纹验证
[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:result reply:^(BOOL success, NSError *error) {
if (success) {
//验证成功，主线程处理UI
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
successBlock();
}];
}
else
{
[SVProgressHUD dismiss];
NSLog(@"%@",error.localizedDescription);
switch (error.code) {
case LAErrorSystemCancel:
{
failBlock(@"切换到其他APP，系统取消验证Touch ID",NO);
//切换到其他APP，系统取消验证Touch ID
break;
}
case LAErrorUserCancel:
{
failBlock(@"用户取消验证Touch ID",NO);
//用户取消验证Touch ID
break;
}
case LAErrorUserFallback:
{
NSLog(@"User selected to enter custom password");
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
//用户选择其他验证方式，切换主线程处理
}];
break;
}
default:
{
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
//其他情况，切换主线程处理
//多次错误
failBlock(@"您已多次错误,请重新登录",YES);
}];
break;
}
}
}
}];
}
else
{
//不支持指纹识别，LOG出错误详情
switch (error.code) {
case LAErrorTouchIDNotEnrolled:
{
failBlock(@"设备不支持指纹解锁",NO);
break;
}
case LAErrorPasscodeNotSet:
{
failBlock(@"设备未设置指纹解锁",NO);
break;
}
case -8:
{
failBlock(@"系统指纹已被锁定,请选择其他登录方式",YES);
break;
}
case -1:
{
//连续错误三次
[SVProgressHUD dismiss];
failBlock(@"抱歉，您未能通过Touch ID指纹验证！",YES);
break;
}
default:
{
failBlock(@"设备未设置touchId",NO);
break;
}
}
}
}
有不足的地方还希望大家能指正以下~
