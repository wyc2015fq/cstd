# 混合两张图 - weixin_33985507的博客 - CSDN博客
2012年02月10日 09:04:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：5
在iOS中如何将两张图混合成一张图呢？比如有一张是透明图，另外一张是不透明的，混合为一张图，并且保存起来。有关保存可见[将图片保存到照片相册中](http://marshal.easymorse.com/archives/4051)。
![image](http://marshal.easymorse.com/wp-content/uploads/2011/02/image_thumb6.png)
上图所示，可将红色手绘的色彩图片和原来的图层混合。
代码如下：
> 
-(void)generateImageToPhotoAlbum{ 
    NSLog(@"save image to photo album."); 
    UIGraphicsBeginImageContext(CGSizeMake(1024, 768)); 
    [drawImage.image drawInRect:self.frame]; 
    UIImage *foregroundImage=[UIImage imageWithCGImage:(CGImageRef)foregroundLayer.contents]; 
    [foregroundImage drawInRect:self.frame blendMode:kCGBlendModeNormal alpha:1.0]; 
    UIImage *newImage=UIGraphicsGetImageFromCurrentImageContext(); 
    UIGraphicsEndImageContext(); 
    UIImageWriteToSavedPhotosAlbum(newImage, nil, nil, nil); 
}
本文参考了：
> 
[http://stackoverflow.com/questions/1309757/blend-two-uiimages](http://stackoverflow.com/questions/1309757/blend-two-uiimages)
错误代码：
I'm trying to blend a background with a foreground image, where the foreground image is a transparent image with lines on it.
I am trying to do it this way.
```
1 UIGraphicsBeginImageContext(CGSizeMake(320,480));
 2 CGContextRef context =UIGraphicsGetCurrentContext();   
 4 // create rect that fills screen
 5 CGRect bounds =CGRectMake(0,0,320,480);
 7 // This is my bkgnd image
 8 CGContextDrawImage(context, bounds,[UIImage imageNamed:@"bkgnd.jpg"].CGImage);
 9 CGContextSetBlendMode(context, kCGBlendModeSourceIn);
//CGContextSetAlpha();
11 // This is my image to blend in
12 CGContextDrawImage(context, bounds,[UIImage imageNamed:@"over.png"].CGImage);
14 UIImage*outputImage =UIGraphicsGetImageFromCurrentImageContext();
16 UIImageWriteToSavedPhotosAlbum(outputImage,self,nil,nil);
17 // clean up drawing environment
18 UIGraphicsEndImageContext();
```
but does not seem to work.
Any suggestions will be appreciated.
方法1：上层图片设置绘画属性    【 drawInRect:  blendMode:  alpha: 】    
This is what I've done in my app, similar to Tyler's - but without the `UIImageView`:
```
1 UIImage*bottomImage =[UIImage imageNamed:@"bottom.png"];
 2 UIImage*image =[UIImage imageNamed:@"top.png"];
 4 CGSize newSize =CGSizeMake(width, height);
 5 UIGraphicsBeginImageContext( newSize );
 7 // Use existing opacity as is
 8 [bottomImage drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];
 9 // Apply supplied opacity
10 [image drawInRect:CGRectMake(0,0,newSize.width,newSize.height) blendMode:kCGBlendModeNormal alpha:0.8];
12 UIImage*newImage =UIGraphicsGetImageFromCurrentImageContext();
14 UIGraphicsEndImageContext();
```
方法2：两张图片放在同一个UIImageView中,然后用[imageView.layer renderInContext:UIGraphicsGetCurrentContext()]  渲染。
```
1 UIImage* bottomImage = [UIImage imageNamed:@"bottom.png"];  
 2 UIImage* topImage    = [UIImageNamed:@"top.png"];
 3 UIImageView* imageView = [[UIImageView alloc] initWithImage:bottomImage];
 4 UIImageView* subView   = [[UIImageView alloc] initWithImage:topImage];
 5 subView.alpha = 0.5;  // Customize the opacity of the top image.
 6 [imageView addSubview:subView];
 7 UIGraphicsBeginImageContext(imageView.frame.size);
 8 [imageView.layer renderInContext:UIGraphicsGetCurrentContext()];
 9 UIImage* blendedImage = UIGraphicsGetImageFromCurrentImageContext();
10 UIGraphicsEndImageContext();
11 [subView release];
12 [imageView release];
13 
14 [self doWhateverIWantWith: blendedImage];
```
If there are alpha values within the top image's png file, just leave out the "subView.alpha = 0.5;" line, and it will draw the top image, including it's custom alpha values, on top of the bottom image.
Blending with alpha
```
1 UIGraphicsBeginImageContext(area.size);
 2 CGContextRef context = UIGraphicsGetCurrentContext();
 3 CGContextRetain(context);
 4 
 5 // mirroring context
 6 CGContextTranslateCTM(context, 0.0, area.size.height);
 7 CGContextScaleCTM(context, 1.0, -1.0);
 8 
 9 for (...) {
10     CGContextBeginTransparencyLayer(context, nil);
11     CGContextSetAlpha( context, alpha );
12     CGContextDrawImage(context, area, tempimg.CGImage);
13     CGContextEndTransparencyLayer(context);
14 }
15 
16 // get created image
17 UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
18 CGContextRelease(context);
19 UIGraphicsEndImageContext();
```
Suggestion: You can use `UIImage`'s `drawInRect:` or `drawAtPoint:` instead of CGContextDrawImage (they draw to the current context). Does using them give you any difference in output?
It may also be helpful to make sure the `UIImage*` values you are getting back from `imageNamed:`are valid.
