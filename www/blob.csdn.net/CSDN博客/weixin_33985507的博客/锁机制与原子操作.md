# 锁机制与原子操作  - weixin_33985507的博客 - CSDN博客
2016年05月05日 15:09:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：3
# 一、线程同步中的一些概念
**　　1.1临界区(共享区)的概念**
　　在多线程的环境中，可能需要共同使用一些公共资源，这些资源可能是变量，方法逻辑段等等，这些被多个线程共用的区域统称为临界区(共享区)，临界区的资源不是很安全，因为线程的状态是不定的，所以可能带来的结果是临界区的资源遭到其他线程的破坏，我们必须采取策略或者措施让共享区数据在多线程的环境下保持完成性不让其受到多线程访问的破坏。
**1.2基元用户模式**
　　基元用户模式是指使用cpu的特殊指令来调度线程，所以这种协调调度线程是在硬件中进行的所以得出了它第一些优点：
- 速度特别快；
- 线程阻塞时间特别短；
　　但是由于该模式中的线程可能被系统抢占，导致该模式中的线程为了获取某个资源，而浪费许多cpu时间，同时如果一直处于等待的话会导致”活锁”，也就是既浪费了内存，又浪费了cpu时间，这比下文中的死锁更可怕，那么如何利用强大的cpu时间做更多的事呢？那就引出了下面的一个模式
**1.3基元内核模式**
　　该模式和用户模式不同，它是windows系统自身提供的，使用了操作系统中内核函数，所以它能够阻塞线程提高了cpu的利用率，同时也带来了一个很可怕的bug,死锁，可能线程会一直阻塞导致程序的奔溃,常用的内核模式的技术例如Monitor,Mutex,等等会在下一章节介绍。本章将详细讨论锁的概念，使用方法和注意事项
**1.4原子性操作**
　　如果一个语句执行一个单独不可分割的指令，那么它是原子的。严格的原子操作排除了任何抢占的可能性，更方便的理解是这个值永远是最新的，在c#中原子操作如下图所示：其实要符合原子操作必须满足以下条件c#中如果是32位cpu的话，为一个少于等于32位字段赋值是原子操作，其他（自增，读，写操作）的则不是。对于64位cpu而言，操作32或64位的字段赋值都属于原子操作其他读写操作都不能属于原子操作相信大家能够理解原子的特点，所以在使用原子操作时也需要注意当前操作系统是32位或是64位cpu或者两者皆要考虑。
**1.5非阻止同步**
　　非阻止同步：不阻止其他线程的情况下实现同步。就是利用原子性操作实现线程间的同步，不刻意阻塞线程，减少相应线程的开销，interlocked类便是c#中非阻止同步的理念所产生的线程同步技术。
**1.6阻止同步**
　　阻止同步：阻止其他线程，同一时间只允许单个线程访问临界资源。其实阻止同步也是基元内核模式的特点之一。
　　例如c# 中的锁机制，及mutex,monitor等都属于阻止同步，他们的根本目的是，以互斥的效果让同一时间只有一个线程能够访问共享区，其他线程必须阻止等待，直到该线程离开共享区后，才让其他一个线程访问共享区，阻止同步缺点也是容易产生死锁，但是阻止同步提高了cpu时间的利用率。
# 二、为何需要同步
　　当多个线程同时访问某个资源，可能造成意想不到的结果。如多个线程同时访问静态资源。
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static void Main(string[] args)
        {
            //初始化10个线程1去访问num
            for (int i = 0; i < 10; i++)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(Run));
            }
            Console.ReadKey();
        }
        static int num = 0;
        static void Run(object state)
        {
            Console.WriteLine("当前数字：{0}", ++num);
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出如下：
![](https://images0.cnblogs.com/blog/347600/201311/27102004-c2ef18965a4542b3b9b779a1d9b8c9be.jpg)
　　我们看到，num++按照逻辑，应该是1,2,3,4,5,6,7,8,9,10。这就是多个线程去访问，顺序乱套了。这时候就需要同步了。
# 三、原子操作同步原理
　　Thread类中的VolatileRead和VolatileWrite方法：
- VolatileWrite：当线程在共享区（临界区）传递信息时，通过此方法来原子性的写入最后一个值；
- VolatileRead：当线程在共享区（临界区）传递信息时，通过此方法来原子性的读取第一个值；
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static Int32 count;//计数值，用于线程同步 （注意原子性，所以本例中使用int32）
        static Int32 value;//实际运算值，用于显示计算结果
        static void Main(string[] args)
        {
            //读线程
            Thread thread2 = new Thread(new ThreadStart(Read));
            thread2.Start();
            //写线程
            for (int i = 0; i < 10; i++)
            {
                Thread.Sleep(20);
                Thread thread = new Thread(new ThreadStart(Write));
                thread.Start();
            }
            Console.ReadKey();
        }
        /// <summary>
        /// 实际运算写操作
        /// </summary>
        private static void Write()
        {
            Int32 temp = 0;
            for (int i = 0; i < 10; i++)
            {
                temp += 1;
            }
            //真正写入
            value += temp;
            Thread.VolatileWrite(ref count, 1);
        }
        /// <summary>
        ///  死循环监控读信息
        /// </summary>
        private static void Read()
        {
            while (true)
            {
                //死循环监听写操作线执行完毕后立刻显示操作结果
                if (Thread.VolatileRead(ref count) > 0)
                {
                    Console.WriteLine("累计计数:{1}", Thread.CurrentThread.ManagedThreadId, value);
                    count = 0;
                }
            }
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出如下:
![](https://images0.cnblogs.com/blog/347600/201311/28135934-f75aa0d382f6495493a67bb12455df85.jpg)
# 三、Volatile关键字
　　Volatile关键字的本质含义是告诉编译器，声明为Volatile关键字的变量或字段都是提供给多个线程使用的。Volatile无法声明为局部变量。作为原子性的操作，Volatile关键字具有原子特性，所以线程间无法对其占有，它的值永远是最新的。
　　Volatile支持的类型:
- 引用类型；
- 指针类型（在不安全的上下文中）；
- 类型，如 sbyte、byte、short、ushort、int、uint、char、float 和 bool；
- 具有以下基类型之一的枚举类型：byte、sbyte、short、ushort、int 或 uint；
- 已知为引用类型的泛型类型参数；
- IntPtr 和 UIntPtr；
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
class Program
    {
        static volatile Int32 count;//计数值，用于线程同步 （注意原子性，所以本例中使用int32）
        static Int32 value;//实际运算值，用于显示计算结果
        static void Main(string[] args)
        {
            //开辟一个线程专门负责读value的值，这样就能看见一个计算的过程
            Thread thread2 = new Thread(new ThreadStart(Read));
            thread2.Start();
            //开辟10个线程来负责计算，每个线程负责1000万条数据
            for (int i = 0; i < 10; i++)
            {
                Thread.Sleep(20);
                Thread thread = new Thread(new ThreadStart(Write));
                thread.Start();
            }
            Console.ReadKey();
        }
        /// <summary>
        /// 实际运算写操作
        /// </summary>
        private static void Write()
        {
            Int32 temp = 0;
            for (int i = 0; i < 10; i++)
            {
                temp += 1;
            }
            value += temp;
            //告诉监听程序，我改变了，读取最新吧！
            count = 1;
        }
        /// <summary>
        ///  死循环监听
        /// </summary>
        private static void Read()
        {
            while (true)
            {
                if (count == 1)
                {
                    Console.WriteLine("累计计数:{1}", Thread.CurrentThread.ManagedThreadId, value);
                    count = 0;
                }
            }
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出：
![](https://images0.cnblogs.com/blog/347600/201311/28140844-2f5f4ecd21024e78b957f5b0fdaeae46.jpg)
# 四、lock关键字
　　lock的作用在于同一时间确保一个对象只允许一个线程访问。
　　lock的语法如下：
```
static object obj = new object();
   lock (obj)
   {
   　　//语句块
   }
```
　　我们使用lock来改写上面的示例：
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static void Main(string[] args)
        {
            //初始化10个线程1去访问num
            for (int i = 0; i < 10; i++)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(Run));
            }
            Console.ReadKey();
        }
        static int num = 0;
        **static object obj = new****object();**static void Run(object state)
        {
            **lock**** (obj)**
        {
                Console.WriteLine("当前数字：{0}", ++num);
            }
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出如下：
![](https://images0.cnblogs.com/blog/347600/201311/27104018-e7ad7f8f36b44a108d4c986a07f98f05.jpg)
# 五、Monitor.Enter与Monitor.Exit
　　Monitor.Enter和Monitor.Exit这个东西跟lock的作用一样。事实上。lock就是Monitor.Enter和Monitor.Exit的包装。
　　下面用Monitor.Enter与Monitor.Exit来实现相同的代码：
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static void Main(string[] args)
        {
            //初始化10个线程1去访问num
            for (int i = 0; i < 10; i++)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(Run));
            }
            Console.ReadKey();
        }
        static int num = 0;
        static object obj = new object();
        static void Run(object state)
        {
            //获取排他锁
        Monitor.Enter(obj);
            Console.WriteLine("当前数字：{0}", ++num);
            //释放排它锁
        Monitor.Exit(obj);
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
# 六、Monitor.Wait与Monitor.Pulse
　　Wait() 和 Pulse() 机制用于线程间交互：
- Wait() 释放锁定资源，进入等待状态直到被唤醒；
- Pulse() 和 PulseAll() 方法用来通知Wait()的线程醒来；
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static void Main(string[] args)
        {
            Thread t1 = new Thread(Run1);
            Thread t2 = new Thread(Run2);
            t1.Start();
            t1.Name = "刘备";
            t2.Start();
            t2.Name = "关羽";
            Console.ReadKey();
        }
        static object obj = new object();
        static void Run1(object state)
        {
            Monitor.Enter(obj);
            Console.WriteLine(Thread.CurrentThread.Name + ":二弟，你上哪去了？");
            Monitor.Wait(obj);      //暂时释放锁，让关羽线程进入
            Console.WriteLine(Thread.CurrentThread.Name + ":你混蛋！");
                
            Monitor.Pulse(obj);     //唤醒关羽线程 
            Monitor.Exit(obj);
        }
        static void Run2(object state)
        {
            Monitor.Enter(obj);
            Console.WriteLine(Thread.CurrentThread.Name + ":老子跟曹操了！");
            Monitor.Pulse(obj);     //唤醒刘备线程
            Monitor.Wait(obj);     //暂停本线程
            
            Console.WriteLine(Thread.CurrentThread.Name + ":投降吧，曹孟德当世英雄，竖子不足与谋！！");
            Monitor.Exit(obj);
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出如下：
![](https://images0.cnblogs.com/blog/347600/201311/27114008-e3e1e7a4f2c749df8e6702c8d25aa5c8.jpg)
# 七、读写锁ReadWriterLock
**写入串行，读取并行；**
　　如果程序中大部分都是读取数据的，那么由于读并不影响数据，ReadWriterLock类能够实现”写入串行“，”读取并行“。
　　常用方法如下：
- AcquireWriterLock: 获取写入锁； ReleaseWriterLock：释放写入锁。
- AcquireReaderLock: 获取读锁； ReleaseReaderLock：释放读锁。
- UpgradeToWriterLock:将读锁转为写锁；DowngradeFromWriterLock：将写锁还原为读锁。
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
   class Program
    {
        static List<string> ListStr = new List<string>();
        static ReaderWriterLock rw = new System.Threading.ReaderWriterLock();
        static void Main(string[] args)
        {
            Thread t1 = new Thread(Run1);
            Thread t2 = new Thread(Run2);
            t1.Start();
            t1.Name = "刘备";
            t2.Start();
            t2.Name = "关羽";
            Console.ReadKey();
        }
        static object obj = new object();
        static void Run1(object state)
        {
            //获取写锁2秒
            rw.AcquireWriterLock(2000);
            Console.WriteLine(Thread.CurrentThread.Name + "正在写入!");
            ListStr.Add("曹操混蛋");
            ListStr.Add("孙权王八蛋");
            Thread.Sleep(1200);
            ListStr.Add("周瑜个臭小子");
            rw.ReleaseWriterLock();
            
        }
        //此方法异常，超时，因为写入时不允许读(那么不用测也能猜到更加不允许写咯)
        static void Run2(object state)
        {
            //获取读锁1秒
            rw.AcquireReaderLock(1000);
            Console.WriteLine(Thread.CurrentThread.Name + "正在读取!");
            foreach (string str in ListStr)
            {
                Console.WriteLine(str);
            }
            rw.ReleaseReaderLock();
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　异常如下:
![](https://images0.cnblogs.com/blog/347600/201311/27120400-44aa92a7da3f435ebf7e80c38aa0ecb6.jpg)
　　下面是读取并行的例子：
```
![复制代码](https://common.cnblogs.com/images/copycode.gif)
    class Program
    {
        static List<string> ListStr = new List<string>();
        static ReaderWriterLock rw = new System.Threading.ReaderWriterLock();
        static void Main(string[] args)
        {
            ListStr.Add("貂蝉");
            ListStr.Add("西施");
            ListStr.Add("王昭君");
            Thread t1 = new Thread(Run1);
            Thread t2 = new Thread(Run2);
            t1.Start();
            t1.Name = "刘备";
            t2.Start();
            t2.Name = "关羽";
            Console.ReadKey();
        }
        static object obj = new object();
        static void Run1(object state)
        {
            //获取写锁2秒
            rw.AcquireReaderLock(2000);
            Console.WriteLine(Thread.CurrentThread.Name + "正在读取!");
            foreach (string str in ListStr)
            {
                Console.WriteLine(Thread.CurrentThread.Name + "在读：" + str);
            }
            rw.ReleaseReaderLock();
            
        }
        //此方法异常，超时，因为写入时不允许读(那么不用测也能猜到更加不允许写咯)
        static void Run2(object state)
        {
            //获取读锁1秒
            rw.AcquireReaderLock(1000);
            Console.WriteLine(Thread.CurrentThread.Name + "正在读取!");
            foreach (string str in ListStr)
            {
                Console.WriteLine(Thread.CurrentThread.Name + "在读：" + str);
            }
            rw.ReleaseReaderLock();
        }
    }
![复制代码](https://common.cnblogs.com/images/copycode.gif)
```
　　输出如下：
![](https://images0.cnblogs.com/blog/347600/201311/27120858-0963f564cea9458fbce867470f03ebfd.jpg)
　　总结：写入锁与任何锁都不兼容，读取锁与读取锁可以兼容。
分类: [.Net模块：多线程](http://www.cnblogs.com/kissdodog/category/464176.html)
