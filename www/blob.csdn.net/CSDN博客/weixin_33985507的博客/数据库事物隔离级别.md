# 数据库事物隔离级别 - weixin_33985507的博客 - CSDN博客
2018年05月07日 09:08:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：8
参考：[https://www.cnblogs.com/huanongying/p/7021555.html](https://www.cnblogs.com/huanongying/p/7021555.html)
[https://blog.csdn.net/cxm19881208/article/details/79415726](https://blog.csdn.net/cxm19881208/article/details/79415726)
#### 一、隔离级别及含义
##### 1、总结：
> 
`1、修改数据不加锁---》脏读（正在修改的数据未提交时被读取）`
`2、查询数据不加锁---》不可重复读（正在读取的数据，被修改了再次读取就不一样了）`
`3、读、修改都加锁---》幻读（读取之后，有数据添加）`
`4、串行化---》事物依次执行避免幻读`
##### 2、简介
> - 事务隔离级别（transaction isolation levels）：隔离级别就是对对事务并发控制的等级。ANSI/ ISO SQL将其分为串行化（SERIALIZABLE）、可重复读（REPEATABLE READ）、读已提交（READ COMMITED）、读未提交（READ UNCOMMITED）四个等级。为了实现隔离级别通常数据库采用锁（Lock）。一般在编程的时候只需要设置隔离等级，至于具体采用什么锁则由数据库来设置。首先介绍四种等级，然后举例解释后面三个等级（可重复读、读已提交、读未提交）中会出现的并发问题。
##### 3、级别详述
> - 读未提交（READ UNCOMMITED）：这是最低的隔离等级，允许其他事务看到没有提交的数据。这种等级会导致脏读（Dirty Read）。
> 
`SQL Server默认的隔离等级`
- 读已提交（READ COMMITED）：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。该等级也是SQL Server默认的隔离等级。
> 
`MySql默认的隔离等级`
- 可重复读（REPEATABLE READ）：所有被Select获取的数据会生成快照，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。
> - 串行化（SERIALIZABLE）：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）。对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询（如选取年龄在10到30之间的用户）的时候，需要获取范围锁（range lock）。如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需要滚回该事务。
#### 二、数据库并发访问可能引起的问题
> 
`1. 脏读(事务没提交，提前读取)`
脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
> 
`2. 不可重复读(两次读的不一致)`
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。
> 
`3. 幻读`
是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。
> 
`4.第一类更新丢失(回滚丢失)`
当2个事务更新相同的数据源，如果第一个事务被提交，而另外一个事务却被撤销，那么会连同第一个事务所做的跟新也被撤销。也就是说第一个事务做的跟新丢失了。
> 
`5.第二类更新丢失(覆盖丢失)`
第二类更新丢失实在实际应用中经常遇到的并发问题，他和不可重复读本质上是同一类并发问题，通常他被看做不可重复读的特例：当2个或这个多个事务查询同样的记录然后各自基于最初的查询结果更新该行时，会造成第二类丢失更新。因为每个事务都不知道不知道其他事务的存在，最后一个事务对记录做的修改将覆盖其他事务对该记录做的已提交的跟新...
#### 三、各类数据库默认隔离级别（转：[https://www.cnblogs.com/who-else/p/6659564.html](https://www.cnblogs.com/who-else/p/6659564.html)）
# [mysql,oracle,sql server中的默认事务隔离级别查看,更改](http://www.cnblogs.com/who-else/p/6659564.html)
![1824078-6516012d7d43d854.jpg](https://upload-images.jianshu.io/upload_images/1824078-6516012d7d43d854.jpg)
image
> 
`1.未提交读（隔离事务的最低级别，只能保证不读取物理上损坏的数据）`
`2.已提交读（数据库引擎的默认级别）`
`3.可重复读`
`4.可序列化（隔离事务的最高级别，事务之间完全隔离）`
可串行化比较严谨,级别高;
#### MySQL
mysql默认的事务处理级别是'REPEATABLE-READ',也就是可重复读
1.查看当前会话隔离级别
```
select @@tx_isolation;
```
2.查看系统当前隔离级别
```
select @@global.tx_isolation;
```
3.设置当前会话隔离级别
```
set session transaction isolatin level repeatable read;
```
4.设置系统当前隔离级别
```
set global transaction isolation level repeatable read;
```
#### Oracle
oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。
默认系统事务隔离级别是READ COMMITTED,也就是读已提交
1.查看系统默认事务隔离级别,也是当前会话隔离级别
--首先创建一个事务
```
declare
     trans_id Varchar2(100);
  begin
     trans_id := dbms_transaction.local_transaction_id( TRUE );
  end;
```
--查看事务隔离级别
```
SELECT s.sid, s.serial#,
　　CASE BITAND(t.flag, POWER(2, 28))
　　　　WHEN 0 THEN 'READ COMMITTED'
　　　　ELSE 'SERIALIZABLE'
　　END AS isolation_level
FROM v$transaction t
JOIN v$session s ON t.addr = s.taddr AND s.sid = sys_context('USERENV', 'SID');
```
#### SQL Server
默认系统事务隔离级别是read committed,也就是读已提交
1.查看系统当前隔离级别
```
DBCC USEROPTIONS
```
isolation level 这一项的 Value 既是当前的隔离级别设置值
2.设置系统当前隔离级别
```
SET TRANSACTION ISOLATION LEVEL Read UnCommitted;
```
其中Read UnCommitted为需要设置的值
