# 泛型 - weixin_33985507的博客 - CSDN博客
2018年07月03日 16:35:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：10
# 定义
其定义方式如 java 一致，**kt 要求泛型实参必须被显式地指明或者能推导出来**：
![7419835-76ab10cc0deaf4a6.png](https://upload-images.jianshu.io/upload_images/7419835-76ab10cc0deaf4a6.png)
泛型定义
# 继承
与 Java 一样。如果类继承了泛型类（或者实现了泛型接口），就必须为**父类提供一个泛型实参**，它可以是另一个具体类型或者另一个类型形参：
![7419835-4533d207a8ecdb73.png](https://upload-images.jianshu.io/upload_images/7419835-4533d207a8ecdb73.png)
泛型基础
# 上界约束
> 
指定上界后，可以把 T 的值当作上界类型的值使用
**约束泛型实参必须是某个类的子类或某个类本身**。Java 中通过 `<T extends List>` 实现，kt 中将 extends 换成冒号即可：
![7419835-c1a287dfce7eb7dd.png](https://upload-images.jianshu.io/upload_images/7419835-c1a287dfce7eb7dd.png)
上界约束
下例调用了上界中的方法，直接将 t 当作 Numbar 的一个子类：
```
fun main(args: Array<String>) {
    printPower(22.2)
}
fun <T:Number> printPower(t:T){
    println("power is ${t.toInt()*t.toInt()}")
}
```
## 多个约束
> 
kt 中一个类型可以指定多个约束条件
通过 `where` 语句指定 T 的多个上界：
![7419835-eca1b2c0fe05bede.png](https://upload-images.jianshu.io/upload_images/7419835-eca1b2c0fe05bede.png)
多个约束
如下例中 T 必须是 CharSequence 与 Appendable 的子类：
```
fun <T> ensureTrailingPeriod(seq: T):T
        where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
    return seq
}
```
## 非空约束
如果不指定上界约束时，**默认上界是`Any?`**，即类型实参可以是任何类型，包括空类型。如果想指定类型为非空，可将 Any? 替换成 Any 或者 其他任何非类类型的类型：
```
fun <T> nullable(seq: T) = println("null")
fun <T> nonull(seq: T) = println("nonull")
```
第一个函数可以传入 null ，但第二个函数不行。
# 类型擦除与实化
与 java 一样，kt 在运行时类型实参也会被擦除，也就是说在运行时 List<String> 与 List<Int> 都会被当作 List。
但 kt 中将***函数声明为 inline，并使用 `reified` 修饰类型参数***，那么在使用时可以直接使用类型实参。
这种能直接使用类型实参，类型实参不被擦除的，在 kt 中叫实化。
如下例中，可以使用 `e is T` ，而一般的函数无法使用 T：
```
inline fun <reified T> List<*>.test2(){
    for(e in this){
        if(e is T){
            println("got=${e}")
        }
    }
}
```
## 原理
kt 中，编译器会把内联函数插入到每一次调用的地方。并且会将被 reified 修饰的类型形参替换成其类型实参，如上例中假设使用 List<String> 进行调用，其等价的代码如下，编译时直接将 T 替换成 String：
```
for(e in this){
        if(e is String){
            println("got=${e}")
        }
    }
```
## 与 Java 交互
- 
***带 reified 类型参数的 inline 函数不能在 java 代码中调用***。这是因为实化要求在编译时，将类型实参替换到字节码中，而这是在 java 中调用不可能办到的。
- 
java 可以将内联函数当作普通的方法进行调用 —— 只是调用，而不是内联。
# 实化限制
实化可用于如下地方：
- 
可用在类型检查和类型转换中（is，!is，as，!as)
- 
可用于 Kt 中的反射
- 
获取相应类的 Class 对象（ 通过 `::class.java` )
- 
作为调用其他函数的类型实参
其不能用于如下地方：
- 
创建类型实参的实例
- 
调用类型实参的伴生对应中的方法
- 
把类、属性或非内联函数的类型参数标志为 reified
- 
调用带实化类型参数函数的时候使用非实化类型形参作为类型实参。
第四点示例如下，在 test 中无法直接将 T 传入到 test2 中：
```
fun <T:Any> test(){
    test2<T>()// 此处编译报错。
}
inline fun <reified T:Any> test2(){
    println("test2 ${T::class.java}")
}
```
