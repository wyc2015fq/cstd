# js执行机制 - weixin_33985507的博客 - CSDN博客
2018年08月11日 14:03:33[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：1
在实际开发中，总是遇到请求结束后，想要把请求得到数据赋值给某一个对象或者变量，如果没有在请求的回调函数中赋值，而是在请求语句下面赋值，我们会发现请求得到数据正常，但是赋值后的变量是undefined。这是为什么呢？
首先，我们要了解一个概念，就是**同步与异步**。众所周知，js是单线程语言，也就是说，js一次只能执行一个任务，如果有多个任务的话呢，那就按照任务的顺序依次执行。但是如果其中某一个任务耗费大量时间，比如陷入死循环，那么其他任务都不能执行，会造成浏览器无响应。那么js是如何解决的呢？那就是将任务分为同步和异步模式进行执行。同步如上，异步呢是指，拥有大于一个的回调函数，任务在执行结束时不是执行下一个任务而是执行回调函数，那么有人可能会有疑问，这样做与同步有什么区别呢？区别在于，后一个任务不用等前一个任务完全执行后再去执行。因此我们得到的程序执行顺序不是任务的排列顺序。
```
setTimeout(function(){
    console.log('第一个延时调用');
});
console.log('哈哈哈');
new Promise(function(resolve){
    console.log('promise任务吗');
    resolve();
}).then(function(){
    console.log('回调函数？？？')
});
console.log('嘻嘻嘻');
setTimeout(function(){
    console.log('第二个延时调用');
});
```
执行结果是什么呢？
哈哈哈
promise任务吗
嘻嘻嘻
回调函数？？？
第一个延时调用
第二个延时调用
为什么是这样呢？为什么setTimeout会在最后才执行，明明是0ms啊。
是因为除了同步异步模式外，我们对任务还有进一步的划分，**宏任务**和**微任务**。
宏任务：包括整体代码script，setTimeout，setInterval
微任务：Promise，process.nextTick
在执行时，进入宏任务后，开始第一次循环，接着执行所有微任务，然后在进行宏任务的下次循环。
在上面代码中，进入宏任务，并将setTimeout注册为宏任务放入队列，接着执行哈哈哈，遇到new Promise 直接执行，回调函数放置微任务队列，接着执行嘻嘻嘻，第二个setTimeout如上。接着执行微任务，这里仅有嘻嘻嘻。最后进入下次宏任务。
