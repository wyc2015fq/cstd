# # 数据库 - weixin_33985507的博客 - CSDN博客
2016年05月06日 23:13:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：1
#### 封装自定义数据库的工具类
```
class SQLiteTool: NSObject {
    // 懒加载数据库工具类的单例对象
    static let shareIstance = SQLiteTool()
    // 指向数据库的指针
    var db: COpaquePointer = nil
    // 重构
    override init() {
        super.init()
        let path = "/Users/yangxiaoming/Desktop/sql/Untitled.sqlite"
        // 打开数据库
        if sqlite3_open(path, &db) != SQLITE_OK {
            print("数据库打开成功")
        }else {
            print("数据库打开失败")
            // 创建表
            createTtable()
        }
    }
}
```
然后可以在该工具类中定义一些需要实现的操作的方法：对表中数据的曾、删、改、查的方法（这里封装了所有的操作的一个方法，可以根据传入进来的sql语句，然后进行执行）
- exec表示执行的意思
```
func excuteSql(sql: String) -> Bool {
        // 2. 执行sql语句
        // 功能, 执行sql字符串
        // 参数1: 一个已经打开的数据库(代表操作的是哪一个数据库)
        // 参数2: sql语句
        // 参数3: 回调函数 nil
        // 参数4: 参数3: 回调函数里面的参数1 nil
        // 参数5: 错误信息 nil
        return sqlite3_exec(db, sql, nil , nil , nil) == SQLITE_OK
    }
```
#### 数据库的优化（大批量插入数据的操作）insert绑定参数
- 如果大批量插入数据的话有两种方案
- 
方案一：sqlite3_step() 准备语句（执行准备语句）
- 
方案二：sqlite3_exec() sql字符串（执行sql语句）
- 
优化的原理：
- 由于这两个执行函数，在执行的时候内部都会自动开启一个事务，当执行完毕之后提交事务，整个过程（开启事务->提交事务）是非常耗费时间（简单来说就是插入提交，插入提交....）
- 优化实现：手动实现事务的开启和提交，那么在函数内部, 就不会自动开启和提交事务
- 
方案一的实现：insert绑定参数和事务开启和提交的手动实现测试插入数据的耗时计算
```
func insertBind() -> () {
        let sql = "insert into t_stu(name, age, score) values (?, ?, ?);"
        // 1. 创建"准备语句"
        // 参数1: 一个打开的数据库
        // 参数2: sql字符串
        // 参数3: 取出参数2 的长度 3  -1代表自动计算
        // 参数4: 指向"准备语句的指针"
        // 参数5: 通过参数3指定的长度, 取出参数2, 字符串之后, 剩余的字符串 nil
        let db = SQLiteTool.shareInstance.db
        var stmt: COpaquePointer = nil
        if sqlite3_prepare_v2(db, sql, -1, &stmt, nil) != SQLITE_OK {
            print("准备语句创建失败")
            return
        }
        // 开启事务
        SQLiteTool.shareInstance.beginTransaction()
        // 测试插入数据耗时
        for _ in 0..<10000 {
            // 2. 绑定数据（不同的数据类型, 绑定的方法不一样）
            /**
            *   参数：
            *   COpaquePointer：准备语句
            *   Int32：绑定的索引 从1开始
            *   UnsafePointer<Int8>：绑定的值（给 ？位置传的值）
            *   Int32：代表, 值取出的长度 -1 自动计算
            *   ((UnsafeMutablePointer<Void>) -> Void)!：指向函数的指针: 参数的处理方式
            */
            // #define SQLITE_STATIC      处理方式: 不对参数做任何操作(认为参数是一个static)
            // #define SQLITE_TRANSIENT   处理方式: 会对参数, 做一个强引用, 然后, 使用完毕之后, 在合适的时候释放
            // 使用这个函数一定要注意: 需要明确的知道最终的确切类型是什么
            let SQLITE_TRANSIENT = unsafeBitCast(-1, sqlite3_destructor_type.self)
            sqlite3_bind_text(stmt, 1, "yang", -1, SQLITE_TRANSIENT)
            // 绑定 Int 类型
            sqlite3_bind_int(stmt, 2, 18)
            // 绑定 -Double 类型
            sqlite3_bind_double(stmt, 3, 99)
            // 3. 执行"准备语句"
            if sqlite3_step(stmt) == SQLITE_DONE {
                print("执行成功")
            }else {
                print("执行失败")
            }
            // 4. 重置"准备语句"
            sqlite3_reset(stmt)
        }
        // 提交事务
        SQLiteTool.shareInstance.commitTransaction()
        // 5. 释放资源
        sqlite3_finalize(stmt)
    }
```
