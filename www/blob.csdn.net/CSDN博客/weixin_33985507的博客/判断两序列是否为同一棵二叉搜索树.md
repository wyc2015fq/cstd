# 判断两序列是否为同一棵二叉搜索树 - weixin_33985507的博客 - CSDN博客
2015年11月18日 14:48:00[weixin_33985507](https://me.csdn.net/weixin_33985507)阅读数：5
题目来源：九度教程第36题
![](https://images2015.cnblogs.com/blog/702782/201511/702782-20151118142748421-1348745239.png)
九度提供的算法设计思路是：对输入的数字序列构建二叉排序树，并对它们进行前序和中序的遍历，依次比较遍历结果是否相同，若相同则说明两棵二叉排序树相同，否则不同。
这个设计思路是没有问题的，但是有点画蛇添足的成份。那么这个“蛇足”是什麽呢？试想一下二叉排序树的性质，如果对二叉排序树来说，对其进行中序遍历，那么无论一组数字按照怎样的顺序构建，其中序遍历后得到的序列都是一样的。例如题目给的测试实例，{5,6,7,4,3,2}和{5,7,6,3,4,2}，他们构造的二叉排序树如下：
![](https://images2015.cnblogs.com/blog/702782/201511/702782-20151118143925483-153369913.jpg)
其中序遍历得到序列都是{2,3,4,5,6,7}。所以说进行中序遍历作为判断的一项是“蛇足”。
对于该题，我们只须对建立的二叉树进行先序遍历，或者后序遍历得到它们的遍历序列进行比较即可。
源码如下：
```
//preMain保存原二叉树先序遍历的序列
//preOther保存与原二叉树比较的二叉树的先序遍历的序列
char preMain[11], preOther[11];
struct BSTNode{
    int value;
    BSTNode *lchild;
    BSTNode *rchild;
};
BSTNode* allocateNode()
{
    if (BSTNode *node = (BSTNode*)malloc(sizeof(BSTNode)))
    {
        node->lchild = nullptr;
        node->rchild = nullptr;
        return node;
    }
    else
        return nullptr;
}
BSTNode* builtBSTree(BSTNode*T, int value)
{
    if (T == nullptr)
    {
        T = allocateNode();
        T->value = value;
        return T;
    }
    else if (T->value > value)
        T->lchild = builtBSTree(T->lchild, value);
    else if (T->value < value)
        T->rchild = builtBSTree(T->rchild, value);
    return T;
}
int size = 0;
void preOrderBST(BSTNode *root, char preArray[])
{
    if (root != nullptr)
    {
        preArray[size++] = root->value + '0';
    }
    if (root->lchild != nullptr)
    {
        preOrderBST(root->lchild, preArray);
    }
    if (root->rchild != nullptr)
    {
        preOrderBST(root->rchild, preArray);
    }
}
```
