# 单例设计 - 苝花向暖丨楠枝向寒 - CSDN博客

2018年01月28日 13:59:15[苝花向暖丨楠枝向寒](https://me.csdn.net/weixin_40247263)阅读数：45标签：[单例设计模式](https://so.csdn.net/so/search/s.do?q=单例设计模式&t=blog)
个人分类：[单例设计](https://blog.csdn.net/weixin_40247263/article/category/7429027)



恶汉单例   -- 线程安全，效率高，耗损内存 （因为类加载时就创建了对象且被static修饰保证唯一） 

public class HungrySingle {

//static 修饰的表示全局唯一，就这么一个 加final更为严谨
//如果属性被修饰为static静态类资源，那么这个字段永远只有一个，
//也就是说不管你new test()多少个类的对象，操作的永远都只是属于类的那一块内存资源。

    private static final HungrySingle sInstance = new HungrySingle();

    private HungrySingle() {

    }

    public static HungrySingle getInstance() {

        return sInstance;

    }

}


懒汉单例 ----  线程安全，效率低，耗损内存少

public class LazySingle {

    private static LazySingle sInstance = null;

    private LazySingle() {

    }

    public static LazySingle getInstance() {  

      if (sInstance == null) {                                 //位置1

            synchronized (LazySingle.class) {          

                if (sInstance == null) {                       //位置2

                    sInstance = new LazySingle();

                }

            }

        }

        return sInstance;

    }

}

解释：

疑点一：synchronized 会降低效率，所以在懒汉单利模式中，选择synchronized 代码块而不是synchronized方法，首先判断sInstance
 是否为空，为空则不走下面的同步代码块。

疑点二：懒汉单例中双重判断的原因是为了提高效率以及严谨。 

第二个if判断作用：假如A线程与B线程几乎同时进入getInstance()方法，又几乎同时到达位置1，然后A线程先进入synchronized代码块，然后判断-为空-创建对象-退出解锁。此时B进入同步代码块，判断-不为空-return返回对象。

第一个if判断作用： 此时线程C来了，第一个if判断了已经创建直接返回，从而不进入synchronized代码块，提高效率。

