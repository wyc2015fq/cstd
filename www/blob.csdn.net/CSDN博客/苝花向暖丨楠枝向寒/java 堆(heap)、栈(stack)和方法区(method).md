# java 堆(heap)、栈(stack)和方法区(method) - 苝花向暖丨楠枝向寒 - CSDN博客

2018年04月22日 18:08:34[苝花向暖丨楠枝向寒](https://me.csdn.net/weixin_40247263)阅读数：19标签：[heap																[method																[stack](https://so.csdn.net/so/search/s.do?q=stack&t=blog)](https://so.csdn.net/so/search/s.do?q=method&t=blog)](https://so.csdn.net/so/search/s.do?q=heap&t=blog)
个人分类：[内存](https://blog.csdn.net/weixin_40247263/article/category/7612057)



转自：[点击打开链接](https://blog.csdn.net/yu8196378/article/details/55099817)

JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)
堆区:
1.存储的是new出来的对象和数组，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身
栈区:
1.每个线程包含一个栈区，栈中保存的是所有的变量，包括基本类型和引用类型，栈中的每个变量都包含类型、名称、值这些内容，只不过基本类型变量的值为一个具体的值，而引用类型的变量的值为对象在堆中的地址。
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
方法区:
1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。

3.字符串常量池就是存放在方法区。（具体原因参见：http://zangxt.iteye.com/blog/472236）

堆和栈的不同：

<1>存数数据不同

<2>回收方式不同

栈中当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。

<3>速度不同

堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

堆和栈的优缺点：

<1>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢.

<2>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性

举例： int a = 3;  int b = 3; 

编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。
接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。
这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。
因此a值的改变不会影响到b的值。

简单代码语句的执行过程：

![](https://img-blog.csdn.net/20170214160235014)

系统收到了我们发出的指令，启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，
然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。
接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：
Sample test1=new Sample("测试1");
就是让java虚拟机创建一个Sample实例，并且呢，使引用变量test1引用这个实例。就让我们来跟踪一下Java虚拟机，看看它究竟是怎么来执行这个任务的：
1、 Java虚拟机直奔方法区，先找到Sample类的类型信息。结果这会儿的方法区里还没有Sample类。于是立马加载了Sample类，把Sample类的类型信息存放在方法区里。
2、 为一个新的Sample实例分配内存, 这个Sample实例持有着指向方法区的Sample类的类型信息的引用。而这个引用地址，就存放了在Sample实例的数据区里。
3、 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位于“=”前的Test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，它被会添加到了执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，它持有指向Sample实例的引用。

接下来，JAVA虚拟机将继续执行后续指令，在堆区里继续创建另一个Sample实例，然后依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令。

