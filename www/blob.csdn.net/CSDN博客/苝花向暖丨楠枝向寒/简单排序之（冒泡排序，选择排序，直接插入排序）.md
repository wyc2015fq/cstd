# 简单排序之（冒泡排序，选择排序，直接插入排序） - 苝花向暖丨楠枝向寒 - CSDN博客

2018年04月21日 15:16:36[苝花向暖丨楠枝向寒](https://me.csdn.net/weixin_40247263)阅读数：56标签：[算法](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[算法与数据结构](https://blog.csdn.net/weixin_40247263/article/category/7609640)



冒泡排序 ： 从后向前比较，比较最后一个和倒数第二个，不符合要求就换位置，然后再比较倒数第二个和倒数第三个，不符合要求再换，一直换到 第一个位置，就是把 最大或最小的那个元素 固定在了索引位为0的位置。然后再做一次上述操作，从最后一个开始和前一个比，只不过这次 比较 一直交换到 第二个元素，即索引位为 1的 位置，因为 第一个元素已经固定，无需再比。

最终效果就是先确定了数组的第一个元素，然后是第二个、第三个 等等..  最小的或最大的数，按照要求，从后面一个一个比较，符合要求的就冒到了前面，所以叫冒泡排序。

代码实例：

```java
/**
	 * 冒泡排序
	 * @param arr
	 */
	public static void sort(long[] arr) {
		long tmp = 0;
		for(int i=0;i<arr.length-1;i++) {
			for(int j = arr.length-1;j>i;j--) {
				if(arr[j]<arr[j-1]) {
					//进行交换
					tmp = arr[j];
					arr[j] = arr[j-1];
					arr[j-1]=tmp;
				} 
			}
		}
	}
```

选择排序：从前向后比较，比如需求是从小大到，那么第一个先和第二个比，如果第二个数小于 第一个，那么就把第二个数的索引位记录下来，然后用这个记录下来的索引位对应的值跟第三个数比，也是小的记录下来，然后再用记录下来的数跟第四个数比，依次类推。最终就把最小的那个数的索引位记录了下来，然后再把这个数和第一个数即索引位为0的数交换。就将最小的那个数固定了在第一个位置，然后再循环从第二个数开始比。

最终效果就是 从第一个开始 选，选到了一个小的就是 记录下 位置，之后碰到更小的就 替换掉之前的，循环之后再做替换，所以叫选择排序。

```java
/**
	 * 选择排序
	 * @param arr
	 */
	public static void sort(long[] arr) {
		int k = 0;
		long tmp = 0;
		for (int i = 0; i < arr.length-1; i++) {
			k=i;
			for (int j = i; j < arr.length; j++) {
				if(arr[j]<arr[k]) {
					k=j;
				}
			}
			tmp = arr[i];
			arr[i] = arr[k];
			arr[k] = tmp;
		}
	}
```

直接插入排序：首先假设从小到大的顺序排，先把数组第二个数 放入一个临时变量long tmp中，然后用这个变量跟第一个数比，如果第一个数 大于 tmp 中的数，那么就把第一个数赋给第二个位置，相当于后移一位，然后把tmp 赋给 第一个索引位(因为第一个移动到了第二个，然后把tmp插入到第一个位置)。将第三个数 放入 tmp ，第二个数 跟 tmp 比，如果第二数大，则将第二个数赋给第三个位置（相当于后移一位），然后第一个数再跟tmp 比，如果第一个的数小于tmp，则将tmp的值赋给第二个位置。

简单的说 就是先拿出第二个放到一个临时变量中，然后依次跟它前面的比，比它大的就后移，比它小的就不动，然后插入到空出的位置。

```java
/**
	 * 插入排序
	 * @param arr
	 */
	public static void sort(long arr[]) {
		long tmp = 0;
		
		for(int i=1;i<arr.length;i++) {
			tmp = arr[i];
			int j = i;
			while(j>0 && arr[j-1]>=tmp) {
				arr[j] = arr[j-1];
				j--;
			}
			arr[j] = tmp;
			
		}
	}
```

