# 对象锁、类锁、自定义锁到底能锁住谁？？？ - 苝花向暖丨楠枝向寒 - CSDN博客

2018年03月20日 22:27:46[苝花向暖丨楠枝向寒](https://me.csdn.net/weixin_40247263)阅读数：99


看了很多关于锁的文章，一直看的晕晕乎乎的，今天下定决心把这点东西弄明白，自己做了测试。

话不多说，进入正题。

对象锁：只能锁住 同一个对象

//说明：ThisClock  extends Thread，MyClock是自己创建的类。

ThisClock th1 = new ThisClock();
ThisClock th2 = new ThisClock();
ThisClock th3 = new ThisClock();

th1.start();
th2.start();

th3.start();

这种情况，创建了多个对象的锁不住。

类锁：上述情况可以锁住，因为创建的所有的对象都属于ThisClock  这个类

内部自定义锁

在ThisClock 类 内部，创建一个 Object obj = new Object();

synchronized(obj ){

...

}

这种情况跟对象锁 一样，也是创建多个对象，每个对象的属性都不一样。也是锁不住。

但是变成static Object obj = new Object();即可解决，静态属性 全局唯一嘛。

外部自定义锁，创建个类。把这个类的对象作为锁。由于上述案例的经验，必须用单例模式，确保每次new出来的对象是唯一的。否则锁不上。

public class MyClock{

    单例模式

}

public class ThisClock extends Thread{

//static Object obj = new Object();
@Override
public void run() {

synchronized(MyClock.getMyclock()) {

for (int i = 0; i < 10; i++) {

System.out.println(Thread.currentThread().getName()+"---"+i);
}

}

}
}

总结：无论是什么锁，关键是 你这个 锁 是否唯一。 synchronized就像是个门，里面的参数就是规定可以打开这个门的钥匙类型。要想保证能锁住，得确保钥匙的唯一性，也就是如果用对象锁和自定义锁，我就不能让你随便new实例，得保证实例的唯一性，那保证唯一性可不就是单例模式。 类锁 本身就具备唯一性。



