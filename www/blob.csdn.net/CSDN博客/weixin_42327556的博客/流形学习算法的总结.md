# 流形学习算法的总结 - weixin_42327556的博客 - CSDN博客
2018年07月18日 14:50:22[王天平](https://me.csdn.net/weixin_42327556)阅读数：1787
![](https://blog.csdn.net/home/jh/Pictures/Screenshot%20from%202018-07-18%2014-17-52%20(copy).png)![](https://blog.csdn.net/home/jh/Pictures/Screenshot%20from%202018-07-18%2014-17-52%20(copy).png)       由于线性降维算法在降维后不能很好保持复杂结构高维数据的完整信息，所以产生对非线性降维的需求，也就有从数学拓扑中出发的流形映射，这是因为大部分现实中非线性结构都可以看做是流形结构，当然也有不是流形结构的几何体，比如两条相交的直线的交叉点，而且由于流形的定义就是和欧式空间存在一个同胚映射（映射和逆映射都是连续映射），同胚映射可以很好保留流形的几何性质。，只要把对应的映射构造出来，就可以把流形体看作一个欧式空间，流形算法就是基于这样的思想去构造优化映射，使得嵌入低维的数据逆映射回来也能保持大部分数据信息
然后呢，今天在做大样本高维数据的降维的时候，还是遇到很多bug，比如lle，hlle，mlle都会遇到无法避免的奇异性问题（lle类最后只用了LTSA方法而且每次降一万条），而且对于大样本数据不建议训练参数，我的感觉是直接调好参数然后进行fit_transform，然后再做进一步数据挖掘，同时看效果调整对应参数，比如经常会用到knn的超参数k设置问题。
![](https://blog.csdn.net/home/jh/Pictures/Screenshot%20from%202018-07-18%2014-17-52.png)![](https://blog.csdn.net/home/jh/Pictures/Screenshot%20from%202018-07-18%2014-46-50.png)![Images](https://static.dingtalk.com/media/lALPBbCc1hPEcMjMrM0Bog_418_172.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22237050%3A483571742%22%2C%22msgId%22%3A%22219457643541%22%7D&open_id=483571742)
一、多维缩放MDS
       首先先来看早期的流形算法多维缩放MDS[Cox and Cox2001] 这样一种经典的降维方法，也是大部分流形算法扩展的基础，下面简介介绍算法流程。
       假设给定m个样本，可以计算出原始空间中的距离矩阵![D\in R^{m\times m}](https://private.codecogs.com/gif.latex?D%5Cin%20R%5E%7Bm%5Ctimes%20m%7D)，其中第i行第j列的元素![dist_{ij}](https://private.codecogs.com/gif.latex?dist_%7Bij%7D)表示样本![x_{i}](https://private.codecogs.com/gif.latex?x_%7Bi%7D)到![x_{j}](https://private.codecogs.com/gif.latex?x_%7Bj%7D)之间的距离。现在希望把数据降维到d′维空间中去，得到所有样本点在d′维空间中的表示![Z\in R^{d^{'}\times m}](https://private.codecogs.com/gif.latex?Z%5Cin%20R%5E%7Bd%5E%7B%27%7D%5Ctimes%20m%7D),![d^{'}\leq d](https://private.codecogs.com/gif.latex?d%5E%7B%27%7D%5Cleq%20d)，并且任意两个样本在d′维空间中的距离等于原始空间中的距离，即 ![||z_{i}-z_{j}||=dist_{ij}](https://private.codecogs.com/gif.latex?%7C%7Cz_%7Bi%7D-z_%7Bj%7D%7C%7C%3Ddist_%7Bij%7D)
       令![B=Z^{T}Z\in R^{m\times m}](https://private.codecogs.com/gif.latex?B%3DZ%5E%7BT%7DZ%5Cin%20R%5E%7Bm%5Ctimes%20m%7D),其中B为降维后样本的内积矩阵，![b_{ij}=z_{i}^{T}z_{j}](https://private.codecogs.com/gif.latex?b_%7Bij%7D%3Dz_%7Bi%7D%5E%7BT%7Dz_%7Bj%7D)，有
![dist_{ij}^{2}=||z_{i}||^{2}+||z_{j}||^{2}-2z_{i}^{T}z_{j} =b_{ii}+b_{jj}-2b_{ij}\qquad(1.1)](https://private.codecogs.com/gif.latex?dist_%7Bij%7D%5E%7B2%7D%3D%7C%7Cz_%7Bi%7D%7C%7C%5E%7B2%7D&plus;%7C%7Cz_%7Bj%7D%7C%7C%5E%7B2%7D-2z_%7Bi%7D%5E%7BT%7Dz_%7Bj%7D%20%3Db_%7Bii%7D&plus;b_%7Bjj%7D-2b_%7Bij%7D%5Cqquad%281.1%29)
不失一般性，我们假设低维空间中的样本点是中心化的，即![\small \sum_{i=1}^{m} z_{i} =0](https://private.codecogs.com/gif.latex?%5Cdpi%7B80%7D%20%5Csmall%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z_%7Bi%7D%20%3D0),显然，矩阵B点行和列之和都为零，即![\small \sum_{i=1}^{m} b_{ij} =\sum_{j=1}^{m} b_{ij} =0](https://private.codecogs.com/gif.latex?%5Cdpi%7B80%7D%20%5Csmall%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20b_%7Bij%7D%20%3D%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20b_%7Bij%7D%20%3D0).易知
![\small \sum_{i=1}^{m}dist_{ij}^{2}=tr(B)+mb_{jj}\quad\eqno(1.2)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%3Dtr%28B%29&plus;mb_%7Bjj%7D%5Cquad%5Ceqno%281.2%29)
![\small \sum_{j=1}^{m}dist_{ij}^{2}=tr(B)+mb_{ii}\quad\eqno(1.3)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%3Dtr%28B%29&plus;mb_%7Bii%7D%5Cquad%5Ceqno%281.3%29)
![\small \sum_{i=1}^{m}\sum_{j=1}^{m}dist_{ij}^{2}=2mtr(B) \quad \eqno(1.4 )](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Csum_%7Bj%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%3D2mtr%28B%29%20%5Cquad%20%5Ceqno%281.4%20%29)
其中tr表示矩阵的迹(trace),![\small tr(B)=\sum_{i=1}^{m}||z_{i}||^{2}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20tr%28B%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7C%7Cz_%7Bi%7D%7C%7C%5E%7B2%7D).令
![\small dist_{i.}^{2}=\frac{1}{m} \sum_{j=1}^{m}dist_{ij}^{2}\quad(1.5)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20dist_%7Bi.%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%5Cquad%281.5%29)
![\small dist_{.j}^{2}=\frac{1}{m} \sum_{i=1}^{m}dist_{ij}^{2}\quad (1.6)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20dist_%7B.j%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%5Cquad%20%281.6%29)
![\small dist_{..}^{2}=\frac{1}{m^{2}}\sum_{i=1}^{m} \sum_{j=1}^{m}dist_{ij}^{2}\quad(1.7)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20dist_%7B..%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bm%5E%7B2%7D%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7Ddist_%7Bij%7D%5E%7B2%7D%5Cquad%281.7%29)
由式(1.1)-(1.7)可得
![\small b_{ij}=-\frac{1}{2}(dist_{ij}^{2}-dist_{i.}^{2}-dist_{.j}^{2}+dist_{..}^{2}) \quad(1.8)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20b_%7Bij%7D%3D-%5Cfrac%7B1%7D%7B2%7D%28dist_%7Bij%7D%5E%7B2%7D-dist_%7Bi.%7D%5E%7B2%7D-dist_%7B.j%7D%5E%7B2%7D&plus;dist_%7B..%7D%5E%7B2%7D%29%20%5Cquad%281.8%29)
由此通过降维前后保持不变的距离矩阵D可以求取内积矩阵B。
对矩阵B做特征值分解，![\small B=V\Lambda V^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20B%3DV%5CLambda%20V%5E%7BT%7D),其中![\small \Lambda=diag(\lambda_{1},\lambda_{2},...\lambda_{d})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CLambda%3Ddiag%28%5Clambda_%7B1%7D%2C%5Clambda_%7B2%7D%2C...%5Clambda_%7Bd%7D%29)为特征值构成的对角矩阵，![\small \lambda_{1}\geq \lambda_{2}...\geq \lambda_{d}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Clambda_%7B1%7D%5Cgeq%20%5Clambda_%7B2%7D...%5Cgeq%20%5Clambda_%7Bd%7D),V为特征向量矩阵。假定其中有![\small d^{*}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20d%5E%7B*%7D)个非零向量，它们构成的对角矩阵![\small \Lambda_{*}=diag(\lambda_{1},\lambda_{2},...,\lambda_{d^{*}})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CLambda_%7B*%7D%3Ddiag%28%5Clambda_%7B1%7D%2C%5Clambda_%7B2%7D%2C...%2C%5Clambda_%7Bd%5E%7B*%7D%7D%29),令![\small V_{*}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20V_%7B*%7D)表示对应的特征向量矩阵，则Z可表示为
![\small Z=\Lambda_{*}^{\frac{1}{2}}V_{*}^{T}\in R^{d^{*}\times m} \quad (1.9)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Z%3D%5CLambda_%7B*%7D%5E%7B%5Cfrac%7B1%7D%7B2%7D%7DV_%7B*%7D%5E%7BT%7D%5Cin%20R%5E%7Bd%5E%7B*%7D%5Ctimes%20m%7D%20%5Cquad%20%281.9%29)
在现实应用中为了有效降维，往往需要仅需降维后的距离与原始空间中的距离尽可能接近，而不必严格相等。此时可取![\small d^{'}<<d](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20d%5E%7B%27%7D%3C%3Cd) 个最大特征值构成对角矩阵![\small \widetilde{\Lambda}=diag(\lambda_{1},\lambda_{2},...,\lambda_{d^{'}})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cwidetilde%7B%5CLambda%7D%3Ddiag%28%5Clambda_%7B1%7D%2C%5Clambda_%7B2%7D%2C...%2C%5Clambda_%7Bd%5E%7B%27%7D%7D%29),令![\small \widetilde{V}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cwidetilde%7BV%7D)表示相应的特征向量矩阵，则样本的低维坐标Z可表达为
![\small Z=\widetilde{\Lambda}^{\frac{1}{2}}\widetilde{V}^{T}\in R^{d^{'}\times m} \quad (1.10)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Z%3D%5Cwidetilde%7B%5CLambda%7D%5E%7B%5Cfrac%7B1%7D%7B2%7D%7D%5Cwidetilde%7BV%7D%5E%7BT%7D%5Cin%20R%5E%7Bd%5E%7B%27%7D%5Ctimes%20m%7D%20%5Cquad%20%281.10%29)
![](https://images2017.cnblogs.com/blog/1289982/201712/1289982-20171219210854662-1216348734.png)
从上面流程我们可以发现MDS的主要思想是对与流形中局部结构的距离用欧式距离来近似，这个原理就是并在低维空间保持欧式距离不变，计算过程简单，但是这个算法只能局限于局部，因为只有在局部流行体的距离才可以用欧式距离近似（这就和在地球很近两个地方距离可以看成连线，但是两个洲的距离就不能简单看成直线了）而且容易受到数据噪声的影响，因为用欧式距离所以对于结构比较复杂流形局部数据容易损失几何信息。
二、isomap
      同距映射的基本出发点，是认为低维流形嵌入到 高维空间之后，直接在高维空间中计算具有误导性，因为高维空间中的直线距离在低维嵌入流形上是不可达，简而言之就是用测地线距离来代替MDS中的欧氏距离输入。那么如何计算测地线距离呢？这时我们可利用流形在局部与欧式空间同胚这个性质，对于每个点基于欧氏距离找出其近邻点，然后就能建立一个近邻连接图（有两种方法可以用来构建连接图，一种是指定k最近连接点，另外一种是距离目标点距离小于![\small \varepsilon](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarepsilon)的都被认为是近邻点），图中近邻点存在连接，而非近邻点之间不存在连接，于是计算两点之间测地线的距离就转变为计算近邻连接图上两点之间的最短路径问题，在近邻连接图上计算两点之间的最短路径，可以采用Dijkstra算法或Floyd算法得到任意两点的距离，然后得到距离矩阵D输入MDS。
     同距映射关注的是如何将整个流形体的点对测地线保留到低维空间里面，由于测地线计算复杂而且随着样本数的增加而增大，这就是同距映射虽然思想简单但是计算复杂度却要比LLE复杂（这里因为同距映射采用测地线计算，而lle是从权重线性关系来考虑的），不过同距映射还要注意近邻点k的设置，要足够大到把所有连接的区域选进来，然后又不能太大把距离太远的点选进来造成短路现象。此外还要注意isomap适合于内部平坦的低维流形，不适合于学习有较大内在曲率的流形
三、局部线性嵌入LLE
      首先假设数据不是分布在闭合的球面或者椭球面上，也就是没有形成一个封闭的超曲面，而且在较小的局部是线性，也就是说某一个数据可以由它邻域中的几个样本来线性表示。
基本思想：我们有一个样本![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D),我们在![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)的流形邻域里用k-近邻思想找到和![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)最近的k个样本![\small x_{1i},x_{2i},...x_{ki}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7B1i%7D%2Cx_%7B2i%7D%2C...x_%7Bki%7D). 然后我们假设![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)可以由x_{1i},x_{2i},...x_{ki}线性加权表示，即：![\small x_{i}=\sum_{j=1}^{k}w_{ji}x_{ji}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bk%7Dw_%7Bji%7Dx_%7Bji%7D),且![\small \sum_{j=1}^{k} w_{ji}=1](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20w_%7Bji%7D%3D1)，这里![\small w_{ji},j=1,2,..,k](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20w_%7Bji%7D%2Cj%3D1%2C2%2C..%2Ck)为权重系数,在我们通过LLE降维后，我们希望![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)在低维空间对应的投影![\small y_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20y_%7Bi%7D)′和![\small x_{1i},x_{2i},...x_{ki}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7B1i%7D%2Cx_%7B2i%7D%2C...x_%7Bki%7D)对应的投影![\small y_{1i},y_{2i},...,y_{ki}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20y_%7B1i%7D%2Cy_%7B2i%7D%2C...%2Cy_%7Bki%7D)也尽量保持同等权重的线性关系，即：![\small y_{i}=\sum_{j=1}^{k}w_{ji}y_{ji}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20y_%7Bi%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bk%7Dw_%7Bji%7Dy_%7Bji%7D),但是现实应用中尽量使得![\small w_{ij}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20w_%7Bij%7D)在降维后维持不变或者变化尽可能小。下图描绘具体流程
![](https://images2015.cnblogs.com/blog/1042406/201701/1042406-20170110114643806-1397788141.png)
具体算法步骤：
　　1.分图：
               输入流形M中m个数据点![x_{1},x_{2},...,x_{m}](https://private.codecogs.com/gif.latex?x_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7Bm%7D)，由于在流形中使用测地线算距离，使用Dijkstra 算法寻找数据点                                          ![\small x_{i},i=1,2,...m](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D%2Ci%3D1%2C2%2C...m)的k个最近数据点集合![\small J_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20J_%7Bi%7D)。 
　　2.构造权重并重构数据 　
               假设每个数据点![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)的数据局部为可以用线性组合表示，且![\small w_{ji}=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20w_%7Bji%7D%3D0)(如果![\small x_{j}\notin J_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bj%7D%5Cnotin%20J_%7Bi%7D)),则对应的损失函数为： 
![\small J(w)=\sum_{i=1}^{m}||x_{i}-\sum_{j\in J_{i}}w_{ji}x_{ji}||^{2} =\sum_{i=1}^{m}W_{i}^{T}(V_{i}X-X)^{T}(V{i}X-X)W_{i}=\sum_{i=1}^{m}W^{T}Z_{i}W \quad(2.1)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20J%28w%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7C%7Cx_%7Bi%7D-%5Csum_%7Bj%5Cin%20J_%7Bi%7D%7Dw_%7Bji%7Dx_%7Bji%7D%7C%7C%5E%7B2%7D%20%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7DW_%7Bi%7D%5E%7BT%7D%28V_%7Bi%7DX-X%29%5E%7BT%7D%28V%7Bi%7DX-X%29W_%7Bi%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7DW%5E%7BT%7DZ_%7Bi%7DW%20%5Cquad%282.1%29)
　　　　其中![\small W_{i}=(w_{1i},w_{2i},...,w_{mi})^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D%3D%28w_%7B1i%7D%2Cw_%7B2i%7D%2C...%2Cw_%7Bmi%7D%29%5E%7BT%7D)表示线性构造时对![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)的贡献比例,![\small X=(x_{1},x_{2}...,x_{m})^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20X%3D%28x_%7B1%7D%2Cx_%7B2%7D...%2Cx_%7Bm%7D%29%5E%7BT%7D),![\small V_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20V_%7Bi%7D)为第i列为1其他为0的m x m矩阵。 
　　　　在![\small \sum_{j=1}^{m}w_{ji}=W_{i}I_{mi}=1,i=1,...,m](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7Dw_%7Bji%7D%3DW_%7Bi%7DI_%7Bmi%7D%3D1%2Ci%3D1%2C...%2Cm)的限制条件下，使用拉格朗日乘值法最小化损失函数J(W)求出权重系数矩阵![\small W=[w_{ij}]](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W%3D%5Bw_%7Bij%7D%5D) ,
              其中![\small W_{i}=\frac{z_{i}^{-1}I_{k}}{I_{k}^{T}z_{i}^{-1}I_{k}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D%3D%5Cfrac%7Bz_%7Bi%7D%5E%7B-1%7DI_%7Bk%7D%7D%7BI_%7Bk%7D%5E%7BT%7Dz_%7Bi%7D%5E%7B-1%7DI_%7Bk%7D%7D), ![\small I_{k}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20I_%7Bk%7D)为全为1的k维列向量.
　　3.由重构样本向低维d维空间映射。
              在得到高维空间的线性权重系数，我们希望嵌入低维也能维持一样的线性权重关系，也是使得对应的均方误差损失函数
              最小,矩阵表示为：                     
![\small J(Y)=\sum_{i=1}^{m}||y_{i}-\sum_{j\in J_{i}}w_{ji}y_{ji}||^{2} =\sum_{i=1}^{m}||YI_{i}-YW_{i}||^{2}=tr(Y^{T}(I-W)^{T}(I-W)Y)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20J%28Y%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7C%7Cy_%7Bi%7D-%5Csum_%7Bj%5Cin%20J_%7Bi%7D%7Dw_%7Bji%7Dy_%7Bji%7D%7C%7C%5E%7B2%7D%20%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7C%7CYI_%7Bi%7D-YW_%7Bi%7D%7C%7C%5E%7B2%7D%3Dtr%28Y%5E%7BT%7D%28I-W%29%5E%7BT%7D%28I-W%29Y%29)
             这里![\small Y=(y_{1},y_{2},...,y_{m})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%3D%28y_%7B1%7D%2Cy_%7B2%7D%2C...%2Cy_%7Bm%7D%29),![\small I_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20I_%7Bi%7D)为第i个元素为1的列向量，![\small W_{i}=(w_{1i},w_{2i},...,w_{mi})^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D%3D%28w_%7B1i%7D%2Cw_%7B2i%7D%2C...%2Cw_%7Bmi%7D%29%5E%7BT%7D)，为了得到标准化的低维数据，加入线性约束                                                                                      ![\small \sum_{i=1}^{m} y_{i}=0,\frac{1}{m}\sum_{i=1}^{m} y_{i}y_{i}^{T}=I \quad (2.2)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20y_%7Bi%7D%3D0%2C%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20y_%7Bi%7Dy_%7Bi%7D%5E%7BT%7D%3DI%20%5Cquad%20%282.2%29)
             在线性约束下使用拉格朗日乘值法最小化J(Y)得到![\small MY=\lambda Y](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20MY%3D%5Clambda%20Y)，![\small M=(I-W)^{T}(I-W)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20M%3D%28I-W%29%5E%7BT%7D%28I-W%29),要想得到使得J(Y)最小化的d维数                   据，这里Y很明显是M的特征向量,只需要求得M的d个最小特征值对应的特征向量，由于线性约束![\small \sum_{j=1}^{m} w_{ij}=1,Me=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20w_%7Bij%7D%3D1%2CMe%3D0)
             则M最小的特征值 是0，所以选择M的第二小到第d+1小的特征值，即![\small Y=[Y_{2},Y_{3},...,Y_{d+1}]](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%3D%5BY_%7B2%7D%2CY_%7B3%7D%2C...%2CY_%7Bd&plus;1%7D%5D)为低维空间样本集数据。
     LLE的优缺点：虽然LLE算法很简便，而且能够保留数据点局部的结构，但是也有一些问题存在，比如x的近邻点个数大于数据的维度，权重矩阵就不是满秩，也就是不可逆，也就是正则化问题，而且使用k近邻对邻域点的稀疏程度也比较敏感，当数据结构比较稀疏，选择的局部范围就会比较大，低维嵌入效果也就变得比较差，此外，学习的流形只能是非闭合的，有局限性，
四、MLLE算法
       由于LLE存在的一些问题，也就产生LLE的一系列变种MLLE,HLLE,LTSA.而MLLE就是为了解决LLE 权重系数矩阵的正则化问题。
基本思想：MLLE在找距离最近的k个最近邻的同时要考虑近邻的分布权重，它希望通过多维局部权重矩阵找到的近邻的分布权重尽量在样本的各个方向，而不是集中在一侧.而且在解决权重矩阵的奇异问题，通过对权重系数矩阵做一个压缩估计，也就是对于![\small W_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D)自身和(2.1)中![\small Z_{i}^{\frac{1}{2}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Z_%7Bi%7D%5E%7B%5Cfrac%7B1%7D%7B2%7D%7D)做svd分解以及对应household矩阵做一个线性组合保证压缩后的![\small W_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D)可逆(原理可见zhang zhenyueMLLE TH2.2)，而且通过![\small Z_{i}^{\frac{1}{2}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Z_%7Bi%7D%5E%7B%5Cfrac%7B1%7D%7B2%7D%7D)奇异值贡献比例![\small \rho _{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Crho%20_%7Bi%7D)来选择特征向量的个数，然后计算压缩后![\small W_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bi%7D)，后续嵌入到低维就和LLE差不多.算法如下：
![](https://img-blog.csdn.net/20180717165803636?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMyNzU1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
   MLLE解决了当邻域点大于数据维数的出现的权重系数不可逆问题，而且算法复杂度与LLE几乎差不多，如果样本数据集是从isomap流形选取的，它可以达到非常理想的嵌入效果（也就是逆映射回来也几乎和原来的流形体一样），而且在cost函数误差比较小的情况下，它的低维嵌入表现和LTSA算法差不多，缺点：解决的流形不能是闭合流形，不能是稀疏的数据集，不能是分布不均匀的数据集。
五、HLLE算法基础
**问题**：
        设![\small M\sqsubseteq R^{D}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20M%5Csqsubseteq%20R%5E%7BD%7D),M是一个d维流形。![\small \Xi \sqsubseteq R^{d}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CXi%20%5Csqsubseteq%20R%5E%7Bd%7D)，![\small \Xi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CXi)是开集，M与![\small \Xi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CXi)同胚，这里![\small d\ll D](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20d%5Cll%20D).我们要找M与![\small \Xi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CXi)之间的同胚映射![\small \varphi\quad \Xi \rightarrow M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%5Cquad%20%5CXi%20%5Crightarrow%20M),使得对任意![\small x \in M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x%20%5Cin%20M)，![\small \varphi ^{-1}(x) \in \Xi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%20%5E%7B-1%7D%28x%29%20%5Cin%20%5CXi)即为x的低维表示，HLLE的目标就是找到这样的同胚映射![\small \varphi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi) .
        基于同胚映射![\small \varphi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi)，我们定义一个泛函![\small f_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f_%7Bi%7D)![\small M\rightarrow R](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20M%5Crightarrow%20R),使得对所有![\small x\in M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x%5Cin%20M),都有![\small f_{i}(x)=[\varphi ^{-1}]_{i}(x)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f_%7Bi%7D%28x%29%3D%5B%5Cvarphi%20%5E%7B-1%7D%5D_%7Bi%7D%28x%29)，这里![\small f_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f_%7Bi%7D)表示![\small \varphi ^{-1}(x)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%20%5E%7B-1%7D%28x%29)的第i个分量，i=1,..,d。因此这些泛函与同胚映射![\small \varphi\quad \Xi \rightarrow M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%5Cquad%20%5CXi%20%5Crightarrow%20M)等价，事实上对任意![\small x \in M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x%20%5Cin%20M)，都有：
![\small \varphi ^{-1}(x)=([\varphi ^{-1}(x)]_{1},...,[\varphi ^{-1}(x)]_{d})=[f_{1}(x),...,f_{d}(x)]\quad (5.1)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%20%5E%7B-1%7D%28x%29%3D%28%5B%5Cvarphi%20%5E%7B-1%7D%28x%29%5D_%7B1%7D%2C...%2C%5B%5Cvarphi%20%5E%7B-1%7D%28x%29%5D_%7Bd%7D%29%3D%5Bf_%7B1%7D%28x%29%2C...%2Cf_%7Bd%7D%28x%29%5D%5Cquad%20%285.1%29)
         因此HLLE是在寻找![\small f_{1},...,f_{d}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f_%7B1%7D%2C...%2Cf_%7Bd%7D)这d个泛函。
**切空间和局部映射**：
         对任意的![\small x \in M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x%20%5Cin%20M)，设![\small T_{x}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20T_%7Bx%7D)表示流形M上一点x的切空间，可以证明![\small dimT_{x}=d](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20dimT_%7Bx%7D%3Dd),令![\small U_{x}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20U_%7Bx%7D)为![\small D\times d](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20D%5Ctimes%20d)的矩阵，并且![\small U_{x}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20U_%7Bx%7D)的列向量就是![\small T_{x}(m)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20T_%7Bx%7D%28m%29)的正交基，基于![\small U_{x}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20U_%7Bx%7D)，定义了一个映射：![\small \varphi _{x}\quad R^{d}\rightarrow R^{D}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%20_%7Bx%7D%5Cquad%20R%5E%7Bd%7D%5Crightarrow%20R%5E%7BD%7D)使得对任意![\small \theta \in R^{d}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Ctheta%20%5Cin%20R%5E%7Bd%7D),都有![\small \varphi _{\theta}=U_{x}\theta+x](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarphi%20_%7B%5Ctheta%7D%3DU_%7Bx%7D%5Ctheta&plus;x),因此HLLE就是基于![\small \{\varphi _{x}|x\in M\}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5C%7B%5Cvarphi%20_%7Bx%7D%7Cx%5Cin%20M%5C%7D),
**Hessian矩阵：**
         令![\small W_{2,2}^{M}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7B2%2C2%7D%5E%7BM%7D)为一个sobolev空间，即它的元素都是平方可积且二阶连续可导。
         定义：对任意的![\small f \in W_{2,2}^{M}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f%20%5Cin%20W_%7B2%2C2%7D%5E%7BM%7D)以及任意的![\small x \in M](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x%20%5Cin%20M)，定义
![\small (H^{iso}f)(x)=(H^{euc}(f\circ \varphi ))(\theta)|_{\theta=\varphi ^{-1}(x)},(H^{tan}f)(x)=(H^{euc}(f\circ \varphi ))(\theta)|_{\theta=0} \quad(5.2)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%28H%5E%7Biso%7Df%29%28x%29%3D%28H%5E%7Beuc%7D%28f%5Ccirc%20%5Cvarphi%20%29%29%28%5Ctheta%29%7C_%7B%5Ctheta%3D%5Cvarphi%20%5E%7B-1%7D%28x%29%7D%2C%28H%5E%7Btan%7Df%29%28x%29%3D%28H%5E%7Beuc%7D%28f%5Ccirc%20%5Cvarphi%20%29%29%28%5Ctheta%29%7C_%7B%5Ctheta%3D0%7D%20%5Cquad%285.2%29)
          HLLE算法证明了:                                              ![\small \forall x \in M,(H^{iso}f)(x)=(H^{tan}f)(x) \quad(5.3)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cforall%20x%20%5Cin%20M%2C%28H%5E%7Biso%7Df%29%28x%29%3D%28H%5E%7Btan%7Df%29%28x%29%20%5Cquad%285.3%29)
**二次泛函：**
          对任意 ![\small f \in W_{2,2}^{M}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f%20%5Cin%20W_%7B2%2C2%7D%5E%7BM%7D) ，定义两个二次泛函为：
**![\small \Phi ^{iso}(f)=\int_{M}|| (H^{iso}f)(m)||^{2}dm:\Phi ^{tan}(f)=\int_{M}|| (H^{tan}f)(m)||^{2}dm \quad(5.4)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi%20%5E%7Biso%7D%28f%29%3D%5Cint_%7BM%7D%7C%7C%20%28H%5E%7Biso%7Df%29%28m%29%7C%7C%5E%7B2%7Ddm%3A%5CPhi%20%5E%7Btan%7D%28f%29%3D%5Cint_%7BM%7D%7C%7C%20%28H%5E%7Btan%7Df%29%28m%29%7C%7C%5E%7B2%7Ddm%20%5Cquad%285.4%29)**
这里![\small ||A||^{2}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%7C%7CA%7C%7C%5E%7B2%7D)表示Frobenius二次范数。
           注：1.![\small \Phi ^{iso}(f)=0\Leftrightarrow \forall x\in M,(H^{iso}f)(x)=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi%20%5E%7Biso%7D%28f%29%3D0%5CLeftrightarrow%20%5Cforall%20x%5Cin%20M%2C%28H%5E%7Biso%7Df%29%28x%29%3D0) ; 2  ![\small \Phi ^{tan}(f)=0\Leftrightarrow \forall x\in M,(H^{tan}f)(x)=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi%20%5E%7Btan%7D%28f%29%3D0%5CLeftrightarrow%20%5Cforall%20x%5Cin%20M%2C%28H%5E%7Btan%7Df%29%28x%29%3D0)
**具体算法步骤:**
       与LSTA类似，HLLE也是基于局部切空间对LLE做的一个正则化优化，它是一种恢复流形本质结构的参数化方法，定义一个泛函：![\small f:M\rightarrow R](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f%3AM%5Crightarrow%20R),基于f定义一个二次泛函:![\small H(f)=\int _{M}||H_{f}(m)||_{F}^{2}dm](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20H%28f%29%3D%5Cint%20_%7BM%7D%7C%7CH_%7Bf%7D%28m%29%7C%7C_%7BF%7D%5E%7B2%7Ddm),如果流形M同胚于![\small R^{d}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20R%5E%7Bd%7D)的一个连通开集，则那么H(f)就有一个d+1维的零空间，它由常函数和一个原始isomap坐标张成的d维坐标构成，因此，低维等距坐标能够从H(f)的零空间中恢复，步骤如下：
**输入：![\small X=[x_{1},x_{2},...,x_{N}],x_{i}\in R^{D},i=1,2,...,N](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20X%3D%5Bx_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7BN%7D%5D%2Cx_%7Bi%7D%5Cin%20R%5E%7BD%7D%2Ci%3D1%2C2%2C...%2CN)表示高维空间N个数据点,参数d维空间，邻域点k**
**        输出：![\small Y=[y_{1},y_{2},...,y_{N}],y_{i}\in R^{D},i=1,2,...,N](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%3D%5By_%7B1%7D%2Cy_%7B2%7D%2C...%2Cy_%7BN%7D%5D%2Cy_%7Bi%7D%5Cin%20R%5E%7BD%7D%2Ci%3D1%2C2%2C...%2CN)表示高维空间N个数据点**
**        条件：![\small d< min\{k,D\}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20d%3C%20min%5C%7Bk%2CD%5C%7D)**
**         步骤如下:**
        (1)选邻域
              设对每一个点![\small x_{i},i=1,...,N](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D%2Ci%3D1%2C...%2CN),用欧式距离确定它的k邻域用![\small N_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20N_%7Bi%7D)表示，然后将邻域集合中心化得到列向量![\small M^{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20M%5E%7Bi%7D)，即 
![\small [M^{i}]_{j}=x_{ij}-\overline{x_{i}},j=1,...,k](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5BM%5E%7Bi%7D%5D_%7Bj%7D%3Dx_%7Bij%7D-%5Coverline%7Bx_%7Bi%7D%7D%2Cj%3D1%2C...%2Ck)，![\small \overline{x_{i}}=\frac{1}{|N_{i}|}\sum_{j=N_{i}}x_{j}=\frac{1}{k}\sum_{p=1}^{k}x_{ip}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cdpi%7B100%7D%20%5Csmall%20%5Coverline%7Bx_%7Bi%7D%7D%3D%5Cfrac%7B1%7D%7B%7CN_%7Bi%7D%7C%7D%5Csum_%7Bj%3DN_%7Bi%7D%7Dx_%7Bj%7D%3D%5Cfrac%7B1%7D%7Bk%7D%5Csum_%7Bp%3D1%7D%5E%7Bk%7Dx_%7Bip%7D)。很明显![\small M^{i}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cdpi%7B100%7D%20%5Csmall%20M%5E%7Bi%7D)是k×D维矩阵。
      （2）获得切坐标。对![\small M^{i}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cdpi%7B100%7D%20%5Csmall%20M%5E%7Bi%7D)进行SVD分解，即![\small M^{i}=U_{k\times k}\Sigma_{k\times D}V_{D\times D}^{T}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cdpi%7B100%7D%20%5Csmall%20M%5E%7Bi%7D%3DU_%7Bk%5Ctimes%20k%7D%5CSigma_%7Bk%5Ctimes%20D%7DV_%7BD%5Ctimes%20D%7D%5E%7BT%7D)。取![\small U_{k\times k}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cdpi%7B100%7D%20%5Csmall%20U_%7Bk%5Ctimes%20k%7D)的前d列作为切坐标。
      （3） 计算hessian估计子![X_{i}](https://private.codecogs.com/gif.latex?%5Cinline%20X_%7Bi%7D).由![U_{k\times k}^{i}](https://private.codecogs.com/gif.latex?%5Cinline%20U_%7Bk%5Ctimes%20k%7D%5E%7Bi%7D)形成矩阵![X_{i}](https://private.codecogs.com/gif.latex?%5Cinline%20X_%7Bi%7D)，![X_{i}](https://private.codecogs.com/gif.latex?%5Cinline%20X_%7Bi%7D)是![k\times (1+d+\frac{d(d+1)}{2})](https://private.codecogs.com/gif.latex?%5Cinline%20k%5Ctimes%20%281&plus;d&plus;%5Cfrac%7Bd%28d&plus;1%29%7D%7B2%7D%29)的矩阵，其中第一列全1向量 ![\Gamma _{k\times 1}](https://private.codecogs.com/gif.latex?%5Cinline%20%5CGamma%20_%7Bk%5Ctimes%201%7D),中间的d列为  
![U_{1}^{i},U_{2}^{i},...,U_{d}^{i}](https://private.codecogs.com/gif.latex?%5Cinline%20U_%7B1%7D%5E%7Bi%7D%2CU_%7B2%7D%5E%7Bi%7D%2C...%2CU_%7Bd%7D%5E%7Bi%7D).后面的![\frac{d(d+1)}{2}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cfrac%7Bd%28d&plus;1%29%7D%7B2%7D)为![U_{1}^{i},U_{2}^{i},...,U_{d}^{i}](https://private.codecogs.com/gif.latex?%5Cinline%20U_%7B1%7D%5E%7Bi%7D%2CU_%7B2%7D%5E%7Bi%7D%2C...%2CU_%7Bd%7D%5E%7Bi%7D)的外积。即如果d=2。则![X_{i}=\{\Gamma _{k\times 1},U_{1}^{i},U_{2}^{i},(U_{1}^{i})^{2},(U_{2}^{i})^{2},U_{1}^{i}\times U_{2}^{i}\}](https://private.codecogs.com/gif.latex?%5Cinline%20X_%7Bi%7D%3D%5C%7B%5CGamma%20_%7Bk%5Ctimes%201%7D%2CU_%7B1%7D%5E%7Bi%7D%2CU_%7B2%7D%5E%7Bi%7D%2C%28U_%7B1%7D%5E%7Bi%7D%29%5E%7B2%7D%2C%28U_%7B2%7D%5E%7Bi%7D%29%5E%7B2%7D%2CU_%7B1%7D%5E%7Bi%7D%5Ctimes%20U_%7B2%7D%5E%7Bi%7D%5C%7D)。
       （4） 正交化。将![X_{i}](https://private.codecogs.com/gif.latex?%5Cinline%20X_%7Bi%7D)施密特正交化得到   ![\widehat{X_{i}}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cwidehat%7BX_%7Bi%7D%7D) ,![\widehat{X_{i}}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cwidehat%7BX_%7Bi%7D%7D)的列向量标准正交。提取最后![\frac{d(d+1)}{2}](https://private.codecogs.com/gif.latex?%5Cinline%20%5Cfrac%7Bd%28d&plus;1%29%7D%7B2%7D)列并且装置得到![H_{i}](https://private.codecogs.com/gif.latex?%5Cinline%20H_%7Bi%7D) 即               
![(H_{i})_{r\times q}=(X_{i})_{q\times(1+d+r)},r=1,2,...,\frac{d+1}{2},q=1,2,...,k](https://private.codecogs.com/gif.latex?%5Cinline%20%28H_%7Bi%7D%29_%7Br%5Ctimes%20q%7D%3D%28X_%7Bi%7D%29_%7Bq%5Ctimes%281&plus;d&plus;r%29%7D%2Cr%3D1%2C2%2C...%2C%5Cfrac%7Bd&plus;1%7D%7B2%7D%2Cq%3D1%2C2%2C...%2Ck)
       （5） 计算hessian矩阵H.
                 令![S=[S_{1},...,S_{N}]^{T},S_{i}=[S_{1col}^{i},...,S_{Ncol}^{i}]^{T}](https://private.codecogs.com/gif.latex?S%3D%5BS_%7B1%7D%2C...%2CS_%7BN%7D%5D%5E%7BT%7D%2CS_%7Bi%7D%3D%5BS_%7B1col%7D%5E%7Bi%7D%2C...%2CS_%7BNcol%7D%5E%7Bi%7D%5D%5E%7BT%7D),![S_{jcol}^{i}=(H_{i})_{pcol},if j=i_{p},p=1,...,k.otherwise S_{jcol}^{i}=0](https://private.codecogs.com/gif.latex?S_%7Bjcol%7D%5E%7Bi%7D%3D%28H_%7Bi%7D%29_%7Bpcol%7D%2Cif%20j%3Di_%7Bp%7D%2Cp%3D1%2C...%2Ck.otherwise%20S_%7Bjcol%7D%5E%7Bi%7D%3D0),
                 则![H=S^{T}S=\sum_{i=1}^{N}S_{i}^{T}S_{i}](https://private.codecogs.com/gif.latex?H%3DS%5E%7BT%7DS%3D%5Csum_%7Bi%3D1%7D%5E%7BN%7DS_%7Bi%7D%5E%7BT%7DS_%7Bi%7D),S是一个![[N\times \frac{d(d+1)}{2}]\times N](https://private.codecogs.com/gif.latex?%5BN%5Ctimes%20%5Cfrac%7Bd%28d&plus;1%29%7D%7B2%7D%5D%5Ctimes%20N)的矩阵，H是一个![N\times N](https://private.codecogs.com/gif.latex?N%5Ctimes%20N)的矩阵。
         (6)   计算嵌入。令V等于H的最小的(d+1)个特征值对应的d个非常数特征向量。即![V_{N\times d}](https://private.codecogs.com/gif.latex?V_%7BN%5Ctimes%20d%7D).
                 定义矩阵![R_{rs}](https://private.codecogs.com/gif.latex?%5Cinline%20R_%7Brs%7D):        ![R_{rs}=\sum_{j\in N_{i}}(V)_{jr}(V)_{js},1\leq r,s\leq d](https://private.codecogs.com/gif.latex?%5Cinline%20R_%7Brs%7D%3D%5Csum_%7Bj%5Cin%20N_%7Bi%7D%7D%28V%29_%7Bjr%7D%28V%29_%7Bjs%7D%2C1%5Cleq%20r%2Cs%5Cleq%20d)
                 那么嵌入坐标矩阵W就等于![W_{N\times d}=VR^{-\frac{1}{2}}](https://private.codecogs.com/gif.latex?%5Cinline%20W_%7BN%5Ctimes%20d%7D%3DVR%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D)
六、LSTA算法
 局部切空间对齐算法是由浙大学者zheng.zhenhua基于LLE提出来的一种有效的流形算法 ，将LLE中的用权重系数对数据点做线性表现形式转化为切空间坐标表现形式，其主要思想是利用低维局部切空间坐标来近似每个局部邻域, 然后通过对齐alignment局部切空间坐标来最小化嵌入误差获得全局的低维坐标 。
算法流程如下： 
1.抽取局部信息：
   1.1 按照输入空间的欧式距离，构建每个点![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)的局部邻域![\small x_{i}=(x_{i1},x_{i2},...,x_{ik})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D%3D%28x_%7Bi1%7D%2Cx_%7Bi2%7D%2C...%2Cx_%7Bik%7D%29)
   1.2  获取每个局部邻域的局部切空间坐标近似表示 ,假设![\small V_{i}=(v_{1},v_{2},...,v_{d})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20V_%7Bi%7D%3D%28v_%7B1%7D%2Cv_%7B2%7D%2C...%2Cv_%7Bd%7D%29)为点![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)邻域协方差矩阵![\small X_{i}(I-\frac{1}{k}ee^{T})X_{i}^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20X_%7Bi%7D%28I-%5Cfrac%7B1%7D%7Bk%7Dee%5E%7BT%7D%29X_%7Bi%7D%5E%7BT%7D)的前d个最大特       征值对应的特征向量所构成的矩阵，则该邻域的局部切空间坐标为 ![\small \widehat{X_{i}}=V_{i}^{T}X_{i}(I-\frac{1}{k}ee^{T})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cwidehat%7BX_%7Bi%7D%7D%3DV_%7Bi%7D%5E%7BT%7DX_%7Bi%7D%28I-%5Cfrac%7B1%7D%7Bk%7Dee%5E%7BT%7D%29).
2.局部切空间对齐:
   假设 d 维全局嵌入坐标为 ![\small Y=(y_{1},y_{2},...,y_{n})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%3D%28y_%7B1%7D%2Cy_%7B2%7D%2C...%2Cy_%7Bn%7D%29) , 且 ![\small Y_{i}=(y_{i1},y_{i2},...,y_{ik})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y_%7Bi%7D%3D%28y_%7Bi1%7D%2Cy_%7Bi2%7D%2C...%2Cy_%7Bik%7D%29) 为邻域![\small X_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20X_%7Bi%7D)中相应元素的嵌入坐标组成的矩阵。通过最小化       如下的局部对齐误差来对齐局部切空间坐标与全局坐标  ：
![\small E=\min\limits_{c_{i}\in R^{d},L_{i}\in R^{d\times d}}||Y_{i}-(c_{i}e^{T}+L_{i}\widehat{X}_{i})||_{F}^{2}=||Y_{i}\Phi_{i} ||_{F}^{2}=||Y_{i}S_{i}\Phi_{i} ||_{F}^{2}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20E%3D%5Cmin%5Climits_%7Bc_%7Bi%7D%5Cin%20R%5E%7Bd%7D%2CL_%7Bi%7D%5Cin%20R%5E%7Bd%5Ctimes%20d%7D%7D%7C%7CY_%7Bi%7D-%28c_%7Bi%7De%5E%7BT%7D&plus;L_%7Bi%7D%5Cwidehat%7BX%7D_%7Bi%7D%29%7C%7C_%7BF%7D%5E%7B2%7D%3D%7C%7CY_%7Bi%7D%5CPhi_%7Bi%7D%20%7C%7C_%7BF%7D%5E%7B2%7D%3D%7C%7CY_%7Bi%7DS_%7Bi%7D%5CPhi_%7Bi%7D%20%7C%7C_%7BF%7D%5E%7B2%7D)
  其中，![\small \Phi_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi_%7Bi%7D)为局部对齐矩阵，![\small S_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20S_%7Bi%7D)为0_1选择矩阵，满足![\small YS_{i}=Y_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20YS_%7Bi%7D%3DY_%7Bi%7D)
3.获取全局嵌入坐标
  通过最小化如下局部对齐误差和来获取全局低维嵌入坐标：
![\small \min \sum_{i=1}^{n}E_{i}=\min \sum_{i=1}^{n} ||YS_{i}\Phi_{i}||_{F}^{2}=\min \sum_{i=1}^{n} tr(YS_{i}\Phi_{i}\Phi_{i}^{T}S_{i}^{T}Y^{T})\par =\min tr(Y(\sum_{i=1}^{n}S_{i}\Phi_{i}\Phi_{i}^{T}S_{i}^{T})Y^{T}) =\min tr(Y\Phi Y^{T})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cmin%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7DE_%7Bi%7D%3D%5Cmin%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%7C%7CYS_%7Bi%7D%5CPhi_%7Bi%7D%7C%7C_%7BF%7D%5E%7B2%7D%3D%5Cmin%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20tr%28YS_%7Bi%7D%5CPhi_%7Bi%7D%5CPhi_%7Bi%7D%5E%7BT%7DS_%7Bi%7D%5E%7BT%7DY%5E%7BT%7D%29%5Cpar%20%3D%5Cmin%20tr%28Y%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7DS_%7Bi%7D%5CPhi_%7Bi%7D%5CPhi_%7Bi%7D%5E%7BT%7DS_%7Bi%7D%5E%7BT%7D%29Y%5E%7BT%7D%29%20%3D%5Cmin%20tr%28Y%5CPhi%20Y%5E%7BT%7D%29)
  其中，![\small \Phi =\sum_{i=1}^{n}S_{i}\Phi_{i}\Phi_{i}^{T}S_{i}^{T}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi%20%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7DS_%7Bi%7D%5CPhi_%7Bi%7D%5CPhi_%7Bi%7D%5E%7BT%7DS_%7Bi%7D%5E%7BT%7D)为全局对齐矩阵.tr表示矩阵的迹，为保证解的唯一性强加约束条件![\small YY^{T}=I](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20YY%5E%7BT%7D%3DI)和，同样与LLE类似这里也  是使用拉格朗日乘值法可得![\small \Phi Y=\lambda Y](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi%20Y%3D%5Clambda%20Y)，由于是最小化且由![\small \Phi](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5CPhi)有0特征值，所以Y是第2到第d+1小的特征值对应的特征向量  
![\small Y=(v_{2},v_{3},...,v_{d+1})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%3D%28v_%7B2%7D%2Cv_%7B3%7D%2C...%2Cv_%7Bd&plus;1%7D%29),其中![\small v_{i},i=2,3,...,d+1](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20v_%7Bi%7D%2Ci%3D2%2C3%2C...%2Cd&plus;1)为第i小的特征值对应的特征向量。
  优点：解决了LLE的权重系数奇异性问题，嵌入精确度高，抗燥性也比LLE好很多
   缺点：对高维数据点稀疏程度依赖性很高，而且对于新加入的样本数据不能有效处理，由于奇异性是由svd分解解决的，所以这也意味着当数据样本数越大，分解的矩阵和计算量就相应也就增加。
七、LE(拉普拉斯降维)
      拉普拉斯算法的直观思想与LLE有些类似，从数据的局部结构出发，希望相互间有关系的点（在图中相连的点）在降维后的空间中尽可能的靠近。Laplacian Eigenmaps可以反映出数据内在的流形结构。Laplacian Eigenmaps也通过构建权重系数矩阵构建相似关系图（对应的矩阵为W）来重构数据流形的局部结构特征。Laplacian Eigenmaps算法的主要思想是，如果两个数据实例i和j很相似，那么i和j在降维后目标子空间中应该尽量接近。
      给定![\small R^{l }](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20R%5E%7Bl%20%7D)中k个点![\small x_{1},...,x_{k}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7B1%7D%2C...%2Cx_%7Bk%7D),我们构建关于这k个点的权重图W,和顶点集合![\small G=\{1,2,..i,..k\}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20G%3D%5C%7B1%2C2%2C..i%2C..k%5C%7D),近邻点边的集合.这个特征映射就是通过计算拉普拉斯的特征向量得到的，具体算法如下：
    step1. 构建连接图,如果![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)和![\small x_{j }](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bj%20%7D)是连接的，我们给顶点i和j设定一条边，下面有两个方法：
             a ![](https://private.codecogs.com/gif.latex?)![\small \varepsilon](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarepsilon)近邻：如果![\small ||x_{i}-x_{j}||^{2}\leq\varepsilon](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%7C%7Cx_%7Bi%7D-x_%7Bj%7D%7C%7C%5E%7B2%7D%5Cleq%5Cvarepsilon)，则i和j是连接的。这里的范数是欧氏范数
                  优点：选择出来的关系是几何对称。
                  缺点： 容易导致连接的区域没被选全，出现断路，这对![\small \varepsilon](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cvarepsilon)的选择要求很高
            b k_nn：设定近邻参数k，如果顶点j在顶点i个k个最近邻域点集合中，则i和j是连接的
                  优点：简单，不会导致出现没有连接的图
                  缺点：如果数据点集合比较稀疏，容易把距离远的点也选进来，就会导致短路。
     step2. 设定权重，下面有两种方法
             a  热核权重:参数![\small t\in R](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20t%5Cin%20R) ,如果顶点i和j是连接  ![\small W_{ij}=e^{-\frac{||x_{i}-x_{j}||^{2}}{t}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bij%7D%3De%5E%7B-%5Cfrac%7B%7C%7Cx_%7Bi%7D-x_%7Bj%7D%7C%7C%5E%7B2%7D%7D%7Bt%7D%7D)  ,否则![\small W_{ij}=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bij%7D%3D0)，t的选取影响着后续拉普拉斯矩阵的计算
             b  简单设定：如果顶点i和j是连接 ![\small W_{ij}=1](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bij%7D%3D1)，否则![\small W_{ij}=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20W_%7Bij%7D%3D0) ，这个方法是无参，不需要考虑参数t的选取
     step3. 假设上述构造的图G是连接的，否则对不连接的各个局域重复step3，计算一般特征向量问题的特征值和特征向量
![\small Lf=\lambda Df \quad (7.1)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Lf%3D%5Clambda%20Df%20%5Cquad%20%287.1%29)
                这里D为对角矩阵![\small D_{ii}=\sum_{j}W_{ji}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20D_%7Bii%7D%3D%5Csum_%7Bj%7DW_%7Bji%7D),L=D-W为拉普拉斯矩阵，对称半正定且具有领特征值，也可以看做对建立在G上顶点的               函数的算子。
             令![\small f_{0},f_{1},...,f_{k-1}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20f_%7B0%7D%2Cf_%7B1%7D%2C...%2Cf_%7Bk-1%7D)为（7.1）的解，按照他们对应的特征值排序有：
![\small Lf_{0}=\lambda_{0} Df_{0}\par Lf_{1}=\lambda_{1} Df_{1}\par ....\par Lf_{k-1}=\lambda_{k-1} Df_{k-1}\par 0=\lambda_{0}\leq \lambda_{1}\leq ....\leq \lambda_{k-1}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Lf_%7B0%7D%3D%5Clambda_%7B0%7D%20Df_%7B0%7D%5Cpar%20Lf_%7B1%7D%3D%5Clambda_%7B1%7D%20Df_%7B1%7D%5Cpar%20....%5Cpar%20Lf_%7Bk-1%7D%3D%5Clambda_%7Bk-1%7D%20Df_%7Bk-1%7D%5Cpar%200%3D%5Clambda_%7B0%7D%5Cleq%20%5Clambda_%7B1%7D%5Cleq%20....%5Cleq%20%5Clambda_%7Bk-1%7D)
              我们令![\small \lambda_{0}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Clambda_%7B0%7D)为特征值0对应的特征向量，使用除了0之外的![\small m\leq k-1](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20m%5Cleq%20k-1)个最小特征值对应的特征向量嵌入到m维空间，即：
![\small x_{i}\rightarrow (f_{1}(i),f_{2}(i),...,f_{m}(i))](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D%5Crightarrow%20%28f_%7B1%7D%28i%29%2Cf_%7B2%7D%28i%29%2C...%2Cf_%7Bm%7D%28i%29%29)
     首先从计算的算法流程我们可以发现拉普拉斯算法计算的复杂度比其他算法低，计算速度也是目前为止最快的，但是效果相对一般，依赖于流形结构的前提假设，如果流形数据满足假设是均匀分布，那么LE算法可以很好保留局部几何信息。但是拉普拉斯受近邻k和热核参数t选取的影响比较大，不同参数会导致不一样的降维效果。
八、t-sne
     TSNE是由SNE衍生出的一种算法，SNE最早出现在2002年，它改变了MDS和ISOMAP中基于距离不变的思想，将高维映射到低维的同时，尽量保证相互之间的分布概率不变，SNE将高维和低维中的样本分布都看作高斯分布，而Tsne将低维中的坐标当做T分布，这样做的好处是为了让距离大的簇之间距离拉大，从而解决了拥挤问题。从SNE到TSNE之间，还有一个对称SNE，其对SNE有部分改进作用。
    首先先了解SNE的原理
    SNE是通过仿射(affinitie)变换将数据点映射到概率分布上，主要包括两个步骤：
- SNE构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。
- SNE在低维空间里在构建这些点的概率分布，使得这两个概率分布之间尽可能的相似
     SNE原理推导:
     SNE是先**将欧几里得距离转换为条件概率来表达点与点之间的相似度**。具体来说，给定一个N个高维的数据![\small x_{1},x_{2},...,x_{N}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7BN%7D),
     SNE首先计算概率![\small p_{ij}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bij%7D),正比于![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)和![\small x_{j}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bj%7D)的相似度即：
![\small p_{j|i}=\frac{exp(-||x_{i}-x_{j}||^{2}/(2\sigma_{i}^{2}))}{\sum_{k\not\equiv i} exp(-||x_{i}-x_{k}||^{2}/(2\sigma_{i}^{2}))}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bj%7Ci%7D%3D%5Cfrac%7Bexp%28-%7C%7Cx_%7Bi%7D-x_%7Bj%7D%7C%7C%5E%7B2%7D/%282%5Csigma_%7Bi%7D%5E%7B2%7D%29%29%7D%7B%5Csum_%7Bk%5Cnot%5Cequiv%20i%7D%20exp%28-%7C%7Cx_%7Bi%7D-x_%7Bk%7D%7C%7C%5E%7B2%7D/%282%5Csigma_%7Bi%7D%5E%7B2%7D%29%29%7D)
    这里的有一个参数是![\small \sigma_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma_%7Bi%7D),对于不同的![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)取值不一样，后续会讨论如何设置。此外设置![\small p_{x|x}=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bx%7Cx%7D%3D0)，因为我们关注的是两两之间的相似度。那对于低维下的![\small y_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20y_%7Bi%7D),我们可以指定高斯分布为方差![\small \frac{1}{\sqrt2}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cfrac%7B1%7D%7B%5Csqrt2%7D),因此他们之间的相似度如下：
![\small q_{j|i}=\frac{exp(-||y_{i}-y_{j}||^{2})}{\sum_{k\not\equiv i} exp(-||y_{i}-y_{k}||^{2})}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20q_%7Bj%7Ci%7D%3D%5Cfrac%7Bexp%28-%7C%7Cy_%7Bi%7D-y_%7Bj%7D%7C%7C%5E%7B2%7D%29%7D%7B%5Csum_%7Bk%5Cnot%5Cequiv%20i%7D%20exp%28-%7C%7Cy_%7Bi%7D-y_%7Bk%7D%7C%7C%5E%7B2%7D%29%7D)
同样设置![\small q_{i|i}=0](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20q_%7Bi%7Ci%7D%3D0)
如果降维的效果比较好，局部特征保留完整，那么![\small p_{i|j}=q_{i|j}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bi%7Cj%7D%3Dq_%7Bi%7Cj%7D),因此我们优化两个分布之间的距离-KLS散度，那么cost function如下：
![\small C=\sum_{i} KL(P_{i}||Q_{i})=\sum_{i}\sum_{j}p_{j|i}\log\frac{p_{j|i}}{q_{j|i}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20C%3D%5Csum_%7Bi%7D%20KL%28P_%7Bi%7D%7C%7CQ_%7Bi%7D%29%3D%5Csum_%7Bi%7D%5Csum_%7Bj%7Dp_%7Bj%7Ci%7D%5Clog%5Cfrac%7Bp_%7Bj%7Ci%7D%7D%7Bq_%7Bj%7Ci%7D%7D)
这里的![\small P_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20P_%7Bi%7D)表示给定点![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)下，其他所有数据点的条件概率分布。需要注意的是KL散步具有不对称性，在低维映射中不同的距离对应惩罚权重是不同的，具体来说：距离较远的两个点来表达距离距离较近的两个点会有比较大cost，相反用距离较近的两个点来表达距离较远的两个点cost相对比较小(类似回归容易受异常值影响，效果相反)，因此SNE倾向于保留数据的局部特征。
  首先不同的点的![\small \sigma_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma_%7Bi%7D)是不一样的，![\small P_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20P_%7Bi%7D)的熵会随着![\small \sigma_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma_%7Bi%7D)的增加而增加。SNE使用困惑度(perplexity)的概念，用二分搜索的方式来寻找一个最佳的![\small \sigma](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma)，其中困惑度指：
![\small Prep(P_{i})=2^{H(P_{i})}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Prep%28P_%7Bi%7D%29%3D2%5E%7BH%28P_%7Bi%7D%29%7D)
这里的![\small H(P_{i})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20H%28P_%7Bi%7D%29)是![\small P_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20P_%7Bi%7D)的熵，即：
![\small H(P_{i})=-\sum_{j}p_{j|i}\log_{2}p_{j|i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20H%28P_%7Bi%7D%29%3D-%5Csum_%7Bj%7Dp_%7Bj%7Ci%7D%5Clog_%7B2%7Dp_%7Bj%7Ci%7D)
其中困惑度可以解释为一个点附近有效近邻点个数。SNE对困惑度的调整比较有鲁棒性，通常选择5-50之间，给定之后，使用二分搜索寻找合适的![\small \sigma](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma)
那么目标函数就等价于![\small \sum\sum-p\log(q)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum%5Csum-p%5Clog%28q%29)这个式子与softmax非常的类似，我们知道softmax的目标函数是![\small \sum-y\log p](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csum-y%5Clog%20p),对应的梯度
y-p (注：这里的softmax中y是label，p表示预估值).同样我们可以推导SNE的目标函数中的i在j下的条件概率情况的梯度是
![\small 2(p_{i|j}-q_{i|j})(y_{i}-y_{j})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%202%28p_%7Bi%7Cj%7D-q_%7Bi%7Cj%7D%29%28y_%7Bi%7D-y_%7Bj%7D%29),同样j在i下的条件概率情况的梯度是![\small 2(p_{j|i}-q_{j|i})(y_{i}-y_{j})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%202%28p_%7Bj%7Ci%7D-q_%7Bj%7Ci%7D%29%28y_%7Bi%7D-y_%7Bj%7D%29),最后得到完整的梯度公式如下:
![\small \frac{\delta C}{\delta y_{i}}=2\sum_{j}(p_{j|i}-q_{j|i}+p_{i|j}-q_{i|j})(y_{i}-y_{j})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cfrac%7B%5Cdelta%20C%7D%7B%5Cdelta%20y_%7Bi%7D%7D%3D2%5Csum_%7Bj%7D%28p_%7Bj%7Ci%7D-q_%7Bj%7Ci%7D&plus;p_%7Bi%7Cj%7D-q_%7Bi%7Cj%7D%29%28y_%7Bi%7D-y_%7Bj%7D%29)
在初始化中,可以用较小的![\small \sigma](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Csigma)下的高斯分布来进行初始化。为了加速优化过程和避免陷入局部最优解，梯度中需要使用一个相对较大的动量。即参数更新中除了当前的梯度，还要引进之前的梯度累加的指数衰减项，如下：  
![\small Y^{(t)}=Y^{(t-1)}+\eta \frac{\delta C}{\delta y}+\alpha (t)(Y^{(t-1)}-Y^{(t-2)})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%5E%7B%28t%29%7D%3DY%5E%7B%28t-1%29%7D&plus;%5Ceta%20%5Cfrac%7B%5Cdelta%20C%7D%7B%5Cdelta%20y%7D&plus;%5Calpha%20%28t%29%28Y%5E%7B%28t-1%29%7D-Y%5E%7B%28t-2%29%7D%29)
这里的![\small Y^{(t)}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20Y%5E%7B%28t%29%7D)表示迭代的t次的解，![\small \eta](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Ceta)表示学习速率，![\small \alpha (t)](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Calpha%20%28t%29)表示迭代t次的动量。
此外，在初始优化的阶段，每次迭代中可以引入一些高斯噪声，之后像模拟退火算法一样逐渐减少该噪声，可以避免陷入局部最优解。
接下来展现t-sne对sne做的一些优化的动机和算法上改变。
 在sne的基础上重新定义概率![\small p_{ij}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bij%7D)，使得其对于离群点施加适当的惩罚值
![\small p_{ij}=\frac{p_{i|j}+p_{j|i}}{2n}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20p_%7Bij%7D%3D%5Cfrac%7Bp_%7Bi%7Cj%7D&plus;p_%7Bj%7Ci%7D%7D%7B2n%7D)
对应的的![\small q_{ij}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20q_%7Bij%7D)也有 ：                                                 ![\small q_{ij}=\frac{q_{i|j}+q_{j|i}}{2n}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20q_%7Bij%7D%3D%5Cfrac%7Bq_%7Bi%7Cj%7D&plus;q_%7Bj%7Ci%7D%7D%7B2n%7D)
其中n为数据点总数，这样定义即满足了对称性，又保证了![\small x_{i}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20x_%7Bi%7D)的惩罚值即使出现特殊情况也不会太小。此时可以用KL距离写出下面cost函数:                         
![\small C=\sum_{i} KL(P_{i}||Q_{i})=\sum_{i}\sum_{j}p_{ij}\log\frac{p_{ij}}{q_{ij}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20C%3D%5Csum_%7Bi%7D%20KL%28P_%7Bi%7D%7C%7CQ_%7Bi%7D%29%3D%5Csum_%7Bi%7D%5Csum_%7Bj%7Dp_%7Bij%7D%5Clog%5Cfrac%7Bp_%7Bij%7D%7D%7Bq_%7Bij%7D%7D)
梯度就变成：
![\small \frac{\delta C}{\delta y_{i}}=4\sum_{j}(p_{ij}-q_{ij})(y_{i}-y_{j})](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cfrac%7B%5Cdelta%20C%7D%7B%5Cdelta%20y_%7Bi%7D%7D%3D4%5Csum_%7Bj%7D%28p_%7Bij%7D-q_%7Bij%7D%29%28y_%7Bi%7D-y_%7Bj%7D%29)
对比之前定义的公式，这个梯度更加简化，计算效率也更高，但是对称SNE的效果也只是略微优于原始SNE的效果，也没有解决sne面临的crowding问题。T-SNE实际上在高维空间下使用高斯分布将距离转换为概率分布，在低维空间下，我们使用更加偏重长尾分布的方式将距离转换为概率分布也就是t分布(对比高斯分布，t分布受异常值影响更小)，使得高维度下中低等距离在映射后能够有一个较大的距离 。
使用了t分布之后的q变化如下:
![\small q_{ij}=\frac{(1+||y_{i}-y_{j}||^{2})^{-1}}{\sum_{k\neq l}(1+||y_{i}-y_{j}||^{2})^{-1}}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20q_%7Bij%7D%3D%5Cfrac%7B%281&plus;%7C%7Cy_%7Bi%7D-y_%7Bj%7D%7C%7C%5E%7B2%7D%29%5E%7B-1%7D%7D%7B%5Csum_%7Bk%5Cneq%20l%7D%281&plus;%7C%7Cy_%7Bi%7D-y_%7Bj%7D%7C%7C%5E%7B2%7D%29%5E%7B-1%7D%7D)
此外，t分布是无限个高斯分布的叠加，计算上不是指数的，会方便很多。优化的梯度如下:
![\small \frac{\delta C}{\delta y_{i}}=4\sum_{j}(p_{ij}-q_{ij})(y_{i}-y_{j})(1+||y_{i}-y_{j}||^{2})^{-1}](https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Csmall%20%5Cfrac%7B%5Cdelta%20C%7D%7B%5Cdelta%20y_%7Bi%7D%7D%3D4%5Csum_%7Bj%7D%28p_%7Bij%7D-q_%7Bij%7D%29%28y_%7Bi%7D-y_%7Bj%7D%29%281&plus;%7C%7Cy_%7Bi%7D-y_%7Bj%7D%7C%7C%5E%7B2%7D%29%5E%7B-1%7D)
![Images](https://static.dingtalk.com/media/lALPBbCc1hW3S7XNAcbNAsw_716_454.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22237050%3A483571742%22%2C%22msgId%22%3A%22223713193316%22%7D&open_id=483571742)
从上面我们可以看到横轴表示距离，纵轴概率表示相似度, 可以看到，对于较大相似度的点，t分布在低维空间中的距离需要稍小一点；而对于低相似度的点，t分布在低维空间中的距离需要更远。这恰好满足了我们的需求，即同一簇内的点(距离较近)聚合的更紧密，不同簇之间的点(距离较远)更加疏远。
总结一下，t-SNE的梯度更新有两大优势：
a:对于不相似的点，用一个较小的距离会产生较大的梯度来让这些点排斥开来。
b:这种排斥又不会无限大(梯度中分母)，避免不相似的点距离太远。
     具体算法流程如下：   
![Images](https://static.dingtalk.com/media/lALPBbCc1hW6dxTNAX_NA3g_888_383.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22237050%3A483571742%22%2C%22msgId%22%3A%22222033798308%22%7D&open_id=483571742)
需要注意的是，这个算法将低维数据作为变量进行迭代，所以如果需要加入插入新的数据，是没有办法直接对新数据进行操作，而是要把新数据加到原始数据中再重新算一遍，因此T-sne主要的功能还是可视化。此外t-sne在所有流形算法中降维效果是比较出色的同时也是计算复杂度比较大的，特别对于数据量大的数据

