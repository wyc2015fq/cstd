# 怎么写递归程序 - qq229873466的博客 - CSDN博客

2016年10月28日 18:38:35[qq229873466](https://me.csdn.net/qq229873466)阅读数：1131



总的来说，递归分为两部分，一是递归过程，即递归关系式（当前与下一次调用时的关系），二是结尾返回的条件。
**例子1：二叉树的最大深度。**

一，假设当前递归到达值为3的位置，3位置的深度等于两个子树深度的最大者加一，即由值4和5之中深度的最大者决定，因此可以写出关系式

```cpp
max(maxDepth(root->left), maxDepth(root->right)) + 1;
```

二，什么时候结尾呢，很显然当递归的当前值为nullptr时结尾，结尾的深度是0。

最后可以得到程序

```cpp
int maxDepth(TreeNode *root) {
if (!root) {
		return 0;
	}
	return max(maxDepth(root->left), maxDepth(root->right)) + 1;
 }
```

**例子2：判断是否是平衡二叉树**

一，判断当前递归位置的树是否是平衡的，由三个条件决定，即当前位置的树是否平衡，左和右子树是否平衡，因此可以写出关系式

```cpp
//当前位置平衡判断
if (abs(maxDepth(root->left) - maxDepth(root->right)) > 1) {
temp =  false;
} else {
temp = true;
}
//三个条件
temp && isBalanced(root->left) && isBalanced(root->right)
```
二，什么时候结尾呢，很显然当递归的当前值为nullptr时结尾，反回true。

最后可以得到程序

```cpp
bool isBalanced(TreeNode *root) {
        if (!root) {
		return true;
	}
	int temp = true;
	if (abs(maxDepth(root->left) - maxDepth(root->right)) > 1) {
		temp =  false;
	} else {
		temp = true;
	}
	return temp && isBalanced(root->left) && isBalanced(root->right);
}
```






