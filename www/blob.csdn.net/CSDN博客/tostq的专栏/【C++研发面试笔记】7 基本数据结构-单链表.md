# 【C++研发面试笔记】7. 基本数据结构-单链表 - tostq的专栏 - CSDN博客





2016年10月02日 19:56:54[tostq](https://me.csdn.net/tostq)阅读数：696
所属专栏：[C++研发面试笔记](https://blog.csdn.net/column/details/15031.html)









## 【C++研发面试笔记】7. 基本数据结构-单链表

### **7.1 STL中的List**

Lists将元素按顺序储存在链表中。与向量（vectors）相比, 它允许快速的插入和删除，但是随机访问却比较慢（其也可以通过[]的方式来访问，不过速度较vector慢了许多）。

#### **7.1.1 List相关成员函数**

```
/* 插入与删除 */
pop_back()  //删除最后一个元素 
pop_front() //删除第一个元素 
push_back() //在list的末尾添加一个元素 
push_front() //在list的头部添加一个元素 
insert() //插入一个元素到list中 
erase() //删除一个元素 
/* 查询  */
begin() //返回指向第一个元素的迭代器
end() //返回末尾的迭代器  
front() //返回第一个元素 
back() //返回最后一个元素 
clear() //删除所有元素 
empty() //如果list是空的则返回true 
size() //返回list中的元素个数
max_size() //返回list能容纳的最大元素数量  
/* 操作算法  */
sort() //给list排序 
merge() //合并两个list
reverse() //把list的元素倒转
splice() //合并两个list 
swap() //交换两个list 
unique() //删除list中重复的元素
/* 其他  */
get_allocator() //返回list的配置器 
assign() //给list赋值 
rbegin() //返回指向第一个元素的逆向迭代器 
remove() //从list删除元素 
remove_if() //按指定条件删除元素 
rend() //指向list末尾的逆向迭代器 
resize() //改变list的大小
```

#### **7.1.2 emplace_back()的意义**

**emplace_back()与push_back()的区别**

emplace_back()在vector的结尾插入一个新的元素，位置为当前最后一个元素的右边，元素的值使用args作为参数传递给其构造函数构造。 

而一个相似的方法是push_back，一样是通过拷贝或者移动一个已经存在（这也是两者最大的区别，push_back的参数对象必须是已经存在的对象）的对象到容器。
### **7.2 自定义单链表操作**

#### **7.2.1 结构**

![这里写图片描述](https://img-blog.csdn.net/20161002195301592)

#### **7.2.2 删除元素**

head链表头指针，p被删除元素位置 
![这里写图片描述](https://img-blog.csdn.net/20161002195403827)
#### **7.2.3 插入元素**

head链表头指针，p新元素插入位置，x新元素中的数据域内容。 
![这里写图片描述](https://img-blog.csdn.net/20161002195414776)
#### **7.2.4 创建链表**

输入：各节点的data，返回值：指针head 
![这里写图片描述](https://img-blog.csdn.net/20161002195427370)
#### **7.2.5 链表倒置**

![这里写图片描述](https://img-blog.csdn.net/20161002195440796)

> 
这篇博文是个人的学习笔记，内容许多来源于网络（包括CSDN、博客园及百度百科等），博主主要做了微不足道的整理工作。由于在做笔记的时候没有注明来源，所以如果有作者看到上述文字中有自己的原创内容，请私信本人修改或注明来源，非常感谢>_<








