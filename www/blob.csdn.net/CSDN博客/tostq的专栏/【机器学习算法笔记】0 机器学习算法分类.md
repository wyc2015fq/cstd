# 【机器学习算法笔记】0. 机器学习算法分类 - tostq的专栏 - CSDN博客





2017年03月28日 18:42:20[tostq](https://me.csdn.net/tostq)阅读数：1685
所属专栏：[机器学习算法笔记](https://blog.csdn.net/column/details/15045.html)









# 【机器学习算法笔记】0. 机器学习算法分类

## 0.1 凸优化问题

凸优化是指一种比较特殊的优化，是指求取最小值的目标函数为凸函数的一类优化问题。其中，目标函数为凸函数且定义域为凸集的优化问题称为无约束凸优化问题。而目标函数和不等式约束函数均为凸函数，且定义域为凸集的优化问题为约束优化问题。 

凸优化问题的特性：
- 1、凸问题的局部最优解就是全局最优解。
- 2、许多非凸问题通过一定的手段可以化归为凸问题。
- 3、凸优化理论中最重要的工具是Lagrange拉格朗日对偶。
- 4、我们没有找到很好的非凸优化的算法。

## 0.2 根据学习方式分类

1、**监督学习：**输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。如神经网络、线性回归等 

2、在**非监督式学习**中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括了许多聚类算法。 

3、**半监督学习**方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法或者拉普拉斯支持向量机等。 

4、**强化学习**模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。学习系统提供行动，并且从环境对该行动的反应评价中学习，实际上，是将监督学习中教师的角色在这里用反应评价来代替了。强化学习是目前深度学习领域的热点问题。
## 0.3 聚类问题

传统的聚类分析计算方法主要有如下几种：

### 0.3.1 划分方法

给定一个有N个元组或者纪录的数据集，分裂法将构造K个分组，每一个分组就代表一个聚类，K小于N。对于给定的K，算法首先给出一个初始的分组方法，以后通过反复迭代的方法改变分组，使得每一次改进之后的分组方案都较前一次好，而所谓好的标准就是：同一分组中的记录越近越好，而不同分组中的纪录越远越好。使用这个基本思想的算法有：K-MEANS算法、K-MEDOIDS算法、CLARANS算法； 

为了达到全局最优，基于划分的聚类可能需要穷举所有可能的划分，计算量极大。实际上，大多数应用都采用了流行的启发式方法，如k-均值和k-中心算法，渐近的提高聚类质量，逼近局部最优解。  
**1. K-means算法**

k-means 算法接受输入量 k，然后将n个数据对象划分为 k个聚类以便使得所获得的聚类满足：同一聚类中的对象相似度较高；而不同聚类中的对象相似度较小。聚类相似度是利用各聚类中对象的均值所获得一个“中心对象”（引力中心）来进行计算的。k个聚类具有以下特点：各聚类本身尽可能的紧凑，而各聚类之间尽可能的分开。 
**2. K- medoids算法**

K-MEANS有其缺点：产生类的大小相差不会很大，对于脏数据很敏感。 

改进的算法：K-medoids方法。K-medoids和K-means不一样的地方在于中心点的选取，在K-means中，我们将中心点取为当前cluster中所有数据点的平均值，在 K-medoids算法中，我们将从当前cluster 中选取这样一个点：它到其他所有（当前cluster中的）点的距离之和最小作为中心点。  

这种算法对于脏数据和异常数据不敏感，但计算量显然要比K均值要大，一般只适合小数据量。 
**3. Clara算法**

上面提到K-medoids算法不适合于大数据量的计算。Clara算法，这是一种基于采样的方法，它能够处理大量的数据。 

Clara算法的思想就是用实际数据的抽样来代替整个数据，然后再在这些抽样的数据上利用K-medoids算法得到最佳的medoids。Clara算法从实际数据中抽取多个采样，在每个采样上都用K-medoids算法得到相应的中心，然后在这当中选取E最小的一个作为最终的结果。 
**4. Clarans算法**

Clara算法的效率取决于采样的大小，一般不太可能得到最佳的结果。 

在Clara算法的基础上，又提出了Clarans的算法，与Clara算法不同的是：在Clara算法寻找最佳的medoids的过程中，采样都是不变的。而Clarans算法在每一次循环的过程中所采用的采样都是不一样的。 
**5. 确定初始类中心**

    1、最简单的确定初始类簇中心点的方法是随机选择K个点作为初始的类簇中心点，但是该方法在有些情况下的效果较差。 

2、选择彼此距离尽可能远的K个点：首先随机选择一个点作为第一个初始类簇中心点，然后选择距离该点最远的那个点作为第二个初始类簇中心点，然后再选择距离前两个点的最近距离最大的点作为第三个初始类簇的中心点，以此类推，直至选出K个初始类簇中心点。 

3、先对数据用层次聚类算法或者Canopy算法进行聚类，得到K个簇之后，从每个类簇中选择一个点，该点可以是该类簇的中心点，或者是距离类簇中心点最近的那个点。
> 
Canopy算法：首先定义两个距离T1和T2，T1>T2。从初始的点的集合S中随机移除一个点P，然后对于还在S中的每个点I，计算该点I与点P的距离，如果距离小于T1，则将点I加入到点P所代表的Canopy中，如果距离小于T2，则将点I从集合S中移除，并将点I加入到点P所代表的Canopy中。迭代完一次之后，重新从集合S中随机选择一个点作为新的点P，然后重复执行以上步骤。 

  Canopy算法执行完毕后会得到很多Canopy，可以认为每个Canopy都是一个Cluster，与KMeans等硬划分算法不同，Canopy的聚类结果中每个点有可能属于多个Canopy。我们可以选择距离每个Canopy的中心点最近的那个数据点，或者直接选择每个Canopy的中心点作为KMeans的初始K个类簇中心点。


**6. K值的确定**

给定一个合适的类簇指标，比如平均半径或直径，只要我们假设的类簇的数目等于或者高于真实的类簇的数目时，该指标上升会很缓慢，而一旦试图得到少于真实数目的类簇时，该指标会急剧上升。类簇的直径是指类簇内任意两点之间的最大距离。类簇的半径是指类簇内所有点到类簇中心距离的最大值。

### 0.3.2 层次方法

这种方法对给定的数据集进行层次似的分解，直到某种条件满足为止。具体又可分为“自底向上”和“自顶向下”两种方案。在“自底向上”方案中，初始时每一个数据纪录都组成一个单独的组，在接下来的迭代中，它把那些相互邻近的组合并成一个组，直到所有的记录组成一个分组或者某个条件满足为止。代表算法有：BIRCH算法、CURE算法、CHAMELEON算法等。 

层次聚类方法可以是基于距离的或基于密度或连通性的。层次聚类方法的一些扩展也考虑了子空间聚类。层次方法的缺陷在于，一旦一个步骤（合并或分裂）完成，它就不能被撤销。这个严格规定是有用的，因为不用担心不同选择的组合数目，它将产生较小的计算开销。然而这种技术不能更正错误的决定。 

### 0.3.3 基于密度的方法

基于密度的方法与其它方法的一个根本区别是：它不是基于各种各样的距离的，而是基于密度的。这样就能克服基于距离的算法只能发现“类圆形”的聚类的缺点。这个方法的指导思想就是，只要一个区域中的点的密度大过某个阀值，就把它加到与之相近的聚类中去。代表算法有：DBSCAN算法、OPTICS算法、DENCLUE算法等。

### 0.3.4 基于网格的方法

这种方法首先将数据空间划分成为有限个单元（cell）的网格结构，所有的处理都是以单个的单元为对象的。这么处理的一个突出的优点就是处理速度很快，通常这是与目标数据库中记录的个数无关的，它只与把数据空间分为多少个单元有关。代表算法有：STING算法、CLIQUE算法、WAVE-CLUSTER算法；

### 0.3.5 基于模型的方法

基于模型的方法给每一个聚类假定一个模型，然后去寻找能够很好的满足这个模型的数据集。这样一个模型可能是数据点在空间中的密度分布函数或者其它。它的一个潜在的假定就是：目标数据集是由一系列的概率分布所决定的。通常有两种尝试方向：统计的方案和神经网络的方案。

### 0.3.6 高维聚类问题

传统聚类方法在高维数据集中进行聚类时，主要遇到两个问题。
- ①高维数据集中存在大量无关的属性使得在所有维中存在簇的可能性几乎为零；
- ②高维空间中数据较低维空间中数据分布要稀疏，其中数据间距离几乎相等是普遍现象，而传统聚类方法是基于距离进行聚类的，因此在高维空间中无法基于距离来构建簇。

### 0.3.7 模糊聚类（软聚类）

聚类问题的研究不仅仅局限于上述的硬聚类，即每一个数据只能被归为一类，模糊聚类也是聚类分析中研究较为广泛的一个分支。模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。目前已有很多关于模糊聚类的算法被提出，如著名的FCM算法等。 

FCM算法是一种以隶属度来确定每个数据点属于某个聚类程度的算法。该聚类算法是传统硬聚类算法的一种改进。 
![这里写图片描述](https://img-blog.csdn.net/20170328180655663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9zdHE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

算法流程：- 1、标准化数据矩阵；
- 2、建立模糊相似矩阵，初始化隶属矩阵；
- 3、算法开始迭代，直到目标函数收敛到极小值；
- 4、根据迭代结果，由最后的隶属矩阵确定数据所属的类，显示最后的聚类结果。

## 0.4   分类问题

### 0.4.1 判别式模型与产生式模型

有监督机器学习方法可以分为生成方法和判别方法。对于监督学习，预测时，一般都是在求P(Y|X)。但生成模型是从数据中学习联合概率分布P(X,Y)，然后利用贝叶斯公式求条件分布，而判别模型：直接学习P(Y|X)，它直观输入什么特征X，就直接预测出最可能的Y。 
**1. 生成模型特点**

生成方法可以还原联合概率分布P(X,Y)，而判别方法则不能；生成方法的学习收敛速度更快，即当样本容量增加的时候，学习的模型可以更快的收敛于真实的模型；当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。 

天下没有免费午餐，联合分布是能提供更多的信息，但也需要更多的样本和更多计算，尤其是为了更准确估计类别条件分布，需要增加样本的数目，而且类别条件概率的许多信息是我们做分类用不到，因而如果我们只需要做分类任务，就浪费了计算资源。在实践中多数情况下判别模型效果更好。 

典型的生成模型有：朴素贝叶斯分类器（NB）、混合多项式分布、混合高斯模型、隐马尔可夫模型（HMM）、马尔可夫的随机场（MRF）等。
**2. 判别模型特点**

判别方法直接学习的是条件概率P(Y|X)或者决策函数f(X)，直接面对预测，往往学习的准确率更高；由于直接学习P(Y|X)或者f(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。 

常见的判别模型有：支持向量机SVM、传统的神经网络、线性判别分析LDA、线性回归（LR）、条件随机场CRF等
**3. 两种模型的判断**

后验正比于先验乘以似然。先验是输入的分布，似然是参数的分布。如果我们先建模先验和似然，然后根据贝叶斯定理得到后验，并做决策，这种模型叫生成模型。 

如果不管先验和似然，直接假设后验的分布所满足的形式（例如逻辑回归），这样学习到后验分布的方式就是判别模型所采用的。因为不涉及到乘法，并且生成模型要建模两个分布，而判别模型只用建模一个，判别模型的学习会更加有效率。 

生成模型当然也有好处，比如异常点检测之类的。简单来说，生成模型是需要先知道先验分布（或者估计参数得到），然后习惯用贝叶斯定理去做预测；判别式是不需要知道原始数据概率密度，只用求出不同类别之间的不同之处，“判定”这这里指的就是当出现新的样本时，该模型能够通过边界判定属于哪个类。
### 0.4.2 线性分类器

线性分类器有三大类分类准则函数：感知器准则函数、SVM、Fisher准则。 
**感知器准则函数：**代价函数J=-(W*X+w0)，分类的准则是最小化代价函数。 
**SVM：**优化目标是最大化间隔，又称最大间隔分类器，是一种典型的线性分类器。（使用核函数可解决非线性问题） 
**Fisher准则：**更广泛的称呼是线性判别分析（LDA），将所有样本投影到一条远点出发的直线，使得同类样本距离尽可能小，不同类样本距离尽可能大。
### 0.4.3 基于统计的方法

**1、贝叶斯分类器NB**

一种基于统计方法的分类器，要求先了解样本的分布特点（高斯、指数等），所以使用起来限制很多。在满足一些特定条件下，其优化目标与线性分类器有相同结构（同方差高斯分布等），其余条件下不是线性分类。
- 1、先验概率的估计 

在贝叶斯决策中，对于先验概率p(y)，分为已知和未知两种情况。 
- p(y)已知，直接使用贝叶斯公式求后验概率即可；
- p(y)未知，可以使用聂曼-皮尔逊决策(N-P决策)来计算决策面。
- 2、贝叶斯分类准则 
- A. 最小风险准则：直接考虑p(wi)变化的条件下，不需要用到先验知识。
- B. 最小误判概率准则：就是判断p(w1|x)和p(w2|x)哪个大，需要用到先验知识
- C. 最小损失准则：在B的基础之上，还要求出p(w1|x)和p(w2|x)的期望损失
- D. N-P判决，即限定一类错误率条件下使另一类错误率为最小的两类别决策，即在一类错误率固定的条件下，求另一类错误率的极小值的问题，直接计算p(x|w1)和p(x|w2)的比值，不需要用到贝叶斯公式
- E. 最大最小损失规则：用于解决最小损失规则时先验概率未知或难以计算的问题的。
- F. 最小错误率等价最大后验概率，0-1风险等价最小错误率，都是需要先验知识的。


**2. 条件随机场CRF**

条件随机场(CRF)结合了最大熵模型和隐马尔可夫模型的特点，是一种无向图模型和典型的判别式模型，其联合概率可以写成若干势函数联乘的形式，其中最常用的是线性链条件随机场。若让X=(x1，x2，…xn)表示被观察的输入数据序列，Y=(y1，y2，…yn)表示一个状态序列，在给定一个输入序列的情况下，线性链的CRF模型定义状态序列的联合条件概率为： 
![这里写图片描述](https://img-blog.csdn.net/20170328181122154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9zdHE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

其中：Z是以观察序列x为条件的概率归一化因子；f是一个任意的特征函数；w是每个特征函数的权值。
**3. 隐马尔可夫模型HMM**

隐马尔可夫模型HMM是产生式模型，隐马尔可夫模型是马尔可夫链的一种，它的状态不能直接观察到，但能通过观测向量序列观察到，每个观测向量都是通过某些概率密度分布表现为各种状态，每一个观测向量是由一个具有相应概率密度分布的状态序列产生： 
![这里写图片描述](https://img-blog.csdn.net/20170328181141122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9zdHE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

这里HMM有严格的独立性假设条件，因而不能像CRF可以容纳任意的上下文信息。 

同时，由于CRF计算全局最优输出节点的条件概率，它还克服了最大熵马尔可夫模型标记偏置的缺点。CRF是在给定需要标记的观察序列的条件下，计算整个标记序列的联合概率分布，而不是在给定当前状态条件下，定义下一个状态的状态分布。
**4. 最大熵马尔可夫模型MEMM**

最大熵准则建模条件概率建模的MM，这点是类似于CRF模型的。可以看做是HMM与log-linear model（指的是exp(wf)）结合的一种方式。 
![这里写图片描述](https://img-blog.csdn.net/20170328181158403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9zdHE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**5. 基于统计分类方法比较**
![这里写图片描述](https://img-blog.csdn.net/20170328181216139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9zdHE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
### 0.4.4 划分分类方法

**1. 最近邻近分类KNN**

邻近算法，或者说K最近邻近分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。 

KNN算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 KNN方法在类别决策时，只与极少量的相邻样本有关。 

由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。
**2. 决策树**

它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分。它的缺点之一就是不支持在线学习，于是在新样本到来后，决策树需要全部重建。另一个缺点就是容易出现过拟合，但这也就是诸如随机森林RF（或提升树boosted tree）之类的集成方法的切入点。另外，随机森林经常是很多分类问题的赢家（通常比支持向量机好上那么一丁点），它训练快速并且可调，同时你无须担心要像支持向量机那样调一大堆参数，所以在以前都一直很受欢迎。

**3. Boosting**

### 0.4.5 神经网络方法

### 0.4.6 各种分类方法比较

如果你的训练集很小，高偏差/低方差的分类器（如朴素贝叶斯）比低偏差/高方差的分类器（如K近邻或Logistic回归）更有优势，因为后者容易过拟合。但是随着训练集的增大，高偏差的分类器并不能训练出非常准确的模型，所以低偏差/高方差的分类器会胜出（它们有更小的渐近误差）。 
**1. 朴素贝叶斯NB**

超级简单，就像做一些数数的工作。如果条件独立假设成立的话，NB将比鉴别模型（如Logistic回归）收敛的更快，所以你只需要少量的训练数据。即使条件独立假设不成立，NB在实际中仍然表现出惊人的好。如果你想做类似半监督学习，或者是既要模型简单又要性能好，NB值得尝试。
**2. Logistic回归(LR)**

LR有很多方法来对模型正则化。比起NB的条件独立性假设，LR不需要考虑样本是否是相关的。与决策树与支持向量机（SVM）不同，NB有很好的概率解释，且很容易利用新的训练数据来更新模型（使用在线梯度下降法）。如果你想要一些概率信息（如为了更容易的调整分类阈值，得到分类的不确定性，得到置信区间），或者希望将来有更多数据时能方便的更新改进模型，LR是值得使用的。

**3. 决策树（Decision Tree）**

DT容易理解与解释。DT是非参数的，所以你不需要担心野点（或离群点）和数据是否线性可分的问题。DT的主要缺点是容易过拟合，这也正是随机森林（Random Forest, RF）（或者Boosted树）等集成学习算法被提出来的原因。此外，RF在很多分类问题中经常表现得最好（我个人相信一般比SVM稍好），且速度快可扩展，也不像SVM那样需要调整大量的参数，所以最近RF是一个非常流行的算法。

**4. 支持向量机（SVM）**

很高的分类正确率，对过拟合有很好的理论保证，选取合适的核函数，面对特征线性不可分的问题也可以表现得很好。SVM在维数通常很高的文本分类中非常的流行。由于较大的内存需求和繁琐的调参，我认为RF已经开始威胁其地位了。 

从目标函数来看，区别在于逻辑回归采用的是logistical loss，svm采用的是hinge loss。这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。SVM的处理方法是只考虑support vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重。两者的根本目的都是一样的。
### 0.4.7 非参数方法与参数方法

略（常见的都是参数方法，非参数方法主要是通过数据分布来进行采样来完成的，贝叶斯非参数估计是一类重要方法，详见以后的章节）

### 0.4.8 分类准确率衡量

1. 偏差&方差

在统计学中，一个模型好坏，是根据偏差和方差来衡量的，模型的真实误差是两者之和。 

偏差：描述的是预测值（估计值）的期望E’与真实值Y之间的差距。偏差越大，越偏离真实数据。 

方差：描述的是预测值P的变化范围，离散程度，是预测值的方差，也就是离其期望值E的距离。方差越大，数据的分布越分散。 

模型的预测错误率，是有两部分组成的，一部分是由于模型太简单而带来的估计不准确的部分（Bias），另一部分是由于模型太复杂而带来的更大的变化空间和不确定性（Variance）。 

朴素贝叶斯简单假设了各个数据之间是无关的，是一个被严重简化了的模型。所以会让Bias部分大于Variance部分，也就是说高偏差而低方差。在实际中，为了让错误率尽量小，我们在选择模型的时候需要平衡Bias和Variance所占的比例，也就是平衡over-fitting和under-fitting。 
2. 分类评价指标

对于二类分类问题常用的评价指标是精准度（precision）与召回率（recall）。分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作： 

TP——将正确预测为正确 

FN——将正确预测为错误 

FP——将错误预测为正确 

TN——将错误预测为错误 

由此： 

精准率定义为：``P = TP / (TP + FP)

召回率定义为：``R = TP / (TP + FN)

可以发现随着精准率增高，召回率会下降，所以很多研究都将精准率和召回率在同一坐标系中画出的曲线所包括面积来衡量整体准确度，称之为平均精度（Average precision），而VOC等图像分类检测中的mAP（mean Average Precision）就是指多个类别的平均精度的平均。0.4.9 损失函数分类

Gold Standard误差，理想情况下的，用得比较少 

Hinger误差，常用于SVM等方法 

Log误差，即交叉熵误差，常用于logistic 回归 

均方误差，比较常见，比如线性回归 

Exponential 误差，又被称为0-1 loss， 记录分类错误的次数常用于Boosting等分类器算法0.4.10 范数与正则化

规则化函数Ω(w)就是添加在损失函数式中，用于防止模型过分拟合。正则化式子在保证模型简单上，最小化训练误差，提升模型泛化性能，也相当于将先验知识引入模型，强行地让模型具有人想要的特性，例如稀疏、低秩、平滑等等。正则化式子还可视为是结构风险最小化策略的实现。 

L0范数是指向量中非0的元素的个数。如果我们用L0范数来规则化一个参数矩阵W的话，就是希望W的大部分元素都是0。 

L1范数是指向量中各个元素绝对值之和，也有个美称叫“稀疏规则算子”。稀疏模型比较符合自然解释，比如大脑的神经元都是稀疏连接的。 

L2范数是向量中各个元素平方和，相较于L1范数一方面更能防止过拟合（向量元素更小），另一方面比较好求导，在反向传播时更好计算。


















