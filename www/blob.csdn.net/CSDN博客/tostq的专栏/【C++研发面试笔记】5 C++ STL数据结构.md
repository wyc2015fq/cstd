# 【C++研发面试笔记】5. C++ STL数据结构 - tostq的专栏 - CSDN博客





2016年10月02日 18:12:46[tostq](https://me.csdn.net/tostq)阅读数：3117
所属专栏：[C++研发面试笔记](https://blog.csdn.net/column/details/15031.html)









## 【C++研发面试笔记】5. C++ STL数据结构（容器）

### **5.1 常见数据结构（容器）分类**
- **vector：**（连续的空间存储，可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间的插入，删除元素要慢，而且如果一开始分配的空间不够的话，可能重新分配更大空间，拷贝的性能开销较高。
- **deque：**（小片的连续，小片间用链表相连，实际上内部有一个map的指针，因为知道类型，所以还是可以使用[]，只是速度没有vector快）快速的访问随机的元素，快速的在开始和末尾插入元素，但随机的插入，删除元素要慢，空间的重新分配要比vector快，重新分配空间后，原有的元素不需要拷贝。对deque的排序操作，可将deque先复制到vector，排序后在复制回deque。
- **list：**（每个元素间用链表相连）访问随机元素不如vector快，随机的插入元素比vector快，对每个元素分配空间，所以不存在空间不够，重新分配的情况。
- **set：**内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找也比较快的哦。 
- **map：**一对一的映射的结合，key不能重复。  
- **stack：**栈，必须结合其他的容器使用，stl中默认的内部容器是deque。先进后出，只有一个出口，不允许遍历。  
- **queue：**是受限制的deque，内部容器一般使用list较简单。先进先出，不允许遍历。   
- **unordered_set、unordered_map：**散列表，Hash表。快速查找，快速插入，但不能随机访问，另外空间消耗大（这里依赖于散列函数）。
- **priority_queue：**优先队列，用于实现最大堆（默认），最小堆。最终在队列里总是top出最大的元素。

### **5.2 选择容器准则**
- 如果我们需要随机访问一个容器，则vector要比list好得多 。  
- 如果我们已知要存储元素的个数，则vector 又是一个比list好的选择。  
- 如果我们需要的在容器中间插入和删除元素，则list显然要比vector好。  
- 如果只在容易的首部和尾部插入数据元素，则选择deque。  
- 如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个List容器，接着对此容器重新拍序，使其适合顺序访问，然后将排序后的list容器复制到一个vector容器中。  
- 快速查找O(1)则需要利用unordered散列表。

### **5.3 容器析构问题**

C++中STL的vector容器的析构函数不用自己调用，系统会进行析构，但是vector内元素的清空（指针vector）需要手动进行。 

1、非指针的数据类型，比如 int、string、char ，还包括自定义的数据结构、自定义的类 等等只需要手动调用vector的clear函数就可以了，空间的释放和析构系统都会自动进行。 

2、指针类型的数据，这种情况需要手动进行释放。也就是说new 产生的内存需要手动使用free进行释放。
> 
这篇博文是个人的学习笔记，内容许多来源于网络（包括CSDN、博客园及百度百科等），博主主要做了微不足道的整理工作。由于在做笔记的时候没有注明来源，所以如果有作者看到上述文字中有自己的原创内容，请私信本人修改或注明来源，非常感谢>_<





