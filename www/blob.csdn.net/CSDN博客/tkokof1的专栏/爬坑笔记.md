# 爬坑笔记 - tkokof1的专栏 - CSDN博客

2016年04月15日 22:09:30[tkokof1](https://me.csdn.net/tkokof1)阅读数：413


**引子**

  游戏开发过程中遇坑在所难免，没遇到的话基本上也是因为爬的不够远不够深罢了，近日自己便遇到一坑，虽小但又觉的挺微妙（subtle），在此一记~

**问题**

  按钮点击事件的重复触发问题：项目目前使用[NGUI](http://www.tasharen.com/?page_id=140)，逻辑中创建了一个按钮B1，并绑定了点击委托D1，D1中的处理逻辑则是销毁按钮B1并创建一个新的按钮B2，并绑定新按钮的点击委托为D2

  伪代码表示一下大概是这个样子：


```
// here B1 is UIButton
 B1.onClick.Add(new EventDelegate(D1));
            
 // B1 button click delegate
 void D1()
 {
     DestroyButton(B1);
     var B2 = CreateButton();
     B2.onClick.Add(new EventDelegate(D2));
 }
            
 // B2 button click delegate
 void D2()
 {
     // some logic here
 }
```

  一开始朴素的实现方式下，世界很平静，一切很正常，点击B1触发了D1：销毁B1并新创建了B2，后来尝试优化了一把，思路还是借鉴[对象池](https://unity3d.com/cn/learn/tutorials/modules/beginner/live-training-archive/object-pooling)：既然B1和B2都是按钮，那就不必执行销毁再创建的流程，直接复用B1即可，只是需要改变一下B1的点击委托，伪代码大概是这个样子：


```
// here B1 is UIButton
  B1.onClick.Add(new EventDelegate(D1));
			
  // B1 button click delegate
  void D1()
  {
      B1.onClick.Clear();
      B1.onClick.Add(new EventDelegate(D2));
  }
			
  // B2 button click delegate
  void D2()
  {
      // some logic here
  }
```

  想法挺美好，但是事实往往很残酷，如此修改之后，点击B1的确触发了D1，但是同时也触发了D2，WTF？

  尝试跟踪了一下执行流程，定位了原因：

![](https://img-blog.csdn.net/20160415220318763)


  以上便是NGUI处理回调委托的大致代码，我们之前注册的D1会在红框标示部分执行，这里我们执行了回调委托的重置（将D1删除，并添加了D2），进而导致执行了黑框部分的代码，于是D2“莫名其妙”的被触发了……

  说来这个问题其实跟列表元素的删除类似，有兴趣的朋友可以看看之前的[一篇](http://blog.csdn.net/tkokof1/article/details/23197215)~

  就这样了~

