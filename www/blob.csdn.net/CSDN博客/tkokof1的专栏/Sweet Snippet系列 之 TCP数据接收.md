# Sweet Snippet系列 之 TCP数据接收 - tkokof1的专栏 - CSDN博客

2014年07月10日 12:57:31[tkokof1](https://me.csdn.net/tkokof1)阅读数：857标签：[网络编程																[tcp](https://so.csdn.net/so/search/s.do?q=tcp&t=blog)](https://so.csdn.net/so/search/s.do?q=网络编程&t=blog)
个人分类：[随性																[算法](https://blog.csdn.net/tkokof1/article/category/642709)](https://blog.csdn.net/tkokof1/article/category/642708)


Sweet Snippet系列 之 TCP数据接收

一．引子

  虽说仍然是Sweet Snippet，不过本篇并没有代码，纯粹是自己觉得有点趣味，就索性一记了~

二. 问题

  接触过网络编程的朋友大概都应知道TCP，作为一种“流”式协议，TCP的粘包问题一直都是程序处理的要点，而这次的问题就是，如果发送n字节的TCP数据，对端接收时会出现多少种接收情况？

三. 解法

  我们先从具体的一个实例来简单算一算吧~就假设我们发送了3个字节的TCP数据：

![](https://img-blog.csdn.net/20140710124906796)



  由于TCP如果接收成功至少可以接收一个字节，所以对于3个字节的数据而言，最多可能造成总计三次TCP接收，让我们分情况讨论一下：

  对于只发生一次TCP接收就获取全部数据的情况，只有1种可能（分隔线代表一次接收）：

![](https://img-blog.csdn.net/20140710125156751)


对于发生两次TCP接收，有2种可能：

![](https://img-blog.csdn.net/20140710124919531)

![](https://img-blog.csdn.net/20140710125205970)


  对于发生三次TCP接收，显而易见，只有1种可能：

![](https://img-blog.csdn.net/20140710125210494)

所以总的接收情况次数为：C(3) = 1 + 2 + 1 = 4

对于n个字节的一般情况，分情况讨论的方法就有些费心费力了，换个思路，以添加分隔线的角度来考虑这个问题，对于任意相邻两个字节之间，我们都可以添加或者不添加分隔线来表示是否在这两个字节间额外发生了一次TCP接收，图示大概就是这个样子（虚线表示可以添加或者不添加的分隔线）：

![](https://img-blog.csdn.net/20140710124932656)

  对于n个字节而言，总计有n-1个间隔可以添加或者不添加分隔线，所以总的可能情况为：

** C(n) = 2^(n-1)**

  对于前面讲述的3字节情况，运用上面的公式，得到C(3) = 2^(3-1) = 4，哈，结果正确~

  至于实践中的一些诸如TCP接收缓冲区大小限制会影响接收可能情况之类的问题，在此就不讨论了，这里就是简单并理想化的计算一下可能的接收情况，就这样了~


