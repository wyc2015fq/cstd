# 指针、引用和常量的一些“故事” - tkokof1的专栏 - CSDN博客

2012年11月20日 17:42:30[tkokof1](https://me.csdn.net/tkokof1)阅读数：1058


  C++也算是学了有些年头，可惜还是不甚了解，这不，今天对于指针、引用和常量这三个在C++中处处可见的东西又有些懵里懵懂了，也罢，今天就稍稍学究一下，再尽力整理一番其中的一些“故事”吧，一则帮助自己记忆，二则也许还能帮助帮助遇到类似问题的朋友 ：）

  1. 常量指针：常量“的”指针，指向常量的指针，所指内容是不能更改的（read-only），但指针本身是可以修改的 

  示例：const Object* objPtr、const int *iPtr

  2. 指针常量：指针“的”常量，即本身为常量的指针，所指向内容是可以修改的，但指针本身是不可以修改的

  示例：Object* const objPtr、int * const iPtr

  3. 常量指针常量（好拗口~~~不知叫这名字是否确切）：上述两者的结合，性质就是两者相加了

  示例：const Object* const objPtr

  4. 引用本身即带有常量语义（类似int& const 的代码表述会引起编译错误），即你无法改变一个已经赋值的引用本身，类似的赋值操作所改变的仅是引用所引用（指向）的数据，并不改变引用本身，所以引用非常类似指针常量，两者之间只有些微区别（譬如引用不能赋空，但指针常量可以）

  示例：

  int value = 13；

  int& valueRef = value；

  valueRef = 17；// 这里你改变的只是value，valueRef仍然保持对value的引用

  5. 常量引用，常量“的”引用，指引用所引用（指向）的内容为常量

  示例：const Object& object

  6. 对于一般数据类型（基本类型和自定义类型）而言，const的位置并不影响其的常量语义，例如const int 和 int const 都表示该int数据为常量，没有区别。

  7. 对于常量类型的结构类型而言，其内部成员都带有常量语义，即int会变为int const（或者可以认为为const int），但是指针类型的内部成员则只能认为为Object* const，而并不是const Object* 类型，两者区别如前所叙述，另外，内部引用类型成员语义不会改变。

  8. 对于本身带有常量语义的成员变量，结构类型的常量化并不会影响其原先的常量语义。

  好了，暂时就这些了，不过鉴于本人水平有限，有啥纰漏之处请不吝指出，万分感谢 ：）

  OK，那么现在就让我们将下面这个不知所云的程序代码修改修改，让其编译通过吧 ：）

```cpp
#include <iostream>

using namespace std;

class Object
{
public:
    int getValue() const { return 1; }
    void setValue() {};
};

struct ObjectDataWrapper
{
    Object* objectPtr;
    Object object;
    Object& objectRef;
};

void HandleData(const ObjectDataWrapper& dataWrapper)
{
    dataWrapper.objectPtr->setValue();
    dataWrapper.objectPtr = NULL;
    dataWrapper.object->setValue();
    dataWrapper.objectRef.setValue();
    dataWrapper.objectRef = Object();
}

void HandleData(const Object* objPtr)
{
    objPtr->setValue();
    objPtr = NULL;
}

void HandleData(Object* const objPtr)
{
    objPtr->setValue();
    objPtr = NULL;
}

void HandleData(const Object& object)
{
    object.setValue();
}

void HandleData(const int data)
{
    data = 1;
}

int main()
{
    std::cout << "Compiled finally ..." << std::endl;
    return 0;
}
```

PS：呵呵，我承认注释也确实是个让上述代码通过编译的好办法~~~

