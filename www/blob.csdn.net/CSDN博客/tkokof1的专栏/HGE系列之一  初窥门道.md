# HGE系列之一    初窥门道 - tkokof1的专栏 - CSDN博客

2009年11月24日 10:33:00[tkokof1](https://me.csdn.net/tkokof1)阅读数：4573



**HGE****系列之一**初窥门道

对于游戏开发有些兴趣的朋友，尤其是那些至今都扔不下2D、如我这般的志士同仁，想必对于HGE都有所耳闻，但如果要论及深入了解与运用，那恐怕就寥寥无几人了，而对于那些压根就未有听说过HGE名号的人士，就更无论什么知晓或是精通了。而我，一个对游戏编程颇有兴致的平庸之辈，恰好在某次网上混迹期间了解到了HGE这个名词，接着也顺势了解了一些有关HGE的零星知识，遂感觉有些话儿想拿出来分享分享，正好网上有关HGE的信息比较缺失( 不信可以Google一下**:)** )，在此我也顺便尽尽薄力，稍稍补缀一下这个缺口，同时也助长一番自己对于HGE的认识，想来真是幸甚至哉啊**:)**

好了好了，打住我这番无聊说辞，让我们马上进入正题，首先的首先呢，我想你可能仍然迷惑：**这****HGE****到底是个什么东西？**不用着急，让我们首先到HGE的官网上去看看：[http://hge.relishgames.com](http://hge.relishgames.com/)，进入之后我想你第一眼就该瞧见HGE最新版的下载提示(目前最新版本为**1.81**)，以及上面赫然的HGE的全称：**Haaf’s Game Engine (****Hardware Accelerated 2D Game Engine) **! 至此我想你终于知晓了HGE其实就是一款游戏引擎，而且是一款支持硬件加速的2D游戏引擎！( 所谓的硬件加速，听来玄乎，其实是HGE使用了DirectX作为底层的缘故 )

好了，第一个问题算是解决了，那么接下来，你可能会问：**为什么我要使用这款名为****HGE****的游戏引擎****？**答案可能很难说清，毕竟世界上优秀的游戏引擎太多了，如果硬要说出些门道来的话，我想可能有以下几个方面：**1.**由于HGE构建于DirectX之上，所以其能够较好的支持硬件加速，并运行于安装有DirectX( 确切的说是DirectX 8.0 )的所有Win32平台上；**2.** HGE拥有较为完善的文档支持，并且HGE小组随时准备处理你的任何反馈；**3.** HGE是免费的，并且从1.7版本起便开始开源，而其发布在zlib/libpng许可证之下的特性，使他能够完全免费的提供给任何的使用者包括商业用户（不过其音频部分由于使用了[BASS](http://www.un4seen.com/)库，所以商业用户不能免费使用(音频部分)…）**4.**本人认为的最突出的优点：由于HGE专注于2D游戏的开发，并且在引擎设计编码上秉承了KISS原则，从不贸然添加一些华而不实的内容，所以使得HGE接口简单并且易于扩展，而且非常稳定！

那么，第二个问题算是过了，而你接下来的问题可能就是：**那我怎么使用它呢？**哈哈，这个问题太简单了：马上下载HGE最新版本，然后在你的IDE中添加必要的头文件和动态链接库，接着参照其文档和示例程序进行简单的“第一次亲密接触”，再然后的深入则可能要各类书籍和Google先生的帮忙了，不过呢一切就是这么简单**:)**

这里我就简单的列出HGE提供的最简单的一个程序示例，其中的注释我想应该足以说明一切了**:)**

**// ****需要包含的头文件**

#include "../../include/hge.h"

**// HGE****全局变量指针**

HGE *hge = 0;

**// ****每一帧HGE****都会调用这个函数，所以**

// **请在此编写你的游戏循环代码. ****不过在这个示例中**

// **我们只是检查了是否按下了ESC****键**

bool FrameFunc()

{

// **如果此函数返回TRUE****，则表示**

**// ****停止应用程序的执行**

**// ****调用Input_GetKeyState****函数获取键盘按键情况**

**// ****其中HGEK_ESCAPE****是HE****自定义的虚拟键码**

if ( hge->Input_GetKeyState(HGEK_ESCAPE) ) return true;

// **如果没有按下ESC****键则继续执行，即返回FALSE**

return false;

}

//**标准的WinMain****函数**

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

{

// **再此我们使用了全局变量指针hge****来指向创建的HGE****实例.**

**// ****不过你可以随时调用hgeCreate****函数来获取对于HGE****的访问**

**// ****但是一定要保证每次对于hgeCreate****的访问都调用Release****函数**

**// ****进行释放。（HGE****在此其实是使用了一个简单的引用计数 :) ****）**

hge = hgeCreate(HGE_VERSION);

// **设置我们程序的帧函数，即先前编写的FrameFunc****函数**

**// ****调用System_SetState****函数，第一参数为HGE****自定义的**

**// ****状态函数枚举值，在此为HGE_FRAMEFUNC****，表明设置**

**// ****的是帧函数，第二参数便自然是相应的函数指针**

hge->System_SetState(HGE_FRAMEFUNC, FrameFunc);

// **设置窗口标题**

hge->System_SetState(HGE_TITLE, "HGE Tutorial 01 - Minimal HGE application");

// **设置是否运行在窗口模式下**

**// ****默认的窗口大小为800x600**

hge->System_SetState(HGE_WINDOWED, true);

// **设置是否使用BASS****库播放音频（由于版权问题…****）**

**// ****在此未使用BASS****库，这也意味着你必须自己编写**

**// ****播放音频的代码…**

hge->System_SetState(HGE_USESOUND, false);

// **调用System_Initiate****函数尝试以**

// **上面设置的各种状态初始化系统.**

**// ****如果出现了错误该函数便返回FALSE**

**// ****并且你可以调用System_GetErrorMessage****函数**

**// ****来获取具体的错误信息**

if(hge->System_Initiate())

{

// **调用System_Start****函数开始运行上面设置的FrameFunc****函数.**

**// ****并且只要FrameFunc****不返回TRUE****便一直在此循环**

hge->System_Start();

}

else

{

//**如果System_Initiate****函数初始化失败便调用最简单的MessageBox**

MessageBox(NULL, hge->System_GetErrorMessage(), "Error", MB_OK | MB_ICONERROR | MB_APPLMODAL);

}

// **程序至此已经退出**

// **调用System_Shutdown****函数释放各类资源并关闭系统**

hge->System_Shutdown();

// **释放HGE****，与先前的hgeCreate****函数对应.**

hge->Release();

return 0;

}

啊哈，第一个HGE程序就这么简单的完成了，马上点击你IDE的编译按钮，然后义无反顾的运行吧，看看你到底搞出了个什么东西**:)**

好了，第一次的HGE简介就到此为止吧，说实话，我也不知道我上面到底说了些什么东西( **Oh,My God! **)，不过对于HGE的其他内容，如高端一些的使用或者是其实现的源码，以后有时间一定一一奉上，大家一起学习嘛，这不正如刘未鹏大牛所言：**书写是一种更好的学习！**不过现在，我得说：下次再见喽**:)**

