# 协同过滤杂谈 - 蓁蓁尔的博客 - CSDN博客





2017年04月09日 19:36:43[蓁蓁尔](https://me.csdn.net/u013527419)阅读数：266








![这里写图片描述](https://img-blog.csdn.net/20170409191736386?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzUyNzQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**两种memory-based CF对比：**

ItemCF：更常用一些，一个是因为其稳定性好，两个商品相似就是相似（可以预先计算并存储两个商品之间的相似度），但是两个用户之间的相似度要考虑时间因素；再一个是商品库里的商品就那么多，计算量级比较固定；还有一个是它发掘长尾商品的能力相对来说更强。 
![这里写图片描述](https://img-blog.csdn.net/20170409191754261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzUyNzQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**CF优缺点：**
**优点：**

（1）与基于内容的推荐多用于推荐文本类的item相比，CF不需要知道用户和items的属性，只基于用户和items间的交互行为即可进行推荐，不需要先验知识，也可以推荐音乐、电影等多媒体类的items； 

（2）如果用户的行为非常丰富的话，那么CF的效果会很好。 
**缺点：**

（1）CF的前提假设是用户的行为完全取决于其之前的历史行为，与当前上下文环境无关，所以推荐的时候可以结合当前的上下文环境从CF判断的用户感兴趣的items中挑选符合用户当前需求的item进行推荐； 

（2）需要大量的用户行为，数据稀疏时效果不好；数据稀疏时可以降维（矩阵分解、聚类、映射（PCA …）） 

（3）需要通过完全相同的商品进行关联（商品的id必须相同），相似的不行。 

（4）可扩展性问题：当商品数目或者是顾客数目增加时，最近邻算法的计算量都会增加。最坏情况下是O(mn) (m 个顾客，n 个商品)，一般在实践中，是O(m+n)因为对每个顾客只考虑一小部分商品。？？？？？？？？ 

k-means等聚类算法可以缓解这个问题。
![这里写图片描述](https://img-blog.csdn.net/20170409191809995?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzUyNzQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

最后一句这个item-based CF可以推荐出来，是说对一个新商品，用户很可能也会对其发生一些交互行为。。？？
![这里写图片描述](https://img-blog.csdn.net/20170412082957456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzUyNzQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)





