# Linux 的(cut,sed,awk,grep,sort) - youbingchen的博客 - CSDN博客





2016年05月25日 15:54:42[youbingchen](https://me.csdn.net/youbingchen)阅读数：935标签：[shell](https://so.csdn.net/so/search/s.do?q=shell&t=blog)
个人分类：[Shell脚本](https://blog.csdn.net/youbingchen/article/category/6244865)









俗话说：磨刀不误砍柴工，这节主要的是从Linux的一些必不可少的工具

# grep的命令

**在了解这些工具之前，先了解一下正则表达式**

#### 正则表达式与通配符
- 正则表达式用来在文件中匹配符合条件的字符串，正则是*包含匹配*，grep、awk、sed等命令都可以支持正则表达式
- 通配符用来匹配符合条件的文件名，通配符是*完全匹配*。ls、find、cp这些命令不能支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。

##### 通配符详解
|符号|含义|
|----|----|
|*|任意字符重复任意多次|
|？|任意字符重复一次|
|[]|中括号的字符中任意字符|

##### 基础正则表达式
|元字符|作用|
|----|----|
|*|前一个字符匹配0次或任意多次|
|.|匹配除了换行符的任意一个字符（相当通配符中的？）|
|^|匹配行首 例如：^hello会匹配以hello开头的行|
|$|匹配行尾 例如：hello$会匹配以hello结尾的行|
|[]|匹配中括号中的指定的任意一个字符，只匹配一个字符。|
|[^]|匹配除中括号的字符意外的任意字符，例如：[^0-9]匹配任意一位非数字的字符|
|\|转义字符，用于取消特殊符号的含义取消|
|{n}|表示前面的字符恰好出现n次。例如：[0-9]{4}匹配4位数字，[1][3-8][0-9]{}匹配手机号码|
|{n,}|表示前面的字符出现不少于n次。例如：[0-9]{2,}表示两位及以上的数字|
|{n,m}|表示前面的字符至少出现n次，最多出现m次。例如：[a-z]{6,8}匹配6到8位的小写字母|

注意: 

```
grep "a*" //无任何意义，会匹配任何字符串
grep "[a-zA-Z]" //表示匹配任意字母
```
`grep [option][mode] file`|选型|含义|
|----|----|
|-c|只输出匹配行的数量|
|-i|搜索时忽略大小写|
|-h|查询多文件时不显示文件名|
|-l|只列出符合匹配的文件名，而不列出具体的匹配行|
|-n|列出所有的匹配行，并显示行号|
|-s|不显示不存在或无匹配文本的错误信息|
|-v|显示不包含匹配文本的所有行|
|-w|匹配整词|
|-x|匹配整行|
|-r|递归搜索，不仅搜索当前工作目录，而且搜索子目录|
|-q|禁止输出任何结果，以退出状态表示搜索是否成功|
|-b|打印匹配行距文件头部的偏移量，以自己为单位|
|-o|与-b选项结合使用，打印匹配的词距头部的偏移量，以字节为单位|
|-E|支持扩展的正则表达式|
|-F|不支持正则表达式，按照字符串的字面意思进行匹配|

# cut的命令

grep 主要用来提取文本中的满足条件的行，cut 和 awk主要用来按列提取文件内容
`cut [选项] 文件名`|选项|含义|
|----|----|
|-f 列号|提取第几列|
|-d 分隔符|按照指定的分隔符分割列（默认分割符是制表符）|
|-b|以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志|
|-c|以字符为单位进行分割|
|-n|取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除|

使用例子

```bash
cut -f 2,4 文件名  //-f 提取多列
cut -d ":" -f 1,3 文件名  //-d 指定分割符
```

注意**cut命令通常和grep命令一起使用**

#### cut的局限

**ccut命令不能同时多个分隔符（特别是多个空格的时候），cut命令不能很好的使用。这时就要使用到 awk 命令**

# sort命令
`sort [选项] 文件名`|选项|含义|
|----|----|
|-f|忽略大小写|
|-n|以数值型进行排序，默认使用字符串型排序|
|-r|反向排序|
|-t|指定分隔符，默认分隔符是制表符|
|-k n[,m]|按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾）|
`sort -t ":" -k 3,3 /etc/passwd //指定分隔符1是 ":",用第三字段开头，第三字段结尾排序，就是只用第三字段排序`
# wc（统计命令）
`wc [选项] 文件名`|选项|含义|
|----|----|
|-l|只统计行数|
|-w|只统计单词数|
|-m|只统计字符数|

# awk 命令

在学习awk 命令之前，先学习printf命令

##### printf命令

printf 命令用于格式化输出，是echo命令的增强版

```bash
printf '输出类型输出格式' 输出内容
```
|输出类型|含义|
|----|----|
|%ns|输出字符串，n是数字代表输出几个字符|
|%ni|输出整数，n是数字指代输出几个数字|
|%m.nf|输出浮点数，m和n是数字，指代输出的整数位和小数位数，如%8.2f代表共输出8位数，其中2位是小数，6位是整数|
|输出格式|含义|
|----|----|
|\a|输出警告声|
|\b|输出退格键|
|\f|清除屏幕|
|\n|换行|
|\r|回车，也就是Enter键|
|\t|水平输出退格键，也就是Tab键|
|\v|垂直输出退格键，也就是Tab键|

注意:**不能和管道符使用，它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。 + printf 命令不用加括号 + format-string 可以没有引号，但最好加上，单引号双引号均可。 + 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。 + arguments 使用空格分隔，不用逗号。例子```bashprintf '%s \t' $(cat 文件名)```print和printf的差别： 在awk命令的输出中支持print和printf命令 + print：print会在每个输出之后自动加入一个换行符（linux默认没有print命令） + printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符#### 进入真正讲解awk命令awk是一种便于使用且表达能力强的程序设计语言，可应用于各种计算和数据处理任务。其内容相对比较复杂，所以在能使用cut命令情况下就使用cut命令，cut命令不能实现的话，我们再考虑使用awk命令。所以这里也只是粗略讲解一下awk命令。```bashawk '条件1{动作1}条件2{动作2}...' 文件名```- 条件：一般使用关系表达式作为条件 比如x > 10- 动作：格式化输出，流程控制语句 比如你想在一个文件提取出相关内容，example.txt|名称|工资|时长||----|----|----||LiMing|20|10||ZhangSan|5|6||LiSi|100|5||WangWu|60|3|打印出工作时间超过4个小时的记录`awk '$3 > 4 {printf $1,$2,$3}' example.txt`说明：awk命令虽然是按列提取，但是它在实际的操作是按行读数据，将数据分别赋予第几列，判断条件。 针对cut命令解决不了的一些内容（比如每一列有多个分隔符的）`df -h | cut -f 5,6`打印出来的是空白，cut命令无法应用这种情况，所以这时采用awk命令` df -h | awk '{print $1 "\t" $5 "\t" $6}' //为了让格式更清楚，在动作中print格式调整时要采用双引号`输出内容： ![这里写图片描述](https://img-blog.csdn.net/20160525154614444)几个命令一起使用：`df -h | grep sda5| awk '{print $5}' | cut -d "%" -f 1`# awk命令进阶模式`awk 'BEGIN{printf "This is my scripts\n"} {printf $2 "\t" $6 "\n"}' 文件名`模式摘要|||----||BEGIN{语句}||END{语句}||表达式{语句}||正则表达式{语句}||组合模式{语句}||模式1，模式2{语句}|**BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。**例子:awk命令默认识别为制表符和空格作为分割符，所以使用BEGIN来自定义分隔符`awk 'BEGIN {FS=":"}{printf $1 "\t" $3"\n"}' /etc/passwd`##### awk命令内置变量|属性|说明||----|----||$0|当前记录（作为单个变量）||$1~$n|当前记录的第n个字段，字段间由FS分隔||FS|输入字段分隔符 默认是空格||NF|当前记录中的字段个数，就是有多少列||NR|已经读出的记录数，就是行号，从1开始||RS|输入的记录他隔符默 认为换行符||OFS|输出字段分隔符 默认也是空格||ORS|输出的记录分隔符，默认为换行符||ARGC|命令行参数个数||ARGV|命令行参数数组||FILENAME|当前输入文件的名字||IGNORECASE|如果为真，则进行忽略大小写的匹配||ARGIND|当前被处理文件的ARGV标志符||CONVFMT|数字转换格式 %.6g||ENVIRON|UNIX环境变量||ERRNO|UNIX系统错误消息||FIELDWIDTHS|输入字段宽度的空白分隔字符串||FNR|当前记录数||OFMT|数字的输出格式 %.6g||RSTART|被匹配函数匹配的字符串首||RLENGTH|被匹配函数匹配的字符串长度||SUBSEP|\034|当然Linux下的awk命令远比我们这边讲解要复杂的多，他还可以实现函数调用，逻辑控制，但是我个人是不建议采用awk编程，完全可以使用shell脚本处理逻辑关键，再结合awk命令# sed命令**sed主要用于数据进行选取、替换、删除新增的命令。就好像文件编辑器（vim），但是文件编辑器只能修改文件，无法接收管道，但是sed是轻量级编辑器，可以接收管道的内容，同时也适用shell脚本批量修改**```bashsed [选项] '[动作]'文件名```|选项|含义||----|----||-n|一般sed命令会把所有数据输出到屏幕，如果加入这个选项，则只会把经过sed命令chulde行输出到屏幕||-e|允许对输入数据应用到多条sed命令编辑||-i|用sed的修改结构直接修改读取数据的文件，而不是由屏幕输出||动作|含义||----|----||a\|追加，在当前行后添加一行或多行，添加多行时，除了最后一行外，每行末尾需要用”\”代表数据未完结||c\|行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每一行的末尾需用”\”代表数据未完结||i\|插入，在当前行前插入一行或多行，插入多行时，除最后一行外，每一行的末尾需用”\”代表数据未完结||d|删除，删除指定的行||p|打印指定的行||s|字符串替换，用一个字符串替换另一个字符串，格式：”行范围s/旧字符串/新字符串/g”（和vim中的替换格式类似）|```sed '2p' /etc/passwd sed -n '2p' /etc/passwd //加上-n和不加上-n的差别，打印一般要和-n一起使用df -h | sed -n '2p'  #和管道符一起使用sed '2,4d' 文件 #删除了（这里删除只会影响输出，不会影响文件内容，除非加上-i）sed '2i hello\ world' 文件名 //插入sed -e 's/Liming//g;s/chao//g' 文件名   //默认是;和换行来分开```**



