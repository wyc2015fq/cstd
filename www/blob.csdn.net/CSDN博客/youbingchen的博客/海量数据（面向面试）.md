# 海量数据（面向面试） - youbingchen的博客 - CSDN博客





2016年05月27日 16:54:13[youbingchen](https://me.csdn.net/youbingchen)阅读数：7545








海量数据这种面试问题经常会在面试被提及到（特别是大的互联网企业），基于上一篇的博客[实用的数据结构](http://blog.csdn.net/youbingchen/article/details/51489154),这篇博客主要利用这些实用的数据结构来处理海量数据的一些问题。

# 海量数据概念

顾名思义，海量就是数据量太大，在短时间无法迅速完成或是数据太大，导致无法一次性装入内存。所以就有两种针对性的方法
- 针对时间，可以采用Bloom filter（布隆过滤器）/Hash/位图/堆/数据库（B+树）或倒序索引/trie树
- 针对空间，大而化小，分而治之（hash映射）

##### 处理海量数据
- 1.分而治之/hash映射+hash统计(trie树统计)+堆/快速/归并排序
- 2.双层桶划分
- 3.Bloom filter/Bitmap
- 4.外排序
- 5.分布式处理之Hadoop/Mapreduce

##### 例子

1.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

> 
**答案：   方案1：采用上述方法1,可以估计每个文件大小大概为$50G\ast64=320G$,远远大于4G,所以考虑采用分而治之的方法：   1.分而治之/hash映射，遍历a文件，对于每个url求取hash(url)%1000,分割成1000个文件，每个文件大约为300M。同样也将文件b分割成小文件   2.hash_set统计或是trie树统计：求每对小文件中相同的url。**  方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 2.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。> **答案：   方案1：   1.采用上述方法1，顺序读取10个文件，按照hash(query)%10的结果query写入另外10个文件，这样大概生成每个文件大概也为1G.   2.hash_map统计：一依次对用hash_map(query,query_count)来统计每个query出现的次数   3.堆/快速/归并排序：利用快速/堆/归并排序按照出现次数排序，最后对这10个文件进行归并排序（内部排序和外排序相结合） **  方案2:   一般query的总量有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入内存，这样我们就可以直接采用trie树/hash_map等直接来统计每个query出现次数，然后按出现的次数做快速排序/堆排序/归并排序 **  方案3：   与方案1类似，在做完hash，分成多个文件，可以交给多个文件来处理，采用分布式的架构来处理（MapReduce），最后再进行合并。 3.在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。> **  方案1：采用2-Bitmap(每个数分配2bit,00表示不存在，01表示出现一次，10出现多次，11无意义)进行，共需2^32*2bit=1GB内存，然后扫描2.5亿个整数，查看Bitmap中相应对应位，如果是00变01,01变10,10保持不变,所扫描完事，查看bitmap，把对应是01的整数输出即可。 **  方案2：采用与第一题类似的方案（针对2.5亿个数是不连续的） 4.上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。> **  上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据 (采用题目1，方案一)   类似的题目: *   + 海量日志数据，提取出某日访问百度次数最多的那个IP    + 量数据分布在100台电脑中，想个办法高校统计出这批数据的TOP10(把每台电脑数据看成一个文件)    + 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。    + 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。    + 100万个数中找出最大的100个数。(对于这种情况直接采用堆排序，不要先hash成文件)    + 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析   方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出 现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。5.文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可（内存限制为 2G的意思就是，可以使用2G的空间来运行程序，而不考虑这台机器上的其他软件的占用内存）。> **  思想：将整形的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的字典序。   第一步:把10G整数每2G读入一次内存，然后一次遍历这536,870,912个数据。每个数据用位运算”>>”取出最高8位(31-24)。这8bits(0-255)最多表示255个桶，那么可以根据8bit的值来确定丢入第几个桶。最后把每个桶写入一个磁盘文件中，同时在内存中统计每个桶内数据的数量，自然这个数量只需要255个整形空间即可。 代价：(1) 10G数据依次读入内存的IO代价(这个是无法避免的，CPU不能直接在磁盘上运算)。(2)在内存中遍历536,870,912个数据，这是一个O(n)的线性时间复杂度。(3)把255个桶写会到255个磁盘文件空间中，这个代价是额外的，也就是多付出一倍的10G数据转移的时间。   第二步：根据内存中255个桶内的数量，计算中位数在第几个桶中。很显然，2,684,354,560个数中位数是第1,342,177,280个。假设前127个桶的数据量相加，发现少于1,342,177,280，把第128个桶数据量加上，大于1,342,177,280。说明，中位数必在磁盘的第128个桶中。而且在这个桶的第1,342,177,280-N(0-127)个数位上。N(0-127)表示前127个桶的数据量之和。然后把第128个文件中的整数读入内存。(平均而言，每个文件的大小估计在10G/128=80M左右，当然也不一定，但是超过2G的可能性很小)。 代价：(1)循环计算255个桶中的数据量累加，需要O(M)的代价，其中m<255。(2)读入一个大概80M左右文件大小的IO代价   注意，变态的情况下，这个需要读入的第128号文件仍然大于2G，那么整个读入仍然可以按照第一步分批来进行读取   第三步：继续以内存中的整数的次高8bit进行桶排序(23-16)。过程和第一步相同，也是255个桶。   第四步：一直下去，直到最低字节(7-0bit)的桶排序结束。我相信这个时候完全可以在内存中使用一次快排就可以了。   类似题目： *5亿个int找它们的中位数。*6.给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？> **  方案1：   申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在 **  方案2：   又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示   假设这40亿个数开始放在一个文件中。然后将这40亿个数分成两类:   1.最高位为0   2.最高位为1   将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找再然后把这个文件为又分成两类:   1.次最高位为0   2.次最高位为1   并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）；与要查找的数的次最高位比较并接着进入相应的文件再查找。   …….   此类推，就可以找到了,而且时间复杂度为O(logn) 7.一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到个数中的中数？> **  方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有个）。我们把0到的整数划分为N个范围段，每个段包含个整数。比如，第一个段位0到，第二段为到，…，第N个段为到。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于，而在第k-1个机器上的累加数小于，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第位。然后我们对第k个机器的数排序，并找出第个数，即为所求的中位数。复杂度是的。 **  方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第个便是所求。复杂度是的。 8.最大间隙问题> **  方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：   1.找到n个数据中最大和最小数据max和min。2.用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为，且桶的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶3.将n个数放入n-1个桶中：将每个元素分配到某个桶（编号为index），其中，并求出分到每个桶的最大最小数据4.最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生。一遍扫描即可完成。 9.将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如：。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出> **  方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。 # 第二部分、十个海量数据处理方法大总结#### Bloom filter适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集 扩展：Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？　　根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。（注意会有一定的错误率）#### Hash适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存 问题实例： 1).海量日志数据，提取出某日访问百度次数最多的那个IP。 IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计#### 堆适用范围：海量数据前n大，并且n比较小，堆可以放入内存 问题实例： 1)100w个数中找最大的前100个数。 用一个100个元素大小的最小堆即可。#### 双层桶划分—-其实本质上就是【分而治之】的思想，重在“分”的技巧上适用范围：第k大，中位数，不重复或重复的数字 问题实例： 1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 　　有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。2).5亿个int找它们的中位数。 　　这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。　　实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。#### 位图适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下 问题实例： 1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 　　将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。#### 数据库索引适用范围：大数据量的增删改查- 关于数据库索引及其优化，更多可参见此文：[http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html](http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html)；- 关于MySQL索引背后的数据结构及算法原理，这里还有一篇很好的文章：[http://blog.codinglabs.org/articles/theory-of-mysql-index.html](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)；- 关于B 树、B+ 树、B* 树及R 树，有篇绝佳文章：[http://blog.csdn.net/v_JULY_v/article/details/6530142](http://blog.csdn.net/v_JULY_v/article/details/6530142)。#### 倒排索引适用范围：搜索引擎，关键字查询 扩展： 问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。 关于倒排索引的应用，更多请参见：- [http://blog.csdn.net/v_july_v/article/details/7085669](http://blog.csdn.net/v_july_v/article/details/7085669)- [http://blog.csdn.net/v_july_v/article/details/7109500](http://blog.csdn.net/v_july_v/article/details/7109500)#### 外排序适用范围：大数据的排序，去重 基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树 问题实例： 1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。 这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。 更多参考： + [http://blog.csdn.net/v_JULY_v/article/details/6451990](http://blog.csdn.net/v_JULY_v/article/details/6451990)#### trie树适用范围：数据量大，重复多，但是数据种类小可以放入内存 问题实例： 　　1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。 　　2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？ 　　3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。#### 分布式处理 mapreduce适用范围：数据量大，但是数据种类小可以放入内存 问题实例： 　　1).The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents: 　　2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。 　　3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？# 参考资料- [http://blog.csdn.net/v_july_v/article/details/7382693](http://blog.csdn.net/v_july_v/article/details/7382693)- [http://blog.csdn.net/u010025211/article/details/51510612](http://blog.csdn.net/u010025211/article/details/51510612)- [http://blog.csdn.net/u012138828/article/details/38927983](http://blog.csdn.net/u012138828/article/details/38927983)*******************************




