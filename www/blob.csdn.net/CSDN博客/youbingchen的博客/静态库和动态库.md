# 静态库和动态库 - youbingchen的博客 - CSDN博客





2016年07月21日 14:33:30[youbingchen](https://me.csdn.net/youbingchen)阅读数：357








> 
有一篇博客专门介绍[程序编译过程](http://blog.csdn.net/youbingchen/article/details/51982509)，在程序编译步骤中有一个很重要的步骤就是链接，这篇博客主要比较静态库和动态库的差别。

在了解两者的区别，我们先学习一下基础知识


# 库是什么

库就是写好的，现有的，成熟的可以 复用的代码，现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都是从零开始，本质上库 就是一种可执行代码的二进制形式，可以被操作系统载入内存 执行，库有两种:静态库（.a,.lib)和动态库（.so,.dll)

# 静态库

静态库在链接阶段会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接，静态库必定跟.o文件格式相似，一个静态库可以看成一组目标文件 (.o/.obj文件)的集合。

静态库的几大特点：
- 静态库对函数库的链接是放在编译时期完成的
- 程序在运行时与函数库再无瓜葛，移植很方便
- 浪费空间和资源，因为所有相关文件与牵涉的函数库链接合成一个可执行文件

### 如何编译自己的静态库

> 
Linux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。一般创建静态库的步骤如图所示:


![lib](https://img-blog.csdn.net/20160721143305250)

### Linux下创建与使用静态库

#### linux静态库命名规则

> 
Linux静态库命名规范，必须“lib[你的库名称].a”:lib为前缀，中间为静态库名，扩展名为.a


#### 创建静态库（.a)
- 首先，将代码文件编译成目标文件.o(StaticMath.o)
`g++  -c StaticMath.cpp  #注意要带-c选项，不然 直接编译成可执行文件`- 然后，通过ar工具将目标文件打包成.a静态库文件
`ar  -crv libStaticMath.a  StaticMath.o`
> 
生成静态库libStaticMath.a,大一点的项目会编写makefile文件（CMake等等工程管理工具）来生成静态库，输入多个命令太麻烦了。


#### 　使用静态库

```cpp
#include "StaticMath.h"
#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    double a = 10;
    double b = 2;

    cout << "a + b = " << StaticMath::add(a, b) << endl;
    cout << "a - b = " << StaticMath::sub(a, b) << endl;
    cout << "a * b = " << StaticMath::mul(a, b) << endl;
    cout << "a / b = " << StaticMath::div(a, b) << endl;

    StaticMath sm;
    sm.print();

    system("pause");
    return 0;
}
```

> 
Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）


```cpp
g++ TestStaticLibrary.cpp -L../StaticLibrary -lstaticmath
```

# 动态库

为什么需要动态库，其实也是静态库的特点导致
- 空间浪费是静态库的一个问题
- 另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新.

> 
动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新.


动态库特点总结： 

+ 动态库把对一些库函数的链接载入推迟到程序运行的时期。
- 
可以实现进程之间的资源共享。（因此动态库也称为共享库）

- 
将一些程序升级变得简单。


+　甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。

### Linux下创建与使用动态库

#### linux动态库的命名规则

> 
动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。

- 针对于实际库文件，每个共享库都有个特殊的名字“soname”。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库
- 在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）

#### 创建动态库
- 首先，生成目标文件，此时要加编译器选项-fpic
`g++ -fPIC -c DynamicMath.cpp    `
> 
-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。


然后，生成动态库，此时要加链接器选项-shared
`g++ -shared -o libdynmath.so DynamicMath.o`
-shared指定生成动态链接库。

> 
其实上面两个步骤可以合并为一个命令

`g++ -fPIC -shared -o libdynmath.so DynamicMath.cpp`
### 使用动态库

```cpp
#include "../DynamicLibrary/DynamicMath.h"

#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    double a = 10;
    double b = 2;

    cout << "a + b = " << DynamicMath::add(a, b) << endl;
    cout << "a - b = " << DynamicMath::sub(a, b) << endl;
    cout << "a * b = " << DynamicMath::mul(a, b) << endl;
    cout << "a / b = " << DynamicMath::div(a, b) << endl;

    DynamicMath dyn;
    dyn.print();
    return 0;
}
```

引用动态库编译成可执行文件（跟静态库方式一样）：
`g++ TestDynamicLibrary.cpp -L../DynamicLibrary -ldynmath`
#### 在执行的时候是如何定位共享库文件的
- 系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)
- 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。

如何让系统找到共享库文件
- 如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作
- 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下 
- 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径
- 运行ldconfig ，该命令会重建/etc/ld.so.cache文件


二者的不同点在于代码被载入的时刻不同。
- 
静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大。

- 
动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小。


动态库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。带来好处的同时，也会有问题！如经典的DLL Hell问题，注意如何规避动态库管理问题。



