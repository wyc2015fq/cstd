# Linux 虚拟内存机制 - youbingchen的博客 - CSDN博客





2016年08月09日 21:31:01[youbingchen](https://me.csdn.net/youbingchen)阅读数：8629标签：[操作系统																[4g																[内存																[linux																[内存管理](https://so.csdn.net/so/search/s.do?q=内存管理&t=blog)
个人分类：[linux](https://blog.csdn.net/youbingchen/article/category/6260822)





> 
华为面试官问了我一个问题就是关于Linux虚拟内存机制，虽然我多少是回答上来，感觉好久没看操作系统的我是时候将其拿起来重温一遍 。




- 每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。
- Linux内存管理采用的是页式管理，使用的是多级页表，动态地址转换机构与主存、辅存共同实现虚拟内存
- 一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录
- 每个进程已经分配的内存空间，都与对应的磁盘空间映射 
![memory_2](https://img-blog.csdn.net/20160809212917680)



> 
每个程序都能看到一片完整连续的地址空间，这些空间并没有直接关联到物理内存，而是操作系统提供了内存的一种抽象概念，使得每个进程都有一个连续完整的地址空间，在程序的运行过程，再完成虚拟地址到物理地址的转换。我们同样知道，进程的地址空间是分段的，存在所谓的数据段，代码段，bbs段，堆，栈等等。每个段都有特定的作用。 

  同时计算机没有那么多的内存（n个进程就需要对应n*4G内存），建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于有一个程序对应多个进程这种情况，浪费内存。
  


# 深入理解
- 1.每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理地址
- 2.所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上
- 3.进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要页表记录
- 4.页表的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存的地址 
- 5.当进程访问某个虚拟地址，去查看页表，如果对应的数据不在物理内存中，，则缺页异常
- 6.缺页异常的处理过程，就是把进程需要的数据从磁盘拷贝到物理内存中，如果内存已经满了 ，没有空地方，那就找一个页进行覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘

# 小结

### 优点：

1.竟然每个进程的内存空间都是一致而且固定的，所以链接器在链接执行文件时，可以设定内存地址，而 不用去管这些数据最终实际的内存地址，这是有独立内存 空间的好处 

2.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存 

3.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。
> 
另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常


# 关于mmap

mmap是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射磁盘文件上，当不设置这个地址的时候，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过manmap可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这样也是一种进程共享数据的方法共享内存

# 关于动态申请空间

> 
在内核态申请内存比用户态申请内存更为直接，他没有采用用户态那种延迟分配内存技术，内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的，相反，对于用户动态申请内存的请求，内核总是尽量延后分配物理内存，用户总是先获得一个 虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。


# 物理内存的内核映射

> 
IA32架构中内核虚拟地址空间只有1GB大小（从3GB到4GB），因此可以直接将1GB大小的物理内存（即常规内存）映射到内核地址空间，但超出1GB大小的物理内存（即高端内存）就不能映射到内核空间。为此，内核采取了下面的方法使得内核可以使用所有的物理内存。

- 高端内存不能全部映射到内核空间，也就是说这些物理内存没有对应的线性地址。不过，内核为每个物理页框都分配了对应的页框描述符，所有的页框描述符都保存在mem_map数组中，因此每个页框描述符的线性地址都是固定存在的。内核此时可以使用alloc_pages()和alloc_page()来分配高端内存，因为这些函数返回页框描述符的线性地址。 
- 内核地址空间的后128MB专门用于映射高端内存，否则，没有线性地址的高端内存不能被内核所访问。这些高端内存的内核映射显然是暂时映射的，否则也只能映射128MB的高端内存。当内核需要访问高端内存时就临时在这个区域进行地址映射，使用完毕之后再用来进行其他高端内存的映射。

![virtual_memory](https://img-blog.csdn.net/20160809212947404)

> 
内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。](https://so.csdn.net/so/search/s.do?q=linux&t=blog)](https://so.csdn.net/so/search/s.do?q=内存&t=blog)](https://so.csdn.net/so/search/s.do?q=4g&t=blog)](https://so.csdn.net/so/search/s.do?q=操作系统&t=blog)




