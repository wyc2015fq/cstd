# object_constructor - youbingchen的博客 - CSDN博客





2016年05月24日 20:20:15[youbingchen](https://me.csdn.net/youbingchen)阅读数：439标签：[继承体系下对象构造](https://so.csdn.net/so/search/s.do?q=继承体系下对象构造&t=blog)
个人分类：[C++ 模型对象](https://blog.csdn.net/youbingchen/article/category/6243383)








- 1.记录在成员初始化列表中的data members初始化操作会被放进constructor的函数本体，并以members的声明顺序为顺序
- 2.如果有一个member并没有出现在成员初始化列表之中，但它有一个默认构造函数，那么默认构造函数必须被调用（**即使没有出现在成员列表，也要调用member构造函数**）
- 3.在那之前如果class object有virtual table pointers，它们必须设定初值，指向适当的virtual tables
- 4.在那之前，所有上一层的基类构造函数必须被调用，以基类的声明顺序，注意**这与成员的初始化列表顺序无关**
- 基类出现在初始化列表上，那么任何显示指定的参数应该传递进去
- 基类没有出现在初始化列表中，同时它有default constructor（或 default memberwise copy constructor），那么调用之。
- 如果基类是多重继承下或后继的基类，那么this 指针必须有所调整。

- 在那之前，所有的virtual base class constructors必须被调用，从左到右，从最深到最浅 
- 如果类被列于成员初始化列表中，那么如果有任何显式指定的参数，都应该传递进去，若没有在初始化列表中，而class一个默认构造函数，也应该调用
- 此外，类中的每一个虚基类的偏移位置（offset)必须在执行期都可被存取
- 如果类对象是最底层的类，它的构造函数可能被调用，某些用以支持这一行为的机制必须被放进来。


# 总结
- (1)任何虚拟基类的构造函数按照它们被继承的顺序构造；
- (2)任何非虚拟基类的构造函数按照它们被继承的顺序构造；
- (3)任何成员对象的构造函数按照它们声明的顺序调用；
- (4)类自己的构造函数(变量是按声明顺序)。

# 虚函数继承问题

virtual table决定了class的virtual functions名单的关键，vptr决定了virtual table如何处理的，为了控制一个class中有所作用的函数，编译系统只要简单地控制住vptr的初始化和设定操作即可。

#### vptr怎么处理（本质上，vptr在构造之中“应该被何时初始化”），三种选择
- 1.在任何操作之前
- 2.在基类构造函数调用操作之后，但是在程序员供应的代码或是初始化成员列表之前
- 3.在每一件事情发生之后

普遍的编译器选择方案2。 

所有一个类的调用顺序如下： 

+ 1.在派生类的构造函数中，所有的 虚基类及上一层基类的构造函数会被调用 

+ 2.上述完成之后，对象的vptrs被初始化，指向相关的虚函数表 

+ 3.如果有初始化成员列表，将在构造函数体内扩展开来，这必须是在vptr被设定之后，以免有一个virtual 成员函数被调用。
注意：**把一个构造函数分为一个完整的对象实例和一个subobject实例，在subobject实例中，vptr的设定可以忽略**

+ 在类构造函数的成员变量初始化列表调用一个类的虚拟函数是安全的，就实际而言，将此函数施行于类的数据成员的初始化行动中，总是安全的，这是因为，vptr保证能够在成员初始化列表被扩展之前，有编译器设定好，但是在语意上这可能是不安全的，因为函数本身可能还得依赖未被设立初始值的成员，所以并不推荐这种写法，然而从vptr的整体角度出发，这是安全的




