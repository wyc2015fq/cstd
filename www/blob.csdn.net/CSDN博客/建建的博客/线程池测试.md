# 线程池测试 - 建建的博客 - CSDN博客
2017年03月12日 13:33:52[纪建](https://me.csdn.net/u013898698)阅读数：352
# [基于C++11的线程池](http://www.cnblogs.com/magicsoar/p/3788180.html)
本篇系[C++ socket网络爬虫（1）](http://www.cnblogs.com/magicsoar/p/3601994.html)的姊妹篇，写网络爬虫怎么能少得了线程呢
源代码地址：[http://files.cnblogs.com/magicsoar/ThreadPoolProject.rar](http://files.cnblogs.com/magicsoar/ThreadPoolProject.rar)
*需要C++11的支持,在vs2013下编译通过
运行效果
![image](http://images.cnitblog.com/blog/412433/201406/141326427495594.png)
背景
在传统的收到任务即创建线程的情况下，我们每收到一个任务，就创建一个线程，执行任务，销毁线程，
我们把这三个过程所用的时间分别记做T1,T2,T3
任务本身所用的时间仅占T2/(T1+T2+T3),这在任务本身所用时间很短的情况下， 效率是很低的
此外，通常操作系统所能创建的线程数量都是有限的，并不能无限制的创建线程。
而在线程池中，我们通常会预先创建m个线程，放到空闲容器中，当有任务来临时，线程池会从空闲的线程中挑选一个线程来执行该任务，
在执行完毕后再将其放回空闲容器中
C++11
在C++11中，C++对线程提供了一个很高的抽象，并没有很好的提供优先级控制等功能，需要调用std::thread::native_handle()，获取原生线程对象
运行平台特定的操作，但这就丧失了std::thread在不同平台上代码层面的一致性。
所以在项目中实现了对std::thread二次封装，并提供了基本的优先级控制
项目概述
项目中有一个主线程，即运行程序时创建的线程可以从用户那里获取任务，还有一个管理线程，用于进行线程池中线程的调度，还有初始化线程池时创建的若干空闲线程，用于执行任务
项目中主要有以下几个类：
Task:任务类，内有任务的优先级，和一个纯虚Run方法，我们需要派生Task，将要完成的任务写到Run方法中
MyThread：线程类，封装了C++11的thread，每一个线程可以关联一个Task对象，执行其Run方法
BusyThreadContainer:工作容器类，采用std::list<MyThread*>实现，储存工作状态的线程
IdleThreadContainer:空闲容器类，采用std::vector<MyThread*>实现，储存处于空闲状态的线程
TaskContainer:任务容器类，采用priority_queue<Task*>实现,储存所有用户添加未执行的任务
MyThreadPool:线程池类，用于从用户获取任务，管理任务，实现对线程池中线程的调度
类图如下
![MainDig](http://images.cnitblog.com/blog/412433/201406/141326461247263.jpg)
*UserTask为用户自己编写的从Task派生的任务类
Task类
```
namespace
{
    enum  PRIORITY
    {
        MIN = 1, NORMAL = 25, MAX = 50
    };
}
class Task
{
    
public:
    Task()
    {
    }
    void SetPriority(int priority)
    {
        if (priority>(PRIORITY::MAX))
        {
            priority = (PRIORITY::MAX);
        }
        else if (priority>(PRIORITY::MAX))
        {
            priority = (PRIORITY::MIN);
        }
    }    
    virtual void Run() = 0;
protected:
    int priority_;
};
```
void SetPriority(int priority) ：设置线程的优先级，数值在1-50之间，值越大，优先级越高
virtualvoid run() = 0：线程执行的方法，用户需要重写为自己的方法
MyThread类
```
class MyThread
{
    friend bool operator==(MyThread my1, MyThread my2);
    friend bool operator!=(MyThread my1, MyThread my2);
public:
    MyThread(MyThreadPool *pool);
    void Assign(Task *Task);
    void Run();
    void StartThread();
    int getthreadid();
    void setisdetach(bool isdetach);    
private:
    MyThreadPool *mythreadpool_;
    static int  s_threadnumber;
    bool isdetach_;
    Task *task_;
    int threadid_;
    std::thread thread_;
};
```
方法：
MyThread(MyThreadPool *pool)：构造一个MyThread对象，将自己与指定的线程池相关联起来
void Assign(Task *Task)：将一个任务与该线程相关联起来
void Run()：调用了Task的Run方法，同时在Task的Run方法结束后将自己从工作容器移回空闲容器
void StartThread()：执行线程的Run方法，即执行了Task的Run方法
int getthreadid()：获取线程的id号
void setisdetach(bool isdetach)：设置线程在运行的时候是join还是detach的
BusyThreadContainer类
```
class BusyThreadContainer
{
    
public:
    BusyThreadContainer();
    ~BusyThreadContainer();
    void push(MyThread *m);
    std::list<MyThread*>::size_type size();
    void erase(MyThread *m);
private:
    std::list<MyThread*> busy_thread_container_;
    typedef std::list<MyThread*> Container;
    typedef Container::iterator Iterator;
};
```
void push(MyThread *m)：将一个线程放入工作容器中
void erase(MyThread *m)：删除一个指定的线程
std::list<MyThread*>::size_type size()：返回工作容器的大小
IdleThreadContainer类
```
class IdleThreadContainer
{
    
public:
    IdleThreadContainer();
    ~IdleThreadContainer();
    std::vector<MyThread*>::size_type size();
    void push(MyThread *m);
    void assign(int n,MyThreadPool* m);    
    MyThread* top();
    void pop();
    void erase(MyThread *m);
private:
    std::vector<MyThread*> idle_thread_container_;
    typedef std::vector<MyThread*> Container;
    typedef Container::iterator Iterator;
};
```
~IdleThreadContainer(); ：负责析构空闲容器中的线程
void push(MyThread *m)：将一个线程放回空闲容器中
void assign(int n,MyThreadPool* m)：创建n个线程与线程池m相关联的线程放入空闲容器中
MyThread* top()：返回位于空闲容器顶端的线程
void pop()：弹出空闲容器顶端的线程
void erase(MyThread *m)：删除一个指定的线程
TaskContainer类
```
class TaskContainer
{
public:
    TaskContainer();
    ~TaskContainer();
    void push(Task *);
    Task* top();
    void pop();
    std::priority_queue<Task*>::size_type size();
private:
    std::priority_queue<Task*> task_container_;
};
```
void push(Task *)：将一个任务放入任务容器中
Task* top()：返回任务容器顶端的任务
void pop()：将任务容器顶端的线程弹出
std::priority_queue<Task*>::size_type size()：返回任务容器的大小
MyThreadPool类
```
class MyThreadPool
{
public:
    
    MyThreadPool(){}
    MyThreadPool(int number);
    ~MyThreadPool();
    void AddTask(Task *Task,int priority);
    void AddIdleThread(int n);
    void RemoveThreadFromBusy(MyThread *myThread);
    void Start();
    void EndMyThreadPool();private:
    BusyThreadContainer busy_thread_container_;
    IdleThreadContainer idle_thread_container_;
    bool issurvive_;
    TaskContainer task_container_;
    std::thread thread_this_;
    std::mutex busy_mutex_;
    std::mutex idle_mutex_;
    std::mutex task_mutex_;
    int number_of_thread_;
};
```
MyThreadPool(int number)：构造MyThreadPool，创建包含number个线程的空闲容器
void AddTask(Task *Task,int priority)：添加一个优先级为priority的任务到任务容器中
void AddIdleThread(int n)：在创建n个空闲线程到空闲容器中
void RemoveThreadFromBusy(MyThread *myThread)：将一个线程从工作容器中删除，并移回空闲容器中
void Start()：判断是否有空闲线程，如有将任务从从任务容器中提出，放入空闲容器中，等待执行
void EndMyThreadPool()：结束线程池的运行
派生自Task的MyTask类
```
class MyTask :public Task
{
    friend bool operator<(MyTask  &lv,MyTask &rv)
    {
        return lv.priority_ < rv.priority_;
    }
public:
    MyTask();
    ~MyTask();
    virtual void Run();
    void setdata(int d);
private:
    int data_;
};
```
```
MyTask::MyTask()
{
}
MyTask::~MyTask()
{
}
void MyTask::setdata(int d)
{
    data_ = d;
}
void MyTask::Run()
{
    std::cout << "Hello I am "<<data_ << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```
friend booloperator<(MyTask &lv,MyTask
 &rv) ：用于确定任务在任务容器中的位置
Run：自定义的Run方法
void setdata(int d)：设置数据
关键代码分析：
void MyThread::Run()
```
void MyThread::Run()
{
    cout <<"Thread:"<< threadid_ << " run ";
    task_->Run();
    mythreadpool_->RemoveThreadFromBusy(this);
}
```
调用了Task的Run方法，同时在Task的Run方法结束后，通知线程池将自己从工作容器中移回空闲容器
void MyThread::StartThread()
```
void MyThread::StartThread()
{
    thread_ = thread(&MyThread::Run, this);
    if (isdetach_ == true)
        thread_.detach();
    else
        thread_.join();
}
```
将MyThread的Run方法与thread_相绑定，this表示类的Run方法的第一个隐含的参数
然后根据isdetach的值，判断是否detach() or join()
void MyThreadPool::RemoveThreadFromBusy(MyThread *myThread)
```
void MyThreadPool::RemoveThreadFromBusy(MyThread *myThread)
{
    busy_mutex_.lock();
    cout << "Thread:" << myThread->getthreadid()<< " remove from busylist" << endl;
    busy_thread_container_.erase(myThread);
    busy_mutex_.unlock();
    idle_mutex_.lock();
    idle_thread_container_.push(myThread);
    idle_mutex_.unlock();
}
```
将一个线程从任务容器中移除，并将其放回空闲容器中，
使用busy_mutex_和idle_mutex_进行加锁和解锁，确保数据的一致性
MyThreadPool::MyThreadPool(int number)
```
MyThreadPool::MyThreadPool(int number)
{
    issurvive_ = true;
    number_of_thread_ = number;
    idle_thread_container_.assign(number, this);
    thread_this_ =thread(&MyThreadPool::Start, this);
    thread_this_.detach();
}
```
MyThreadPool的构造函数，创建number个空闲线程与空闲容器中，同时创建管理线程thread_this，用于进行线程池中线程的调度
void MyThreadPool::Start()
```
void MyThreadPool::Start()
{
    
    while (true)
    {
        if (issurvive_==false)
        {
            busy_mutex_.lock();
            if (busy_thread_container_.size()!=0)
            {
                busy_mutex_.unlock();
                continue;
            }
            busy_mutex_.unlock();
            break;
        }
        idle_mutex_.lock();
        if (idle_thread_container_.size() == 0)
        {
            idle_mutex_.unlock();
            continue;
        }
        idle_mutex_.unlock();
        task_mutex_.lock();
        if (task_container_.size() == 0)
        {
            task_mutex_.unlock();
            continue;
        }
        Task *b = task_container_.top();;
        task_container_.pop();
        task_mutex_.unlock();
        
        idle_mutex_.lock();
        MyThread *mythread = idle_thread_container_.top();;
        idle_thread_container_.pop();
        mythread->Assign(b);
        idle_mutex_.unlock();
        busy_mutex_.lock();
        busy_thread_container_.push(mythread);
        busy_mutex_.unlock();
        mythread->StartThread();
    }
}
```
管理线程对应的Start方法，内有一个死循环，不停的判断任务容器中是否有任务，和是否有空闲线程来执行任务，若有，则将任务从
任务容器中提出，从空闲线程中提取出一个空闲线程与其绑定，执行该任务，同时将该线程从空闲容器移动到工作容器中。
当线程池想要结束运行时，即survive为false时，首先要判断工作容器是否为空，若不为空，则代表还有任务正在被线程执行，线程池不能结束运行
否则可以结束线程池的运行，跳出死循环
int main()
```
int main()
{
    MyThreadPool mythreadPool(10);
    MyTask j[50];
    for (int i = 0; i < 50;i++)
    {
        j[i].setdata(i);
    }
    for (int i = 0; i < 50; i++)
    {
        mythreadPool.AddTask(&j[i],i);
    }
    int i;
    //按100添加一个任务
    //按-1结束线程池
    while (true)
    {
        cin >> i;    
        if (i == 100)
        {
            MyTask j;
            j.setdata(i);
            mythreadPool.AddTask(&j, i);
        }
        if (i == -1)
        {        
            mythreadPool.EndMyThreadPool();
            break;
        }        
    }
    system("pause");
}
```
创建了一个含有10个空闲线程的线程池，和50个MyTask任务，并将其放入线程池中等待运行
在循环中，用户输入100可以再添加一个任务到线程池中等待运行，输入-1结束线程池的运行。
运行结果如下
![image](http://images.cnitblog.com/blog/412433/201406/141326475922249.png)
线程池使用后记
线程池并不是万能的，线程池减少了创建与销毁线程本身对任务照成的影响，但如果任务本身的运行时间很长，那么这些开销相当于任务本身执行开销而言是可以忽略的。那么我们也可以
选择“即时创建，即时销毁”的策略
线程池通常适合下面的几个场合：
(1)  单位时间内处理的任务数较多，且每个任务的执行时间较短
(2)  对实时性要求较高的任务，如果接受到任务后在创建线程，再执行任务，可能满足不了实时要求，因此必须采用线程池进行预创建。
