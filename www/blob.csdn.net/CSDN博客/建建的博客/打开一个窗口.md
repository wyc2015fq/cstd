# 打开一个窗口 - 建建的博客 - CSDN博客
2017年07月17日 11:03:11[纪建](https://me.csdn.net/u013898698)阅读数：104
### 背景
感谢Mariano Suligoy，您可以用[西班牙语](http://ogldev.atspace.co.uk/www/tutorial01/tutorial01_spanish.html)阅读本教程。
OpenGL规范没有指定任何API来创建和操纵窗口。支持OpenGL的现代窗口系统包括一个在OpenGL上下文和窗口系统之间提供绑定的子系统。在X Window系统中，该界面称为GLX。微软为Windows提供WGL（发音：Wiggle），MacOS有CGL。直接与这些接口工作，以创建一个窗口来显示图形通常是咕噜的工作，这就是为什么我们使用一个高级别的图书馆来摘取细节。我们在这里使用的库称为“OpenGL实用程序库”或GLUT。它为窗口管理以及事件处理，IO控制和其他一些服务提供了一个简化的API。此外，GLUT是跨平台，使便携性更容易。GLUT的替代品包括SDL和GLFW。
### 来源walkthru
`glutInit(&argc, argv);`
此呼叫初始化GLUT。这些参数可以直接从命令行提供，并且包括诸如'-sync'和'-gldebug'的有用选项，它们会禁用X的异步性质，并自动检查GL错误并分别显示它们。
`glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);`
这里我们配置一些GLUT选项。GLUT_DOUBLE启用双缓冲（绘制到后台缓冲区，另一个缓冲区显示）和最多渲染结束的颜色缓冲区（即屏幕）。我们通常会想要这两个以及我们稍后会看到的其他选项。
```
glutInitWindowSize(1024, 768); 
glutInitWindowPosition(100, 100); 
glutCreateWindow("Tutorial 01");
```
这些调用指定窗口参数并创建它。您还可以选择指定窗口标题。
`glutDisplayFunc(RenderSceneCB);`
由于我们正在开窗系统中，大多数与运行程序的交互都是通过事件回调函数发生的。GLUT负责与底层窗口系统的交互，并为我们提供了一些回调选项。这里我们只使用一个“主”回调来执行一帧的所有渲染。该功能由GLUT内部循环连续调用。
`glClearColor(0.0f, 0.0f, 0.0f, 0.0f);`
这是我们第一次遇到OpenGL中的状态概念。状态背后的想法是，渲染是一个复杂的任务，它不能被视为接收几个参数的函数调用（正确设计的函数从不接收很多参数）。您需要指定着色器，缓冲区和影响渲染发生的各种标志。此外，您经常希望在多个渲染操作中保持相同的配置（例如，如果您从不禁用深度测试，则无需为每次渲染调用指定它）。这就是为什么大部分渲染操作的配置都是通过在OpenGL状态机中设置标志和值来完成的，而渲染调用本身通常限于围绕要绘制的顶点数量和起始偏移量的几个参数。在调用状态改变功能后，特定配置保持不变，直到下一次调用具有不同值的同一功能。上述调用设置清除帧缓冲区（稍后描述）时将使用的颜色。颜色有四个通道（RGBA），它被指定为0.0到1.0之间的归一化值。上述调用设置清除帧缓冲区（稍后描述）时将使用的颜色。颜色有四个通道（RGBA），它被指定为0.0到1.0之间的归一化值。上述调用设置清除帧缓冲区（稍后描述）时将使用的颜色。颜色有四个通道（RGBA），它被指定为0.0到1.0之间的归一化值。
`glutMainLoop();`
此调用将控制传递给GLUT，它现在开始自己的内部循环。在这个循环中，它监听来自窗口系统的事件，并通过我们配置的回调传递它们。在我们的情况下，GLUT只会调用我们注册为显示回调函数（RenderSceneCB）的函数，以便我们给出一个渲染框架的方法。
```
glClear(GL_COLOR_BUFFER_BIT); 
glutSwapBuffers();
```
我们在渲染功能中唯一的做法是清除帧缓冲区（使用上面指定的颜色 - 尝试更改它）。第二个呼叫告诉GLUT来交换backbuffer和frontbuffer的角色。在下一轮中，通过渲染回调，我们将渲染到当前帧前缓冲区中，并显示当前的后缓冲区。
