# 关于网络字节序和主机字节序 - 建建的博客 - CSDN博客
2017年03月12日 11:30:50[纪建](https://me.csdn.net/u013898698)阅读数：176
什么是字节序？是指整数在内存中保存的顺序。
      字节序有两种：
      a.Little endinan 低位存储在内存的低地址，高位存储在内存的高地址；
      b.Big endian 高位存储在内存的低地址，低位存储在内存的高地址；
      举个简单的例子：
DWORD dwCount = 0x01020304;这样的一个双字节变量在内存中如下分布0013FF70  04 03 02 01
（注：实验结果取之 XPSP3 VC6.0，说明我的机器是Little endinan序）
而如果是Big endian序的话，应该是0013FF70  01 02 03 04。用的比较多的x86系列的CPU，都是Little endinan序的。
      而网络字节序这是TCP/IP协议中定义好的一种数据表示格式，它是与你的机器的cpu，[操作系统](http://lib.csdn.net/base/operatingsystem)什么的无关的，这样可以保证数据在网络中传输时，不管怎么样都能正确的解释了，网络字节序选择了Big
 endian。这样就给编写网络程序的程序员带来一个问题，程序员必须把本地数据从主机字节序转换成网络字节序发送到主机，同时，主机也必须把收到的数据从网络字节序转换成本地字节序，这样才能保证双方正确的收发数据，不然就是产生bug。
      winapi提供了四个函数用于进行网络字节序到本机字节序和本机字节序到网络字节序的转换：
htons：把unsigned short类型从主机序转换到网络序
htonl：把unsigned long类型从主机序转换到网络序
ntohs：把unsigned short类型从网络序转换到主机序
ntohl：把unsigned long类型从网络序转换到主机序
（这四个API可以这样记，s表示short，l表示long，n表示network，h表示host）
      另外：char类型是没有字节序的问题的，只有大于一个字节的数据类型才有字节序的问题。很多翻译书籍将Little endinan翻译成小端模式，将Big endian翻译成大端模式。
