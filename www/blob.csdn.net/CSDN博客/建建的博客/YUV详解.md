# YUV详解 - 建建的博客 - CSDN博客
2017年02月08日 15:14:07[纪建](https://me.csdn.net/u013898698)阅读数：197
个人分类：[视频编解码学习](https://blog.csdn.net/u013898698/article/category/6703370)
**概要：**
与RGB编码方法类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它是指将亮度参量（Y：Luminance或Luma）和色度参量（UV：Chrominance或Chroma）分开进行表示的像素编码格式。而这样分开的好处就是不但可以避免相互干扰--没有UV信息一样可以显示完整的图像，因而解决了彩色电视与黑白电视的兼容问题；还可以降低色度的采样率而不会对图像质量影响太大，降低了视屏信号传输时对频宽（带宽）的要求。YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式
**YUV格式类别：**
- 打包（packed）格式：将每个像素点的Y,U,V分量交叉排列并以像素点为单元连续的存放在同一数组中，通常几个相邻的像素组成一个宏像素（macro-pixel）
- 平面（planar）格式：使用三个数组分开连续的存放Y,U,V三个分量，即Y,U,V分别存放在各自的数组中。
**YUV采样表示法：**
YUV采用A:B:C表示法来描述Y,U,V采样频率比例，下图中黑点表示采样像素点Y分量， 空心圆表示采样像素点的UV分量。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305181725659-651666756.jpg)
- 4:4:4 表示色度频道没有下采样，即一个Y分量对应着一个U分量和一个V分量。
- 4:2:2 表示 2:1 的水平下采样，没有垂直下采样，即每两个Y分量共用一个U分量和一个V分量。
- 4:2:0 表示 2:1 的水平下采样，2:1 的垂直下采样，即每四个Y分量共用一个U分量和一个V分量。
- 4:1:1 表示 4:1 的水平下采样，没有垂直下采样。即每四个Y分量共用一个U分量或一个V分量，与其他格式相比，4:1:1 采样不太常用。
**YUV数据存储：**
下面以每个分量数据存储在一个char（或byte）中为例描述YUV的数据存储方式， 图中每个方格表示一个chat。
（1）. 4:4:4格式，每像素32位
推荐一个 4:4:4 格式，FOURCC 码为 AYUV。这是一个打包格式，其中每个像素都被编码为四个连续字节，其组织顺序如下所示，其中A标示了alpha通道。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305182918034-486561221.jpg)
（2）. 4:2:2格式，每像素16位
支持两个 4:2:2 格式，FOURCC 码如为 YUY2 和 UYVY。两个都是打包格式，其中每个巨像素都是编码为四个连续字节的两个像素。这样会使得色度水平下采样乘以系数 2。
- **YUY2**
在 YUY2 格式中，数据可被视为一个不带正负号的 char 值组成的数组，其中第一个字节存储第一个 Y 样例，第二个字节存储第一个 U (Cb) 样例，第三个字节存储第二个 Y 样例，第四个字节存储第一个 V (Cr) 样例，如下图。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305183600721-526567488.jpg)
如果该图像被看作由两个 little-endian WORD 值组成的数组，则第一个 WORD 在最低有效位(LSB) 中包含 Y0，在最高有效位 (MSB) 中包含 U0。第二个 WORD 在 LSB 中包含
 Y1，在 MSB 中包含 V0。
- **UYVY**
此格式与 YUY2 相同，只是字节顺序是与之相反的。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305184220393-983231153.jpg)
如果该图像被看作由两个 little-endian WORD 值组成的数组，则第一个 WORD 在 LSB 中包含 U0，在 MSB 中包含 Y0，第二个 WORD 在 LSB 中包含 V0，在 MSB 中包含 Y1。
（3）. 4:2:0格式，每像素16位
推荐两个 4:2:0 每像素 16 位格式，FOURCC 码： IMC1 和 IMC3。两个
 FOURCC 码都是平面格式。色度频道在水平方向和垂直方向上都要以系数 2 来进行再次采样。
- **IMC1**
所有 Y 样例都会作为不带正负号的 char 值组成的数组首先存储在内存中。后面跟着存储所有 V (Cr) 样例，然后是所有 U (Cb) 样例。V 和 U 平面与 Y 平面具有相同的跨距（即存储数组的宽度），从而遗留了如下图所示的未使用的内存区域。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305185001690-1618536341.jpg)
- **IMC3**
此格式与 IMC1 相同，只是 U 和 V 平面进行了交换。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305185105159-2072411729.jpg)
（4）. 4:2:0格式，每像素12位
推荐四个 4:2:0 每像素 12 位格式，FOURCC 码：IMC2, IMC4, YV12, NV12。在所有这些格式中，色度频道在水平方向和垂直方向上都要以系数 2 来进行再次采样。
- **IMC2**
此格式与 IMC1 相同，只是 V (Cr) 和 U (Cb) 行在半跨距边界处进行了交错。换句话说，就是色度区域中的每个完整跨距行都以一行 V 样例开始，然后是一行在下一个半跨距边界处开始的 U 样例。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305185453737-1208673453.jpg)
此布局与 IMC1 相比，IMC2能够更加高效地利用存储空间。它的色度存储空间缩小了一半，因此整体存储空间缩小了 25%。在各个 4:2:0 格式中，IMC2 是第二首选格式，排在 NV12 之后。
- **IMC4**
此格式与 IMC2 相同，只是 U (Cb) 和 V (Cr) 行进行了交换。
**![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305185741174-189370495.jpg)**
- **YV12 **（YU12格式和YV12存储格式基本相同，只是UV存储位置互换）
所有 Y 样例都会作为不带正负号的 char 值组成的数组首先存储在内存中。此数组后面紧接着存储所有 V (Cr) 样例。V 平面的跨距为 Y 平面跨距的一半，V 平面包含的行为 Y 平面包含行的一半。V 平面后面紧接着存储所有 U (Cb) 样例，它的跨距和行数与 V 平面相同。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305190004518-828699461.jpg)
- **NV12**（NV21格式和NV12存储格式基本相同，只是UV存储位置互换）
所有 Y 样例都会作为由不带正负号的 char 值组成的数组首先存储在内存中，并且行数为偶数。Y 平面后面紧接着一个由不带正负号的 char 值组成的数组，其中包含了打包的 U (Cb) 和 V (Cr) 样例。
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305190233737-1959432806.jpg)
当组合的 U-V 数组被视为一个由 little-endian WORD 值组成的数组时，LSB 包含 U 值，MSB包含 V 值。NV12 是用于 DirectX VA 的首选 4:2:0 像素格式。
**YUV数据转换：**
（1）. 4:2:2
 -> 4:2:0的有损压缩转换
　　Y存储数据不变，对U和V分量在行垂直下采样进行隔行抽样。
（2）. 4:2:0
 -> 4:2:2的补足转换
　　Y存储数据不变，对U和V分量在行垂直下采样进行隔行拷贝补足下一行色度数据。
在YUV中，一个像素点对应一个Y分量，同一图像无论是4:4:4, 4:2:2, 4:2:0, 4:1:1的格式，其中Y分量数据都是完全相同的。YUV420sp和YUV420p的数据存储格式区别在于UV分量排列的顺序不同，YUV420p是先存储完U分量后再存储V分量，也就是说UV分量各自都是连续的，而YUV420sp则交叉存储UV分量，因此一个YUV420图片的存储空间为：
　　Y分量 = width * hight
　　U分量 = Y / 4
　　V分量 = Y / 4
　　YUV420图像存储空间 = width * hight * 3 / 2
例如一张分辨率为8X4的YUV420图像，数据存储格式如下图：
YUV420sp格式
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305192837174-139297124.png)
YUV420p格式
![](http://images2015.cnblogs.com/blog/110750/201603/110750-20160305192846799-826782938.png)
**YUV图像旋转算法：**
下面以YUV420sp格式图像为例给出旋转90的算法。
```
```java
public
```
```java
void
```
```java
rotateYUV420sp(
```
```java
byte
```
```java
[]
 src,
```
```java
byte
```
```java
[]
 des,
```
```java
int
```
```java
width,
```
```java
int
```
```java
height)
 {
```
```java
```
```java
int
```
```java
length
 = width * height;
```
```java
```
```java
int
```
```java
k
 =
```
```java
0
```
```java
;
```
```java
```
```java
for
```
```java
(
```
```java
int
```
```java
i
 =
```
```java
0
```
```java
;
 i < width; i++) {
```
```java
```
```java
for
```
```java
(
```
```java
int
```
```java
j
 =
```
```java
0
```
```java
;
 j < height; j++) {
```
```java
```
```java
des[k]
 = src[width * j + i];
```
```java
```
```java
k++;
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
for
```
```java
(
```
```java
int
```
```java
i
 =
```
```java
0
```
```java
;
 i < width; i + =
```
```java
2
```
```java
)
 {
```
```java
```
```java
for
```
```java
(
```
```java
int
```
```java
j
 =
```
```java
0
```
```java
;
 j < height /
```
```java
2
```
```java
;
 j++) {
```
```java
```
```java
des[k]    
 = src[length + width * j + i];
```
```java
```
```java
des[k
 +
```
```java
1
```
```java
]
 = src[length + width * j + i +
```
```java
1
```
```java
];
```
```java
```
```java
k
 +=
```
```java
2
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
