# 统一变量 - 建建的博客 - CSDN博客
2017年07月17日 13:56:54[纪建](https://me.csdn.net/u013898698)阅读数：484
### 背景
在本教程中，我们遇到了一种新的着色器变量 - 统一变量。属性和统一变量之间的区别在于，属性变量包含顶点特定的数据，因此每个着色器调用将从顶点缓冲区重新加载一个新值，而整个绘图调用的均匀变量的值保持不变。这意味着您在进行绘图调用之前加载该值，然后可以在顶点着色器的每次调用中访问相同的值。统一变量可用于存储照明参数（光照位置和方向等），变换矩阵，纹理对象句柄等数据。
在本教程中，我们终于在屏幕上移动了一些东西。我们使用统一变量的组合来实现，它们的值每帧都改变，而GLUT提供的空闲回调函数。关键是GLUT不会重复调用我们的渲染回调函数 - 除非它必须。GLUT必须在事件之后调用渲染回调，例如最小化和最大化窗口或通过另一个窗口发现它。如果在启动应用程序后，我们不更改Windows布局中的任何内容，则只需调用渲染回调。您可以通过在render函数中添加一个printf调用来查看自己。您将看到输出只有一次，如果最小化然后最大化窗口，您将再次看到它。在GLUT中仅注册渲染回调对于以前的教程是好的，但在这里我们想重复更改变量的值。我们通过注册空闲函数回调来实现。当没有从窗口系统接收到事件时，GLUT调用空闲功能。您可以为此回调使用专用功能，您可以在此处执行任何簿记，例如时间更新，或者简单地将渲染回调函数注册为空闲回调。在本教程中，我们稍后再对render函数进行更新。您可以为此回调使用专用功能，您可以在此处执行任何簿记，例如时间更新，或者简单地将渲染回调函数注册为空闲回调。在本教程中，我们稍后再对render函数进行更新。您可以为此回调使用专用功能，您可以在此处执行任何簿记，例如时间更新，或者简单地将渲染回调函数注册为空闲回调。在本教程中，我们稍后再对render函数进行更新。
### 来源walkthru
`glutIdleFunc(RenderSceneCB);`
这里我们将render回调注册为空闲功能。请注意，如果您决定使用专用的空闲回调函数，则需要在其末尾添加对glutPostRedisplay（）的调用。否则空闲功能将被一次又一次地调用，但是渲染功能不会。glutPostRedisplay（）根据需要重新显示当前窗口，在下一轮中，通过GLUT的主循环将调用渲染回调。
```
gScaleLocation = glGetUniformLocation(ShaderProgram, "gScale");
assert(gScaleLocation != 0xFFFFFFFF);
```
链接程序后，我们查询程序对象的统一变量的位置。这是应用程序C / C ++执行环境需要映射到着色器执行环境的另一个例子。您没有直接访问着色器内容，您不能直接更新其变量。编译着色器时，GLSL编译器会为每个均匀变量分配一个索引。在编译器的内部表示中，编译器访问变量是使用其索引来解决的。该索引也可通过glGetUniformLocation对应用程序使用。您可以使用程序对象句柄和变量的名称来调用此函数。该函数返回索引，如果有错误返回-1。检查错误非常重要（如我们在断言中所做的那样），否则将来不会将更新变量传递给着色器。主要有两个原因导致此功能失败。你或者拼错了变量的名称，或者被编译器优化了。如果GLSL编译器发现该变量实际上并没有在着色器中使用，那么它可以简单地删除它。在这种情况下，glGetUniformLocation将失败。
```
static float Scale = 0.0f;
Scale += 0.001f;
glUniform1f(gScaleLocation, sinf(Scale));
```
我们维护一个静态浮点变量，我们在每次调用render函数时增加一点（如果您的机器运行速度太慢或太快，您可能需要播放0.001）。传递给着色器的实际值是“Scale”变量的正弦值。这是在-1.0和1.0之间创建一个很好的循环。请注意，sinf（）取弧度而不是度数作为参数，但在这一点上，我们根本不在乎。我们只想要窦产生的波。使用glUniform1f将sinf（）的结果传递给着色器。OpenGL为glUniform
 {1234} {if}的一般形式提供了这个功能的多个实例。您可以使用它将值加载到1D，2D，3D或4D（基于“glUniform”之后的数字）浮点或整数向量（这是“i” 或'f'后缀）。还有一些版本可以将一个向量地址作为参数以及特殊的矩阵版本。函数的第一个参数是使用glGetUniformLocation（）提取的索引位置。
现在我们来看一下VS中发生的变化（FS保持不变）。
`uniform float gScale;`
这里我们在着色器中声明均匀值。
`gl_Position = vec4(gScale * Position.x, gScale * Position.y, Position.z, 1.0);`
我们将位置向量的X和Y值乘以应用程序每帧改变的值。你可以解释为什么三角形倒立一半的循环？
