# OpenSL  ES  进行音频解码播放 - 建建的博客 - CSDN博客
2017年05月31日 16:45:06[纪建](https://me.csdn.net/u013898698)阅读数：1163
![这里写图片描述](http://www.2cto.com/uploadfile/Collfiles/20170203/2017020309514894.png)
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
/*
```
```java
*
```
```java
*这里使用了transcode-1.1.7对wav文件进行解码，然后使用opensl
 es进行播放
```
```java
*
```
```java
*/
```
```java
//用到的变量和结构体
```
```java
WAV
 wav;
```
```java
//wav文件指针
```
```java
SLObjectItf
 engineObject;
```
```java
//引擎对象
```
```java
SLEngineItf
 engineInterface;
```
```java
//引擎接口
```
```java
SLObjectItf
 outputMixObject;
```
```java
//混音器
```
```java
SLObjectItf
 audioPlayerObject;
```
```java
//播放器对象
```
```java
SLAndroidSimpleBufferQueueItf
 andioPlayerBufferQueueItf;
```
```java
//缓冲器队列接口
```
```java
SLPlayItf
 audioPlayInterface;
```
```java
//播放接口
```
```java
unsigned
```
```java
char
```
```java
*buffer;
```
```java
//缓冲区
```
```java
size_t
 bufferSize;
```
```java
//缓冲区大小
```
```java
//上下文
```
```java
struct
 PlayerContext{
```
```java
```
```java
WAV
 wav;
```
```java
```
```java
unsigned
```
```java
char
```
```java
*buffer;
```
```java
```
```java
size_t
 bufferSize;
```
```java
```
```java
PlayerContext(WAV
 wav,
```
```java
```
```java
unsigned
```
```java
char
```
```java
*buffer,
```
```java
```
```java
size_t
 bufferSize){
```
```java
```
```java
this
```
```java
->wav
 = wav;
```
```java
```
```java
this
```
```java
->buffer
 = buffer;
```
```java
```
```java
this
```
```java
->bufferSize
 = bufferSize;
```
```java
```
```java
}
```
```java
};
```
```java
//实现对象
```
```java
void
```
```java
RealizeObject(SLObjectItf object){
```
```java
```
```java
//非异步（阻塞）
```
```java
```
```java
(*object)->Realize(object,SL_BOOLEAN_FALSE);
```
```java
}
```
```
## 具体实现流程：
## 1.打开文件
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
WAV
 wav = OpenWaveFile(env,jFileName);
```
```
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//打开文件
```
```java
WAV
 OpenWaveFile(JNIEnv *env,jstring jFileName){
```
```java
```
```java
const
```
```java
char
```
```java
*cFileName = env->GetStringUTFChars(jFileName,JNI_FALSE);
```
```java
```
```java
WAVError
 err;
```
```java
```
```java
WAV
 wav = wav_open(cFileName,WAV_READ,&err);
```
```java
```
```java
LOGI(
```
```java
"%d"
```
```java
,wav_get_bitrate(wav));
```
```java
```
```java
env->ReleaseStringUTFChars(jFileName,cFileName);
```
```java
```
```java
if
```
```java
(wav
 ==
```
```java
0
```
```java
){
```
```java
```
```java
LOGE(
```
```java
"%s"
```
```java
,wav_strerror(err));
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
wav;
```
```java
}
```
```
## 2.创建OpenSL ES引擎
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//OpenSL
 ES在Android平台下默认是线程安全的，这样设置是为了为了兼容其他平台
```
```java
```
```java
SLEngineOption
 options[] = {
```
```java
```
```java
{(SLuint32)SL_ENGINEOPTION_THREADSAFE,
 (SLuint32)SL_BOOLEAN_TRUE}
```
```java
```
```java
};
```
```java
```
```java
slCreateEngine(&engineObject,ARRAY_LEN(engineObject),options,
```
```java
0
```
```java
,
```
```java
0
```
```java
,
```
```java
0
```
```java
);
```
```java
//没有接口
```
```java
//实例化对象
```
```java
```
```java
//对象创建之后，处于未实例化状态，对象虽然存在但未分配任何资源，使用前先实例化（使用完之后destroy）
```
```java
```
```java
RealizeObject(engineObject);
```
```
## 3.获取引擎接口
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
(*engineObject)->GetInterface(engineObject,SL_IID_ENGINE,&engineInterface);
```
```
## 4.创建输出混音器
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
(*engineInterface)->CreateOutputMix(engineInterface,&outputMixObject,
```
```java
0
```
```java
,
```
```java
0
```
```java
,
```
```java
0
```
```java
);
```
```java
//没有接口
```
```java
```
```java
//实例化混音器
```
```java
```
```java
RealizeObject(outputMixObject);
```
```
<h2 id="5创建缓冲区保存读取到的音频[数据库">5.创建缓冲区保存读取到的音频数据库]( database=)
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//缓冲区的大小
```
```java
```
```java
bufferSize
 = wav_get_channels(wav) * wav_get_rate(wav) * wav_get_bits(wav);
```
```java
```
```java
buffer
 =
```
```java
new
```
```java
unsigned
```
```java
char
```
```java
[bufferSize];
```
```
## 6.创建带有缓冲区队列的音频播放器
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
CreateBufferQueueAudioPlayer(wav,engineInterface,outputMixObject,audioPlayerObject);
```
```java
```
```java
//实例化音频播放器
```
```java
```
```java
RealizeObject(audioPlayerObject);
```
```
CreateBufferQueueAudioPlayer.cpp
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
extern
```
```java
"C"
```
```java
{
```
```java
#include
```
```java
"wavlib.h"
```
```java
}
```
```java
#include
 <sles opensles.h=
```
```java
""
```
```java
>
```
```java
#include
 <sles opensles_android.h=
```
```java
""
```
```java
>
```
```java
#include
```
```java
#define
 ARRAY_LEN(a) (sizeof(a) / sizeof(a[
```
```java
0
```
```java
]))
```
```java
//创建音频播放对象
```
```java
void
```
```java
CreateBufferQueueAudioPlayer(
```
```java
```
```java
WAV
 wav,
```
```java
```
```java
SLEngineItf
 engineEngine,
```
```java
```
```java
SLObjectItf
 outputMixObject,
```
```java
```
```java
SLObjectItf
 &audioPlayerObject){
```
```java
```
```java
//
 Android针对数据源的简单缓冲区队列定位器
```
```java
```
```java
SLDataLocator_AndroidSimpleBufferQueue
 dataSourceLocator = {
```
```java
```
```java
SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,
```
```java
//
 定位器类型
```
```java
```
```java
1
```
```java
// 缓冲区数
```
```java
```
```java
};
```
```java
```
```java
//
 PCM数据源格式
```
```java
```
```java
SLDataFormat_PCM
 dataSourceFormat = {
```
```java
```
```java
SL_DATAFORMAT_PCM,
```
```java
//
 格式类型
```
```java
```
```java
wav_get_channels(wav),
```
```java
//
 通道数
```
```java
```
```java
wav_get_rate(wav)
 *
```
```java
1000
```
```java
,
```
```java
//
 毫赫兹/秒的样本数
```
```java
```
```java
wav_get_bits(wav),
```
```java
//
 每个样本的位数
```
```java
```
```java
wav_get_bits(wav),
```
```java
//
 容器大小
```
```java
```
```java
SL_SPEAKER_FRONT_CENTER,
```
```java
//
 通道屏蔽
```
```java
```
```java
SL_BYTEORDER_LITTLEENDIAN
```
```java
//
 字节顺序
```
```java
```
```java
};
```
```java
```
```java
//
 数据源是含有PCM格式的简单缓冲区队列
```
```java
```
```java
SLDataSource
 dataSource = {
```
```java
```
```java
&dataSourceLocator,
```
```java
//
 数据定位器
```
```java
```
```java
&dataSourceFormat
```
```java
//
 数据格式
```
```java
```
```java
};
```
```java
```
```java
//
 针对数据接收器的输出混合定位器
```
```java
```
```java
SLDataLocator_OutputMix
 dataSinkLocator = {
```
```java
```
```java
SL_DATALOCATOR_OUTPUTMIX,
```
```java
//
 定位器类型
```
```java
```
```java
outputMixObject
```
```java
//
 输出混合
```
```java
```
```java
};
```
```java
```
```java
//
 数据定位器是一个输出混合
```
```java
```
```java
SLDataSink
 dataSink = {
```
```java
```
```java
&dataSinkLocator,
```
```java
//
 定位器
```
```java
```
```java
0
```
```java
// 格式
```
```java
```
```java
};
```
```java
```
```java
//
 需要的接口
```
```java
```
```java
SLInterfaceID
 interfaceIds[] = {
```
```java
```
```java
SL_IID_BUFFERQUEUE
```
```java
```
```java
};
```
```java
```
```java
//
 需要的接口，如果所需要的接口不要用，请求将失败
```
```java
```
```java
SLboolean
 requiredInterfaces[] = {
```
```java
```
```java
SL_BOOLEAN_TRUE
```
```java
//
 for SL_IID_BUFFERQUEUE
```
```java
```
```java
};
```
```java
```
```java
//
 创建音频播放器对象
```
```java
```
```java
SLresult
 result = (*engineEngine)->CreateAudioPlayer(
```
```java
```
```java
engineEngine,
```
```java
```
```java
&audioPlayerObject,
```
```java
```
```java
&dataSource,
```
```java
```
```java
&dataSink,
```
```java
```
```java
ARRAY_LEN(interfaceIds),
```
```java
```
```java
interfaceIds,
```
```java
```
```java
requiredInterfaces);
```
```java
}
```
```java
</android></sles></sles>
```
```
## 7.获得缓冲区队列接口Buffer Queue Interface
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//通过缓冲区队列接口对缓冲区进行排序播放
```
```java
```
```java
(*audioPlayerObject)->GetInterface(audioPlayerObject,SL_IID_BUFFERQUEUE,&andioPlayerBufferQueueItf);
```
```
## 8.注册音频播放器回调函数
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//当播放器完成对前一个缓冲区队列的播放时，回调函数会被调用，然后我们又继续读取音频数据，直到结束
```
```java
```
```java
//上下文，包裹参数方便再回调函数中使用
```
```java
```
```java
PlayerContext
 *ctx =
```
```java
new
```
```java
PlayerContext(wav,buffer,bufferSize);
```
```java
```
```java
(*andioPlayerBufferQueueItf)->RegisterCallback(andioPlayerBufferQueueItf,PlayerCallBack,ctx);
```
```
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//回调函数
```
```java
void
```
```java
PlayerCallBack(SLAndroidSimpleBufferQueueItf andioPlayerBufferQueue,
```
```java
void
```
```java
*context){
```
```java
```
```java
PlayerContext*
 ctx = (PlayerContext*)context;
```
```java
```
```java
//读取数据
```
```java
```
```java
ssize_t
 readSize = wav_read_data(ctx->wav,ctx->buffer,ctx->bufferSize);
```
```java
```
```java
if
```
```java
(
```
```java
0
```
```java
< readSize){
```
```java
```
```java
(*andioPlayerBufferQueue)->Enqueue(andioPlayerBufferQueue,ctx->buffer,readSize);
```
```java
```
```java
}
```
```java
else
```
```java
{
```
```java
```
```java
//destroy
 context
```
```java
```
```java
CloseWaveFile(ctx->wav);
```
```java
//关闭文件
```
```java
```
```java
delete
 ctx->buffer;
```
```java
//释放缓存
```
```java
```
```java
}
```
```java
}
```
```
## 9.获取Play Interface通过对SetPlayState函数来启动播放音乐
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
//一旦播放器被设置为播放状态，该音频播放器开始等待缓冲区排队就绪
```
```java
```
```java
(*audioPlayerObject)->GetInterface(audioPlayerObject,SL_IID_PLAY,&audioPlayInterface);
```
```java
```
```java
//设置播放状态
```
```java
```
```java
(*audioPlayInterface)->SetPlayState(audioPlayInterface,SL_PLAYSTATE_PLAYING);
```
```
## 10.开始，让第一个缓冲区入队
![这里写图片描述](http://www.2cto.com/uploadfile/Collfiles/20170203/2017020309514898.png)
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
PlayerCallBack(andioPlayerBufferQueueItf,ctx);
```
```
## 完整代码
[?](http://www.2cto.com/kf/201702/595008.html#)
```
```java
#include
```
```java
"com_dongnaoedu_jasonaudioplayer_AudioPlayer.h"
```
```java
extern
```
```java
"C"
```
```java
{
```
```java
#include
```
```java
"wavlib.h"
```
```java
}
```
```java
#include
 <sles opensles.h=
```
```java
""
```
```java
>
```
```java
#include
 <sles opensles_android.h=
```
```java
""
```
```java
>
```
```java
#include
```
```java
#include
```
```java
"CreateBufferQueueAudioPlayer.cpp"
```
```java
#define
 LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,
```
```java
"jason"
```
```java
,FORMAT,##__VA_ARGS__);
```
```java
#define
 LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,
```
```java
"jason"
```
```java
,FORMAT,##__VA_ARGS__);
```
```java
#define
 ARRAY_LEN(a) (sizeof(a) / sizeof(a[
```
```java
0
```
```java
]))
```
```java
WAV
 wav;
```
```java
//wav文件指针
```
```java
SLObjectItf
 engineObject;
```
```java
//引擎对象
```
```java
SLEngineItf
 engineInterface;
```
```java
//引擎接口
```
```java
SLObjectItf
 outputMixObject;
```
```java
//混音器
```
```java
SLObjectItf
 audioPlayerObject;
```
```java
//播放器对象
```
```java
SLAndroidSimpleBufferQueueItf
 andioPlayerBufferQueueItf;
```
```java
//缓冲器队列接口
```
```java
SLPlayItf
 audioPlayInterface;
```
```java
//播放接口
```
```java
unsigned
```
```java
char
```
```java
*buffer;
```
```java
//缓冲区
```
```java
size_t
 bufferSize;
```
```java
//缓冲区大小
```
```java
//上下文
```
```java
struct
 PlayerContext{
```
```java
```
```java
WAV
 wav;
```
```java
```
```java
unsigned
```
```java
char
```
```java
*buffer;
```
```java
```
```java
size_t
 bufferSize;
```
```java
```
```java
PlayerContext(WAV
 wav,
```
```java
```
```java
unsigned
```
```java
char
```
```java
*buffer,
```
```java
```
```java
size_t
 bufferSize){
```
```java
```
```java
this
```
```java
->wav
 = wav;
```
```java
```
```java
this
```
```java
->buffer
 = buffer;
```
```java
```
```java
this
```
```java
->bufferSize
 = bufferSize;
```
```java
```
```java
}
```
```java
};
```
```java
//打开文件
```
```java
WAV
 OpenWaveFile(JNIEnv *env,jstring jFileName){
```
```java
```
```java
const
```
```java
char
```
```java
*cFileName = env->GetStringUTFChars(jFileName,JNI_FALSE);
```
```java
```
```java
WAVError
 err;
```
```java
```
```java
WAV
 wav = wav_open(cFileName,WAV_READ,&err);
```
```java
```
```java
LOGI(
```
```java
"%d"
```
```java
,wav_get_bitrate(wav));
```
```java
```
```java
env->ReleaseStringUTFChars(jFileName,cFileName);
```
```java
```
```java
if
```
```java
(wav
 ==
```
```java
0
```
```java
){
```
```java
```
```java
LOGE(
```
```java
"%s"
```
```java
,wav_strerror(err));
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
wav;
```
```java
}
```
```java
//关闭文件
```
```java
void
```
```java
CloseWaveFile(WAV wav){
```
```java
```
```java
wav_close(wav);
```
```java
}
```
```java
//实现对象
```
```java
void
```
```java
RealizeObject(SLObjectItf object){
```
```java
```
```java
//非异步（阻塞）
```
```java
```
```java
(*object)->Realize(object,SL_BOOLEAN_FALSE);
```
```java
}
```
```java
//回调函数
```
```java
void
```
```java
PlayerCallBack(SLAndroidSimpleBufferQueueItf andioPlayerBufferQueue,
```
```java
void
```
```java
*context){
```
```java
```
```java
PlayerContext*
 ctx = (PlayerContext*)context;
```
```java
```
```java
//读取数据
```
```java
```
```java
ssize_t
 readSize = wav_read_data(ctx->wav,ctx->buffer,ctx->bufferSize);
```
```java
```
```java
if
```
```java
(
```
```java
0
```
```java
< readSize){
```
```java
```
```java
(*andioPlayerBufferQueue)->Enqueue(andioPlayerBufferQueue,ctx->buffer,readSize);
```
```java
```
```java
}
```
```java
else
```
```java
{
```
```java
```
```java
//destroy
 context
```
```java
```
```java
CloseWaveFile(ctx->wav);
```
```java
//关闭文件
```
```java
```
```java
delete
 ctx->buffer;
```
```java
//释放缓存
```
```java
```
```java
}
```
```java
}
```
```java
JNIEXPORT
```
```java
void
```
```java
JNICALL Java_com_dongnaoedu_jasonaudioplayer_AudioPlayer_play
```
```java
```
```java
(JNIEnv
 *env, jclass jthiz, jstring jFileName){
```
```java
```
```java
//1.打开文件
```
```java
```
```java
WAV
 wav = OpenWaveFile(env,jFileName);
```
```java
```
```java
//2.创建OpenSL
 ES引擎
```
```java
```
```java
//OpenSL
 ES在Android平台下默认是线程安全的，这样设置是为了为了兼容其他平台
```
```java
```
```java
SLEngineOption
 options[] = {
```
```java
```
```java
{(SLuint32)SL_ENGINEOPTION_THREADSAFE,
 (SLuint32)SL_BOOLEAN_TRUE}
```
```java
```
```java
};
```
```java
```
```java
slCreateEngine(&engineObject,ARRAY_LEN(engineObject),options,
```
```java
0
```
```java
,
```
```java
0
```
```java
,
```
```java
0
```
```java
);
```
```java
//没有接口
```
```java
```
```java
//实例化对象
```
```java
```
```java
//对象创建之后，处于未实例化状态，对象虽然存在但未分配任何资源，使用前先实例化（使用完之后destroy）
```
```java
```
```java
RealizeObject(engineObject);
```
```java
```
```java
//3.获取引擎接口
```
```java
```
```java
(*engineObject)->GetInterface(engineObject,SL_IID_ENGINE,&engineInterface);
```
```java
```
```java
//4.创建输出混音器
```
```java
```
```java
(*engineInterface)->CreateOutputMix(engineInterface,&outputMixObject,
```
```java
0
```
```java
,
```
```java
0
```
```java
,
```
```java
0
```
```java
);
```
```java
//没有接口
```
```java
```
```java
//实例化混音器
```
```java
```
```java
RealizeObject(outputMixObject);
```
```java
```
```java
//5.创建缓冲区保存读取到的音频数据库
```
```java
```
```java
//缓冲区的大小
```
```java
```
```java
bufferSize
 = wav_get_channels(wav) * wav_get_rate(wav) * wav_get_bits(wav);
```
```java
```
```java
buffer
 =
```
```java
new
```
```java
unsigned
```
```java
char
```
```java
[bufferSize];
```
```java
```
```java
//6.创建带有缓冲区队列的音频播放器
```
```java
```
```java
CreateBufferQueueAudioPlayer(wav,engineInterface,outputMixObject,audioPlayerObject);
```
```java
```
```java
//实例化音频播放器
```
```java
```
```java
RealizeObject(audioPlayerObject);
```
```java
```
```java
//7.获得缓冲区队列接口Buffer
 Queue Interface
```
```java
```
```java
//通过缓冲区队列接口对缓冲区进行排序播放
```
```java
```
```java
(*audioPlayerObject)->GetInterface(audioPlayerObject,SL_IID_BUFFERQUEUE,&andioPlayerBufferQueueItf);
```
```java
```
```java
//8.注册音频播放器回调函数
```
```java
```
```java
//当播放器完成对前一个缓冲区队列的播放时，回调函数会被调用，然后我们又继续读取音频数据，直到结束
```
```java
```
```java
//上下文，包裹参数方便再回调函数中使用
```
```java
```
```java
PlayerContext
 *ctx =
```
```java
new
```
```java
PlayerContext(wav,buffer,bufferSize);
```
```java
```
```java
(*andioPlayerBufferQueueItf)->RegisterCallback(andioPlayerBufferQueueItf,PlayerCallBack,ctx);
```
```java
```
```java
//9.获取Play
 Interface通过对SetPlayState函数来启动播放音乐
```
```java
```
```java
//一旦播放器被设置为播放状态，该音频播放器开始等待缓冲区排队就绪
```
```java
```
```java
(*audioPlayerObject)->GetInterface(audioPlayerObject,SL_IID_PLAY,&audioPlayInterface);
```
```java
```
```java
//设置播放状态
```
```java
```
```java
(*audioPlayInterface)->SetPlayState(audioPlayInterface,SL_PLAYSTATE_PLAYING);
```
```java
```
```java
//10.开始，让第一个缓冲区入队
```
```java
```
```java
PlayerCallBack(andioPlayerBufferQueueItf,ctx);
```
```java
```
```java
//关闭文件
```
```java
```
```java
//CloseWaveFile(wav);
```
```java
}
```
```
