# 给RGB加上BMP文件头 - 建建的博客 - CSDN博客
2017年03月20日 09:49:58[纪建](https://me.csdn.net/u013898698)阅读数：224
实习时需要从相机取出的纯RGB数据封装上BMP文件头
需要将摄像头采集到的图像数据（纯净的RGB，或BGR数据）加上文件头后暂存在内存中
如若写入文件仅需将memcpy换成fwrite即可。
**[cpp]**[view
 plain](http://blog.csdn.net/libin88211/article/details/36186697#)[copy](http://blog.csdn.net/libin88211/article/details/36186697#)
![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/588031/fork)
- #ifndef RGB2BMP_H
- #define RGB2BMP_H
- ///为拍摄的RGB数据加上BMP文件头
- ///作者：
- /// 2014.6.25
- ///
- typedef unsigned charBYTE;  
- typedef unsigned shortWORD;  
- // BMP图像各部分说明如下
- /***********
-     第一部分    位图文件头
- 该结构的长度是固定的，为14个字节，各个域的依次如下：
-     2byte   ：文件类型，必须是0x4d42，即字符串"BM"。
-     4byte   ：整个文件大小
-     4byte   ：保留字，为0
-     4byte   ：从文件头到实际的位图图像数据的偏移字节数。
- *************/
- typedefstruct
- {    long imageSize;  
- long blank;  
- long startPosition;  
- }BmpHead;  
- /*********************
- /*********************
- 第二部分    位图信息头
- 该结构的长度也是固定的，为40个字节，各个域的依次说明如下：
-     4byte   ：本结构的长度，值为40
-     4byte   ：图像的宽度是多少象素。
-     4byte   ：图像的高度是多少象素。
-     2Byte   ：必须是1。
-     2Byte   ：表示颜色时用到的位数，常用的值为1(黑白二色图)、4(16色图)、8(256色图)、24(真彩色图)。
-     4byte   ：指定位图是否压缩，有效值为BI_RGB，BI_RLE8，BI_RLE4，BI_BITFIELDS。Windows位图可采用RLE4和RLE8的压缩格式，BI_RGB表示不压缩。
-     4byte   ：指定实际的位图图像数据占用的字节数，可用以下的公式计算出来：
-      图像数据 = Width' * Height * 表示每个象素颜色占用的byte数(即颜色位数/8,24bit图为3，256色为1）
-      要注意的是：上述公式中的biWidth'必须是4的整数倍(不是biWidth，而是大于或等于biWidth的最小4的整数倍)。
-      如果biCompression为BI_RGB，则该项可能为0。
-     4byte   ：目标设备的水平分辨率。
-     4byte   ：目标设备的垂直分辨率。
-     4byte   ：本图像实际用到的颜色数，如果该值为0，则用到的颜色数为2的(颜色位数)次幂,如颜色位数为8，2^8=256,即256色的位图
-     4byte   ：指定本图像中重要的颜色数，如果该值为0，则认为所有的颜色都是重要的。
- ***********************************/
- typedefstruct
- 
- {  
- long    Length;  
- long    width;  
- long    height;  
- WORD    colorPlane;  
- WORD    bitColor;  
- long    zipFormat;  
- long    realSize;  
- long    xPels;  
- long    yPels;  
- long    colorUse;  
- long    colorImportant;  
- 
- }InfoHead;  
- /***************************
- /***************************
-     第三部分    调色盘结构  颜色表
-     对于256色BMP位图，颜色位数为8，需要2^8 = 256个调色盘；
-     对于24bitBMP位图，各象素RGB值直接保存在图像数据区，不需要调色盘，不存在调色盘区
-     rgbBlue：   该颜色的蓝色分量。
-     rgbGreen：  该颜色的绿色分量。
-     rgbRed：    该颜色的红色分量。
-     rgbReserved：保留值。
- *****************************/
- typedefstruct
- {         BYTE   rgbBlue;  
- BYTE   rgbGreen;  
- BYTE   rgbRed;  
- BYTE   rgbReserved;  
- 
- }RGBMixPlate;  
- /*********************
- /*********************
- //输入
- // rgb_buffer: RGB24缓冲区指针
- // nWidth    : 图片宽度
- // nHeight   : 图片高度
- // fp2       : 指向加bmp头后的数据
- **************************/
- int RGB2BMP1(char *rgb_buffer,int nWidth,int nHeight,char*fp2)  
- {  
-      BmpHead m_BMPHeader;  
- char bfType[2]={'B','M'};  
-      m_BMPHeader.imageSize=3*nWidth*nHeight+54;  
-      m_BMPHeader.blank=0;  
-      m_BMPHeader.startPosition=54;  
- char* temp=fp2;  
-      memcpy(fp2,bfType,2);  
-      fp2+=sizeof(bfType);  
- 
-      memcpy(fp2,&m_BMPHeader,sizeof(m_BMPHeader.imageSize));  
-      fp2+=sizeof(m_BMPHeader.imageSize);  
- 
- 
-      memcpy(fp2,&m_BMPHeader.blank,sizeof(m_BMPHeader.blank));  
-      fp2+=sizeof(m_BMPHeader.blank);  
- 
- 
-      memcpy(fp2,&m_BMPHeader.startPosition,sizeof(m_BMPHeader.startPosition));  
-      fp2+=sizeof(m_BMPHeader.startPosition);  
- 
- 
-      InfoHead  m_BMPInfoHeader;  
-      m_BMPInfoHeader.Length=40;  
-      m_BMPInfoHeader.width=nWidth;  
-      m_BMPInfoHeader.height=-nHeight;  
-      m_BMPInfoHeader.colorPlane=1;  
-      m_BMPInfoHeader.bitColor=24;  
-      m_BMPInfoHeader.zipFormat=0;  
-      m_BMPInfoHeader.realSize=3*nWidth*nHeight;  
-      m_BMPInfoHeader.xPels=0;  
-      m_BMPInfoHeader.yPels=0;  
-      m_BMPInfoHeader.colorUse=0;  
-      m_BMPInfoHeader.colorImportant=0;  
- 
-      memcpy(fp2,&m_BMPInfoHeader.Length,sizeof(m_BMPInfoHeader.Length));  
-       fp2+=sizeof(m_BMPInfoHeader.Length);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.width,sizeof(m_BMPInfoHeader.width));  
-       fp2+=sizeof(m_BMPInfoHeader.width);  
- 
-       memcpy(fp2,&m_BMPInfoHeader.height,sizeof(m_BMPInfoHeader.height));  
-       fp2+=sizeof(m_BMPInfoHeader.height);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.colorPlane,sizeof(m_BMPInfoHeader.colorPlane));  
-      fp2+=sizeof(m_BMPInfoHeader.colorPlane);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.bitColor,sizeof(m_BMPInfoHeader.bitColor));  
-      fp2+=sizeof(m_BMPInfoHeader.bitColor);  
- 
- 
-      memcpy(fp2,&m_BMPInfoHeader.zipFormat,sizeof(m_BMPInfoHeader.zipFormat));  
-      fp2+=sizeof(m_BMPInfoHeader.zipFormat);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.realSize,sizeof(m_BMPInfoHeader.realSize));  
-      fp2+=sizeof(m_BMPInfoHeader.realSize);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.xPels,sizeof(m_BMPInfoHeader.xPels));  
-      fp2+=sizeof(m_BMPInfoHeader.xPels);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.yPels,sizeof(m_BMPInfoHeader.yPels));  
-      fp2+=sizeof(m_BMPInfoHeader.yPels);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.colorUse,sizeof(m_BMPInfoHeader.colorUse));  
-      fp2+=sizeof(m_BMPInfoHeader.colorUse);  
- 
-      memcpy(fp2,&m_BMPInfoHeader.colorImportant,sizeof(m_BMPInfoHeader.colorImportant));  
-      fp2+=sizeof(m_BMPInfoHeader.colorImportant);  
- 
-      memcpy(fp2,rgb_buffer,3*nWidth*nHeight);  
-      fp2=temp;  
- return 1;  
- }  
- 
- #endif // RGB2BMP_H
- 
