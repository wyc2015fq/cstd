# 着色器 - 建建的博客 - CSDN博客
2017年07月17日 12:08:58[纪建](https://me.csdn.net/u013898698)阅读数：229
### 背景
从本教程中，我们将实现使用着色器完成每一个效果和技术。着色器是3D图形的现代化方式。在某种程度上，您可以声称这是一个退后步骤，因为固定功能管道提供的大多数3D功能，并且要求开发人员仅指定配置参数（照明属性，旋转值等）现在必须由开发人员（通过着色器），但是这种可编程性能够实现极大的灵活性和创新性。
OpenGL可编程管道可以如下显示：
![](http://ogldev.atspace.co.uk/www/tutorial04/pipeline.png)
顶点处理器负责在通过流水线的每个顶点上执行顶点着色器（其数量根据绘图调用的参数确定）。顶点着色器不了解渲染的图元的拓扑。另外，您不能舍弃顶点处理器中的顶点。每个顶点进入顶点处理器一次，进行转换并继续沿管道。
下一个阶段是几何处理器。在这个阶段，关于完整原始（即其所有顶点）以及相邻顶点的知识都被提供给着色器。这使得技术必须考虑顶点本身旁边的附加信息。几何着色器还具有将输出拓扑切换到与绘图调用中选择的拓扑不同的拓扑。例如，您可以提供一个点列表，并从每个点（称为广告牌的技术）生成两个三角形（即四边形）。此外，您可以选择为每个几何着色器调用发出多个顶点，从而根据您选择的输出拓扑生成多个基元。
管子的下一个阶段是剪刀。这是一个具有直接任务的固定功能单元，它将原始图像剪辑到上一个教程中看到的标准化框。它还将它们剪辑到近Z和远Z平面。还可以选择提供用户剪辑平面，并对其进行剪辑剪辑。现在，已经存储在剪辑器中的顶点的位置被映射到屏幕空间坐标，并且光栅化器根据它们的拓扑将它们呈现给屏幕。例如，在三角形的情况下，这意味着找出三角形内的所有点。对于每个点，光栅化器调用片段处理器。在这里，您可以选择通过从纹理采样或使用任何您想要的技术来确定像素的颜色。
三个可编程阶段（顶点，几何和片段处理器）是可选的。如果您不绑定着色器，那么将执行一些默认功能。
着色器管理与C / C ++程序创建非常相似。首先，您将着色器文本写入您的程序。这可以通过简单地将文本包含在源代码本身的字符数组中，或者通过从外部文本文件（再次成为字符数组）来加载。然后你将着色器逐个编译成着色器对象。之后，您将着色器链接到单个程序并将其加载到GPU中。链接着色器使驾驶员有机会根据他们的关系修剪着色器并进行优化。例如，您可以将发出法线的顶点着色器与忽略它的片段着色器配对。在这种情况下，驱动程序中的GLSL编译器可以删除着色器的正常相关功能，并可以更快地执行顶点着色器。如果该着色器后来与使用法则的片段着色器配对，则链接另一个程序将生成不同的顶点着色器。
### 来源walkthru
`GLuint ShaderProgram = glCreateProgram();`
我们通过创建程序对象来开始设置着色器的过程。我们将所有的着色器链接到这个对象中。
`GLuint ShaderObj = glCreateShader(ShaderType);`
我们使用上述调用创建两个着色器对象。其中一个着色器类型为GL_VERTEX_SHADER，另一个为GL_FRAGMENT_SHADER。指定着色器源并编译着色器的过程对于两者都是相同的。
```
const GLchar* p[1];
p[0] = pShaderText;
GLint Lengths[1];
Lengths[0]= strlen(pShaderText);
glShaderSource(ShaderObj, 1, p, Lengths);
```
在编译着色器对象之前，我们必须指定其源代码。函数glShaderSource将着色器对象作为参数，为您提供指定源的灵活性。源可以分布在多个字符数组中，您将需要提供一个指向这些数组的指针数组以及整数数组，其中每个时隙包含相应字符数组的长度。为了简单起见，我们为整个着色器源使用单个字符数组，我们只使用一个插槽来指向源的指针以及它的长度。调用的第二个参数是两个数组中的槽数（在本例中只有1个）。
`glCompileShader(ShaderObj);`
编译着色器很容易
```
GLint success;
glGetShaderiv(ShaderObj, GL_COMPILE_STATUS, &success);
if (!success) {
    GLchar InfoLog[1024];
    glGetShaderInfoLog(ShaderObj, sizeof(InfoLog), NULL, InfoLog);
    fprintf(stderr, "Error compiling shader type %d: '%s'\n", ShaderType, InfoLog);
}
```
...但是，您通常会收到一些编译错误，正如预期的那样。上面的代码获取编译状态并显示编译器遇到的所有错误。
`glAttachShader(ShaderProgram, ShaderObj);`
最后，我们将编译的着色器对象附加到程序对象。这与在makefile中链接的对象列表非常相似。由于我们在这里没有makefile，我们以编程方式模拟这个行为。只有附加的对象才能参与链接过程。
`glLinkProgram(ShaderProgram);`
在编译所有着色器对象并将其附加到程序之后，我们可以将其链接起来。注意，链接程序后，您可以通过调用glDetachShader和glDeleteShader来消除中间着色器对象的每一个。OpenGL驱动程序在其生成的大多数对象上维护引用计数。如果一个着色器对象被创建，然后被删除，驱动程序将会摆脱它，但是如果它连接到一个程序调用glDeleteShader将只标记它删除，你还需要调用glDetachShader，使其引用计数将下降到零它将被删除。
```
glGetProgramiv(ShaderProgram, GL_LINK_STATUS, &Success);
if (Success == 0) {
    glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog);
    fprintf(stderr, "Error linking shader program: '%s'\n", ErrorLog);
}
```
请注意，我们检查程序相关的错误（如链接错误）有点不同于与着色器相关的错误。而不是glGetShaderiv，我们使用glGetProgramiv，而不是glGetShaderInfoLog，我们使用glGetProgramInfoLog。
`glValidateProgram(ShaderProgram);`
您可能会问自己为什么在成功关联程序后需要验证程序。不同之处在于，链接根据着色器的组合检查错误，而上面的调用检查程序是否可以在给定当前管道状态的情况下执行。在具有多个着色器和大量状态更改的复杂应用程序中，最好在每次绘制调用之前进行验证。在我们简单的应用程序中，我们只检查一次。此外，您可能只想在开发过程中进行此检查，并避免最终产品中的这种开销。
`glUseProgram(ShaderProgram);`
最后，要使用链接的着色器程序，请使用上面的调用将其设置为流水线状态。通过调用具有NULL的glUseProgram，这个程序将保持对所有绘制调用有效，直到用另一个替换或显式地禁用其使用（并启用固定功能管道）。如果您创建了一个仅包含一种着色器的着色器程序，则其他阶段将使用其默认的固定功能进行操作。
我们完成了与着色器管理相关的OpenGL调用。本教程的其余部分涉及顶点和片段着色器的内容（包含在“pVS”和“pFS”变量中）。
`#version 330`
这告诉编译器，我们正在针对GLSL的3.3版本。如果编译器不支持它，它将发出错误。
`layout (location = 0) in vec3 Position;`
此语句显示在顶点着色器中。它声明一个顶点特定属性，它是3个浮点的向量，在着色器中称为“Position”。“顶点特定”意味着对于GPU中的着色器的每次调用，将提供来自缓冲区的新顶点的值。语句的第一部分，layout（location
 = 0）在缓冲区中创建属性名称和属性之间的绑定。对于我们的顶点包含几个属性（位置，正常，纹理坐标等）的情况，这是必需的。我们必须让编译器知道缓冲区中顶点中的哪个属性必须映射到着色器中声明的属性。有两种方法可以做到这一点。我们可以按照我们这里（为零）明确设置它。在这种情况下，我们可以在我们的应用程序中使用硬编码值（我们使用第一个参数来调用glVertexAttributePointer）。或者我们可以把它留下来（并且简单地在着色器中声明“在vec3位置”），然后使用glGetAttribLocation在运行时从应用程序查询位置。在这种情况下，我们需要将返回的值提供给glVertexAttributePointer，而不是使用硬编码值。我们在这里选择简单的方法，但对于更复杂的应用程序，最好让编译器确定属性索引并在运行时查询它们。这使得更容易地整合来自多个源的着色器，而不需要将它们调整到缓冲区布局。或者我们可以把它留下来（并且简单地在着色器中声明“在vec3位置”），然后使用glGetAttribLocation在运行时从应用程序查询位置。在这种情况下，我们需要将返回的值提供给glVertexAttributePointer，而不是使用硬编码值。我们在这里选择简单的方法，但对于更复杂的应用程序，最好让编译器确定属性索引并在运行时查询它们。这使得更容易地整合来自多个源的着色器，而不需要将它们调整到缓冲区布局。或者我们可以把它留下来（并且简单地在着色器中声明“在vec3位置”），然后使用glGetAttribLocation在运行时从应用程序查询位置。在这种情况下，我们需要将返回的值提供给glVertexAttributePointer，而不是使用硬编码值。我们在这里选择简单的方法，但对于更复杂的应用程序，最好让编译器确定属性索引并在运行时查询它们。这使得更容易地整合来自多个源的着色器，而不需要将它们调整到缓冲区布局。在这种情况下，我们需要将返回的值提供给glVertexAttributePointer，而不是使用硬编码值。我们在这里选择简单的方法，但对于更复杂的应用程序，最好让编译器确定属性索引并在运行时查询它们。这使得更容易地整合来自多个源的着色器，而不需要将它们调整到缓冲区布局。在这种情况下，我们需要将返回的值提供给glVertexAttributePointer，而不是使用硬编码值。我们在这里选择简单的方法，但对于更复杂的应用程序，最好让编译器确定属性索引并在运行时查询它们。这使得更容易地整合来自多个源的着色器，而不需要将它们调整到缓冲区布局。
`void main()`
您可以通过将多个着色器对象链接在一起来创建着色器。然而，每个着色器阶段（VS，GS，FS）只能有一个主要功能，作为着色器的入口点。例如，您可以创建具有多个功能的照明库，并将其与着色器链接，只要其中的任何函数都不会被命名为“主”。
`gl_Position = vec4(0.5 * Position.x, 0.5 * Position.y, Position.z, 1.0);`
这里我们对传入的顶点位置进行硬编码转换。我们将X和Y值削减一半，保持Z不变。'gl_Position'是一个特殊的内置变量，它应该包含均匀（包含X，Y，Z和W分量）顶点位置。光栅化器将寻找该变量，并将其用作屏幕空间中的位置（再进行几次转换）。将X和Y值削减一半意味着我们将看到一个三角形，它是上一个教程中三角形的四分之一。请注意，我们将W设置为1.0。这对于正确显示三角形是非常重要的。从3D到2D的投影实际上是在两个独立的阶段完成的。首先，您需要将所有顶点乘以投影矩阵（我们将在几个教程中开发），然后GPU在到达光栅化器之前自动执行所谓的“透视分割”到position属性。这意味着它通过W分量将gl_Position的所有组件分割。在本教程中，我们还没有在顶点着色器中做任何投影，但是透视分割阶段是我们无法禁用的。无论我们从顶点着色器输出的gl_Position值将由HW使用其W分量除。我们需要记住，否则我们不会得到我们期待的结果。为了规避透视分割的影响，我们将W设置为1.0。分1。
如果一切正常，三个顶点（-0.5，-0.5），（0.5，-0.5）和（0.0,0.5）到达光栅化器。裁剪器不需要做任何事情，因为所有顶点都在标准化框内。这些值映射到屏幕空间坐标，并且光栅化器开始在三角形内的所有点上运行。对于每个点，片段着色器被执行。从片段着色器获取以下着色器代码。
`out vec4 FragColor;`
通常片段着色器的作业是确定片段（像素）的颜色。此外，片段着色器可以完全丢弃像素或改变其Z值（这将影响后续Z测试的结果）。输出颜色是通过声明上述变量来完成的。四个分量表示R，G，B和A（对于α）。您设置到此变量中的值将由光栅化器接收并自动写入帧缓冲区。
`FragColor = vec4(1.0, 0.0, 0.0, 1.0);`
在以前的几个教程中，没有片段着色器，所以所有内容都以默认的白色颜色绘制。这里我们将FragColor设置为红色。
有关此主题的更多信息，请查看[Frahaan
 Hussain](https://www.youtube.com/watch?v=aA112viAx7c&list=PLRtjMdoYXLf6zUMDJVRZYV-6g6n62vet8&index=8)的以下[视频教程](https://www.youtube.com/watch?v=aA112viAx7c&list=PLRtjMdoYXLf6zUMDJVRZYV-6g6n62vet8&index=8)。
