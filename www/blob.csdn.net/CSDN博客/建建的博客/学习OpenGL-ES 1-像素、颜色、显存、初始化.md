# 学习OpenGL-ES: 1 - 像素、颜色、显存、初始化 - 建建的博客 - CSDN博客
2018年02月24日 18:06:40[纪建](https://me.csdn.net/u013898698)阅读数：179
## [学习OpenGL-ES: 1 - 像素、颜色、显存、初始化](http://www.cnblogs.com/kiffa/archive/2013/02/21/2920106.html)
## 1，隐喻
思考一下画家绘画的过程，首先要有一名懂得各种绘画技艺的画家，然后他需要一张画布，一些笔，一些颜料，一些辅助工具（尺、圆规、模板、橡皮、调色板等等），然后他在画布上绘制第一幅画，完成之后展示给人们看；在人们观赏第一幅画的时候，他可以在第二张画布上绘制第二幅画，绘制完成后收回第一幅画，将第二幅画展现给人们看；接着使用工具擦除第一幅画，在同一张画布上绘制第三幅画；周而复始，人们便看到了一幅接一幅的画。
对比OpenGL ES，各要素的对应关系大体如下：
画家：我们
笔、颜料、辅助工具：OpenGL ES API
画布：？？？ 
## 2，画布、像素、显存 
画布是画面的载体，而计算机图形总是展现在屏幕的某个矩形范围内，这个矩形就是其载体。我们用像素作为基本单位来描述这个矩形的大小，像素是屏幕显示画面的最小单位，可以近似的认为是一个有特定颜色特定大小（面积）的点。256 * 128表明这个矩形的长为256像素，高为128像素，这也是屏幕分辨率的定义（屏幕可视为一个最大的显示矩形）。所谓绘制就是用不同颜色的像素填充矩形，矩形的本质是一块内存（一般位于GPU上，称为显存），填充像素的本质就是向这块内存写入数据，这些数据描述了每个像素应该是什么颜色。（大部分显示器上）计算机画面最终都是作为像素点阵呈现的。
屏幕上一个10*10的矩形，对应着一块10*10的显存，总共有10*10 = 100个像素，那么这块显存有多大呢？这要看每个像素有多大，假设一个像素占用2个字节，那么显示10*10矩形所需用到的显存就是10*10*2=200字节。 如果一个像素占用4个字节，那么显存大小就是10*10*4 = 400字节。
## 3，颜色 
那么一个像素是如何描述某种特定的颜色的？有很多种方式，这里我们只谈最通用的RGB颜色模型。
人眼所看到的颜色本质上是光子撞击人眼产生，所有颜色都可以用RGB三原色(红、绿、蓝)按一定强度比例混合而成，显示器屏幕所展现的各种颜色，是所有像素的集合，而每个像素都会发出RGB三种颜色混合的光，只要通过某种特定方式控制这三种颜色的比例和光的强度，就达到了控制颜色显示的目的。
假设一个像素为两个字节，我们可以给这个像素任意一个值，比如0x3826，最终硬件驱动将会解析这个数值，将其转化为RGB的每个颜色分量的强度，按此激发屏幕像素，我们就看到了特定的一种颜色。因此这里需要有个约定，类似：0x1000代表100%的R，0%的G和B。这种约定称之为像素（颜色）格式（Pixel/Color Format)。 
Android中的像素格式在 PixelFormat类中描述，包括RGBA_8888，RGB_565等。这里的RGB_565表示每个像素有5个二进制位(bit)来表示R, 6 bits表示G，5 bits表示B，每个像素占用5+6+5 = 16 bits = 2字节。数值越大，表明对应的颜色（光）分量越强。比如：0x0000(RGB_565)代表没有任何颜色，即黑色。
## 4，绘制 
所以计算机绘画的本质就是选择一种像素格式，申请一块显存（画布），填充像素（颜色），绘制完成之后，通知计算机显示到屏幕上（按比例发射RGB光），最终就看到了所绘制的画面。之所以要先选择像素格式，是因为无论是所申请显存的大小，还是硬件驱动解析显存的方式，都是由像素格式决定的。
## 5，环境初始化 
 因此，在使用OpenGL ES绘制之前，所需要做的初始化工作就比较清晰了：
a, 选择像素格式。
b, 申请显存。
除此之外，还有一些初始化工作要做：
c, 选择显示设备(有些设备可能有不只一个显示器）；
d, 选择某些特性，比如如果你打算画中国水墨画，你需要额外指定宣纸和毛笔。 
e, 创建上下文（Context），上下文本质上是一组状态的集合，描述了在某个特定时刻系统的状态， 用于处理暂停、恢复、销毁、重建等情况；
f, 指定当前的环境为绘制环境；比如你可能有多个环境，每个环境有不同参数，你需要在这些环境中切换（想象一下同时在两个显示器上绘制不同的画面），所以必须指定当前的绘制环境。
完成上述所有工作之后，就可以开始使用OpenGL ES API进行绘制了（所有器具准备完毕，画家开始作画）。 
## 6, EGL 
 由于像素格式、显示设备这些涉及到硬件，不同系统之间可能差异很大（比如有的系统不支持RGB_565)，维护OpenGL ES 的khronos组织使用一个专门的抽象层（想起了一句名言 - 某种意义上的冷笑话：所有的计算机问题都可以通过添加一个抽象层来解决）来处理不同系统间的适配，从而保证了OpenGL ES本身的平台无关性，这个抽象层就是EGL.
权威资料见这里：[http://www.khronos.org/egl](http://www.khronos.org/egl)
EGL用来进行环境的初始化，包含了上面所描述的种种。 
关于EGL的详细说明将在下一篇文章中讲述，以Android为例。            
