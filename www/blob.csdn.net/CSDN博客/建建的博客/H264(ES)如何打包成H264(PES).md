# H264(ES)如何打包成H264(PES) - 建建的博客 - CSDN博客
2017年03月22日 14:32:02[纪建](https://me.csdn.net/u013898698)阅读数：1832
# **  H264(ES)如何打包成H264(PES)**
一直在网上搜集各种资料，心累啊！下面由九把锁为你们阐述TS和H264之间不为人知的关系，还真是比较复杂。
# **一、总的大致关系图**
这个我也不知道是在哪个CSDN高手那弄来的图，帮了我很大的忙，上图时间到：
![](https://img-blog.csdn.net/20150720153932949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
# 二、如何由ES数据封装成PES数据
**1****、如何提取一帧ES数据, 就是这么简单，So Easy...**
**[cpp]**[view
 plain](http://blog.csdn.net/nine_locks/article/details/46968995#)[copy](http://blog.csdn.net/nine_locks/article/details/46968995#)
[print](http://blog.csdn.net/nine_locks/article/details/46968995#)[?](http://blog.csdn.net/nine_locks/article/details/46968995#)
- #include "stdafx.h"
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
- 
- typedefstruct
- {  
- int startcodeprefix_len;      //! 4 for parameter sets and first slice in picture, 3 for everything else (suggested)
-   unsigned len;                 //! Length of the NAL unit (Excluding the start code, which does not belong to the NALU)
-   unsigned max_size;            //! Nal Unit Buffer size
- 
- int forbidden_bit;            //! should be always FALSE
- int nal_reference_idc;        //! NALU_PRIORITY_xxxx
- int nal_unit_type;            //! NALU_TYPE_xxxx   
- 
- char *buf;                    //! contains the first byte followed by the EBSP
-   unsigned short lost_packets;  //! true, if packet loss is detected
- } NALU_t;  
- 
- FILE *bits = NULL;                //!< the bit stream file
- staticint FindStartCode2 (unsigned char *Buf);//查找开始字符0x000001
- staticint FindStartCode3 (unsigned char *Buf);//查找开始字符0x00000001
- //static bool flag = true;
- staticint info2=0, info3=0;  
- 
- 
- NALU_t *AllocNALU(int buffersize)  
- {  
-   NALU_t *n;  
- 
- if ((n = (NALU_t*)calloc (1, sizeof (NALU_t))) == NULL)  
-   {  
-       printf("AllocNALU: n");  
-       exit(0);  
-   }  
- 
-   n->max_size=buffersize;  
- 
- if ((n->buf = (char*)calloc (buffersize, sizeof (char))) == NULL)  
-   {  
-     free (n);  
-     printf ("AllocNALU: n->buf");  
-     exit(0);  
-   }  
- 
- return n;  
- }  
- 
- void FreeNALU(NALU_t *n)  
- {  
- if (n)  
-   {  
- if (n->buf)  
-     {  
-       free(n->buf);  
-       n->buf=NULL;  
-     }  
-     free (n);  
-   }  
- }  
- 
- void OpenBitstreamFile (char *fn)  
- {  
- if (NULL == (bits=fopen(fn, "rb")))  
-   {  
-       printf("open file error\n");  
-       exit(0);  
-   }  
- }  
- 
- int GetAnnexbNALU (NALU_t *nalu)  
- {  
- int pos = 0;  
- int StartCodeFound, rewind;  
-   unsigned char *Buf;  
- 
- if ((Buf = (unsigned char*)calloc (nalu->max_size , sizeof(char))) == NULL)   
-       printf ("GetAnnexbNALU: Could not allocate Buf memory\n");  
- 
-   nalu->startcodeprefix_len=3;//初始化码流序列的开始字符为3个字节
- 
- if (3 != fread (Buf, 1, 3, bits))//从码流中读3个字节
-    {  
-     free(Buf);  
- return 0;  
-    }  
-    info2 = FindStartCode2 (Buf);//判断是否为0x000001 
- if(info2 != 1) {//如果不是，再读一个字节
- if(1 != fread(Buf+3, 1, 1, bits))//读一个字节
-     {  
-      free(Buf);  
- return 0;  
-     }  
-     info3 = FindStartCode3 (Buf);//判断是否为0x00000001
- if (info3 != 1)//如果不是，返回-1
-     {   
-      free(Buf);  
- return -1;  
-     }  
- else {//如果是0x00000001,得到开始字符为4个字节
-      pos = 4;  
-      nalu->startcodeprefix_len = 4;  
-     }  
-    }  
- 
- else{//如果是0x000001,得到开始字符为3个字节
-     nalu->startcodeprefix_len = 3;  
-     pos = 3;  
-    }  
- 
-    StartCodeFound = 0;//查找下一个开始字符的标志位
-    info2 = 0;  
-    info3 = 0;  
- 
- while (!StartCodeFound)  
-   {  
- if (feof (bits))//判断是否到了文件尾
-     {  
-       nalu->len = (pos-1)-nalu->startcodeprefix_len;  
-       memcpy (nalu->buf, &Buf[nalu->startcodeprefix_len], nalu->len);       
-       nalu->forbidden_bit = (nalu->buf[0]>>7) & 1;  
-       nalu->nal_reference_idc = (nalu->buf[0]>>5) & 3;  
-       nalu->nal_unit_type = (nalu->buf[0]) & 0x1f;  
-       free(Buf);  
- return pos-1;  
-     }  
-     Buf[pos++] = fgetc (bits);//读一个字节到BUF中
-     info3 = FindStartCode3(&Buf[pos-4]);//判断是否为0x00000001
- if(info3 != 1)  
-       info2 = FindStartCode2(&Buf[pos-3]);//判断是否为0x000001
-     StartCodeFound = (info2 == 1 || info3 == 1);  
-   }  
- //flag = false;
- 
- 
- // Here, we have found another start code (and read length of startcode bytes more than we should
- // have.  Hence, go back in the file
-   rewind = (info3 == 1)? -4 : -3;  
- 
- if (0 != fseek (bits, rewind, SEEK_CUR))//把文件指针向后退开始字节的字节数
-   {  
-     free(Buf);  
-     printf("GetAnnexbNALU: Cannot fseek in the bit stream file");  
-   }  
- 
- // Here the Start code, the complete NALU, and the next start code is in the Buf.  
- // The size of Buf is pos, pos+rewind are the number of bytes excluding the next
- // start code, and (pos+rewind)-startcodeprefix_len is the size of the NALU
- 
-   nalu->len = (pos+rewind)-nalu->startcodeprefix_len;  
-   memcpy (nalu->buf, &Buf[nalu->startcodeprefix_len], nalu->len);  
- 
-   nalu->forbidden_bit = nalu->buf[0] & 0x80; //(nalu->buf[0]>>7) & 1;
-   nalu->nal_reference_idc = nalu->buf[0] & 0x60; //(nalu->buf[0]>>5) & 3;
-   nalu->nal_unit_type = (nalu->buf[0]) & 0x1f;  
- /*write by qiuliangbin in 2015-7-18 where is rongle changsha*/
- if (nalu->nal_unit_type == 7)//7 序列参数集 8个字节
-   {  
-         printf("\t NALU->RBSP->SPS->profile_idc(8):%d\n",nalu->buf[1]);  
-         printf("\t constraint_set0_flag(1):%d\n",(nalu->buf[2]>>7) & 1);  
-         printf("\t constraint_set1_flag(1):%d\n",(nalu->buf[2]>>6) & 1);  
-         printf("\t constraint_set2_flag(1):%d\n",(nalu->buf[2]>>5) & 1);  
-         printf("\t constraint_set3_flag(1):%d\n",(nalu->buf[2]>>4) & 1);  
-         printf("\t reserved_zero_4bits(4):%d\n",(nalu->buf[2]>>0) & 0x0f);  
-         printf("\t level_idc(8):%d\n",nalu->buf[3]);  
-         printf("\t seq_parameter_set_id(UE(V)):uvlC(1):%d\n",(nalu->buf[4]>>7) & 1);//表示往后的数据忽略掉最高位
- //  根据profile_idc忽略掉一部分。
-         printf("\t log2_max_frame_num_minus4(ue(v):len=5,value=%d\n",(nalu->buf[4]>>5) & 0x1f);  
-         printf("\t pic_order_cnt_type(ue(v)):len=3,value=%d\n",((nalu->buf[4]) & 0x03)<<1);  
- //  根据pic_order_cnt_type忽略几个参数
-         printf("\t num_ref_frames（ue）:len=3,value=%d\n",(nalu->buf[5]>>4) & 0x07);  
-         printf("\t gaps_in_frame_num_value_allowed_flag(1):value=%d\n",(nalu->buf[5]>>3) & 1);  
-         printf("\t pic_width_in_mbs_minus1-ue-:len=7 ,value=%d\n", (((nalu->buf[5])&0x07)<<4)| (((nalu->buf[6])>>4)&0x0e) );  
-         printf("\t pic_height_in_map_units_minus1-ue-:len=7 ,value=%d\n",(((nalu->buf[6])&0x0f)<<3) |((((nalu->buf[7])>>5))&0x06) );  
-         printf("\t frame_mbs_only_flag(1):%d\n",(nalu->buf[7]>>4) & 1);  
- //忽略1
-         printf("\t flag(4):%d\n",(nalu->buf[7]) & 0x0f);  
-   }  
- if (nalu->nal_unit_type == 8)//8 图像参数集  4个字节
-   {  
- /*  68 CE 38 80 00 00 00 01
-           0110 1000
-           forbidden_zero_bit（1）＝ 0
-           nal_ref_idc（2）＝ 11
-           nal_unit_type（5） ＝01000：pic_parameter_set_rbsp( ),7.3.2.2//8图像参数集
-           1100
-           pic_parameter_set_id (ue)=0
-           seq_parameter_set_id(ue)=0
-           entropy_coding_mode_flag(1) :0,   重要的flag,0表示编码Exp-Golomb coded and CAVLC,1表示CABAC
-           pic_order_present_flag(1):0
-           1110
-           num_slice_groups_minus1(ue):0
-           忽略
-           num_ref_idx_l0_active_minus1（ue）:0
-           num_ref_idx_l1_active_minus1(ue):0
-           weighted_pred_flag(1);0
-           0011 1000 1000 0000
-           weighted_bipred_idc(2):00
-           pic_init_qp_minus26 /* relative to 26 *///(se):0  
- //pic_init_qs_minus26 /* relative to 26 *///(se):0
- /* chroma_qp_index_offset(se):0
-           deblocking_filter_control_present_flag(1);0
-           constrained_intra_pred_flag(1):0
-           redundant_pic_cnt_present_flag(1):0
-           忽略
-         NALU结束
-         */
-   }  
- if (nalu->nal_unit_type == 5) //5  IDR帧
-   {  
-   }  
- 
-   free(Buf);  
- 
- return (pos+rewind);//返回两个开始字符之间间隔的字节数
- }  
- void dump(NALU_t *n)  
- {  
- if (!n)return;  
- //printf("a new nal:");
-     printf(" len: %d  ", n->len);  
-     printf("nal_unit_type: %x\n", n->nal_unit_type);  
- }  
- int main(int argc, char* argv[])  
- {  
-     OpenBitstreamFile("./my.h264");  
-     NALU_t *n;  
-     n = AllocNALU(8000000);  
- while(!feof(bits)) {  
-         GetAnnexbNALU(n);  
-         dump(n);  
-     }  
-     FreeNALU(n);  
- return 0;  
- }  
- staticint FindStartCode2 (unsigned char *Buf)  
- {  
- if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=1) return 0; //判断是否为0x000001,如果是返回1
- elsereturn 1;  
- }  
- 
- staticint FindStartCode3 (unsigned char *Buf)  
- {  
- if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=0 || Buf[3] !=1) return 0;//判断是否为0x00000001,如果是返回1
- elsereturn 1;  
- }  
这是一个纯c语言的例子，应该是很好理解的，不谢！接下来会有更猛的料，尽请期待，觉得不错可以关注下......
