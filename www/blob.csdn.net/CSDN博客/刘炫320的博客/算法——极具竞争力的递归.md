# 算法——极具竞争力的递归 - 刘炫320的博客 - CSDN博客
2017年02月13日 10:53:13[刘炫320](https://me.csdn.net/qq_35082030)阅读数：265标签：[算法																[二叉树																[高度](https://so.csdn.net/so/search/s.do?q=高度&t=blog)](https://so.csdn.net/so/search/s.do?q=二叉树&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[算法](https://blog.csdn.net/qq_35082030/article/category/6715681)
# 算法——极具竞争力的递归
相应的练习代码：[https://github.com/liuxuan320/Algorithm_Exercises](https://github.com/liuxuan320/Algorithm_Exercises)
### 0.写在前面
算法既是一个大的定义，也可能指的是某一个具体的算法。很多算法我们弄不清楚，除了是因为其核心思想没有掌握外，也有可能是因为其表现形式是递归，让我们很难理解。 
其实，《暗时间》的作者刘未鹏指出真正学习算法，应该去学习整个算法的想出的过程，这其实也是国外的教育思维，更倾向于发现问题的过程和解决办法的提出，而中国教育通常是教授现成的N种方法，方法越多越好，这也是国情决定的，需要在短时间内快速的提高我们的国民素质，这一步是不可或缺的，看看我们现在所取得的辉煌成就就知道了。
### 1.递归的定义
扯得有点远，我们现在进入正题。递归作为算法中最常见的表现形式，因为具有极强的表现力，而被大多数算法所青睐。直接递归和间接递归都属于递归算法，其实质都是**通过自己调用自己，将求解问题转化成性质相同的子问题，最终达到求解的目的的**。
### 2.递归的内部原理
递归的具体实现，有点类似于计算机中的程序中断，如果学过计算机组成原理的同学，想必应该对递归有着更为深刻的理解和认识。无怪乎以下几个步骤：关中断，保护现场，执行程序，恢复现场，开中断。那么递归时的内部操作也差不多，主要有以下2个方面： 
**（1）在执行调用时，系统至少执行的操作。**
1. 返回地址进栈，同时在栈顶为被调子程序的局部变量开辟空间。 
2. 为被调子程序准备数据：计算实参值，并赋给对应的栈顶的形参。 
3. 将指令流转入被调子程序的入口处。 
**（2）在执行返回操作时，操作系统至少执行的操作。**
1. 若有变参或是函数，将其值保存到回传变量中。 
2. 从栈顶取出返回地址。 
3. 按返回地址返回 
4. 若有变参或是函数，从回传变量中取出保存的值传送给想赢的变量或者位置上。 
上面所述的就是整个递归时的内部操作，是不是和程序中断差不多呢？
### 3.递归转非递归
为什么我们要介绍这个呢，因为所有的递归程序都可以使用非递归来实现。而递归程序虽然形式上很简洁明朗，但是真正理解起来却十分困难。因此有时候为了理解其递归，就需要转化为非递归程序。而这个过程有一套标准规则，恐怕国外早已有自动化工具了，当然有可能时实验室产品。 
以下就是递归转非递归的规则。 
1. 在过程的开始部分，插入说明为栈的代码并将其初始化为空。在一般情况i啊，这个栈用来存放参数、局部变量和函数的值，每次递归调用的返回地址也要存入栈。 
2. 将标号$L_1$附于第一条可执行语句。然后，对于每一处递归调用都用两组执行下列规则的指令来代替。 
3. 将所有参数和局部变量的值存入栈。栈顶指针可作为一个全程变量来看待。 
4. 建立第i个新标号$L_i$，并将i存入栈。这个标号的i值将用来计算返回地址。此标号放在规则（7）所描述的程序段中。 
5. 计算这次调用的各实参（可能时表达式）的值，并把这些值赋给相应的形参。 
6. 插入一条无条件转向语句，转向过程的开始部分。 
7. 如果此过程时函数，则对递归过程中含有此次函数调用的那条语句做如下处理：将该语句的此次函数调用部分用栈顶取回该函数值的代码来代替，其余部分的代码按原描述方式照抄，并将规则（4）中建立的标号附于这条语句上。如果此过程不是函数，则将规则（4）中建立的标号附于规则（6）所产生的转移语句后面的那条语句。 
以上步骤时消去过程中各处的递归调用，下面对递归过程中出现的return语句进行处理（将纯过程结束处的end语句看成是一条没有值与其相联系的return语句）。在每个有return语句的地方，执行下述规则： 
8. 如果栈为空，则执行正常返回。 
9. 否则，将所有输出参数（理解为out或者inout型的参数）的当前值赋给栈顶上的那些对应的变量。 
10. 如果栈中有返回地址标号的下标，就插入一条此下标从栈中推出的代码，并把这个下标值赋给一个未使用的变量。 
11. 从栈中退出所有局部变量和参数的值并把它们赋值给对应的变量。 
12. 如果这个过程时函数，则插入以下指令，这些指令用来计算紧接在return语句后面的表达式并将结果值存入栈顶。 
13. 用返回地址标号的下标实现对该语句的转向。 
不得不说，用以上规则确实可以进行非递归的转化，但是转化出来时，不一定时最简形式，还需要进一步优化才能达到最优性能。
### 4.递归的例子
常见的递归有**Fibonacci数列**、**辗转相除法**、**二分检索**、**层次遍历二叉树**等，都还能记得么？下面我们使用**求二叉树高度**，作为我们递归转非递归的例子，结束我们今天的话题。 
原递归算法：
```
procedure TreeDeep(T)
    if T=null then deep<-0
    else ldeep<-TreeDeep(T.lchild)
        rdeep<-TreeDeep(T.rchild)
        deep<-Max(ldeep,rdeep)+1
    endif
    return(deep)
end TreeDeep
```
转换为非递归算法：
```
procedure TreeDeep(T)
        STACK(1:8n);top<-0             
L1:     if T=null then deep<-0             //r2
        else top<-top+1;STACK(top)<-T      //r3 
             top<-top+1;STACK(top)<-ldeep  //r3 
             top<-top+1;STACK(top)<-rdeep  //r3 
             top<-top+1;STACK(top)<-2      //r4
             T<-T.lchild                   //r5
             goto L1                       //r6
L2:          ldeep<-STACK(top);top<-top-1  //r7
             top<-top+1;STACK(top)<-T      //r3 
             top<-top+1;STACK(top)<-ldeep  //r3 
             top<-top+1;STACK(top)<-rdeep  //r3 
             top<-top+1;STACK(top)<-3      //r4
             T<-T.rchild                   //r5     
             goto L1                       //r6
L3:          rdeep<-STACK(top);top<-top-1  //r7
             deep<-Max(ldeep,rdeep)+1      
        endif
        if top=0 then return (deep)        //r8
        else addr<-STACK(top);top<-top-1   //r10
             rdeep<-STACK(top);top<-top-1  //r11
             ldeep<-STACK(top);top<-top-1  //r11
             T<-STACK(top);top<-top-1      //r11
             top<-top+1;STACK(top)<-deep   //r12
             if addr=2 then goto L2 endif  //r13
             if addr=3 then goto L3 endif  //r13
        endif
end TreeDeep
```
### 5.递归小结
以上就是我们对于递归的认识了，从递归的定义讲到递归的内部原理，并且也着重介绍了递归转非递归的方法以及附带了一个小小的例子，希望可以在接下来的学习中多加体会。
