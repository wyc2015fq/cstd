# 计算语言学之句法理论（1） - 刘炫320的博客 - CSDN博客
2017年05月14日 21:47:01[刘炫320](https://me.csdn.net/qq_35082030)阅读数：1382
所属专栏：[自然语言处理（计算语言学）概论](https://blog.csdn.net/column/details/16369.html)
在这一章中，我们主要介绍的内容有句法理论，基于CFG的线图分析法和CYK算法，以及PCFG算法，并对短语结构标准进行相关介绍。
# 1. 句法理论
从刚开始的以单词为核心的词法理论，再到现在的句法理论以及后面讲的语义和篇章，自然语言处理的对象逐渐变大，而且越来越难以处理。准确来讲，目前尚且称为合格的，可以成熟的用作商业上的层次，大概也就在句法这一级别，再高的层次上，其普适应用还尚未形成。
句法分析的任务就是识别句子的句法结构。如果用过斯坦福的句法分析工具，应该知道，句法分析出的结果有两种，一种是短语结构分析，另一种是依存句法分析。
在这一讲中，我们主要讲解短语结构分析。短语结构分析的样子大概如下所示： 
![短语结构分析](https://img-blog.csdn.net/20170513193411895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如果这样可能不容易看，那么使用树状表示，则可以更清楚的看出，它在做什么。 
![这里写图片描述](https://img-blog.csdn.net/20170513193529369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
而对于句法分析的短语结构分析方面，就是给出一句话，实现高正确率、高鲁棒性 (robustness)、高速度的自动句法分析过程。但是，由于歧义的出现，使得这项工程到目前为止也只能达到90%左右的水平（20词以下）。
英语中的结构歧义随介词短语组合个数的增加而不断加深的，这个组合个数我们称之为卡特兰数(Catalan number，记作$C_N$)。这个数量已经相当可怕了。
在短语结构分析中，有2类算法，一类称为CFG（上下文无关文法）规则的分析方法，另一类是PCFG（概率上下文无关文法）分析方法。在这里，我们主要介绍基于CFG的线图分析法和CYK算法以及PCFG算法。
# 2 线图分析法
线图分析法有3种策略，一、自底向上；二、自上到下；三、从上到下和从下到上相结合。这里我们介绍自底向上的线图分析法。
**输入**： 
给定一组 CFG 规则: $XP \rightarrow\alpha_1…\alpha_n (n\ge1)$
给定一个句子的词性序列：$S=W_1W_2...W_n$
**准备**： 
构造一个线图：一组结点和边的集合；
建立一个二维表：记录每一条边的起始位 
置和终止位置。
**执行**： 
查看任意相邻几条边上的词性串是否与某条重写规则的右部相同，如果相同，则增加一条新的边跨越原来相应的边，新增加边上的标记为这条重写规则的头(左部)。重复这个过程，直到没有新的边产生。 
我们使用点规则来表示整个过程：用于表示规则右部被归约(reduce)的程度。
**数据结构**： 
线图(Chart)：保存分析过程中已经建立的成分(包括终结符和非终结符)、位置(包括起点和终点)。通常以 n×n 的数组表示(n 为句子包含的词数)。
代理表(待处理表)(Agenda)：记录刚刚得到的一些重写规则所代表的成分，这些重写规则的右端符号串与输入词性串(或短语标志串)中的一段完全匹配，通常以栈或线性队列表示。这里是词性序列存储。
活动边集(ActiveArc)：记录那些右端符号串与输入串的某一段相匹配，但还未完全匹配的重写规则，通常以数组或列表存储。这里是匹配的那些串的存储。
**算法描述**： 
从输入串的起始位置到最后位置，循环执行如下步骤： 
(1) 如果待处理表(Agenda)为空，则找到下一个位置上的词，将该词对应的(所有)词类X 附以 (i, j) 作为元素放到待处理表中，即X (i, j)。其中，i, j 分别是该词的起始位置和终止位置，j > i，j - i 为该词的长度。 
(2) 从 Agenda 中取出一个元素X(i, j)。 
(3) 对于每条规则A$\rightarrow X\gamma$，将 A$\rightarrow X\circ\gamma$(i, j) 加入活动边集ActiveArc 中，然后调用 扩展弧子程序。
其扩展弧子程序为： 
(a) 将 X 插入图表(Chart)的 (i, j) 位置中。 
(b) 对于活动边集(ActiveArc)中每个位置为(k, i) (1$\le$k$<$i ) 的点规则，如果该规则具有如下形式：A$\rightarrow\alpha\circ X$(i, j) , 如果A=S, 则把 S(1, n+1) 加入到 Chart 中，并给出一个完整的分析结果；否则，则将 A(k, j) 加入到Agenda表中。 
(c) 对于每个位置为(k, i) 的点规则： A$\rightarrow\alpha\circ X\beta$，则将A$\rightarrow\alpha\circ X\beta$(k, j ) 加入到活动边集中。
下面举例说明： 
：G (S): S $\rightarrow $NP VP , NP $\rightarrow $Det N 
VP $\rightarrow $ V NP, VP $\rightarrow $VP PP 
PP $\rightarrow $Prep NP 
输入句子： the boy hits the dog with a rod 
首先进行形态分析：the boy hit the dog with a rod 
再进行词性标注：Det N V Det N Prep Det N
你让电脑做，那么很复杂，需要一步一步的按部就班去做。至少电脑不会觉得复杂。而如果是人做的话。是比较容易的，只需要使用贪心的方法，从左到右一点点规约，把能合并的都合并了就行。然后就能形成一棵树。但是如果树不存在唯一性，可能这时候人的随机选择方法就要差上许多。这也是这个方法的缺陷。
线图分析法，总的来讲是一种贪心算法，它具有算法简单，容易实现，开发周期短等优点，但是它的缺点也是十分明显的：算法效率低，时间复杂度为 $Kn^3$ ;需要高质量的规则，分析结果与规则质量密切相关;难以区分歧义结构。
# 3 CYK算法
Coke-Younger-Kasami (CYK) 算法是由这三个人的名字共同组成的,它主要是对Chomsky 文法进行范式化： 
A$\rightarrow$w 或 A $\rightarrow$BC 
A, B, C $\in V_N$, w$\in V_T$ , G=($V_N, V_T$, P, S)
说人话就是，它只有2种转换规则，一种是从非终结字符到终结字符（A$\rightarrow$w），一种是非终结字符间的规约A $\rightarrow$BC。它是一种自底向上构造的树，采用的是一个 (n+1)×(n+1) 识别矩阵，n为输入句子长度。假设输入句子 x=w1w2…wn，wi 为构成句子的单词，n=| x |。
虽然它很简单，但是我们还是要把规范说一下： 
识别矩阵的构成为：
- 方阵对角线以下全部为0
- 主对角线以上的元素由文法G的非终结符构成
- 主对角线上的元素由输入句子的终结符号(单词)构成
其识别的步骤为： 
(1)首先构造主对角线，令 t0,0=0，然后，从 t1,1 到tn,n 在主对角线的位置上依次放入输入句子x 的单词wi。 
(2)构造主对角线以上紧靠主对角线的元素ti, i+1, 其中，i = 0, 1, 2 , …, n-1。对于输入句子 x = w1 w2 … wn，从 w1 开始分析。 
如果在文法G 的产生式集中有一条规则： 
A $\rightarrow w_1 $
则$t_{0, 1}$=A。 
依此类推，如果有 A $\rightarrow w_{i+1}$，则 $t_{i, i+1}$ =A。 
即，对于主对角线上的每一个终结符 $w_i$，所有可能推导出它的非终结符写在它的右边主对角线上方的位置上。 
(3) 按平行于主对角线的方向，一层一层地向上填写矩阵的各个元素 ti, j，其中，i = 0,1, …, n-d, j = d+i，d=2, 3, …, n。如果存在一个正整数 k, i+1$\le$k $\le$ j-1，在文法G的规则集中有产生式 A $\rightarrow  $BC, 并且，B$\in t_{i,k}$, C$\in t_{k,j}$， 那么，将A写到矩阵$ t_{i,j}$位置上。
判断句子 x 由文法 G 所产生的充要条件是：$t_{0,n}$=S。
上面那么多，多半都是学术规则，为的是当没有人讲解的时候也一样可以理解。下面我们以一个例子来讲解具体操作，构造“他喜欢读书。”这句话的短语结构分析树，最重要的一点是操作顺序为平行于对角线的方向，一层一层网上填写，如果可以规约，则规约，不能规约，直接平移即可。
![短语结构分析](https://img-blog.csdn.net/20170514205849775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这幅图可以看的很清楚，所有的规约规则均来源于已给出的规则，而方向是从对角线开始从左下至右上平行于对角线逐层分析。这样最终就得到了一个短语结构树。 
![例子](https://img-blog.csdn.net/20170514210143003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
CYK算法就是这么简单，虽然它具有简单易行，执行效率高的特点，但是它同样无法解决歧义问题。
# 4 概率上下文无关文法（PCFG）
其实我们也可以看出CYK算法的缺陷，在一个以概率为基础的世界里，我们怎么可能少的了概率。因此，把CYK概率化后就是PCFG了。例如： 
![这里写图片描述](https://img-blog.csdn.net/20170514210825043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这也很好理解，一旦概率化，那么似然估计就派上用场了。因此也就可以进行机器学习。但是我们这里讲如何实现，PCFG有3条基本假设：
- 位置不变性：子树的概率与其管辖的词在整个句子中所处的位置无关，即对于任意的 k,p($A_{k(k+C)} \rightarrow $w) 一样。
- 上下文无关性：子树的概率与子树管辖范围以外的词无关，即  p($A_{kl} \rightarrow $w|任何超出k~l 范围的上下文) = p($A_{kl} \rightarrow $w)。
- 祖先无关性：子树的概率与推导出该子树的祖先结点无关，即  p($A_{kl} \rightarrow $w| 任何除 A 以外的祖先结点) =  p($A_{kl} \rightarrow $w)。
下面我们给出一个例子，旨在说明，如何计算概率值。 
以下图为例，概率和目标句子都已经给出： 
![这里写图片描述](https://img-blog.csdn.net/20170514211839583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如果根据CYK算法，不考虑同一层上的先后顺序的话，它就有可能产生歧义，也就是产生两个不同的树，如t1和t2: 
![这里写图片描述](https://img-blog.csdn.net/20170514212011614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](https://img-blog.csdn.net/20170514212042990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
那么究竟该选哪一棵树，当然是概率大的那个。因此我们使用下面算法来计算一棵树的概率值： 
![这里写图片描述](https://img-blog.csdn.net/20170514212154256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
可以看到一个树的概率主要来源一三个部分，左孩子概率，右孩子概率和本身结构的概率，而这个过程是递推的，在父节点上的概率指的是这棵树本身的结构概率，而整棵树的概率是隐含的。这里不要弄错了。
经过计算后，我们可以看出对于给定的句子 S ，两棵句法分析树的概率不等，P(t1) > P(t2)，因此，可以得出结论：分析结果t1正确的可能性大于t2。
但这只是一个简单的例子，事实上，PCFG算法面临三个问题： 
1、给定句子 W=w1w2…wn 和 PCFG G，如何快速计算 p(W|G) ？ 
2、给定句子 W=w1w2…wn 和 PCFG G，如何快速地选择最佳句法结构树？ 
3、给定句子 W=w1w2…wn 和 PCFG G，如何调节 G 的参数，使得 p(W|G) 最大？
这三个问题的答案分别是：内向/外向算法、维特比算法、EM算法。 
具体的我们不赘述，因为都是算法公式，等有机会详细介绍，这里以一个示例来介绍整个分析过程。 
![这里写图片描述](https://img-blog.csdn.net/20170514213312543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
方法还是如CYK方法一样，只不过可以多重选择，并且附加概率，即如图所示： 
![这里写图片描述](https://img-blog.csdn.net/20170514213835061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
由此，我们可以得到两棵树t1、t2，并且可以得知t1的概率大于t2。因此我们选择t1作为最终的树形结构。 
![这里写图片描述](https://img-blog.csdn.net/20170514214006506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUwODIwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
PCFG有着明显的优点，例如可利用概率减少分析过程的搜索空间；可利用概率对概率较小的子树剪枝，加快分析效率；可以定量地比较两个语法的性能等。但是它也有缺点，例如分析树的概率计算条件非常苛刻，甚至不够合理。也就是我们提到的上面的三个基本假设。
# 5 短语结构分析方法评估
我们在这里简要介绍一下评估方法，一般来讲分为2类：内部评测 (intrinsic evaluation)与对比评测 (comparative evaluation )
## 5.1 内部评测
对评测方法本身的评测，用于指导句法分析系统及其语法的开发过程。主要指标有： 
1. 语法的覆盖性 (grammatical coverage) 
2. 平均分析基数 (average parse base) 
3. 结构一致性 (structural consistency) 
4. 排序的一致性 (best-first/ranked consistency)等
## 5.2 对比评测
用于对比不同系统之间的性能差别，主要评测指标和方法包括： 
1. 树相似性 (tree similarity) 
2. 模型的熵 (或困惑度) (entropy/perplexity) 
3. 语法评估兴趣小组 (grammar evaluation interest group, GIEG)的评测方案等
## 5.3 性能指标
性能指标一般为PRF值与交叉括号数。PRF值一般指的是精度、召回率和F1值。而交叉括号数指的是一棵分析树中与其他分析树中边界相交叉的成分个数的平均值。
另外，关于PCFG的改进，我们有空会补上。这里就先这样了。
