# 编程语言习题集（3） - 刘炫320的博客 - CSDN博客
2017年12月22日 17:32:09[刘炫320](https://me.csdn.net/qq_35082030)阅读数：234
所属专栏：[编程语言笔试习题集](https://blog.csdn.net/column/details/18350.html)
# 0.写在前面
我们的习题集会越来越精华，遇见过的题目不会再出现，容易题目出现频率逐渐降低，最后都是易错题和难题，请大家持续关注。
# 1.$C#$
> 
1.1有关结构体和类的说法不正确的是（ ）？ 
  A.结构体直接继承于System.ValueType 
  B.结构体不可以声明构造函数 
  C.结构是值类型的，而类是引用类型的 
  D.结构体可以继承接口
参考答案：B
解析：结构体没有默认构造函数，但可以声明构造函数，结构体是值类型System.ValueType。结构体和类很像，其区别是: 
1.结构体对象给函数使用时，只是作为一个值传递，而类属于引用。 
2.结构体的对象使用new运算符创建，也可以直接创建单个元素赋值(obj2)这是与类不同的因为类只能使用new创建对象
> 
1.2扩展方法是能访问被扩展对象的成员。判断这句话是否正确？ 
  A.能 
  B.不能
参考答案：B
解析：只能是访问所扩展类的public成员。 
具体的，是考察扩展方法和扩展对象的相关内容，可以参考[《C#扩展方法详解》](http://blog.csdn.net/zyh_1988/article/details/51103612)
> 
1.3装箱、拆箱操作发生在: () 
  A.类与对象之间 
  B.对象与对象之间 
  C.引用类型与值类型之间 
  D.引用类型与引用类型之间
参考答案：C
解析：通俗的讲，就是基本数据类型和包装类之间的转换。如： int  类型和  Integer  类的转换
基本数据类型转化成包装类是装箱  (如： int  –>  Integer)。
包装类转化成基本数据类型就是拆箱  (如：Integer  –>  int)。
包装类就是引用类型，基本数据类型就是值类型。所以选C
> 
1.4接口是一种引用类型，在接口中可以声明（），但不可以声明公有的域或私有的成员变量。 
  A.方法、属性、索引器和事件 
  B.方法、属性信息、属性 
  C.索引器和字段 
  D.事件和字段；
参考答案：A
解析：这是对接口成员的一个概括。
> 
1.5在下面的C#类声明中，属于私有字段的是（）
```
class Persong
{
    public string name;
    public string sex;
    private int age;
    double weight;
}
```
> 
A.weight 
  B.name sex 
  C.age 
  D.age weight
参考答案：D
解析：C#与Java不同，其构造函数默认修饰符为public，析构函数不能使用修饰符且默认为private，成员变量默认修饰符为private
> 
1.6下列关于C#中索引器理解正确的是？ 
  A.索引器的参数必须是两个或两个以上 
  B.索引器的参数类型必须是整数型 
  C.索引器没有名字 
  D.以上皆非
参考答案：C
解析：索引至少声明1个参数，A错;索引参数类型不必是整型, B错;索引确实没有名字,名字位置上都是关键字this，C对。论述代码见下:
```
using System;
namespace ConsoleApp5
{
    class Program
    {
        static void Main(string[] args)
        {
            Employee ep1 = new Employee();
            ep1.firstName = "你";
            ep1.middleName = "是";
            ep1.lastName = "猪";
            Console.Write("我的名字叫{0}{1}{2}", ep1["a"], ep1["b"], ep1["c"]);
            Console.ReadLine();
        }
    }
    class Employee
    {
        public string firstName;
        public string middleName;
        public string lastName;
        public string this[string index]
        {
            set
            {
                switch (index)
                {
                    case "a": firstName = value;
                        break;
                    case "b": middleName = value;
                        break;
                    case "c": lastName = value;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("index");
                }
            }
            get
            {
                switch (index)
                {
                    case "a": return firstName;
                    case "b": return middleName;
                    case "c": return lastName;
                    default:
                        throw new ArgumentOutOfRangeException("index");
                }
            }
        }
    }
}
```
所引起与数组和属性也有不同：索引器允许类或者结构的实例按照与数组相同的方式进行索引取值，索引器与属性类似，不同的是索引器的访问是带参的。
索引器和数组比较：
- 索引器的索引值(Index) 类型不受限制
- 索引器允许重载
- 索引器不是一个变量
索引器和属性比较：
- 属性以名称来标识，索引器以函数形式标识
- 索引器可以被重载，属性不可以
- 索引器不能声明为static，属性可以
# 2.Java
> 
2.1以下代码执行后输出结果为（ ）
```java
public class Test
{
    public static Test t1 = new Test();
    {
         System.out.println("blockA");
    }
    static
    {
        System.out.println("blockB");
    }
    public static void main(String[] args)
    {
        Test t2 = new Test();
    }
 }
```
> 
A.blockAblockBblockA 
  B.blockAblockAblockB 
  C.blockBblockBblockA 
  D.blockBblockAblockB
参考答案：A
解析：
静态块：用static申明，JVM加载类时执行，仅执行一次 
构造块：类中直接用{}定义，每一次创建对象时执行 
执行顺序优先级：静态块>main()>构造块>构造方法 
初始化类的时候，首先在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的0。所以加载时，对t1初始化为null，对static静态块做了初步的初始化，但是还未执行里面的代码。然后按照静态变量的初始化顺序，首先对t1进行具体的初始化，由于static静态块已经进行了初步的初始化，所以这时候是直接跳过这里的，所以首先输出 blockA，然后初始化t1后，执行到static静态块之后，再执行里面的内容，所以输出blockB，最后执行普通的初始化块blockA.
> 
2.2在Java中，关于HashMap类的描述，以下错误的是 
  A.HashMap使用键/值得形式保存数据 
  B.HashMap 能够保证其中元素的顺序 
  C.HashMap允许将null用作键 
  D.HashMap允许将null用作值
参考答案：B
解析：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，
主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。
HashMap 把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 
> 
2.3假设有以下代码String s = “hello”；String t = “hello”；char c [ ] = {‘h’,’e’,’l’,’l’,’o’}；下列选项中返回false的语句是？ 
  A.s.equals (t)； 
  B.t.equals (c)； 
  C.s==t； 
  D.t.equals (new String (“hello”))；
参考答案：B
解析：首先==与equals是有明显区别的。
==强调栈中的比较，可以理解为地址比较
equals强调对象的内容比较
String s=“hello”；会在栈中生成hello字符串，并存入字符串常量池中。
String t=“hello” ；创建时，会在字符串常量池中寻找，当找到需要的 
hello时，不进行字符串的创建，引用已有的。 所以，s==t返回true，s.equals(t)也是true。
char c[]={‘h’,’e’,’l’,’l’,’o’}; c==s这个是不存在的，==两边类型不同 
t.equals(c)这个语句在anObject instanceof String这步判断不会通过，也就是cha[] 压根不能与String相比较，类型不是相同的。返回false.
> 
2.4Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（） 
  A.”.*?(?=\()” 
  B.”.*?(?=()” 
  C.”.*(?=\()” 
  D.”.*(?=()”
参考答案：A
解析： 
(?=Expression) 顺序环视，(?=\()就是匹配正括号 
量词：{m,n}：m到n个 
*：任意多个 
+：一个到多个 
？：0或一个
> 
2.5下列关于Java并发的说法中正确的是（） 
  A.CopyOnWriteArrayList适用于写多读少的并发场景 
  B.ReadWriteLock适用于读多写少的并发场景 
  C.ConcurrentHashMap的写操作不需要加锁，读操作需要加锁 
  D.只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了
参考答案：B
解析：
A，CopyOnWriteArrayList适用于写少读多的并发场景
B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 
   读与读之间可以并发执行。在读多写少的情况下可以提高效率
C，ConcurrentHashMap是同步的HashMap，读写都加锁
D，volatile只保证多线程操作的可见性，不保证原子性
> 
2.6 一般有两种用于创建线程对象的方法,一是(),二是()。 
  A.从Java.lang.Thread类派生一个新的线程类，重写它的runnable()方法 
  B.从Java.lang.Thread类派生一个新的线程类，重写它的run()方法 
  C.实现Thread接口，重写Thread接口中的run()方法 
  D.实现Runnable接口，重写Runnable接口中的run()方法
参考答案：BD
解析：创建线程对象两种方式：
- 继承Thread类，重载run方法；
- 实现Runnable接口，实现run方法  
> 
2.7有关finally语句块说法正确的是（ ） 
  A.不管 try 语句块正常结束还是异常结束，finally语句块都是要被执行的 
  B.在try语句块或catch语句块中执行到System.exit(0)直接退出程序 
  C.finally块中的return语句会覆盖try块中的return返回 
  D.finally 语句块在 catch语句块中的return语句之前执行
   
  参考答案：ABCD
解析： 
1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。
# 3C++
> 
3.1 32位系统下，对于下面的结构体A和B，sizeof（A），sizeof（B）的结果分别是（）
```
#include <stdio.h>
#pragma pack(2)
struct A
{
 int a;
 char b;
 short c;
};
#pragma pack()
#pragma pack(4)
struct B
{
 char b;
 int a;
 short c;
};
#pragma pack()
int main()
{
    printf(“sizeof(A)=%d,sizeof(B)=%d\n”,sizeof(A),sizeof(B));
    return 0;
}
```
> 
A.8,8 
  B.8,10 
  C.8,12 
  D.7,8
参考答案：C
解析：#pragma pack(n)表示默认以n字节对齐，若某变量（如int）的字节大于n,则以n的倍数对齐。
> 
3.2下列的模板声明中，其中几个是正确的（）
```cpp
1)template
2)template<T1,T2>
3)template<class T1,T2>
4)template<class T1,class T2>
5)template<typename T1,T2>
6)template<typename T1,typename T2>
7)template<class T1,typename T2>
8)<typename T1,class T2>
```
> 
A.2 
  B.3 
  C.4 
  D.5
参考答案：B
解析：4，6，7是对的。模版的声明要说明形参的类型，有几个说明几个，不能省略。
> 
3.3下面程序应该输出多少？
```
char *c[] = { "ENTER", "NEW", "POINT", "FIRST" }; 
char **cp[] = { c+3, c+2, c+1, c }; 
char ***cpp = cp; 
int main(void)
{ 
    printf("%s", **++cpp); 
    printf("%s", *--*++cpp+3); 
    printf("%s", *cpp[-2]+3); 
    printf("%s\n", cpp[-1][-1]+1); 
    return 0;
}
```
> 
A.POINTERSTEW 
  B.FERSTEPOINW 
  C.NEWPOINTW 
  D.POINTFIREST
参考答案：A
解析：其中考了指针应用，隐含中也考了运算符优先级的问题`（*--*++cpp+3）`
具体运算符优先关系记忆这个写的比较好[《C语言运算符优先级 之 快速记忆》](http://blog.csdn.net/skywalker_leo/article/details/6237222)
c是一个指针数组，每个数组单元都是一个指针，指向一个字符创。 
即c[0]=”ENTER”……c[3]=”FIRST”
由于[]与*运算本质几乎是一致的，以下用[]替换*更容易理解。 
`c[i]=*(c+i)`c和c+i都是`char*[]`类型，它可以退化成`char**`类型，它正好是一个`char**`数组 
cp[0]=c+3 …..cp[3]=c引用后`cp[0][0]=*(c+3)=c[3]="FIRST"`
cp是`char**`[]类型，它可以退化成`char***`类型，正好与cpp类型一致。
1>`++ccp的值是cp+1`
`*++p=*(cp+1)=cp[1]`
`**++p=*(cp[1])=c[2]="POINT"`
2>运算符优先级决定运算先后关系 
`++ccp的值是cp+2`
`*++p=*(cp+2)=cp[2]=c+1`
`--*++p=c *--*++p=*(c+0)=c[0]="ENTER"`
再+3字符串指向”ER”
3>cpp的值为`cp+2`
`cpp[-2]=*(cpp-2)=*(cp+2-2)=cp[0]=c+3`
再引用`*（c+3）=c[3]="FIRST"`字符串指到”ST”
4>cpp的值没变， 
`cpp[-1]=*(cpp-1)=*(cp+2-1)=cp[1]=c+2`
`再[-1]得*(c+2-1)=c[1]="NEW"`, 
`+1字符创指针指到"EW"`
翻来覆去，记得这个换算关系式即可，`c[i]=*(c+i)。`
> 
3.4下面函数：
```php
int Function(unsigned int n) {
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
        return n;
}
```
> 
输入参数为197时，函数返回多少？ 
  A.2 
  B.3 
  C.4 
  D.5
参考答案：C
解析：这个函数是十分熟悉的，它是一个统计一个数的二进制1的个数的。它已经被封装到了java的自带函数中。它的思想是分治法。
先计算每2个相邻的位置上，有几个1，然后再计算每4个位置上有几个1，再计算每8个位置上，16个位置上，32个位置上有几个1，然后最终得到解。
# 4. js
> 
4.1下列js延迟加载的方式中，只有IE浏览器支持的是哪一种方式？（） 
  A.async 
  B.defer 
  C.动态创建DOM方式 
  D.按需异步载入
参考答案：B
解析：其实这道题应该是老题了，HTML的Script标签的defer属性在W3Cshool里说明是只有IE支持。 
![这里写图片描述](https://uploadfiles.nowcoder.com/images/20170126/9460551_1485402987244_2AF4A6E3829C3D230ECEE23C9FD5F4F4)
但是实际上其他浏览器也都支持此属性，详见[支持defer的浏览器](https://caniuse.com/#search=defer)。
> 
4.2以下描述错误的是 
  A.cookie以及loaclStorage都会伴随着http请求发送到服务器 
  B.get提交的url会有长度的限制，而post提交的数据则可以比较大 
  C.在javascript中可以操作cookie 
  D.javascript在浏览器的执行是单线程的 
  E.html5中的新增存储方式包括localStorage/sessionsTORAGE
参考答案：A
解析： 
sessionStorage 、localStorage 和 cookie 之间的区别 
共同点：都是保存在浏览器端，且同源的。 
区别： 
- 
cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 
- 
存储大小限制也不同 
cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 
- 
数据有效期不同， 
sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； 
localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； 
cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 
- 
作用域不同 
sessionStorage不在不同的浏览器窗口敏感词享，即使是同一个页面； 
localStorage在所有同源窗口中都是共享的； 
cookie也是在所有同源窗口中都是共享的。 
- 
Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。 
- 
Web Storage 的 api 接口使用更方便。 
> 
4.3js数组的方法中，哪些方法不能改变自身数组？（） 
  A.pop 
  B.splice 
  C.sort 
  D.concat
参考答案：D
解析：
- pop方法：用于删除并返回数组的最后一个元素，把数组长度减1，并且返回它删除的元素的值。如果数组已经为空，则pop()不改变数组，并返回undefined值
- splice()方法：向/从数组中添加/删除项目，然后返回被删除的项目，该方法会改变原始数组
- sort()方法：用于对数组的元素进行排序。返回对数组的引用。请注意，数组在原数组上进行排序，不生成副本。
- concat()方法： 用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
综上所述，只有concat()方法不会改变数组，故选D
> 
4.4假设有如下代码，那么a(10)的返回结果是？（ ）
```
function a(a)
{
  a^=(1<<4)-1;
   return a;
}
```
> 
A.5 
  B.10 
  C.15 
  D.16
参考答案：A
解析： 
1<<4   左移相当于1*2^4=16 
a^=16-1=15 
a=a^15=10^15 
^ 异或运算： 
10的二进制00001010 
15的二进制00001111 
========>00000101  转成十进制：5
# 5.HTML/CSS
> 
5.1CSS 盒子模型中（ ）是透明的，这部分可以显示背景（ ） 
  A.padding 
  B.margin 
  C.border 
  D.content
参考答案：A
解析：
Margin(外边距) - 清除边框外的区域，外边距是透明的。
Border(边框) - 围绕在内边距和内容外的边框。
Padding(内边距) - 清除内容周围的区域，内边距是透明的。
Content(内容) - 盒子的内容，显示文本和图像。
Margin 
margin清除周围的元素（外边框）的区域。margin没有背景颜色，是完全透明的
Padding（填充） 
当元素的 Padding（填充）（内边距）被清除时，所”释放”的区域将会受到元素背景颜色的填充。
> 
5.2关于下列CSS选择器：ID选择器、类选择器、伪类选择器、标签名称选择器，排序正确的是：（） 
  A.ID选择器>Class选择器>伪类=标签名称选择器 
  B.ID选择器>伪类>Class选择器>标签名称选择器 
  C.ID选择器>Class选择器>伪类>标签名称选择器 
  D.ID选择器>Class选择器=伪类>标签名称选择器
参考答案：D
解析：记着就行越明确的越级别高，也就是越特殊的级别越高。
> 
5.3 关于HTTP协议，下面哪个说法是正确的？ 
  A.HTTP协议是有状态协议。 
  B.以下是一个Http链接的response 的响应头： GET /xxx/xxx/js/lib/test.js HTTP/1.1 Host: 127.0.0.1 Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Accept: */*
  C.RESTful 接口中，利用HTTP协议的method字段来描述要对资源操作的方式，比如GET表示获取资源，POST表示新增一个资源，PUT表示更新资源,DELETE 表示删除资源等等。 
  D.一个HTTP请求返回的HTTP状态码中，304表示临时重定向。
参考答案：C
解析：
A错误，http是无状态的
B错误，后面的是request 头
C正确，GET表示获取资源，POST表示新增一个资源，PUT表示更新资源,DELETE 表示删除资源等等
D错误，状态码304表示：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。307表示临时重定向！
> 
5.4下面关于IE、FF下面CSS的解释区别描述正确的有？ 
  A.FireFox的div的内嵌div可以把父级的高度撑大，而IE6.0不可以，要自己设置高度。 
  B.当设置为三列布局时，FireFox0的float宽度不能达到100％，而IE6.可以。当设置为两列布局时，两种浏览器都可以。 
  C.火狐浏览器中，非float的div前面有同一父级的float的div，此div若有背景图，要使用clear：both，才能显示背景图，而IE6.0中不用使用clear：both 
  D.在[text-decoration:underline]的属性下，IE6.0显示的下划线会比FireFox低一点。在FireFox中，部分笔画会在下划线的下面1个象素左右。
参考答案：CD
解析： 
A:IE6.0的div的内嵌div可以把父级的高度撑大，而FireFox不可以，要自己设置高度。
B: 当设置为三列布局时，IE6.0的float宽度不能达到100％，而FireFox可以。当设置为两列布局时，两种浏览器都可以。
> 
5.5关于web表单登录中用到的图形验证码的实现,以下做法不正确的有: 
  A.返回给浏览器的html代码中包含图形验证码和文本字符串,登录前客户端判断输入内容和页面中保存的内容是否一致 
  B.服务器端在返回的图片和cookie中同时包含图形验证码,登录前客户端判断输入内容和cookie保存的内容是否一致 
  C.服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务器端保存文本的验证码,由服务器端验证输入内容是否正确 
  D.浏览器通过识别图形验证码中的内容和用户输入的内容判断是否一致
参考答案：ABD
解析：A B选项都把正确的验证码文本放在了客户端，这是违背了验证码的初衷的。爬虫或者是恶意程序依旧可以通过各种手段获取你嵌入在html文本或者保存在cookie中的正确验证码文本，模拟表单提交来达到攻击的目的。 
D选项更是无稽之谈。
