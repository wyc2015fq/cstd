# 统计学习方法——感知机模型 - 刘炫320的博客 - CSDN博客
2017年03月05日 14:28:07[刘炫320](https://me.csdn.net/qq_35082030)阅读数：939
所属专栏：[统计学习方法笔记](https://blog.csdn.net/column/details/16460.html)
### 0. 写在前面
在这一节，我们将要正式介绍第一个机器学习方法，感知机。在机器学习课程中，我们在神经网络的课程中，第一次接触到了感知机。不过那时候，我们更多的是关注，感知机如何进行训练，包括随机梯度下降法和批梯度下降。但是对于其数学原理和正确性没有具体的深究，只是对于其表现形式和具体运行步骤有了一定的了解。在这一节中，我们将对感知机的相关问题进行讨论。
### 1. 感知机的定义
对于我们要讨论的感知机，首先要明确什么是感知机。感知机是二分类的线性分类模型，其输入为实例的特征向量，输出为实力的类别，取+1和-1两个值。 
感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于判别模型。其策略就是使损失函数最小化来进行求解，而具体算法通常使用的是梯度下降法。这样统计学习方法的三个要素模型、策略、算法都大概清楚了。 
那么感知机的具体表现形式是什么呢？具体见下： 
$f(x)=sign(w·x+b)$
就是这么简单的一个函数，构成了神经网络和支持向量机的基本单元。不过其中x是向量表示的是输入空间，w是参数向量，表示的是输入空间中每一维度的权重,b是标量，表示的是偏置,w·x是内积。 
其实感知机模型是由缺陷的，首先它的前提是整个训练空间是线性可分的，也就是说会找到一个超平面，可以把正负样本分开。另一方面，它是线性的，因此对于非线性模型它就没有办法去学习。不过线性可分的约束条件也可以让它胜任很多问题了。
### 2.损失函数的选取
在经过基本的概念学习后，进入到了感知机学习策略的讨论。在这一部分，讨论的集中点在于损失函数的选取问题。到底是选取误分类点数目作为衡量标准，还是选取误分类点样本到超平面S的总距离作为衡量标准，有一定的争议。 
这里之所以存在争议，有可能基于以下几个认知上的不同。首先，这个损失函数是一个动态变化的过程，它的存在并不是为了衡量最终模型的好坏，而是指导整个模型的演化方向。换言之，损失函数一定要是连续可导，这样就可以指导每次迭代的方向。另一个，由于感知机模型默认为训练样本线性可分，那么经过有限次的迭代后，一定可以找到一个超平面，可以把正负样本分开。这点我们在接下来的部分会讲到。 
对于感知机的损失函数，最终选取的是误分类点样本到超平面S的总距离作为其衡量标准。而点到面的距离公式我们高中就学过了： 
$d=\frac{1}{||w||}|w·x_0+b|$
其中||w||说玄乎点是w的$L_2$范式，说直白点，就是内积平方和开根号。 
这样，再配合我们的样本标记$y_i$的+1、-1，就能够写出所有误差的距离总和： 
$-\frac{1}{||w||}\displaystyle\sum_{x_i∈M}y_i(w·x_i+b)$
如果不考虑系数，则损失函数为： 
$L(w,b)=-\displaystyle\sum_{x_i∈M}y_i(w·x_i+b)$
由于最终一定会得到一个误分类点为0的超平面，那么损失函数值最终会变为0，
### 3. 感知机学习算法的原始形式
既然损失函数都确定下来了，那么我们就知道我们的目标最终是使得损失函数极小化，这里我们称为梯度下降法。之所以称为梯度下降，这就关系到我们在高数里学到的一个名词，梯度。在标量场中某一点的梯度指向标量场增长最快的方向，而梯度的长度是这个最大的变化率。在单变量的实值函数中，梯度和导数是一样的，但是在线性函数中，则为线的斜率。这个在机器学习的课程中已经讲过，就不在细说，样例里使用的随机梯度下降法。 
具体做法是取损失函数L(w,b)的梯度为： 
$\triangledown_wL(w,b)=-\displaystyle\sum_{x_i∈M}y_ix_i$
$\triangledown_bL(w,b)=-\displaystyle\sum_{x_i∈M}y_i$
而对于每一个误分类点$(x_i,y_i)$，对w,b进行更新的算法为： 
$w\leftarrow w+\eta y_ix_i$
$b\leftarrow b+\eta y_i$
其中$\eta$为学习速率，表示的是每一步改变的值的步长。该值越大，学习速度越快，但是有可能误差越大。这就好比你走向一个珍珠，你每一步走的越大，你离珍珠近的速度越快，但是你错过珍珠的可能性也就越大。 
好了，下面给出具体的感知机原始算法： 
**算法2.1 感知机学习算法的原始形式**
输入：训练集T{($x_i,y_i$)}，其中，i∈(0,N),$y_i$∈{+1,-1},$0<\eta\leq 1$
输入w,b;也就是感知器模型 
（1）选取初值$w_0,b_0$
（2）在训练集中选取数据$x_i,y_i$
（3）如果$y_i(w·x_i+b)\leq0$
$w\leftarrow w+\eta y_ix_i$
$b\leftarrow b+\eta y_i$
（4）转至（2），直至训练集中没有误分类点。
这个感知机的原始算法，真正的意义是，对于每一个误分类样本，当发现误分类点时，就根据误分类点的位置来调整整个超平面。如果知道了这个意思，那么后面的对偶形式也就理解了。
### 4. 感知机学习算法的对偶形式
对于这个改进后的算法形式，我们首先要知道什么是对偶，就具体而言，感知机算法的对偶形式，指的是和感知机算法的原始形式一一对应，在步骤和最终结果上都能够对应起来，但是是从不同角度来计算问题。通常我之前称之为映射计算。但是和映射计算不同的是，对偶计算的两个对应之间，没有谁优谁劣之分，基本上是在同一表现形式下的不同运算手段而已。映射计算多半是由于原计算实在是过于复杂或无法计算，这时候才采用映射计算来进行解决。 
好了，言归正传，我们来看一看对偶形式。由原始算法，我们可以得出，假设修改了n次w和b，那么，记$\alpha_i=n_i\eta$，则: 
$w=\displaystyle\sum_{i=1}^N\alpha_iy_ix_i$
$b=\displaystyle\sum_{i=1}^N\alpha_iy_i$
这看起来好像没啥区别，也就是把迭代w和b转换为迭代$\alpha$了。实际上是一一对应的。那么对偶形式又具有什么先进性呢？ 
**算法2.2 感知机算法的对偶形式**
输入：训练集T{($x_i,y_i$)}，其中，i∈(0,N),$y_i$∈{+1,-1},$0<\eta\leq 1$
输入$\alpha$,b;也就是感知器模型$f(x)=sign(\displaystyle\sum_{j=1}^N\alpha_jy_jx_j·x+b)$
（1）选取初值$\alpha\leftarrow0,b\leftarrow0$
（2）在训练集中选取数据$x_i,y_i$
（3）如果$y_i(\displaystyle\sum_{j=1}^N\alpha_jy_jx_j·x_i+b)\leq0$
$\alpha_i\leftarrow\alpha_i+\eta$
$b\leftarrow b+\eta y_i$
（4）转至（2），直至训练集中没有误分类点。 
粗看起来，是没有什么特别的地方，但是仔细管卡可以看到，对偶形式中训练实力仅以内积的形式出现。可以使用Gram矩阵来现进行存储，这样，在每次训练时，就不用再算一次了，样本量少的时候，可能你不觉得什么，如果样本数据十分庞大的时候，这样可以大大节省时间。 
所谓的Gram矩阵，就是格拉姆矩阵G= [Gij]，由函数的标准内积给出： 
$G=[x_i·x_j]_{N*N}$
这样就会方便许多了。
### 5.算法的收敛性
对于感知机的算法的收敛性，我们放到最后来讲。在这一点上，仍然有人存有疑问，其最大的疑问在于，既然感知机的前提条件是样本集线性可分，那么肯定能够找到这么一条超平面，可以分开正负类样本。 
但是，算法的收敛性并不是证明它能不能分，而是证明我们现在这个算法是不是正确的，也就是说，最终的结果是不是通过有限次的迭代，能够找到这么一条超平面，可以分开正负类样本。 
具体的公式大家可以看一下定理2.1（Novikoff定理），我这里简要介绍一下它的思想过程，主要证明的是$w_k$和$w_{opt}$的上下界，然后推导出k的上界的。 
它用的是数学归纳法，有人说，这跟说白话不是一样么。其实不然，在数学归纳法中最重要的是要带入你要证明的定律，这里对于w和b的推广时，就用到了梯度下降，因此才能证明，梯度下降法是正确的。
### 6. 习题解答
该习题由3题，真正需要解答的只有1题。 
第一题是要验证感知机为什么不能表示异或。其实，感知机是线性模型，而且它的前提是训练集是线性可分的，然而异或的训练样本集是线性不可分的，因此所有的线性模型都没有办法表示异或。不过幸运的是，2层感知器模型就可以很好的表示出异或，准确来讲，两层感知器模型可以表示出所有的逻辑运算符。 
第二题是个验证题，我们也不讲了，自己可以动手试试看，其实我们在机器学习的课程中就已经学习过并且考试考过了。 
第三题是要证明一下定理：样本集线性可分的充分必要条件是正实力点集所构成的凸壳与负实例点集所构成的凸壳不相交。 
大家可以参考[http://blog.csdn.net/y954877035/article/details/52210734](http://blog.csdn.net/y954877035/article/details/52210734)给出的答案。 
具体来讲就是通过必要性和充分性两个方面来对定理给出证明。在证明的时候，尤其是知道充要条件正确的情况下，我们通常采用的反证法，即假设前提是正确的，推出矛盾，从而证明原假设错误。
### 7. 小结
通过以上的讨论，我们对于感知机模型有了更为深刻的了解，对于统计机器学习也有了一定的认识，在接下来的讨论中，我们将对k近邻算法进行相关讨论。好了，下期见。
