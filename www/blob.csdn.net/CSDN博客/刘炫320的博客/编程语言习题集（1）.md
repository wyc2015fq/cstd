# 编程语言习题集（1） - 刘炫320的博客 - CSDN博客
2017年12月11日 11:15:54[刘炫320](https://me.csdn.net/qq_35082030)阅读数：831
所属专栏：[编程语言笔试习题集](https://blog.csdn.net/column/details/18350.html)
从今天开始，我们新开了一个栏目，叫做编程语言习题集，供大家对于常见的语言（Java、C#、C++、python、js）等进行相关的练习。与数理逻辑不同的是，我们这里是混合的，只挑选出容易错的题目来进行讲解。
# 1. C/C++
> 
1.1 Math.round(11.5) 等于多少 (). Math.round(-11.5) 等于多少 (  ) 
  A.11 ,-11 
  B.11 ,-12 
  C.12 ,-11 
  D.12 ,-12
参考答案：C
解析：Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：
ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；
floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；
最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.
> 
1.2有如下程序段
```cpp
#include <iostream>
using namespace std;
class A {
    public:
    ~A() {
        cout << "~A()";
    }
};
class B{
    public:
    virtual ~B() {
    cout << "~B()";
}
};
class C: public A, public B {
    public:
    ~C() {
        cout << "~C()";
    }
};
int main() {
    C * c = new C;
    B * b1 = dynamic_cast<B *>(c);
    A * a2 = dynamic_cast<A *>(b1);
    delete a2;
}
```
> 
则程序输出为: 
  A.~C()~B()~A() 
  B.~C()~A()~B() 
  C.A)B)都有可能 
  D.以上都不对
参考答案：D
解析：main()函数中，第一句只用了new，调用了构造函数，没用delete，不会调用析构函数，内存泄露。
第二句、第三句只是定义了指向不同对象的指针，不会产生对象，所以构造函数、析构函数都没调用，最后一句delete调用析构函数，因为基类A的析构函数不是虚函数，所以只调用A的析构函数，输出：~A().
如果A的析构函数加上virtual, 输出：~C()~B()~A()，与直接delete c输出一样。 析构函数声明为虚函数，这样析构时，先调用派生类的析构函数，再调用基类的析构函数，防止内存泄露。
> 
1.3有这样一个类：
```
class Eye
{
    public:
    void Look(void);
};
```
> 
现在希望定义一个Head类，也想实现Look的功能，应该使用()方法，实现代码重用。 
  A.继承 
  B.组合 
  C.模板 
  D.过滤
参考答案：B
解析：组合是在新类中以原有类的对象作为数据成员，继承是在不改变现有的类的基础上，采用现有类的形式并在其中添加新代码，组合一般用于在新类中使用现有类的功能而不是他的接口的情况，就是新类用户看到的只是为新类所定义的接口。
而继承则是用于在新类需要向基类转化的情况（多态），这也是组合和继承使用的最清晰的判断方法。
简单来讲：组合就是从小到大，而继承则是从大到小。
> 
1.4若 a 是 float 型变量,b 是 unsigned 型变量,以下输入语句中合法的是（）。 
  A.scanf(“%6.2f%d”,&a,&b); 
  B.scanf(“%f%n”,&a,&b); 
  C.scanf(“%f%3o”,&a,&b); 
  D.scanf(“%f%f”,&a,&b);
参考答案：BC
解析： 
A.浮点数类型定义宽度不能定义精度，所以%6.2是不对的，如果是%6则正确。还需要注意的是宽度是uint类型的，别定义为负数；scanf不存在printf那种左右对齐的限定符
B.%n用于接受一个uint，代表到%n为止所输入的字符数，其本身不消耗字符
C.u/o/x分别代表10/8/16进制的无符号数输入
D.整型数不能用浮点数模式输入，因为整型数和浮点型的机内表示完全不同，混用会导致未定义的结果
# 2. Java
> 
2.1下面不属于HttpServletRequest接口完成功能的是？ 
  A.读取cookie 
  B.读取HTTP头 
  C.设定响应的content类型 
  D.读取路径信息
参考答案：C
解析：A: request.getCookies();
B: request.getHeader(String s);
C: response.setContentType(“text/html;charset=utf-8”);
D: request.getContextPath();/request.getServletPath();
可以看到C是response完成的结果，在请求的时候是不能设定响应的Content类型的。
> 
2.2检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。
```java
public class HelloB extends HelloA 
{
 public HelloB()
 {
 }
 {
     System.out.println("I’m B class");
 }
 static
 {
     System.out.println("static B");
 }
 public static void main(String[] args)
 {
     new HelloB();
 }
}
class HelloA
{
 public HelloA()
 {
 }
 {
     System.out.println("I’m A class");
 }
 static
 {
     System.out.println("static A");
 }
}
```
> 
A. static A\nI’m A class\nstatic B\nI’m B class 
  B.I’m A class\nI’m B class\nstatic A\nstatic B 
  C.static A\nstatic B\nI’m A class\nI’m B class 
  D.I’m A class\nstatic A\nI’m B class\nstatic B
参考答案：C 
解析： 
1.静态代码块 2.构造代码块3.构造方法执行顺序是1>2>3
明白他们是干嘛的就理解了。
1.静态代码块：是在类的加载过程的第三步初始化的时候进行的，主要目的是给类变量赋予初始值。
2.构造代码块：是独立的，必须依附载体才能运行，Java会把构造代码块放到每种构造方法的前面，用于实例化一些共有的实例变量，减少代码量。
3.构造方法：用于实例化变量。
1是类级别的，2、3是实例级别的，自然1要优先23.
再就是明白一点：对子类得主动使用会导致对其父类得主动使用，所以尽管实例化的是子类，但也会导致父类的初始化和实例化，且优于子类执行。
> 
2.3关于struts框架，下面那些说法是正确的？ 
  A.Struts中无法完成上传功能 
  B.Struts框架基于MVC模式 
  C.Struts框架容易引起流程复杂、结构不清晰等问题 
  D.Struts可以有效地降低项目的类文件数目
参考答案：B 
解析：A，structs可以进行文件上传
B，structs基于MVC模式，MVC是模型，视图，控制器，是一种设计模式
C，structs框架让流程结构更清晰
D，structs需要很多 action类，会增加类文件数目
> 
2.4关于sleep()和wait()，以下描述错误的一项是（ ） 
  A.sleep是线程类（Thread）的方法，wait是Object类的方法； 
  B.sleep不释放对象锁，wait放弃对象锁 
  C.sleep暂停线程、但监控状态仍然保持，结束后会自动恢复 
  D.wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态
参考答案：D
解析：ava中的多线程是一种抢占式的机制，而不是分时机制。抢占式的机制是有多个线程处于可运行状态，但是只有一个线程在运行。 
wait()和sleep()的共同点 ：  
1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。  
2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。  
如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 
需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 
wait()和sleep()的不同点 ： 
1.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。  
2.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用  
3.sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常  
4.sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 
5.wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
> 
2.5JAVA反射机制主要提供了以下哪些功能？ 
  A.在运行时判断一个对象所属的类 
  B.在运行时构造一个类的对象 
  C.在运行时判断一个类所具有的成员变量和方法 
  D.在运行时调用一个对象的方法
参考答案：A B C D  
解析：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
Java反射机制主要提供了以下功能：  
    在运行时判断任意一个对象所属的类； 
    在运行时构造任意一个类的对象； 
    在运行时判断任意一个类所具有的成员变量和方法； 
    在运行时调用任意一个对象的方法； 
    生成动态代理。
> 
2.6final、finally和finalize的区别中，下述说法正确的有？ 
  A.final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
  B.finally是异常处理语句结构的一部分，表示总是执行。 
  C.finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。 
  D.引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。
参考答案：A B 
解析： 
一.final
如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在new一个对象时初始化（即只能在声明变量或构造器或代码块内初始化），而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能覆盖(重写)。
二.finally
在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
三.finalize
方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。
> 
2.7Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )
```
public class Demo{
　　float func0()
　　{
　　　　byte i=1;
　　　　return i;
　　}
　　float func1()
　　{
　　　　int i=1;
　　　　return;
　　}
　　float func2()
　　{
　　　　short i=2;
　　　　return i;
　　}
　　float func3()
　　{
　　　　long i=3;
　　　　return i;
　　}
　　float func4()
　　{
　　　　double i=4;
　　　　return i;
　　}
}
```
> 
A.func1 
  B.func2 
  C.func3 
  D.func4
参考答案：AD
解析：数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中 “ 悄然 ” 进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。
自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：  
    低 ———————————————> 高  
    byte,short,char-> int -> long -> float -> double
而由大到小需要强制转换，由小到大不需要。
# 3.$C#$
> 
3.1定义以下泛型：  
  Internal sealed class DictionaryStringKey:Dictionary{}  
  哪个选项不会抛出异常（） 
  A.Type t=typeof(Dictionary<,>); 
    Object o=Activator.CreateInstance(t); 
  B.Type t=typeof(DictionaryStringKey<>); 
    Object o=Activator.CreateInstance(t); 
  C.Type t=typeof(DictionaryStringKey); 
    Object o=Activator.CreateInstance(t);
参考答案:C
解析：选C 在.NET中，CLR会为应用程序使用的每个类型创建一个内部数据结构，这种数据结构成为：类型对象（type Object）。 
具有泛型类型参数的类型仍然是类型，CLR同样会为它创建一个内部类型对象。无论是引用类型（类）、值类型（结构）、接口类型，还是委托类型，这一点都是成立的。
然而，具有泛型类型参数的类型称之为：开放类型（open type），CLR禁止构造开放类型的任何实例。这一点类似于CLR禁止构造结构类型的实例。 
代码引用一个泛型类型时，可指定一组泛型类型实参，假如所有类型实参传递的都是实际数据类型，类型就称为封闭类型（closed type）。
CLR允许构造封闭类型的实例，然而，当代码引用一个泛型类型的时候，可能会留下一些泛型类型实参未指定，这会在CLR中创建一个新的开放类型的对象，而且不能创建该类型的实例。
> 
3.2下列描述错误的是：（ ） 
  A.类不可以多继承而接口可以 
  B.抽象类自身可以定义成员而接口不可以 
  C.抽象类和接口都不能被实例化 
  D.一个类可以有多个基类和多个基接口
参考答案：D（BD）
解析：参考答案给出的是D，但是其实严格意义上讲，B也是错的，接口也是可以定义常量成员的。
如果按照时间分类的话，类的成员分为静态成员（类）和实例成员（对象）。如果按照存储类型的话，可分为属性、方法、索引、代理、事件、嵌套类和字段。而静态常量也是属于成员的。
> 
3.3下面不是面向对象的基本原则的是？ 
  A.单一职责原则（Single-Resposibility Principle） 
  B.开放封闭原则（Open-Closed principle） 
  C.抽象类原则（Abstract-Class principle） 
  D.依赖倒置原则（Dependecy-Inversion Principle） 
  E.接口隔离原则（Interface-Segregation Principle）
参考答案：C
解析：五个基本原则： 
单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。  
接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。
依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
全部连起来就是一个单词：立方体(solid),很好记!!!
> 
3.4ASP中Session对象默认有效期为多少分钟？ 
  A.10 
  B.20 
  C.30 
  D.60
参考答案：B
解析：ASP中默认的时间20分钟
JSP使用TomCat服务器，默认是30分钟。
> 
3.5以下关于 ref 和 out 描述哪些项是正确的？（） 
  A.使用ref参数，传递到ref参数的参数必须是最先初始化 
  B.使用out参数，传递到out参数的参数必须最先初始化 
  C.使用ref参数，必须将参数作为ref参数显式传递到方法 
  D.使用out参数，必须将参数作为out参数显示传递到方法
参考答案：A C D
解析：out、ref都是引用传递，传递后使用都会改变原有的值，引用传递都需要显示传递到方法。
ref 是有进有出，即能将参数传进去，函数里对变量的改变在函数结束时会改变值，因此需要在传递进去前初始化。
out 是只出不进，即将参数传进去时值是无效的，out会把参数清空，所以无法将一个值从 out 传递进去。
# 4js
> 
4.1`1==true的返回值是true`，这句话是否正确？ 
  A.正确 
  B.错误
参考答案：A
看到很多说的类型转化其实有点错误，并不是把1转化成true，而是把true转化成1。
在==的隐式转化中，是对两边进行Number(),Number(true) = 1 
具体的，在转换不同的数据类型时，相等和不相等操作符都会遵循下列基本规则：
如果有一个操作数是布尔值，则在比较之前先将其转换为数值——false转换为0，而true转换为1；
如果一个操作符是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
如果一个操作数是对象，另一个操作数不是，则调用对象的valueof()方法，用得到的基本类型值按照前面的规则进行比较；
这两个操作符在进行比较时则要遵循下列规则。 
（1）      null和undefined是相等的。 
（2）      要比较相等性之前，不能将null和undefined转换成其他任何值。 
（3）      如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，NaN不等于NaN。 
（4）      如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则返回false。
> 
4.2下面不属于ajax事件的是？ 
  A.ajaxComplete(callback) 
  B.ajaxSuccess(callback) 
  C.$.post(url) 
  D.ajaxSend(callback)
参考答案：C
解析：$.post(url)是ajax请求；  
ajax的事件是：  
ajaxComplete(callback)  
ajaxError(callback)  
ajaxSend(callback)  
ajaxStart(callback)  
ajaxStop(callback)  
ajaxSuccess(callback)
> 
4.3表达式 ”2”+3+4 的值为？ 
  A.”27” 
  B.9 
  C.”234” 
  D.”9”
参考答案：C
解析： 
1、“+”是左关联，表达式相当于(“2”+3)+4 
2、根据ES5规范11,6,1节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+将进行拼接操作。
> 
4.4在jquery中想要找到所有元素的同辈元素，下面哪一个是可以实现的？ 
  A.eq(index) 
  B.find(expr) 
  C.siblings([expr]) 
  D.next()
参考答案;C 
解析： 
jQuery siblings() 方法 
siblings() 方法返回被选元素的所有同胞元素。 
下面的例子返回 `<h2>`的所有同胞元素：
```java
$(document).ready(function(){
  $("h2").siblings();
});
```
jQuery next() 方法 
next() 方法返回被选元素的下一个同胞元素。 
该方法只返回一个元素。 
下面的例子返回 `h2` 的下一个同胞元素：
```
$(document).ready(function(){
  $("h2").next();
});
```
jQuery find() 方法 
find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。 
下面的例子返回属于 `<div>` 后代的所有`<span>`元素：
```java
$(document).ready(function(){
  $("div").find("span");
});
```
> 
4.5以下js表达式返回false的是（） 
  A.1==true 
  B.“”==false 
  C.false==null 
  D.null==undefined
参考答案：C
解析：同第一题答案一样。
> 
4.6下面这个JS程序的输出是什么：
```
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}
var f1 = Foo(),
    f2 = Foo();
f1();
f1();
f2();
```
> 
A.0 1 0 
  B.0 1 2 
  C.0 0 0 
  D.0 0 2
参考答案：A
解析：本题考查闭包。
在一个函数的内部定义另一个函数，通过另一个函数来访问这个函数的局部变量，这是创建闭包的最常见的方式。而闭包会常驻内存（增大内存的使用量）所以，第一次调用f1后，i输出为0，但i++后，在第二次调用f1时，输出的i就为1了。另外，f2是f1都是同时声明的，二者地位相当，结果也都一样。
> 
4.7下面有关浏览器中使用js跨域获取数据的描述，说法错误的是？ 
  A.域名、端口相同，协议不同，属于相同的域 
  B.js可以使用jsonp进行跨域 
  C.通过修改document.domain来跨子域 
  D.使用window.name来进行跨域
参考答案：A
解析：这题是醉翁之意不在酒，我主要想介绍一下js跨域获取数据的方法：
1.CORS 
CORS（Corss-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。
2.document.domain 
将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。 
注意： 
不能将值设置为URL中不包含的域； 
松散的域名不能再设置为紧绷的域名。
3.图像Ping 
var img=new Image(); 
img.onload=img.onerror=function(){ 
… … 
} 
img.src=”url?name=value”; 
请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。 
图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 
缺点： 
只能发送GET请求； 
无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。
4.Jsonp 
var script=document.createElement(“script”); 
script.src=”url?callback=handleResponse”; 
document.body.insertBefore(script,document.body.firstChild); 
JSONP由两部分组成：回调函数和数据 
回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 
数据是传入回调函数中的JSON数据。 
优点： 
能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 
缺点： 
JSONP从其他域中加载代码执行，其他域可能不安全； 
难以确定JSONP请求是否失败。
5.Comet 
Comet可实现服务器向浏览器推送数据。 
Comet是实现方式：长轮询和流 
短轮询即浏览器定时向服务器发送请求，看有没有数据更新。 
长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。 
流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。
6.WebSocket 
WebSocket可在一个单独的持久连接上提供全双工、双向通信。 
WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。 
var webSocket=new WebSocket(“ws://”); 
webSocket.send(message); 
webSocket.onmessage=function(event){ 
var data=event.data; 
… …. 
} 
注意： 
必须给WebSocket构造函数传入绝对URL； 
WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器； 
WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。
优点： 
在客户端和服务器之间发送非常少的数据，减少字节开销。
> 
4.8javascirpt中的数字在计算机内存储为多少Byte？ 
  A.2 Byte 
  B.4Byte 
  C.8Byte 
  D.16Byte
参考答案：C
解析：关于Javascript中数字的部分知识总结： 
1. Javascript中，由于其变量内容不同，变量被分为基本数据类型变量和引用数据类型变量。基本类型变量用八字节内存，存储基本数据类型(数值、布尔值、null和未定义)的值，引用类型变量则只保存对对象、数组和函数等引用类型的值的引用(即内存地址)。 
2. JS中的数字是不分类型的，也就是没有byte/int/float/double等的差异。 
3. JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。
> 
4.9下面有关javascript内部对象的描述，正确的有？ 
  A.History 对象包含用户（在浏览器窗口中）访问过的 URL 
  B.Location 对象包含有关当前 URL 的信息 
  C.Window 对象表示浏览器中打开的窗口 
  D.Navigator 对象包含有关浏览器的信息
参考答案：ABCD
解析：Navagator：提供有关浏览器的信息
Window：Window对象处于对象层次的最顶层，它提供了处理Navagator窗口的方法和属性
Location：提供了与当前打开的URL一起工作的方法和属性，是一个静态的对象
History：提供了与历史清单有关的信息
Document：包含与文档元素一起工作的对象，它将这些元素封装起来供编程人员使用。
# 5Html/Css
> 
5.1网页开发中，一般需判断浏览器类型，需通过userAgent中获取浏览器内核来判断，下列说法错误的是？ 
  A.一直到IE9，都是Trident内核 
  B.firefox是Gecko内核 
  C.chrome是webkit内核 
  D.IE是目前最快的浏览器
参考答案：D
解析：又黑IE，我们也希望有一天D不是错误答案。正经的，
-moz代表firefox浏览器私有属性
-ms代表IE浏览器私有属性
-webkit代表chrome、safari私有属性 IE使用的是Trident内核，Firefox 使用的是Gecko内核。目前使用IE内核的浏览器还有搜狗，遨游，360等等。
> 
5.2下面哪条声明能固定背景图片（） 
  A.background-attachment:fixed; 
  B.background-attachment:scroll; 
  C.background-origin: initial; 
  D.background-clip: initial;
参考答案：A
解析：background-attachment有三个值，scroll是默认值，背景图像会随着页面其余部分的滚动而移动。fixed当页面的其余部分滚动时，背景图像不会移动。 inherit规定应该从父元素继承 background-attachment 属性的设置。
background-origin属性规定 background-position 属性相对于什么位置来定位。
background-clip 属性规定背景的绘制区域。
> 
5.3用于预格式化文本的标签是 
  A.`<meta>`
  B.`<pre>`
  C.`<mark>`
  D.`<small>`
参考答案：B 
解析： 
`<meta>` 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 
`<meta>` 标签位于文档的头部，不包含任何内容。 
`<meta>` 标签的属性定义了与文档相关联的名称/值对。 
`<mark>`标签定义带有记号的文本。请在需要突出显示文本时使用 `<m>`标签。 
`<small>`标签呈现小号字体效果。
> 
5.4下列哪些功能可以通过Cookie来实现？（ ） 
  A.记录访问者的信息 
  B.在页面之间传递信息 
  C.自动识别用户 
  D.对数据库进行操作
参考答案：ABC
解析： 
A 项，访问者的信息一般都可以处理成 kv 键值对的形式，故可以保存在 Cookie 中，正确。
B 项，通过设置 Cookie 的 path 等属性，可以在特定域名或 URI 下共享 Cookie 信息，正确。
C 项，通过在 Cookie 中保存用户uid、服务器会话sid等方法，可以记录用户登录状态，正确。
D 项，Cookie 是保存在用户浏览器上的小文本文件，不是数据库，也没有提供操作数据库的 API，故此项错误。
> 
5.5MVC是一种常见的架构。以下描述错误的是？ 
  A.只有Web系统才能使用MVC 
  B.只有能够保存正在数据库里面的实体才能称之为模型（Model） 
  C.只有以HTML形式显示的页面才是视图（View） 
  D.模型变更之后，只有控制器（Controller）才能驱动视图变更或重新渲染视图
参考答案：ABC
解析： 
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 
通常模型对象负责在数据库中存取数据。
View（视图）是应用程序中处理数据显示的部分。 
通常视图是依据模型数据创建的。
Controller（控制器）是应用程序中处理用户交互的部分。 
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
B主要是因为如果现在不在数据库里实体也是可以成为模型的。
> 
5.6关于bootstrap以下说法正确的是 
  A.为`<table>`标签添加.table类可以给表格添加水平分割线 
  B.给表格添加table-striped类可以使IE8中的表格出现斑马线 
  C.为表格添加table-bordered类可为表格中每个元素增加边框 
  D.为表格添加table-hover类可为表格中增加鼠标悬停样式
参考答案：ACD
解析： 
.table  为任意 `<table>` 添加基本样式 (只有横向分隔线) 
.table-striped  在 `<tbody>` 内添加斑马线形式的条纹 ( IE8 不支持) 
.table-bordered 为所有表格的单元格添加边框 
.table-hover    在 `<tbody>` 内的任一行启用鼠标悬停状态 
.table-condensed    让表格更加紧凑
