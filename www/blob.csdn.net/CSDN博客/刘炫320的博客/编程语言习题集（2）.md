# 编程语言习题集（2） - 刘炫320的博客 - CSDN博客
2017年12月18日 17:10:30[刘炫320](https://me.csdn.net/qq_35082030)阅读数：464
所属专栏：[编程语言笔试习题集](https://blog.csdn.net/column/details/18350.html)
# 1.C/C++
> 
1.1以下叙述中正确的是（） 
  A.int* p1; int ** p2; int *p3;都是合法的定义指针变量的语句 
  B.指针变量只能通过求地址运算符（&) 来获得地址值 
  C.语句p=NULL;与p=\0;是等价的语句 
  D.语句p=NULL;执行后，指针p指向地址为0的存储单元
参考答案：A
解析：
B 选项描述不正确，指针变量可以通过求地址运算符（ &) 来获得地址值，可以通过指针变量获得地址值，还可以通过标准函数获得地址值；
C 选项中， p=NULL ；和 p=0 ；或 p=’\0’ ；等价； 
> 
1.2关于内联函数说法错误的是: 
  A.不是任何一个函数都可定义成内联函数 
  B.内联函数的函数体内不能含有复杂的结构控制语句 
  C.递归函数可以被用来作为内联函数 
  D.内联函数一般适合于只有1~5行语句的小函数
参考答案：C
解析：
内联函数是使用inline关键字声明的函数，也成内嵌函数，它主要的作用是解决程序的运行效率。
使用内联函数的时候要注意：
- 
递归函数不能定义为内联函数
- 
内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。
- 
内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。
- 对内联函数不能进行异常的接口声明。
> 
1.3请问经过表达式a = 5 ? 0 : 1的运算,变量a的最终值是? 
  A.5 
  B.1 
  C.0 
  D.true
参考答案：C
解析：
首先明确一点，赋值运算符的优先级基本上是最低的。因此应当优先进行三目运算符，5是非0的，也就是True，因此三目运算符的值为True，也就是0，因此a也为0。
> 
1.4下面说法正确的是（） 
  A.C++已有的任何运算符都可以重载 
  B.const对象只能调用const类型成员函数 
  C.构造函数和析构函数都可以是虚函数 
  D.函数重载返回值类型必须相同
参考答案：B
解析：
A，普通的运算符可以重载，特殊的不能重载，比如 . :: 等
B，coust是常对象，也就是不改变成员变量的值，而成员函数中只有const函数可以确保不改变成员变量的值
C，析构函数一般定义为虚函数，构造函数不能是虚函数、内联函数和静态函数。
D，重载只要求函数名相同，参数类型和个数不同，不要求返回值类型
> 
1.5如果类的定义如下，则以下代码正确并且是良好编程风格的是：
```
class Object
{
  public:
    virtual ~Object() {}
    //…
};
```
A.`std::auto_ptr<Object> pObj(new Object);`
B.`std::vector<std::auto_ptr<Object*> > object_vector;`
C.`std::auto_ptr<Object*> pObj(new Object);`
D.`std::vector<std::auto_ptr<Object> > object_vector;`
参考答案：A
解析：
- 
1 auto_ptr的意义  
`std::auto_ptr`是C++标准库里面的模版类， 属于智能指针 
当系统异常退出的时候避免资源泄漏（内存）。 其他的资源还对应其他的智能指针。  
- 
2 auto_ptr的使用  
`std::auto_ptr<int> test(new int（1）);`
test将是一个auto_ptr的对象，使用一个int指针进行初始化。  
test可以象其他指针一样使用，如使用* 使用->但是＋＋不可以使用，以后也许会扩展，其实难对++做越界管理，也许可以放弃一些速度。 
当使用`auto_ptr`的时候，必须使用显式的类型转化来初始化，如`auto_ptr<classA> a(new classA）`
而不能使用`auto_ptr<classA> a = new classA;`
- 
3 `auto_ptr`所有权的转移  
`auto_ptr`对所有权有严格的约定，一个`auto_ptr`只能控制一个指针，不能控制多个，当`auto_ptr`拥有一个指针的时候就不能在拥有其他的指针了。同时，不同的`auto_ptr`不能拥有同一个指针。
智能指针实质是一个栈对象，而并非指针类型。C++的`auto_ptr`的作用是动态分配对象以及当对象不再需要时自动执行清理。 
使用`std::auto_ptr`，要`#include <memory>`。
（1）尽量不要使用“`operator=`”（如果使用了，请不要再使用先前对象）。
（2）记住`release()`函数不会释放对象，仅仅归还所有权。
（3）`std::auto_ptr`最好不要当成参数传递（读者可以自行写代码确定为什么不能）。
（4）`auto_ptr`存储的指针应该为NULL或者指向动态分配的内存块。
（5）`auto_ptr`存储的指针应该指向单一物件（是new出来的，而不是new[]出来的）。`auto_ptr`不能指向数组，因为`auto_ptr`在析构的时候只是调用delete,而数组应该要调用delete[]。
（6）使用`auto_ptr`作为成员变量，以避免资源泄漏。
（7）`auto_ptr`不能共享所有权，即不要让两个auto_ptr指向同一个对象。
（8）`auto_ptr`不能作为容器对象，STL容器中的元素经常要支持拷贝，赋值等操作，在这过程中`auto_ptr`会传递所有权，那么source与sink元素之间就不等价了。
# 2.$C#$
> 
2.1在C#中，索引器是专门用来访问对象中的数组信息的。 
  A.对 
  B.错
参考答案：B
解析：索引器为c#程序语言中类的一种成员，它使得对象可以像数组一样被索引，使程序看起来更直观，更容易编写。它可以使得像数组那样对对象使用下标。它提供了通过索引方式方便地访问类的数据信息的方法。
要声明类或结构上的索引器，请使用this关键字，例如： public int this[int index] //声明索引器 { // get and set 访问 }
> 
2.2接口中的成员不可以有访问域修饰符，但可以有其它修饰符。 
  A.对 
  B.错
参考答案：B
解析：类定义中可以使用的访问修饰符组合
none or internal 类只能在当前工程中访问
public 类可以在任何地方访问
abstract or internal abstract 类只能在当前工程中访问，不能实例化，只能继承
public abstract 类可以在任何地方访问，不能实例化，只能继承
sealed or internal sealed 类只能在当前工程中访问，不能派生，只能实例化
public sealed 类可以在任何地方访问，不能派生，只能实例化
下面介绍一下C#中方法、类等的默认访问修饰符
- 接口(interface) 
接口成员访问修饰符默认为public,且不能显示使用访问修饰符。
- 类(class) 
构造函数默认为public访问修饰符。 
析构函数不能显示使用访问修饰符且默认为private访问修饰符。 
类的成员默认访问修饰符为private;
- 枚举(enum) 
枚举类型成员默认为public访问修饰符，且不能显示使用修饰符。
- 结构(struct) 
构成员默认为private修饰符。 
结构成员无法声明为protected成员，因为结构不支持继承。
- 嵌套类型 
嵌套类型的默认访问修饰符为private。 和类，结构的成员默认访问类型一致
> 
2.3请问， o.MethodA 调用的是?
```
using System;
namespace Application
{
abstract class BaseClass
{
    public virtual void MethodA()
    {
    }
    public virtual void MethodB()
    {
    }
}
class Class1: BaseClass
{
    public void MethodA(string arg)
    {
    }
    public override void MethodB()
    {
    }
}
class Class2: Class1
{
    new public void MethodB()
    {
    }
}
class MainClass
{
    public static void Main(string[] args)
    {
        Class2 o = new Class2();
        o.MethodA();
    }
}
}
```
> 
A.BaseClass.MethodA 
  B.Class2.MethodA 
  C.Class1.MethodA 
  D.都不是
参考答案：A
解析：无论是class1还是class2都没有override/new MethodA(),所以调得是基类的virtual MethodA();因为Class1里的MethodA是有参数的。
> 
2.4在C#中，int[][]是定义一个int型的二维数组。 
  A.对 
  B.错
参考答案：B
解析：
int[][] 是锯齿数组必须一维度一维度的新建。
int[,]是二维数组。
> 
2.5以下的 c# 代码段：
```
Public struct Person{
 String Name;
 Int Age;
}
Public  static void Main()
{
 Hashtable A;
 Person B;
 // 其他处理代码
}
```
> 
以下说法正确的是（） 
  A.A为引用类型的变量，B为值类型的变量 
  B.A为值类型的变量 ，B为引用类型的变量 
  C.A和B都是值类型的变量 
  D.A和B都是引用类型的变量
参考答案：A
解析：在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。
# 3.Java
> 
3.1下面关于垃圾收集的描述哪个是错误的？ 
  A.使用垃圾收集的程序不需要明确释放对象 
  B.现代垃圾收集能够处理循环引用问题 
  C.垃圾收集能提高程序员效率 
  D.使用垃圾收集的语言没有内在泄漏问题
参考答案：D
解析：也会有内存泄露问题，例如访问资源文件，流不关闭，访问数据库等连接不关闭。
内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。
内存泄露主要有两种情况：
1.在堆中申请的空间没有释放。
2.对象已不再被使用(注意：这里的不在被使用是指对程序来说没有用处，如数据库连接使用后没有关。但是还是存在着引用)，但是仍然在内存中保留着。
GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。
内存泄露的原因： 
1.静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。
2.各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。
3.监听器，释放对象时往往没有相应的删除监听器，可能会导致内存泄露。
内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄露（Memory Leak）最终会导致内存溢出。
> 
3.2J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（    ）方法 
  A.service 
  B.doget 
  C.dopost 
  D.init
参考答案：A
解析：HttpServlet容器响应Web客户请求流程如下：
1）Web客户向Servlet容器发出Http请求；
2）Servlet容器解析Web客户的Http请求；
3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；
4）Servlet容器创建一个HttpResponse对象；
5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；
6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；
7）HttpServlet调用HttpResponse的有关方法，生成响应数据；
8）Servlet容器把HttpServlet的响应结果传给Web客户。
> 
3.3下面有关struts1和struts2的区别，描述错误的是？ 
  A.Struts1要求Action类继承一个抽象基类。Struts 2 Action类可以实现一个Action接口 
  B.Struts1 Action对象为每一个请求产生一个实例。Struts2 Action是单例模式并且必须是线程安全的 
  C.Struts1 Action 依赖于Servlet API，Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试 
  D.Struts1 整合了JSTL，Struts2可以使用JSTL，但是也支持OGNL
参考答案：B
解析：Struts1和Struts2的区别和对比:
Action 类:  
• Struts1要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口，而struts2的Action是接口。  
• Struts 2 Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts2提供一个ActionSupport基类去 实现 常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。 
线程模式:  
• Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。 
• Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题） 
Servlet 依赖:  
• Struts1 Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和 HttpServletResponse 被传递给execute方法。 
• Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。 
可测性:  
• 测试Struts1 Action的一个主要问题是execute方法暴露了servlet API（这使得测试要依赖于容器）。一个第三方扩展－－Struts TestCase－－提供了一套Struts1的模拟对象（来进行测试）。 
• Struts 2 Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。  
捕获输入:  
• Struts1 使用ActionForm对象捕获输入。所有的ActionForm必须继承一个基类。因为其他JavaBean不能用作ActionForm，开发者经常创建多余的类捕获输入。动态Bean（DynaBeans）可以作为创建传统ActionForm的选择，但是，开发者可能是在重新描述(创建)已经存 在的JavaBean（仍然会导致有冗余的javabean）。 
• Struts 2直接使用Action属性作为输入属性，消除了对第二个输入对象的需求。输入属性可能是有自己(子)属性的rich对象类型。Action属性能够通过 web页面上的taglibs访问。Struts2也支持ActionForm模式。rich对象类型，包括业务对象，能够用作输入/输出对象。这种 ModelDriven 特性简化了taglib对POJO输入对象的引用。 
表达式语言：  
• Struts1 整合了JSTL，因此使用JSTL EL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。  
• Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－”Object Graph Notation Language” (OGNL). 
> 
3.4下列哪种情况可以终止当前线程的运行？ 
  A.当一个优先级高的线程进入就绪状态时 
  B.当该线程调用sleep()方法时 
  C.当创建一个新线程时 
  D.抛出一个异常时
参考答案：D
解析：
优先级高的并不一定会马上执行。
sleep方法会阻塞一个线程并不会终止
创建一个新的线程时也不会终止另一个线程
当抛出一个异常后程序会结束，所以线程也会被终止
> 
3.5HashMap和HashTable的描述，错误的是 
  A.他们都实现了Map接口。 
  B.HashMap非线程安全，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供额外同步。 
  C.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
  D.通过contains方法可以判断一个对象是否存在于HashMap或者Hashtable中。
参考答案：D
解析：
- 
关于HashMap的一些说法： 
a)  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 
b)  HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。 
c)  HashMap实现不同步，线程不安全。  HashTable线程安全 
d)  HashMap中的key-value都是存储在Entry中的。 
e)  HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 
f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 
注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位； 
用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。 
拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。
- 
Hashtable和HashMap的区别： 
a)   继承不同。 
public class Hashtable extends Dictionary implements Map 
public class HashMap extends  AbstractMap implements Map 
b)  Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 
c)  Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。 
d)  两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 
e)  哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 
f)  Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。
注：  HashSet子类依靠hashCode()和equal()方法来区分重复元素。 
     HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。
# 4.js
> 
4.1
```
var one;
var two=null;
console.log(one==two,one===two);
```
> 
上面代码的输出结果是： 
  A.true false 
  B.true true 
  C.false false 
  D.false true 
  E.错误：one没有定义
参考答案：A
解析：在JavaScript中下面的值被当作假 :false. undefined. null. 空字符串 数字0 数字NAN
one==two 是 loose comparison, 只比较值, 不比较类型, 所以为 true
one===two 是 strict comparison, 既比较值, 又比较类型, 所以为 false
> 
4.2要在10秒后调用checkState，下列哪个是正确的 
  A.window.setTimeout(checkState, 10); 
  B.window.setTimeout(checkState, 10000); 
  C.window.setTimeout(checkState(), 10); 
  D.window.setTimeout(checkState(), 10000);
参考答案：B
解析：checkState加了圆括弧相当于函数表达式，会立即执行，执行的结果作为返回值传递给settimeout,下面是个例子：
```
window.setTimeout(checkState(), 10000); //立即被调用 
window.setTimeout(checkState, 10000); // 10s后被调用 
window.setTimeout("checkState()", 10000); //10s后被调用 注意和第一个的区别 有引号
```
> 
4.3在JavaScript中，文本域不支持的事件包括( ) 
  A.onBlur 
  B.onLostFocused 
  C.onChange 
  D.onFocus
参考答案：B
解析：
onBlur:文本域失去焦点
onFocus:得到焦点
onchange:焦点状态改变
> 
4.4写出下面代码的运行结果
```java
var a,b;
(function(){
    alert(a);
    alert(b);
    var a=b=3;
    alert(a);
    alert(b);
})();
alert(a);
alert(b);
```
> 
A.undefined，undefined，3,3，undefined，3 
  B.undefined，undefined，3,3，undefined，undefined 
  C.0，0，3,3，undefined，undefined 
  D.undefined，undefined，3,3，0，0
参考答案：A
解析：这里要注意`var a=b=3;`这里的b并没有新创建。
> 
4.5在ECMAScript6 中,promise的状态有（） 
  A.Pending 
  B.Pause 
  C.Resolved 
  D.Rejected
参考答案：ACD
解析：‘Promise 对象代表一个异步操作，有3种状态：Pending(进行中)、Resolved(已完成，又称Fulfilled)和Rejected(已拒绝)’
# 5.HTML/CSS
> 
5.1下面关于 CSS 布局的描述，不正确的是？（ ） 
  A.块级元素实际占用的宽度与它的 width 属性有关； 
  B.块级元素实际占用的宽度与它的 border 属性有关； 
  C.块级元素实际占用的宽度与它的 padding 属性有关； 
  D.块级元素实际占用的宽度与它的 background 属性有关。
参考答案：D 
解析：D.描述不正确：background设置背景属性，与块级元素实际占用宽度无关；  
A.描述正确：width设置宽度属性，与块级元素实际占用宽度有关；  
B.描述正确：border设置边框属性，与块级元素实际占用宽度有关；  
C.描述正确：padding设置内边距属性，与块级元素实际占用宽度有关。
> 
5.2以下关于盒子模型描述正确的是： 
  A.标准盒子模型中：盒子的总宽度 ＝ 左右margin + 左右border + 左右padding + width 
  B.IE盒子模型中：盒子总宽度 ＝ 左右margin + 左右border + width 
  C.标准盒子模型中：盒子的总宽度 ＝ 左右margin + 左右border + width 
  D.IE盒子模型中：盒子总宽度 ＝ width
参考答案：A
解析： 
标准W3C模型：$宽度 = margin*2 + border*2 + padding*2 + width$
IE模型： $宽度 = margin*2 + width$
不同的是在标准盒子模型中content是一个独立的部分不包含其他部分！！但是在IE盒子模型中content包含了border,padding,是一个总体的概念！
> 
5.3能在1024的windows机器上显示8列而在肾6手机上显示12列的是 
  A.col-md-8 col-xs-12 
  B.col-lg-8 col-sm-12 
  C.col-md-8 col-sm-12 
  D.col-lg-8 col-xs-12
参考答案：A 
解析： 
.col-xs- 超小屏幕 手机 <768px 
.col-sm- 小屏幕 平板  >=768px 
.col-md- 中等屏幕  >=992px 
.col-lg- 大屏幕  >1200px
> 
5.4下面有关CSS sprites说法错误的是？ 
  A.允许你将一个页面涉及到的所有零星图片都包含到一张大图中去 
  B.利用CSS的“background-image”，“background-repeat”，“background-position”的组合进行背景定位 
  C.CSS Sprites虽然增加了总的图片的字节，但是很好地减少网页的http请求，从而大大的提高页面的性能 
  D.CSS Sprites整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名
参考答案：C 
解析：把多个图片放到同一张图中，图片的总大小是减少的。
