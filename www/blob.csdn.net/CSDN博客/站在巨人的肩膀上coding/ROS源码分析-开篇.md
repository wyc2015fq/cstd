# ROS源码分析-开篇 - 站在巨人的肩膀上coding - CSDN博客





2018年07月18日 16:45:22[coding思想](https://me.csdn.net/LOVE1055259415)阅读数：640








原作者：[sukha1988](https://blog.csdn.net/sukha)

博客链接：[https://blog.csdn.net/sukha/article/details/52454735](https://blog.csdn.net/sukha/article/details/52454735)

# ROS源码分析

## 写在前面

很久就有写ROS源码分析的想法。2014年最初接触ROS，当时中文资料比较少，基本只有一本红皮的ROS介绍，内容大多是对ROS官方wiki的翻译，版本也跟不上ROS官方发布的速度。因此开始刷官方wiki教程。官方教程简单形象，原理与例子结合，至今我仍然认为是入门ROS的不二之选。

刷完教程后，出于工作需要（主要在ROS实时性方面），开始阅读ROS的核心代码。ROS的代码量并不大，结构也比较清楚，虽然可以用来参考学习的资料完全没有，并且本人也非计算机专业出身，C++功底并不深，但结合实际使用效果勉强啃得动。当时觉得如果有个参考的资料，讲讲每个文件是干什么，每个函数是什么功能，那学习起来就方便多了。但是并没有。

如今两年过去了，机器人行业越来越火，ROS也逐渐成为机器人软件平台的事实标准，但依然没有人对ROS的源码进行分析。仔细想想，这种状况也算是正常的，毕竟使用ROS的人一般只关注ROS带来的简单的接口、丰富的调测试工具、多语言多平台的支持以及海量开源代码包，而对于ROS到底如何实现这些并不关心。同时ROS当前的主要受众还是学术界，更强调新研究、新算法的快速部署，对调度、通信的性能并不特别关注。而国外的ROS的开发者和维护者本身对ROS特别熟悉，没有必要专门花心思在介绍ROS内部的实现机制上。

那么分析ROS的源码到底有没有用呢？如果你是一个ROS的使用者，只是用ROS的包进行学术研究和算法验证，那么分析ROS源码的用处并不大。分析ROS源码能够让你更清楚ROS的用法，在出现某些错误时能够更快速的定位问题，但也仅此而已。对于你的目标，分析源码带来的收益与付出的时间是不符的。 

不过我相信，在进行ROS学习的过程中，总有人有好奇心，想要知道ROS到底是如何封装node的？是如何实现topic的？是如何收发message的？或者有人像我一样，想知道为什么ROS不能保证消息传输的实时性？在存在大量节点时通信的瓶颈在哪？

要想知道这些问题，就需要对ROS的源码进行分析。 

从今天开始，希望以后每个工作日都能有更新，把我在阅读ROS源码获得的一些经验和大家分享。一是对知识的总结和归纳，二是与其他高手交流，最后也希望能够为刚刚接触ROS的朋友提供一点帮助。

首先，从文件结构开始。

## 文件结构

从Groovy版本开始，ROS正式引入全新的编译工具catkin。同时被抛弃的还有“stack”的概念。我接触ROS也是在这个时间点上，因此对之前的ROS文件结构了解的也不是很深。 

从引入catkin开始，ROS的文件结构没有发生大的变化。由于ROS内核源码也是以同样的结构组织，因此在此进行一点简单说明。 

对于任何一个ROS package，其文件结构如下：
- package_name 
	- include 
		- file.h

- src 
		- file.cpp

- msg(optional) 
		- MyMessage.msg

- srv(optional) 
		- MyService.srv

- launch(optional) 
		- MyLaunch.launch

- **CMakeList.txt**
- **package.xml**


编译工具catkin是基于CMake实现的，因此主要的编译选项在CMakeList.txt中进行配置。CMakeList.txt的语法与CMake完全一致，只不过增加了一些用于catkin和ROS的语句。 

package.xml是用来指示编译和运行时所依赖的其它软件包，同时保存本软件包的描述信息。

在我们编写ROS程序时，必须依赖roscpp和/或rospy两个代码包，这两个包均在ros_comm元包（meta package）中，[github地址](https://github.com/ros/ros_comm)

对ROS源码的分析从roscpp开始，整个代码树结构如下图：

![roscpp代码结构](https://img-blog.csdn.net/20160906231222213)

这里面，msg目录下是一个log消息文件，srv目录下是三个服务文件，后两个可以用于在运行时动态改变log打印级别，后面代码涉及到时会在详细说明。大部分代码分布在include/ros和src/libros两个目录下，这和我们常见的项目代码组织形式比较一致。 

后面的大部分分析工作主要在这两个目录下进行。



