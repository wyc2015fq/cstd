# 动态规划入门之硬币问题 - Machine Learning with Peppa - CSDN博客





2018年02月04日 20:34:05[刺客五六柒](https://me.csdn.net/qq_39521554)阅读数：229标签：[算法																[数据结构																[动态规划																[编程](https://so.csdn.net/so/search/s.do?q=编程&t=blog)
个人分类：[***算法与编程艺术***																[算法之数据结构																[Data Science：机器学习](https://blog.csdn.net/qq_39521554/article/category/7361355)
所属专栏：[有趣的算法](https://blog.csdn.net/column/details/19022.html)[机器学习与数据挖掘](https://blog.csdn.net/column/details/18961.html)](https://blog.csdn.net/qq_39521554/article/category/7389781)




## 问题描述



动态规划算法的核心是：每一个子问题的状态和状态的转移方程。




状态是：dp[i] ，即凑够i元最少须要的硬币的个数


转移方程是：dp[i] = min(dp[i-C1]+1,dp[i-C2]+1,dp[i-C3]+1,……,dp[i-Cj]+1])


即。每一个状态的值都是最小的那个。



假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 11 元，问如何组合才能使硬币的数量最少？

## 问题分析


乍看之下，我们简单的运用一下心算就能解出需要 2 个 5 元和 1 个 1 元的解。当然这里只是列出了这个问题比较简单的情况。当硬币的币制或者种类变化，并且需要凑出的总价值变大时，就很难靠简单的计算得出结论了。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。


这里运用动态规划的思路解决该问题。按照一般思路，我们先从最基本的情况来一步一步地推导。


我们先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量。
- 当 i = 0 时，很显然我们可以知道 d(0) = 0。因为不要凑钱了嘛，当然也不需要任何硬币了。注意这是很重要的一步，其后所有的结果都从这一步延伸开来。
- 当 i = 1 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = 1。
- 当 i = 2 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = 2。
- 当 i = 3 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 3 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上
 1 个 3 元硬币，得到 d(3) = 1。
- ...


接着就不再举例了，我们来分析一下。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。得出：

d(i) = d(j) + 1


这里 j < i。通俗地讲，我们需要凑出 i 元，就在凑出 j 的结果上再加上某一个硬币就行了。


那这里我们加上的是哪个硬币呢。嗯，其实很简单，把每个硬币试一下就行了：
- 假设最后加上的是 1 元硬币，那 d(i) = d(j) + 1 = d(i - 1) + 1。
- 假设最后加上的是 3 元硬币，那 d(i) = d(j) + 1 = d(i - 3) + 1。
- 假设最后加上的是 5 元硬币，那 d(i) = d(j) + 1 = d(i - 5) + 1。


我们分别计算出 d(i - 1) + 1，d(i - 3) + 1，d(i - 5) + 1 的值，取其中的最小值，即为最优解，也就是 d(i)。


最后公式：

![](https://img-blog.csdn.net/20180204203300911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzk1MjE1NTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)






- #include<iostream>
- usingnamespace std;  
- //money需要找零的钱
- //coin可用的硬币
- //硬币种类
- void FindMin(int money,int *coin, int n)  
- {  
- int *coinNum=newint[money+1]();//存储1...money找零最少需要的硬币的个数
- int *coinValue=newint[money+1]();//最后加入的硬币，方便后面输出是哪几个硬币
-     coinNum[0]=0;  
- 
- for(int i=1;i<=money;i++)  
-     {  
- int minNum=i;//i面值钱，需要最少硬币个数
- int usedMoney=0;//这次找零，在原来的基础上需要的硬币
- for(int j=0;j<n;j++)  
-         {  
- if(i>=coin[j])//找零的钱大于这个硬币的面值
-             {  
- //if(coinNum[i-coin[j]]+1<=minNum)//所需硬币个数减少了
- /*
-                 上面的判断语句有问题，在更新时，需要判断i-coin[j]是否能找的开，如果找不开，就不需要更新。
-                 多谢zywscq 指正
-                 */
- if(coinNum[i-coin[j]]+1<=minNum&&(i==coin[j]||coinValue[i-coin[j]]!=0))//所需硬币个数减少了
-                 {  
-                     minNum=coinNum[i-coin[j]]+1;//更新
-                     usedMoney=coin[j];//更新
-                 }  
-             }  
-         }  
-         coinNum[i]=minNum;  
-         coinValue[i]=usedMoney;  
-     }](https://blog.csdn.net/qq_39521554/article/category/7361353)](https://so.csdn.net/so/search/s.do?q=动态规划&t=blog)](https://so.csdn.net/so/search/s.do?q=数据结构&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)




