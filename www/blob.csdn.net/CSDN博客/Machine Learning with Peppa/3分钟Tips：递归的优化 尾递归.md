# 3分钟Tips：递归的优化|尾递归 - Machine Learning with Peppa - CSDN博客





2018年03月02日 22:41:59[刺客五六柒](https://me.csdn.net/qq_39521554)阅读数：222标签：[算法																[递归																[优化																[Python																[编程](https://so.csdn.net/so/search/s.do?q=编程&t=blog)
个人分类：[编程之美：C/C++																[算法之离散数学																[***算法与编程艺术***](https://blog.csdn.net/qq_39521554/article/category/7361353)
所属专栏：[C语言入门](https://blog.csdn.net/column/details/18792.html)](https://blog.csdn.net/qq_39521554/article/category/7476429)




**定义：**

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。





**优点：**

当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。因此，它有如下三个优点

1. 通过覆盖当前的栈帧而不是在其之上重新添加一个

2. 所使用的栈空间就大大缩减

3. 大大提高实际的运行效率





**例子：**




尾递归就是操作的**最后一步**是调用自身的递归。
这是尾递归：


```
function f(x) {
   if (x === ) return ;
   return f(x-);
}
```


（这个程序没什么意义，仅作为理解辅助之用）

这不是尾递归：


```
function f(x) {
   if (x === ) return ;
   return  + f(x-);
}
```



后者不是尾递归，是因为该函数的最后一步操作是用1加上f(x-1)的返回结果，因此，最后一步操作不是调用自身。注意，后面这段代码的递归也发生在函数末尾，但它不是尾递归。**尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。**因此阶乘n!的递归求法，尽管看起来递归发生在函数末尾，其实也不是尾递归：


```
function factorial(n) {
   if (n === ) return ;
   return n * factorial(n-); // 最后一步不是调用自身，因此不是尾递归
}
```



使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。

一些语言提供了尾递归优化，当识别出使用了尾递归时，会相应地只保留当前层函数的stack，节省内存。




**方法：**




那么，怎么优化成尾递归的形式呢？我们观察到，f(x)中形式变量x的实际变量值是不断更新的，对比普通递归就很清楚，后者仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。


怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：



`return tailrec(x+)`](https://blog.csdn.net/qq_39521554/article/category/7294876)](https://so.csdn.net/so/search/s.do?q=Python&t=blog)](https://so.csdn.net/so/search/s.do?q=优化&t=blog)](https://so.csdn.net/so/search/s.do?q=递归&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)




