# 一文读懂RAS公钥加密算法与非对称加密 - Machine Learning with Peppa - CSDN博客





2018年04月11日 09:50:59[刺客五六柒](https://me.csdn.net/qq_39521554)阅读数：241








本文参考如下资料（建议阅读）：

a). [公钥加密](https://en.wikipedia.org/wiki/Public-key_cryptography)

b). [Diffie-Hellman密钥交换](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)

c). [公钥证书](https://en.wikipedia.org/wiki/Public_key_certificate)

d). [公钥证书X509](https://en.wikipedia.org/wiki/X.509)

公钥加密算法又称非对称加密算法，围绕这一算法延伸出很多东西，比如：公私密钥对，密钥交换，身份验证，证书，签名。。。




## 1. 密钥对

我们先从密钥对说起，这是其他所有拓展技术的核心。

公私密钥对实际上是一种数学元素延伸出来的产物，产生的过程如下（起源的方式）：

![](https://img-blog.csdn.net/20151006210906308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


                                                                                            图示1

其中a即为Alice的私钥，A为Alice的公钥。b即为Bob的私钥，B为Bob的公钥。

嗯...因为我是做工程的，没法带领读者深入探究它的数学理论了，有兴趣的可以google，我们回到这个数学理论与密钥对的联系。

有趣的地方就在于a加密的内容只有A能解密，反之A加密的内容只有a能解密。a加密的内容a本身不能解密，A加密的内容A本身也不能解密。

## 2. 密钥交换

严格来说是公钥交换。（在公钥加密系统中，私钥是一直只会由所有者持有的，而公钥是可以分发或者交换的）


假设现在Alice和Bob要使用公钥加密系统通信，那他们可以这样进行：

1). Alice将公钥给Bob

2). Bob将公钥回给Alice

3). Alice使用Bob的公钥加密一串信息，发给Bob

4). Bob收到加密的信息，使用自己的私钥解密

5). Bob使用Alice的公钥加密一串信息，回给Alice

6). Alice收到加密的信息，使用自己的私钥解密

然后一直这样来往通信。

其中1)、2)过程我们称为密钥交换

## 3. 身份验证

我们清楚地知道一个事实，2. 密钥交换中Alice和Bob不会总是在专线上进行通信，在他们交换密钥的过程中，很可能出现坏人，我们来看一幅图。

![](https://img-blog.csdn.net/20151006211009406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


                                                                                        图示2

A是Alice，B是Bob，pri_A是Alice的私钥，pri_B是Bob的私钥，pub_A是Alice的公钥，pub_B是Bob的公钥。

M是坏人，pub_M是M的公钥。

虚线部分是密钥交换的过程，实线部分是传递消息的过程。

可以看到在密钥交换的过程中M可以对Alice冒充Bob，把pub_M给Alice，对Bob冒充Alice，把pub_M给Bob，然后把Alice的fuck消息拦截之后篡改成hello发给Bob。

这种攻击我们称为中间人攻击，这个中间人一般就是坏人。

为了防止这种中间人攻击我们需要引入一种叫证书的玩意，证书可以用来鉴别一个通信方的身份，即可以用来进行身份验证。

## 4. 证书

我们先看看证书是个什么玩意：证书是用来标识一个公钥的所有者身份信息的。

证书中含有一段签发机构的签名（详情请看X509），所以证书是无法篡改的，值得注意的是证书中是包含有公钥的。




在3.身份验证中，如果Alice和Bob拥有证书，那他们就可以交换证书，而不只是公钥，这样坏人就没法篡改消息了。

我们来看看这个过程：

1). 当Alice将cert_A给Bob时，被坏人M拦截，但M无计可施，他无法篡改这个证书，他只能原封不动地把cert_A转给Bob

2). 然后Bob把cert_B发给Alice，被M拦截，但M无计可施，他无法篡改这个证书，他只能原封不动地把cert_B转给Alice

3). Alice收到cert_B，经过一番分析，确定这确实Bob的证书，然后就欣然接受了。之后就用cert_B加密消息，发给Bob

4). 坏人M拦截到Alice用cert_B加密的消息，但他无计可施，他无法解开这个密文，于是他只得把密文原封不动转给Bob

5). 同理Bob回给Alice的消息，坏人M也无法篡改

## 5. 签名

在4.证书中我们可以发现一个问题，如果坏人M一不小心得到了Bob或者Alice的证书，那他就可以冒充一方了。那如何应对这种情况呢？（有没有感觉一环套一环）

聪明又机智的人类将签名用到了公钥加密通信上，我们来看看签名的概念：将一段信息使用私钥加密，即是签名。嗯。。是的，你没看错，签名就是私钥加密的密文

这种密文为何称为签名？因为能解开这段密文的公钥可以知道这段密文只能是由私钥所有者加密发出的。学名叫做不可抵赖(否认)性。

于是Alice或者Bob在发出消息前，对消息做md5/sha1之类的摘要算法，然后将摘要使用私钥加密就形成了这段消息的签名，最后将消息和签名一起发出去。接收者将签名解密之后，对消息做摘要算法，对比即可知消息未经篡改，且知道消息的确切发送者。




实际上，在公钥加密通信系统中，极少数时候会完全使用非对称加解密，更多的时候是使用公钥加密通信系统协商一个会话密钥之后进行对称加解密通信（SSL/TLS大致如斯），这又是另一个大话题了，各位观众朋友，下次再会。



