# 深度学习入门：手把手教你用TensorFlow搭建图像识别模块 - Machine Learning with Peppa - CSDN博客





2018年02月18日 22:03:31[刺客五六柒](https://me.csdn.net/qq_39521554)阅读数：10238
所属专栏：[机器学习与数据挖掘](https://blog.csdn.net/column/details/18961.html)









之前和大家简单介绍了什么是神经网络（见我的文章：[一句话告诉你什么是神经网络](http://blog.csdn.net/qq_39521554/article/details/79337929) )。那么今天再跟大家分享一些深度学习算法在图像识别上的应用。主要内容大概可以分为如下三个部分：

● 深度学习介绍；

● 神经网络工作原理；

● 用 TensorFlow 实现图像识别。

![](http://n.sinaimg.cn/translate/20170322/NPVs-fycnyhm2055322.jpg)

深度学习介绍

我们知道深度学习现在是已经是一个非常热门的技术，那大家第一次听到这个深度学习的时候呢？很有可能就是因为去年这个时候 AlphaGo 战胜李世石的这个事情。当时这个事情获得了全社会的广泛关注和热烈讨论。

![](http://n.sinaimg.cn/translate/20170322/qlpW-fycnyhm2055407.jpg)

但其实 AlphaGo 并不是第一个战胜人类的智能机器人，早在 20 年前就有过 IBM 深蓝机器人战胜人类国际象棋冠军的记录。那为什么 AlphaGo 可以引发这么大的关注呢？

我认为原因有两个方面：一是围棋的复杂度远超国际象棋；二是因为深度学习技术的发展，它推动了不仅是一个 AlphaGo 这样的应用程序，它其实也推动了各个方面的人工智能的应用。

![](http://n.sinaimg.cn/translate/20170322/thsN-fycnyhm2055435.jpg)

例如谷歌的无人车项目，就是一个距离我们更近的例子。大家都知道，现在无论在国内还是国外，堵车和停车的问题其实都是很严重的。但是如果有了无人车这样一个工具，就能大大提升车主的用户体验。

正是因为深度学习技术在 AlphaGo 和无人车等项目背后的巨大推动力，才使得这些项目能够发展到目前这样一个比较高的水平。

但其实，深度学习技术并不是一个新技术，它的起源可以追溯到几十年前，只是这两年才得到了一个比较快速的发展。如图中所示的搜索热度变化图也能看出，从 2012 年到 2016 年，深度学习这个词的受关注程度是处于一个指数级增长的状态。那为什么会在 2012 年这个时间点出现这样的一个增长呢？其实是因为 ImageNet 这样一个图像识别的比赛。

![](http://n.sinaimg.cn/translate/20170322/egq1-fycnyhm2055446.jpg)

ImageNet 是由李飞飞教授发起的一个著名的图像识别数据集，里面包括了各种各样的图片，然后参赛者需要将物体从图片中标记出来，做一个分类。这个比赛每年都会举办，而且每次的比赛细节都会有所不同。然后在 2012 年的时候，由于深度学习的作用，比赛结果产生了一个巨大突破。

![](http://n.sinaimg.cn/translate/20170322/IY73-fycnyhm2055455.jpg)

从下图可以看出，在 2012 年之前，采用了传统分类算法的时候，错误率大概是 26% 左右。而且我们可以看到这个错误率的变化趋势非常缓慢，也就是说要减低一点错误率，就必须付出巨大的努力。但是在引入深度学习算法之后，从 2011 到 2012 年，使得错误率从 26% 一下子降低到了 16%，并且从 2012 年开始的这三四年中，错误率还在以每年 4% 左右的一个速度在降低。到 2015 年，机器的识别率已经接近了人类的水平，即 5.1% 的错误率。2016 年，机器最新的识别正确率已经达到了 97% ，错误率达到了 3% 左右，已经比人类好得多。

![](http://n.sinaimg.cn/translate/20170322/-Flh-fycnyhm2055460.jpg)

如下图是才云科技集成 Google 训练好的一个模型，它可以通过分析用户上传的图片，例如一头牛，然后分析出这头牛是某个品种的概率是多少。还有现在大家在 Google 或者百度上传一张图片，然后搜索引擎就能比较精确地告诉你这个图片里的主体是什么动物，或者什么植物，甚至还能提供一段简单的文字描述等等。其实这些都是基于深度学习的算法来实现的。

![](http://n.sinaimg.cn/translate/20170322/6YHq-fycnyhm2055468.jpg)

除了图像识别之外，其实深度学习的早期应用是数字识别。例如图中所示的这个就是 1998 年的时候 Yann LeCun 教授做的一个手写体数字识别的项目（如下图所示），用的就是深度学习技术。

![](http://n.sinaimg.cn/translate/20170322/Z0_H-fycnyhm2055474.jpg)

此外还有 Google 在地图上的应用，能够通过图像识别自动定位门牌号和地理位置等信息。

![](http://n.sinaimg.cn/translate/20170322/vAaX-fycnyhm2055483.jpg)

其实神经网络，也就是深度学习技术用在图像识别的应用还有很多，包括人脸识别、安防领域、火警、群众事件，还有现在的美颜等等。并且，受到神经网络思想的启发，目前包括语音识别、机器翻译、自然语言处理和大数据分析、预测等行业都得到一个比较大的发展。

神经网络原理

下面简单介绍一下神经网络的情况。

这里我不会去推导前向传播或者反向传播的具体过程。前向传播的过程比较简单，这里会做一个大致的介绍。而反向传播对数学的要求比较高，并且通过 TensorFlow 可以非常容易地去实现，因此我只会简单介绍一下基本原理，大家自己有兴趣的话可以自己去深挖。这个部分我主要还是做一些流程上的介绍，让大家知道一个完整的机器学习或者说图像识别问题，我该怎样一步一步地去解决它，包括我需要做哪些事，什么事情可以通过什么工具来帮助我实现。

首先我们来介绍一下什么是深度学习。大家可能经常会听到深度学习和神经网络这些词，但它们之间究竟是一个什么关系呢？其实，深度学习在维基百科上的定义是：多层的非线性变换的一个算法合集。那怎样实现这个多层非线性变换呢？最好最方便的一种方法就是神经网络。所以说基本上当前来讲的深度学习，就等于是深层神经网络的一个代名词。

![](http://n.sinaimg.cn/translate/20170322/yxh6-fycnyhm2055491.jpg)

神经网络，大家从这个词就能看出它多多少少跟人脑的神经网络有些关联。如图所示，左上角就是一个神经元的模型，他包括很多不同的输入，以及一个轴壳来处理这些输入，最终得到一个输出。这个对应到人工神经网络也是一样的，它会有多个输入，然后经过一些变换得到输出。但人脑的变换函数具体是怎样的，现在还弄不清楚，我们只能通过这样一组加权和，加上一个激活函数来模拟人脑。

大家都知道，人脑是通过这种神经网络的网络状结构处理信息的，因此在人工神经网络结构中也是通过这样的一种多层结构来实现神经元的连接。如上图的右下角所示，每一个圆圈都代表一个神经元，多个输入，一个输出，上一层的输出作为下一层的输入。

下面我简单介绍一下怎么用这个网络结构来处理问题。比如数字识别问题，如图所示的数字图像在计算机里就是一个像素矩阵，然后每个矩阵元素里面都是各种各样的一个数字，我们把这些数字作为这个神经网络的输入层提供进来，然后通过不同结构的神经网络处理，从输入层到隐藏层再到输出层，就可以得到处理结果。

![](http://n.sinaimg.cn/translate/20170322/u8ym-fycnyhm2055498.jpg)

比如图中的这个手写数字问题，其实就是要识别这个数字到底和 0 到 9 中的哪个数字更像一点。我们可以安排输出层有 10 个结点，分别代表 0 到 9 的 10 个数字。那么如果这个图像是 1 的话，我们就希望代表 1 的这个结点输出的结果是 1 ，其他的结点是 0 。这样的话假设我们输入一张图像，然后发现代表数字 7 的结点输出为 1，其他结点为 0 ，那么我们就等于识别出了这个图像的内容是 7，也就完成了一个数字识别的任务。

这只是一个最简单的例子，还有更多更复杂的神经网络这里我们就不做具体介绍了，感兴趣的朋友可以关注才云科技开源的一个代码库，里面有各种丰富的样例代码。（雷锋网(公众号：雷锋网)注：开源地址见下文链接）

下面简单介绍一下深度学习的两个大的分类：监督学习和非监督学习。

![](http://n.sinaimg.cn/translate/20170322/EbTX-fycnyhm2055502.jpg)

我通常会把机器学习和人类学习来做一个对比，其实有很多地方都是比较类似的。例如我们小时候去上课，然后考试。其实机器学习也是一个类似的过程，它通过海量的数据，然后学习（总结）出一些对应的规律，并将规律应用在一个测试环境上，就能得到一个诸如正确率这样的评测指标，最终通过评测指标来评测一个机器学习算法的好坏。

那么在监督学习的场景中，通过海量的标记过的数据，就相当于人类在学习中通过大量的做题，然后每做一个题都知道对错，没有错的话就加强这个过程，有错的话就反向改进，这就是监督学习。

而非监督式就不需要人为的标签数据，它是监督式和强化学习等策略之外的一个选择。典型的非监督学习有聚类等，它是直接从数据中寻找相似性，即规律。

现在其实机器学习除了监督式和非监督式之外，还有增强学习。它是和监督式及非监督式都有些不同的一种方式。然后，但其实在工业界用得最多的，其实还是监督式学习的方式，非监督式和增强学习现在在工业界的使用还是相对比较少。那其实我们今天也会主要以监督式的这种学习方式作为一个样例，来告诉大家怎样去完成一个监督式的学习方法来完成图像识别工作。

在具体介绍整个模型之前，这里我先跟大家详细介绍一下神经网络的工作原理。

刚刚讲到，我们要去做一个图像分类模块，就相当于是把这个图像的原始的像素矩阵传入输入层，然后经过一层一层的推导，得到输出层。那其实神经网络里面一个最关键的部分，就是说我怎样通过一层一层的网络结构来得到从输入层到输出层的结果。最简单的来讲，我们先要知道一个单一的神经元的工作方式。

![](http://n.sinaimg.cn/translate/20170322/0pU_-fycnyhm2055506.jpg)

如图所示，我们其实可以将每个神经元视为这样的一个多项式组合，w表示权重，b表示偏移量。那么训练时一个最重要的工作就是找到最合适的权重，使得我们的实际输出与预想输出一致。那么输入的一个加权平均，加一个偏移，最后再通过一个激活函数，最后就能得到输出。

![](http://n.sinaimg.cn/translate/20170322/MJOa-fycnyhm2055512.jpg)

这里我们以一个判断零件是否合格的例子来讲解，注意这里省略了偏移量和激活函数。比如说我这里的每一个零件它都会有长度、质量等参数，就相当于收集了很多关于这个零件的数据，其中有一些我们知道是已经合格了的，也就相当于有了一个训练数据。将这些训练数据输入模型，通过结果对比不断调节隐藏层的权重参数，最终达到一定的正确率之后，也就是完成了模型训练。接着我们可以测量任意一个零件的参数，把测量数据输入神经网络，就能判断这个零件是否合格。

这样的一个过程其实就是正向传播的一个过程。反向传播相当于是我知道一个零件的长度和质量，也知道它是否合格的时候，再去根据这个目标做一个反向的回馈。

![](http://n.sinaimg.cn/translate/20170322/AT2Z-fycnyhm2055520.jpg)

这里我列出了一些简单的激活函数，注意这里所有的激活函数都是非线性的函数。如果一个模型没有激活函数的话，就相当于是所有线性过程的叠加，不论模型有多少层，叠加出来还是一个线性过程，也就是模型没有涉及非线性的因素，也就不会有实际的应用。而激活函数就是一个提供非线性过程的因子，有了激活函数我们才能完成一个非线性变化的过程。

更详细的内容大家可以参考《TensorFlow：实战Google深度学习框架》这本书。

![](http://n.sinaimg.cn/translate/20170322/YCsd-fycnyhm2055529.jpg)

这里我们介绍两种常用的激活函数：Softmax 和 Sigmoid。在多分类的问题中，经过层层的推导，其实每个节点的输出都是不一定的。那么如果我们想得到一个概率分布，就需要用到 Softmax 这样一个层。它相当于对每个输出节点的大小作为置信度做一个归一化的操作，然后使得每一个最终输出节点的值都在 0 到 1 之间，这样就等于输出了一个概率分布。我们可以大概理解为不同的输出类别的一个概率分布。在多分类问题中，一般都会用 Softmax 作为最后的处理层，得到一个概率分布情况。类似的，在二分类中我们通常使用 Sigmoid 函数。

这样，从输入层到隐藏层到输出层再到激活函数，我们等于介绍了全连接神经网络的一个基本结构。刚刚提到，监督学习就是我们得到一个结果之后，能够判断它的好坏。那么怎么判断和评测呢，就需要损失函数。

![](http://n.sinaimg.cn/translate/20170322/PI5g-fycnyhm2055535.jpg)

通过损失函数，我们可以计算出实际输出和真实标签的差别，然后进行优化，缩小这种差别。两个经典的损失函数一个是交叉熵，另一个是 MSE 最小平方差。他们详细的用法，包括自定义函数怎么样去定义等内容，大家可以参考《TensorFlow：实战Google深度学习框架》这本书。

定义完损失函数，我们再来讲讲优化。

首先，优化的是什么？我们刚刚提到，神经网络里的每一个神经元都有参数，我们要优化就是这些参数。那怎样来优化呢？就是通过我们定义的损失函数，即推导得出的结果要跟真实结果越接近越好。这相当于变成了一个最小化问题。最小化问题确实有比较成熟的数学解法。但对于神经网络这么复杂的一个结构，它其实并没有特别好的数学公式能够直接求解。

虽然说，优化神经网络的算法有不少，但主体的思想其实都是基于梯度下降，或者随机梯度下降。那么，梯度下降是什么？用简单的话来讲，它就相当于是把不同参数的取值和损失函数的大小，看成空间中的一个曲面。最简单的情况下，可看成二维空间上的一条曲线。任意一个参数的取值，就对应了损失函数的取值。这样子的话，我们就可以通过计算它的梯度来修改参数，使得损失函数会往更小的这样一个方向去发展。这就是优化神经网络的最基本的思想。包括反向传播算法，其实也就是怎么更快地去计算出每一个参数的梯度，使得计算的时间复杂度减少。优化神经网络的核心思想其实还是梯度下降。

![](http://n.sinaimg.cn/translate/20170322/KPzX-fycnyhm2055541.jpg)

梯度下降是在所有的数据集上去算它的梯度。但神经网络的数据量一般会比较大，一般很难把所有的数据全都用上。这样的时候，我们一般会采用 minibatch。一次计算部分的梯度来减少计算量。本来我们就知道，梯度下降其实就已经无法达到全局最优值。那使用随机梯度下降呢，其实就更加难以保证达到最小值，有全部训练数据集才能有最小值。但我们可以通过调整学习率，使它更加逼近极小值。

这些就是我想给大家讲的，神经网络的大致工作原理。其实这个工作原理讲得比较粗浅，也比较 high-level。但大部分人其实对主要的一些部分了解就 OK 了。

用 TensorFlow 实现图像识别

接下来，我会把这些原理对应到具体的代码里面，然后让大家知道怎么样通过 TensorFlow 来实现图像识别。同时讲解怎么用 TensorFlow 来实现大致的机器学习分类算法。

虽然上面有很多的细节没有覆盖，但其实 TensorFlow 也把这样的一些细节给屏蔽掉了。我的意思是，其实大家只需要理解一些比较 high-level 的东西，就完全能够通过 TensorFlow 来实现神经网络的训练。

我们先谈什么是 TensorFlow，为什么要选择 TensorFlow。

TensorFlow 是谷歌在 2015 年底开源的一个深度学习框架。虽然说是深度学习，官方来讲，其实 Google 希望把它做成一个计算工具。但这个计算工具的主要任务，就是用来实现深度学习算法。所以说，其他的功能我们暂时也就抛开不谈。就深度学习的基本功能来讲，TensorFlow 已经得到广泛的应用。Google自不必提，现在所有 Google 内部的深度学习系统全都是基于TensorFlow。DeepMind 卖了之后，推出的东西也都会基于TensorFlow。

![](http://n.sinaimg.cn/translate/20170322/kcio-fycnyhm2055547.jpg)

Google 之外，国内包括华为、京东、小米，其实都在用 TensorFlow。国外像 Twitter、Uber、Snapchat 也在用。使用它的公司其实非常多。现在学术界也好，工业界也好，都偏向使用它。为什么 TensorFlow 会这么受欢迎？除了有大公司的背书，社区的贡献度也是非常重要的一个参考指标。

![](http://n.sinaimg.cn/translate/20170322/Bs6r-fycnyhm2055550.jpg)

![](http://n.sinaimg.cn/translate/20170322/ruba-fycnyhm2055557.jpg)

在 GitHub，无论是从 star 的数量，fork 的数量，还是从 issues 和 pull request， TensorFlow 都遥遥领先于其他同类深度学习开源框架。对于深度学习来讲，它还是一门正在发展中的技术。对于工具来讲，我们认为，它是否能够跟上这门技术的发展，其实是非常重要的一个考核标准。就是说，因为技术的发展是非常快的，如果工具的发展落后于技术的发展，它就会有一个被淘汰的风险。所以说，当它的社区活跃度非常高的时候，这个风险度就会相应的降低。因此我们比较推荐使用 TensorFlow。对于新手来讲，我们也比较推荐。

![](http://n.sinaimg.cn/translate/20170322/BcTV-fycnyhm2055560.jpg)

这里给出了一个简单的 TensorFlow 的 Hello World 的程序，实现了一个简单的向量加法的操作。首先 import 了 TensorFlow ，然后定义了 a、b 两个向量，包括 name 属性，接着把它们加起来。这里 TensorFlow 采用了这样的一个惰性计算模型，输出的并不是加法的结果，而是结果的一个引用。另外，要运行整个 result 运算，就必须定义一个 session ，session 会掌握所有 TensorFlow 的运算资源，然后通过 session 运行相关操作。

这里只是简单介绍了一个 TensorFlow 的简单用法，由于时间有限，也无法深入地去详细介绍。我们关注的是如何用 TensorFlow 实现一个神经网络的全连接，也就是加权和，加上激活函数的模型。

![](http://n.sinaimg.cn/translate/20170322/WMRU-fycnyhm2055565.jpg)


加权和可以通过矩阵乘法的方式实现。如上图代码所示，这里通过 placeholder 的方法定义了一个 input ，其中类型是必须的，其他的诸如 shape 等参数则可以等使用的时候再赋值。之后定义了权重 w 和偏移量 b，这里是通过 Variable 方法定义的，这样等最后优化的时候，TensorFlow 会针对这些 Variable 展开优化。最后通过乘法和加法操作，也就是通过 output = tf.nn.relu(tf.matmul(x, w) + b) 这一行代码就实现了神经网络的基本结构。

这里是通过基础的 TensorFlow API 实现的，如果通过 Keras 等更高层的封装来实现会更加简单。这里我们是从基础的 API 入手来进行讲解，如果大家对高层封装感兴趣，可以自己学习。需要指出的是，其实高层封装和基础 API 的主要区别是实现上的区别，他们整体上的过程是基本一样的。

下面我们来看一下如何用 TensorFlow 实现一个具体的图像识别模块，即从 MNIST 数据集中识别手写数字。（完整代码见下文链接）

![](http://n.sinaimg.cn/translate/20170322/1kmT-fycnyhm2055569.jpg)

可以看到，TensorFlow 通过 read_data_sets 方法对引用数据进行了一个非常好的封装，后续可以通过非常简单的方式读取这些划分好的数据集，例如通过 train、validation、test 等关键词就可以读取训练和测试数据集等。

如下图所示，然后是通过 next_batch 来获取一小批的训练数据。我们刚刚提到，在利用梯度下降算法时需要在所有的训练数据上计算梯度，但是计算量太大了，因此这里通过 next_batch 方法，相当于我们在所有的训练数据集中筛选一部分，随机选取一部分训练数据集，提供到神经网络的输入层，然后通过反向迭代方法去优化这个神经网络。

![](http://n.sinaimg.cn/translate/20170322/l71T-fycnyhm2055577.jpg)

这里 xx 设置等于 100，也就是我们得到了 xs 和 ys 两个矩阵，xs 代表输入数组，相当于把一个 28×28 的手写图像展开成一个长度为 748 的一维数组。ys 相当于我们的结果，也就是 0-9 这 10 种可能值。

![](http://n.sinaimg.cn/translate/20170322/JufW-fycnyhm2055584.jpg)

如上图，完了之后是一个前向传播的一个大致过程的程序截图。这个过程就相当于是定义一层一层的神经网络结构，这里 inference 函数中的 input_tensor 相当于输入矩阵，后面的 reqularizer 就相当于一个正则化的东西。我们可以看到，当输入来了之后，程序开始进行一层一层的推导，定义一层一层的权重和偏移量，算出每一层的结果，传入下一层，进入下一层的计算。

其实通过这个前项传播的定义我们可以看到，无论是全连接层还是卷积神经网络，甚至是循环神经网络，它的大致流程都是一样的，给定输入，然后通过一层一层的传递就可以得到最后的输出。

![](http://n.sinaimg.cn/translate/20170322/jNUC-fycnyhm2055589.jpg)

![](http://n.sinaimg.cn/translate/20170322/KqwQ-fycnyhm2055611.jpg)

如上图，下面我们看一下主程序。其实主程序就是调用了 train 的过程，这个 train 的过程其实也是比较简单的。第一部分是定义输入，也就是怎样来提供这个训练数据的接口，也就是通过 placeholder 的方式导入，输入这里是 x ，输出是 y_ 。然后通过调用 inference 函数来进行一个前向传播的计算。然后定义了滑动平均和损失函数。

这里的过程其实是就相当于是：我通过输入一个训练数据集，然后得到在当前数据集下的推导结果，然后再通过这个推导结果和正确答案对比，就知道跟正确答案的差别在哪。下一步可以看到我们定义了 loss ，它相当于评估当前模型好坏的一个指标。这里其实就相当于是评价 cross_entropy 加上正则化，这里正则化是为了避免过耦合的。

完了之后，下一行是通过 GradientDescentOptimizer 函数优化。TensorFlow 提供了大概 5-7 中不同的优化函数可供选择，它们针对不同的应用场景，各具特点，大家可以灵活选择。这里我认为，对于那些不搞学术研究的同学，其实没有必要去从数学的角度推导每一个优化函数具体是怎么优化的，从应用层的角度来看，大部分用户只需要提供学习率和目标函数，并且了解这些优化函数的优劣就可以了，这个相对来说还是比较方便。

在把所有的这些计算方式都定义好了之后，下面就是生成 TensorFlow 的计算图，以及生成 session。定义好 session 之后，下面训练的过程就比较简单了，其实就是写了一个循环，每次选取一小部分训练数据，然后去做训练，隔一段时间再打印一下训练结果，整个过程就完成了。

所以说整个用 Tensorflow 来实现一个神经网络的过程，相对还是比较简单的。需要注意的是，这里我介绍的只是原生态的 TensorFlow，如果大家要去使用 TFLearn，或者 Keras 这些高级封装去实现 MNIST 问题的话，可能会更加简单，大概只需要 2-3 行代码就可以解决了。

![](http://n.sinaimg.cn/translate/20170322/9btU-fycnyhm2055623.jpg)

这里我们基本上把通过原生态的 Tensorflow 生成神经网络的过程为大家介绍了一下。其实后面还有个 evaluate 评估的部分（代码如上图所示），因为时间关系我就不对着代码详细讲了，感兴趣的同学可以自己下去研究（源码见下文链接）。

下面我再跟大家再介绍一下循环卷积神经网络。

![](http://n.sinaimg.cn/translate/20170322/-wW9-fycnyhm2055631.jpg)

刚刚大家看到的这个结构是一个全链接的神经网络，在图像处理的过程中，使用全连接神经网络最大的一个问题就是它的参数太多了，这个问题可能会导致模型最终训练不好。

例如，经常发生的，当你的训练数据不足的时候，参数又太多，你就可能训练不出来。一个非常简单的例子，大家可以想象 N 元的一个方程组，然后我们假设只有 N 个数据，并且这些数据是完全可分的，也就是我们是可以完全求解。但完全求解可能会导致过拟合，因为训练数据在真实环境下都是有噪音的，也就是没有办法做到完全避免随机因素的影响。在这种情况下如果你过于贴合训练数据，那么就有可能没有办法去收敛到未知的数据。

所以这就是参数过多可能引发的问题，即过拟合和训练不出来。那怎样去解决这两个问题呢？卷积神经网络就是一个很好的方法。

![](http://n.sinaimg.cn/translate/20170322/kYES-fycnyhm2055646.jpg)

卷积神经网络就相当于是采用一个内核，即一个规模较小的矩阵，去处理一个比较小的区域，然后去通过移动这个小矩阵，去处理不同的这个块。这种方式一个直观的一个意义就是：一般的图像上相邻区域的内容是相似的。然后通过这样的一个潜在的东西，就可以去把一个浅层的表达变成一个更深层的表达。也就是相当于自动从图像中去提取特征。

![](http://n.sinaimg.cn/translate/20170322/Rglx-fycnyhm2055662.jpg)

例如上图所示，第一层可能可以从图像中提取一些线条和斑点，第二层提取一些更复杂的性状。第三层和第四层，层数越多，提取的特征就会越复杂。然后通过最后提取出来的这样一些特征，我们再去做一个全连接的分类，最后这个分类的效果也就会更好。

![](http://n.sinaimg.cn/translate/20170322/GiHJ-fycnyhm2055673.jpg)

然后这里给出了一个简单的 LeNet5 的模型，我们可以看到他的大致结构就是从输入层，经过不断地卷积池化，再经过 1 到 3 层不等的全连接层，最后得到输出层。其实现在很多的卷积神经网络基本上也都保留了这样的一种结构。

除了这种模型之外，另一种比较特殊的模型是 Google Inception 模型，这里因为时间关系我也不去做过多的介绍了。

然后我在这里给出了一个简单的用 TensorFlow 的程序来实现卷积层。通过代码其实大家也可以看到，在这个框架里面，无论是全连接的神经网络也好，还是卷积神经网络也好，甚至循环神经网络也好。它们的训练过程，以及前面的准备过程其实基本上都是差不多的，你基本上只要去修改，怎么样去从输入得到输出就可以了。

![](http://n.sinaimg.cn/translate/20170322/AAqK-fycnyhm2055681.jpg)

![](http://n.sinaimg.cn/translate/20170322/d_aO-fycnyhm2055701.jpg)

从代码也可以看到，开始是定义这个卷积层中的权重和偏移量，完了之后 TensorFlow 会对这个卷积层有一个封装，然后通过 conv2d 函数得到一个 2D 的卷积层，然后再把偏移量、激活函数加上去。大家可以看到整个的过程还是比较简单的，同样的，如果用 Keras 等更高级的封装来实现的化会更加简单。

最后我要推荐一下《TensorFlow：实战Google深度学习框架》这本书，今天讲的内容，包括一些略去的内容，基本上全部在这本书里都有非常详细的介绍。

另外，前面提到的代码地址如下：

https://github.com/caicloud/tensorflow-tutorial

代码库里包含了书中所有的样例代码，此外还包括了才云科技提供的 TensorFlow as a Service (TaaS) 深度学习平台的一些教程和代码，包括后面我们做的一些图像分类和图像识别的样例代码，后面也都会陆陆续续添加进去。大家有兴趣的化可以关注一下这个代码库。



