# 有趣的算法（八）：3分钟看懂选择排序（C语言实现） - Machine Learning with Peppa - CSDN博客





2018年03月18日 18:03:42[刺客五六柒](https://me.csdn.net/qq_39521554)阅读数：87
所属专栏：[C语言入门](https://blog.csdn.net/column/details/18792.html)









之前两篇文章我们了解[插入排序](http://blog.csdn.net/qq_39521554/article/details/79593071)和它的衍生方法[shell排序](http://blog.csdn.net/qq_39521554/article/details/79594178)，那么今天我们来看看基于另一种算法思想的排序方法——选择排序。






# 一、算法思想



和直接插入排序相同，我们采用原地排序（即只用一个数组进行排序），分为有序区间和无序区间。具体思想则是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。

那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。

举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

另一种基于选择思想的排序方法叫做堆排序，它利用了完全二叉树的性质，是一种高效的排序方法。具体思想可以参看一位大神 的一篇文章：[浅谈堆排序](https://www.jianshu.com/p/938789fde325)




# 二、算法步骤





n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：
①初始状态：无序区为R[1..n]，有序区为空。

②第1趟排序
在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。

……
③第i趟排序
第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。



# 三、算法分析

一般来说选择比冒泡效率高，因为只要交换一次，但是冒泡也可以只记录坐标然后做一次性变换，只是牺牲空间复杂度。但是冒泡有个很大的优点就是它可以检测整个数组是否已经有序，当某次遍历没有发生任何交换的时候你就可以提前终止了。也算是个小优化吧。
|排序方法|时间复杂度|空间复杂度|稳定性|复杂性| | |
|----|----|----|----|----|----|----|
|平均情况|最坏情况|最好情况| | | | |
|选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定|简单|


另外对于选择排序和冒泡排序的比较，我觉得可以用逆序数来理解，假设我们要从小到大排序，一个数组中取两个元素如果前面比后面大，则为一个逆序，容易看出排序的本质就是消除逆序数，可以证明对于随机数组，逆序数是O(N^2)的，而如果采用“交换相邻元素”的办法来消除逆序，每次正好只消除一个，因此必须执行O(N^2)的交换次数，这就是冒泡、插入等算法只能到平方级别的原因，反过来，基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，使得一次交换能消除一个以上的逆序，希尔、快排、堆排等等算法都是交换比较远的元素，只不过规则各不同罢了。

因此，选择排序总是会比冒泡排序效率高，因为选择排序每轮至多只交换1轮逆序，但从算法角度考虑，时间复杂度并没有什么改进，因为都是O(n^2)算法。





# 四、算法实现

代码在VC++环境下编译通过

```cpp
/**选择排序
test version 1::
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef N
#define N 10
#endif // N


inline int swap(int *s1, int *s2)   //交换函数
{
    int tmp;

    tmp = *s1;
    *s1 = *s2;
    *s2 = tmp;
}

inline int Select_Sort(int *arr, int len)
{

    register int i, j;

    for(i = 0; i != len ; i++)
    {

        for(j = i + 1;j != len; j++) //其实这里用while更好
        {
            if(arr[i] > arr[j])
            {
                swap(&arr[i], &arr[j]);
            }
            else
                continue;
    }
    }
}

int main( int argc, int *argv[])
{
    //test

    printf("please enter 10 numbers: \n");
    int i, arr[N];

    for(i = 0;i < N;i++)
    {

        scanf("%d", &arr[i]);

    }

    int len = sizeof(arr) / sizeof(arr[0]);

    Select_Sort(arr, len);

    printf("\n");
    printf("the ordered array is: \n");

    for(i = 0;i < N;i++)
    {
        printf("%4d", arr[i]);

    }

    return 0;
}
```



