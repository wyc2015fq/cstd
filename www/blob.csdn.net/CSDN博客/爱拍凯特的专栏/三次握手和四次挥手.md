# 三次握手和四次挥手 - 爱拍凯特的专栏 - CSDN博客
2016年06月07日 08:54:00[爱拍凯特](https://me.csdn.net/apacat)阅读数：259
三次握手和四次挥手
1、为什么要三次握手？
因为信道是不可靠的，而TCP协议是一个可靠的传输协议，要在不可靠的信道上实现可靠的传输，那么就需要一钟同步机制，而进行三次握手是理论上所需要的最少的握手次数。
因为如果只进行两次握手的化，会出现以下的一个问题：如果第一个SYN握手包发送过去之后在网络中滞留，没有被送到服务端，然后过了一段时间之后客户端和服务端通信结束，并且断开了
socket链接，此时如果这个滞留的包又被送到服务端，服务端会认为客户端又要建立链接，所以就会给客户端发送 SYN + ACK也就是第二个握手包，如果两次握手就能建立链接的化，那么这个
时候服务端就建立一条socket链接，并分配资源、但是客户端并不需要建立链接，所以这个时候不会给服务端发回响应，所以服务端就收不到响应，以为一直没有数据发送，这样就白白的维持了一个链接，浪费了资源。
2、三次握手的过程？
首先，客户端调用connect()函数，向服务端发送一个SYN包，然后客户端成为SYN_SEND状态，服务端接受到这个SYN包之后，服务端变成SYN_RCVD状态，服务端向客户端发送SYN+ACK数据包，服务端状态变为ESTABLISHED
客户端接受到SYN+ACK 之后，向服务端发送一个ACK 客户端也变成 ESTABLISHED 状态。
3、为什么要进行四次挥手？
四次挥手目的是确保数据能够传输完成。
那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。
4、四次握手的过程？
首先客户端调用close()函数向服务端发送一个FIN数据包，客户端状态变成FIN_WAIT1，服务端收到之后会回复一个FIN+ACK，然后服务端知道客户端没有数据要发送了，关闭从客户端到服务端的链接。此时服务端处于CLOSE_WAIT状态，客户端接受到服务端发送的FIN+ACK之后状态转变为FIN_WAIT2，当服务端调用close()函数向客户端发送一个FIN数据包之后，服务端状态转变为LAST_ACK，这个时候等待对这个最后的FIN的ACK分组，客户端接受到这个FIN之后，状态转变为TIME_WAIT，然后想服务端发送一个ACK，服务端接受到这个ACK之后，转变为CLOSED状态，服务端到客户端的链接也关闭了。
5、三次挥手中数据包的标志位和顺序号变化
客户端-->服务端:  SYN=1,seq=随机值N（链接请求的时候 SYN=1）
服务端-->客户端:  SYN=1,ACK=1,ack=N+1,seq=随机值M（链接响应的时候 SYN=1，ACK=1）
客户端-->服务端:  ACK=1,ack=M+1
6、四次挥手中数据包的标志位和顺序号变化
客户端-->服务端:FIN=1,seq=x;
服务端-->客户端:ACK=1,seq=y,ack=x+1;
服务端-->客户端:FIN=1,ACK=1.seq=w,ack=x+1;
客户端-->服务端:ACK=1,seq = x+1,ack=w+1;
