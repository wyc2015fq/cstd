# 死锁、活锁、优先级翻转 - 爱拍凯特的专栏 - CSDN博客
2016年03月14日 16:36:13[爱拍凯特](https://me.csdn.net/apacat)阅读数：310
个人分类：[操作系统](https://blog.csdn.net/apacat/article/category/6224432)
这几个概念中：
**死锁**比较常见是多个进程在争夺系统资源的过程中出现的互相等待，且在无外力作用的情况下，导致无法继续推进运行的状况。而这些不能的到系统资源的进程则称为是死锁进程，并最终被**饿死**。
导致死锁的因素有以下几个：
1、互斥条件
    互斥是在访问临界资源的时候不能多个进程同时访问，只能允许其中的一个进程访问，这个进程访问完成之后才能有其他的进程继续访问，这种一把使用互斥锁来实现。
2、请求和保持
    这种情况是指当一个进程已经请求到了一些系统资源，在不放弃对这些系统资源的占用的情况下，又向系统申请了其他的资源，而他所占有的资源因为不能被其他进程使用，同时他所请求的资源又得不到满足的情况，就会出现死锁。
3、循环等待
   这种情况的死锁发生的时候一般会形成一个进程-资源的环形链，如一个进程的集合中包含｛P1、P2、P3...｝而同时，P1、请求P2的资源，P2请求P3的资源....Pn请求P1的资源，从而导致任何一个进程的资源请求都得不到满足，从而发生了死锁。
4、不剥夺条件
   这种情况是指进程在获取到一个资源之后，在使用完这个资源之前是不释放对这个资源的占有的，只有使用完成之后才会由进程来释放掉。
解决的办法就是想办法不能够形成除了互斥之外的三个条件。
**活锁**是也是在多个进程在请求资源的过程中形成的一种僵化状态，这种状态是由于这多个进程之间互相谦让，都让其他的进程来先执行，最终导致大家都没法执行的情况。
而活锁是有一定的概率破除的，简单的解决方式就是采用先来先服务的策略，而死锁是在没有外力的情况下永远无法破除。
**优先级反转**这个问题 最早发生在“挑战者“号火星探测器在执行任务的过程中的。
优先级反转是指的是有三个优先级的进程A、B、C，它们的优先级分别是高、中、低。而当前高优先级的进程A需要访问某个系统资源的时候被低优先级的进程C占有，从而导致了高优先级的进程A发生阻塞，而此时中优先级的进程B抢占了处理器的使用权，从而获得了执行，导致了较低的优先级的进程先于较高的优先级的进程执行，从而发生了系统的错误，甚至崩溃，这种问题一般出现在可抢占式的实时操作系统上。
高优先级的任务A不能够执行的原因是在于所访问的资源被低优先级的任务C占有，从而导致了A的阻塞，如果让C尽快执行完成就可以避免这种事情的发生。
而解决的办法有两种方法：
1、优先级继承
当高优先级的进程因为访问资源失败而导致阻塞的时候，可以将低优先级的进程的优先级设置为这个阻塞的高优先级的进程的优先级，这样就不会导致中优先级的进程来抢占处理器。
2、优先级天花板
对所有可能访问该资源的任务的优先级设置为最高优先级。
两者的区别：
优先级继承：只有一个任务访问资源时一切照旧，没有区别，只有当高优先级任务因为资源被低优先级占有而被阻塞时,才会提高占有资源任务的优先级；而优先级天花板,不论是否发生阻塞,都提升,即谁先拿到资源，就将这个任务提升到该资源的天花板优先级。
