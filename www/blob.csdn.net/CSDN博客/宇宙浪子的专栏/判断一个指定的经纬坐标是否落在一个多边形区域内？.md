# 判断一个指定的经纬坐标是否落在一个多边形区域内？ - 宇宙浪子的专栏 - CSDN博客
2016年06月14日 11:34:28[_宇宙浪子_](https://me.csdn.net/bluehawksky)阅读数：6395
Python：
```python
def IsPtInPoly(aLon, aLat, pointList):
    '''
    :param aLon: double 经度
    :param aLat: double 纬度
    :param pointList: list [(lon, lat)...] 多边形点的顺序需根据顺时针或逆时针，不能乱
    '''
    
    iSum = 0
    iCount = len(pointList)
    
    if(iCount < 3):
        return False
    
    
    for i in range(iCount):
        
        pLon1 = pointList[i][0]
        pLat1 = pointList[i][1]
        
        if(i == iCount - 1):
            
            pLon2 = pointList[0][0]
            pLat2 = pointList[0][1]
        else:
            pLon2 = pointList[i + 1][0]
            pLat2 = pointList[i + 1][1]
        
        if ((aLat >= pLat1) and (aLat < pLat2)) or ((aLat>=pLat2) and (aLat < pLat1)):
            
            if (abs(pLat1 - pLat2) > 0):
                
                pLon = pLon1 - ((pLon1 - pLon2) * (pLat1 - aLat)) / (pLat1 - pLat2);
                
                if(pLon < aLon):
                    iSum += 1
    if(iSum % 2 != 0):
        return True
    else:
        return False
```
Delphi
```
Type
  TMyPoint = packed record
    X : double;
    Y : double;
  end;
{*------------------------------------------------------------------------------
  判断指定的经纬度坐标点是否落在指定的多边形区域内
  @param ALon   指定点的经度
  @param ALat   指定点的纬度
  @param APoints   指定多边形区域各个节点坐标
  @return True 落在范围内 False 不在范围内
------------------------------------------------------------------------------*}
function IsPtInPoly(ALon, ALat: double; APoints: array of TMyPoint): Boolean;
var
  iSum, iCount, iIndex: Integer;
  dLon1, dLon2, dLat1, dLat2, dLon: double;
begin
  Result := False;
  if (Length(APoints) < 3) then
  begin
    Result := False;
    Exit;
  end;
  iSum := 0;
  iCount := Length(APoints);
  for iIndex :=0 to iCount - 1 do
  begin
    if (iIndex = iCount - 1) then
    begin
      dLon1 := APoints[iIndex].X;
      dLat1 := APoints[iIndex].Y;
      dLon2 := APoints[0].X;
      dLat2 := APoints[0].Y;
    end
    else
    begin
      dLon1 := APoints[iIndex].X;
      dLat1 := APoints[iIndex].Y;
      dLon2 := APoints[iIndex + 1].X;
      dLat2 := APoints[iIndex + 1].Y;
    end;
    if ((ALat >= dLat1) and (ALat < dLat2)) or ((ALat>=dLat2) and (ALat < dLat1)) then
    begin
      if (abs(dLat1 - dLat2) > 0) then
      begin
        dLon := dLon1 - ((dLon1 -dLon2) * (dLat1 -ALat)) / (dLat1 - dLat2);
        if (dLon < ALon) then
          Inc(iSum);
      end;
    end;
  end;
  if (iSum mod 2 <> 0) then
    Result := True;
end;
```

