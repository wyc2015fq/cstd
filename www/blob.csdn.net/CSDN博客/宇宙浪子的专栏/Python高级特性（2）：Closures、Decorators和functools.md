# Python高级特性（2）：Closures、Decorators和functools - 宇宙浪子的专栏 - CSDN博客
2014年09月05日 15:27:03[_宇宙浪子_](https://me.csdn.net/bluehawksky)阅读数：524标签：[python](https://so.csdn.net/so/search/s.do?q=python&t=blog)
个人分类：[Python](https://blog.csdn.net/bluehawksky/article/category/2542577)
本文由 [伯乐在线](http://blog.jobbole.com/) - [熊崽Kevin](http://blog.jobbole.com/author/dysj4099/) 翻译自 [sahandsaba](http://sahandsaba.com/python-decorators.html)。欢迎加入[技术翻译小组](http://www.jobbole.com/groups/6/)。转载请参见文章末尾处的要求。
《[Python高级特性（1）：Iterators、Generators和itertools](http://blog.jobbole.com/66097/)》
## 装饰器(Decorators)
装饰器是这样一种设计模式：如果一个类希望添加其他类的一些功能，而不希望通过继承或是直接修改源代码实现，那么可以使用装饰器模式。简单来说Python中的装饰器就是指某些函数或其他可调用对象，以函数或类作为可选输入参数，然后返回函数或类的形式。通过这个在Python2.6版本中被新加入的特性可以用来实现装饰器设计模式。
顺便提一句，在继续阅读之前，如果你对Python中的闭包(Closure)概念不清楚，请查看本文结尾后的附录，如果没有闭包的相关概念，很难恰当的理解Python中的装饰器。
在Python中，装饰器被用于用@语法糖修辞的函数或类。现在让我们用一个简单的装饰器例子来演示如何做一个函数调用日志记录器。在这个例子中，装饰器将时间格式作为输入参数，在调用被这个装饰器装饰的函数时打印出函数调用的时间。这个装饰器当你需要手动比较两个不同算法或实现的效率时很有用。
```
```python
def
```
```python
logged(time_format):
```
```python
```
```python
def
```
```python
decorator(func):
```
```python
```
```python
def
```
```python
decorated_func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
print
```
```python
"-
 Running '%s' on %s "
```
```python
%
```
```python
(
```
```python
```
```python
func.__name__,
```
```python
```
```python
time.strftime(time_format)
```
```python
```
```python
)
```
```python
```
```python
start_time
```
```python
=
```
```python
time.time()
```
```python
```
```python
result
```
```python
=
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
end_time
```
```python
=
```
```python
time.time()
```
```python
```
```python
print
```
```python
"-
 Finished '%s', execution time = %0.3fs "
```
```python
%
```
```python
(
```
```python
```
```python
func.__name__,
```
```python
```
```python
end_time
```
```python
-
```
```python
start_time
```
```python
```
```python
)
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
decorated_func.__name__
```
```python
=
```
```python
func.__name__
```
```python
```
```python
return
```
```python
decorated_func
```
```python
```
```python
return
```
```python
decorator
```
```
来看一个例子，在这里add1和add2函数被logged修饰，下面给出了一个输出示例。请注意在这里时间格式参数是存储在被返回的装饰器函数中(decorated_func)。这就是为什么理解闭包对于理解装饰器来说很重要的原因。同样也请注意返回函数的名字是如何被替换为原函数名的，以防万一如果它还要被使用到，这是为了防止混淆。Python默认可不会这么做。
```
```python
@logged
```
```python
(
```
```python
"%b
 %d %Y - %H:%M:%S"
```
```python
)
```
```python
def
```
```python
add1(x,
 y):
```
```python
```
```python
time.sleep(
```
```python
1
```
```python
)
```
```python
```
```python
return
```
```python
x
```
```python
+
```
```python
y
```
```python
@logged
```
```python
(
```
```python
"%b
 %d %Y - %H:%M:%S"
```
```python
)
```
```python
def
```
```python
add2(x,
 y):
```
```python
```
```python
time.sleep(
```
```python
2
```
```python
)
```
```python
```
```python
return
```
```python
x
```
```python
+
```
```python
y
```
```python
print
```
```python
add1(
```
```python
1
```
```python
,
```
```python
2
```
```python
)
```
```python
print
```
```python
add2(
```
```python
1
```
```python
,
```
```python
2
```
```python
)
```
```python
#
 Output:
```
```python
-
```
```python
Running
```
```python
'add1'
```
```python
on
 Jul
```
```python
24
```
```python
2013
```
```python
-
```
```python
13
```
```python
:
```
```python
40
```
```python
:
```
```python
47
```
```python
-
```
```python
Finished
```
```python
'add1'
```
```python
,
 execution time
```
```python
=
```
```python
1.001s
```
```python
3
```
```python
-
```
```python
Running
```
```python
'add2'
```
```python
on
 Jul
```
```python
24
```
```python
2013
```
```python
-
```
```python
13
```
```python
:
```
```python
40
```
```python
:
```
```python
48
```
```python
-
```
```python
Finished
```
```python
'add2'
```
```python
,
 execution time
```
```python
=
```
```python
2.001s
```
```python
3
```
```
如果你足够细心，你可能会注意到我们对于返回函数的名字__name__有着特别的处理，但对其他的注入__doc__或是__module__则没有如此。所以如果，在这个例子中add函数有一个doc字符串的话，它就会被丢弃。那么该如何处理呢？我们当然可以像处理__name__那样对待所有的字段，不过如果在每个装饰器内都这么做的话未免太繁冗了。这就是为何functools模块提供了一个名为wraps的装饰器的原因，那正是为了处理这种情况。可能在理解装饰器的过程中会被迷惑，不过当你把装饰器看成是一个接收函数名作为输入参数并且返回一个函数，这样就很好理解了。我们将在下个例子中使用wraps装饰器而不是手动去处理__name__或其他属性。
下个例子会有点复杂，我们的任务是将一个函数调用的返回结果缓存一段时间，输入参数决定缓存时间。传递给函数的输入参数必须是可哈希的对象，因为我们使用包含调用输入参数的tuple作为第一个参数，第二个参数则为一个frozenset对象，它包含了关键词项kwargs，并且作为cache key。每个函数都会有一个唯一的cache字典存储在函数的闭包内。
【译注】set和frozenset为Python的两种内建集合，其中前者为可变对象(mutable)，其元素可以使用add()或remove()进行变更，而后者为不可变对象(imutable)并且是可哈希的(hashable)，在建立之后元素不可变，他可以作为字典的key或是另一个集合的元素。
```
```python
import
```
```python
time
```
```python
from
```
```python
functools
```
```python
import
```
```python
wraps
```
```python
def
```
```python
cached(timeout,
 logged
```
```python
=
```
```python
False
```
```python
):
```
```python
```
```python
"""Decorator
 to cache the result of a function call.
```
```python
```
```python
Cache
 expires after timeout seconds.
```
```python
```
```python
"""
```
```python
```
```python
def
```
```python
decorator(func):
```
```python
```
```python
if
```
```python
logged:
```
```python
```
```python
print
```
```python
"--
 Initializing cache for"
```
```python
,
 func.__name__
```
```python
```
```python
cache
```
```python
=
```
```python
{}
```
```python
```
```python
@wraps
```
```python
(func)
```
```python
```
```python
def
```
```python
decorated_function(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
if
```
```python
logged:
```
```python
```
```python
print
```
```python
"--
 Called function"
```
```python
,
 func.__name__
```
```python
```
```python
key
```
```python
=
```
```python
(args,
```
```python
frozenset
```
```python
(kwargs.items()))
```
```python
```
```python
result
```
```python
=
```
```python
None
```
```python
```
```python
if
```
```python
key
```
```python
in
```
```python
cache:
```
```python
```
```python
if
```
```python
logged:
```
```python
```
```python
print
```
```python
"--
 Cache hit for"
```
```python
,
 func.__name__, key
```
```python
```
```python
(cache_hit,
 expiry)
```
```python
=
```
```python
cache[key]
```
```python
```
```python
if
```
```python
time.time()
```
```python
-
```
```python
expiry
 < timeout:
```
```python
```
```python
result
```
```python
=
```
```python
cache_hit
```
```python
```
```python
elif
```
```python
logged:
```
```python
```
```python
print
```
```python
"--
 Cache expired for"
```
```python
,
 func.__name__, key
```
```python
```
```python
elif
```
```python
logged:
```
```python
```
```python
print
```
```python
"--
 Cache miss for"
```
```python
,
 func.__name__, key
```
```python
```
```python
#
 No cache hit, or expired
```
```python
```
```python
if
```
```python
result
```
```python
is
```
```python
None
```
```python
:
```
```python
```
```python
result
```
```python
=
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
cache[key]
```
```python
=
```
```python
(result,
 time.time())
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
decorated_function
```
```python
```
```python
return
```
```python
decorator
```
```
来看看它的用法。我们使用装饰器装饰一个很基本的斐波拉契数生成器。这个cache装饰器将对代码使用备忘录模式(Memoize Pattern)。请注意fib函数的闭包是如何存放cache字典、一个指向原fib函数的引用、logged参数的值以及timeout参数的最后值的。dump_closure将在文末定义。
```
```python
>>>
 @cached(
```
```python
10
```
```python
,
```
```python
True
```
```python
)
```
```python
...
```
```python
def
```
```python
fib(n):
```
```python
...
```
```python
"""Returns
 the n'th Fibonacci number."""
```
```python
...
```
```python
if
```
```python
n
```
```python
=
```
```python
=
```
```python
0
```
```python
or
```
```python
n
```
```python
=
```
```python
=
```
```python
1
```
```python
:
```
```python
...
```
```python
return
```
```python
1
```
```python
...
```
```python
return
```
```python
fib(n
```
```python
-
```
```python
1
```
```python
)
```
```python
+
```
```python
fib(n
```
```python
-
```
```python
2
```
```python
)
```
```python
...
```
```python
-
```
```python
-
```
```python
Initializing
 cache
```
```python
for
```
```python
fib
```
```python
>>>
 dump_closure(fib)
```
```python
1.
```
```python
Dumping
 function closure
```
```python
for
```
```python
fib:
```
```python
-
```
```python
-
```
```python
cell
```
```python
0
```
```python
=
```
```python
{}
```
```python
-
```
```python
-
```
```python
cell
```
```python
1
```
```python
=
```
```python
-
```
```python
-
```
```python
cell
```
```python
2
```
```python
=
```
```python
True
```
```python
-
```
```python
-
```
```python
cell
```
```python
3
```
```python
=
```
```python
10
```
```python
>>>
```
```python
>>>
```
```python
print
```
```python
"Testing
 - F(4) = %d"
```
```python
%
```
```python
fib(
```
```python
4
```
```python
)
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 miss
```
```python
for
```
```python
fib
 ((
```
```python
4
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 miss
```
```python
for
```
```python
fib
 ((
```
```python
3
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 miss
```
```python
for
```
```python
fib
 ((
```
```python
2
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 miss
```
```python
for
```
```python
fib
 ((
```
```python
1
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 miss
```
```python
for
```
```python
fib
 ((
```
```python
0
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 hit
```
```python
for
```
```python
fib
 ((
```
```python
1
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
-
```
```python
-
```
```python
Called
 function fib
```
```python
-
```
```python
-
```
```python
Cache
 hit
```
```python
for
```
```python
fib
 ((
```
```python
2
```
```python
,),
```
```python
frozenset
```
```python
([]))
```
```python
Testing
```
```python
-
```
```python
F(
```
```python
4
```
```python
)
```
```python
=
```
```python
5
```
```
### Class Decorators
在之前的小节中，我们看了一些函数装饰器和一些使用的小技巧，接下来我们来看看类装饰器。类装饰器将一个class作为输入参数(Python中的一种类类型对象)，并且返回一个修改过的class。
第一个例子是一个简单的数学问题。当给定一个有序集合P，我们定义Pd为P的反序集合P(x,y)
 <-> Pd(x,y)，也就是说两个有序集合的元素顺序互为相反的，这在Python中该如何实现？假定一个类定义了__lt__以及__le__或其他方法来实现有序。那么我们可以通过写一个类装饰器来替换这些方法。
```
```python
def
```
```python
make_dual(relation):
```
```python
```
```python
@wraps
```
```python
(relation,
 [
```
```python
'__name__'
```
```python
,
```
```python
'__doc__'
```
```python
])
```
```python
```
```python
def
```
```python
dual(x,
 y):
```
```python
```
```python
return
```
```python
relation(y,
 x)
```
```python
```
```python
return
```
```python
dual
```
```python
def
```
```python
dual_ordering(
```
```python
cls
```
```python
):
```
```python
```
```python
"""Class
 decorator that reverses all the orderings"""
```
```python
```
```python
for
```
```python
func
```
```python
in
```
```python
[
```
```python
'__lt__'
```
```python
,
```
```python
'__gt__'
```
```python
,
```
```python
'__ge__'
```
```python
,
```
```python
'__le__'
```
```python
]:
```
```python
```
```python
if
```
```python
hasattr
```
```python
(
```
```python
cls
```
```python
,
 func):
```
```python
```
```python
setattr
```
```python
(
```
```python
cls
```
```python
,
 func, make_dual(
```
```python
getattr
```
```python
(
```
```python
cls
```
```python
,
 func)))
```
```python
```
```python
return
```
```python
cls
```
```
下面是将这个装饰器用以str类型的例子，创建一个名为rstr的新类，使用反字典序(opposite lexicographic)为其顺序。
```
```python
@dual_ordering
```
```python
class
```
```python
rstr(
```
```python
str
```
```python
):
```
```python
```
```python
pass
```
```python
x
```
```python
=
```
```python
rstr(
```
```python
"1"
```
```python
)
```
```python
y
```
```python
=
```
```python
rstr(
```
```python
"2"
```
```python
)
```
```python
print
```
```python
x
 < y
```
```python
print
```
```python
x
 <
```
```python
=
```
```python
y
```
```python
print
```
```python
x
 > y
```
```python
print
```
```python
x
 >
```
```python
=
```
```python
y
```
```python
#
 Output:
```
```python
False
```
```python
False
```
```python
True
```
```python
True
```
```
来看一个更复杂的例子。假定我们希望前面所说的logged装饰器能够被用于某个类的所有方法。一个方案是在每个类方法上都加上装饰器。另一个方案是写一个类装饰器自动完成这些工作。在动手之前，我将把前例中的logged装饰器拿出来做一些小改进。首先，它使用functools提供的wraps装饰器完成固定__name__的工作。第二，一个_logged_decorator属性被引入(设置为True的布尔型变量)，用来指示这个方法是否已经被装饰器装饰过，因为这个类可能会被继承而子类也许会继续使用装饰器。最后，name_prefix参数被加入用来设置打印的日志信息。
```
```python
def
```
```python
logged(time_format,
 name_prefix
```
```python
=
```
```python
""):
```
```python
```
```python
def
```
```python
decorator(func):
```
```python
```
```python
if
```
```python
hasattr
```
```python
(func,
```
```python
'_logged_decorator'
```
```python
)
```
```python
and
```
```python
func._logged_decorator:
```
```python
```
```python
return
```
```python
func
```
```python
```
```python
@wraps
```
```python
(func)
```
```python
```
```python
def
```
```python
decorated_func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
start_time
```
```python
=
```
```python
time.time()
```
```python
```
```python
print
```
```python
"-
 Running '%s' on %s "
```
```python
%
```
```python
(
```
```python
```
```python
name_prefix
```
```python
+
```
```python
func.__name__,
```
```python
```
```python
time.strftime(time_format)
```
```python
```
```python
)
```
```python
```
```python
result
```
```python
=
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
end_time
```
```python
=
```
```python
time.time()
```
```python
```
```python
print
```
```python
"-
 Finished '%s', execution time = %0.3fs "
```
```python
%
```
```python
(
```
```python
```
```python
name_prefix
```
```python
+
```
```python
func.__name__,
```
```python
```
```python
end_time
```
```python
-
```
```python
start_time
```
```python
```
```python
)
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
decorated_func._logged_decorator
```
```python
=
```
```python
True
```
```python
```
```python
return
```
```python
decorated_func
```
```python
```
```python
return
```
```python
decorator
```
```
好的，让我们开始写类装饰器：
```
```python
def
```
```python
log_method_calls(time_format):
```
```python
```
```python
def
```
```python
decorator(
```
```python
cls
```
```python
):
```
```python
```
```python
for
```
```python
o
```
```python
in
```
```python
dir
```
```python
(
```
```python
cls
```
```python
):
```
```python
```
```python
if
```
```python
o.startswith(
```
```python
'__'
```
```python
):
```
```python
```
```python
continue
```
```python
```
```python
a
```
```python
=
```
```python
getattr
```
```python
(
```
```python
cls
```
```python
,
 o)
```
```python
```
```python
if
```
```python
hasattr
```
```python
(a,
```
```python
'__call__'
```
```python
):
```
```python
```
```python
decorated_a
```
```python
=
```
```python
logged(time_format,
```
```python
cls
```
```python
.__name__
```
```python
+
```
```python
"."
```
```python
)(a)
```
```python
```
```python
setattr
```
```python
(
```
```python
cls
```
```python
,
 o, decorated_a)
```
```python
```
```python
return
```
```python
cls
```
```python
```
```python
return
```
```python
decorator
```
```
下面是使用方法，注意被继承的或被重写的方法是如何处理的。
```
```python
@log_method_calls
```
```python
(
```
```python
"%b
 %d %Y - %H:%M:%S"
```
```python
)
```
```python
class
```
```python
A(
```
```python
object
```
```python
):
```
```python
```
```python
def
```
```python
test1(
```
```python
self
```
```python
):
```
```python
```
```python
print
```
```python
"test1"
```
```python
@log_method_calls
```
```python
(
```
```python
"%b
 %d %Y - %H:%M:%S"
```
```python
)
```
```python
class
```
```python
B(A):
```
```python
```
```python
def
```
```python
test1(
```
```python
self
```
```python
):
```
```python
```
```python
super
```
```python
(B,
```
```python
self
```
```python
).test1()
```
```python
```
```python
print
```
```python
"child
 test1"
```
```python
```
```python
def
```
```python
test2(
```
```python
self
```
```python
):
```
```python
```
```python
print
```
```python
"test2"
```
```python
b
```
```python
=
```
```python
B()
```
```python
b.test1()
```
```python
b.test2()
```
```python
#
 Output:
```
```python
-
```
```python
Running
```
```python
'B.test1'
```
```python
on
 Jul
```
```python
24
```
```python
2013
```
```python
-
```
```python
14
```
```python
:
```
```python
15
```
```python
:
```
```python
03
```
```python
-
```
```python
Running
```
```python
'A.test1'
```
```python
on
 Jul
```
```python
24
```
```python
2013
```
```python
-
```
```python
14
```
```python
:
```
```python
15
```
```python
:
```
```python
03
```
```python
test1
```
```python
-
```
```python
Finished
```
```python
'A.test1'
```
```python
,
 execution time
```
```python
=
```
```python
0.000s
```
```python
child
 test1
```
```python
-
```
```python
Finished
```
```python
'B.test1'
```
```python
,
 execution time
```
```python
=
```
```python
1.001s
```
```python
-
```
```python
Running
```
```python
'B.test2'
```
```python
on
 Jul
```
```python
24
```
```python
2013
```
```python
-
```
```python
14
```
```python
:
```
```python
15
```
```python
:
```
```python
04
```
```python
test2
```
```python
-
```
```python
Finished
```
```python
'B.test2'
```
```python
,
 execution time
```
```python
=
```
```python
2.001s
```
```
我们第一个类装饰器的例子是类的反序方法。一个相似的装饰器，可以说是相当有用的，实现__lt__、__le__、__gt__、__ge__和__eq__中的一个，能够实现类的全排序么？这也就是functools.total_ordering装饰器所做的工作。详情请见[参考文档](https://docs.python.org/2/library/functools.html)。
### Flask中的一些例子
让我们来看看Flask中用到的一些有趣的装饰器。
假定你希望让某些函数在特定的调用时刻输出警告信息，例如仅仅在debug模式下。而你又不希望每个函数都加入控制的代码，那么你就能够使用装饰器来实现。以下就是Flask的app.py中定义的装饰器的工作。
```
```python
def
```
```python
setupmethod(f):
```
```python
```
```python
"""Wraps
 a method so that it performs a check in debug mode if the
```
```python
```
```python
first
 request was already handled.
```
```python
```
```python
"""
```
```python
```
```python
def
```
```python
wrapper_func(
```
```python
self
```
```python
,
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
if
```
```python
self
```
```python
.debug
```
```python
and
```
```python
self
```
```python
._got_first_request:
```
```python
```
```python
raise
```
```python
AssertionError(
```
```python
'A
 setup function was called after the '
```
```python
```
```python
'first
 request was handled.  This usually indicates a bug '
```
```python
```
```python
'in
 the application where a module was not imported '
```
```python
```
```python
'and
 decorators or other functionality was called too late.\n'
```
```python
```
```python
'To
 fix this make sure to import all your view modules, '
```
```python
```
```python
'database
 models and everything related at a central place '
```
```python
```
```python
'before
 the application starts serving requests.'
```
```python
)
```
```python
```
```python
return
```
```python
f(
```
```python
self
```
```python
,
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
return
```
```python
update_wrapper(wrapper_func,
 f)
```
```
来看一个更有趣的例子，这个例子是Flask的route装饰器，在Flask类中定义。注意到装饰器可以是类中的一个方法，将self作为第一个参数。完整的代码在app.py中。请注意装饰器简单的将被装饰过的函数注册成为一个URL句柄，这是通过调用add_url_rule函数来实现的。
```
```python
def
```
```python
route(
```
```python
self
```
```python
,
 rule,
```
```python
*
```
```python
*
```
```python
options):
```
```python
```
```python
"""A
 decorator that is used to register a view function for a
```
```python
```
```python
given
 URL rule.  This does the same thing as :meth:`add_url_rule`
```
```python
```
```python
but
 is intended for decorator usage::
```
```python
```
```python
@app.route('/')
```
```python
```
```python
def
 index():
```
```python
```
```python
return
 'Hello World'
```
```python
```
```python
For
 more information refer to :ref:`url-route-registrations`.
```
```python
```
```python
:param
 rule: the URL rule as string
```
```python
```
```python
:param
 endpoint: the endpoint for the registered URL rule.  Flask
```
```python
```
```python
itself
 assumes the name of the view function as
```
```python
```
```python
endpoint
```
```python
```
```python
:param
 options: the options to be forwarded to the underlying
```
```python
```
```python
:class:`~werkzeug.routing.Rule`
 object.  A change
```
```python
```
```python
to
 Werkzeug is handling of method options.  methods
```
```python
```
```python
is
 a list of methods this rule should be limited
```
```python
```
```python
to
 (`GET`, `POST` etc.).  By default a rule
```
```python
```
```python
just
 listens for `GET` (and implicitly `HEAD`).
```
```python
```
```python
Starting
 with Flask 0.6, `OPTIONS` is implicitly
```
```python
```
```python
added
 and handled by the standard request handling.
```
```python
```
```python
"""
```
```python
```
```python
def
```
```python
decorator(f):
```
```python
```
```python
endpoint
```
```python
=
```
```python
options.pop(
```
```python
'endpoint'
```
```python
,
```
```python
None
```
```python
)
```
```python
```
```python
self
```
```python
.add_url_rule(rule,
 endpoint, f,
```
```python
*
```
```python
*
```
```python
options)
```
```python
```
```python
return
```
```python
f
```
```python
```
```python
return
```
```python
decorator
```
```
## 扩展阅读
1. [official Python Wiki](https://wiki.python.org/moin/PythonDecorators)
2. [metaprogramming in Python 3](http://pyvideo.org/video/1716/python-3-metaprogramming)
## 附录：闭包
一个函数闭包是一个函数和一个引用集合的组合，这个引用集合指向这个函数被定义的作用域的变量。后者通常指向一个引用环境(referencing environment)，这使得函数能够在它被定义的区域之外执行。在Python中，这个引用环境被存储在一个cell的tuple中。你能够通过func_closure或Python 3中的__closure__属性访问它。要铭记的一点是引用及是引用，而不是对象的深度拷贝。当然了，对于不可变对象而言，这并不是问题，然而对可变对象(list)这点就必须注意，随后会有一个例子说明。请注意函数在定义的地方也有__globals__字段来存储全局引用环境。
来看一个简单的例子：
```
```python
>>>
```
```python
def
```
```python
return_func_that_prints_s(s):
```
```python
...
```
```python
def
```
```python
f():
```
```python
...
```
```python
print
```
```python
s
```
```python
...
```
```python
return
```
```python
f
```
```python
...
```
```python
>>>
 g
```
```python
=
```
```python
return_func_that_prints_s(
```
```python
"Hello"
```
```python
)
```
```python
>>>
 h
```
```python
=
```
```python
return_func_that_prints_s(
```
```python
"World"
```
```python
)
```
```python
>>>
 g()
```
```python
Hello
```
```python
>>>
 h()
```
```python
World
```
```python
>>>
 g
```
```python
is
```
```python
h
```
```python
False
```
```python
>>>
 h.__closure__
```
```python
(,)
```
```python
>>>
```
```python
print
```
```python
[
```
```python
str
```
```python
(c.cell_contents)
```
```python
for
```
```python
c
```
```python
in
```
```python
g.__closure__]
```
```python
[
```
```python
'Hello'
```
```python
]
```
```python
>>>
```
```python
print
```
```python
[
```
```python
str
```
```python
(c.cell_contents)
```
```python
for
```
```python
c
```
```python
in
```
```python
h.__closure__]
```
```python
[
```
```python
'World'
```
```python
]
```
```
一个稍复杂的例子。确保明白为什么会这么执行。
```
```python
>>>
```
```python
def
```
```python
return_func_that_prints_list(z):
```
```python
...
```
```python
def
```
```python
f():
```
```python
...
```
```python
print
```
```python
z
```
```python
...
```
```python
return
```
```python
f
```
```python
...
```
```python
>>>
 z
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
]
```
```python
>>>
 g
```
```python
=
```
```python
return_func_that_prints_list(z)
```
```python
>>>
 g()
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
]
```
```python
>>>
 z.append(
```
```python
3
```
```python
)
```
```python
>>>
 g()
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
]
```
```python
>>>
 z
```
```python
=
```
```python
[
```
```python
1
```
```python
]
```
```python
>>>
 g()
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
]
```
```
【译者】：z.append(3)时，g()内部的引用和z仍然指向一个变量，而z=[1]之后，两者就不再指向一个变量了。
最后，来看看代码中使用到的dump_closure方法的定义。
```
```python
def
```
```python
dump_closure(f):
```
```python
```
```python
if
```
```python
hasattr
```
```python
(f,
```
```python
"__closure__"
```
```python
)
```
```python
and
```
```python
f.__closure__
```
```python
is
```
```python
not
```
```python
None
```
```python
:
```
```python
```
```python
print
```
```python
"-
 Dumping function closure for %s:"
```
```python
%
```
```python
f.__name__
```
```python
```
```python
for
```
```python
i,
 c
```
```python
in
```
```python
enumerate
```
```python
(f.__closure__):
```
```python
```
```python
print
```
```python
"--
 cell %d  = %s"
```
```python
%
```
```python
(i, c.cell_contents)
```
```python
```
```python
else
```
```python
:
```
```python
```
```python
print
```
```python
"
 - %s has no closure!"
```
```python
%
```
```python
f.__name__
```
```python
```
```
