# 第三篇：白话tornado源码之请求来了 - 宇宙浪子的专栏 - CSDN博客
2017年09月08日 13:16:03[_宇宙浪子_](https://me.csdn.net/bluehawksky)阅读数：193
转自：[http://www.cnblogs.com/wupeiqi/p/4540398.html](http://www.cnblogs.com/wupeiqi/p/4540398.html)
上一篇[《白话tornado源码之待请求阶段》](http://www.cnblogs.com/wupeiqi/p/4375610.html)中介绍了tornado框架在客户端请求之前所做的准备（下图1、2部分），本质上就是创建了一个socket服务端，并进行了IP和端口的绑定，但是未执行
 socket的accept方法，也就是未获取客户端请求信息。
### 概述
![](http://images0.cnblogs.com/blog2015/425762/201506/171124357959505.png)
本篇就来详细介绍tornado服务器（socket服务端）是如何接收用户请求数据以及如果根据用户请求的URL处理并返回数据，也就是上图的3系列所有步骤，如上图【start】是一个死循环，其中利用epoll监听服务端socket句柄，一旦客户端发送请求，则立即调用HttpServer对象的_handle_events方法来进行请求的处理。
对于整个3系列按照功能可以划分为四大部分：
- 获取用户请求数据（上图3.4）
- 根据用户请求URL进行路由匹配，从而使得某个方法处理具体的请求（上图3.5～3.19）
- 将处理后的数据返回给客户端（上图3.21～3.23）
- 关闭客户端socket（上图3.24～3.26）
### 3.1、HTTPServer对象的_handle_events方法
此处代码主要有三项任务：
　　1、 socket.accept() 接收了客户端请求。
　　2、创建封装了客户端socket对象和IOLoop对象的IOStream实例（用于之后获取或输出数据）。
　　3、创建HTTPConnection对象，其内容是实现整个功能的逻辑。
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
class HTTPServer(object):
def _handle_events(self, fd, events):
        while True:
            try:
                #======== 获取客户端请求 =========#
                connection, address = self._socket.accept()
            except socket.error, e:
                if e.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):
                    return
                raise
            if self.ssl_options is not None:
                assert ssl, "Python 2.6+ and OpenSSL required for SSL"
                try:
                    connection = ssl.wrap_socket(connection,
                                                 server_side=True,
                                                 do_handshake_on_connect=False,
                                                 **self.ssl_options)
                except ssl.SSLError, err:
                    if err.args[0] == ssl.SSL_ERROR_EOF:
                        return connection.close()
                    else:
                        raise
                except socket.error, err:
                    if err.args[0] == errno.ECONNABORTED:
                        return connection.close()
                    else:
                        raise
            try:
                #这是的条件是选择https和http请求方式
                if self.ssl_options is not None:
                    stream = iostream.SSLIOStream(connection, io_loop=self.io_loop)
                else:
                    #将客户端socket对象和IOLoop对象封装到IOStream对象中
                    #IOStream用于从客户端socket中读取请求信息
                    stream = iostream.IOStream(connection, io_loop=self.io_loop)
                #创建HTTPConnection对象
                #address是客户端IPdizhi
                #self.request_callback是Application对象，其中包含了：url映射关系和配置文件等..
                #so，HTTPConnection的构造函数就是下一步处理请求的位置了..
                HTTPConnection(stream, address, self.request_callback,self.no_keep_alive, self.xheaders)
            except:
                logging.error("Error in connection callback", exc_info=True)
![复制代码](http://common.cnblogs.com/images/copycode.gif)
### 3.2、IOStream的__init__方法
此处代码主要两项目任务：
- 封装客户端socket和其他信息，以便之后执行该对象的其他方法获取客户端请求的数据和响应客户信息
- 将客户端socket对象添加到epoll，并且指定当客户端socket对象变化时，就去执行 IOStream的_handle_events方法（调用socket.send给用户响应数据）
```
```python
class
```
```python
IOStream(
```
```python
object
```
```python
):
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
,
 socket, io_loop
```
```python
=
```
```python
None
```
```python
,
 max_buffer_size
```
```python
=
```
```python
104857600
```
```python
,
```
```python
```
```python
read_chunk_size
```
```python
=
```
```python
4096
```
```python
):
```
```python
```
```python
#客户端socket对象
```
```python
```
```python
self
```
```python
.socket
```
```python
=
```
```python
socket
```
```python
```
```python
self
```
```python
.socket.setblocking(
```
```python
False
```
```python
)
```
```python
```
```python
self
```
```python
.io_loop
```
```python
=
```
```python
io_loop
```
```python
or
```
```python
ioloop.IOLoop.instance()
```
```python
```
```python
self
```
```python
.max_buffer_size
```
```python
=
```
```python
max_buffer_size
```
```python
```
```python
self
```
```python
.read_chunk_size
```
```python
=
```
```python
read_chunk_size
```
```python
```
```python
self
```
```python
._read_buffer
```
```python
=
```
```python
collections.deque()
```
```python
```
```python
self
```
```python
._write_buffer
```
```python
=
```
```python
collections.deque()
```
```python
```
```python
self
```
```python
._write_buffer_frozen
```
```python
=
```
```python
False
```
```python
```
```python
self
```
```python
._read_delimiter
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._read_bytes
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._read_callback
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._write_callback
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._close_callback
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._connect_callback
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._connecting
```
```python
=
```
```python
False
```
```python
```
```python
self
```
```python
._state
```
```python
=
```
```python
self
```
```python
.io_loop.ERROR
```
```python
```
```python
with
 stack_context.NullContext():
```
```python
```
```python
#将客户端socket句柄添加的epoll中，并将IOStream的_handle_events方法添加到
 Start 的While循环中
```
```python
```
```python
#Start
 的While循环中监听客户端socket句柄的状态，以便再最后调用IOStream的_handle_events方法把处理后的信息响应给用户
```
```python
```
```python
self
```
```python
.io_loop.add_handler(
```
```python
self
```
```python
.socket.fileno(),
```
```python
self
```
```python
._handle_events,
```
```python
self
```
```python
._state)
```
```
### 3.3、HTTPConnections的__init__方法
此处代码主要两项任务：
- 获取请求数据
- 调用 _on_headers 继续处理请求
对于获取请求数据，其实就是执行IOStream的read_until函数来完成，其内部通过socket.recv(4096)方法获取客户端请求的数据，并以 【\r\n\r\n】作为请求信息结束符（http请求头和内容通过\r\n\r\n分割）。
```
```python
class
```
```python
HTTPConnection(
```
```python
object
```
```python
):
```
```python
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
,
 stream, address, request_callback, no_keep_alive
```
```python
=
```
```python
False
```
```python
,xheaders
```
```python
=
```
```python
False
```
```python
):
```
```python
```
```python
```
```python
self
```
```python
.stream
```
```python
=
```
```python
stream
```
```python
#stream是封装了客户端socket和IOLoop实例的IOStream对象
```
```python
```
```python
self
```
```python
.address
```
```python
=
```
```python
address
```
```python
#address是客户端IP地址
```
```python
```
```python
self
```
```python
.request_callback
```
```python
=
```
```python
request_callback
```
```python
#request_callback是封装了URL映射和配置文件的Application对象。
```
```python
```
```python
self
```
```python
.no_keep_alive
```
```python
=
```
```python
no_keep_alive
```
```python
```
```python
self
```
```python
.xheaders
```
```python
=
```
```python
xheaders
```
```python
```
```python
self
```
```python
._request
```
```python
=
```
```python
None
```
```python
```
```python
self
```
```python
._request_finished
```
```python
=
```
```python
False
```
```python
```
```python
#获取请求信息（请求头和内容），然后执行
 HTTPConnection的_on_headers方法继续处理请求
```
```python
```
```python
self
```
```python
._header_callback
```
```python
=
```
```python
stack_context.wrap(
```
```python
self
```
```python
._on_headers)
```
```python
```
```python
self
```
```python
.stream.read_until(
```
```python
"\r\n\r\n"
```
```python
,
```
```python
self
```
```python
._header_callback)
```
```
请求数据格式：
> 
GET
 / HTTP/1.1
Host: localhost:8888
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like
 Gecko) Chrome/41.0.2272.118 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4
If-None-Match: "e02aa1b106d5c7c6a98def2b13005d5b84fd8dc8"
详细代码解析：
```
```
```
