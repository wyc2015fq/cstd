# Python高级特性（1）：Iterators、Generators和itertools - 宇宙浪子的专栏 - CSDN博客
2014年09月05日 14:43:18[_宇宙浪子_](https://me.csdn.net/bluehawksky)阅读数：603标签：[python](https://so.csdn.net/so/search/s.do?q=python&t=blog)
个人分类：[Python](https://blog.csdn.net/bluehawksky/article/category/2542577)

# 本文由 [伯乐在线](http://blog.jobbole.com/) - [熊崽Kevin](http://blog.jobbole.com/author/dysj4099/) 翻译自 [Sahand Saba](http://sahandsaba.com/python-iterators-generators.html)。欢迎加入[技术翻译小组](http://www.jobbole.com/groups/6/)。转载请参见文章末尾处的要求。
【译注】：作为一门动态脚本语言，Python对编程初学者而言很友好，丰富的第三方库能够给使用者带来很大的便利。而Python同时也能够提供一些高级的特性方便用户使用更为复杂的数据结构。本系列文章共有三篇，本文是系列的第一篇，将会介绍迭代器、生成器以及itertools模块的相关用法。由于作者
 Sahand Saba 列举的示例中有诸多专业的数学相关内容，因此翻译中有诸多不妥之处请大家指出，非常感谢。
对数学家来说，Python这门语言有着很多吸引他们的地方。举几个例子：对于tuple、lists以及sets等容器的支持，使用与传统数学类似的符号标记方式，还有列表推导式这样与数学中集合推导式和集的结构式(set-builder notation)很相似的语法结构。
另外一些很吸引数学爱好者的特性是Python中的iterator(迭代器)、generator(生成器)以及相关的itertools包。这些工具帮助人们能够很轻松的写出处理诸如无穷序列(infinite sequence)、随机过程(stochastic processes)、递推关系(recurrence relations)以及组合结构(combinatorial structures)等数学对象的优雅代码。本文将涵盖我关于迭代器和生成器的一些笔记，并且有一些我在学习过程中积累的相关经验。
## Iterators
迭代器(Iterator)是一个可以对集合进行迭代访问的对象。通过这种方式不需要将集合全部载入内存中，也正因如此，这种集合元素几乎可以是无限的。你可以在Python官方文档的“迭代器类型(Iterator Type)”部分找到相关文档。
让我们对定义的描述再准确些，如果一个对象定义了__iter__方法，并且此方法需要返回一个迭代器，那么这个对象就是可迭代的(iterable)。而迭代器是指实现了__iter__以及next(在Python 3中为__next__)两个方法的对象，前者返回一个迭代器对象，而后者返回迭代过程的下一个集合元素。据我所知，迭代器总是在__iter__方法中简单的返回自己(self)，因为它们正是自己的迭代器。
一般来说，你应该避免直接调用__iter__以及next方法。而应该使用for或是列表推导式(list comprehension)，这样的话Python能够自动为你调用这两个方法。如果你需要手动调用它们，请使用Python的内建函数iter以及next，并且把目标迭代器对象或是集合对象当做参数传递给它们。举个例子，如果c是一个可迭代对象，那么你可以使用iter(c)来访问，而不是c.__iter__()，类似的，如果a是一个迭代器对象，那么请使用next(a)而不是a.next()来访问下一个元素。与之相类似的还有len的用法。
说到len，值得注意的是对迭代器而言没必要去纠结length的定义。所以它们通常不会去实现__len__方法。如果你需要计算容器的长度，那么必须得手动计算，或者使用sum。本文末，在itertools模块之后会给出一个例子。
有一些可迭代对象并不是迭代器，而是使用其他对象作为迭代器。举个例子，list对象是一个可迭代对象，但并不是一个迭代器(它实现了__iter__但并未实现next)。通过下面的例子你可以看到list是如何使用迭代器listiterator的。同时值得注意的是list很好地定义了length属性，而listiterator却没有。
```
```python
>>>
 a
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
]
```
```python
>>>
```
```python
type
```
```python
(a)
```
```python
<
```
```python
type
```
```python
'list'
```
```python
>
```
```python
>>>
```
```python
type
```
```python
(
```
```python
iter
```
```python
(a))
```
```python
<
```
```python
type
```
```python
'listiterator'
```
```python
>
```
```python
>>>
 it
```
```python
=
```
```python
iter
```
```python
(a)
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
1
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
2
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
Traceback
 (most recent call last):
```
```python
```
```python
File
```
```python
"<stdin>"
```
```python
,
 line
```
```python
1
```
```python
,
```
```python
in
```
```python
<module>
```
```python
StopIteration
```
```python
>>>
```
```python
len
```
```python
(a)
```
```python
2
```
```python
>>>
```
```python
len
```
```python
(it)
```
```python
Traceback
 (most recent call last):
```
```python
```
```python
File
```
```python
"<stdin>"
```
```python
,
 line
```
```python
1
```
```python
,
```
```python
in
```
```python
<module>
```
```python
TypeError:
```
```python
object
```
```python
of
```
```python
type
```
```python
'listiterator'
```
```python
has
 no
```
```python
len
```
```python
()
```
```
当迭代结束却仍然被继续迭代访问时，Python解释器会抛出StopIteration异常。然而，前述中提到迭代器可以迭代一个无穷集合，所以对于这种迭代器就必须由用户负责确保不会造成无限循环的情况，请看下面的例子：
```
```python
class
```
```python
count_iterator(
```
```python
object
```
```python
):
```
```python
```
```python
n
```
```python
=
```
```python
0
```
```python
```
```python
def
```
```python
__iter__(
```
```python
self
```
```python
):
```
```python
```
```python
return
```
```python
self
```
```python
```
```python
def
```
```python
next
```
```python
(
```
```python
self
```
```python
):
```
```python
```
```python
y
```
```python
=
```
```python
self
```
```python
.n
```
```python
```
```python
self
```
```python
.n
```
```python
+
```
```python
=
```
```python
1
```
```python
```
```python
return
```
```python
y
```
```
下面是例子，注意最后一行试图将一个迭代器对象转为list，这将导致一个无限循环，因为这种迭代器对象将不会停止。
```
```python
>>>
 counter
```
```python
=
```
```python
count_iterator()
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
0
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
1
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
2
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
3
```
```python
>>>
```
```python
list
```
```python
(counter)
```
```python
#
 This will result in an infinite loop!
```
```
最后，我们将修改以上的程序：如果一个对象没有__iter__方法但定义了__getitem__方法，那么这个对象仍然是可迭代的。在这种情况下，当Python的内建函数iter将会返回一个对应此对象的迭代器类型，并使用__getitem__方法遍历list的所有元素。如果StopIteration或IndexError异常被抛出，则迭代停止。让我们看看以下的例子：
```
```python
class
```
```python
SimpleList(
```
```python
object
```
```python
):
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
,
```
```python
*
```
```python
items):
```
```python
```
```python
self
```
```python
.items
```
```python
=
```
```python
items
```
```python
```
```python
def
```
```python
__getitem__(
```
```python
self
```
```python
,
 i):
```
```python
```
```python
return
```
```python
self
```
```python
.items[i]
```
```
用法在此：
```
```python
>>>
 a
```
```python
=
```
```python
SimpleList(
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
)
```
```python
>>>
 it
```
```python
=
```
```python
iter
```
```python
(a)
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
1
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
2
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
3
```
```python
>>>
```
```python
next
```
```python
(it)
```
```python
Traceback
 (most recent call last):
```
```python
```
```python
File
```
```python
"<stdin>"
```
```python
,
 line
```
```python
1
```
```python
,
```
```python
in
```
```python
<module>
```
```python
StopIteration
```
```
现在来看一个更有趣的例子：根据初始条件使用迭代器生成[Hofstadter Q序列](http://en.wikipedia.org/wiki/Hofstadter_sequence)。Hofstadter在他的著作《Gödel, Escher, Bach:
 An Eternal Golden Braid》中首次提到了这个嵌套的序列，并且自那时候开始关于证明这个序列对所有n都成立的问题就开始了。以下的代码使用一个迭代器来生成给定n的Hofstadter序列，定义如下：
```
Q(n)=Q(n-Q(n-1))+Q(n−Q(n−2))
```
给定一个初始条件，举个例子，qsequence([1, 1])将会生成H序列。我们使用StopIteration异常来指示序列不能够继续生成了，因为需要一个合法的下标索引来生成下一个元素。例如如果初始条件是[1,2]，那么序列生成将立即停止。
```
```python
class
```
```python
qsequence(
```
```python
object
```
```python
):
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
,
 s):
```
```python
```
```python
self
```
```python
.s
```
```python
=
```
```python
s[:]
```
```python
```
```python
def
```
```python
next
```
```python
(
```
```python
self
```
```python
):
```
```python
```
```python
try
```
```python
:
```
```python
```
```python
q
```
```python
=
```
```python
self
```
```python
.s[
```
```python
-
```
```python
self
```
```python
.s[
```
```python
-
```
```python
1
```
```python
]]
```
```python
+
```
```python
self
```
```python
.s[
```
```python
-
```
```python
self
```
```python
.s[
```
```python
-
```
```python
2
```
```python
]]
```
```python
```
```python
self
```
```python
.s.append(q)
```
```python
```
```python
return
```
```python
q
```
```python
```
```python
except
```
```python
IndexError:
```
```python
```
```python
raise
```
```python
StopIteration()
```
```python
```
```python
def
```
```python
__iter__(
```
```python
self
```
```python
):
```
```python
```
```python
return
```
```python
self
```
```python
```
```python
def
```
```python
current_state(
```
```python
self
```
```python
):
```
```python
```
```python
return
```
```python
self
```
```python
.s
```
```
用法在此：
```
```python
>>>
 Q
```
```python
=
```
```python
qsequence([
```
```python
1
```
```python
,
```
```python
1
```
```python
])
```
```python
>>>
```
```python
next
```
```python
(Q)
```
```python
2
```
```python
>>>
```
```python
next
```
```python
(Q)
```
```python
3
```
```python
>>>
 [
```
```python
next
```
```python
(Q)
```
```python
for
```
```python
__
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
)]
```
```python
[
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
6
```
```python
,
```
```python
6
```
```python
,
```
```python
8
```
```python
,
```
```python
8
```
```python
,
```
```python
8
```
```python
]
```
```
## Generators
生成器(Generator)是一种用更简单的函数表达式定义的生成器。说的更具体一些，在生成器内部会用到yield表达式。生成器不会使用return返回值，而当需要时使用yield表达式返回结果。Python的内在机制能够帮助记住当前生成器的上下文，也就是当前的控制流和局部变量的值等。每次生成器被调用都适用yield返回迭代过程中的下一个值。__iter__方法是默认实现的，意味着任何能够使用迭代器的地方都能够使用生成器。下面这个例子实现的功能同上面迭代器的例子一样，不过代码更紧凑，可读性更强。
```
```python
def
```
```python
count_generator():
```
```python
```
```python
n
```
```python
=
```
```python
0
```
```python
```
```python
while
```
```python
True
```
```python
:
```
```python
```
```python
yield
```
```python
n
```
```python
```
```python
n
```
```python
+
```
```python
=
```
```python
1
```
```
来看看用法：
```
```python
>>>
 counter
```
```python
=
```
```python
count_generator()
```
```python
>>>
 counter
```
```python
<generator
```
```python
object
```
```python
count_generator
 at
```
```python
0x106bf1aa0
```
```python
>
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
0
```
```python
>>>
```
```python
next
```
```python
(counter)
```
```python
1
```
```python
>>>
```
```python
iter
```
```python
(counter)
```
```python
<generator
```
```python
object
```
```python
count_generator
 at
```
```python
0x106bf1aa0
```
```python
>
```
```python
>>>
```
```python
iter
```
```python
(counter)
```
```python
is
```
```python
counter
```
```python
True
```
```python
>>>
```
```python
type
```
```python
(counter)
```
```python
<
```
```python
type
```
```python
'generator'
```
```python
>
```
```
现在让我们尝试用生成器来实现Hofstadter’s Q队列。这个实现很简单，不过我们却不能实现前的类似于current_state那样的函数了。因为据我所知，不可能在外部直接访问生成器内部的变量状态，因此如current_state这样的函数就不可能实现了(虽然有诸如gi_frame.f_locals这样的数据结构可以做到，但是这毕竟是CPython的特殊实现，并不是这门语言的标准部分，所以并不推荐使用)。如果需要访问内部变量，一个可能的方法是通过yield返回所有的结果，我会把这个问题留作练习。
```
```python
def
```
```python
hofstadter_generator(s):
```
```python
```
```python
a
```
```python
=
```
```python
s[:]
```
```python
```
```python
while
```
```python
True
```
```python
:
```
```python
```
```python
try
```
```python
:
```
```python
```
```python
q
```
```python
=
```
```python
a[
```
```python
-
```
```python
a[
```
```python
-
```
```python
1
```
```python
]]
```
```python
+
```
```python
a[
```
```python
-
```
```python
a[
```
```python
-
```
```python
2
```
```python
]]
```
```python
```
```python
a.append(q)
```
```python
```
```python
yield
```
```python
q
```
```python
```
```python
except
```
```python
IndexError:
```
```python
```
```python
return
```
```
请注意，在生成器迭代过程的结尾有一个简单的return语句，但并没有返回任何数据。从内部来说，这将抛出一个StopIteration异常。
下一个例子来自Groupon的面试题。在这里我们首先使用两个生成器来实现[Bernoulli过程](http://en.wikipedia.org/wiki/Bernoulli_process)，这个过程是一个随机布尔值的无限序列，True的概率是p而False的概率为q=1-p。随后实现一个[von
 Neumann extractor](http://en.wikipedia.org/wiki/Randomness_extractor)，它从Bernoulli process获取输入(0<p<1)，并且返回另一个Bernoulli process(p=0.5)。
```
```python
import
```
```python
random
```
```python
def
```
```python
bernoulli_process(p):
```
```python
```
```python
if
```
```python
p
 >
```
```python
1.0
```
```python
or
```
```python
p
 <
```
```python
0.0
```
```python
:
```
```python
```
```python
raise
```
```python
ValueError(
```
```python
"p
 should be between 0.0 and 1.0."
```
```python
)
```
```python
```
```python
while
```
```python
True
```
```python
:
```
```python
```
```python
yield
```
```python
random.random()
 < p
```
```python
def
```
```python
von_neumann_extractor(process):
```
```python
```
```python
while
```
```python
True
```
```python
:
```
```python
```
```python
x,
 y
```
```python
=
```
```python
process.
```
```python
next
```
```python
(),
 process.
```
```python
next
```
```python
()
```
```python
```
```python
if
```
```python
x
 !
```
```python
=
```
```python
y:
```
```python
```
```python
yield
```
```python
x
```
```
最后，生成器是一种生成随机动态系统的很有利的工具。下面这个例子将演示著名的[帐篷映射(tent map)](http://en.wikipedia.org/wiki/Tent_map)动态系统是如何通过生成器实现的。(插句题外话，看看数值的不准确性是如何开始关联变化并呈指数式增长的，这是一个如帐篷映射这样的动态系统的关键特征)。
```
```python
>>>
```
```python
def
```
```python
tent_map(mu,
 x0):
```
```python
...   
 x
```
```python
=
```
```python
x0
```
```python
...
```
```python
while
```
```python
True
```
```python
:
```
```python
...
```
```python
yield
```
```python
x
```
```python
...       
 x
```
```python
=
```
```python
mu
```
```python
*
```
```python
min
```
```python
(x,
```
```python
1.0
```
```python
-
```
```python
x)
```
```python
...
```
```python
>>>
```
```python
>>>
 t
```
```python
=
```
```python
tent_map(
```
```python
2.0
```
```python
,
```
```python
0.1
```
```python
)
```
```python
>>>
```
```python
for
```
```python
__
```
```python
in
```
```python
xrange
```
```python
(
```
```python
30
```
```python
):
```
```python
...
```
```python
print
```
```python
t.
```
```python
next
```
```python
()
```
```python
...
```
```python
0.1
```
```python
0.2
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.8
```
```python
0.4
```
```python
0.799999999999
```
```python
0.400000000001
```
```python
0.800000000003
```
```python
0.399999999994
```
```python
0.799999999988
```
```python
0.400000000023
```
```python
0.800000000047
```
```python
0.399999999907
```
```python
0.799999999814
```
```python
0.400000000373
```
```python
0.800000000745
```
```python
0.39999999851
```
```python
0.79999999702
```
```
另一个相似的例子是[Collatz](http://en.wikipedia.org/wiki/Collatz_conjecture)序列。
```
```python
def
```
```python
collatz(n):
```
```python
```
```python
yield
```
```python
n
```
```python
```
```python
while
```
```python
n
 !
```
```python
=
```
```python
1
```
```python
:
```
```python
```
```python
n
```
```python
=
```
```python
n
```
```python
/
```
```python
2
```
```python
if
```
```python
n
```
```python
%
```
```python
2
```
```python
=
```
```python
=
```
```python
0
```
```python
else
```
```python
3
```
```python
*
```
```python
n
```
```python
+
```
```python
1
```
```python
```
```python
yield
```
```python
n
```
```
请注意在这个例子中，我们仍旧没有手动抛出StopIteration异常，因为它会在控制流到达函数结尾的时候自动抛出。
请看用法：
```
```python
>>>
```
```python
#
 If the Collatz conjecture is true then list(collatz(n)) for any n will
```
```python
...
```
```python
#
 always terminate (though your machine might run out of memory first!)
```
```python
>>>
```
```python
list
```
```python
(collatz(
```
```python
7
```
```python
))
```
```python
[
```
```python
7
```
```python
,
```
```python
22
```
```python
,
```
```python
11
```
```python
,
```
```python
34
```
```python
,
```
```python
17
```
```python
,
```
```python
52
```
```python
,
```
```python
26
```
```python
,
```
```python
13
```
```python
,
```
```python
40
```
```python
,
```
```python
20
```
```python
,
```
```python
10
```
```python
,
```
```python
5
```
```python
,
```
```python
16
```
```python
,
```
```python
8
```
```python
,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
]
```
```python
>>>
```
```python
list
```
```python
(collatz(
```
```python
13
```
```python
))
```
```python
[
```
```python
13
```
```python
,
```
```python
40
```
```python
,
```
```python
20
```
```python
,
```
```python
10
```
```python
,
```
```python
5
```
```python
,
```
```python
16
```
```python
,
```
```python
8
```
```python
,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
]
```
```python
>>>
```
```python
list
```
```python
(collatz(
```
```python
17
```
```python
))
```
```python
[
```
```python
17
```
```python
,
```
```python
52
```
```python
,
```
```python
26
```
```python
,
```
```python
13
```
```python
,
```
```python
40
```
```python
,
```
```python
20
```
```python
,
```
```python
10
```
```python
,
```
```python
5
```
```python
,
```
```python
16
```
```python
,
```
```python
8
```
```python
,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
]
```
```python
>>>
```
```python
list
```
```python
(collatz(
```
```python
19
```
```python
))
```
```python
[
```
```python
19
```
```python
,
```
```python
58
```
```python
,
```
```python
29
```
```python
,
```
```python
88
```
```python
,
```
```python
44
```
```python
,
```
```python
22
```
```python
,
```
```python
11
```
```python
,
```
```python
34
```
```python
,
```
```python
17
```
```python
,
```
```python
52
```
```python
,
```
```python
26
```
```python
,
```
```python
13
```
```python
,
```
```python
40
```
```python
,
```
```python
20
```
```python
,
```
```python
10
```
```python
,
```
```python
5
```
```python
,
```
```python
16
```
```python
,
```
```python
8
```
```python
,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
]
```
```
## Recursive Generators
生成器可以像其它函数那样递归。让我们来看一个自实现的简单版本的itertools.permutations，这个生成器通过给定一个item列表生成其全排列(在实际中请使用itertools.permutations，那个实现更快)。基本思想很简单：对列表中的每一个元素，我们通过将它与列表第一个元素交换将其放置到第一的位置上去，而后重新递归排列列表的剩余部分。
```
```python
def
```
```python
permutations(items):
```
```python
```
```python
if
```
```python
len
```
```python
(items)
```
```python
=
```
```python
=
```
```python
0
```
```python
:
```
```python
```
```python
yield
```
```python
[]
```
```python
```
```python
else
```
```python
:
```
```python
```
```python
pi
```
```python
=
```
```python
items[:]
```
```python
```
```python
for
```
```python
i
```
```python
in
```
```python
xrange
```
```python
(
```
```python
len
```
```python
(pi)):
```
```python
```
```python
pi[
```
```python
0
```
```python
],
 pi[i]
```
```python
=
```
```python
pi[i],
 pi[
```
```python
0
```
```python
]
```
```python
```
```python
for
```
```python
p
```
```python
in
```
```python
permutations(pi[
```
```python
1
```
```python
:]):
```
```python
```
```python
yield
```
```python
[pi[
```
```python
0
```
```python
]]
```
```python
+
```
```python
p
```
```
```
```python
>>>
```
```python
for
```
```python
p
```
```python
in
```
```python
permutations([
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
]):
```
```python
...
```
```python
print
```
```python
p
```
```python
...
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
]
```
```python
[
```
```python
1
```
```python
,
```
```python
3
```
```python
,
```
```python
2
```
```python
]
```
```python
[
```
```python
2
```
```python
,
```
```python
1
```
```python
,
```
```python
3
```
```python
]
```
```python
[
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
1
```
```python
]
```
```python
[
```
```python
3
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
]
```
```python
[
```
```python
3
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
]
```
```
## Generator Expressions
生成器表达式可以让你通过一个简单的，单行声明定义生成器。这跟Python中的列表推导式非常类似，举个例子，下面的代码将定义一个生成器迭代所有的完全平方。注意生成器表达式的返回结果是一个生成器类型对象，它实现了next和__iter__两个方法。
```
```python
>>>
 g
```
```python
=
```
```python
(x
```
```python
*
```
```python
*
```
```python
2
```
```python
for
```
```python
x
```
```python
in
```
```python
itertools.count(
```
```python
1
```
```python
))
```
```python
>>>
 g
```
```python
<generator
```
```python
object
```
```python
<genexpr>
 at
```
```python
0x1029a5fa0
```
```python
>
```
```python
>>>
```
```python
next
```
```python
(g)
```
```python
1
```
```python
>>>
```
```python
next
```
```python
(g)
```
```python
4
```
```python
>>>
```
```python
iter
```
```python
(g)
```
```python
<generator
```
```python
object
```
```python
<genexpr>
 at
```
```python
0x1029a5fa0
```
```python
>
```
```python
>>>
```
```python
iter
```
```python
(g)
```
```python
is
```
```python
g
```
```python
True
```
```python
>>>
 [g.
```
```python
next
```
```python
()
```
```python
for
```
```python
__
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
)]
```
```python
[
```
```python
9
```
```python
,
```
```python
16
```
```python
,
```
```python
25
```
```python
,
```
```python
36
```
```python
,
```
```python
49
```
```python
,
```
```python
64
```
```python
,
```
```python
81
```
```python
,
```
```python
100
```
```python
,
```
```python
121
```
```python
,
```
```python
144
```
```python
]
```
```
同样可以使用生成器表达式实现Bernoulli过程，在这个例子中p=0.4。如果一个生成器表达式需要另一个迭代器作为循环指示器，并且这个生辰器表达式使用在无限序列上的，那么itertools.count将是一个很好的选择。若非如此，xrange将是一个不错的选择。
```
```python
>>>
 g
```
```python
=
```
```python
(random.random()
 <
```
```python
0.4
```
```python
for
```
```python
__
```
```python
in
```
```python
itertools.count())
```
```python
>>>
 [g.
```
```python
next
```
```python
()
```
```python
for
```
```python
__
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
)]
```
```python
[
```
```python
False
```
```python
,
```
```python
False
```
```python
,
```
```python
False
```
```python
,
```
```python
True
```
```python
,
```
```python
True
```
```python
,
```
```python
False
```
```python
,
```
```python
True
```
```python
,
```
```python
False
```
```python
,
```
```python
False
```
```python
,
```
```python
True
```
```python
]
```
```
正如前面提到的，生成器表达式能够用在任何需要迭代器作为参数的地方。举个例子，我们可以通过如下代码计算前十个全平方数的累加和：
```
```python
>>>
```
```python
sum
```
```python
(x
```
```python
*
```
```python
*
```
```python
2
```
```python
for
```
```python
x
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
))
```
```python
285
```
```
更多生成器表达式的例子将在下一节给出。
## itertools模块
itertools模块提供了一系列迭代器能够帮助用户轻松地使用排列、组合、笛卡尔积或其他组合结构。
在开始下面的部分之前，注意到上面给出的所有代码都是未经优化的，在这里只是充当一个示例的作用。在实际使用中，你应该避免自己去实现排列组合除非你能够有更好的想法，因为枚举的数量可是按照指数级增加的。
让我们先从一些有趣的用例开始。第一个例子来看如何写一个常用的模式：循环遍历一个三维数组的所有下标元素，并且循环遍历满足0≤i<j<k≤n条件的所有下标。
```
```python
from
```
```python
itertools
```
```python
import
```
```python
combinations,
 product
```
```python
n
```
```python
=
```
```python
4
```
```python
d
```
```python
=
```
```python
3
```
```python
def
```
```python
visit(
```
```python
*
```
```python
indices):
```
```python
```
```python
print
```
```python
indices
```
```python
#
 Loop through all possible indices of a 3-D array
```
```python
for
```
```python
i
```
```python
in
```
```python
xrange
```
```python
(n):
```
```python
```
```python
for
```
```python
j
```
```python
in
```
```python
xrange
```
```python
(n):
```
```python
```
```python
for
```
```python
k
```
```python
in
```
```python
xrange
```
```python
(n):
```
```python
```
```python
visit(i,
 j, k)
```
```python
#
 Equivalent using itertools.product
```
```python
for
```
```python
indices
```
```python
in
```
```python
product(
```
```python
*
```
```python
([
```
```python
xrange
```
```python
(n)]
```
```python
*
```
```python
d)):
```
```python
```
```python
visit(
```
```python
*
```
```python
indices)
```
```python
#
 Now loop through all indices 0 <= i < j < k <= n
```
```python
for
```
```python
i
```
```python
in
```
```python
xrange
```
```python
(n):
```
```python
```
```python
for
```
```python
j
```
```python
in
```
```python
xrange
```
```python
(i
```
```python
+
```
```python
1
```
```python
,
 n):
```
```python
```
```python
for
```
```python
k
```
```python
in
```
```python
xrange
```
```python
(j
```
```python
+
```
```python
1
```
```python
,
 n):
```
```python
```
```python
visit(i,
 j, k)
```
```python
#
 And equivalent using itertools.combinations
```
```python
for
```
```python
indices
```
```python
in
```
```python
combinations(
```
```python
xrange
```
```python
(n),
 d):
```
```python
```
```python
visit(
```
```python
*
```
```python
indices)
```
```
使用itertools模块提供的枚举器有两个好处：代码能够在单行内完成，并且很容易扩展到更高维度。我并未比较for方法和itertools两种方法的性能，也许跟n有很大关系。如果你想的话请自行测试评判。
第二个例子，来做一些有趣的数学题：使用生成器表达式、itertools.combinations以及itertools.permutations来计算排列的逆序数，并且计算一个列表全排列逆序数之和。如[OEIS
 A001809](https://oeis.org/A001809)所示，求和的结果趋近于n!n(n-1)/4。在实际使用中直接通过这公式计算要比上面的代码更高效，不过我写这个例子是为了练习itertools枚举器的使用。
```
```python
import
```
```python
itertools
```
```python
import
```
```python
math
```
```python
def
```
```python
inversion_number(A):
```
```python
```
```python
"""Return
 the number of inversions in list A."""
```
```python
```
```python
return
```
```python
sum
```
```python
(
```
```python
1
```
```python
for
```
```python
x,
 y
```
```python
in
```
```python
itertools.combinations(
```
```python
xrange
```
```python
(
```
```python
len
```
```python
(A)),
```
```python
2
```
```python
)
```
```python
if
```
```python
A[x]
 > A[y])
```
```python
def
```
```python
total_inversions(n):
```
```python
```
```python
"""Return
 total number of inversions in permutations of n."""
```
```python
```
```python
return
```
```python
sum
```
```python
(inversion_number(A)
```
```python
for
```
```python
A
```
```python
in
```
```python
itertools.permutations(
```
```python
xrange
```
```python
(n)))
```
```
用法如下：
```
```python
>>>
 [total_inversions(n)
```
```python
for
```
```python
n
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
)]
```
```python
[
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
9
```
```python
,
```
```python
72
```
```python
,
```
```python
600
```
```python
,
```
```python
5400
```
```python
,
```
```python
52920
```
```python
,
```
```python
564480
```
```python
,
```
```python
6531840
```
```python
]
```
```python
>>>
 [math.factorial(n)
```
```python
*
```
```python
n
```
```python
*
```
```python
(n
```
```python
-
```
```python
1
```
```python
)
```
```python
/
```
```python
4
```
```python
for
```
```python
n
```
```python
in
```
```python
xrange
```
```python
(
```
```python
10
```
```python
)]
```
```python
[
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
9
```
```python
,
```
```python
72
```
```python
,
```
```python
600
```
```python
,
```
```python
5400
```
```python
,
```
```python
52920
```
```python
,
```
```python
564480
```
```python
,
```
```python
6531840
```
```python
]
```
```
第三个例子，通过brute-force counting方法计算recontres number。recontres number的定义[在此](http://en.wikipedia.org/wiki/Rencontres_numbers)。首先，我们写了一个函数在一个求和过程中使用生成器表达式去计算排列中fixed
 points出现的个数。然后在求和中使用itertools.permutations和其他生成器表达式计算包含n个数并且有k个fixed points的排列的总数。然后得到结果。当然了，这个实现方法是效率低下的，不提倡在实际应用中使用。再次重申，这只是为了掩饰生成器表达式以及itertools相关函数使用方法的示例。
```
```python
def
```
```python
count_fixed_points(p):
```
```python
```
```python
"""Return
 the number of fixed points of p as a permutation."""
```
```python
```
```python
return
```
```python
sum
```
```python
(
```
```python
1
```
```python
for
```
```python
x
```
```python
in
```
```python
p
```
```python
if
```
```python
p[x]
```
```python
=
```
```python
=
```
```python
x)
```
```python
def
```
```python
count_partial_derangements(n,
 k):
```
```python
```
```python
"""Returns
 the number of permutations of n with k fixed points."""
```
```python
```
```python
return
```
```python
sum
```
```python
(
```
```python
1
```
```python
for
```
```python
p
```
```python
in
```
```python
itertools.permutations(
```
```python
xrange
```
```python
(n))
```
```python
if
```
```python
count_fixed_points(p)
```
```python
=
```
```python
=
```
```python
k)
```
```
用法：
```
```python
#
 Usage:
```
```python
>>>
 [count_partial_derangements(
```
```python
6
```
```python
,
 i)
```
```python
for
```
```python
i
```
```python
in
```
```python
xrange
```
```python
(
```
```python
7
```
```python
)]
```
```python
[
```
```python
265
```
```python
,
```
```python
264
```
```python
,
```
```python
135
```
```python
,
```
```python
40
```
```python
,
```
```python
15
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
]
```
```
## 扩展阅读
[http://linuxgazette.net/100/pramode.html](http://linuxgazette.net/100/pramode.html)
[http://www.dabeaz.com/generators/](http://www.dabeaz.com/generators/)
## 致谢
谢谢reddit用户jms_nh对本文的修改建议。
