# 深入浅出 Python 装饰器：16 步轻松搞定 Python 装饰器 - 宇宙浪子的专栏 - CSDN博客
2015年12月21日 15:22:49[_宇宙浪子_](https://me.csdn.net/bluehawksky)阅读数：6104
目录[-]
- [1. 函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_1)
- [2. 作用域](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_2)
- [3. 变量解析规则](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_3)
- [4. 变量生存周期](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_4)
- [5. 函数参数](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_5)
- [6. 嵌套函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_6)
- [7. 函数是python世界里的一级类对象](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_7)
- [8. 闭包](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_8)
- [9. 装饰器](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_9)
- [10. 使用 @ 标识符将装饰器应用到函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_10)
- [11. *args and **kwargs](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_11)
- [12. 更通用的装饰器](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_12)
- [13. 带参数的装饰器：](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_13)
- [14. 装饰器的副作用](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_14)
- [15. class式的 Decorator](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_15)
- [16. 一些decorator的示例](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_16)
- [16.1 给函数调用做缓存](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_17)
- [16.2 Profiler的例子](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_18)
- [16.3 注册回调函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_19)
- [16.4 给函数打日志](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_20)
- [16.5 一个MySQL的Decorator](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_21)
- [16.6 线程异步](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_22)
- [16.7 超时函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_23)
- [16.8 Trace函数](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_24)
- [16.9 单例模式](http://my.oschina.net/leejun2005/blog/477614#OSC_h2_25)
- [17. 小结](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_26)
- [18. Refer：](http://my.oschina.net/leejun2005/blog/477614#OSC_h1_27)
Python的装饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去。但是OO的Decorator简直就是一场恶梦，不信你就去看看wikipedia上的词条（[Decorator
 Pattern](http://en.wikipedia.org/wiki/Decorator_pattern)）里的UML图和那些代码，这就是我在《 [从面向对象的设计模式看软件设计](http://coolshell.cn/articles/8961.html)》“餐后甜点”一节中说的，OO鼓励了——“厚重地胶合和复杂层次”，也是《 [如此理解面向对象编程](http://coolshell.cn/articles/8745.html)》中所说的“OO的狂热者们非常害怕处理数据”，Decorator
 Pattern搞出来的代码简直就是OO的反面教程。
Python 的 Decorator在使用上和Java/C#的Annotation很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太TMD的复杂了，你要玩它，你需要了解一堆Annotation的类库文档，让人感觉就是在学另外一门语言。
而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。如果你看过本站的《[函数式编程](http://coolshell.cn/articles/10822.html)》，你一定会为函数式编程的那种“描述你想干什么，而不是描述你要怎么去实现”的编程方式感到畅快。（如果你不了解函数式编程，那在读本文之前，还请你移步去看看《[函数式编程](http://coolshell.cn/articles/10822.html)》）
 好了。
作为一名教python的老师，我发现学生们基本上一开始很难搞定python的装饰器，也许因为装饰器确实很难懂。搞定装饰器需要你了解一些函数式编程的概念，当然还有理解在python中定义和调用函数相关语法的一些特点。
我没法让装饰器变得简单，但是通过一步步的剖析，我也许能够让你在理解装饰器的时候更自信一点。因为装饰器很复杂，这篇文章将会很长（自己都说很长，还敢这么多废话blablabla…前戏就不继续翻译直接省略了)
# 1. 函数
在python中，函数通过def关键字、函数名和可选的参数列表定义。通过return关键字返回值。我们举例来说明如何定义和调用一个简单的函数：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
foo():
```
```python
```
```python
return
```
```python
1
```
```python
foo()
```
```python
1
```
```
方法体（当然多行也是一样的）是必须的，通过缩进来表示，在方法名的后面加上双括号()就能够调用函数
# 2. 作用域
在python中，函数会创建一个新的作用域。python开发者可能会说函数有自己的命名空间，差不多一个意思。这意味着在函数内部碰到一个变量的时候函数会优先在自己的命名空间里面去寻找。让我们写一个简单的函数看一下 本地作用域 和 全局作用域有什么不同：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
a_string
```
```python
=
```
```python
"This is a global variable"
```
```python
def
```
```python
foo():
```
```python
```
```python
print
```
```python
locals
```
```python
()
```
```python
print
```
```python
globals
```
```python
()
```
```python
{...,
```
```python
'a_string'
```
```python
:
```
```python
'This is a global variable'
```
```python
}
```
```python
foo()
```
```python
# 2
```
```python
{}
```
```
内置的函数globals返回一个包含所有python解释器知道的变量名称的字典（为了干净和洗的白白的，我省略了python自行创建的一些变量）。在#2我调用了函数 foo 把函数内部本地作用域里面的内容打印出来。我们能够看到，函数foo有自己独立的命名空间，虽然暂时命名空间里面什么都还没有。
# 3. 变量解析规则
当然这并不是说我们在函数里面就不能访问外面的全局变量。在python的作用域规则里面，创建变量一定会一定会在当前作用域里创建一个变量，但是访问或者修改变量时会先在当前作用域查找变量，没有找到匹配变量的话会依次向上在闭合的作用域里面进行查看找。所以如果我们修改函数foo的实现让它打印全局的作用域里的变量也是可以的：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
a_string
```
```python
=
```
```python
"This is a global variable"
```
```python
def
```
```python
foo():
```
```python
```
```python
print
```
```python
a_string
```
```python
# 1
```
```python
foo()
```
```python
This
```
```python
is
```
```python
a
```
```python
global
```
```python
variable
```
```
在#1处，python解释器会尝试查找变量a_string，当然在函数的本地作用域里面是找不到的，所以接着会去上层的作用域里面去查找。
但是另一方面，假如我们在函数内部给全局变量赋值，结果却和我们想的不一样：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
a_string
```
```python
=
```
```python
"This is a global variable"
```
```python
def
```
```python
foo():
```
```python
```
```python
a_string
```
```python
=
```
```python
"test"
```
```python
# 1
```
```python
```
```python
print
```
```python
locals
```
```python
()
```
```python
foo()
```
```python
{
```
```python
'a_string'
```
```python
:
```
```python
'test'
```
```python
}
```
```python
a_string
```
```python
# 2
```
```python
'This is a global variable'
```
```
我们能够看到，全局变量能够被访问到（如果是可变数据类型(像list,dict这些)甚至能够被更改）但是赋值不行。在函数内部的#1处，我们实际上新创建了一个局部变量，隐藏全局作用域中的同名变量。我们可以通过打印出局部命名空间中的内容得出这个结论。我们也能看到在#2处打印出来的变量a_string的值并没有改变。
# 4. 变量生存周期
值得注意的一个点是，变量不仅是生存在一个个的命名空间内，他们都有自己的生存周期，请看下面这个例子：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
foo():
```
```python
```
```python
x
```
```python
=
```
```python
1
```
```python
foo()
```
```python
print
```
```python
x
```
```python
# 1
```
```python
#Traceback (most recent call last):
```
```python
#NameError: name 'x' is not defined
```
```
#1处发生的错误不仅仅是因为作用域规则导致的（尽管这是抛出了NameError的错误的原因）它还和python以及其它很多编程语言中函数调用实现的机制有关。在这个地方这个执行时间点并没有什么有效的语法让我们能够获取变量x的值，因为它这个时候压根不存在！函数foo的命名空间随着函数调用开始而开始，结束而销毁。
# 5. 函数参数
python允许我们向函数传递参数，参数会变成本地变量存在于函数内部。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
foo(x):
```
```python
```
```python
print
```
```python
locals
```
```python
()
```
```python
foo(
```
```python
1
```
```python
)
```
```python
{
```
```python
'x'
```
```python
:
```
```python
1
```
```python
}
```
```
在Python里有很多的方式来定义和传递参数，完整版可以查看 python官方文档。我们这里简略的说明一下：函数的参数可以是必须的位置参数或者是可选的命名，默认参数。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
foo(x, y
```
```python
=
```
```python
0
```
```python
):
```
```python
# 1
```
```python
```
```python
return
```
```python
x
```
```python
-
```
```python
y
```
```python
foo(
```
```python
3
```
```python
,
```
```python
1
```
```python
)
```
```python
# 2
```
```python
2
```
```python
foo(
```
```python
3
```
```python
)
```
```python
# 3
```
```python
3
```
```python
foo()
```
```python
# 4
```
```python
#Traceback (most recent call last):
```
```python
#TypeError: foo() takes at least 1 argument (0 given)
```
```python
foo(y
```
```python
=
```
```python
1
```
```python
, x
```
```python
=
```
```python
3
```
```python
)
```
```python
# 5
```
```python
2
```
```
在#1处我们定义了函数foo,它有一个位置参数x和一个命名参数y。在#2处我们能够通过常规的方式来调用函数，尽管有一个命名参数，但参数依然可以通过位置传递给函数。在调用函数的时候，对于命名参数y我们也可以完全不管就像#3处所示的一样。如果命名参数没有接收到任何值的话，python会自动使用声明的默认值也就是0。需要注意的是我们不能省略第一个位置参数x,
 否则的话就会像#4处所示发生错误。
目前还算简洁清晰吧， 但是接下来可能会有点令人困惑。python支持函数调用时的命名参数（个人觉得应该是命名实参）。看看#5处的函数调用，我们传递的是两个命名实参，这个时候因为有名称标识，参数传递的顺序也就不用在意了。
当然相反的情况也是正确的：函数的第二个形参是y，但是我们通过位置的方式传递值给它。在#2处的函数调用foo(3,1)，我们把3传递给了第一个参数，把1传递给了第二个参数，尽管第二个参数是一个命名参数。
桑不起，感觉用了好大一段才说清楚这么一个简单的概念：函数的参数可以有名称和位置。这意味着在函数的定义和调用的时候会稍稍在理解上有点儿不同。我们可以给只定义了位置参数的函数传递命名参数（实参），反之亦然！如果觉得不够可以查看官方文档
# 6. 嵌套函数
Python允许创建嵌套函数。这意味着我们可以在函数里面定义函数而且现有的作用域和变量生存周期依旧适用。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
outer():
```
```python
```
```python
x
```
```python
=
```
```python
1
```
```python
```
```python
def
```
```python
inner():
```
```python
```
```python
print
```
```python
x
```
```python
# 1
```
```python
```
```python
return
```
```python
inner()
```
```python
# 2
```
```python
outer()
```
```python
1
```
```
这个例子有一点儿复杂，但是看起来也还行。想一想在#1发生了什么：python解释器需找一个叫x的本地变量，查找失败之后会继续在上层的作用域里面寻找，这个上层的作用域定义在另外一个函数里面。对函数outer来说，变量x是一个本地变量，但是如先前提到的一样，函数inner可以访问封闭的作用域（至少可以读和修改）。在#2处，我们调用函数inner，非常重要的一点是，inner也仅仅是一个遵循python变量解析规则的变量名，python解释器会优先在outer的作用域里面对变量名inner查找匹配的变量.
# 7. 函数是python世界里的一级类对象
显而易见，在python里函数和其他东西一样都是对象。（此处应该大声歌唱）啊！包含变量的函数，你也并不是那么特殊！
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
issubclass
```
```python
(
```
```python
int
```
```python
,
```
```python
object
```
```python
)
```
```python
# all objects in Python inherit from a common baseclass
```
```python
#True
```
```python
def
```
```python
foo():
```
```python
```
```python
pass
```
```python
foo.__class__
```
```python
# 1
```
```python
#<type 'function'>
```
```python
issubclass
```
```python
(foo.__class__,
```
```python
object
```
```python
)
```
```python
#True
```
```
你也许从没有想过，你定义的函数居然会有属性。没办法，函数在python里面就是对象，和其他的东西一样，也许这样描述会太学院派太官方了点：在python里，函数只是一些普通的值而已和其他的值一毛一样。这就是说你尅一把函数想参数一样传递给其他的函数或者说从函数了里面返回函数！如果你从来没有这么想过，那看看下面这个例子：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
add(x, y):
```
```python
```
```python
return
```
```python
x
```
```python
+
```
```python
y
```
```python
def
```
```python
sub(x, y):
```
```python
```
```python
return
```
```python
x
```
```python
-
```
```python
y
```
```python
def
```
```python
apply
```
```python
(func, x, y):
```
```python
# 1
```
```python
```
```python
return
```
```python
func(x, y)
```
```python
# 2
```
```python
apply
```
```python
(add,
```
```python
2
```
```python
,
```
```python
1
```
```python
)
```
```python
# 3
```
```python
3
```
```python
apply
```
```python
(sub,
```
```python
2
```
```python
,
```
```python
1
```
```python
)
```
```python
1
```
```
这个例子对你来说应该不会很奇怪。add和sub是非常普通的两个python函数，接受两个值，返回一个计算后的结果值。在#1处你们能看到准备接收一个函数的变量只是一个普通的变量而已，和其他变量一样。在#2处我们调用传进来的函数：“()代表着调用的操作并且调用变量包含的值。在#3处，你们也能看到传递函数并没有什么特殊的语法。”
 函数的名称只是很其他变量一样的表标识符而已。
你们也许看到过这样的行为：“python把频繁要用的操作变成函数作为参数进行使用，像通过传递一个函数给内置排序函数的key参数从而来自定义排序规则。那把函数当做返回值回事这样的情况呢：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
outer():
```
```python
```
```python
def
```
```python
inner():
```
```python
```
```python
print
```
```python
"Inside inner"
```
```python
```
```python
return
```
```python
inner
```
```python
# 1
```
```python
foo
```
```python
=
```
```python
outer()
```
```python
#2
```
```python
foo
```
```python
#<function inner at 0x...>
```
```python
foo()
```
```python
#Inside inner
```
```
这个例子看起来也许会更加的奇怪。在#1处我把恰好是函数标识符的变量inner作为返回值返回出来。这并没有什么特殊的语法：”把函数inner返回出来，否则它根本不可能会被调用到。“还记得变量的生存周期吗？每次函数outer被调用的时候，函数inner都会被重新定义，如果它不被当做变量返回的话，每次执行过后它将不复存在。
在#2处我们捕获住返回值 – 函数inner，将它存在一个新的变量foo里。我们能够看到，当对变量foo进行求值，它确实包含函数inner，而且我们能够对他进行调用。初次看起来可能会觉得有点奇怪，但是理解起来并不困难是吧。坚持住，因为奇怪的转折马上就要来了
# 8. 闭包
我们先不急着定义什么是闭包，先来看看一段代码，仅仅是把上一个例子简单的调整了一下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
outer():
```
```python
```
```python
x
```
```python
=
```
```python
1
```
```python
```
```python
def
```
```python
inner():
```
```python
```
```python
print
```
```python
x
```
```python
# 1
```
```python
```
```python
return
```
```python
inner
```
```python
foo
```
```python
=
```
```python
outer()
```
```python
foo.func_closure
```
```python
#(<cell at 0x...: int object at 0x...>,)
```
```
在上一个例子中我们了解到，inner作为一个函数被outer返回，保存在一个变量foo，并且我们能够对它进行调用foo()。不过它会正常的运行吗？我们先来看看作用域规则。
所有的东西都在python的作用域规则下进行工作：“x是函数outer里的一个局部变量。当函数inner在#1处打印x的时候，python解释器会在inner内部查找相应的变量，当然会找不到，所以接着会到封闭作用域里面查找，并且会找到匹配。
但是从变量的生存周期来看，该怎么理解呢？我们的变量x是函数outer的一个本地变量，这意味着只有当函数outer正在运行的时候才会存在。根据我们已知的python运行模式，我们没法在函数outer返回之后继续调用函数inner，在函数inner被调用的时候，变量x早已不复存在，可能会发生一个运行时错误。
万万没想到，返回的函数inner居然能够正常工作。Python支持一个叫做函数闭包的特性，用人话来讲就是，嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间。这能够通过查看函数的func_closure属性得出结论，这个属性里面包含封闭作用域里面的值（只会包含被捕捉到的值，比如x，如果在outer里面还定义了其他的值，封闭作用域里面是不会有的)
记住，每次函数outer被调用的时候，函数inner都会被重新定义。现在变量x的值不会变化，所以每次返回的函数inner会是同样的逻辑，假如我们稍微改动一下呢？
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
outer(x):
```
```python
```
```python
def
```
```python
inner():
```
```python
```
```python
print
```
```python
x
```
```python
# 1
```
```python
```
```python
return
```
```python
inner
```
```python
print1
```
```python
=
```
```python
outer(
```
```python
1
```
```python
)
```
```python
print2
```
```python
=
```
```python
outer(
```
```python
2
```
```python
)
```
```python
print1()
```
```python
1
```
```python
print2()
```
```python
2
```
```
从这个例子中你能够看到闭包 – 被函数记住的封闭作用域 – 能够被用来创建自定义的函数，本质上来说是一个硬编码的参数。事实上我们并不是传递参数1或者2给函数inner，我们实际上是创建了能够打印各种数字的各种自定义版本。
闭包单独拿出来就是一个非常强大的功能， 在某些方面，你也许会把它当做一个类似于面向对象的技术：outer像是给inner服务的构造器，x像一个私有变量。使用闭包的方式也有很多：你如果熟悉python内置排序方法的参数key，你说不定已经写过一个lambda方法在排序一个列表的列表的时候基于第二个元素而不是第一个。现在你说不定也可以写一个itemgetter方法，接收一个索引值来返回一个完美的函数，传递给排序函数的参数key。
不过，我们现在不会用闭包做这么low的事(⊙o⊙)…！相反，让我们再爽一次，写一个高大上的装饰器!
# 9. 装饰器
装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数。我们一步步从简到繁来瞅瞅：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
outer(some_func):
```
```python
```
```python
def
```
```python
inner():
```
```python
```
```python
print
```
```python
"before some_func"
```
```python
```
```python
ret
```
```python
=
```
```python
some_func()
```
```python
# 1
```
```python
```
```python
return
```
```python
ret
```
```python
+
```
```python
1
```
```python
```
```python
return
```
```python
inner
```
```python
def
```
```python
foo():
```
```python
```
```python
return
```
```python
1
```
```python
decorated
```
```python
=
```
```python
outer(foo)
```
```python
# 2
```
```python
decorated()
```
```python
#before some_func
```
```python
#2
```
```
仔细看看上面这个装饰器的例子。们定义了一个函数outer，它只有一个some_func的参数，在他里面我们定义了一个嵌套的函数inner。inner会打印一串字符串，然后调用some_func，在#1处得到它的返回值。在outer每次调用的时候some_func的值可能会不一样，但是不管some_func的之如何，我们都会调用它。最后，inner返回some_func()
 + 1的值 – 我们通过调用在#2处存储在变量decorated里面的函数能够看到被打印出来的字符串以及返回值2，而不是期望中调用函数foo得到的返回值1。
我们可以认为变量decorated是函数foo的一个装饰版本，一个加强版本。事实上如果打算写一个有用的装饰器的话，我们可能会想愿意用装饰版本完全取代原先的函数foo，这样我们总是会得到我们的”加强版“foo。想要达到这个效果，完全不需要学习新的语法，简单地赋值给变量foo就行了：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
foo
```
```python
=
```
```python
outer(foo)
```
```python
foo
```
```python
# doctest: +ELLIPSIS
```
```python
#<function inner at 0x...>
```
```
现在，任何怎么调用都不会牵扯到原先的函数foo，都会得到新的装饰版本的foo。
假设有如下函数：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
now():
```
```python
```
```python
print
```
```python
'2013-12-25'
```
```python
f
```
```python
=
```
```python
now
```
```python
f()
```
```python
#2013-12-25
```
```
现在假设我们要增强`now()`函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改`now()`函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
log(func):
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw):
```
```python
```
```python
print
```
```python
'call %s():'
```
```python
%
```
```python
func.__name__
```
```python
```
```python
return
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw)
```
```python
```
```python
return
```
```python
wrapper
```
```
观察上面的`log`，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。
# 10. 使用 @ 标识符将装饰器应用到函数
Python2.4支持使用标识符@将装饰器应用在函数上，只需要在函数的定义前加上@和装饰器的名称。在上一节的例子里我们是将原本的方法用装饰后的方法代替:
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
add
```
```python
=
```
```python
wrapper(add)
```
```
这种方式能够在任何时候对任意方法进行包装。但是如果我们自定义一个方法，我们可以使用@进行装饰：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@wrapper
```
```python
def
```
```python
add(a, b):
```
```python
```
```python
return
```
```python
Coordinate(a.x
```
```python
+
```
```python
b.x, a.y
```
```python
+
```
```python
b.y)
```
```
需要明白的是，这样的做法和先前简单的用包装方法替代原有方法是一模一样的， python只是加了一些语法糖让装饰的行为更加的直接明确和优雅一点。
多个decorator
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@decorator_one
```
```python
@decorator_two
```
```python
def
```
```python
func():
```
```python
```
```python
pass
```
```
相当于：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
func
```
```python
=
```
```python
decorator_one(decorator_two(func))
```
```
比如：带参数的decorator：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@decorator
```
```python
(arg1, arg2)
```
```python
def
```
```python
func():
```
```python
```
```python
pass
```
```
相当于：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
func
```
```python
=
```
```python
decorator(arg1,arg2)(func)
```
```
这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”。
# 11. *args and **kwargs
我们已经完成了一个有用的装饰器，但是由于硬编码的原因它只能应用在一类具体的方法上，这类方法接收两个参数，传递给闭包捕获的函数。如果我们想实现一个能够应用在任何方法上的装饰器要怎么做呢？再比如，如果我们要实现一个能应用在任何方法上的类似于计数器的装饰器，不需要改变原有方法的任何逻辑。这意味着装饰器能够接受拥有任何签名的函数作为自己的被装饰方法，同时能够用传递给它的参数对被装饰的方法进行调用。
非常巧合的是Python正好有支持这个特性的语法。可以阅读 Python Tutorial 获取更多的细节。当定义函数的时候使用了*，意味着那些通过位置传递的参数将会被放在带有*前缀的变量中， 所以：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
one(
```
```python
*
```
```python
args):
```
```python
```
```python
print
```
```python
args
```
```python
# 1
```
```python
one()
```
```python
#()
```
```python
one(
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
)
```
```python
#(1, 2, 3)
```
```python
def
```
```python
two(x, y,
```
```python
*
```
```python
args):
```
```python
# 2
```
```python
```
```python
print
```
```python
x, y, args
```
```python
two(
```
```python
'a'
```
```python
,
```
```python
'b'
```
```python
,
```
```python
'c'
```
```python
)
```
```python
#a b ('c',)
```
```
第一个函数one只是简单地讲任何传递过来的位置参数全部打印出来而已，你们能够看到，在代码#1处我们只是引用了函数内的变量args,
 *args仅仅只是用在函数定义的时候用来表示位置参数应该存储在变量args里面。Python允许我们制定一些参数并且通过args捕获其他所有剩余的未被捕捉的位置参数，就像#2处所示的那样。
*操作符在函数被调用的时候也能使用。意义基本是一样的。当调用一个函数的时候，一个用*标志的变量意思是变量里面的内容需要被提取出来然后当做位置参数被使用。同样的，来看个例子：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
add(x, y):
```
```python
```
```python
return
```
```python
x
```
```python
+
```
```python
y
```
```python
lst
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
]
```
```python
add(lst[
```
```python
0
```
```python
], lst[
```
```python
1
```
```python
])
```
```python
# 1
```
```python
3
```
```python
add(
```
```python
*
```
```python
lst)
```
```python
# 2
```
```python
3
```
```
#1处的代码和#2处的代码所做的事情其实是一样的，在#2处，python为我们所做的事其实也可以手动完成。这也不是什么坏事，*args要么是表示调用方法大的时候额外的参数可以从一个可迭代列表中取得，要么就是定义方法的时候标志这个方法能够接受任意的位置参数。
接下来提到的**会稍多更复杂一点，**代表着键值对的餐宿字典，和*所代表的意义相差无几，也很简单对不对：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
foo(
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
print
```
```python
kwargs
```
```python
foo()
```
```python
#{}
```
```python
foo(x
```
```python
=
```
```python
1
```
```python
, y
```
```python
=
```
```python
2
```
```python
)
```
```python
#{'y': 2, 'x': 1}
```
```
当我们定义一个函数的时候，我们能够用**kwargs来表明，所有未被捕获的关键字参数都应该存储在kwargs的字典中。如前所诉，args、kwargs并不是python语法的一部分，但在定义函数的时候，使用这样的变量名算是一个不成文的约定。和*一样，我们同样可以在定义或者调用函数的时候使用**。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
dct
```
```python
=
```
```python
{
```
```python
'x'
```
```python
:
```
```python
1
```
```python
,
```
```python
'y'
```
```python
:
```
```python
2
```
```python
}
```
```python
def
```
```python
bar(x, y):
```
```python
```
```python
return
```
```python
x
```
```python
+
```
```python
y
```
```python
bar(
```
```python
*
```
```python
*
```
```python
dct)
```
```python
#3
```
```
# 12. 更通用的装饰器
有了这招新的技能，我们随随便便就可以写一个能够记录下传递给函数参数的装饰器了。先来个简单地把日志输出到界面的例子：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
logger(func):
```
```python
```
```python
def
```
```python
inner(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
#1
```
```python
```
```python
print
```
```python
"Arguments were: %s, %s"
```
```python
%
```
```python
(args, kwargs)
```
```python
```
```python
return
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
#2
```
```python
```
```python
return
```
```python
inner
```
```
请注意我们的函数inner，它能够接受任意数量和类型的参数并把它们传递给被包装的方法，这让我们能够用这个装饰器来装饰任何方法。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@logger
```
```python
def
```
```python
foo1(x, y
```
```python
=
```
```python
1
```
```python
):
```
```python
```
```python
return
```
```python
x
```
```python
*
```
```python
y
```
```python
@logger
```
```python
def
```
```python
foo2():
```
```python
```
```python
return
```
```python
2
```
```python
foo1(
```
```python
5
```
```python
,
```
```python
4
```
```python
)
```
```python
#Arguments were: (5, 4), {}
```
```python
#20
```
```python
foo1(
```
```python
1
```
```python
)
```
```python
#Arguments were: (1,), {}
```
```python
#1
```
```python
foo2()
```
```python
#Arguments were: (), {}
```
```python
#2
```
```
随便调用我们定义的哪个方法，相应的日志也会打印到输出窗口，和我们预期的一样。
# 13. 带参数的装饰器：
如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
def
```
```python
log(text):
```
```python
```
```python
def
```
```python
decorator(func):
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw):
```
```python
```
```python
print
```
```python
'%s %s():'
```
```python
%
```
```python
(text, func.__name__)
```
```python
```
```python
return
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw)
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
return
```
```python
decorator
```
```
这个3层嵌套的decorator用法如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@log
```
```python
(
```
```python
'execute'
```
```python
)
```
```python
def
```
```python
now():
```
```python
```
```python
print
```
```python
'2013-12-25'
```
```
执行结果如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
>>> now()
```
```python
execute now():
```
```python
2013
```
```python
-
```
```python
12
```
```python
-
```
```python
25
```
```
和两层嵌套的decorator相比，3层嵌套的效果是这样的：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
now
```
```python
=
```
```python
log(
```
```python
'execute'
```
```python
)(now)
```
```
我们来剖析上面的语句，首先执行`log('execute')`，返回的是`decorator`函数，再调用返回的函数，参数是`now`函数，返回值最终是`wrapper`函数。
# 14. 装饰器的副作用
以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有`__name__`等属性，但你去看经过decorator装饰之后的函数，它们的`__name__`已经从原来的`'now'`变成了`'wrapper'`：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
>>> now.__name__
```
```python
'wrapper'
```
```
因为返回的那个`wrapper()`函数名字就是`'wrapper'`，所以，需要把原始函数的`__name__`等属性复制到`wrapper()`函数中，否则，有些依赖函数签名的代码执行就会出错。
不需要编写
```
wrapper.__name__
 = func.__name__
```
这样的代码，Python内置的`functools.wraps`就是干这个事的，所以，一个完整的decorator的写法如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
functools
```
```python
def
```
```python
log(func):
```
```python
```
```python
@functools.wraps(func)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw):
```
```python
```
```python
print
```
```python
'call %s():'
```
```python
%
```
```python
func.__name__
```
```python
```
```python
return
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw)
```
```python
```
```python
return
```
```python
wrapper
```
```
或者针对带参数的decorator：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
functools
```
```python
def
```
```python
log(text):
```
```python
```
```python
def
```
```python
decorator(func):
```
```python
```
```python
@functools.wraps(func)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw):
```
```python
```
```python
print
```
```python
'%s %s():'
```
```python
%
```
```python
(text, func.__name__)
```
```python
```
```python
return
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kw)
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
return
```
```python
decorator
```
```
```
import
 functools
```
是导入`functools`模块。模块的概念稍候讲解。现在，只需记住在定义`wrapper()`的前面加上`@functools.wraps(func)`即可。
当然，即使是你用了functools的wraps，也不能完全消除这样的副作用。你会发现，即使是你你用了functools的wraps，你在用getargspec时，参数也不见了。要修正这一问题，我们还得用Python的反射来解决，当然，我相信大多数人的程序都不会去getargspec。所以，用functools的wraps应该够用了。
# 15. class式的 Decorator
首先，先得说一下，decorator的class方式，还是看个示例：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
class
```
```python
myDecorator(
```
```python
object
```
```python
):
```
```python
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
, fn):
```
```python
```
```python
print
```
```python
"inside myDecorator.__init__()"
```
```python
```
```python
self
```
```python
.fn
```
```python
=
```
```python
fn
```
```python
```
```python
```
```python
def
```
```python
__call__(
```
```python
self
```
```python
):
```
```python
```
```python
self
```
```python
.fn()
```
```python
```
```python
print
```
```python
"inside myDecorator.__call__()"
```
```python
```
```python
@myDecorator
```
```python
def
```
```python
aFunction():
```
```python
```
```python
print
```
```python
"inside aFunction()"
```
```python
```
```python
print
```
```python
"Finished decorating aFunction()"
```
```python
```
```python
aFunction()
```
```python
```
```python
# 输出：
```
```python
# inside myDecorator.__init__()
```
```python
# Finished decorating aFunction()
```
```python
# inside aFunction()
```
```python
# inside myDecorator.__call__()
```
```
1）一个是__init__()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个fn的参数，也就是被decorator的函数。
2）一个是__call__()，这个方法是在我们调用被decorator函数时被调用的。
上面输出可以看到整个程序的执行顺序。
这看上去要比“函数式”的方式更易读一些。
上面这段代码中，我们需要注意这几点：
1）如果decorator有参数的话，__init__() 成员就不能传入fn了，而fn是在__call__的时候传入的。
# 16. 一些decorator的示例
好了，现在我们来看一下各种decorator的例子：
## 16.1 给函数调用做缓存
这个例实在是太经典了，整个网上都用这个例子做decorator的经典范例，因为太经典了，所以，我这篇文章也不能免俗。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
from
```
```python
functools
```
```python
import
```
```python
wraps
```
```python
def
```
```python
memo(fn):
```
```python
```
```python
cache
```
```python
=
```
```python
{}
```
```python
```
```python
miss
```
```python
=
```
```python
object
```
```python
()
```
```python
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args):
```
```python
```
```python
result
```
```python
=
```
```python
cache.get(args, miss)
```
```python
```
```python
if
```
```python
result
```
```python
is
```
```python
miss:
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args)
```
```python
```
```python
cache[args]
```
```python
=
```
```python
result
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
@memo
```
```python
def
```
```python
fib(n):
```
```python
```
```python
if
```
```python
n <
```
```python
2
```
```python
:
```
```python
```
```python
return
```
```python
n
```
```python
```
```python
return
```
```python
fib(n
```
```python
-
```
```python
1
```
```python
)
```
```python
+
```
```python
fib(n
```
```python
-
```
```python
2
```
```python
)
```
```
上面这个例子中，是一个斐波拉契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。
而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。
## 16.2 Profiler的例子
这个例子没什么高深的，就是实用一些。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
cProfile, pstats, StringIO
```
```python
```
```python
def
```
```python
profiler(func):
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
datafn
```
```python
=
```
```python
func.__name__
```
```python
+
```
```python
".profile"
```
```python
# Name the data file
```
```python
```
```python
prof
```
```python
=
```
```python
cProfile.Profile()
```
```python
```
```python
retval
```
```python
=
```
```python
prof.runcall(func,
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
#prof.dump_stats(datafn)
```
```python
```
```python
s
```
```python
=
```
```python
StringIO.StringIO()
```
```python
```
```python
sortby
```
```python
=
```
```python
'cumulative'
```
```python
```
```python
ps
```
```python
=
```
```python
pstats.Stats(prof, stream
```
```python
=
```
```python
s).sort_stats(sortby)
```
```python
```
```python
ps.print_stats()
```
```python
```
```python
print
```
```python
s.getvalue()
```
```python
```
```python
return
```
```python
retval
```
```python
```
```python
```
```python
return
```
```python
wrapper
```
```
## 16.3 注册回调函数
下面这个示例展示了通过URL的路由来调用相关注册的函数示例：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
class
```
```python
MyApp():
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
):
```
```python
```
```python
self
```
```python
.func_map
```
```python
=
```
```python
{}
```
```python
```
```python
```
```python
def
```
```python
register(
```
```python
self
```
```python
, name):
```
```python
```
```python
def
```
```python
func_wrapper(func):
```
```python
```
```python
self
```
```python
.func_map[name]
```
```python
=
```
```python
func
```
```python
```
```python
return
```
```python
func
```
```python
```
```python
return
```
```python
func_wrapper
```
```python
```
```python
```
```python
def
```
```python
call_method(
```
```python
self
```
```python
, name
```
```python
=
```
```python
None
```
```python
):
```
```python
```
```python
func
```
```python
=
```
```python
self
```
```python
.func_map.get(name,
```
```python
None
```
```python
)
```
```python
```
```python
if
```
```python
func
```
```python
is
```
```python
None
```
```python
:
```
```python
```
```python
raise
```
```python
Exception(
```
```python
"No function registered against - "
```
```python
+
```
```python
str
```
```python
(name))
```
```python
```
```python
return
```
```python
func()
```
```python
```
```python
app
```
```python
=
```
```python
MyApp()
```
```python
```
```python
@app
```
```python
.register(
```
```python
'/'
```
```python
)
```
```python
def
```
```python
main_page_func():
```
```python
```
```python
return
```
```python
"This is the main page."
```
```python
```
```python
@app
```
```python
.register(
```
```python
'/next_page'
```
```python
)
```
```python
def
```
```python
next_page_func():
```
```python
```
```python
return
```
```python
"This is the next page."
```
```python
```
```python
print
```
```python
app.call_method(
```
```python
'/'
```
```python
)
```
```python
print
```
```python
app.call_method(
```
```python
'/next_page'
```
```python
)
```
```
注意：
1）上面这个示例中，用类的实例来做decorator。
2）decorator类中没有__call__()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。
## 16.4 给函数打日志
下面这个示例演示了一个logger的decorator，这个decorator输出了函数名，参数，返回值，和运行时间。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
from
```
```python
functools
```
```python
import
```
```python
wraps
```
```python
def
```
```python
logger(fn):
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
ts
```
```python
=
```
```python
time.time()
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
te
```
```python
=
```
```python
time.time()
```
```python
```
```python
print
```
```python
"function      = {0}"
```
```python
.
```
```python
format
```
```python
(fn.__name__)
```
```python
```
```python
print
```
```python
"    arguments = {0} {1}"
```
```python
.
```
```python
format
```
```python
(args, kwargs)
```
```python
```
```python
print
```
```python
"    return    = {0}"
```
```python
.
```
```python
format
```
```python
(result)
```
```python
```
```python
print
```
```python
"    time      = %.6f sec"
```
```python
%
```
```python
(te
```
```python
-
```
```python
ts)
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
@logger
```
```python
def
```
```python
multipy(x, y):
```
```python
```
```python
return
```
```python
x
```
```python
*
```
```python
y
```
```python
```
```python
@logger
```
```python
def
```
```python
sum_num(n):
```
```python
```
```python
s
```
```python
=
```
```python
0
```
```python
```
```python
for
```
```python
i
```
```python
in
```
```python
xrange
```
```python
(n
```
```python
+
```
```python
1
```
```python
):
```
```python
```
```python
s
```
```python
+
```
```python
=
```
```python
i
```
```python
```
```python
return
```
```python
s
```
```python
```
```python
print
```
```python
multipy(
```
```python
2
```
```python
,
```
```python
10
```
```python
)
```
```python
print
```
```python
sum_num(
```
```python
100
```
```python
)
```
```python
print
```
```python
sum_num(
```
```python
10000000
```
```python
)
```
```
上面那个打日志还是有点粗糙，让我们看一个更好一点的（带log level参数的）：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
inspect
```
```python
def
```
```python
get_line_number():
```
```python
```
```python
return
```
```python
inspect.currentframe().f_back.f_back.f_lineno
```
```python
```
```python
def
```
```python
logger(loglevel):
```
```python
```
```python
def
```
```python
log_decorator(fn):
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
ts
```
```python
=
```
```python
time.time()
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
te
```
```python
=
```
```python
time.time()
```
```python
```
```python
print
```
```python
"function   = "
```
```python
+
```
```python
fn.__name__,
```
```python
```
```python
print
```
```python
"    arguments = {0} {1}"
```
```python
.
```
```python
format
```
```python
(args, kwargs)
```
```python
```
```python
print
```
```python
"    return    = {0}"
```
```python
.
```
```python
format
```
```python
(result)
```
```python
```
```python
print
```
```python
"    time      = %.6f sec"
```
```python
%
```
```python
(te
```
```python
-
```
```python
ts)
```
```python
```
```python
if
```
```python
(loglevel
```
```python
=
```
```python
=
```
```python
'debug'
```
```python
):
```
```python
```
```python
print
```
```python
"    called_from_line : "
```
```python
+
```
```python
str
```
```python
(get_line_number())
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
return
```
```python
log_decorator
```
```
但是，上面这个带log level参数的有两具不好的地方，
1） loglevel不是debug的时候，还是要计算函数调用的时间。
2） 不同level的要写在一起，不易读。
我们再接着改进：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
inspect
```
```python
```
```python
def
```
```python
advance_logger(loglevel):
```
```python
```
```python
```
```python
def
```
```python
get_line_number():
```
```python
```
```python
return
```
```python
inspect.currentframe().f_back.f_back.f_lineno
```
```python
```
```python
```
```python
def
```
```python
_basic_log(fn, result,
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
print
```
```python
"function   = "
```
```python
+
```
```python
fn.__name__,
```
```python
```
```python
print
```
```python
"    arguments = {0} {1}"
```
```python
.
```
```python
format
```
```python
(args, kwargs)
```
```python
```
```python
print
```
```python
"    return    = {0}"
```
```python
.
```
```python
format
```
```python
(result)
```
```python
```
```python
```
```python
def
```
```python
info_log_decorator(fn):
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
_basic_log(fn, result, args, kwargs)
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
```
```python
def
```
```python
debug_log_decorator(fn):
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
ts
```
```python
=
```
```python
time.time()
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
te
```
```python
=
```
```python
time.time()
```
```python
```
```python
_basic_log(fn, result, args, kwargs)
```
```python
```
```python
print
```
```python
"    time      = %.6f sec"
```
```python
%
```
```python
(te
```
```python
-
```
```python
ts)
```
```python
```
```python
print
```
```python
"    called_from_line : "
```
```python
+
```
```python
str
```
```python
(get_line_number())
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
```
```python
if
```
```python
loglevel
```
```python
is
```
```python
"debug"
```
```python
:
```
```python
```
```python
return
```
```python
debug_log_decorator
```
```python
```
```python
else
```
```python
:
```
```python
```
```python
return
```
```python
info_log_decorator
```
```
你可以看到两点，
1）我们分了两个log level，一个是info的，一个是debug的，然后我们在外尾根据不同的参数返回不同的decorator。
2）我们把info和debug中的相同的代码抽到了一个叫_basic_log的函数里，DRY原则。
## 16.5 一个MySQL的Decorator
下面这个decorator是我在工作中用到的代码，我简化了一下，把DB连接池的代码去掉了，这样能简单点，方便阅读。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
import
```
```python
umysql
```
```python
from
```
```python
functools
```
```python
import
```
```python
wraps
```
```python
```
```python
class
```
```python
Configuraion:
```
```python
```
```python
def
```
```python
__init__(
```
```python
self
```
```python
, env):
```
```python
```
```python
if
```
```python
env
```
```python
=
```
```python
=
```
```python
"Prod"
```
```python
:
```
```python
```
```python
self
```
```python
.host
```
```python
=
```
```python
"coolshell.cn"
```
```python
```
```python
self
```
```python
.port
```
```python
=
```
```python
3306
```
```python
```
```python
self
```
```python
.db
```
```python
=
```
```python
"coolshell"
```
```python
```
```python
self
```
```python
.user
```
```python
=
```
```python
"coolshell"
```
```python
```
```python
self
```
```python
.passwd
```
```python
=
```
```python
"fuckgfw"
```
```python
```
```python
elif
```
```python
env
```
```python
=
```
```python
=
```
```python
"Test"
```
```python
:
```
```python
```
```python
self
```
```python
.host
```
```python
=
```
```python
'localhost'
```
```python
```
```python
self
```
```python
.port
```
```python
=
```
```python
3300
```
```python
```
```python
self
```
```python
.user
```
```python
=
```
```python
'coolshell'
```
```python
```
```python
self
```
```python
.db
```
```python
=
```
```python
'coolshell'
```
```python
```
```python
self
```
```python
.passwd
```
```python
=
```
```python
'fuckgfw'
```
```python
```
```python
def
```
```python
mysql(sql):
```
```python
```
```python
```
```python
_conf
```
```python
=
```
```python
Configuraion(env
```
```python
=
```
```python
"Prod"
```
```python
)
```
```python
```
```python
```
```python
def
```
```python
on_sql_error(err):
```
```python
```
```python
print
```
```python
err
```
```python
```
```python
sys.exit(
```
```python
-
```
```python
1
```
```python
)
```
```python
```
```python
```
```python
def
```
```python
handle_sql_result(rs):
```
```python
```
```python
if
```
```python
rs.rows >
```
```python
0
```
```python
:
```
```python
```
```python
fieldnames
```
```python
=
```
```python
[f[
```
```python
0
```
```python
]
```
```python
for
```
```python
f
```
```python
in
```
```python
rs.fields]
```
```python
```
```python
return
```
```python
[
```
```python
dict
```
```python
(
```
```python
zip
```
```python
(fieldnames, r))
```
```python
for
```
```python
r
```
```python
in
```
```python
rs.rows]
```
```python
```
```python
else
```
```python
:
```
```python
```
```python
return
```
```python
[]
```
```python
```
```python
```
```python
def
```
```python
decorator(fn):
```
```python
```
```python
@wraps(fn)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
mysqlconn
```
```python
=
```
```python
umysql.Connection()
```
```python
```
```python
mysqlconn.settimeout(
```
```python
5
```
```python
)
```
```python
```
```python
mysqlconn.connect(_conf.host, _conf.port, _conf.user, \
```
```python
```
```python
_conf.passwd, _conf.db,
```
```python
True
```
```python
,
```
```python
'utf8'
```
```python
)
```
```python
```
```python
try
```
```python
:
```
```python
```
```python
rs
```
```python
=
```
```python
mysqlconn.query(sql, {})
```
```python
```
```python
except
```
```python
umysql.Error as e:
```
```python
```
```python
on_sql_error(e)
```
```python
```
```python
```
```python
data
```
```python
=
```
```python
handle_sql_result(rs)
```
```python
```
```python
kwargs[
```
```python
"data"
```
```python
]
```
```python
=
```
```python
data
```
```python
```
```python
result
```
```python
=
```
```python
fn(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
mysqlconn.close()
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
wrapper
```
```python
```
```python
```
```python
return
```
```python
decorator
```
```python
```
```python
@mysql
```
```python
(sql
```
```python
=
```
```python
"select * from coolshell"
```
```python
)
```
```python
def
```
```python
get_coolshell(data):
```
```python
```
```python
... ...
```
```python
```
```python
... ..
```
```
## 16.6 线程异步
下面量个非常简单的异步执行的decorator，注意，异步处理并不简单，下面只是一个示例。
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
from
```
```python
threading
```
```python
import
```
```python
Thread
```
```python
from
```
```python
functools
```
```python
import
```
```python
wraps
```
```python
```
```python
def
```
```python
async(func):
```
```python
```
```python
@wraps(func)
```
```python
```
```python
def
```
```python
async_func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
func_hl
```
```python
=
```
```python
Thread(target
```
```python
=
```
```python
func, args
```
```python
=
```
```python
args, kwargs
```
```python
=
```
```python
kwargs)
```
```python
```
```python
func_hl.start()
```
```python
```
```python
return
```
```python
func_hl
```
```python
```
```python
```
```python
return
```
```python
async_func
```
```python
```
```python
if
```
```python
__name__
```
```python
=
```
```python
=
```
```python
'__main__'
```
```python
:
```
```python
```
```python
from
```
```python
time
```
```python
import
```
```python
sleep
```
```python
```
```python
```
```python
@async
```
```python
```
```python
def
```
```python
print_somedata():
```
```python
```
```python
print
```
```python
'starting print_somedata'
```
```python
```
```python
sleep(
```
```python
2
```
```python
)
```
```python
```
```python
print
```
```python
'print_somedata: 2 sec passed'
```
```python
```
```python
sleep(
```
```python
2
```
```python
)
```
```python
```
```python
print
```
```python
'print_somedata: 2 sec passed'
```
```python
```
```python
sleep(
```
```python
2
```
```python
)
```
```python
```
```python
print
```
```python
'finished print_somedata'
```
```python
```
```python
```
```python
def
```
```python
main():
```
```python
```
```python
print_somedata()
```
```python
```
```python
print
```
```python
'back in main'
```
```python
```
```python
print_somedata()
```
```python
```
```python
print
```
```python
'back in main'
```
```python
```
```python
```
```python
main()
```
```
## 16.7 超时函数
这个函数的作用在于可以给任意可能会hang住的函数添加超时功能，这个功能在编写外部API调用 、网络爬虫、数据库查询的时候特别有用。
timeout装饰器的代码如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
# coding=utf-8
```
```python
# 测试utf-8编码
```
```python
import
```
```python
sys
```
```python
reload
```
```python
(sys)
```
```python
sys.setdefaultencoding(
```
```python
'utf-8'
```
```python
)
```
```python
import
```
```python
signal,functools
```
```python
#下面会用到的两个库
```
```python
class
```
```python
TimeoutError(Exception):
```
```python
pass
```
```python
#定义一个Exception，后面超时抛出
```
```python
def
```
```python
timeout(seconds, error_message
```
```python
=
```
```python
'Function call timed out'
```
```python
):
```
```python
```
```python
def
```
```python
decorated(func):
```
```python
```
```python
def
```
```python
_handle_timeout(signum, frame):
```
```python
```
```python
raise
```
```python
TimeoutError(error_message)
```
```python
```
```python
def
```
```python
wrapper(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
signal.signal(signal.SIGALRM, _handle_timeout)
```
```python
```
```python
signal.alarm(seconds)
```
```python
```
```python
try
```
```python
:
```
```python
```
```python
result
```
```python
=
```
```python
func(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
finally
```
```python
:
```
```python
```
```python
signal.alarm(
```
```python
0
```
```python
)
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
functools.wraps(func)(wrapper)
```
```python
```
```python
return
```
```python
decorated
```
```python
@timeout
```
```python
(
```
```python
5
```
```python
)
```
```python
#限定下面的slowfunc函数如果在5s内不返回就强制抛TimeoutError Exception结束
```
```python
def
```
```python
slowfunc(sleep_time):
```
```python
```
```python
import
```
```python
time
```
```python
```
```python
time.sleep(sleep_time)
```
```python
#这个函数就是休眠sleep_time秒
```
```python
# slowfunc(3) #sleep 3秒，正常返回 没有异常
```
```python
slowfunc(
```
```python
10
```
```python
)
```
```python
#被终止
```
```python
## 输出
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
TimeoutError                              Traceback (most recent call last)
```
```
## 16.8 Trace函数
有时候出于演示目的或者调试目的，我们需要程序运行的时候打印出每一步的运行顺序 和调用逻辑。类似写bash的时候的bash -x调试功能，然后Python解释器并没有 内置这个时分有用的功能，那么我们就“自己动手，丰衣足食”。
Trace装饰器的代码如下：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
# coding=utf-8
```
```python
# 测试utf-8编码
```
```python
import
```
```python
sys
```
```python
reload
```
```python
(sys)
```
```python
sys.setdefaultencoding(
```
```python
'utf-8'
```
```python
)
```
```python
import
```
```python
sys,os,linecache
```
```python
def
```
```python
trace(f):
```
```python
```
```python
def
```
```python
globaltrace(frame, why, arg):
```
```python
```
```python
if
```
```python
why
```
```python
=
```
```python
=
```
```python
"call"
```
```python
:
```
```python
return
```
```python
localtrace
```
```python
```
```python
return
```
```python
None
```
```python
```
```python
def
```
```python
localtrace(frame
```
```python
=
```
```python
1
```
```python
, why
```
```python
=
```
```python
2
```
```python
, arg
```
```python
=
```
```python
4
```
```python
):
```
```python
```
```python
if
```
```python
why
```
```python
=
```
```python
=
```
```python
"line"
```
```python
:
```
```python
```
```python
# record the file name and line number of every trace
```
```python
```
```python
filename
```
```python
=
```
```python
frame.f_code.co_filename
```
```python
```
```python
lineno
```
```python
=
```
```python
frame.f_lineno
```
```python
```
```python
bname
```
```python
=
```
```python
os.path.basename(filename)
```
```python
```
```python
print
```
```python
"{}({}): {}"
```
```python
.
```
```python
format
```
```python
(  bname,
```
```python
```
```python
lineno,
```
```python
```
```python
linecache.getline(filename, lineno)),
```
```python
```
```python
return
```
```python
localtrace
```
```python
```
```python
def
```
```python
_f(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwds):
```
```python
```
```python
sys.settrace(globaltrace)
```
```python
```
```python
result
```
```python
=
```
```python
f(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwds)
```
```python
```
```python
sys.settrace(
```
```python
None
```
```python
)
```
```python
```
```python
return
```
```python
result
```
```python
```
```python
return
```
```python
_f
```
```python
@trace
```
```python
def
```
```python
xxx():
```
```python
```
```python
a
```
```python
=
```
```python
1
```
```python
```
```python
print
```
```python
a
```
```python
```
```python
print
```
```python
22
```
```python
```
```python
print
```
```python
333
```
```python
xxx()
```
```python
#调用
```
```python
#######################################
```
```python
C:\Python27\python.exe F:
```
```python
/
```
```python
sourceDemo
```
```python
/
```
```python
flask
```
```python
/
```
```python
study
```
```python
/
```
```python
com.test.bj
```
```python
/
```
```python
t2.py
```
```python
t2.py(
```
```python
31
```
```python
):   a
```
```python
=
```
```python
1
```
```python
t2.py(
```
```python
32
```
```python
):
```
```python
print
```
```python
a
```
```python
1
```
```python
t2.py(
```
```python
33
```
```python
):
```
```python
print
```
```python
22
```
```python
22
```
```python
t2.py(
```
```python
34
```
```python
):
```
```python
print
```
```python
333
```
```python
333
```
```python
Process finished with exit code
```
```python
0
```
```
## 16.9 单例模式
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
# coding=utf-8
```
```python
# 测试utf-8编码
```
```python
# 单例装饰器
```
```python
import
```
```python
sys
```
```python
reload
```
```python
(sys)
```
```python
sys.setdefaultencoding(
```
```python
'utf-8'
```
```python
)
```
```python
# 使用装饰器实现简单的单例模式
```
```python
def
```
```python
singleton(
```
```python
cls
```
```python
):
```
```python
```
```python
instances
```
```python
=
```
```python
dict
```
```python
()
```
```python
# 初始为空
```
```python
```
```python
def
```
```python
_singleton(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs):
```
```python
```
```python
if
```
```python
cls
```
```python
not
```
```python
in
```
```python
instances:
```
```python
#如果不存在, 则创建并放入字典
```
```python
```
```python
instances[
```
```python
cls
```
```python
]
```
```python
=
```
```python
cls
```
```python
(
```
```python
*
```
```python
args,
```
```python
*
```
```python
*
```
```python
kwargs)
```
```python
```
```python
return
```
```python
instances[
```
```python
cls
```
```python
]
```
```python
```
```python
return
```
```python
_singleton
```
```python
@singleton
```
```python
class
```
```python
Test(
```
```python
object
```
```python
):
```
```python
```
```python
pass
```
```python
if
```
```python
__name__
```
```python
=
```
```python
=
```
```python
'__main__'
```
```python
:
```
```python
```
```python
t1
```
```python
=
```
```python
Test()
```
```python
```
```python
t2
```
```python
=
```
```python
Test()
```
```python
```
```python
# 两者具有相同的地址
```
```python
```
```python
print
```
```python
t1
```
```python
```
```python
print
```
```python
t2
```
```
# 17. 小结
在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。
decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。
最后留个小作业：
请编写一个decorator，能在函数调用的前后打印出
```
'begin
 call'
```
和
```
'end
 call'
```
的日志。
再思考一下能否写出一个`@log`的decorator，使它既支持：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@log
```
```python
def
```
```python
f():
```
```python
```
```python
pass
```
```
又支持：
[?](http://my.oschina.net/leejun2005/blog/477614#)
```
```python
@log
```
```python
(
```
```python
'execute'
```
```python
)
```
```python
def
```
```python
f():
```
```python
```
```python
pass
```
```
# 18. Refer：
[1] 12步轻松搞定python装饰器
[http://python.jobbole.com/81683/](http://python.jobbole.com/81683/)
[2] 装饰器
[liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000)
[3] Python修饰器的函数式编程
[http://coolshell.cn/articles/11265.html](http://coolshell.cn/articles/11265.html)
[4] Python Decorator Library
[https://wiki.python.org/moin/PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary)
[5] Python装饰器实例：调用参数合法性验证
[http://python.jobbole.com/82114/](http://python.jobbole.com/82114/)
[6] Python 装饰器
[http://python.jobbole.com/82344/](http://python.jobbole.com/82344/)
[7] 两个实用的Python的装饰器
[http://blog.51reboot.com/%E4%B8%A4%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84python%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/](http://blog.51reboot.com/%E4%B8%A4%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84python%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/)
