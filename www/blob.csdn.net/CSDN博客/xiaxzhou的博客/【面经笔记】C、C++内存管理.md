# 【面经笔记】C、C++内存管理 - xiaxzhou的博客 - CSDN博客





2017年07月12日 20:33:57[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：274








## C内存管理

**存储时:**

执行程序在存储时（没有调入到内存）分为代码区（text）、数据区（data）和未初始化数据区（bss）3个部分。

1 代码区（text segment）

存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

2 数据区：
- 全局初始化数据区/静态数据区（initialized data segment/data segment）

data段：该区包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）。

BSS段（uninitialized data segment），存入的是全局、静态 未初始化的变量，**程序没有存储实际的数据，只是存储了必要的信息，程序执行前，系统根据信息分配相应的新的内存，然后全部清0。供程序使用。所以，未初始的全局、静态变量在程序执行之前已经成0了。**

常量存储区：常量数据（如字符串常量）

**运行时：**

（1）代码区（text segment）

代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。

> 
**代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。**


（2）全局初始化数据区/静态数据区（Data Segment）

只初始化一次。

（3）未初始化数据区（BSS）

在运行时改变其值。

（4）栈区（stack）

由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。

（5）堆区（heap）

用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，**若程序员不释放，程序结束时有可能由OS回收。**

```cpp
//main.cpp 
int a = 0;    //a在全局已初始化数据区 
char *p1;    //p1在BSS区（未初始化全局变量） 
main() 
{
int b;    //b在栈区
char s[] = "abc"; //s为数组变量，存储在栈区，
//"abc"为字符串常量，存储在已初始化数据区
char *p1，p2;  //p1、p2在栈区
char *p3 = "123456"; //123456\0在已初始化数据区，p3在栈区 
static int c =0；  //C为全局（静态）数据，存在于已初始化数据区
//另外，静态数据会自动初始化  （立即数0 存储在代码中？）
p1 = (char *)malloc(10);//分配得来的10个字节的区域在堆区
p2 = (char *)malloc(20);//分配得来的20个字节的区域在堆区
free(p1);
free(p2);
}
```

在c中分为这几个存储区 

1.栈 - 由编译器自动分配释放 

2.堆 - 一般由程序员malloc分配释放，使用free释放,若程序员不释放，程序结束时由OS回收 

3.全局区（静态区），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放 

4.另外还有一个专门放常量的地方。- 程序结束释放
# 在C++中，内存分成5个区

1.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。

2.堆，就是那些由malloc分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制。使用free释放内存，如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

> 
3.自由存储区，就是那些由new分配的内存块，他和堆是十分相似的，不过它是用delete来结束自己的生命的。

**自由存储是C++中通过new与delete动态分配和释放对象的抽象概念**，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。


C++ 自由存储区是否等价于堆？:  
[http://www.codesec.net/view/223702.html](http://www.codesec.net/view/223702.html)

4.全局/静态存储区，**全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。**

5.**常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）

例：

```
char *GetString_1(void)
{
    char * p = "hello world";
    return p;
}
char *GetString_2(void)
{
    char  p[] = "hello world";
    return p;
}
int main()
{
    char *str = NULL;
    str = GetString_1();
    printf("%s", str);
    str = GetString_2();
    printf("%s", str);
    return 0;
}
```

**new/delete 与malloc/free的区别**
- new不需要手动计算内存大小，malloc需要手动计算
- new包含了malloc和构造两步，new调用构造函数，delete调用析构函数
- new返回类型指针，malloc返回void指针




