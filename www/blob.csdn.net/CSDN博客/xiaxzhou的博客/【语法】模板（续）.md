# 【语法】模板（续） - xiaxzhou的博客 - CSDN博客





2017年07月07日 21:09:07[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：146
个人分类：[C++语法](https://blog.csdn.net/xiaxzhou/article/category/7013275)








- 函数指针与实参推断

当使用函数模板初始化函数指针或为函数指针赋值时，编译器使用指针类型推断函数模板实参

```cpp
template<typename T> inline bool compare(const T& lhs, const T& rhs)
{
    return lhs < rhs;
}

bool (*pfunc) (const int & lhs, const int & rhs) = compare; 
//pfunc = compare<int>;//显式指出
```
- **模板实参推断 与 引用**

左值引用（T&）

> 
**T&** ：只能传递给它左值：变量、返回引用的表达式

**const T&**： 可以绑定到**任何**类型：对象（左值）、临时对象（右值）、字面常量（右值）


右值引用（T&&）

> 
一般传入右值，如func(3) 推断出T为int

通常不允许将右值引用绑定到左值上，但有两个**特例**： 
**左值传递给模板函数的右值引用参数(T&&)**

  推断出实参为左值引用(T&)。因此：func(i)，推断出T为int&而非int
**引用折叠**： 

  T&& &和T& &&和T& & 折叠为T& 

  T&& && 折叠为T&&
**任何**参数类型可以传给右值引用。 

若传入左值给它，则函数参数实例化为普通的左值引用（T->int &  、int& &&->int&）

**通过引用可以保留const属性**
**通过右值引用可以保留左右属性**
- 函数模板特例化：

```
template<>
bool compare(const char* const &p1, const char* const &p2)
{
    return true;
}
```
- 类模板特例化

函数模板不能部分特例化，类模板可以部分特例化

```cpp
template<typename T> 
class Blob<T&>
{
private:
    vector<T> vec;
public:
    void func(const T& lhs);
    Blob operator++(int lhs);
    Blob(){};
    template<typename It> Blob(It b, It e);
};
```






