# 【面经笔记】进程调度方式 - xiaxzhou的博客 - CSDN博客





2017年08月31日 10:28:45[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：337








分为两大类：可剥夺和不可剥夺

### 基于优先级调度：

优先级高的进程先运行，可剥夺

### 基于调度策略：

选择函数：
- 先进先出（FCFS、FIFO）

> 
改进：将优先级与队列结合，每个优先级一个队列

- 轮询/轮转

> 
周期性间隔产生中断，中断发生时，当前运行的进程置于就绪队列中，然后基于FIFO策略选择下一个就绪进程。

- 最短进程优先（Shortest Process Next,SPN）

> 
这是一个非抢占策略，**下一次**选择**预计处理时间**最短的进程进行处理，其难点是不知道进程的运行时间。风险是长进程饥饿。

- 最短剩余时间（Shortest Remaining Time ,SRT）

> 
针对SPN增加了**抢占机制**，总是选择预计**剩余处理时间**最短的进程。 

  当一个新进程加入就绪队列时，它可能比当前运行的进程具有更短的剩余时间，因此，只要新进程就绪，就抢占当前正在运行的进程。 

  相对于一个正在运行的长作业，短作业可以**立即**被选择运行。- 最高响应比

> 


$R = \frac{w+s}{s}$

w 为等待处理器时间，s为预计的服务时间。

处理器选择R最大的就绪进程。当系统偏向短作业时，长作业由于得不到服务的时间不断增加，R会不断增大，从而胜过短作业。

- 多级反馈队列调度

既能使高优先级的作业得到响应又能使短作业（进程）迅速完成

> 
由于没法获得进程剩余执行时间，那就关注**已经执行的时间**。 

   多级反馈队列调度基于抢占原则（基于**时间片**），并使用**动态优先级机制**

当一个进程第一次进入系统后，优先级最高，随后的时间里，每当它被抢占时，它就被降级到下一个低优先级队列。

除了优先级最低的队列外，其他队列都使用FIFO调度：**每个队列都是基于时间片的轮询策略，但是每个进程在非底层队列中最多被调用一个时间片，然后就去了下一个队列。所以可以按FIFO调度理解。**

优先级最低的队列使用轮询调度。

短进程很快会执行完，不会在就绪队列中降很多级，一个长进程会逐级下降。因此，新到的进程和短进程优先级优先于老进程和长进程。


多级(假设为N级)反馈队列调度算法可以如下原理：

1、设有N个队列（Q1,Q2….QN），其中各个队列对于处理机的优先级是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) > Priority(Q2) > … > Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被处理机调度），依次类推其它的队列。

2、对于某个特定的队列来说，里面是遵循时间片轮转法。也就是说，位于队列Q2中有N个作业，它们的运行时间是通过Q2这个队列所设定的时间片来确定的（为了便于理解，我们也可以认为特定队列中的作业的优先级是**按照FCFS来调度的**）。

3、各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。**各个队列的时间片是随着优先级的增加而减少的**，也就是说，优先级越高的队列中它的时间片就越短。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。

多级反馈队列调度算法描述：

1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。

2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。

3、对于同一个队列中的各个进程，按照时间片轮转法调度。**比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待**，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。

4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。、





