# 【面经笔记】C++语法 - xiaxzhou的博客 - CSDN博客





2017年09月04日 11:42:58[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：394








## C++11有哪些新特性？

auto类型推导

Override和final

lambda表达式

constexpr常量表达式

智能指针：weak_ptr、shared_ptr、unique_ptr

Move语义、右值引用

## c++中的隐藏、重载、覆盖（重写）

> 
成员函数被重载的特征：


（1）**相同的范围**（在同一个类中）；

（2）函数名字相同；

（3）参数不同；

（4）virtual关键字可有可无。

> 
覆盖是指派生类函数覆盖基类函数，特征是：


（1）不同的范围（分别位于派生类与基类）；

（2）函数名字相同；

（3）参数相同；

（4）基类函数必须有virtual关键字。

> 
令人迷惑的隐藏规则：


本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 

（1）如果派生类的函数与基类的函数同名，但是**参数不同**。此时，**不论有无virtual关键字**，基类的函数将被隐藏（注意别与重载混淆）。 

（2）如果派生类的函数与基类的函数同名，并且**参数也相同**，但是基类函数**没有virtual关键字**。此时，基类的函数被隐藏（注意别与覆盖混淆）。 

```cpp
#include <iostream.h>

    class Base
{
public:
    virtual void f(float x){ cout << "Base::f(float) " << x << endl; }
　　virtual void g(float x){ cout << "Base::g(float) " << x << endl; }
　　void h(float x){ cout << "Base::h(float) " << x << endl; }
}; 


 class Derived : public Base
{
public:
    virtual void f(float x){ cout << "Derived::f(float) " << x << endl; }
　　virtual void g(int x){ cout << "Derived::g(int) " << x << endl; }
   void h(float x){ cout << "Derived::h(float) " << x << endl; }
};
```

上面的程序中：  

（1）函数Derived::f(float)覆盖了Base::f(float)。  

（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。  

（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。
override：表示函数应当覆盖/重写基类中的虚函数。

final：表示派生类不应当覆盖/重写这个虚函数。

## 左值、右值

在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。  

在c++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。

### 右值、将亡值

在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，**纯右值指的是临时变量值、不跟对象关联的字面量值**。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。

C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；**将亡值则是C++11新增的跟右值引用相关的表达式**，这样表达式通常是**将要被移动的对象**（移为他用），比如返回**右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。**

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

### 左值引用、右值引用

左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。

右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。**左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名**。

左值引用不能绑定到右值对象上，右值引用也不能绑定到左值对象上。 

例外：如果左值引用是const类型的，则其可以绑定到右值对象上。

左值引用通常也不能绑定到右值，但**常量左值引用是个“万能”的引用类型**。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，**非常量左值只能接受非常量左值对其进行初始化**。

```
int &a = 2;       # 左值引用绑定到右值，编译失败

int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
```

右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，需要**std::move()将**左值强制转换为右值，例如：

```cpp
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

由于右值引用只能绑定到右值对象上，而右值对象又是短暂的、即将销毁的。也就是说右值引用有一个重要性质：只能绑定到即将销毁的对象上。 

只要能够绑定右值的引用类型，都能够延长右值的生命期。

[参考1](http://www.cnblogs.com/niuxichuan/p/5679813.html%20%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2)
[参考2](http://blog.csdn.net/hyman_yx/article/details/52044632)

## 常量表达式

一. constexpr和常量表达式

　　常量表达式（const expression）是指值**不会改变**并且在**编译过程就能得到计算结果的表达式**。显然，**字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。**

　　一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```
const int max_files = 20;       // max_files是常量表达式  
const int limit = max_files + 1;    // limit是常量表达式  
int staff_size = 27;                // staff_size不是常量表达式  
const int sz = get_size();      // sz不是常量表达式
```

　　尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。另一方面，*尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。*

　　在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。

　　C++11新标准规定，**允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式**。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```cpp
constexpr int mf = 20;          // 20是常量表达式  
constexpr int limit = mf + 1;   // mf + 1是常量表达式  
constexpr int sz = size();      // 只有当size是一个onstexpr函数时才是一条正确的声明语句
```

　　尽管不能使用普通函数作为constexpr变量的初始值，但是，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

　　一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。

　　常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为”字面值类型”（literal type）。

　　到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。

　　尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

　　值得一提的是，函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样，允许函数定义一类有效范围超出函数本身的变量（即局部静态变量），这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。
- 指针和constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```cpp
const int *p = nullptr;         // p是一个指向整型常量的指针  
constexpr int *q = nullptr;     // q是一个指向整数的常量指针
```

　　p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于**constexpr把它所定义的对象置为了顶层const。**

与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：

```cpp
constexpr int *np = nullptr;    // np是一个指向整数的常量指针，其值为空  
int j = 0;  
constexpr int i = 42;       // i的类型是整型常量  
// i和j都必须定义在函数体之外  
constexpr const int *p = &i;    // p 是常量指针，指向整型常量i  
constexpr int *p1 = &j;         // p1是常量指针，指向整数j
```

[参考](http://blog.csdn.net/hyman_yx/article/details/52044632)

## 函数、函数指针、函数对象、lambda表达式

### 函数指针

是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。  

函数指针的用途是很大的，主要有两个作用：用作调用函数和做函数的参数。  

函数指针的声明方法：  

数据类型标志符 （指针变量名） （形参列表）；  

一般函数的声明为:  

int func ( int x );  

而一个函数指针的声明方法为：  

int (*func) (int x);  

前面的那个(*func)中括号是必要的，这会告诉编译器我们声明的是函数指针而不是声明一个具有返回型为指针的函数，后面的形参要视这个函数指针所指向的函数形参而定。  

然而这样声明我们有时觉得非常繁琐，于是typedef可以派上用场了，我们也可以这样声明： 
typedef int (*PF) (int x);  

PF pf;

这样pf便是一个函数指针，方便了许多。当要使用函数指针来调用函数时，func(x)或者 (*fucn)(x) 就可以了，当然，函数指针也可以指向被重载的函数，编译器会为我们区分这些重载的函数从而使函数指针指向正确的函数。

```cpp
typedef void (*PFT) ( char ,int );
void bar(char ch, int i)
{
    cout<<"bar "<<ch<<' '<<i<<endl;
    return ;
}
PFT pft;
pft = bar;
pft('e',91);
```

函数指针另一个作用便是作为函数的参数，我们可以在一个函数的形参列表中传入一个函数指针，然后便可以在这个函数中使用这个函数指针所指向的函数，这样便可以使程序变得更加清晰和简洁，而且这种用途技巧可以帮助我们解决很多棘手的问题，使用很小的代价就可获得足够大的利益（速度+复杂度）。

### 函数对象

前面是函数指针的应用，从一般的函数回调意义上来说，函数对象和函数指针是相同的，但是函数对象却具有许多函数指针不具有的优点，函数对象使程序设计更加灵活，而且能够实现函数的内联（inline）调用，使整个程序实现性能加速。  

函数对象：这里已经说明了这是一个对象，而且实际上只是这个对象具有的函数的某些功能，我们才称之为函数对象，意义很贴切，如果一个对象具有了某个函数的功能，我们变可以称之为函数对象。 

可以向一个算法传递任何类型的可调用对象。可调用对象有函数、函数指针、lambda表达式、重载了函数调用运算符的类即函数对象。
```
class A{
public:
int operator()(int x){return x;}
};
A a;
a(5);
```

[原文博客](http://www.cnblogs.com/lvpengms/archive/2011/02/21/1960078.html)

### lambda表达式

匿名**函数**

　lambda函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把lambda函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个std::function类似的对象去捕获lambda函数.使用 auto关键字可以帮助存储lambda函数,  

```
auto my_lambda_func = [&](int x) { /*...*/ };
auto my_onheap_lambda_func = new auto([=](int x) { /*...*/ });
```

一个没有指定任何捕获的lambda函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:

```
auto a_lambda_func = [](int x) { /*...*/ };
void(*func_ptr)(int) = a_lambda_func;
func_ptr(4); //calls the lambda.
```

[lambda使用](http://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html)

## STL三种智能指针
- 
unique_ptr  
**只允许基础指针的一个所有者。unique_ptr则无拷贝语义，但提供了移动语义。** 除非你确信需要 shared_ptr，否则请将该指针用作 POCO 的默认选项。 可以移到新所有者，但不会复制或共享。 替换已弃用的 auto_ptr。 与 boost::scoped_ptr 比较。 unique_ptr 小巧高效，大小等同于一个指针且支持 rvalue 引用，从而可实现快速插入和对 STL 集合的检索。

- 
shared_ptr  

采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。 **大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。**

- 
weak_ptr  

结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，用于断开 shared_ptr 实例间的循环引用。


### shared_ptr:

[参考](http://blog.csdn.net/nicolasyan/article/details/50588022)

智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。
- 每次**创建**指针类的新对象时，初始化指针并将引用计数置为1；
- 当指针对象作为另一指针对象的副本而**创建**时，拷贝构造函数拷贝指针并**增加**与之相应的引用计数；
- 对一个指针对象进行**赋值**时，赋值操作符**减少**左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并**增加**右操作数所指对象的引用计数；
- 调用指针**析构**函数时，**减少**引用计数（如果引用计数减至0，则删除所指基础对象）。

#### shared_ptr实现细节：

利用一个**辅助类**来管理指针的复制。原来的类中有一个指针指向辅助类，辅助类的数据成员是一个**计数器**和一个**基础对象指针**。

### unique_ptr基本操作：

unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。

unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。**离开作用域时/reset函数时，若其指向对象，则将其所指对象销毁**(默认使用delete操作符，用户可指定其他操作)。

unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、**通过reset方法重新指定（原对象被销毁）**、通过release方法释放所有权（原对象不会被销毁）、通过移动语义转移所有权。

```cpp
//智能指针的创建  
unique_ptr<int> u_i; //创建空智能指针”
u_i.reset(new int(3)); //"绑定”动态对象  
unique_ptr<int> u_i2(new int(4));//创建时指定动态对象  

//所有权的变化  
int *p_i = u_i2.release(); //释放所有权  
unique_ptr<string> u_s(new string("abc"));  
unique_ptr<string> u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针”  
u_s2=nullptr;//显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价
```

### weak_ptr：

当一个weak_ptr所观察的**shared_ptr要释放**它的资源时，它会把相关的weak_ptr的指针设**置为空**，防止weak_ptr持有悬空的指针。

weak_ptr并不拥有资源的所有权，所以**不能直接使用资源**。

weak_ptr并没有重载-> 和 * 操作符，所以我们不能通过他来直接使用资源，我们可以通过**lock**来获得一个shared_ptr对象来对资源进行使用，如果引用的资源已经释放，lock()函数将返回一个存储空指针的shared_ptr。 **expired**函数用来判断资源是否失效。

```cpp
shared_ptr<int> sp(new int(4));
weak_ptr<int> wp(sp);
if (!wp.expired())
{
    shared_ptr<int> sp2 = wp.lock();
    *sp2 = 100;
}
```

应用： 
[weak_ptr用于解决循环引用问题](http://blog.csdn.net/zhangxiao93/article/details/50570531)

## 虚函数表实现细节

[参考1](http://www.cnblogs.com/malecrab/p/5572730.html)

[参考2](http://www.cnblogs.com/webary/p/4731457.html)

[成员函数指针](http://www.cnblogs.com/malecrab/p/5572119.html)

派生类新增虚函数会增加到非虚主基类虚函数表中。

编译器只知道pb是B*类型的指针，并不知道它指向的具体对象类型 ：pb可能指向的是B的对象，也可能指向的是D的对象。

但对于“pb->bar()”，编译时能够确定的是：此处operator->的另一个参数是B::bar（因为pb是B*类型的，编译器认为bar是B::bar），**而B::bar和D::bar在各自虚函数表中的偏移位置是相等的。**

无论指针/引用指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移值，待运行时，能够确定具体类型，并能找到相应vptr了，就能找出真正应该调用的函数。

函数成员指针与普通函数指针相比，其size为普通函数指针的两倍（x64下为16字节），分为：ptr和adj两部分。

虚函数成员指针ptr部分内容为虚函数对应的函数指针在虚函数表中的偏移地址加1（之所以加1是为了用0表示空指针），**而adj部分为调节this指针的偏移字节数**。






