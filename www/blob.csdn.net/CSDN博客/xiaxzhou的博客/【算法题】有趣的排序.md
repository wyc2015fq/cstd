# 【算法题】有趣的排序 - xiaxzhou的博客 - CSDN博客





2017年06月03日 11:35:56[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：891








> 
度度熊有一个N个数的数组，他想将数组从小到大 排好序，但是萌萌的度度熊只会下面这个操作： 

  任取数组中的一个数然后将它放置在数组的最后一个位置。 

  问最少操作多少次可以使得数组从小到大有序？ 
**输入描述:**

  首先输入一个正整数N，接下来的一行输入N个整数。(N <= 50, 每个数的绝对值小于等于1000)

**输出描述**: 

  输出一个整数表示最少的操作次数。

**输入例子:**

  4 

  19 7 8 25
**输出例子:**

  2

复杂度 nlogn 但是需要一个 n 的辅助数组 

用一个辅助数组对所有元素进行排序，从小到大排序 

从第一个排好序的元素开始，即最小的元素开始与没排好序数组元素比较， 

检查有多少个已经是从最小到大好序的，位置可以不连续，但是大的元素必须在小的元素后面， 

 统计出一共有 count个，这些元素是不需要移动的元素 

 一共有 n 个元素，所以需要移动 n - count 次
首先将数组排序，然后按照排序的顺序，查找其在原数组的相对顺序是否与排序后一致：例： 

19 7 8 25 10 

排序后： 

7 8 10 19 25 
首先查找7在原数组位置：2 

然后查找8在原数组位置：3>2 

然后查找10在原数组位置：5>3 

然后查找19在原数组位置：1<5
则从19开始，需要将所有大于等于19的数执行一次放置操作

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include<algorithm>
using namespace std;

int func(vector<int>& vec)
{
    vector<int> vec_r=vec;
    sort(vec_r.begin(), vec_r.end());

    int index;
    int last;
    last = find(vec.begin(), vec.end(), vec_r[0]) - vec.begin();

    for (auto i = 1; i < vec_r.size();++i)
    {
        index = find(vec.begin(), vec.end(), vec_r[i])-vec.begin();
        if (index<last)
        {
            return vec.size() - i;
        }
        else
        {
            last = index;
        }
    }
     return 0;
}


int main()
{
    int n;
    cin >> n;
    vector<int> vec;
    vec.resize(n);
    for (auto i = 0; i < n;++i)
    {
        cin >> vec[i];
    }
    cout << func(vec) << endl;

     return 0;
}
```









