# 【算法题】地牢逃脱 - xiaxzhou的博客 - CSDN博客





2017年06月08日 16:23:38[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：808








> 
给定一个 n 行 m 列的地牢，其中 ‘.’ 表示可以通行的位置，’X’ 表示不可通行的障碍，牛牛从 (x0 , y0 ) 位置出发，遍历这个地牢，和一般的游戏所不同的是，他每一步只能按照一些指定的步长遍历地牢，要求每一步都不可以超过地牢的边界，也不能到达障碍上。地牢的出口可能在任意某个可以通行的位置上。牛牛想知道最坏情况下，他需要多少步才可以离开这个地牢。 

**输入描述:**

  每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 <= n, m <= 50），表示地牢的长和宽。接下来的 n 行，每行 m 个字符，描述地牢，地牢将至少包含两个 ‘.’。接下来的一行，包含两个整数 x0, y0，表示牛牛的出发位置（0 <= x0 < n, 0 <= y0 < m，左上角的坐标为 （0, 0），出发位置一定是 ‘.’）。之后的一行包含一个整数 k（0 < k <= 50）表示牛牛合法的步长数，接下来的 k 行，每行两个整数 dx, dy 表示每次可选择移动的行和列步长（-50 <= dx, dy <= 50）

**输出描述:**

  输出一行一个数字表示最坏情况下需要多少次移动可以离开地牢，如果永远无法离开，输出 -1。以下测试用例中，牛牛可以上下左右移动，在所有可通行的位置.上，地牢出口如果被设置在右下角，牛牛想离开需要移动的次数最多，为3次。

**输入例子:**

  3 3 

  … 

  … 

  … 

  0 1 

  4 

  1 0 

  0 1 

  -1 0 

  0 -1
**输出例子:**

  3

题意理解： 

1. 移动是瞬移，可以跨越障碍，只要目的地可以通行 

2. 在所有可以通行的位置放置出口，找出需要最短步数最长的出口，返回此到出口的最短步长 

3. 如果存在任何一个可以通行的点无法到达情况，返回-1
注：出题人：题意你能理解，就算我输

求源节点到所有节点的**最短路径**

```cpp
#include <iostream>
#include <numeric>
#include <algorithm>
#include <string>
#include <hash_map>
#include <set>
using namespace std;
//#define debug_
int n, m;
vector<vector<int>> vec;
vector<pair<int, int>> step;
int x, y;
int k;

int func()
{
    vec[x][y] = 0;
    int x_, y_;
    int flag(0);
    int result(-1);
    while (1)
    {
        flag = 0;
        for (auto i = 0; i < vec.size(); ++i)
        {
            for (auto j = 0; j < vec[0].size(); ++j)
            {
                if (vec[i][j] != 999999 && vec[i][j] != -1)
                {
                    for (auto k = 0; k < step.size(); ++k)
                    {
                        x_ = i + step[k].first;
                        y_ = j + step[k].second;
                        if (x_ < 0 || x_ >= n || y_ < 0 || y_ >= m)
                        {
                            continue;
                        }

                        if (vec[x_][y_] == -1)
                            continue;

                        if (vec[x_][y_]>vec[i][j]+1)
                        {
                            flag = 1;
                            vec[x_][y_] = vec[i][j] + 1;
                        }
                    }
                }
            }
        }

        if (flag == 0)
        {
            break;
        }
    }

    for (auto i = 0; i < vec.size(); ++i)
    {
        for (auto j = 0; j < vec[0].size(); ++j)
        {
            if (vec[i][j] == -1)
            {
                continue;
            }
            if (vec[i][j] == 999999)
            {
                return -1;
            }
            else
            {
                result = max(result, vec[i][j]);
            }
        }
    }
    return result;
}

int main()
{

#ifdef debug_
    n= 3;
    m=3;
    vec.resize(n);
    for (auto i = 0;i<n;++i)
    {
        vec[i].resize(m,-1);
    }
    x = 0;
    y = 1;
    k = 4;

    step.resize(k);
    step[0].first = 1;
    step[0].second = 0;

    step[1].first = 0;
    step[1].second = 1;

    step[2].first = -1;
    step[2].second =  0;

    step[3].first = 0;
    step[3].second = -1;
    outx = n - 1;
    for (auto i = 0; i < m; i++)
    {
        if (vec[n - 1][i] != -1)
        {
            outy = i;
        }
    }
#else
    cin>>n;
    cin >> m;
    vec.resize(n);
    for (auto i = 0; i < n; ++i)
    {
        vec[i].resize(m);
    }
    char c;
    for (auto i = 0;i<n;++i)
    {
        for (auto j = 0;j<m;++j)
        {
            cin >> c;
            if (c == '.')
            {
                vec[i][j] = 999999;
            }
            else
            {
                vec[i][j]  = -1;
            }
        }
    }
    cin >> x;
    cin >> y;
    cin >> k;
    step.resize(k);
    for (auto i = 0;i<k;++i)
    {
        cin >> step[i].first;
        cin >> step[i].second;
    }

#endif
    cout << func() << endl;

    return 0;
}
```






