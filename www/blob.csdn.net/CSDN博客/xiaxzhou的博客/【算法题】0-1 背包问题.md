# 【算法题】0-1 背包问题 - xiaxzhou的博客 - CSDN博客





2017年05月15日 22:25:14[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：210








> 
问题如图：


![这里写图片描述](https://img-blog.csdn.net/20170515204848543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlheHpob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> 
**常规动态规划解法**


**使用二维数组：**

```cpp
#include<stdio.h>
#include<vector>
#include <algorithm>
using namespace std;

int main()
{
    int B(0);
    int pi, vi;
    vector<int> P;
    vector<int> V;
    P.resize(3000);
    V.resize(3000);
    int n(0);
    scanf("%d", &B);
    while (1)
    {
        scanf("%d", &P[n]);
        scanf("%d", &V[n]);
        ++n;
        char c = getchar();
        if (c == '\n')
        {
            break;
        }
    }
    vector<vector<int>> F;
    F.resize(n);
    for (auto i = 0; i < n;++i)
    {
        F[i].resize(B+1);
    }

    //初始化F[0][j]
    for (auto j = 0; j < P[0];++j)
        F[0][j] = 0;
    for (auto j = P[0]; j <=B; ++j)
        F[0][j] = V[0];

    for (auto i = 1; i < n; ++i)
    {
        for (auto j = 0; j < P[i];++j)
        {
            F[i][j] = F[i - 1][j];
        }
        for (auto j = P[i]; j <= B;++j)
        {
            F[i][j] = max(F[i-1][j],F[i-1][j-P[i]]+V[i]);
        }
    }
    printf("%d\n", F[n-1][B]);
    return 0;
}
```

> 
常规方法需要M*N 内存，为了**节省内存**，可使用一维数组，内存需求可降低到M 

  参见：[http://blog.csdn.net/qq_32036091/article/details/51301912](http://blog.csdn.net/qq_32036091/article/details/51301912)


```cpp
#include<stdio.h>
#include<vector>
#include <algorithm>
using namespace std;

int main()
{
    int B(0);
    int pi, vi;
    vector<int> P;
    vector<int> V;
    P.resize(3000);
    V.resize(3000);
    int n(0);
    scanf("%d", &B);
    while (1)
    {
        scanf("%d", &P[n]);
        scanf("%d", &V[n]);
        ++n;
        char c = getchar();
        if (c == '\n')
        {
            break;
        }
    }
    vector<int> F;
    F.resize(B+1);

    for (auto i = 0; i < n;++i)
    {
        for (auto j = B; j >= P[i];--j)
        {
            F[j] = max(F[j],F[j-P[i]]+V[i]);
        }
    }

    printf("%d\n", F[B]);
    return 0;
}
```



