# 【算法题】编程测试：射击场 - xiaxzhou的博客 - CSDN博客





2017年08月17日 10:50:38[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：1089








> 
在某射击场有N个靶，每个靶上都有一个分数，存在score数组中，击中第i个靶的得分为score[left]*score[i]*score[right]，同时原left和right两个靶变为相邻的靶，其中得分为0的靶是不能射击的，当left不存在或者不能射击时，得分为score[i]*score[right],同理，right也遵循此规则，当left和right都不存在或者都不能射击时，得分为score[i]，请计算出击中所有能射击的靶，最多得多少分？   

输入样例 :4 2 3 0 3    

输出结果:12


第一想法是用0将数组截成多个小数组，分别计算最大分数后求和。

对于每个小数组使用动态规划计算最大分数：
- 1：不正确的状态方程：自顶向下



$dp[1,2,...,n] = \\max\{ dp[1,...i-1,i+1,...n]+array[i-1]*array[i]*array[i+1]\}$

这种原问题和“子问题”不是一致的，**不能继续分解**
- 2：正确的状态方程：自底向上 


$dp[1,2,...,n] = \\max\{ dp[1,...i-1]+dp[i+1,...n]+dp[1,..i-1]*array[i]*dp[i+1,...n]\}$

时间复杂度：

$T(n) = 2T(n/2)+f(n)$

$f(n) = O(n) = O(n^{log_22})$

$T(n) = O(n^{log_22}*log(n)) = O(nlog(n))$

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;
//#define debug_

int func(vector<int>& nums) {
    int N = nums.size();
    nums.insert(nums.begin(), 1);
    nums.insert(nums.end(), 1);

    vector<vector<int>> rangeValues(nums.size(), vector<int>(nums.size(), 0));

    for (int len = 1; len <= N; ++len) {
        for (int start = 1; start <= N - len + 1; ++start) {
            int end = start + len - 1;
            int bestCoins = 0;
            for (int final = start; final <= end; ++final) {
                int coins = rangeValues[start][final - 1] + rangeValues[final + 1][end];
                coins += nums[start - 1] * nums[final] * nums[end + 1];
                if (coins > bestCoins) bestCoins = coins;
            }
            rangeValues[start][end] = bestCoins;
        }
    }
    return rangeValues[1][N];
}

int main()
{
    int n(0);
#ifdef debug_

#else
    cin >> n;
    int k;
    long long sum(0);
    vector<int> vec;
    for (auto i = 0; i < n;++i)
    {
        cin >> k;
        if (k == 0)
        {
            sum += func(vec);
            vec.clear();
        }
        else
        {
            vec.push_back(k);
        }
    }
#endif
    sum += func(vec);

    cout << sum;
    return 0;
}
```



