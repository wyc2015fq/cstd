# 【算法题】分田地 - xiaxzhou的博客 - CSDN博客





2017年06月03日 22:21:14[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：378








> 
牛牛和 15 个朋友来玩打土豪分田地的游戏，牛牛决定让你来分田地，地主的田地可以看成是一个矩形，每个位置有一个价值。分割田地的方法是横竖各切三刀，分成 16 份，作为领导干部，牛牛总是会选择其中总价值最小的一份田地， 作为牛牛最好的朋友，你希望牛牛取得的田地的价值和尽可能大，你知道这个值最大可以是多少吗？ 

**输入描述:**

  每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 <= n, m <= 75），表示田地的大小，接下来的 n 行，每行包含 m 个 0-9 之间的数字，表示每块位置的价值。

**输出描述:**

  输出一行表示牛牛所能取得的最大的价值。

**输入例子:**

  4 4 

  3332 

  3233 

  3332 

  2323
**输出例子:**

  2

一直没思路，看了大佬的代码，使用了二分查找
- 快速计算**矩阵块之和**：

先求出矩阵vec的累加矩阵sum： 


$sum[i][j]  = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + vec[i-1][j-1] $

则矩阵块vec[x1-x1][y1-y2] 元素之和为：

$sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]$

–
- **二分查找**：

暴力循序时间复杂度太高，使用二分查找法，最大的最小区域值取值范围为0-sum[i-1][j-1]，在此范围内二分查找可以使得判定函数(ValidCut)为真的最大值。

ValidCut函数用于判定矩阵是否能划分出最小区域大于等于给定值，暴力搜索横向的所有切法，而纵向切法类似贪心，具体细节见代码。

–
- **输入导致超时**

我自己写的输入是不断地读取单个数字，

```
for (auto i = 1; i <= row ; ++i)
    {
        for (auto j = 1; j <= col ; ++j)
        {
            cin >> sum[i][j];
            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
```

结果**超时**，调了好久

最后使用了大佬的代码，一次读取一行，终于通过了：

```
for (size_t i = 1; i <= row; ++i) {
        string str;
        cin >> str;
        for (size_t j = 1; j <= col; ++j) {
            sum[i][j] = str[j - 1] - '0';
            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
```
- 代码：

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include<algorithm>
#include <string>
using namespace std;

//#define debug_
int getvalue(vector<vector<int>>& sum, int x1, int y1, int x2, int y2)
{
    return sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];
}

bool ValidCut(vector<vector<int>>& sum, int mid)
{
    int n = sum.size();
    int m = sum[0].size();

    int cuttime(0);//可切次数
    int lastcut, currentcut;//上次切的位置 和 当前切的位置

    for (auto x1 = 1; x1 < n - 3; ++x1)
    {
        for (auto x2 = x1 + 1; x2 < n - 2; ++x2)
        {
            for (auto x3 = x2 + 1; x3 < n - 1; ++x3)//遍历横向的所有可能切法
            {
                cuttime = 0;
                lastcut = 0;
                for (currentcut = 1; currentcut < m; ++currentcut)//能否切出： 最小块 > mid
                {
                    int s1 = getvalue(sum, 0, lastcut, x1, currentcut);
                    int s2 = getvalue(sum, x1, lastcut, x2, currentcut);
                    int s3 = getvalue(sum, x2, lastcut, x3, currentcut);
                    int s4 = getvalue(sum, x3, lastcut, n - 1, currentcut);

                    if (min(min(s1, s2), min(s3, s4)) >= mid)
                    {
                        lastcut = currentcut;
                        cuttime++;
                    }
                }
                if (cuttime >= 4)
                {
                    return true;
                }
            }
        }
    }
    return false;
}


int BinSearch(vector<vector<int>> & sum)
{
    int n = sum.size();
    int m = sum[0].size();
    int left = 0;
    int right = sum[n - 1][m - 1];
    int mid = (left + right)/2;

    int record(0);

    while (left <= right)//二分查找
    {
        mid = left + right >> 1;

        if (ValidCut(sum, mid))
        {
            record = mid;
            left = mid + 1;//***
        }
        else
        {
            right = mid - 1;//***
        }
    }
    return record;
}

int main()
{
    int row;
    int col;
    cin >> row >> col;
    vector<vector<int>> sum(row + 1, vector<int>(col + 1, 0));

    //for (auto i = 1; i <= row ; ++i)
    //{
    //  for (auto j = 1; j <= col ; ++j)
    //  {
    //      cin >> sum[i][j];
    //      sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
    //  }
    //}


    for (size_t i = 1; i <= row; ++i) {
        string str;
        cin >> str;
        for (size_t j = 1; j <= col; ++j) {
            sum[i][j] = str[j - 1] - '0';
            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
    cout << BinSearch(sum) << endl;

    return 0;
}
```





