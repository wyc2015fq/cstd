# 【算法题】2018今日头条编程题一 - xiaxzhou的博客 - CSDN博客





2017年08月23日 11:47:34[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：542








![这里写图片描述](https://img-blog.csdn.net/20170823113937605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlheHpob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

维持一个当前边界点的数组，按x从小到达排序，由于是边界点，故其y对应是从大到小排序的。

对于一个新加入的点，分别按x和y坐标值**二分查找**其在边界点数组中的位置：iter_x ,  iter_y
- 
若iter_x == iter_y： 

则直接插入新边界点

- 
若iter_x < iter_y ： 

非边界点

- 
若iter_x>iter_y： 

删除iter_x 与iter_y之间的无效边界点，并插入新边界点


```cpp
#include <stdio.h>
#include <vector>
#include <numeric>
#include <algorithm>
#include <iostream>
#include <list>
using namespace std;
//#define debug_
int N;
struct point
{
    int x;
    int y;
};
typedef vector<point>::iterator iter;

vector<point> vec;

void func()
{
    vector<point> Bound;
    iter iter_x, iter_y;

    for (auto i = 0; i < N;++i)
    {
        iter_x = lower_bound(Bound.begin(), Bound.end(), vec[i], [](const point& lhs, const point& rhs){ return lhs.x < rhs.x; });
        iter_y = lower_bound(Bound.begin(), Bound.end(), vec[i], [](const point& lhs, const point& rhs){ return lhs.y >= rhs.y; });
        if (iter_x == iter_y)
        {
            Bound.insert(iter_x,vec[i]);
            continue;
        }
        if (iter_x<iter_y)
        {
            continue;
        }
        else
        {
            iter_x = Bound.erase(iter_y, iter_x);
            Bound.insert(iter_x, vec[i]);
        }
    }
    for (auto i = 0; i < Bound.size();++i)
    {
        cout << Bound[i].x << " " << Bound[i].y << endl;
    }
}

int main()
{
#ifdef debug_
    N = 5;
    vec.resize(N);
    vec[0].x = 1;
    vec[0].y = 2;
    vec[1].x = 5;
    vec[1].y = 3;
    vec[2].x = 4;
    vec[2].y = 6;
    vec[3].x = 7;
    vec[3].y = 5;
    vec[4].x = 7;
    vec[4].y = 6;
#else
    cin >> N;
    vec.resize(N);
    for (auto i = 0; i < N;++i)
    {
        cin>>vec[i].x;
        cin>>vec[i].y;
    }
#endif
    func();
    return 0;
}
```



