# 【算法题】判断二叉树平衡性 - xiaxzhou的博客 - CSDN博客





2017年06月04日 21:53:45[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：218标签：[二叉树																[二叉树深度																[平衡二叉树](https://so.csdn.net/so/search/s.do?q=平衡二叉树&t=blog)
个人分类：[程序员面试笔试宝典																[剑指offer](https://blog.csdn.net/xiaxzhou/article/category/6949916)](https://blog.csdn.net/xiaxzhou/article/category/6949915)





由平衡二叉树的定义可知，每个节点的左右子树的高度差要小于等于1
- 可以用递归实现，在遍历二叉树各节点事，若节点的左右子树的深度之差不超过1，则是平衡二叉树。

```
int getDepth(Tree*root){
    if (root == NULL)
        return 0;
    int leftDepth = getDepth(root->left);
    int rightDepth = getDepth(root->right);
    return leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1;
}

bool IsBalanced(Tree* root)
{
    if (root == NULL)
        return true;
    int leftDepth = getDepth(root->left);
    int rightDepth = getDepth(root->right);
    int diff = leftDepth - rightDepth;
    if (abs(diff) > 1)
        return false;
    return IsBalanced(root->left) && IsBalanced(root->right);
}
```
- 上述方法在求该结点的的左右子树深度时遍历一遍树，再次判断子树的平衡性时又遍历一遍树结构，造成遍历多次。因此方法二是一边遍历树一边判断每个结点是否具有平衡性

```
bool IsBalancedCore(Tree* root, int& depth)
{
    if (root == NULL)
    {
        depth = 0;
        return true;
    }
    int leftdepth(0), rightdepth(0);
    bool leftbalanced = IsBalancedCore(root->left, leftdepth);
    bool rightbalanced = IsBalancedCore(root->right, rightdepth);
    bool rootbalenced = abs(leftbalanced - rightbalanced) < 2;
    depth = max(leftdepth, rightdepth)+1;
    return leftbalanced&&rightbalanced&&rootbalenced;
}

bool IsBalanced(Tree* root)
{
    int i(0);
    return IsBalancedCore(root, i);
}
```](https://so.csdn.net/so/search/s.do?q=二叉树深度&t=blog)](https://so.csdn.net/so/search/s.do?q=二叉树&t=blog)




