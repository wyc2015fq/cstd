# 【算法题】生日礼物 - xiaxzhou的博客 - CSDN博客





2017年06月23日 19:36:21[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：784
个人分类：[京东2016编程题](https://blog.csdn.net/xiaxzhou/article/category/6987919)









题目描述

BF的生日快到了，这一次，小东决定为BF送一份特别的生日礼物为其庆生。作为高智商中的佼佼者，BF在国外求学，因此小东无法与之一起庆生。小东计划送一个生日卡片，并通过特别的包装让BF永远难忘。

她决定把卡片套装在一系列的信封A = {a1,  a2,  …,  an}中。小东已经从商店中购买了很多的信封，她希望能够用手头中尽可能多的信封包装卡片。为防止卡片或信封被损坏，只有长宽较小的信封能够装入大些的信封，同尺寸的信封不能套装，卡片和信封都不能折叠。

小东计算了邮寄的时间，发现她的时间已经不够了，为此找你帮忙包装，你能帮她吗？

> 
输入 

  输入有若干组，每组的第一行包含三个整数n, w, h，1<=n<=5000, 1<=w, h<=10^6，分别表示小东手头的信封数量和卡片的大小。紧随其后的n行中，每行有两个整数wi和hi，为第i个信封的大小，1<=wi, hi<=10^6。 
**样例输入**

  2 1 1 

  2 2 

  2 2 

  3 3 3 

  5 4 

  12 11 

  9 8
输出 

  对每组测试数据，结果第一行中输出最多能够使用的信封数量，结果第二行中按使用顺序输出信封的编号。由于小东有洁癖，她对排在前面的信封比较有好感，若有多个信封可用，她喜欢用最先拿到的信封。另外别忘了，小东要求把卡片装入能够装的最小信封中。 

  如果卡片无法装入任何信封中，则在单独的行中输出0。
**样例输出**

  1 

  1 

  3 

  1 3 2
分析：BFS



$dp[j] = max\begin{cases}dp[i] + 1& w_i<w_i且h_i<h_j\\  \\dp[j]\\\end{cases}$

**题意不明确：**

5 1000 998 

5002 5005 

5003 5004 

5003 5002 

5002 5001 

5002 5002
标准答案是 

2 

4 2 

说明： 

1. 东要求把卡片装入能够装的最小信封中：这个小，比较的只有信封的宽度 

2. 只有长宽较小的信封能够装入大些的信封的意思是： 

必须 ：`w1<w2 && h1<h2   不可以 w1<h2&&h1<w2`
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <utility>
#include <set>
#include <numeric>
#include <queue>

using namespace std;
//#define debug_
int n, w, h;
vector<pair<int, int>> vec;

void func()
{
    vector<int> dp(n + 1);
    queue<int> que;
    que.push(0);

    while (!que.empty())
    {
        int cur_index = que.front();
        que.pop();
        int cur_w = vec[cur_index].first;
        int cur_h = vec[cur_index].second;
        for (auto j = 0; j < vec.size(); ++j)
        {
            if ((cur_w < vec[j].first&&cur_h < vec[j].second))//|| (cur_w<vec[j].second&&cur_h<vec[j].first) )
            {
                if (dp[cur_index] + 1 > dp[j])
                {
                    dp[j] = dp[cur_index] + 1;
                    que.push(j);
                }
            }
        }
    }
    vector<int> print_vec;
    int max_num(0);
    int index(0);
    for (auto i = 0; i < dp.size(); ++i)
    {
        if (max_num<dp[i])
        {
            max_num = dp[i];
            index = i;
        }
        else if (max_num == dp[i])
        {
            if (vec[index].first > vec[i].first)
            {
                index = i;
            }
        }
    }
    if (max_num == 0)
    {
        cout << "0" << endl;
        return;
    }
    cout << max_num << endl;
    print_vec.insert(print_vec.begin(), index);

    while (index)
    {
        for (auto j = 0; j < vec.size(); ++j)
        {
            int cur_w = vec[j].first;
            int cur_h = vec[j].second;
            if (dp[j] + 1 == dp[index])
            {
                if ((cur_w < vec[index].first&&cur_h < vec[index].second))//|| (cur_w<vec[index].second&&cur_h<vec[index].first))
                {
                    index = j;
                    print_vec.insert(print_vec.begin(), j);
                    break;
                }
            }
        }
    }
    for (auto i = 1; i < print_vec.size(); ++i)
    {
        cout << print_vec[i] << " ";
    }
    cout << endl;
}

int main()
{

#ifdef debug_
    n = 3;
    w = 3;
    h = 3;
    vec.push_back(pair<int, int>(3, 3));
    vec.push_back(pair<int, int>(5, 4));
    vec.push_back(pair<int, int>(12, 11));
    vec.push_back(pair<int, int>(9, 8));
    func();
#else
    while (cin >> n >> w >> h)
    {
        vec.clear();
        vec.resize(n + 1);
        vec[0] = pair<int, int>(w, h);
        for (auto i = 1; i <= n; ++i)
        {
            cin >> vec[i].first;
            cin >> vec[i].second;
        }
        func();
    }

#endif
    return 0;

}
```









