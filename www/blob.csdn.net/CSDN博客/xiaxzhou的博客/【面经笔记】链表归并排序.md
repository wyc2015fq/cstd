# 【面经笔记】链表归并排序 - xiaxzhou的博客 - CSDN博客





2017年07月24日 21:17:18[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：159








链表适合归并排序 

时间复杂度：O（nlogn） 

空间复杂度：O（1） 

稳定性：稳定
```
#include <iostream>
using namespace std;

class Node
{
public:
    Node(){ next = NULL; val = 0; };
    Node(int i){ next = NULL; val = i; };
    Node* next;
    int val;
};

Node* merge(Node* pleft, Node* pright)
{
    if (pleft == NULL)
    {
        return pright;
    }
    if (pright == NULL)
    {
        return pleft;
    }
    Node dummy;
    Node* ptmp = &dummy;
    while (pleft != NULL&&pright != NULL)
    {
        if (pleft->val < pright->val)
        {
            ptmp->next = pleft;
            pleft = pleft->next;
            ptmp = ptmp->next;
        }
        else
        {
            ptmp->next = pright; 
            pright = pright->next;
            ptmp = ptmp->next;
        }
    }
    if (pleft!=NULL)
    {
        ptmp->next = pleft;
    }
    if (pright!=NULL)
    {
        ptmp->next = pright;
    }
    return dummy.next;
}

Node * MergeSort(Node * phead)
{
    if (phead == NULL|| phead->next == NULL)
    {
        return phead;
    }
    Node * pfast(phead);
    Node * pslow(phead);

    while (pfast->next != NULL&&pfast->next->next != NULL)
    //while (pfast != NULL&&pfast->next != NULL)错误，无法分割两个点
    {
        pfast = pfast->next->next;
        pslow = pslow->next;
    }
    Node * pleftpart = phead;
    Node * prightpart = pslow->next;
    pslow->next = NULL;

    pleftpart = MergeSort(pleftpart);
    prightpart = MergeSort(prightpart);

    return merge(pleftpart, prightpart);
}

int main()
{
    Node n1(4);
    Node n2(3);
    Node n3(2);
    Node n4(1);
    n1.next = &n2;
    n2.next = &n3;
    n3.next = &n4;

    auto tmp = MergeSort(&n1);
    while (tmp)
    {
        cout << tmp->val << endl;
        tmp = tmp->next;
    }
    return 0;
}
```

查找中间节点使用快慢指针

while (pfast != NULL&&pfast->next != NULL) //无法分割两个点的情况




