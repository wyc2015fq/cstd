# 【算法题】疯狂的队列 - xiaxzhou的博客 - CSDN博客





2017年08月13日 09:42:18[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：895
个人分类：[网易2017秋招编程题](https://blog.csdn.net/xiaxzhou/article/category/6949755)









> 
小易老师是非常严厉的,它会要求所有学生在进入教室前都排成一列,并且他要求学生按照身高不递减的顺序排列。有一次,n个学生在列队的时候,小易老师正好去卫生间了。学生们终于有机会反击了,于是学生们决定来一次疯狂的队列,他们定义一个队列的疯狂值为每对相邻排列学生身高差的绝对值总和。由于按照身高顺序排列的队列的疯狂值是最小的,他们当然决定按照疯狂值最大的顺序来进行列队。现在给出n个学生的身高,请计算出这些学生列队的最大可能的疯狂值。小易老师回来一定会气得半死。 

输入描述: 

  输入包括两行,第一行一个整数n(1 ≤ n ≤ 50),表示学生的人数 

  第二行为n个整数h[i](1 ≤ h[i] ≤ 1000),表示每个学生的身高
输出描述: 

  输出一个整数,表示n个学生列队可以获得的最大的疯狂值。

如样例所示:  

  当队列排列顺序是: 25-10-40-5-25, 身高差绝对值的总和为15+30+35+20=100。 

  这是最大的疯狂值了。
输入例子1: 

  5 

  5 10 25 40 25
输出例子1: 

  100

贪心算法：首先数组排序。然后 

将最大值排中间， 

最小的两个值排两边， 

再将剩下的最大值和次大值加排在两边， 

依次类推，，，，
```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//#define debug_
int n;
vector<int> vec;

int func()
{
    sort(vec.begin(), vec.end());
    int count(0);

    int left(0), right(vec.size()-2);
    count += 2*vec.back() - vec[left] - vec[left + 1];

    while (1)
    {
        if (left + 2 >= right)
        {
            if (left < right)
            {
                count += vec[right] - vec[left];
            }
            break;
        }
        count += vec[right] + vec[right - 1] - vec[left] - vec[left + 1];
        left += 2;

        if (left + 2 >= right)
        {
            if (left < right)
            {
                count += vec[right] - vec[left];
            }
            break;
        }
        count += vec[right] + vec[right - 1] - vec[left] - vec[left + 1];
        right -= 2;
    }
    return count;

}

int main()
{
#ifdef debug_
    n = 5;
    vec.push_back(5);
    vec.push_back(10);
    vec.push_back(25);
    vec.push_back(40);
    vec.push_back(25);
#else
    cin >> n;
    vec.resize(n);
    for (auto i = 0; i < n; i++)
    {
        cin >> vec[i];
    }
#endif
    cout<<func();
    return 0;
}
```








