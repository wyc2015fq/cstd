# 【面经笔记】哈希表 - xiaxzhou的博客 - CSDN博客





2017年07月15日 18:25:54[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：215








> 
[http://blog.csdn.net/xxpresent/article/details/55806298](http://blog.csdn.net/xxpresent/article/details/55806298)


哈希表几种方法：
- 直接定址法：取关键字key的某个线性函数为散列地址 Hash(key) = A*key+B
- 除留取余法 ：关键值除以比散列表长度小的素数所得的余数作为散列地址 Hash(key) = key % p;
- 字符串：BKDR哈希算法（字符串哈希算法）

```
size_t BKDRHash(const char* str)  //字符串哈希算法
    {  
        register size_t hash = 0;  
        while(*str)  
        {  
            hash = hash*131 + *str;  
            ++str;  
        }  
        return hash;  
    }
```

处理哈希冲突的闭散列方法： 

闭散列：
- 线性探测

检测当前地址的下一个地址是否可以插入，如果可以的话，就存在当前位置的下一个地址，否则，继续向下一个地址寻找，地址++
- 二次探测：

通过二次探测的方法，取当前地址加上i^2，可以取到的新的地址就会稍微分散开。

```
pair<Node*, bool> Insert(const K& key, const V& value)
    {
        _CheckCapacity();
        size_t index = HashFunc(key);
        //线性探测  
        /*while(_tables[index]._status ==  EXIST )
        {
        if(_tables[index]._key == key)
        return make_pair((Node*)NULL,false);
        ++index;

        if(index == _tables.size())
        {
        index = 0;
        }
        }
        */
        //二次探测  
        size_t i = 0;
        size_t first = index;
        while (_tables[index]._status == EXIST)
        {
            if (_tables[index]._key == key)
                return make_pair((Node*)NULL, false);
            ++i;
            index = first + i*i;
            index %= _tables.size();
        }
        ++_size;
        _tables[index]._key = key;
        _tables[index]._value = value;
        _tables[index]._status = EXIST;
        return make_pair(&_tables[index], true);
    }

    Node* Find(const K& key, const V& value)
    {
        size_t index = HashFunc(key);
        while (_tables[index]._status != EMPTY)
        {
            if (_tables[index]._key == key && _tables[index]._status == EXIST)
            {
                return &_tables[index];
            }
            else
            {
                ++index;
                if (index == _tables.size())
                {
                    index = 0;
                }
            }
        }
        return NULL;
    }
```
- 开链法（哈希桶）

当用线性探测和二次探测时，总是在一个有限的哈希表中存储数据，当数据特别多时，效率就比较低。因此采用拉链法的方式来降低哈希冲突，

```
pair<Iterator,bool> Insert(pair<K,V> kv)  
        {  
            _CheckCapacity();  
            size_t index = HashFunc(kv.first);  
            Node* cur = _tables[index];  
            while(cur)  
            {  
                if(cur->_kv.first == kv.first)  
                {  
                    return make_pair(Iterator(cur,this),false);  
                }  
                cur = cur->_next;  
            }  
            Node* tmp = new Node(kv);  
            tmp->_next = _tables[index];  
            _tables[index] = tmp;  
            _size++;  
            return make_pair(Iterator(tmp,this),true);  
        }  

        Node* Find(const K& key)  
        {  
            size_t index = HashFunc(key);  
            Node* cur = _tables[index];  
            while(cur)  
            {  
                if(cur->_kv.first == key)  
                {  
                    return cur;  
                }  
                cur = cur->_next;  
            }  
            return NULL;  
        }
```

SGI STL的hash_table就是采用**开链法**

迭代器在遍历完当前桶后跳转到下一个桶之中。

开链法不要求表格大小必须为质数，但是SGI STL仍以质数设计表格大小：**先将28个质数计算好，同时提供函数查询在这28个质数中最接近某数并大于某数的质数。**

### 装载因子：

每个槽的平均存储元素个数

给定一个存放n个元素的、具有m个槽位的散列表，装载因子为： $\alpha =n/m $。

开放散列寻址的散列表的装载因子小于等于1， 

开链法的装载因子即每个链中的平均元素个数，最大值可大于1。

### 开链法的时间复杂度：

一次不成功的查找的平均时间复杂度为：$O（1+\alpha）$

一次成功的查找的平均时间复杂度为：$O（1+\alpha）$

当$\alpha=1$时 ，时间复杂度为理想值：O（1）

### 完全散列：

[http://blog.csdn.net/ture010love/article/details/6664501](http://blog.csdn.net/ture010love/article/details/6664501)

完全散列将关键字通过一级散列函数h1和二级散列函数h2后映射到二级散列中，其中，关键字个数等于桶数(n=m)，二级散列的大小N(T[i])为关键字个数的平方，用以保证完全O(n)的存储空间，以及O(1)的访问效率。但实际上，不可能真正地完全实现无冲突。

### 了解一致哈希吗？

[http://blog.csdn.net/cywosp/article/details/23397179](http://blog.csdn.net/cywosp/article/details/23397179)



