# 【算法题】对称二叉树判断 - xiaxzhou的博客 - CSDN博客





2017年09月02日 18:50:08[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：178标签：[二叉树](https://so.csdn.net/so/search/s.do?q=二叉树&t=blog)
个人分类：[面试题																[数据结构](https://blog.csdn.net/xiaxzhou/article/category/7119623)](https://blog.csdn.net/xiaxzhou/article/category/7119468)








### 解法1：

分层遍历二叉树，判断每一层的节点是否轴对称。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;
#define debug_

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
        val(x), left(NULL), right(NULL) {}
};

bool isok(vector<TreeNode*>& vec)
{
    int i = 0, j = vec.size() - 1;
    while (i < j)
    {
        if ((vec[i] == NULL&&vec[j] != NULL) || (vec[i] != NULL&&vec[j] == NULL))
        {
            return false;
        }
        if (vec[i]==NULL&&vec[j]==NULL)//考虑对称的空节点
        {
            i++;
            j--;
            continue;
        }
        if (vec[i]->val != vec[j]->val)
        {
            return false;
        }
        i++;
        j--;
    }
    return true;
}

bool isSymmetrical(TreeNode* pRoot)
{
        if (pRoot == NULL)
        {
            return true;
        }
        vector<TreeNode*> vec_old;
        vector<TreeNode*> vec_new;

        vec_old.push_back(pRoot);
        while (!vec_old.empty())
        {
            if (!isok(vec_old))
            {
                return false;
            }
            for (auto i = 0; i < vec_old.size(); ++i)
            {
                if (vec_old[i] == NULL)
                {
                    continue;
                }
                vec_new.push_back(vec_old[i]->left);
                vec_new.push_back(vec_old[i]->right);
            }
            swap(vec_old, vec_new);
            vec_new.clear();
        }
        return true;
}

int p = 0;
TreeNode* DeSerialByPre(char* str)
{
    if (str[p] == '#'){
        p += 2;
        return NULL;

    }
    TreeNode* node = new TreeNode(str[p]);
    p += 2;
    node->left = DeSerialByPre(str);
    node->right = DeSerialByPre(str);
    return node;
}

int main()
{
    char* str = "8!6!5!#!#!7!#!#!6!7!#!#!5!#!#!";
    TreeNode* root;
    root = DeSerialByPre(str);

    cout<<isSymmetrical(root);
#ifdef debug_
#else
#endif
    return 0;
}
```

解法2：前序遍历与对称前序遍历

```
bool isSymmetrical(TreeNode* pRoot1, TreeNode* pRoot2)
{
    if (pRoot1 == NULL && pRoot2 == NULL)
    {
        return true;
    }
    if (pRoot1 == NULL || pRoot2 == NULL)
    {
        return false;
    }
    if (pRoot1->val != pRoot2->val)
    {
        return false;
    }
    return isSymmetrical(pRoot1->left, pRoot2->right) && isSymmetrical(pRoot1->right, pRoot2->left);
}

bool isSymmetrical(TreeNode* pRoot)
{
    return isSymmetrical(pRoot, pRoot);
}
```




