# 【读书笔记】同步设备I/O与异步设备I/O - xiaxzhou的博客 - CSDN博客





2017年09月06日 09:18:40[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：219








## 同步IO

最方便和常用的对设备数据进行读写的函数时ReadFile和WriteFile。 

打开设备时如：CreatFile、WSASocket。没有指定FILE_FLAG_VERLAPPED标志，则执行同步IO操作。

## 异步IO

打开设备时如：CreatFile、WSASocket。指定FILE_FLAG_VERLAPPED标志，则执行异步IO操作。

当调用ReadFile（）或WriteFile（）时，函数会检查hFile参数标识的设备是否是用**FILE_FLAG_OVERLAPPED**标志打开的。如果是，则执行异步I/O。

## OVERLAPPED结构

执行异步IO时，必须在ReadFile（）或WriteFile（）参数中的pOverlapped参数中传入一个已经初始化的OVERLAPPED结构。

OVERLAPPED结构包含以下成员：

1、偏移量：为了避免对同一个对象进行多个异步调用时出现混淆，所有异步IO请求必须指定偏移量。非文件设备会忽略此成员。

2、hEvetn成员：用来接收I/O完成通知的4种方式的一种会用到这个成员。

3、Internal成员：保存IO请求错误码

4、InternalHight成员：保存已传输字节数。

使用技巧：**异步IO请求完成时，会收到一个OVERLAPPED结构的地址，它就是我们发出请求时使用的那个**。故可以派生OVERLAPPED类，用于传输其他一些附加信息。

## 异步IO注意事项
- 
1 . 设备驱动程序不是先入先出处理IO请求的

- 
2 . 当将一个异步IO请求添加到队列中的时候，设备驱动程序可能选择同步的方式处理请求！如当我们读取文件数据时，如果数据已经在缓存中，系统就不会将请求添加到设备驱动程序的队列中，而会将高速缓存中的数据复制到我们的额缓存中，从而完成这个IO操作。


> 
如果请求的IO操作是以同步的方式执行的，那么ReadFile（）/WriteFile（）会返回非零值。如果IO是以异步方式执行的执行，或者发生了错误，则返回FALSE（0）。

- 3 .异步IO请求完成之前，一定不能移动或者销毁发出请求时使用的数据缓存和OVERLAPPED结构。**设备驱动程序会使用数据缓存和OVERLAPPED结构。我们必须为每个IO请求分配、初始化一个独立的OVERLAPPED结构。**

## 接收I/O请求完成通知

设备驱动程序如何通知我们IO请求已经完成？ 

windows提供了4种方法：
- 触发设备内核对象
- 触发事件内核对象
- 使用可提醒I/O
- 使用I/O完成端口
|技术|特点|优缺点|
|----|----|----|
|触发设备内核对象|允许一个线程发出I/O请求，另一个线程对结果进行处理|当向一个设备发出多个I/O请求，只要任何一个I/O请求完成时都会被触发，却没办法区别是哪个请求的完成触发了内核对象。|
|触发事件内核对象|允许一个线程发出I/O请求，另一个线程对结果进行处理|每个请求都通过pOverlapped与一个事件相关联，允许我们向一个设备同时发出多个I/O请求。|
|使用可警告I/O|发出I/O请求的线程必须对结果进行处理|没有负载均衡，伸缩性不好|
|使用I/O完成端口|允许一个线程发出I/O请求，另一个线程对结果进行处理|具有高度的伸缩性和最佳的灵活性|

### 触发设备内核对象

ReadFile（）/WriteFile（）函数在将I/O请求添加到队列之前，会将设备内核对象设为未触发状态。当设备驱动程序完成了请求之后，驱动程序会将设备内核对象设为触发状态。

线程可以使用WaitForSingleObject（）或者WaitForMultipleObject（）检查异步IO是否完成。

> 
WaitForMultipleObject（）可指定参数，设置：1 等待指定的内核对象中的一个被触发为止，2 等待指定的内核对象全部被触发为止


问题：

当**向一个设备同时发出多个I/O请求的时候，这种方法是不能用的**，因为等待函数中等待的是同一个内核对象，只要任何一个I/O请求完成时都会被触发，却**没办法区别是哪个请求的完成触发了内核对象**。

### 触发事件内核对象

OVERLAPPED结构的一个成员hEvent用来标识一个事件内核对象。

我们必须通过CreateEvent创建这个事件对象，当设备驱动程序完成IO请求时，会检查OVERLAPPED结构成员hEvent是否为NULL，若不是，则会触发。此时，驱动程序仍然会触发设备内核对象。

允许我们向一个设备同时发出多个I/O请求的时候。（因为每个请求都通过pOverlapped与一个事件相关联）。

如果想要同时执行多个异步IO请求，必须为每个请求创建不同的事件对象，并初始化每个请求的OVERLAPPED结构。再调用ReadFile（）/WriteFile（）。

我们只需在线程中调用WaitForMultipleObject（）并传入与每个待处理的IO请求的OVERLAPPED结构关联的事件句柄。

通过这种方式，可以同时执行多个异步IO操作并使用同一个设备对象。

### 可提醒I/O

当系统创建一个线程的时候，会同时创建一个**与线程相关联的队列**。这个队列被称为**异步过程调用** APC(asynchronous procedure call)队列。

当发出一个IO请求的时候，可以告诉设备驱动程序在调用线程的APC队列中添加一项。

为了将IO完成通知添加到线程的APC队列中，需要调用**ReadFileEx()和WriteFileEx()**函数。

*Ex函数要求传入一个回调函数的地址。回调函数被称为完成函数。

当线程处于可提醒状态的时候，系统会马上检查它的APC队列，对队列中的每一项，系统会让线程调用完成函数。

当IO请求完成的时候，系统会将它们添加到发出请求的线程的PAC队列中，回调函数不会马上被执行，这是因为线程可能在处理重要的事情，不能被打断。为了对线程的APC队列中的项进行处理，线程可通过调用等待内核对象函数将自己设置为可提醒状态。

**如果APC队列为空，线程会被挂起，直到APC队列非空，或者所等待的内核对象被出触发。**如果APC队列出现了一项，系统唤醒线程并调用回调函数，然后返回，**不会再次进入睡眠状态等待内核对象**。

可理解为：设备驱动程序完成IO请求后，系统提醒发出IO请求的线程去继续完成后续操作。

**问题：**

**发出I/O请求的线程必须对结果进行处理，因为这是通过线程的APC队列来实现的，而APC队列是线程独有的。**

### I/O完成端口

> 
创建IO完成端口


CreateIoCompletionPort()

> 
关联IO完成端口与设备


CreateIoCompletionPort()

两个函数是一样的！只是调用时传入的参数不一样。创建完成端口时，可以指定同一时间最多能有多少线程处于可运行状态。

设备必须是用**FILE_FLAG_OVERLAPPED**标志打开的。即异步IO属性。

> 
获取IO请求完成信息


GetQueuedCompletionStatus（）

线程池中的所有线程应该执行同一个函数。 

函数中，不断循环。 

循环内部，线程调用GetQueuedCompletionStatus（）将自己切换到睡眠状态，直到指定的完成端口的IO完成队列中出现一项，或者等待超时为止。
调用了GetQueuedCompletionStatus（）函数后，线程会得到已完成IO项中的所有信息。可以继续后续处理操作。
- 是否自动创建线程？

否，需要程序员自行创建线程，**并向线程传入IO完成端口的句柄**。该线程为了确认I/O的完成会调用GetQueuedCompletionStatus（）函数，并传入IO完成端口的句柄。线程就会得到指定IO完成端口中已完成IO项中的所有信息。

任何线程都能调用GetQueuedCompletionStatus（）函数，但**实际得到I/O完成信息的线程数不会超过创建CP对象时指定的最大线程数。**

## 理解：

> 
**在可提醒I/O中，设备驱动程序将将完成IO请求的信息放入发出IO请求的线程APC队列中，让发出请求的线程执行对IO结果的处理。**

**在I/O完成端口中，所有与完成端口关联了的设备，会将完成IO请求信息统一放入完成端口的线程池任务队列中，由完成端口调用线程池中的空闲线程对IO结果进行处理。**


[实例参考](http://blog.csdn.net/xiaxzhou/article/details/77159443)




