# 【算法题】买苹果 - xiaxzhou的博客 - CSDN博客





2017年06月01日 20:45:55[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：432








> 
小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装(包装不可拆分)。 可是小易现在只想购买恰好n个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小易将不会购买。 

**输入描述:**

  输入一个整数n，表示小易想购买n(1 ≤ n ≤ 100)个苹果

**输出描述:**

  输出一个整数表示最少需要购买的袋数，如果不能买恰好n个苹果则输出-1

**输入例子:**

  20

**输出例子:**

  3

动态规划： 

f(i)表示买i个苹果最少需要购买的袋数
- 
i<=8 


$f(6)=f(8) =1$


$f(1) = f(2) = ... =f(7) = -1;$- 
i>8




$f(i)=min\begin{cases}f(i-6)+1&若f(i-6)!=-1\\\\f(i-8)+1&若f(i-8)!=-1\end{cases}$

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include<algorithm>
using namespace std;

int func(int N)
{
    if ((N&1)!=0)//奇数
    {
        return -1;
    }
    vector<int> vec;
    vec.resize(101, 999);
    vec[0] = 0;
    for (auto i = 0; i < 101;i++)
    {
        if (vec[i]!=999)
        {
            if (i+6<101)
            {
                vec[i + 6] = min(vec[i + 6], vec[i] + 1);
            }
            if (i+8<101)
            {
                vec[i + 8] = min(vec[i + 8], vec[i] + 1);
            }
        }
     }

    if (vec[N]==999)
    {
        return -1;
    }
    else
    {
        return vec[N];
    }
}

 int main()
{
    int N;
    cin >> N;
    cout << func(N) << endl;
    return 0;
}
```






