# 【算法题】双核处理 - xiaxzhou的博客 - CSDN博客





2017年05月26日 20:43:59[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：542
个人分类：[动态规划](https://blog.csdn.net/xiaxzhou/article/category/6958606)









> 
时间限制：1秒 

  空间限制：32768K

一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 

**输入描述:**

  输入包括两行： 

  第一行为整数n(1 ≤ n ≤ 50) 

  第二行为n个整数length[i](1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。
**输出描述:**

  输出一个整数，表示最少需要处理的时间

**输入例子:**

  5 

  3072 3072 7168 3072 1024
**输出例子:**

  9216

这是个数组分割问题，见编程之美2.18 

基本思路是动态规划 

定义$S_k$为前k个元素的任意i个项之和$V_i$（只考虑取值小于sum/2的情况）的集合 


$S_k = \{V_i\}$

则状态转换方程为： 


$S_k = S_{k-1}U\{V_i +array[k]\}$
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;

void func(vector<int>& length)
{
    for (auto & i:length)
    {
        i = i / 1024;
    }

    long long sum = accumulate(length.begin(), length.end(), 0);
    long long half = sum / 2;

    vector<char> vec_1,vec_2;
    vec_1.resize(half + 1);
    vec_2.resize(half + 1);

    vec_1[0] = 1;

    for (auto i = 0; i < length.size();++i)
    {
        vec_2 = vec_1;
        for (auto j = 0; j < vec_1.size();++j)
        {
            if (vec_1[j] != 0 && (j + length[i])<=vec_1.size())
            {
                vec_2[j + length[i]] = 1;
            }
        }
        vec_1 = vec_2;
    }
    long long tmp;
    for (auto  i = half; i > 0; --i)
    {
        if (vec_1[i]!=0)
        {
            tmp = i;
            break;
        }
    }
    cout<< 1024*(sum - tmp);
}

int main()
{
    register int n;
    cin >> n;
    vector<int> length;
    length.resize(n);
    for (auto i = 0; i < n;++i)
    {
        cin >> length[i];
    }
    func(length);

    return 0;
}
```







