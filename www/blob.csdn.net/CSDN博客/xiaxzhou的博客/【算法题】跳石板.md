# 【算法题】跳石板 - xiaxzhou的博客 - CSDN博客





2017年06月01日 19:47:30[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：284








> 
小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3……. 

  这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。 

  例如： 

  N = 4，M = 24： 

  4->6->8->12->18->24 

  于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 
**输入描述:**

  输入为一行，有两个整数N，M，以空格隔开。 

  (4 ≤ N ≤ 100000) 

  (N ≤ M ≤ 100000)
**输出描述:**

  输出小易最少需要跳跃的步数,如果不能到达输出-1

**输入例子:**

  4 24

**输出例子:**

  5

使用数组vec[M+1]，vec[i]表示从N跳到 i 需要的最少步数，初始全部为-1. 

令vec[N] = 0

自N至M遍历数组：
- 当vec[i]==-1，说明无法到达，跳过
- 当vec[i]!=-1时，更新自i所能到达的所有石板：

对i的所有约数k: 


$vec[i+k] = min\begin{cases}vec[i]+1\\vec[i+k]&若： vec[i+k]!=-1\end{cases}$

遍历结束，返回vec[M].

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include<algorithm>
using namespace std;

int func(int n, int m)
{
    vector<int> vec;
    vec.resize(m + 1, -1);
    vec[n] = 0;

    int tmp_1, tmp_2, tmp_3;
    for (auto i = n; i < m; ++i)
    {
        if (vec[i] == -1)
        {
            continue;
        }
        tmp_1 = sqrt(i);
        for (auto j = 2; j <= tmp_1+1; ++j)
        {
            tmp_2 = i%j;
            tmp_3 = i / j;
            if ((tmp_2 == 0) && (i + j) <= m)
            {
                if (vec[i + j] == -1)
                {
                    vec[i + j] = vec[i] + 1;
                }
                else
                {
                    vec[i + j] = min(vec[i + j], vec[i] + 1);

                }
            }
            if ((tmp_2 == 0) && (i + tmp_3) <= m)
            {
                if (vec[i + tmp_3] == -1)
                {
                    vec[i + tmp_3] = vec[i] + 1;
                }
                else
                {
                    vec[i + tmp_3] = min(vec[i + tmp_3], vec[i] + 1);

                }
            }
        }
    }
    return vec[m];
}

int main()
{
    int n, m;
    cin >> n >> m;
    cout << func(n, m) << endl;

    return 0;
}
```






