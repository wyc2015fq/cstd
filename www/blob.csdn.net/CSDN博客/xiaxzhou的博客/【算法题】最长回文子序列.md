# 【算法题】最长回文子序列 - xiaxzhou的博客 - CSDN博客





2017年05月31日 14:30:37[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：209








> 
给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？ 

  输出需要**删除**的字符个数。

**输入描述:**

  输入数据有**多组**，每组包含一个字符串s，且保证:1<=s.length<=1000.

**输出描述:**

  对于每组数据，输出一个整数，代表最少需要删除的字符个数。

**输入例子:**

  abcda 

  google
**输出例子:**

  2 

  2
动态规划：f[i][j]表示以i为头，j为尾的字符串删除字符可得的最长回文串长度。

则状态转移方程为： 


$f[i][j]=max\begin{cases}f[i+1][j]\\\\f[i][j-1]\\\\f[i+1][j-1]+2&if :str[i]==str[j]\end{cases}$

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include<algorithm>
using namespace std;

int main()
{
    string str;
    while (cin >> str)
    {
        int count(0);
        int size = str.size();
        vector<vector<int>> dp;
        dp.resize(size);
        for (auto i = 0; i < size; ++i)
        {
            dp[i].resize(size);
        }

        for (auto i = 0; i < size; ++i)//i==j时
        {
            dp[i][i] = 1;
        }
        for (auto i = 0; i < size-1; ++i)//(j-i==1)时
        {
            dp[i][i+1] = 1;
            if (str[i] == str[i + 1])
            {
                dp[i][i + 1] = 2;
            }
        }
        int j;
        for (auto len = 2; len < size; ++len)//2~(size-1)
        {
            for (auto i = 0; i < size - len; ++i)
            {
                j = i + len;
                dp[i][j] = max(dp[i][j-1],dp[i+1][j]);//状态转移
                if (str[i] == str[j])
                {
                    dp[i][j] = max(dp[i][j],dp[i+1][j-1]+2);//状态转移
                }
            }
        }
        cout << size-dp[0][size-1]<<endl;
    }
    return 0;
}
```






