# 【算法题】回文序列 - xiaxzhou的博客 - CSDN博客





2017年06月01日 19:12:57[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：211
个人分类：[网易2017秋招编程题](https://blog.csdn.net/xiaxzhou/article/category/6949755)









> 
（网易2017秋招编程题） 

  如果一个数字序列逆置之后跟原序列是一样的就称这样的数字序列为回文序列。例如： 

  {1, 2, 1}, {15, 78, 78, 15} , {112} 是回文序列,  

  {1, 2, 2}, {15, 78, 87, 51} ,{112, 2, 11} 不是回文序列。 

  现在给出一个数字序列，允许使用一种转换操作： 

  选择任意两个相邻的数，然后从序列移除这两个数，并用这两个数字的和插入到这两个数之前的位置(只插入一个和)。 

  现在对于所给序列要求出最少需要多少次操作可以将其变成回文序列。
**输入描述:**

  输入为两行，第一行为序列长度n ( 1 ≤ n ≤ 50) 

  第二行为序列中的n个整数item[i]  (1 ≤ iteam[i] ≤ 1000)，以空格分隔。
**输出描述:**

  输出一个数，表示最少需要的转换次数

**输入例子:**

  4 

  1 1 1 3
**输出例子:**

  2

对撞指针： 

左指针lp自左向右遍历，对lp经过的元素求和sum_l； 

右指正rp自右向左遍历，对rp经过的元素求和sum_r。 

统计转换操作次数为count。
当sum_l==sum_r 时:

$sum_l = *lp;\\sum_r=*rp;\\lp++;\\rp--;$

当$sum\_l<sum\_r$时:  

$sum_l += *lp ;\\ lp++;\\count++;$

当$sum\_l>sum\_r$时:

$  sum_r += *rp;\\rp- -;\\count++；$
此外 当lp>rp时：返回count；

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include<algorithm>
using namespace std;

int func(int* item,int left,int right)
{
    int left_sum(0), right_sum(0);
    int count(0);

    while (left <= right)
    {
        if (left_sum == right_sum)
        {
            left_sum = item[left];
            left++;
            right_sum = item[right];
            right--;
        }
        else if (left_sum < right_sum)
        {
            left_sum += item[left];
            left++;
            count++;
        }
        else
        {
            right_sum += item[right];
            right--;
            count++;
        }
    }
    if (left_sum == right_sum)
    {
        return count;
    }
    else{
        return count + 1;
    }
}

int main()
{
    int item[50];
    int n;
    cin >> n;
    int tmp;
    for (auto i = 0; i < n; ++i)
    {
        cin >> item[i];
    }
    cout << func(item, 0,n-1) << endl;

    return 0;
}
```









