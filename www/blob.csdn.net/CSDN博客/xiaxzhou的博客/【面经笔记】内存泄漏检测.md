# 【面经笔记】内存泄漏检测 - xiaxzhou的博客 - CSDN博客





2017年07月26日 10:16:32[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：182








> 
参考： 
[http://www.cnblogs.com/juncheng/archive/2009/11/12/1602165.html](http://www.cnblogs.com/juncheng/archive/2009/11/12/1602165.html)

- 
new/new[]表达式会首先调用operator new/new[]操作运算符函数开辟内存，再调用构造函数构造对象

- 
而为了给操作运算符函数传递额外的参数：文件名与行号，需要使用定位new表达式（C++primer P729） 

new(void *) type  ->  operator new(size_t,void* )

> 
new(char*,int) type  ->  operator new(size_t,char* ,int )



定位new表达式一般用于placemen new： 
[http://www.cppblog.com/kongque/archive/2010/02/20/108093.html](http://www.cppblog.com/kongque/archive/2010/02/20/108093.html)
- 
重载operator new/delete/new[]/delete[] 四个运算操作符函数

- 
使用map保存指针及分配它的代码所在位置信息，new中插入，delete中删除


```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include<algorithm>
#include <stack>
#include <string>
#include <map>

using namespace std;

class A
{
public:
    int a = 1;
};

#define debug_

#ifdef debug_
map<void*, pair<char*, int>> my_map;

void * __cdecl operator new(unsigned int size, const char *file, int line)
{
    void* p = malloc(size);
    pair<char*, int> tmp_2(const_cast<char *>(file), line);
    pair<void*, pair<char*, int>> tmp(p, tmp_2);
    my_map.insert(tmp);
    cout << "new" << endl;
    return p;
};
void * __cdecl operator new[](unsigned int size, const char *file, int line)
{
    void* p = malloc(size);
    pair<char*, int> tmp_2(const_cast<char *>(file), line);
    pair<void*, pair<char*, int>> tmp(p, tmp_2);
    my_map.insert(tmp);
    cout << "new[]" << endl;
    return p;
};

void __cdecl operator delete(void *p)
{
    if(my_map.erase(p))
        cout << "delete" << endl;
    free(p);
};
void __cdecl operator delete[](void *p)
{
    if(my_map.erase(p))
        cout << "delete []" << endl;
    free(p);
};
#define new new(__FILE__,__LINE__)
#endif

int main()
{
    auto tmp_1 = new A;
    auto tmp_2 = new A[5];

    //delete tmp_1;
    //delete[] tmp_2;
    return 0;
}
```



