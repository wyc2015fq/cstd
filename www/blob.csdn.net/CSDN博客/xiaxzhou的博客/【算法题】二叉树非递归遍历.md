# 【算法题】二叉树非递归遍历 - xiaxzhou的博客 - CSDN博客





2017年06月04日 11:09:34[xiaxzhou](https://me.csdn.net/xiaxzhou)阅读数：182标签：[二叉树																[遍历																[非递归](https://so.csdn.net/so/search/s.do?q=非递归&t=blog)
个人分类：[程序员面试笔试宝典](https://blog.csdn.net/xiaxzhou/article/category/6949915)





> 
**先序遍历**：**入栈**时访问 
**中序遍历**：**出栈**时访问 
**后续遍历**：**第二次出栈**时访问
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include<algorithm>
#include <stack>
#include <string>
using namespace std;


struct Tree
{
    double value;
    Tree* left;
    Tree* right;
};
void PreOrder(Tree * root)//先序遍历
{
    stack<Tree*> s;
    Tree* p = root;

    while (p != NULL || !s.empty())
    {
        while (p != NULL)
        {
            cout << p->value<<" ";
            s.push(p);
            p = p->left;
        }
        if (!s.empty())
        {
            p = s.top();
            s.pop();
            p = p->right;
        }
    }
}

void MidOrder(Tree * root)//中序遍历 
{
    stack<Tree*> s;
    Tree * p = root;

    while (p != NULL || !s.empty())
    {
        while (p != NULL)
        {
            s.push(p);
            p = p->left;
        }
        if (!s.empty())
        {
            p = s.top();
            s.pop();
            cout << p->value << " ";
            p = p->right;
        }
    }
}

void PostOrder(Tree* root)//后序遍历
{
    struct Note
    {
        Tree * p;
        bool isFirst;
    };

    stack<Note> s;
    Note tmp;
    Tree* p=root;

    while (p != NULL || !s.empty())
    {
        while (p != NULL)
        {
            tmp.p = p;
            tmp.isFirst = true;
            s.push(tmp);
            p = p->left;
        }
        if (!s.empty())
        {
            tmp = s.top();
            s.pop();
            if (tmp.isFirst == true)
            {
                p = tmp.p->right;
                tmp.isFirst = false;
                s.push(tmp);
            }
            else
            {
                cout << tmp.p->value << " ";
                p = NULL;
            }
        }
    }
}

int main()
{
    Tree root;
    Tree node1_1;
    Tree node1_2;
    Tree node2_1;
    Tree node2_2;
    Tree node2_3;
    Tree node3_1;
    Tree node3_2;
    Tree node3_3;
    Tree node3_4;

    root.value = 0;
    node1_1.value = 1.1;
    node1_2.value = 1.2;
    node2_1.value = 2.1;
    node2_2.value = 2.2;
    node2_3.value = 2.3;
    node3_1.value = 3.1;
    node3_2.value = 3.2;
    node3_3.value = 3.3;
    node3_4.value = 3.4;

    root.left = &node1_1;
    root.right = &node1_2;

    node1_1.left = &node2_1;
    node1_1.right = &node2_2;

    node1_2.left = &node2_3;
    node1_2.right = NULL;

    node2_1.left = &node3_1;
    node2_1.right = &node3_2;

    node2_2.left = NULL;
    node2_2.right = NULL;

    node2_3.left = &node3_3;
    node2_3.right = &node3_4;

    node3_1.left = NULL;
    node3_1.right = NULL;

    node3_2.left = NULL;
    node3_2.right = NULL;

    node3_3.left = NULL;
    node3_3.right = NULL;

    node3_4.left = NULL;
    node3_4.right = NULL;

    PreOrder(&root);
    cout << endl;
    MidOrder(&root);
    cout << endl;
    PostOrder(&root);
    cout << endl;

    return -1;
}
```](https://so.csdn.net/so/search/s.do?q=遍历&t=blog)](https://so.csdn.net/so/search/s.do?q=二叉树&t=blog)




