# 图像匹配算法比较与分析 - qq_19833853的博客 - CSDN博客
2017年06月01日 08:12:16[jessie Fei](https://me.csdn.net/qq_19833853)阅读数：2842
**1.感知哈希（pHash）算法的Opencv实现**
**均值Hash算法**
- //均值Hash算法
-  string HashValue(Mat &src)  
-  {  
-      string rst(64,'\0');  
-      Mat img;  
- if(src.channels()==3)  
-          cvtColor(src,img,CV_BGR2GRAY);  
- else
-         img=src.clone();  
- /*第一步，缩小尺寸。
-          将图片缩小到8x8的尺寸，总共64个像素,去除图片的细节*/
- 
-         resize(img,img,Size(8,8));  
- /* 第二步，简化色彩(Color Reduce)。
-        将缩小后的图片，转为64级灰度。*/
- 
-     uchar *pData;  
- for(int i=0;i<img.rows;i++)  
-     {  
-         pData = img.ptr<uchar>(i);  
- for(int j=0;j<img.cols;j++)  
-         {  
-             pData[j]=pData[j]/4;            }  
-     }  
- 
- /* 第三步，计算平均值。
-        计算所有64个像素的灰度平均值。*/
- int average = mean(img).val[0];  
- 
- /* 第四步，比较像素的灰度。
-      将每个像素的灰度，与平均值进行比较。大于或等于平均值记为1,小于平均值记为0*/
-     Mat mask= (img>=(uchar)average);  
- 
- /* 第五步，计算哈希值。*/
- int index = 0;  
- for(int i=0;i<mask.rows;i++)  
-     {  
-         pData = mask.ptr<uchar>(i);  
- for(int j=0;j<mask.cols;j++)  
-         {  
- if(pData[j]==0)  
-                 rst[index++]='0';  
- else
-                 rst[index++]='1';  
-         }  
-     }  
- return rst;  
-  }  
**pHash算法**
- //pHash算法
-  string pHashValue(Mat &src)  
-  {  
-      Mat img ,dst;  
-      string rst(64,'\0');  
- double dIdex[64];  
- double mean = 0.0;  
- int k = 0;  
- if(src.channels()==3)  
-      {  
-          cvtColor(src,src,CV_BGR2GRAY);  
-          img = Mat_<double>(src);  
-      }     
- else
-      {  
-          img = Mat_<double>(src);  
-      }       
- 
- /* 第一步，缩放尺寸*/
-      resize(img, img, Size(8,8));  
- 
- /* 第二步，离散余弦变换，DCT系数求取*/
-      dct(img, dst);   
- 
- /* 第三步，求取DCT系数均值（左上角8*8区块的DCT系数）*/
- for (int i = 0; i < 8; ++i) {  
- for (int j = 0; j < 8; ++j)   
-          {  
-              dIdex[k] = dst.at<double>(i, j);  
-              mean += dst.at<double>(i, j)/64;  
-              ++k;  
-          }  
-      }  
- 
- /* 第四步，计算哈希值。*/
- for (int i =0;i<64;++i)  
-      {  
- if (dIdex[i]>=mean)  
-          {  
-              rst[i]='1';  
-          }  
- else
-          {  
-              rst[i]='0';  
-          }  
-      }  
- return rst;  
-  }  
![](http://static.blog.csdn.net/images/save_snippets.png)
![](http://static.blog.csdn.net/images/save_snippets.png)
# 汉明距离计算     
    通过上面两段代码就可以计算出图像的Hash值，检索的时候一般采用汉明距离来进行判断两幅图像的相似性，一般情况下认为汉明距离小于5，就可以认为两幅图像时相似的。汉明具体计算实现：
**[cpp]**[view
 plain](http://blog.csdn.net/huixingshao/article/details/43524581#)[copy](http://blog.csdn.net/huixingshao/article/details/43524581#)
- //汉明距离计算
- int HanmingDistance(string &str1,string &str2)  
-  {  
- if((str1.size()!=64)||(str2.size()!=64))  
- return -1;  
- int difference = 0;  
- for(int i=0;i<64;i++)  
-     {  
- if(str1[i]!=str2[i])  
-             difference++;  
-     }  
- return difference;  
-  }  
**哈希值海明距离图像匹配应用**
#include<iostream>
#include<opencv2/opencv.hpp>
using namespace std;
using namespace cv;
string pHashValue(Mat &src);
int HanmingDistance(string &str1, string &str2);
void main()
{
string pHashValue(Mat &src);
int HanmingDistance(string &str1, string &str2);
Mat srcImage = imread("1-300(1).bmp", 1);
Mat srcImage1 = imread("1-130(1).bmp", 1);
string rst1(64, '\0');
string rst2(64, '\0');
rst1=pHashValue(srcImage);
rst2=pHashValue(srcImage1);
int t;
t=HanmingDistance(rst1, rst2);
cout << "图一与图二的海明距离为=" << t << endl;
}
//pHash算法  
string pHashValue(Mat &src)
{
Mat img, dst;
string rst(64, '\0');
double dIdex[64];
double mean = 0.0;
int k = 0;
if (src.channels() == 3)
{
cvtColor(src, src, CV_BGR2GRAY);
img = Mat_<double>(src);
}
else
{
img = Mat_<double>(src);
}
/* 第一步，缩放尺寸*/
resize(img, img, Size(8, 8));
/* 第二步，离散余弦变换，DCT系数求取*/
dct(img, dst);
/* 第三步，求取DCT系数均值（左上角8*8区块的DCT系数）*/
for (int i = 0; i < 8; ++i) {
for (int j = 0; j < 8; ++j)
{
dIdex[k] = dst.at<double>(i, j);
mean += dst.at<double>(i, j) / 64;
++k;
}
}
/* 第四步，计算哈希值。*/
for (int i = 0; i<64; ++i)
{
if (dIdex[i] >= mean)
{
rst[i] = '1';
}
else
{
rst[i] = '0';
}
}
return rst;
}
//汉明距离计算  
int HanmingDistance(string &str1, string &str2)
{
if ((str1.size() != 64) || (str2.size() != 64))
return -1;
int difference = 0;
for (int i = 0; i<64; i++)
{
if (str1[i] != str2[i])
difference++;
}
return difference;
}
![](https://img-blog.csdn.net/20170601101932549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTk4MzM4NTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
**感知哈希（pHash）算法的缺点**
1.算法得到的海明距离对于相同大小有旋转的图像距离值都较大。
2.若图像有遮挡或者缩放该算法均不适用。
2[BRISK特征提取算法](http://blog.csdn.net/carson2005/article/details/53767565)
#include <cv.h>  
#include <opencv2/highgui/highgui.hpp>  
#include <opencv2/core/core.hpp>  
#include <opencv2/nonfree/features2d.hpp>  
#include <opencv2/nonfree/nonfree.hpp>  
#include <Windows.h>  
using namespace cv;
using namespace std;
int main()
{
//Load Image  
Mat c_src1 = imread("1-130(1).bmp");
Mat c_src2 = imread("3-130(1).bmp");
Mat src1 = imread("1-130(1).bmp", CV_LOAD_IMAGE_GRAYSCALE);
Mat src2 = imread("3-130(1).bmp", CV_LOAD_IMAGE_GRAYSCALE);
if (!src1.data || !src2.data)
{
cout << "Error reading images " << std::endl;
return -1;
}
//feature detect  
BRISK detector;
vector<KeyPoint> kp1, kp2;
double start = GetTickCount();
detector.detect(src1, kp1);
detector.detect(src2, kp2);
//cv::BRISK extractor;  
Mat des1, des2;//descriptor  
detector.compute(src1, kp1, des1);
detector.compute(src2, kp2, des2);
Mat res1, res2;
int drawmode = DrawMatchesFlags::DRAW_RICH_KEYPOINTS;
drawKeypoints(c_src1, kp1, res1, Scalar::all(-1), drawmode);//画出特征点  
drawKeypoints(c_src2, kp2, res2, Scalar::all(-1), drawmode);
cout << "size of description of Img1: " << kp1.size() << endl;
cout << "size of description of Img2: " << kp2.size() << endl;
BFMatcher matcher(NORM_HAMMING);
vector<DMatch> matches;
matcher.match(des1, des2, matches);
double end = GetTickCount();
cout << "耗时：" << (end - start) << "ms" << endl;
Mat img_match;
drawMatches(src1, kp1, src2, kp2, matches, img_match);
cout << "number of matched points: " << matches.size() << endl;
namedWindow("matches", WINDOW_NORMAL);
imshow("matches", img_match);
cvWaitKey(0);
cvDestroyAllWindows();
return 0;
}
![](https://img-blog.csdn.net/20170601180455054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTk4MzM4NTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
