# 仿射变换和透射变换 - qq_19833853的博客 - CSDN博客
2017年06月12日 22:45:04[jessie Fei](https://me.csdn.net/qq_19833853)阅读数：777
**仿射变换**
定义：仿射变换的功能是从二维坐标到二维坐标之间的线性变换，且保持二维图形的“平直性”和“平行性”。仿射变换可以通过一系列的原子变换的复合来实现，包括平移，缩放，翻转，旋转和剪切。
这类变换可以用一个3*3的矩阵M来表示，其最后一行为（0，0，1）。该变换矩阵将原坐标为（x,y)变换为新坐标（x',y')，
即
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;x%27%5C%5C&space;y%27%5C%5C&space;1&space;%5Cend%7Bbmatrix%7D=&space;%5Cbegin%7Bbmatrix%7D&space;m_%7B00%7D&space;&m_%7B01%7D&space;&&space;m_%7B02%7D%5C%5C&space;m_%7B10%7D&&space;m_%7B11%7D&space;&&space;m_%7B12%7D&space;%5C%5C&space;0&space;&&space;0&space;&1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;x%5C%5C&space;y%5C%5C&space;1&space;%5Cend%7Bbmatrix%7D)
[OpenCV](http://lib.csdn.net/base/opencv)中相应的函数是：
void warpAffine(InputArray src, OutputArray dst, InputArray M,
 Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())[¶](http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html?highlight=getrotationmatrix2d#void%20warpAffine%28InputArray%20src,%20OutputArray%20dst,%20InputArray%20M,%20Size%20dsize,%20int%20flags,%20int%20borderMode,%20const%20Scalar&%20borderValue%29)
Parameters:
- src – input image.
- dst – output image that has the size dsize and
 the same type as src .
- M –  transformation matrix，最重要的东东了，本文中着重讲M的构造
- dsize – size of the output image.ansformation (  ).
- borderMode – pixel extrapolation method (see [borderInterpolate()](http://docs.opencv.org/modules/imgproc/doc/filtering.html#int%20borderInterpolate%28int%20p,%20int%20len,%20int%20borderType%29));
 when borderMode=BORDER_TRANSPARENT , it means that the pixels in the destination image corresponding to the “outliers”
 in the source image are not modified by the function.
- borderValue – value used in case of a constant border; by default, it is 0.
 下面介绍一些典型的仿射变换：
（1）平移，将每一点移到到（x+t , y+t)，变换矩阵为
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;1&space;&0&space;&t_%7Bx%7D&space;%5C%5C&space;0&&space;1&space;&t_%7By%7D&space;%5C%5C&space;0&&space;0&&space;1&space;%5Cend%7Bbmatrix%7D)
(2)缩放变换  将每一点的横坐标放大或缩小sx倍，纵坐标放大（缩小）到sy倍，变换矩阵为
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;1&space;&0&space;&s_%7Bx%7D&space;%5C%5C&space;0&&space;1&space;&s_%7By%7D&space;%5C%5C&space;0&&space;0&&space;1&space;%5Cend%7Bbmatrix%7D)
（3）旋转变换原点：目标图形围绕原点顺时针旋转Θ 弧度，变换矩阵为
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;cos%5CTheta&space;&-sin%5CTheta&space;&0&space;%5C%5C&space;sin%5CTheta&space;&&space;cos%5CTheta&space;&0&space;%5C%5C&space;0&&space;0&&space;1&space;%5Cend%7Bbmatrix%7D)
(4) 旋转变换  ：目标图形以（x , y ）为轴心顺时针旋转θ弧度，变换矩阵为
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;cos%5CTheta&space;&-sin%5CTheta&space;&x-x%5Ccdot&space;cos%5CTheta+y%5Ccdot&space;sin%5CTheta&space;%5C%5C&space;sin%5CTheta&space;&&space;cos%5CTheta&space;&y-x%5Ccdot&space;sin%5CTheta-y%5Ccdot&space;cos%5CTheta&space;%5C%5C&space;0&&space;0&&space;1&space;%5Cend%7Bbmatrix%7D)
相当于两次平移与一次原点旋转变换的复合，即先将轴心（x,y)移到到原点，然后做旋转变换，最后将图片的左上角置为图片的原点,即
![](http://latex.codecogs.com/gif.latex?M=%5Cbegin%7Bbmatrix%7D&space;1&space;&&space;0&space;&-x&space;%5C%5C&space;0&&space;-&space;&&space;-y%5C%5C&space;0&space;&0&space;&&space;1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;cos%5CTheta&space;&-sin%5CTheta&space;&&space;0%5C%5C&space;sin%5CTheta&space;&cos%5CTheta&space;&&space;0%5C%5C&space;0&space;&&space;0&space;&&space;1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;1&space;&0&space;&x&space;%5C%5C&space;0&space;&&space;1&y&space;%5C%5C&space;0&0&space;&1&space;%5Cend%7Bbmatrix%7D)
有的人可能会说为什么这么复杂呢，那是因为在[opencv](http://lib.csdn.net/base/opencv)的图像处理中，所有对图像的处理都是从原点进行的，而图像的原点默认为图像的左上角，而我们对图像作旋转处理时一般以图像的中点为轴心，因此就需要做如下处理
 如果你觉得这样很麻烦，可以使用opencv中自带的Mat getRotationMatrix2D(Point2f
 center, double angle, double scale)函数获得变换矩阵M，
center:旋转中心
　　angle：旋转弧度，一定要将角度转换成弧度
　　scale:缩放尺度
它得到的矩阵是：
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;%5Calpha&space;&-%5Cbeta&space;&center.x%5Ccdot&space;%7B(%5Calpha&space;-&space;1)%7D-center.y%5Ccdot&space;%5Cbeta&space;%5C%5C&space;%5Cbeta&space;&%5Calpha&space;&center.x%5Ccdot&space;%5Cbeta&space;+&space;%7B(%5Cbeta-1)%5Ccdot&space;center.y%7D&space;%5C%5C&space;0&0&space;&&space;1&space;%5Cend%7Bbmatrix%7D)
 其中α = scale * cos( angle ) , β = scale  * sing( angle )  , ( center.x , center.y ) 表示旋转轴心
但是不得不说opencv的文档以及相关书籍中都把这个矩阵写错了，如下：
![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D&space;%5Calpha&space;&%5Cbeta&space;&center.x%5Ccdot&space;%7B(1-%5Calpha&space;)%7D-center.y%5Ccdot&space;%5Cbeta&space;%5C%5C&space;-%5Cbeta&space;&%5Calpha&space;&center.x%5Ccdot&space;%5Cbeta&space;+&space;%7B(1-%5Calpha)%5Ccdot&space;center.y%7D&space;%5C%5C&space;0&0&space;&&space;1&space;%5Cend%7Bbmatrix%7D)
建议大家自己通过下式验证一下，即首先将轴心(x,y)移到原点，然后做旋转平绽放变换，最后再将图像的左上角转换为原点
![](http://latex.codecogs.com/gif.latex?M=&space;%5Cbegin%7Bbmatrix%7D&space;1&space;&&space;0&space;&-x&space;%5C%5C&space;0&1&space;&&space;-y%5C%5C&space;0&&space;0&space;&1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;cos%5CTheta&space;&-sin%5CTheta&space;&0&space;%5C%5C&space;sin%5CTheta&space;&&space;cos%5CTheta&space;&&space;0%5C%5C&space;0&space;&&space;0&space;&&space;1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;s&space;&&space;0&space;&&space;0%5C%5C&space;0&s&space;&&space;0%5C%5C&space;0&space;&0&space;&&space;1&space;%5Cend%7Bbmatrix%7D&space;%5Cbegin%7Bbmatrix%7D&space;1&space;&&space;0&space;&&space;x%5C%5C&space;0&space;&&space;1&space;&y&space;%5C%5C&space;0&&space;0&space;&&space;1&space;%5Cend%7Bbmatrix%7D)
没有去研究该函数的源码，不晓得源码中到底怎么写的，但是在别人的博客中看到这个函数貌似需要修正
opencv中还有一个函数：Mat getAffineTransform(InputArray src, InputArray dst)[¶](http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html?highlight=getrotationmatrix2d#Mat%20getAffineTransform%28InputArray%20src,%20InputArray%20dst%29)
　它通过三组点对就可以获得它们之间的仿射变换，如果我们在一组图像变换中知道变换后的三组点，那么我们就可以利用该函数求得变换矩阵，然后对整张图片进行仿射变换
还有一种与仿射变换经常混淆的变换为透视变换，透视变换需要四组点对才能确定变换矩阵，由于仿射变换保持“平直性”与“平行性”，因此只需要三组点对，而透视变换没有这种约束，故需要四组点对
**warpPerspective函数**
**主要作用：对图像进行透视变换，就是变形**
**函数的调用形式：**
C++:void warpPerspective(InputArray src,
 OutputArray dst, InputArray M,
 Size dsize, int flags=INTER_LINEAR,
 int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
参数详解：
InputArray src：输入的图像
OutputArray dst：输出的图像
InputArray M：透视变换的矩阵
Size dsize：输出图像的大小
int flags=INTER_LINEAR：输出图像的插值方法，
combination of interpolation methods (INTER_LINEAR or INTER_NEAREST)
 and the optional flagWARP_INVERSE_MAP,
 that sets M as the inverse transformation
 ( ![\texttt{dst}\rightarrow\texttt{src}](http://docs.opencv.org/_images/math/79358c8b893d7d0db75b629175a7eab3db5f192b.png) )
int borderMode=BORDER_CONSTANT：图像边界的处理方式
const Scalar& borderValue=Scalar()：边界的颜色设置，一般默认是0
函数原理：
透视变换(Perspective Transformation)是将图片投影到一个新的视平面(Viewing Plane)，也称作投影映射(Projective Mapping)。通用的变换公式为：
![](https://img-blog.csdn.net/20140521142738671)
u,v是原始图片左边，对应得到变换后的图片坐标x,y,其中![](https://img-blog.csdn.net/20140521142754687)。
变换矩阵![](https://img-blog.csdn.net/20140521142820609)可以拆成4部分，![](https://img-blog.csdn.net/20140521142832296)表示线性变换，比如scaling，shearing和ratotion。![](https://img-blog.csdn.net/20140521142911312)用于平移，![](https://img-blog.csdn.net/20140521142842390)产生透视变换。所以可以理解成仿射等是透视变换的特殊形式。经过透视变换之后的图片通常不是平行四边形（除非映射视平面和原来平面平行的情况）。
重写之前的变换公式可以得到：
![](https://img-blog.csdn.net/20140521143006406)
所以，已知变换对应的几个点就可以求取变换公式。反之，特定的变换公式也能新的变换后的图片。简单的看一个正方形到四边形的变换：
变换的4组对应点可以表示成：![](https://img-blog.csdn.net/20140521143117828)
根据变换公式得到：
![](https://img-blog.csdn.net/20140521143219625)
定义几个辅助变量：
![](https://img-blog.csdn.net/20140521143302781)
![](https://img-blog.csdn.net/20140521143339968)都为0时变换平面与原来是平行的，可以得到：
![](https://img-blog.csdn.net/20140521143422484)
![](https://img-blog.csdn.net/20140521143339968)不为0时，得到：
![](https://img-blog.csdn.net/20140521143514640)
求解出的变换矩阵就可以将一个正方形变换到四边形。反之，四边形变换到正方形也是一样的。于是，我们通过两次变换：四边形变换到正方形+正方形变换到四边形就可以将任意一个四边形变换到另一个四边形。
![](https://img-blog.csdn.net/20140521143605687)
 opencv代码：
- #include<cv.h>
- #include<highgui.h>
- 
- #pragma comment(lib, "cv.lib")
- #pragma comment(lib, "cxcore.lib")
- #pragma comment(lib, "highgui.lib")
- 
- int main()  
- {  
-     CvPoint2D32f srcTri[4], dstTri[4];  
-     CvMat*       warp_mat = cvCreateMat (3, 3, CV_32FC1);  
-     IplImage*    src = NULL;  
-     IplImage*    dst = NULL;  
- 
-     src = cvLoadImage ("test.png", 1);  
-     dst = cvCloneImage (src);  
-     dst->origin = src->origin;  
-     cvZero (dst);  
- 
-     srcTri[0].x = 0;  
-     srcTri[0].y = 0;  
-     srcTri[1].x = src->width - 1;  
-     srcTri[1].y = 0;  
-     srcTri[2].x = 0;  
-     srcTri[2].y = src->height - 1;  
-     srcTri[3].x = src->width - 1;  
-     srcTri[3].y = src->height - 1;  
- 
-     dstTri[0].x = src->width * 0.05;  
-     dstTri[0].y = src->height * 0.33;  
-     dstTri[1].x = src->width * 0.9;  
-     dstTri[1].y = src->height * 0.25;  
-     dstTri[2].x = src->width * 0.2;  
-     dstTri[2].y = src->height * 0.7;  
-     dstTri[3].x = src->width * 0.8;  
-     dstTri[3].y = src->height * 0.9;  
- 
-     cvGetPerspectiveTransform (srcTri, dstTri, warp_mat);  
-     cvWarpPerspective (src, dst, warp_mat);  
- 
-     cvNamedWindow("src", 1);  
-     cvShowImage("src", src);  
-     cvNamedWindow ("Affine_Transform", 1);  
-     cvShowImage ("Affine_Transform", dst);  
- 
-     cvWaitKey (0);  
- 
-     cvReleaseImage (&src);  
-     cvReleaseImage (&dst);  
-     cvReleaseMat (&warp_mat);  
- 
- return 0;  
- }  
# **1.仿射变换**
仿射变换代表是两幅图像之间的映射关系，可以表达为乘以一个矩阵再加上一个向量的形式；通常使用2×3的矩阵来表示仿射变换。
![](http://latex.codecogs.com/gif.latex?A=%5Cbegin%7Bbmatrix%7D&space;a_%7B00%7D&space;&a_%7B01%7D&space;%5C%5C&space;a_%7B10%7D&space;&&space;a_%7B11%7D&space;%5Cend%7Bbmatrix%7D&space;;&space;B=%5Cbegin%7Bbmatrix%7D&space;b_%7B00%7D%5C%5C&space;b_%7B10%7D%5Cend%7Bbmatrix%7D;T=%5Cbegin%7Bbmatrix%7D&space;A&space;&&space;B&space;%5Cend%7Bbmatrix%7D;X=%5Cbegin%7Bbmatrix%7D&space;x%5C%5C&space;y%5Cend%7Bbmatrix%7D;X%5E%7B%27%7D=%5Cbegin%7Bbmatrix%7D&space;x%5C%5C&space;y%5C%5C&space;1%5Cend%7Bbmatrix%7D)
仿射变换可表达为Y=A×X+B的形式，在效果上等价于将向量X拓展成X’，并且只是将X’左乘T，即：![](http://latex.codecogs.com/gif.latex?Y=T%5Ctimes&space;X%5E%7B%27%7D)
![](http://latex.codecogs.com/gif.latex?Y=T%5Ctimes&space;X%5E%7B%27%7D=%5Cbegin%7Bbmatrix%7D&space;a_%7B00%7Dx+a_%7B01%7Dy+b_%7B00%7D%5C%5C&space;a_%7B10%7Dx+a_%7B11%7Dy+b_%7B10%7D%5Cend%7Bbmatrix%7D)
 仿射变换可以表达成以下形式。一个平面内的任意平行四边形ABCD可以被仿射变换映射为另一个平行四边形A’B’C’D’。如果这些平行四边形的面积不等于0，这个隐含的仿射变换就被两个平行四边形唯一定义。可以把仿射变换想象成把一幅图像画到一个胶板上，在胶板的角上任意推拉改变形状得到不同类型的平行四边形。
# 2.透视变换
仿射变换可以将图像转换为平行四边形，透视变换提供了更大的灵活性，一个透视变换可以将矩形转变为梯形，平行四边形也是梯形，所以仿射变换是透视变换的子集。设透视变换矩阵：
![](http://latex.codecogs.com/gif.latex?T=%5Cbegin%7Bbmatrix%7D&space;M_%7B11%7D&space;&&space;M_%7B12%7D&space;&M_%7B13%7D&space;%5C%5C&space;M_%7B21%7D&&space;M_%7B22%7D&space;&M_%7B23%7D&space;%5C%5C&space;M_%7B31%7D&&space;M_%7B32%7D&space;&&space;M_%7B33%7D&space;%5Cend%7Bbmatrix%7D)
则，透视变换的原图像与目标图像的映射关系为：
![\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )](http://docs.opencv.org/2.4.11/_images/math/fa7e99ae84a2294284e680e2d4c4011121be6492.png)
**[cpp]**[view
 plain](http://blog.csdn.net/u012507022/article/details/52899936#)[copy](http://blog.csdn.net/u012507022/article/details/52899936#)
- #include "opencv2/highgui/highgui.hpp"
- #include "opencv2/imgproc/imgproc.hpp"
- #include <iostream>
- usingnamespace cv;  
- usingnamespace std;  
- 
- #define WINDOW_NAME1 "Original Image"                    
- #define WINDOW_NAME2 "Affine transformation"             
- #define WINDOW_NAME3 "Perspective transformation"     
- 
- int main(  )  
- {  
- bool  Affine=true;     
- bool  Perspective=true;  
- 
-     Mat srcImage, dstImage_Aff, dstImage_Per;  
- 
- //加载源图像并作一些初始化
-     srcImage = imread( "lena.png", 1 );  
- if(!srcImage.data ) { printf("读取图片错误\n"); returnfalse; }   
-     dstImage_Aff = Mat::zeros(srcImage.rows, srcImage.cols, srcImage.type());  
-     dstImage_Per = Mat::zeros(srcImage.rows, srcImage.cols, srcImage.type());  
- 
- if(Affine){  
- //仿射变换三个点的映射关系
-         Point2f srcTriangle[3];  
-         Point2f dstTriangle[3];  
-         Mat AffMat( 2, 3, CV_32FC1 );  //仿射变换矩阵
- //设置源图像和目标图像上的三组点以计算仿射变换
-         srcTriangle[0] = Point2f( 0,0 );  //原始图像的左上点
-         srcTriangle[1] = Point2f( (srcImage.cols), 0 ); //原始图像的右上点
-         srcTriangle[2] = Point2f( 0, (srcImage.rows )); //原始图像的左下点
- 
-         dstTriangle[0] = Point2f( (srcImage.cols*0.0), (srcImage.rows*0.5));  
-         dstTriangle[1] = Point2f( (srcImage.cols*0.5), (srcImage.rows*0.0));  
-         dstTriangle[2] = Point2f( (srcImage.cols*0.5), (srcImage.rows*1.0));  
- //求得仿射变换矩阵并计算的仿射变换
-         AffMat = getAffineTransform( srcTriangle, dstTriangle );  
- //Output affine transformation matrix
-         cout<<"affine transformation matrix:\n"<<AffMat<<endl;  
-         warpAffine(srcImage, dstImage_Aff, AffMat,dstImage_Aff.size());  
- 
-         imshow( WINDOW_NAME2, dstImage_Aff );  
-     }  
- if(Perspective){  
- //投影变换四个点的映射关系
-         Point2f srcQuadrilateral[4];  
-         Point2f dstQuadrilateral[4];  
- //定义一些Mat变量
-         Mat PerMat( 3, 3, CV_32FC1 );  //透视变换矩阵
- //设置源图像和目标图像上的四组点以计算透视变换
-         srcQuadrilateral[0] = Point2f(0,               0);  //原始图像的左上点
-         srcQuadrilateral[1] = Point2f((srcImage.cols), 0); //原始图像的右上点
-         srcQuadrilateral[2] = Point2f(0,                (srcImage.rows )); //原始图像的左下点
-         srcQuadrilateral[3] = Point2f((srcImage.cols ), (srcImage.rows )); //原始图像的左下点
- 
-         dstQuadrilateral[0] = Point2f( (srcImage.cols*0.0),(srcImage.rows*0.5));  
-         dstQuadrilateral[1] = Point2f( (srcImage.cols*0.5),(srcImage.rows*0.0));  
-         dstQuadrilateral[2] = Point2f( (srcImage.cols*0.5),(srcImage.rows*1.0));  
-         dstQuadrilateral[3] = Point2f( (srcImage.cols*1.0),(srcImage.rows*0.5));  
- 
- //求得透视变换矩阵并计算的透视变换
-         PerMat = getPerspectiveTransform( srcQuadrilateral, dstQuadrilateral );  
- //Output perspective transformation matrix
-         Mat PerMat2;  
-         PerMat.convertTo(PerMat2, CV_32F);  
-         cout<<"perspective transformation matrix:\n"<<PerMat2<<endl;  
-         warpPerspective(srcImage, dstImage_Per, PerMat,dstImage_Per.size());  
- 
-         imshow( WINDOW_NAME3, dstImage_Per );  
-     }  
- 
- //显示结果
-     imshow( WINDOW_NAME1, srcImage );  
-     waitKey(0);  
- 
- return 0;  
- }  
更多资源：http://blog.csdn.net/xiaowei_cqu/article/details/26471527
      http://m.blog.csdn.net/article/details?id=51355600
      http://blog.csdn.net/u012380663/article/details/43273527
