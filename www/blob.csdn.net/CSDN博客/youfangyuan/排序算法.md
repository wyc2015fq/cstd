# 排序算法 - youfangyuan - CSDN博客
2012年06月30日 21:07:26[youfangyuan](https://me.csdn.net/youfangyuan)阅读数：414标签：[算法																[sorting																[n2																[pascal																[compiler																[shell](https://so.csdn.net/so/search/s.do?q=shell&t=blog)](https://so.csdn.net/so/search/s.do?q=compiler&t=blog)](https://so.csdn.net/so/search/s.do?q=pascal&t=blog)](https://so.csdn.net/so/search/s.do?q=n2&t=blog)](https://so.csdn.net/so/search/s.do?q=sorting&t=blog)](https://so.csdn.net/so/search/s.do?q=算法&t=blog)
个人分类：[算法](https://blog.csdn.net/youfangyuan/article/category/1177028)
在[计算机科学](http://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)与[数学](http://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)中，一个**排序算法**（Sorting
 algorithm）是一种能将一串资料依照特定排序方式的一种[算法](http://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。最常用到的排序方式是数值顺序以及[字典顺序](http://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E5%85%B8%E9%A0%86%E5%BA%8F&action=edit&redlink=1)。有效的排序算法在一些算法（例如[搜寻算法](http://zh.wikipedia.org/w/index.php?title=%E6%90%9C%E5%B0%8B%E7%AE%97%E6%B3%95&action=edit&redlink=1)与[合并算法](http://zh.wikipedia.org/w/index.php?title=%E5%90%88%E4%BD%B5%E7%AE%97%E6%B3%95&action=edit&redlink=1)）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字资料以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：
- 输出结果为递增序列（递增是针对所需的排序顺序而言）
- 输出结果是原输入的一种[排列](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97)、或是重组
虽然排序算法是一个简单的问题，但是从计算机科学发展以来，已经有大量的研究在此问题上。举例而言，[冒泡排序](http://zh.wikipedia.org/wiki/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F)在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：[图书馆排序](http://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E6%9B%B8%E9%A4%A8%E6%8E%92%E5%BA%8F&action=edit&redlink=1)在2004年被发表）
## 目录
 [[隐藏](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#)] 
- [1分类](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.88.86.E9.A1.9E)- [1.1稳定度](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E5.BA.A6)
- [2排列算法列表](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E6.8E.92.E5.88.97.E7.AE.97.E6.B3.95.E5.88.97.E8.A1.A8)- [2.1稳定的](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E7.9A.84)
- [2.2不稳定](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E4.B8.8D.E7.A9.A9.E5.AE.9A)
- [2.3不实用的排序算法](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E4.B8.8D.E5.AF.A6.E7.94.A8.E7.9A.84.E6.8E.92.E5.BA.8F.E7.AE.97.E6.B3.95)
- [3平均时间复杂度](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.B9.B3.E5.9D.87.E6.97.B6.E9.97.B4.E5.A4.8D.E6.9D.82.E5.BA.A6)
- [4实际测试结果](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.AE.9E.E9.99.85.E6.B5.8B.E8.AF.95.E7.BB.93.E6.9E.9C)
- [5简要比较](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.AE.80.E8.A6.81.E6.AF.94.E8.BE.83)
- [6外部链接](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.A4.96.E9.83.A8.E9.93.BE.E6.8E.A5)
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=1)]分类
在[计算机科学](http://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)所使用的排序算法通常被分类为：
- 计算的[复杂度](http://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E8%A4%87%E9%9B%9C%E6%80%A7%E7%90%86%E8%AB%96)（[最差](http://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%B7%AE%E6%83%85%E6%B3%81%E6%95%88%E8%83%BD&action=edit&redlink=1)、[平均](http://zh.wikipedia.org/w/index.php?title=%E5%B9%B3%E5%9D%87%E6%95%88%E8%83%BD&action=edit&redlink=1)、和[最好](http://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%A5%BD%E6%83%85%E6%B3%81%E6%95%88%E8%83%BD&action=edit&redlink=1)性能），依据列表（list）的大小（*n*）。一般而言，好的性能是[O](http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)(*n* log *n*)，且坏的性能是O(*n*2)。对于一个排序理想的性能是[O](http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)(*n*)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(*n* log *n*)。
- 内存使用量（以及其他电脑资源的使用）
- 稳定度：**稳定排序算法**会依照相等的关键（换言之就是值）维持纪录的相对次序。也就是一个排序算法是**稳定**的，就是当有两个有相等关键的纪录*R*和*S*，且在原本的列表中*R*出现在*S*之前，在排序过的列表中*R*也将会是在*S*之前。
- 一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和[快速排序](http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)。选择排序包含[希尔排序](http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)和[堆排序](http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F)。
### [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=2)]稳定度
当相等的元素是无法分辨的，比如像是整数，稳定度并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。
(4, 1)  (3, 1)  (3, 7)  (5, 6)
在这个状况下，有可能产生两种不同的结果，一个是依照相等的键值维持相对的次序，而另外一个则没有：
(3, 1)  (3, 7)  (4, 1)  (5, 6)   (維持次序)
(3, 7)  (3, 1)  (4, 1)  (5, 6)   (次序被改變)
不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实作为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个物件间之比较，就会被决定使用在原先资料次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=3)]排列算法列表
在这个表格中，*n*是要被排序的纪录数量以及*k*是不同键值的数量。
### [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=4)]稳定的
- [冒泡排序](http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)（bubble sort） — O(*n*2)
- [鸡尾酒排序](http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F) (Cocktail sort, 双向的冒泡排序) — O(*n*2)
- [插入排序](http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F) （insertion sort）— O(*n*2)
- [桶排序](http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F) （bucket sort）— O(*n*); 需要 O(*k*) 额外空间
- [计数排序](http://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) (counting sort) — O(*n*+*k*); 需要 O(*n*+*k*)
 额外空间
- [合并排序](http://zh.wikipedia.org/wiki/%E5%90%88%E4%BD%B5%E6%8E%92%E5%BA%8F) （merge sort）— O(*n* log *n*);
 需要 O(*n*) 额外空间
- 原地[合并排序](http://zh.wikipedia.org/wiki/%E5%90%88%E4%BD%B5%E6%8E%92%E5%BA%8F) — O(*n*2)
- [二叉排序树](http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91)排序 （Binary tree sort）
 — O(*n* log *n*)期望时间; O(*n*2)最坏时间; 需要 O(*n*) 额外空间
- [鸽巢排序](http://zh.wikipedia.org/wiki/%E9%B8%BD%E5%B7%A2%E6%8E%92%E5%BA%8F) (Pigeonhole sort) — O(*n*+*k*); 需要 O(*k*)
 额外空间
- [基数排序](http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F) （radix sort）— O(*n*·*k*); 需要 O(*n*)
 额外空间
- [Gnome 排序](http://zh.wikipedia.org/w/index.php?title=Gnome_%E6%8E%92%E5%BA%8F&action=edit&redlink=1) —
 O(*n*2)
- [图书馆排序](http://zh.wikipedia.org/w/index.php?title=%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F&action=edit&redlink=1) —
 O(*n* log *n*) with high probability, 需要 (1+ε)*n* 额外空间
### [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=5)]不稳定
- [选择排序](http://zh.wikipedia.org/wiki/%E9%81%B8%E6%93%87%E6%8E%92%E5%BA%8F) （selection sort）— O(*n*2)
- [希尔排序](http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F) （shell sort）— O(*n* log *n*) 如果使用最佳的现在版本
- [组合排序](http://zh.wikipedia.org/w/index.php?title=%E7%BB%84%E5%90%88%E6%8E%92%E5%BA%8F&action=edit&redlink=1) —
 O(*n* log *n*)
- [堆排序](http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F) （heapsort）— O(*n* log *n*)
- [平滑排序](http://zh.wikipedia.org/w/index.php?title=%E5%B9%B3%E6%BB%91%E6%8E%92%E5%BA%8F&action=edit&redlink=1) —
 O(*n* log *n*)
- [快速排序](http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F) （quicksort）— O(*n* log *n*) 期望时间, O(*n*2)
 最坏情况; 对于大的、乱数列表一般相信是最快的已知排序
- [Introsort](http://zh.wikipedia.org/wiki/Introsort) — O(*n* log *n*)
- [Patience sorting](http://zh.wikipedia.org/w/index.php?title=Patience_sorting&action=edit&redlink=1) —
 O(*n* log *n* + *k*) 最坏情况时间，需要 额外的 O(*n* + *k*) 空间，也需要找到[最长的递增子序列](http://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E9%95%B7%E7%9A%84%E9%81%9E%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97&action=edit&redlink=1)（longest
 increasing subsequence）
### [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=6)]不实用的排序算法
- [Bogo排序](http://zh.wikipedia.org/wiki/Bogo%E6%8E%92%E5%BA%8F) — O(*n* × *n*!) 期望时间，无穷的最坏情况。
- [Stupid sort](http://zh.wikipedia.org/w/index.php?title=Stupid_sort&action=edit&redlink=1) — O(*n*3);
 递回版本需要 O(*n*2) 额外内存
- [珠排序](http://zh.wikipedia.org/wiki/%E7%8F%A0%E6%8E%92%E5%BA%8F)（Bead sort） — O(*n*) or O(√*n*), 但需要特别的硬件
- [Pancake sorting](http://zh.wikipedia.org/w/index.php?title=Pancake_sorting&action=edit&redlink=1) —
 O(*n*), 但需要特别的硬件
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=7)]平均时间复杂度
平均时间复杂度由高到低为：
- [冒泡排序](http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F) O(*n*2)
- [插入排序](http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F) O(*n*2)
- [选择排序](http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F) O(*n*2)
- [归并排序](http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F) O(*n* log *n*)
- [堆排序](http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F) O(*n* log *n*)
- [快速排序](http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F) O(*n* log *n*)
- [希尔排序](http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F) O(*n*1.25)
- [基数排序](http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F) O(*n*)
说明：虽然完全逆续的情况下，快速排序会降到选择排序的速度，不过从概率角度来说(参考信息学理论，和概率学)，不对算法做编程上优化时，快速排序的平均速度比堆排序要快一些。
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=8)]实际测试结果
OS: winxp, Compiler: vc8, CPU：Intel T7200,  Memory: 2G
不同数组长度下调用6种排序1000次所需时间(秒）
length          shell           quick           merge           insert          select          bubble
100             0.0141          0.359           1.875           0.204           0.313           0.421
1000            0.218           0.578           2.204           1.672           2.265           4
5000            1.484           3.25            14.14           41.392          63.656          101.703
10000           3.1             7.8             23.5            253.1           165.6           415.7
50000           21.8            40.6            121.9           411.88          6353.1          11648.5
100000          53.1            89              228.1           16465.7         25381.2         44250
结论：
数组长度不大的情况下不宜使用归并排序，其它排序差别不大。
数组长度很大的情况下Shell最快，Quick其次，冒泡最慢。
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=9)]简要比较
|名称|数据对象|稳定性|时间复杂度|空间复杂度|描述| |
|----|----|----|----|----|----|----|
| | | | | | | |
|[插入排序](http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)|数组、链表|√|![O(n^2)](http://upload.wikimedia.org/wikipedia/zh/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png)|O(1)|(有序区,无序区)。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。| |
|[直接选择排序](http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)|数组|×|![O(n^2)](http://upload.wikimedia.org/wikipedia/zh/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png)|O(1)|(有序区,无序区)。在无序区里找一个最小的元素跟在有序区的后面。 对数组：比较得多，换得少。| |
|链表|√| | | | | |
|[堆排序](http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F)|数组|×|O(nlogn)|O(1)|(最大堆,有序区)。从堆顶把根卸出来放在有序区之前，再恢复堆。| |
|[归并排序](http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)|数组、链表|√|O(nlogn)|O(n) +O(logn) ， 如果不是从下到上|把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。| |
|[快速排序](http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)|数组|×|O(nlogn)|![O(n^2)](http://upload.wikimedia.org/wikipedia/zh/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png)|O(logn) ,O(n)|(小数,枢纽元,大数)。|
|[Accum qsort](http://zh.wikipedia.org/w/index.php?title=Accum_qsort&action=edit&redlink=1)|链表|√|O(nlogn)|![O(n^2)](http://upload.wikimedia.org/wikipedia/zh/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png)|O(logn) ,O(n)|(无序区,有序区)。把无序区分为(小数,枢纽元,大数)，从后到前压入有序区。|
||| | | | | |
|[决策树排序](http://zh.wikipedia.org/w/index.php?title=%E5%86%B3%E7%AD%96%E6%A0%91%E6%8E%92%E5%BA%8F&action=edit&redlink=1)||√|O(logn!)|O(n!)|O(n) <O(logn!) <O(nlogn)| |
||| | | | | |
|[计数排序](http://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)|数组、链表|√|O(n)|O(n+m)|统计小于等于该元素值的元素的个数 i，于是该元素就放在目标数组的索引 i位。(i≥0)| |
|[桶排序](http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F)|数组、链表|√|O(n)|O(m)|将值为 i 的元素放入i 号桶，最后依次把桶里的元素倒出来。| |
|[基数排序](http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)|数组、链表|√|O(k*n),最坏:O(n^2)||一种多关键字的排序算法，可用桶排序实现。| |
- 均按从小到大排列
- k 代表数值中的"数位"个数
- n 代表数据规模
- m 代表数据的最大值减最小值
## [[编辑](http://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&action=edit&section=10)]外部链接
- [不同排序算法间的比较(英语)](http://commons.wikimedia.org/wiki/File:SortingAlgoComp.png)
- [一些排序算法的 C 及 Pascal
 实现](http://www.nocow.cn/index.php/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
- [一些排序算法的
 C++ 实作](http://home.ustc.edu.cn/~lushijia/solutions/libsort/manual/html/index.html)
