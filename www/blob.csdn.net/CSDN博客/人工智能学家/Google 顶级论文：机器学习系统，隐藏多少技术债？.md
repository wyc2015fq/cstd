# Google 顶级论文：机器学习系统，隐藏多少技术债？ - 人工智能学家 - CSDN博客
2017年10月10日 00:00:00[人工智能学家](https://me.csdn.net/cf2SudS8x8F0v)阅读数：460
*![640?wx_fmt=png&wxfrom=5&wx_lazy=1](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWGWib99skrRftia1rlwfVT3P1pwcyUU8L0tm9Xa5eE2kdiaUVhmjhugQvVHRorljGwCSn8DAlXwg3icfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1)*
*来源： *[*全球人工智能*](https://mp.weixin.qq.com/s?__biz=MzA4NzE1NzYyMw==&mid=2247494193&idx=1&sn=b0bbea04aa4645f5f87582410841dc5d&chksm=903f1429a7489d3f90074cc2286bbf8ea53ba7d0afd784127942ac41de7404dd1e6a539eff3c&mpshare=1&scene=1&srcid=1010qfsWODmmVTw5vHKWjvT0&key=9d4ce337ad01ff27fcd4b370d5691a0b67bc545bc12084fd2f6cd96e08d73968d3e5b1706bd1526371e787925a95c85c12803d9a091ac598ca8b373e981370494c6f122fb8cba7b750b86b76457dd332&ascene=1&uin=MTQxMDUzNDAyNQ%3D%3D&devicetype=Windows+7&version=6205051a&pass_ticket=jZKyWSA6ALoJtIjx3Pf9ueS4UVhN4BFNE8rNZ528YKvQtOwwR4hhmk3wINHdM5m1&winzoom=1#%23)
*概要：随着机器学习（ML）社群持续积累了几年对于活跃系统（live systems）的经验，一种让人不舒服的趋势广泛地浮出水面：研发和部署机器学习系统相对来说是既快速又便宜的，但维护它们却很困难，并且成本昂贵。*
**一、介绍：**随着机器学习（ML）社群持续积累了几年对于活跃系统（live systems）的经验，一种让人不舒服的趋势广泛地浮出水面：研发和部署机器学习系统相对来说是既快速又便宜的，但维护它们却很困难，并且成本昂贵。
![640?wx_fmt=png&wxfrom=5&wx_lazy=1](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/X8OUs1wOMWGWib99skrRftia1rlwfVT3P1n0wmncibqnzibbmjF6Es5DRRRxmjsFjjIokjkfMPZqZ0tRCrl9XuFdiag/640?wx_fmt=png&wxfrom=5&wx_lazy=1)
这种对立可以用“技术债”的框架来理解。1992年WardCunningham引入了这个比喻，用来帮助解释在软件工程领域里因为进展快速而带来的长期成本。就像欠下财政债务一样，欠下技术债务也总是有充分的战略性原因。并不是所有的债务都是不好的，但是，所有的债务都需要付出利息。技术债可能通过：
- 
重构代码（refactoringcode）
- 
改进单元测试（improvingunit tests）
- 
删除无用代码（deletingdead code）
- 
降低依赖（reducing dependencies）
- 
精简应用程序接口（tightening APIs）
- 
以及改进说明（improving documentation）的方式来逐渐偿还。
这些行动的目标并不是为了增加全新的功能，而是为了使未来能够继续改进，减少报错，以及提高维护性。推迟偿还只会带来越来越高昂的成本。因为技术债会高速增长，所以它是非常危险的。
在这篇论文中，我们提出，机器学习系统有其特有的、带来技术债的能力，因为它们不仅有传统代码所有的维护问题，还要额外加上机器学习的一些特有问题。这种债务可能很难被察觉到，因为它存在于系统层面而不是代码层面。鉴于数据会影响机器学习系统的行为表现，传统的抽象化和边界可能悄悄崩溃（corrupted）或是失效（invalidated）。偿还代码层面技术债务的典型方法在系统层面的机器学习特有的技术债面前是不够的。
这篇论文并不提供全新的机器学习算法，而是寻求提高机器学习社群对于机器学习系统技术债的意识；从长远来看，实际操作中这些艰难的权衡必须得到考虑。我们关注于系统层面的交互和接口，因为这是一个可能会快速积累机器学习技术债的领域。在系统层面上，一个机器学习模型可能会严重侵蚀抽象化边界（abstractionboundaries）。多次利用输入信号（re-use）或连锁输入信号（chain）非常吸引人，但可能会无意中将几个系统组合起来（combine），也可能会令组合系统脱节（disjoint）。机器学习可能会被当作是黑匣，导致大量的“胶水代码”（glue
 code）或是大量校准层（calibration layers）。外部世界的变化可能会在无意中影响系统行为。在设计不够仔细的时候，即使是监控机器学习系统的行为都可能会使一件困难的事情。我们探索了一些机器学习特有的需要在设计系统时考虑到的风险因素。这些包括了：
（1）边界侵蚀（boundary erosion）
（2）纠缠（entanglement）
（3）隐藏反馈循环（hiddenfeedback loops）
（4）未申明的访问者（undeclared consumers）
（5）数据依赖（data dependencies）
（6）配置问题（configuration issues）
（7）外部世界变化（changesin the external world）
（8）系统层面的反面模式（anti-patterns）
**二、复杂模型侵蚀边界**
传统的软件设计实践表明，使用封装和模块设计的强抽象化边界有助于创造便于维护的代码，因为这让独立更改和改进变得很简单。给定元素中信息输入输出中，严格的抽象化边界有助于表达不变条件（invariants）以及逻辑一致性。
不幸的是，通过预先设置特殊的行为来迫使机器学习系统拥有严格的抽象化边界是非常困难的。事实上，机器学习恰恰是被应用在相反的情况中：当不依赖于外部数据、期望的行为便无法在软件逻辑里被有效表达时。真实世界并不能被干净整齐地封装起来。在这里，我们检验了一些会导致边界侵蚀、进而使机器学习系统中的技术债显著提高的情况。
**1.纠缠**
机器学习系统将信号混在一起，使它们互相纠缠，让独立更新变成一件不可能的事。比如，想象一下一个在模型中使用了特征x1,…xn的系统。如果我们改变了x1中输入值的分布，那么剩下n-1个特征的重要性、权重、或是用法（use）可能都会随之发生变化。增加一个新特征xn+1会导致相似的改变，就像移除其中任何一个特征一样。不存在真正意义上独立的输入。我们在这里称它为CACE法则：改变任何东西都意味着改变一切（ChangingAnything Changes Everything）。CACE不仅适用于输入信号，也适用于超参数（hyper-parameters）、学习情景（learningsettings）、抽样方法（samplingmethods）、收敛阈值（convergencethresholds）、数据选择（dataselection）、以及其他在本质上是微小改动的部分。
一种可能的缓解策略是，将模型分离开、转而提供集成模型。这个方法在分离式多层环境之类的情景下（例如在[14]中）是有用的，因为这样的环境下，这个方法能够让纠缠导致的各种问题都自然而然地消解。然而，在许多例子里，集成模型的效果非常好是因为它的组成模型各自的误差是不相关的。依赖于这样的组合会导致严重的纠缠问题：改进一个组成模型可能实际上让整个系统的准确度变得糟糕了——如果余下的误差与其它组成模型的误差相关性变得更强烈。
第二种可能的策略是，关注预测行为发生的变化。[12]中提出，用一个高维度可视化工具来让研究者们可以快速看到许多维度和切片上的效果。以切片为基础进行操作的矩阵可能也会非常有用。
**2.嵌套修正**
经常会出现一种情况：针对问题A的模型ma已经有了，但现在需要一个针对稍有不同的问题A’的模型。在这样的情况下，将ma作为输入信息、并学习一个小改变的模型是非常诱人的，它可以很快地解决问题。
然而，这种修正模型带来了新的对于ma的系统依赖，让未来分析改进这个模型的代价变得更为昂贵。当修正模型多层嵌套——针对问题A’’的模型是基于m’a习得的之类——来适应几个有些许不同的测试分布时，成本会变得更为高昂。一旦存在，嵌套修正模型会让改进陷入僵局，因为改进任何一个单独的组成部分的准确性事实上都会带来系统层面的损害。缓解策略是扩充ma，通过增加辨别特征让ma直接在它所在的模型里习得修正；或者接受为A’单独创造一个模型的成本。
**3.未声明的访问者**
许多时候，来自一个机器学习模型ma的预测能被许多程序访问的，或者是在运行时、或者是通过写入文件或是日志来让其他系统可以在之后访问。不对访问进行控制的话，一些访问者可能是未声明的（undeclared），悄无声息地将一个模型的输出结果输入给另一个系统。在更经典的软件工程领域，这个问题被称为可见性债务（visibilitydebt）。
未声明的访问者往好了说会带来昂贵的成本，往坏了说更是危险的，因为它们在模型ma与堆栈其他部分之间创建了一个隐藏的紧耦合。对ma的改变将很有可能也影响到这些其它的部分，也许通过无意的、尚未被理解的、会造成损伤的方式。实际操作中，这种紧耦合会逐渐增加对ma做任何改变的成本和难度，即使这些改变是为了提升性能。不仅如此，未声明的访问者可能会创建隐藏的反馈循环，在第4部分我们会更详细地讨论这个问题。
未声明的访问者可能很难被发现，除非系统在设计时就特意针对这个问题作了防护，比如限制访问或是有严格的服务级别协议（strictservice-level agreements, SLAs）。在缺乏限制的情况下，工程师们自然会使用手头最方便的信号，特别是当需要面对截止时间的压力时。
