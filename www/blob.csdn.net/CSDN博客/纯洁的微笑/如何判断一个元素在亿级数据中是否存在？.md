# 如何判断一个元素在亿级数据中是否存在？ - 纯洁的微笑 - CSDN博客
2018年11月30日 09:09:00[微笑很纯洁](https://me.csdn.net/ityouknow)阅读数：154
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGiankicr7MfHLVyWEV1LPbTtzxZMAWPf6Z5PJ6PoYFwmTjxSnAE64JxNHdg/640)
**本文系作者crossoverJie投稿**
# 前言
最近有朋友问我这么一个面试题目：
> 
现在有一个非常庞大的数据，假设全是 int 类型。现在我给你一个数，你需要告诉我它是否存在其中(尽量高效)。
需求其实很清晰，只是要判断一个数据是否存在即可。
但这里有一个比较重要的前提：**非常庞大的数据**。
# 常规实现
先不考虑这个条件，我们脑海中出现的第一种方案是什么？
我想大多数想到的都是用 `HashMap` 来存放数据，因为它的写入查询的效率都比较高。
写入和判断元素是否存在都有对应的 `API`，所以实现起来也比较简单。
为此我写了一个单测，利用 `HashSet` 来存数据（底层也是 `HashMap` ）；同时为了后面的对比将堆内存写死：
- 
```java
-Xms64m -Xmx64m -XX:+PrintHeapAtGC -XX:+HeapDumpOnOutOfMemoryError
```
为了方便调试加入了 `GC` 日志的打印，以及内存溢出后 `Dump` 内存。
- 
```java
@Test
```
- 
```java
public void hashMapTest(){
```
- 
```java
long star = System.currentTimeMillis();
```
- 
- 
```java
Set<Integer> hashset = new HashSet<>(100) ;
```
- 
```java
for (int i = 0; i < 100; i++) {
```
- 
```java
hashset.add(i) ;
```
- 
```java
}
```
- 
```java
Assert.assertTrue(hashset.contains(1));
```
- 
```java
Assert.assertTrue(hashset.contains(2));
```
- 
```java
Assert.assertTrue(hashset.contains(3));
```
- 
- 
```java
long end = System.currentTimeMillis();
```
- 
```java
System.out.println("执行时间：" + (end - star));
```
- 
```java
}
```
当我只写入 100 条数据时自然是没有问题的。
还是在这个基础上，写入 1000W 数据试试：
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianWcpAznJfmqibIKs5fkWic8VlfY1st0hjUgSDp5mMut9hpGA8JiagdckTA/640)
执行后马上就内存溢出。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianZQyKHQA2n1aE8AvT7kHDyoXYpe5JrIU3ZfrcMuUNdNNPwErqrCxZ5w/640)
可见在内存有限的情况下我们不能使用这种方式。
实际情况也是如此；既然要判断一个数据是否存在于集合中，考虑的算法的效率以及准确性肯定是要把数据全部 `load` 到内存中的。
# Bloom Filter
基于上面分析的条件，要实现这个需求最需要解决的是 `如何将庞大的数据load到内存中。`
而我们是否可以换种思路，因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。
伟大的科学家们已经帮我们想到了这样的需求。
`BurtonHowardBloom` 在 1970 年提出了一个叫做 `BloomFilter`（中文翻译：布隆过滤）的算法。
它主要就是用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。
所以在这个场景下在合适不过了。
## Bloom Filter 原理
下面来分析下它的实现原理。
> 
官方的说法是：它是一个保存了很长的二级制向量，同时结合 Hash 函数实现的。
听起来比较绕，但是通过一个图就比较容易理解了。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGiancITgRibThicbh1uSsD00Az1wNtzodfbykcXgrH41vtSVXIdrjjMfoOSQ/640)
如图所示：
- 
首先需要初始化一个二进制的数组，长度设为 L（图中为 8），同时初始值全为 0 。
- 
当写入一个 `A1=1000` 的数据时，需要进行 H 次 `hash` 函数的运算（这里为 2 次）；与 HashMap 有点类似，通过算出的 `HashCode` 与 L 取模后定位到 0、2 处，将该处的值设为 1。
- 
`A2=2000` 也是同理计算后将 `4、7` 位置设为 1。
- 
当有一个 `B1=1000` 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 `B1=1000` 存在于集合中。
- 
当有一个 `B2=3000` 时，也是同理。第一次 Hash 定位到 `index=4` 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 `index=5` 的值为 0，所以认为 `B2=3000` 不存在于集合中。
整个的写入、查询的流程就是这样，汇总起来就是：
> 
对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。
一旦其中的有一位为 **0** 则认为数据**肯定不存在于集合**，否则数据**可能存在于集合中**。
所以布隆过滤有以下几个特点：
- 
只要返回数据不存在，则肯定不存在。
- 
返回数据存在，但只能是大概率存在。
- 
同时不能清除其中的数据。
第一点应该都能理解，重点解释下 2、3 点。
为什么返回存在的数据却是可能存在呢，这其实也和 `HashMap` 类似。
在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 `A、B` 两个数据最后定位到的位置是一模一样的。
这时拿 B 进行查询时那自然就是误报了。
删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。
基于以上的 `Hash` 冲突的前提，所以 `BloomFilter` 有一定的误报率，这个误报率和 `Hash` 算法的次数 H，以及数组长度 L 都是有关的。
# 自己实现一个布隆过滤
算法其实很简单不难理解，于是利用 `Java` 实现了一个简单的雏形。
- 
```java
public class BloomFilters {
```
- 
- 
```java
/**
```
- 
```java
* 数组长度
```
- 
```java
*/
```
- 
```java
private int arraySize;
```
- 
- 
```java
/**
```
- 
```java
* 数组
```
- 
```java
*/
```
- 
```java
private int[] array;
```
- 
- 
```java
public BloomFilters(int arraySize) {
```
- 
```java
this.arraySize = arraySize;
```
- 
```java
array = new int[arraySize];
```
- 
```java
}
```
- 
- 
```java
/**
```
- 
```java
* 写入数据
```
- 
```java
* @param key
```
- 
```java
*/
```
- 
```java
public void add(String key) {
```
- 
```java
int first = hashcode_1(key);
```
- 
```java
int second = hashcode_2(key);
```
- 
```java
int third = hashcode_3(key);
```
- 
- 
```java
array[first % arraySize] = 1;
```
- 
```java
array[second % arraySize] = 1;
```
- 
```java
array[third % arraySize] = 1;
```
- 
- 
```java
}
```
- 
- 
```java
/**
```
- 
```java
* 判断数据是否存在
```
- 
```java
* @param key
```
- 
```java
* @return
```
- 
```java
*/
```
- 
```java
public boolean check(String key) {
```
- 
```java
int first = hashcode_1(key);
```
- 
```java
int second = hashcode_2(key);
```
- 
```java
int third = hashcode_3(key);
```
- 
- 
```java
int firstIndex = array[first % arraySize];
```
- 
```java
if (firstIndex == 0) {
```
- 
```java
return false;
```
- 
```java
}
```
- 
- 
```java
int secondIndex = array[second % arraySize];
```
- 
```java
if (secondIndex == 0) {
```
- 
```java
return false;
```
- 
```java
}
```
- 
- 
```java
int thirdIndex = array[third % arraySize];
```
- 
```java
if (thirdIndex == 0) {
```
- 
```java
return false;
```
- 
```java
}
```
- 
- 
```java
return true;
```
- 
- 
```java
}
```
- 
- 
- 
```java
/**
```
- 
```java
* hash 算法1
```
- 
```java
* @param key
```
- 
```java
* @return
```
- 
```java
*/
```
- 
```java
private int hashcode_1(String key) {
```
- 
```java
int hash = 0;
```
- 
```java
int i;
```
- 
```java
for (i = 0; i < key.length(); ++i) {
```
- 
```java
hash = 33 * hash + key.charAt(i);
```
- 
```java
}
```
- 
```java
return Math.abs(hash);
```
- 
```java
}
```
- 
- 
```java
/**
```
- 
```java
* hash 算法2
```
- 
```java
* @param data
```
- 
```java
* @return
```
- 
```java
*/
```
- 
```java
private int hashcode_2(String data) {
```
- 
```java
final int p = 16777619;
```
- 
```java
int hash = (int) 2166136261L;
```
- 
```java
for (int i = 0; i < data.length(); i++) {
```
- 
```java
hash = (hash ^ data.charAt(i)) * p;
```
- 
```java
}
```
- 
```java
hash += hash << 13;
```
- 
```java
hash ^= hash >> 7;
```
- 
```java
hash += hash << 3;
```
- 
```java
hash ^= hash >> 17;
```
- 
```java
hash += hash << 5;
```
- 
```java
return Math.abs(hash);
```
- 
```java
}
```
- 
- 
```java
/**
```
- 
```java
*  hash 算法3
```
- 
```java
* @param key
```
- 
```java
* @return
```
- 
```java
*/
```
- 
```java
private int hashcode_3(String key) {
```
- 
```java
int hash, i;
```
- 
```java
for (hash = 0, i = 0; i < key.length(); ++i) {
```
- 
```java
hash += key.charAt(i);
```
- 
```java
hash += (hash << 10);
```
- 
```java
hash ^= (hash >> 6);
```
- 
```java
}
```
- 
```java
hash += (hash << 3);
```
- 
```java
hash ^= (hash >> 11);
```
- 
```java
hash += (hash << 15);
```
- 
```java
return Math.abs(hash);
```
- 
```java
}
```
- 
```java
}
```
- 
首先初始化了一个 int 数组。
- 
写入数据的时候进行三次 `hash` 运算，同时把对应的位置置为 1。
- 
查询时同样的三次 `hash` 运算，取到对应的值，一旦值为 0 ，则认为数据不存在。
实现逻辑其实就和上文描述的一样。
下面来测试一下，同样的参数：
- 
```java
-Xms64m -Xmx64m -XX:+PrintHeapAtGC
```
- 
```java
@Test
```
- 
```java
public void bloomFilterTest(){
```
- 
```java
long star = System.currentTimeMillis();
```
- 
```java
BloomFilters bloomFilters = new BloomFilters(10000000) ;
```
- 
```java
for (int i = 0; i < 10000000; i++) {
```
- 
```java
bloomFilters.add(i + "") ;
```
- 
```java
}
```
- 
```java
Assert.assertTrue(bloomFilters.check(1+""));
```
- 
```java
Assert.assertTrue(bloomFilters.check(2+""));
```
- 
```java
Assert.assertTrue(bloomFilters.check(3+""));
```
- 
```java
Assert.assertTrue(bloomFilters.check(999999+""));
```
- 
```java
Assert.assertFalse(bloomFilters.check(400230340+""));
```
- 
```java
long end = System.currentTimeMillis();
```
- 
```java
System.out.println("执行时间：" + (end - star));
```
- 
```java
}
```
执行结果如下：
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianCG3ibyEgpTgT9UnGQduAkSY81RUMwh8UbAEVfe9hiaKDthqa8VLMO1eQ/640)
只花了 3 秒钟就写入了 1000W 的数据同时做出来准确的判断。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianUe1k90uEYBXBvaIP21v3lRA8jzUVzIGJdzsUOxrTFTiaqXYQich2ibxFw/640)
当让我把数组长度缩小到了 100W 时就出现了一个误报， `400230340` 这个数明明没在集合里，却返回了存在。
这也体现了 `BloomFilter` 的误报率。
我们提高数组长度以及 `hash` 计算次数可以降低误报率，但相应的 `CPU、内存`的消耗就会提高；这就需要根据业务需要自行权衡。
# Guava 实现
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGian0BXm7ZVdIuTYV5XmNWnowZbibibu6eibxicUZ723g9EL44L56a5cRAUq5Q/640)
刚才的方式虽然实现了功能，也满足了大量数据。但其实观察 `GC` 日志非常频繁，同时老年代也使用了 90%，接近崩溃的边缘。
总的来说就是内存利用率做的不好。
其实 Google Guava 库中也实现了该算法，下面来看看业界权威的实现。
- 
```java
-Xms64m -Xmx64m -XX:+PrintHeapAtGC
```
- 
```java
@Test
```
- 
```java
public void guavaTest() {
```
- 
```java
long star = System.currentTimeMillis();
```
- 
```java
BloomFilter<Integer> filter = BloomFilter.create(
```
- 
```java
Funnels.integerFunnel(),
```
- 
```java
10000000,
```
- 
```java
0.01);
```
- 
- 
```java
for (int i = 0; i < 10000000; i++) {
```
- 
```java
filter.put(i);
```
- 
```java
}
```
- 
- 
```java
Assert.assertTrue(filter.mightContain(1));
```
- 
```java
Assert.assertTrue(filter.mightContain(2));
```
- 
```java
Assert.assertTrue(filter.mightContain(3));
```
- 
```java
Assert.assertFalse(filter.mightContain(10000000));
```
- 
```java
long end = System.currentTimeMillis();
```
- 
```java
System.out.println("执行时间：" + (end - star));
```
- 
```java
}
```
也是同样写入了 1000W 的数据，执行没有问题。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianyaOIGZF4tyWFv18InKB7I9aoKxJYibMq9wukIh9rAojqm9IEfU6luJA/640)
观察 GC 日志会发现没有一次 `fullGC`，同时老年代的使用率很低。和刚才的一对比这里明显的要好上很多，也可以写入更多的数据。
## 源码分析
那就来看看 `Guava` 它是如何实现的。
构造方法中有两个比较重要的参数，一个是预计存放多少数据，一个是可以接受的误报率。
我这里的测试 demo 分别是 1000W 以及 0.01。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianFVATmstxOkTWMpqD9xqicFASA2bDF0kz0or7GGFRfGE1GwFO52RNayQ/640)
`Guava` 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 `numBits` 以及需要计算几次 Hash 函数 `numHashFunctions` 。
这个算法计算规则可以参考维基百科。
### put 写入函数
真正存放数据的 `put` 函数如下：
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianJfDkAQGicvAytSicibBeXMadsSlMMhvVnCY411PVLZRbuJibN6mpsC2IsQ/640)
- 
根据 `murmur3_128` 方法的到一个 128 位长度的 `byte[]`。
- 
分别取高低 8 位的到两个 `hash` 值。
- 
再根据初始化时的到的执行 `hash` 的次数进行 `hash` 运算。
- 
```java
bitsChanged |= bits.set((combinedHash & Long.MAX_VALUE) % bitSize);
```
其实也是 `hash取模`拿到 `index` 后去赋值 1.
重点是 `bits.set()` 方法。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianorEMr8Xm8raUu4DibxtnratyiaGTdgWWe0LvyHRJjibEB1SaFhQicGhT4g/640)
其实 set 方法是 `BitArray` 中的一个函数， `BitArray` 就是真正存放数据的底层数据结构。
利用了一个 `long[]data` 来存放数据。
所以 `set()` 时候也是对这个 `data` 做处理。
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianesDCuV4GOqxq2vkDDrKia3LHiaWr1DO1sR5PHgj7TfCWQEzUrgUicL8KQ/640)
- 
在 `set` 之前先通过 `get()` 判断这个数据是否存在于集合中，如果已经存在则直接返回告知客户端写入失败。
- 
接下来就是通过位运算进行 `位或赋值`。
- 
`get()` 方法的计算逻辑和 set 类似，只要判断为 0 就直接返回存在该值。
### mightContain 是否存在函数
![640](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/csD7FygBVl1whlD22IErSG1dFe3uTGianVQP0UPh4vw2QtQ9ZRE23zp6grWiaj4kBnIMtkg4NP2v3IkHNS0lbr8A/640)
前面几步的逻辑都是类似的，只是调用了刚才的 `get()` 方法判断元素是否存在而已。
# 总结
布隆过滤的应用还是蛮多的，比如数据库、爬虫、防缓存击穿等。
特别是需要精确知道某个数据不存在时做点什么事情就非常适合布隆过滤。
这段时间的研究发现算法也挺有意思的，后续应该会继续分享一些类似的内容。
如果对你有帮助那就分享一下吧。
本问的示例代码参考这里：https://github.com/crossoverJie/JCSprout
-END-
**纯洁的微笑**
**一个有故事的程序员**
![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/PgqYrEEtEnqjV7GOKB2htgfZjgMjqxftxfmmdrLiaMKpyicTmLLX5fUjb6YxA6Z5Bhcozb3p0uMV7wqdKED89HZA/640?wx_fmt=jpeg)
