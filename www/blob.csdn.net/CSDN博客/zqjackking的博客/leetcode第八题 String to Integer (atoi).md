# leetcode第八题  String to Integer (atoi) - zqjackking的博客 - CSDN博客





2017年02月19日 10:39:40[zqjackking](https://me.csdn.net/zqjackking)阅读数：187








题目要求： 

1. 字串为空或者全是空格，返回0；  

2. 字串的前缀空格需要忽略掉； 

3. 忽略掉前缀空格后，遇到的第一个字符，如果是‘+’或‘－’号，继续往后读；如果是数字，则开始处理数字；如果不是前面的2种，返回0； 

4. 处理数字的过程中，如果之后的字符非数字，就停止转换，返回当前值； 

5. 在上述处理过程中，如果转换出的值超出了int型的范围，就返回int的最大值或最小值。 

我一开始的代码如下：
```
int len=str.size();
if(len==0)
    return 0;
int i;
int sign=1;
int ans=0;
for(i=0;str[i]==' ';i++); //为了让for循环不影响后面的，在此加上了分号
if(str[i]=='+')
{
    sign=1;
    i++;
}
else if(str[i]=='-')
{
    sign=-1;
    i++;
}
while(i<len&&str[i]>='0'&&str[i]<='9')
{
    ans=ans*10+str[i++]-'0';
    if(ans*sign>=INT_MAX)
        return INT_MAX;
    if(ans*sign<=INT_MIN)
        return INT_MIN;
}
return ans*sign;
```

这样做会报错。输入是”2147483648”时，输出是“-2147483648”（正确结果是2147483647） 

当输入为“2147483648”（INT_MAX+1）,最后一次执行ans=ans*10+str[i++]-‘0’之前ans=214748364，可是一执行这一句话就产生了溢出。（后面那个自然也检测不出来了） 

对于int来说，2147483647+1=-2147483648，也就是214748364*10+8=-2147483648。 

但是如果把ans的定义从int改成long，就没问题了。我也不知道是怎么回事。 

查了下，sizeof(int)=sizeof(long)=4,sizeof(long long)=8;其能表示的最大数为2^31-1,最小的数是-2^31. 

现在以8位的为例。（计算机中以补码存储，所以下面都是补码） 

255  01111111 

-256 10000000 

-255 10000001 

-1     11111111 

0       00000000 

所以就有   255+1=-256（溢出），-256-1=255（溢出）  -1+1=0。 

对于计算机来说，它在执行加法计算的时候完全是按照补码相加，而不用考虑正负号，甚至都不用考虑溢出的问题。 

回到正题，在认识到上述问题后，我修改了while循环。
```
while(i<len&&str[i]>='0'&&str[i]<='9')
 {
   if(ans>INT_MAX/10||(ans==INT_MAX/10&&str[i]>'7'))
       return  (sign==1)?INT_MAX:INT_MIN;
    ans=ans*10+str[i++]-'0';
 }
```

也就是在执行ans=ans*10+str[i++]-‘0’之前就着手检查，而不是在溢出之后才检查，那样就晚了。





