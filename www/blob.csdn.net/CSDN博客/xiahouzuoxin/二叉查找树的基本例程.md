# 二叉查找树的基本例程 - xiahouzuoxin - CSDN博客





2012年11月07日 20:13:50[xiahouzuoxin](https://me.csdn.net/xiahouzuoxin)阅读数：2028








        使二叉树为二叉查找树（Binary Search Tree）的性质是：对于树中的每个节点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。


        以下为BinaryTree的基本实现例程，大部分功能采用递归实现。

        参考书籍《数据结构与算法——C语言实现》！

types.h



```cpp
/*
 * =====================================================================================
 *
 *       Filename:  types.h
 *
 *    Description:  definition of types
 *
 *        Version:  1.0
 *        Created:  2012/9/19 14:08:58
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  xhzuoxin (QQ:1126804077), xiahouzuoxin@163.com
 *   Organization:  
 *
 * =====================================================================================
 */
#ifndef _TYPES_H
#define _TYPES_H

#ifndef _STDINT_H
typedef unsigned char        uint8_t;
typedef unsigned short       uint16_t;
typedef unsigned long        uint32_t;
typedef char                 int8_t;
typedef short                int16_t;
typedef long                 int32_t;
typedef float                fp32_t;
typedef double               fp64_t;
#endif

typedef unsigned char        uint8;
typedef unsigned short       uint16;
typedef unsigned long        uint32;
typedef char                 int8;
typedef short                int16;
typedef long                 int32;
typedef float                fp32;
typedef double               fp64;

typedef unsigned char        UINT8;
typedef unsigned short       UINT16;
typedef unsigned long        UINT32;
typedef char                 INT8;
typedef short                INT16;
typedef long                 INT32;
typedef float                FP32;
typedef double               FP64;

#ifndef TRUE
#define TRUE                 (1)
#endif
#ifndef FALSE             
#define FALSE                (0)
#endif

typedef enum BOOLEAN_ENUM
{
	false = 0,
	true = 1
}boolean, BOOLEAN;

#endif
```





bsTree.h



```cpp
/*
 * =====================================================================================
 *
 *       Filename:  bsTree.h
 *
 *    Description:  Binary search tree
 *
 *        Version:  1.0
 *        Created:  2012/11/7 10:24:31
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  xhzuoxin (QQ:1126804077), xiahouzuoxin@163.com
 *   Organization:  
 *
 * =====================================================================================
 */
#ifndef _BSTREE
#define _BSTREE

#include <stdio.h>
#include <stdlib.h>
#include "types.h"

typedef UINT16 EleType;
struct TreeNode
{
	EleType ele;
	struct TreeNode *Left;
	struct TreeNode *Right;
};
typedef struct TreeNode *Position;
typedef struct TreeNode *SearchTree;

SearchTree MakeEmpty( SearchTree T );
Position Find(EleType X, SearchTree T);
Position FindMin(SearchTree T);
Position FindMax(SearchTree T);
SearchTree Insert(EleType X, SearchTree T);
SearchTree Delete(EleType X, SearchTree T);
EleType Retrieve(Position P);

void PrintTree(SearchTree T);

#endif
```


bsTree.c





```cpp
/*
 * =====================================================================================
 *
 *       Filename:  bsTree.c
 *
 *    Description:  pacages for binary tree, most of them are carry out by recursive
 *
 *        Version:  1.0
 *        Created:  2012/11/7 10:33:09
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  xhzuoxin (QQ:1126804077), xiahouzuoxin@163.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include "bsTree.h"

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  MakeEmpty
 *  Description:  init SearchTree be NULL
 * =====================================================================================
 */
SearchTree MakeEmpty(SearchTree T)
{
	if(T != NULL)
	{
		MakeEmpty(T->Left);
		MakeEmpty(T->Right);
		free(T);
	}

	return NULL;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  Find
 *  Description:  Find element X from BinaryTree
 *                return the node pointer to the element node
 * =====================================================================================
 */
Position Find(EleType X, SearchTree T)
{
	if(T == NULL)
	{
		return NULL;
	}
	if(X < T->ele)
	{
		return Find(X, T->Left);
	}
	else if(X > T->ele)
	{
		return Find(X, T->Right);
	}
	else 
	{
		return T;
	}
}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  FindMax
 *  Description:  Find max element form Tree
 *                return pointer to the max element node
 * =====================================================================================
 */
Position FindMax(SearchTree T)
{
	if(T == NULL)
	{
		return NULL;
	}
	else if(T->Right == NULL)
	{
		return T;
	}
	else
	{
		return FindMax(T->Right);
	}
}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  FindMin
 *  Description:  Find min element form Tree
 *                return pointer to the min element node
 * =====================================================================================
 */
Position FindMin(SearchTree T)
{
	if(T == NULL)
	{
		return NULL;
	}
	else if(T->Left == NULL)
	{
		return T;
	}
	else
	{
		return FindMin(T->Left);
	}
}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  Insert
 *  Description:  insert an element to the tree 
 * =====================================================================================
 */
SearchTree Insert(EleType X, SearchTree T)
{
	if(T == NULL)
	{
		/* create a new node tree */
		T = (SearchTree)malloc(sizeof(struct TreeNode));
		if(T == NULL)
		{
			printf("error: cannot alloc space for tree node!\n");
			return NULL;
		}
		else
		{
			T->ele = X;
			T->Left = T->Right = NULL;
		}
	}
	else if(X < T->ele)
	{
		T->Left = Insert(X, T->Left);
	}
	else if(X > T->ele)
	{
		T->Right = Insert(X, T->Right);
	}
	else
	{
		//node already in the tree, do nothing
	}

	return T;
}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  Delete
 *  Description:  delete @X from tree, considered one child and two child
 * =====================================================================================
 */
SearchTree Delete(EleType X, SearchTree T)
{
	Position TempCell = NULL;

	if(T == NULL)
	{
		printf("cannot find %d to delete!\n", X);
		return NULL;
	}
	else if(X < T->ele)
	{
		T->Left = Delete(X, T->Left);
	}
	else if(X > T->ele)
	{
		T->Right = Delete(X, T->Right);
	}
	else if( (T->Left != NULL) && (T->Right != NULL) )
	{
		/* 2 child */
		TempCell = FindMin(T->Right);
		T->ele = TempCell->ele;
		T->Right = Delete(T->ele, T->Right);
	}	
	else
	{
		/* 1 child or 0 child */
		TempCell = T;
		if(T->Left == NULL)
		{
			T = T->Right;
		}
		else if(T->Right == NULL)
		{
			T = T->Left;
		}
		free(TempCell);
	}

	return T;
}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  PrintTree
 *  Description:  printf tree elements by recursive
 * =====================================================================================
 */
void PrintTree(SearchTree T)
{
	if(T != NULL)
	{
		PrintTree(T->Left);
		printf("%d ", T->ele);
		PrintTree(T->Right);
	}
}
```


test.c





```cpp
/*
 * =====================================================================================
 *
 *       Filename:  test.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2012/11/7 10:58:23
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  xhzuoxin (QQ:1126804077), xiahouzuoxin@163.com
 *   Organization:  
 *
 * =====================================================================================
 */

#include "bsTree.h"

int main(void)
{
	SearchTree T = NULL;
	Position P = NULL;

	MakeEmpty(T);
	T = Insert(10, T);
	T = Insert(20, T);
	T = Insert(30, T);
	T = Insert(5, T);
	T = Insert(7, T);
	T = Insert(3, T);
	T = Insert(9, T);

	printf("Tree:\n");
	PrintTree(T);
	printf("\n");
	P = FindMax(T);
	printf("max=%d\n", P->ele);
	P = FindMin(T);
	printf("min=%d\n", P->ele);

	T = Delete(5, T);
	PrintTree(T);

	return 0;
}
```


因为采用gcc编译，其makefile文件如下：



```
SRC=bsTree.c bsTree.h test.c

all:$(SRC)
	gcc -g -Wall $^ -o $@

.PHONY:clean tags run
clean:
	rm *.o all *~
tags:
	ctags -R --c++-kinds=+p --fields=+iaS --extra=+q
run:
	./all
```

测试结果输出



![](https://img-my.csdn.net/uploads/201211/07/1352290631_2402.JPG)




