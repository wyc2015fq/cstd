# 函数返回类型为指针类型时的一些问题 - xiahouzuoxin - CSDN博客





2012年08月23日 21:00:04[xiahouzuoxin](https://me.csdn.net/xiahouzuoxin)阅读数：1018标签：[存储																[function																[null](https://so.csdn.net/so/search/s.do?q=null&t=blog)
个人分类：[ComputerLanuage](https://blog.csdn.net/xiahouzuoxin/article/category/1172320)





原文出处：[http://blog.csdn.net/tigerjb/article/details/7425571#comments](http://blog.csdn.net/tigerjb/article/details/7425571#comments)



1.先看程序：





```cpp
#include<stdio.h>
char *returnStr()
{
           char  *p = “tigerjibo”;
           return  p;
}
int  main()
{
           char*str;
           str =returnStr();
   //str[0]=’T’;则会引起错误，不能修改只读数据段中的内容
           printf(“%s\n”,str);
           return0;
}
```

来分析下该程序。

（1）char  *p = “tigerjibo”。系统在栈上分配四个字节的空间存放p的数值。“tigerjibo”是字符常量，存放在只读数据段内。指向完后，系统把”tigerjibo”的地址赋值给p。

（2）函数用return 把p的数值返回。该数值指向只读数据段（该数据段内的数据是静态的不会改变）。退出子函数后，系统把p的数值销毁。但是p的数值已经通过return 返回。且只读数据段中的内容不会被修改和回收（其输于静态区域）

（3）在主程序中把该地址又给了str。因此str指向了“tigerjbo”。

（4）该程序虽然能运行，担又一个缺点，就是在程序中不能修改字符常常量中的数值。如果修改会引起段错误。

2.先看程序



```cpp
#include<stdio.h>
char *returnStr()
{
           char  p[]=”tigerjibo”;
           return  p;
}
int  main()
{
           char  *str;
           str =returStr();
           printf(“%s\n”,str);
}
```



编译该程序后，系统会提示如下警告：



function returns  address of local variable

（函数返回一个可变地址）

分析该错误：

1>”tigerjibo”是一个字符常量，存放在只读数据段中，是不能被修改的。

2>char p[],是一个局部变量，当函数被调用时，在栈上开辟一个空间来存放数组P的内容。

3>char p[]=”tigerjibo”，该语句是把”tigerjibo”的值赋值给数值P,存放在数组p地址处。而不是把”tigerjibo”的地址赋值给数组p。因此，“tigerjibo”此时在系统中有一处备份，一个在只读数据段中（不能修改，内容也不会被回收），一个在栈上存储（可以修改起内容，但函数退出后，其栈上存储的内容也会被回收）。

4>因此，当return p,返回了数组的首地址，但是当函数退出后，其栈上的内容也将被丢弃，局部变量的内存也被清空了，因此该数组首地址处的内容是一个可变的值。

3.先看一个程序：



```cpp
#include<stdio.h>
char *returnStr()
{
           static  char p[]=”tigerjibo”;
           return  p;
}
int  main()
{
           char  *str;
           str =returnStr();
           str[0]=’T’;
           printf(“%s\n”,str);
}
```



此程序运行正确。

分析如下：

1>”tigerjibo”是一个字符常量，存放在只读数据段中，是不能被修改的。

2>static char p[],是一个静态局部变量，在读写数据段中开辟一个空间给p用来存放其数值。

3>static char p[]=”tigerjibo”，该语句是把”tigerjibo”的值赋值给数值P,存放在数组p地址处。而不是把”tigerjibo”的地址赋值给数组p。因此，“tigerjibo”此时在系统中有一处备份，一个在只读数据段中（不能修改，内容也不会被回收），一个在读写数据段中存储（可以修改其内容，当函数退出后，因其在读写数据段中存储，起内容不会被丢弃）。

4>因此，当return p,返回了数组的首地址，但是当函数退出后，虽然栈上的内容都清除了，但是p地址是读写数据段中的地址，其上的内容不会被回收。

4.先看一个程序：



```cpp
#include<stdio.h>
#include<string.h>
#include<strdlib.h>
void getmemory(char *p)
{
        p = (char *)malloc(100);
}
int  main()
{
      char  *str=NULL;
      getmemory(str);
      strcpy(str,”helloworld”);
      printf(“%s\n”,str);
}
```



编译后错误：

段错误

分析：在主程序中，str地址为空。在函数传递中将str的地址传给了子函数中的指针p(是拷贝了一份)，然后在字函数中给p在堆上申请了一个100字节的空间，并把首地址赋值给p。但是函数传递中，p值改变不会影响到主函数中str的值。因此,str的地址仍为空。在strcpy中引用空指针会出现段错误。](https://so.csdn.net/so/search/s.do?q=function&t=blog)](https://so.csdn.net/so/search/s.do?q=存储&t=blog)




