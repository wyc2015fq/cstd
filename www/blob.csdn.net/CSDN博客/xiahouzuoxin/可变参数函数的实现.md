# 可变参数函数的实现 - xiahouzuoxin - CSDN博客





2012年06月22日 16:35:17[xiahouzuoxin](https://me.csdn.net/xiahouzuoxin)阅读数：1510
个人分类：[ComputerLanuage](https://blog.csdn.net/xiahouzuoxin/article/category/1172320)









前提要求：包含#include <stdarg.h>，该头文件中定义了一个va_list类型和三个宏——va_start、va_list和va_end。



## 标准 C 库 <stdarg.h>




它接受一个格式字符串，并且后面跟随任意指定的参数，根据实际需要而确定入参的个数。


实际上它的实现要依赖于一个标准 C 库 <stdarg.h>，standard argument(标准参数) 的意思。下面先稍为介绍一下 <stdarg.h>，或者在 C++ 中的 <cstdarg> 的功效：


这实际上是一组初始化和调用可变参数的宏，下面先介绍一下可变参数表的调用形式以及原理：


首先是参数的内存存放格式：参数存放在内存的[堆栈段](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)中，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址，举个例子如下：


void func(int x, float y, char z);


那么，调用函数的时候，[实参](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#) char z 先进栈，然后是 float y，最后是 int x，因此在内存中[变量](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)的存放次序是
 x->y->z，因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过[指针](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)移位运算，则总可以顺藤摸瓜找到其他的输入变量。


然后是可变入参表格式，省略的参数用** ... **代替，但必须注意：


1. 只能有一个 **... **并且它必须是最后一个参数；


2. 不要只用一个 **... **作为所有的参数，因为从后面可以知道，这样你无法确定入参表的地址。


举个例子，声明函数如下：


void func(int x, int y, **...**);


然后调用：func(3, 5, 'c', 2.1f, 6);


于是在调用参数的时候，[编译器](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)则不会检查实际输入的是什么参数，只管把所有参数按照上面描述的方法，变成[实参](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)堆放在内存中，在本例中，内存中依次存放
 x=3, y=5, 'c', 2.1f, 6


但是有一个需要注意的地方，这些东西只是紧挨着堆放在内存中，于是想要正确调用这些参数，必须知道他们确切的类型，并且我们也关心这个参数表实际的长度，然而不幸的是，这些我们无从得知。因此，这个解决办法决不是高明的，从某种程度上说，这甚至是一个严重的漏洞。因此，C++ 很不提倡去使用它。不过缺点归缺点，万不得已的时候我们还是得用，但是我们对里面输入[变量](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)的时候，应该对入参的类型有一个清醒的认识，否则这样的操作是很危险的。


下面是 <stdarg.h> 对上面这一个思路的实现，里面重要的几个宏定义如下：


typedef char* va_list;


void va_start ( va_list ap, prev_param ); /* ANSI version */


type va_arg ( va_list ap, type );


void [va_end](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#) ( va_list ap );


其中，va_list 是一个字符[指针](http://baike.baidu.com/edit/1340814?lemmaId=1340814&subLemmaId=1340814&dl=2#)，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。


【实现过程实例】

```cpp
/*
 * 作者：夏侯佐鑫
 * 日期: 2012.06.21
 * 功能：可变参数计算平均值 
 */
#include <stdio.h>
#include <stdarg.h>

float average(int n_values, ...)
{
	va_list var_arg;
	int count = 0;
	float sum = 0;
	
	/*
 	 * 可变参数访问 
	 */
	 va_start(var_arg, n_values);  //function:将var_arg变量设置为指向可变参数部分的第一个参数 
	/*
 	 * 添加取自可变参数列表值 
	 */	  
	 for(count=0; count<n_values; count+=1)
	 {
	 	sum += va_arg(var_arg, int);
	 }
	 
	 va_end(var_arg);
	 
	 return sum / n_values;
}

int main(void)
{
	float a = average(3, 20,10,30);  //第一个值为后续参数个数 
	
	printf("求平均值结果为%f\n", a);
	
	return
```

【结果】

![](https://img-my.csdn.net/uploads/201206/23/1340383079_1073.JPG)





