# 关于怎样产生随机数的彻底研究 - xiahouzuoxin - CSDN博客





2013年08月11日 23:00:06[xiahouzuoxin](https://me.csdn.net/xiahouzuoxin)阅读数：3632








C语言/C++中怎样产生随机数


C语言/C++怎样产生随机数：这里要用到的是rand()函数, srand()函数，C语言/C++里没有自带的random(int number)函数。



(1)  如果你只要产生随机数而不需要设定范围的话，你只要用rand()就可以了：rand()会返回一随机数值, 范围在0至RAND_MAX 间。RAND_MAX定义在stdlib.h, 其值为2147483647。

例如：

> 
#include<stdio.h>

#include<stdlib.h>

void main()

{

       for(int i=0;i<10;i+)

             printf("%d\n",rand());   //printf("%d\n",rand()%100);

}

//这里貌似有点小问题，若用**rand()%n(n表示范围)，**也是可以产生一定范围的随机数的。






(2)  如果你要随机生成一个在一定范围的数，你可以在宏定义中定义一个random(int number)函数，然后在main()里面直接调用random()函数：

> 
例如：随机生成10个0~100的数（主题代码）：


#define random(x) (rand()%x)       



for(int x=0;x<10;x++)

   printf("%d\n",random(100));    //范围，0~100。


---------------------

(3)但是上面两个例子所生成的随机数都只能是一次性的，如果你第二次运行的时候输出结果仍和第一次一样。这与srand()函数有关。srand()用来设置rand()产生随机数时的随机数种子。

在调用rand()函数产生随机数前，必须先利用srand()设好随机数种子（seed）, 如果未设随机数种子, rand()在调用时会自动设随机数种子为1。



上面的两个例子就是因为没有设置随机数种子，每次随机数种子都自动设成相同值1 ，进而导致rand()所产生的随机数值都一样。

srand()函数定义 ： void srand (unsigned int seed);

通常可以利用geypid()或time(0)的返回值来当做seed

如果你用time(0)的话，要加入头文件#include<time.h>

> 
例如：
#include<stdio.h>

#include<stdlib.h>

#include<time.h>

#define random(x) (rand()%x)         //此x表示。。


int main()

{

     srand((int)time(0));

     for(int x=0;x<10;x++)

        printf("%d\n",random(100）);   //产生0~100之间的数。

     return 0;

}


这样两次运行的结果就会不一样了！！





------------------------------------------------------------------ 

**rand()通常的使用方法是这样的：**

rand()不需要参数，它会返回一个从0到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。

这样，如果你要产生0~10的10个整数，可以表达为：

int N = rand() % 11;

这样，N的值就是一个0~10的随机数，如果要产生1~10，则是这样：

int N = 1 + rand() % 11;



总结来说，可以表示为：
a + rand() % n

其中的a是起始值，n是整数的范围。

//此处，需用一个**for循环控制**要产生随机数的个数。



--------

ok。我自己写小段代码测试下（主体代码）：



 for(int x=0;x<10;x++)

  printf("%d\n",rand()%100);

//不过，每次产生的随机数，都是相同的。莫急，以下有解决办法。

---------------------------------------------



若要0~1的小数，则可以先取得0~10的整数，然后均除以10即可得到随机到十分位的10个随机小数，若要得到随机到百分位的随机小数，则需要先得到0~100的10个整数，然后均除以100，其它情况依此类推。

----

如 in a=rand()%10;      //0~10的整数

**return b=a/10;**     //0~1的小数。

-----------



通常rand()产生的随机数在每次运行的时候都是与上一次相同的，这是有意这样设计的，是为了便于程序的调试。若要产生每次不同的随机数，可以使用srand( seed )函数进行随机化，随着seed的不同，就能够产生不同的随机数。

----------

如：

#include<stdio.h>

#include<stdlib.h>

#include<time.h>


int main()

{

 srand((int)time(0));   //加了这个东东。

 for(int x=0;x<10;x++)

  printf("%d\n",**rand()%100**);     //0~100之内。

 return 0;

}

//这样，就能每次都产生出不同的随机数了。





如大家所说，还可以包含time.h头文件，然后使用srand( time(0))来使用当前时间使随机数发生器随机化，这样就可以保证每两次运行时可以得到不同的随机数序列(只要两次运行的间隔超过1秒)。





待续中。。。



-------------------------------------------------------------





随机数产生原理及应用


原创作者:EmilMatthew

**摘要 : 本文简述了随机数的产生原理，并用 C 语言实现了迭代取中法，乘同余法等随机数产生方法，同时，还给出了在符合某种概率分布的随机变量的产生方法。关键词** : 伪随机数产生，概率分布 , 正态随机数 , 泊松随机数 , 高斯随机数


1 前言 :

在用计算机编制程序时，经常需要用到随机数，尤其在仿真等领域，更对随机数的产生提出了较高的要求，仅仅使用 C 语言类库中的随机函数已难以胜任相应的工作。

用投色子计数的方法产生真正的随机数 , 但电脑若也这样做 , 将会占用大量内存 ; 用噪声发生器或放射性物质也可产生真正的随机数 , 但不可重复 .

而用数学方法产生最适合计算机 , 这就是周期有限 , 易重复的 ” 伪随机数 ”

注 : 这里生成的随机数所处的分布为 0-1 区间上的均匀分布。不是 0-1 区间怎么办 ? 除以 (high-low), 再加上 low 不就行了 . 我们需要的随机数序列应具有非退化性，周期长，相关系数小等优点。

**2.1 迭代取中法：**     ( 鄙视它 )

这里在迭代取中法中介绍平方取中法 , 其迭代式如下 : 
**  Xn+1=(Xn^2/10^s)(mod 10^2s)                    Rn+1=Xn+1/10^2s**其中， Xn+1 是迭代算子，而 Rn+1 则是每次需要产生的随机数   。

第一个式子表示的是将 Xn 平方后右移 s 位，并截右端的 2s 位。

而第二个式子则是将截尾后的数字再压缩 2s 倍，显然 :0=<Rn+1<=1.

迭代取中法有一个不良的性就是它比较容易退化成 0.

实现 : 网上一大把 , 略 . 

** 2.2 乘同余法： **乘同余法的迭代式如下 : 

**  Xn+1=Lamda*Xn(mod M)  (Lamda 即参数λ )    Rn+1=Xn/M**


各参数意义及各步的作用可参 2.1 

当然，这里的参数的选取至关重要 .

经过前人检验的两组性能较好的素数取模乘同余法迭代式的系数为 :

1 ）   lamda=5^5,M=2^35-31

2 ）   lamda=7^5,M=2^31-1

实现 : 请注意，这里一定要用到 double long, 否则计算 2^32 会溢出

**2.3 混合同余法**： **C++ 中的 rand() 就是这么实现的 , 伪随机 , 故使用前一定要加 srand() 来随机取种** , 这样每次实验结果才不会相同 .


混合同余法是加同余法和乘同余法的混合形式 , 其迭代式如下 :

**Xn+1=( Lamda*Xn+C )%MRn+1=Xn/M**


 经前人研究表明，在 M=2^q 的条件下，参数 lamda,miu,X0 按如下选取，周期较大，概率统计特性好 :

Lamda=2^b+1,b 取 q/2 附近的数 

 C=(1/2+sqrt(3))/M

X0 为任意非负整数


它的一个致命的弱点，那就是随机数的生成在某一周期内成线性增长的趋势，显然，在大多数场合，这种极富“规律”型的随机数是不应当使用的。


实现 :

1 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/None.gif) double  _random( void ) 

 2 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockStart.gif)![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ContractedBlock.gif)![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/dot.gif) { 

 3 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif) int  a; 

 4 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif) double  r; 

 5 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)

 6 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)**a = rand() % 32767 ;**            //生成整型的随机数

 7 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)**r = (a + 0.00 ) / 32767.00 ;**     //生成浮点型的随机数

 8 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)

 9 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif) return  r; 

10 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)

11 ![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif) }






**3连续型随机变量的生成:**



**3.1 反函数法 : 又叫反变换法** , 记住 , 它首先需要使用均匀分布获得一个 (0,1) 间随机数 , 这个随机数相当于原概率分布的 Y 值 , 因为我们现在是反过来求 X. 哎 , 听糊涂了也没关系 , 只要知道算法怎么执行的就行 .

    采用概率积分变换原理 , 对于随机变量 X 的分布函数 F(X) 可以求其反函数，得 : 原来我们一般面对的是概率公式 Y=f(X). 现在反过来 , 由已知的概率分布或通过其参数信息来反求 X.

Xi=G(Ri)

其中 ,Ri 为一个 0-1 区间内的均匀分布的随机变量 .

F(X) 较简单时，求解较易，当 F(X) 较复杂时，需要用到较为复杂的变换技巧。

可能你没明白 , 看 3.1.1 的例子就一定会明白 .



**3.1.1 平均分布 :**

已知随机变量密度函数为 :

![公式](http://www.cppblog.com/images/cppblog_com/pengkuny/2978/r_Image00002.gif)

**3.1.2 指数分布 :**

指数分布的分布函数为 :

x<0 时 ,F(x)=0     ; x>=0,F(x)=1-exp(-lamda*x)

利用反函数法，可以求得 :    x=-lnR/lamda( 怎么来的别问 )



**3.2 正态分布随机变量的生成 :**

正态分布在概率统计的理论及应用中占有重要地位，因此，能产生符合正态分布的随机变量就在模拟一类的工作中占有相当重要的地位。

下面介绍两种方法。

3.2.1

    经过一定的计算变行，符合二维的正态分布的随机变量的生成可按下面的方法进行：

1) 产生位于 0-1 区间上的两个随机数 r1 和 r2.

2) 计算 u=2*r1-1,v=2*r2-1 及 w=u^2+v^2

3) 若 w>1 ，则返回 1)

4)    x=u[(-lnw)/w]^(1/2) ( 怎么来的别问 )

       y=v[(-lnw)/w]^(1/2)

如果为 (miu,sigma^2) 正态分布 , 则按上述方法产生 x 后， x’=miu+sigma*x

由于采用基于乘同余法生成的 0-1 上的随机数的正态分布随机数始终无法能过正态分布总体均值的假设检验。而采用 C 语言的库函数中的随机数生成函数 rand() 来产生 0-1 上的随机数，效果较为理想。






**3.2.2 利用中心极限定理生成符合正态分布的随机量：**

根据独立同分布的中心极限定理，有 :

![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/images/cppblog_com/pengkuny/2978/r_clip_image002.jpg)

   这里，其实只要取 n=12 （这里，亦即生成 12 个 0-1 上的随机数序列）就会有比较好的效果。

    经验证，用该种方法生成生的随机数序列同样能比较好的符合正态分布特性。

    由于生成的都是标准正态分布，所以，当需要生成 N(a,b) 的正态分布随机量时，根据正态分布的线性变换特性，只要用 x=a*x0+b 即可。（其中， x0 表示生成的符合 N(0,1) 分布的正态随机变量。方法 3.1 亦是如此）

实现 :

![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockStart.gif)
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/None.gif)1  : double  _sta( double  mu, double  sigma)  // 利用中心极限定理生成 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockStart.gif)2{ 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)3int  i; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)4double  r,sum =0.0 ; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)5
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)6if (sigma <=0.0 )   { printf( " Sigma<=0.0 in _sta! " ); exit( 1 ); }
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)7for (i =1 ;i <=12 ;i ++ ) 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)8 sum  =  sum  +  _random(); 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)9 r = (sum -6.00 ) * sigma + mu; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)10
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)11return  r; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)12
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)13 }
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/None.gif)14
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/None.gif)
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/None.gif)1double  _sta2( double  mu, double  sigma)  //  利用反函数法公式x=u[(-lnw)/w]^(1/2) 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockStart.gif)2{ 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)3double  r1,r2; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)4
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)5 r1 = _random(); 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)6 r2 = _random(); 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)7
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)8return  sqrt( -2* log(r1)) * cos( 2* M_PI * r2) * sigma + mu ; 
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)9
![关于怎样产生随机数的彻底研究 <wbr>[自行理解]](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)10 }







**4 离散型随机变量的生成 :**

    离散型随机变量的生成主要是希望得到在已知 X 符合某类分布的条件下，生成相应的 X 。




       4.1 符合**泊松分布**的随机变量的生成 :

    这里，采用 ” 上限拦截 ” 法进行测试 ，我看了不懂 , 希望有人帮我分析一下 , 从数学角度帮我分析一下,谢谢!




基本的思想是这样的：

1）在泊松分布中，求出 X 取何值时， p(X=k) 取最大值时，设为 Pxmax.

    其时，这样当于求解 f(x)=lamda^k/k! 在 k 取何值时有最大值，虽然，这道题有一定的难度，但在程序中可以能过一个循环来得到取得 f(x) 取最大值时的整数自变量 Xmax 。

2) 通过迭代，不断生成 0-1 区间上的随机数，当随机数 <Pxmax 时，则终止迭代，否则重复 (2)

3) 记录迭代过程的次数，即为所需要得到的符何泊松分布的随机量。

显然，这种方法较为粗糙，在试验的过程中发现：生成的的随机量只能算是近似的服从泊松分布，所以，更为有效的算法还有待尝试。

实现 : 采用  double 至少可以支持 lamda=700 ，即 exp(-700)!=0

 1  const  int MAX_VAL = 10000 ;  

 2  double U_Rand( double a, double b)      //    均匀分布   

 3      {  

 4      double  x = random(   MAX_VAL   );  

 5      return  a + (b - a) * x / (MAX_VAL-  1 );  

 6   }   

 7    double  P_Rand(double Lamda )         //    泊松分布   

 8       {  

 9            double x = 0 ,b = 1 ,c = exp( - Lamda ),u;  

10           do  {  

11                   u  = U_Rand(    0 , 1    );  

12                   b *= u;  

13                    if ( b >= c )  

14                      x    ++ ;  

15           } while (b >=  c );    

16         




