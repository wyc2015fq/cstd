# 聚类分析（K-means算法） - wsp_1138886114的博客 - CSDN博客





2018年05月28日 22:05:44[SongpingWang](https://me.csdn.net/wsp_1138886114)阅读数：6199
所属专栏：[机器学习算法](https://blog.csdn.net/column/details/24447.html)











- - - - [1 聚类分析](#1-聚类分析)- - [1.1 相似度与距离度量](#11-相似度与距离度量)
- [1.2 聚类算法 及 划分方法](#12-聚类算法-及-划分方法)


- [2 聚类模型评估（优缺点）](#2-聚类模型评估优缺点)
- [3 K-means 在 sklearn方法](#3-k-means-在-sklearn方法)
- [4 确定K值–肘部法则–SSE](#4-确定k值肘部法则sse)
- [5 模型评估指标–轮廓系数法–最近簇](#5-模型评估指标轮廓系数法最近簇)- - [5.1 轮廓系数](#51-轮廓系数)
- [5.2 最近簇定义—平均轮廓系数 [0,1]：](#52-最近簇定义平均轮廓系数-01)
- [5.3、Canopy算法配合初始聚类](#53canopy算法配合初始聚类)


- [6 K-mean 优化](#6-k-mean-优化)- - [6.1 K-means++优化](#61-k-means优化)
- [6.2 映射到高维（Kernel k-means）](#62-映射到高维kernel-k-means)
- [6.3 二分法（二分K-means）](#63-二分法二分k-means)
- [6.4 Mini Batch K-Means（分批处理）](#64-mini-batch-k-means分批处理)
- [6.5 迭代自组织数据分析算法（ISODATA）](#65-迭代自组织数据分析算法isodata)
- [6.6 基于MCMC采样的算法](#66-基于mcmc采样的算法)
- [6.7 AFK-MC^2](#67-afk-mc2)
- [附：马尔可夫链蒙特卡洛方法](#附马尔可夫链蒙特卡洛方法)


- [7 以下代码演示：请点击](#7-以下代码演示请点击)- - [K-means 肘部法则（确定K值）](#k-means-肘部法则确定k值)
- [K-means 轮廓系数法（验证K值）](#k-means-轮廓系数法验证k值)
- [Mini Batch K-Means（适合大数据的聚类算法）](#mini-batch-k-means适合大数据的聚类算法)









![这里写图片描述](https://img-blog.csdn.net/20180528210122552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 1 聚类分析

> 
```
聚类：
    把相似数据并成一组（group）的方法。‘物以类聚，人以群分’
    不需要类别标注的算法，直接从数据中学习模式
    所以，聚类是一种 数据探索 的分析方法，他帮助我们在大量数据中探索和发现数据结构
```

###### 1.1 相似度与距离度量

```
定义距离来度量表示相似度：
    欧式距离，曼哈顿距离，闵氏距离

距离与变量量纲的关系
    变量标准化方法：
        0-1 标准化
        区间缩放法 （a,b）=(0,1)
        类别变量onehot
```

###### 1.2 聚类算法 及 划分方法

```
常见的两类聚类算法：
    层次聚类算法（Hierarchical）
    基于划分的方法（Partitional）
    基于密度 和 基于模型

基于划分的方法（Partitional）:K-means（K均值）
    1 随机选取K个数据点作为‘种子’
    2 根据数据点与‘种子’的距离大小进行类分配
    3 更新类中心点的位置，以新的类中心点作为‘种子’
    4 按照新的‘种子’对数据归属的类进行重新分配
    5 更新类中心点（-->3-->4），不断迭代，直到类中心点变得很小
```


#### 2 聚类模型评估（优缺点）

```
优点： 算法原理简单，处理快
      当聚类密集时，类与类之间区别明显，效果好

缺点： K是事先给定的，K值选定难确定
      对孤立点、噪声敏感
      结果不一定是全局最优，只能保证局部最优。
      很难发现大小差别很大的簇及进行增量计算
      结果不稳定，初始值选定对结果有一定的影响
      计算量大
```

#### 3 K-means 在 sklearn方法

```python
sklearn.cluster.KMeans(
                        n_clusters = 8,         #聚类个数，K值，默认8
                        init = 'k-means++',     
                        n_init = 10,
                        max_iter = 300,
                        tol = 0.0001,
                        precompute_distances = 'auto',
                        verbose = 0,
                        random_state = None,
                        copy_x = True,
                        n_jobs = 1,
                        algorithm = 'auto'
                    )

一些重要的参数：
n_clusters = 8,          #聚类个数，K值，默认8
init = 'k-means++',      #初始化类中心点选择方法，可选：
        {
            'k-means++', #是一种优化选择方法，比较容易收敛
            'random',    #随机选择
            an ndarray   #可以通过输入ndarray数组手动指定中心点
        }
max_iter:                #最大迭代数         
precompute_distances：   #预计算距离，计算速度更快但占用更多内存。auto  True
copy_x                   # True,原始数据不变，False直接在原始数据上做更改
```

#### 4 确定K值–肘部法则–SSE

```
最合适的K值
    肘部法则（Elbow method）：找到随着K值变大，损失函数的拐点。
    损失函数：各个类畸变程度（distortions）之和
```

肘方法的核心指标是 $SSE$ (sum of the squared errors，误差平方和)，$C_i$是第 $i$ 个簇，$p$ 是 $C_i$ 中的样本点，$m_i$是$C_i$的质心（$C_i$中所有样本的均值），SSE是所有样本的聚类误差，代表了聚类效果的好坏。 



$SSE = \sum_{i=1}^{K}\sum_{p\in C_i}|p-m_i|^2$

```
SSE是每个属性的SSE之和：
    1. 对于所有的簇，某变量的SSE都很低，都意味着什么？
    2. 如果只对一个簇很低，意味着什么？
    3. 如果只对一个簇很高，意味着什么？
    4. 如果对所有簇都很高，意味着什么？
    5. 如何使用每个变量的SSE信息改进聚类？

    解答： 1. 说明该属性本质上为常量，不能作为聚类依据。
          2. 那么该属性有助于该簇的定义
          3. 那么该属性为噪声属性
          4. 那么该属性 与 定义该属性提供的信息不一致，也意味着该属性不利于簇的定义。
          5. 消除对于所有簇都是 低的SSE（高的SSE）的属性。因为这些属性对聚类没有帮助， 
             这些属性在SSE的总和计算中引入了噪声。

             也可以对其中某些属性用加权概率来计算，使该属性有助于该簇的定义， 
             去除某些不利于该簇定义的影响因子（那些可能是噪声）。从而更有利于簇的聚类。

K-means 附加问题
    1.处理空簇：如果数据量少，寻找替补质心，使SSE最小。如果数据量大，保留该空簇
    2.离群点：不能删除。建议聚类之前离群检测。分析看能否删除 
    3.降低SSE ：将大的分散的簇再次拆开；引入新的簇将之前的大簇拆分。 
    4.增量更新质心:再次在质心附近寻找测试点，看能否再次找到更优的质心。
```


![这里写图片描述](https://img-blog.csdn.net/20180711152824535?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


#### 5 模型评估指标–轮廓系数法–最近簇

聚类目的是让“组内数据尽量相似”，而“组间数据差异明显”，轮廓系数就是衡量方法。
- 针对每一条数据i
a(i)数据i与组内其它数据的平均距离b(i)数据i与邻组的数据的平均距离
###### 5.1 轮廓系数



$S(i)=\frac{b(i)-a(i)}{max\left \{ a(i),b(i) \right \}}  \Rightarrow S(i)\left\{\begin{matrix}1-\frac{a(i)}{b(i)}, & a(i)<b(i) & S(i)\rightarrow 1\\  0&a(i)=b(i) & S(i)\rightarrow -1\\  \frac{a(i)}{b(i)}-1 , & a(i)>b(i) & S(i)\rightarrow 0\end{matrix}\right.$
- 数据i的轮廓系数s(i)
s(i) –> 1  样本i聚类合理s(i) –> -1 样本i应该分到其它类s(i) –> 0  样本i在两个轮廓的边界
###### 5.2 最近簇定义—平均轮廓系数 [0,1]：



$C_j = arg\min_{C_k}\frac{1}{n}\sum_{p\in C_k}|p-X_i|^2$

```
其中p是某个簇Ck中的样本。即，用Xi到某个簇所有样本平均距离作为衡量该点到该簇的距离后，
选择离Xi最近的一个簇作为最近簇。
```

```
sklearn.metrics.silhouette_score    
sklearn.metrics.silhouette_score(
                                    X,
                                    labels = 'euclidean',
                                    sample_size = None,
                                    random_state = None
                                    )
一些重要的参数：
    X:      聚类的输入特征数据
    labels：类标签数组
    metrics：
    sample_size:是否抽样计算
```

###### 5.3、Canopy算法配合初始聚类

```
1.聚类最耗费计算的地方是计算对象相似性的时候，Canopy聚类在第一阶段选择简单、 
  计算代价较低的方法计算对象相似性，将相似的对象放在一个子集中，这个子集被叫做Canopy ， 
  通过一系列计算得到若干Canopy，Canopy之间可以是重叠的，但不会存在某个对象不属于任何Canopy的情况， 
  可以把这一阶段看做数据预处理； 

2.在各个Canopy 内使用传统的聚类方法(如K-means)，不属于同一Canopy 的对象之间不进行相似性计算。 
 （即，根据Canopy算法产生的Canopies代替初始的K个聚类中心点， 
 由于已经将所有数据点进行Canopies有覆盖划分， 
 在计算数据离哪个k-center最近时，不必计算其到所有k-centers的距离， 
 只计算和它在同一个Canopy下的k-centers这样可以提高效率。
```
- 算法过程：
1，首先选择两个距离阈值：T1和T2，其中T1 > T22，从list中任取一点P，用低计算成本方法快速计算点P与所有Canopy之间的距（如果当前不存在Canopy，则把点P作为一个Canopy），如果点P与某个Canopy距离在T1以内，则将点P加入到这个Canopy3，如果点P曾经与某个Canopy的距离在T2以内，则需要把点P从list中删除，这一步是认为点P此时与这个Canopy已经够近了，因此它不可以再做其它Canopy的中心了；4，重复步骤2、3，直到list为空结束。  
![这里写图片描述](https://img-blog.csdn.net/20180716134910881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)- 优缺点
1、Kmeans对噪声抗干扰较弱，通过Canopy对比，将较小的NumPoint的Cluster直接去掉有利于抗干扰。2、Canopy选择出来的每个Canopy的centerPoint作为K会更精确。3、只是针对每个Canopy的内做Kmeans聚类，减少相似计算的数量。
#### 6 K-mean 优化

> 
###### 6.1 K-means++优化

```
◆ K-means算法的先决条件
    1）必须先行指定k的大小，及最终结果需要聚为几类。
    2）第一次分配数据点的时候需要选取起始质心（seeds），即初始化聚类中心点。 

k-means++是一种基于采样方法(称为D^2-sampling)的中心点选择方法。其核心为： 
    最开始的质心间两两的距离要尽可能远。 

K-means++算法改进了标准K-means算法随机选取初始质心的缺点，但其内在的有序性导致了它的可扩展型不足。 
    由于选择下一个中心点所需的计算依赖于已经选择的所有中心点，这种内在的顺序执行特性使得到k个聚类中心 
    必须遍历数据集 k 次，从而使得算法无法并行扩展而应用在超大规模数据集上。
```

###### 6.2 映射到高维（Kernel k-means）

```
kernel k-means：
    将每个样本映射到高维空间的处理，
    然后再将处理后的数据使用普通的k-means算法思想进行聚类。
```

###### 6.3 二分法（二分K-means）

```
首先将所有点作为一个簇，然后将该簇一分为二。 
之后选择能最大限度降低聚类代价函数（也就是误差平方和）的簇划分为两个簇。 
以此进行下去，直到簇的数目等于用户给定的数目k为止。
```

###### 6.4 Mini Batch K-Means（分批处理）

```
该算法的迭代步骤有两步： 
    1：从数据集中随机抽取一些数据形成小批量，把他们分配给最近的质心 
    2：更新质心，适用大数据类型
```

###### 6.5 迭代自组织数据分析算法（ISODATA）

```
类别数目随着聚类过程而变化； 
    对类别数的“合并”：（当聚类结果某一类中样本数太少，或两个类间的距离太近时） 
    “分裂”（当聚类结果中某一类的类内方差太大，将该类进行分裂）
```

###### 6.6 基于MCMC采样的算法

```
MCMC的采样方法，k−MC2就是为了降低 k-means 算法的时间复杂度的改进算法。 

使用MCMC采样来近似 D2−sampling 这个过程 
    在选取候选种子节点时，随机选取一个seeding，然后用MCMC的方法采样出长为M的马尔科夫链，
    使得马尔科夫链的平稳分布为 p(x) ，从而马尔科夫链达到平稳状态后的那些状态就可以看作是以
    p(x) 进行采样的样本点。 

k-MC^2 算法有一个缺点：
    即由于在MCMC过程中，算法使用的提案分布 q(x) 为均匀分布，这导致了潜在的缺点，
    就是那些样本数较小的聚类中可能不会被选中为候选节点。
```

###### 6.7 AFK-MC^2

```
AFK-MC^2关键之处：
    在于它使用马尔科夫链对k-Means++进行近似处理，也就是将数据点看做状态点。
    第一个状态是随机采样的数据点，通过一个随机过程来决定链的状态是否要转移到其他的随机数据点。
    状态是否转移与所有点的初始距离是相互独立的（马尔科夫链的稳定状态与初始状态无关）， 
    并且初始距离作为预处理的一部分只计算一次。与k-Means++不同的是，AFK-MC2算法只需要遍历一次数据集。
```

###### 附：马尔可夫链蒙特卡洛方法

```
◆ 蒙特卡洛方法
    蒙特卡洛模拟只是一种通过不断地生成随机数来评估固定参数的方法。 
    通过生成随机数并对其做一些计算，蒙特卡洛模拟给出了一个参数的近似值（其中直接
    计算是不可能的或者计算量过大）
```


![这里写图片描述](https://img-blog.csdn.net/20180705105929953?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


```
由于 15 个点落在了圆内，那么圆的面积可以近似地为 75 平方英寸，对于只有 20 个随机点 
的蒙特卡洛模拟来说，结果并不差。

现在，假设我们想要计算下图中由蝙蝠侠方程（Batman Equation）绘制的图形的面积：
```


![这里写图片描述](https://img-blog.csdn.net/20180705110251335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


```
我们从来没有学过一个方程可以求这样的面积。不管怎样，通过随机地放入随机点， 
蒙特卡洛模拟可以相当容易地为该面积提供一个近似值。

◆ 马尔可夫链 
    在十九世纪，人们观察到钟形曲线在自然中是一种很常见的模式。 
    （我们注意到，例如，人类的身高服从钟形曲线分布。） 
    Galton Boards 曾通过将弹珠坠落并通过布满木钉的板模拟了重复随机事件的平均值， 
    弹珠的最终数量分布中重现了钟形曲线：
```

![这里写图片描述](https://img-blog.csdn.net/20180705113120604?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```
给定一个确定的上述字母或空白，关于下一个字母将是 A、T 或者空白等，存在一个确定的概率。 
通过这些概率，Markov 可以模拟一个任意的长字符序列。这就是马尔科夫链。
```

#### [7 以下代码演示：请点击](https://blog.csdn.net/wsp_1138886114/article/details/80893941)

> 
###### K-means 肘部法则（确定K值）

###### K-means 轮廓系数法（验证K值）

###### Mini Batch K-Means（适合大数据的聚类算法）





