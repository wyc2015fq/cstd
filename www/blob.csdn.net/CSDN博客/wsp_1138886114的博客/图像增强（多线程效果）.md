# 图像增强（多线程效果） - wsp_1138886114的博客 - CSDN博客





2019年03月08日 11:02:39[SongpingWang](https://me.csdn.net/wsp_1138886114)阅读数：74











### 文章目录
- [单线程](#_1)
- [遍历list 多线程（线程个数=列表长度）](#list__149)
- [生成多列，开4个线程](#4_309)
- [程序3 最省时(同时调用不同函数)](#3__495)




### 单线程

```python
"""
单线程
"""

import os
import random
import numpy as np
import cv2
import time

def Affine_transformation(img_array):
    rows, cols = img_array.shape[:2]
    pointsA = np.float32([[30, 80], [180, 60], [80, 230]])  # 左偏
    pointsB = np.float32([[60, 50], [220, 70], [20, 180]])  # 右偏
    pointsC = np.float32([[70, 60], [180, 50], [50, 200]])  # 前偏
    pointsD = np.float32([[40, 50], [210, 60], [70, 180]])  # 后偏

    points1 = np.float32([[50, 50], [200, 50], [50, 200]])
    points2 = random.choice((pointsA, pointsB, pointsC, pointsD))

    matrix = cv2.getAffineTransform(points1, points2)
    Affine_transfor_img = cv2.warpAffine(img_array, matrix, (cols, rows))
    return Affine_transfor_img

def random_rotate_img(img):
    rows, cols= img.shape[:2]
    angle = random.choice([25, 90, -25, -90, 180])
    Matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)
    res = cv2.warpAffine(img, Matrix, (cols, rows), borderMode=cv2.BORDER_CONSTANT)
    return res

def random_hsv_transform(img, hue_vari, sat_vari, val_vari):
    """
    :param img:
    :param hue_vari: 色调变化比例范围(0,360)
    :param sat_vari: 饱和度变化比例范围(0,1)
    :param val_vari: 明度变化比例范围(0,1)
    :return:
    """
    hue_delta = np.random.randint(-hue_vari, hue_vari)
    sat_mult = 1 + np.random.uniform(-sat_vari, sat_vari)
    val_mult = 1 + np.random.uniform(-val_vari, val_vari)

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV).astype(np.float)
    img_hsv[:, :, 0] = (img_hsv[:, :, 0] + hue_delta) % 180
    img_hsv[:, :, 1] *= sat_mult
    img_hsv[:, :, 2] *= val_mult
    img_hsv[img_hsv > 255] = 255
    return cv2.cvtColor(np.round(img_hsv).astype(np.uint8), cv2.COLOR_HSV2BGR)

def random_gamma_transform(img, gamma_vari):
    """
    :param img:
    :param gamma_vari:
    :return:
    """
    log_gamma_vari = np.log(gamma_vari)
    alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)
    gamma = np.exp(alpha)
    gamma_table = [np.power(x / 255.0, gamma) * 255.0 for x in range(256)]
    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)
    return cv2.LUT(img, gamma_table)

def random_flip_img(img):
    """
    0 = X axis, 1 = Y axis,  -1 = both
    :param img:
    :return:
    """
    flip_val = [0,1,-1]
    random_flip_val = random.choice(flip_val)
    res = cv2.flip(img, random_flip_val)
    return res

def clamp(pv):     #防止像素溢出
    if pv > 255:
        return 255
    if pv < 0:
        return 0
    else:
        return pv

def gaussian_noise(image):   # 加高斯噪声
    """
    :param image:
    :return:
    """
    h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0] # blue
            g = image[row, col, 1] # green
            r = image[row, col, 2] # red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])
    return image

def get_img(input_dir):
    img_path_list = []
    for (root_path,dirname,filenames) in os.walk(input_dir):
        for filename in filenames:
            img_path = root_path+"/"+filename
            img_path_list.append(img_path)
    return  img_path_list


if __name__ == '__main__':
    "注意输入目录与输出目录不能一样，这样会照成图像出错！"
    start_time = time.time()
    input_dir = "./content"
    output_dir = "./dddd"
    img_path_list = get_img(input_dir)
    index = 1
    for i in range(len(img_path_list)):
        Suffix_name = ['.png', '.jpg', '.tif', '.jpeg']
        if img_path_list[i].endswith(tuple(Suffix_name)):
            print("处理图像", img_path_list[i])
            img_array = cv2.imread(img_path_list[i])
            Affine_transfor_img = Affine_transformation(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_Affine_transfor' + str(index) + '.png', Affine_transfor_img)

            res_rotate = random_rotate_img(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_rotate_img' + str(index) + '.png', res_rotate)

            GAMMA_IMG = random_gamma_transform(img_array, 0.3)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_GAMMA_IMG' + str(index) + '.png', GAMMA_IMG)

            res_flip = random_flip_img(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_flip_img' + str(index) + '.png', res_flip)

            G_Noiseimg = gaussian_noise(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_G_Noise_img' + str(index) + '.png', G_Noiseimg)

            HSV_IMG = random_hsv_transform(img_array, 2, 0.3, 0.6)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_HSV_IMG' + str(index) + '.png', HSV_IMG)
            index+=1
        else:
            print("图像格式错误！")
            pass
    print("done!")

    end_time = time.time()
    print("Total Spend time：", str((end_time - start_time) / 60)[0:6] + "分钟")
```

### 遍历list 多线程（线程个数=列表长度）

```python
"""
多线程
"""

import os
import random
import numpy as np
import threading
import cv2
import time

def Affine_transformation(img_array):
    rows, cols = img_array.shape[:2]
    pointsA = np.float32([[30, 80], [180, 60], [80, 230]])  # 左偏
    pointsB = np.float32([[60, 50], [220, 70], [20, 180]])  # 右偏
    pointsC = np.float32([[70, 60], [180, 50], [50, 200]])  # 前偏
    pointsD = np.float32([[40, 50], [210, 60], [70, 180]])  # 后偏

    points1 = np.float32([[50, 50], [200, 50], [50, 200]])
    points2 = random.choice((pointsA, pointsB, pointsC, pointsD))

    matrix = cv2.getAffineTransform(points1, points2)
    Affine_transfor_img = cv2.warpAffine(img_array, matrix, (cols, rows))
    return Affine_transfor_img

def random_rotate_img(img):
    rows, cols= img.shape[:2]
    angle = random.choice([25, 90, -25, -90, 180])
    Matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)
    res = cv2.warpAffine(img, Matrix, (cols, rows), borderMode=cv2.BORDER_CONSTANT)
    return res

def random_hsv_transform(img, hue_vari, sat_vari, val_vari):
    """
    :param img:
    :param hue_vari: 色调变化比例范围(0,360)
    :param sat_vari: 饱和度变化比例范围(0,1)
    :param val_vari: 明度变化比例范围(0,1)
    :return:
    """
    hue_delta = np.random.randint(-hue_vari, hue_vari)
    sat_mult = 1 + np.random.uniform(-sat_vari, sat_vari)
    val_mult = 1 + np.random.uniform(-val_vari, val_vari)

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV).astype(np.float)
    img_hsv[:, :, 0] = (img_hsv[:, :, 0] + hue_delta) % 180
    img_hsv[:, :, 1] *= sat_mult
    img_hsv[:, :, 2] *= val_mult
    img_hsv[img_hsv > 255] = 255
    return cv2.cvtColor(np.round(img_hsv).astype(np.uint8), cv2.COLOR_HSV2BGR)

def random_gamma_transform(img, gamma_vari):
    """
    :param img:
    :param gamma_vari:
    :return:
    """
    log_gamma_vari = np.log(gamma_vari)
    alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)
    gamma = np.exp(alpha)
    gamma_table = [np.power(x / 255.0, gamma) * 255.0 for x in range(256)]
    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)
    return cv2.LUT(img, gamma_table)

def random_flip_img(img):
    """
    0 = X axis, 1 = Y axis,  -1 = both
    :param img:
    :return:
    """
    flip_val = [0,1,-1]
    random_flip_val = random.choice(flip_val)
    res = cv2.flip(img, random_flip_val)
    return res

def clamp(pv):     #防止像素溢出
    if pv > 255:
        return 255
    if pv < 0:
        return 0
    else:
        return pv

def gaussian_noise(image):   # 加高斯噪声
    """
    :param image:
    :return:
    """
    h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0] # blue
            g = image[row, col, 1] # green
            r = image[row, col, 2] # red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])
    return image

def get_img(input_dir):
    img_path_list = []
    for (root_path,dirname,filenames) in os.walk(input_dir):
        for filename in filenames:
            Suffix_name = ['.png', '.jpg', '.tif', '.jpeg']
            if filename.endswith(tuple(Suffix_name)):
                img_path = root_path+"/"+filename
                img_path_list.append(img_path)
    return  img_path_list

def main(img_path):
    try:
        print("处理图像:",img_path)
        img_array = cv2.imread(img_path)
        Affine_transfor_img = Affine_transformation(img_array)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_Affine_transfor.png', Affine_transfor_img)

        res_rotate = random_rotate_img(img_array)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_rotate_img.png', res_rotate)

        GAMMA_IMG = random_gamma_transform(img_array, 0.3)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_GAMMA_IMG.png', GAMMA_IMG)

        res_flip = random_flip_img(img_array)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_flip_img.png', res_flip)

        G_Noiseimg = gaussian_noise(img_array)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_G_Noise_img.png', G_Noiseimg)

        HSV_IMG = random_hsv_transform(img_array, 2, 0.3, 0.6)
        cv2.imwrite(output_dir+"/"+img_path[len(input_dir):-4] + '_HSV_IMG.png', HSV_IMG)
    except:
        print("图像格式错误！")
        pass
    print("done!")

if __name__ == '__main__':
    "注意输入目录与输出目录不能一样，这样会照成图像出错！"
    start_time = time.time()
    input_dir = "./cccc"
    output_dir = "./eeee"
    img_path_list = get_img(input_dir)

    threads = []
    files = range(len(img_path_list))

    for i in files:      # 创建线程
        t = threading.Thread(target=main, args=(img_path_list[i],))
        threads.append(t)

    for i in files:     # 启动线程
        threads[i].start()
    for i in files:
        threads[i].join()

    end_time = time.time()
    print("Total Spend time：", str((end_time - start_time) / 60)[0:6] + "分钟")
```

### 生成多列，开4个线程

```python
"""
开启多线程：图像增强
"""
import os
import random
import queue
import numpy as np
import cv2
import time
import threading

def Affine_transformation(img_array):
    rows, cols = img_array.shape[:2]
    pointsA = np.float32([[30, 80], [180, 60], [80, 230]])  # 左偏
    pointsB = np.float32([[60, 50], [220, 70], [20, 180]])  # 右偏
    pointsC = np.float32([[70, 60], [180, 50], [50, 200]])  # 前偏
    pointsD = np.float32([[40, 50], [210, 60], [70, 180]])  # 后偏

    points1 = np.float32([[50, 50], [200, 50], [50, 200]])
    points2 = random.choice((pointsA, pointsB, pointsC, pointsD))

    matrix = cv2.getAffineTransform(points1, points2)
    Affine_transfor_img = cv2.warpAffine(img_array, matrix, (cols, rows))
    return Affine_transfor_img

def random_rotate_img(img):
    rows, cols= img.shape[:2]
    angle = random.choice([25, 90, -25, -90, 180])
    Matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), angle, 1)
    res = cv2.warpAffine(img, Matrix, (cols, rows), borderMode=cv2.BORDER_CONSTANT)
    return res

def random_hsv_transform(img, hue_vari, sat_vari, val_vari):
    """
    :param img:
    :param hue_vari: 色调变化比例范围(0,360)
    :param sat_vari: 饱和度变化比例范围(0,1)
    :param val_vari: 明度变化比例范围(0,1)
    :return:
    """
    hue_delta = np.random.randint(-hue_vari, hue_vari)
    sat_mult = 1 + np.random.uniform(-sat_vari, sat_vari)
    val_mult = 1 + np.random.uniform(-val_vari, val_vari)

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV).astype(np.float)
    img_hsv[:, :, 0] = (img_hsv[:, :, 0] + hue_delta) % 180
    img_hsv[:, :, 1] *= sat_mult
    img_hsv[:, :, 2] *= val_mult
    img_hsv[img_hsv > 255] = 255
    return cv2.cvtColor(np.round(img_hsv).astype(np.uint8), cv2.COLOR_HSV2BGR)

def random_gamma_transform(img, gamma_vari):
    """
    :param img:
    :param gamma_vari:
    :return:
    """
    log_gamma_vari = np.log(gamma_vari)
    alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)
    gamma = np.exp(alpha)
    gamma_table = [np.power(x / 255.0, gamma) * 255.0 for x in range(256)]
    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)
    return cv2.LUT(img, gamma_table)

def random_flip_img(img):
    """
    0 = X axis, 1 = Y axis,  -1 = both
    :param img:
    :return:
    """
    flip_val = [0,1,-1]
    random_flip_val = random.choice(flip_val)
    res = cv2.flip(img, random_flip_val)
    return res

def clamp(pv):     #防止像素溢出
    if pv > 255:
        return 255
    if pv < 0:
        return 0
    else:
        return pv

def gaussian_noise(image):   # 加高斯噪声
    """
    :param image:
    :return:
    """
    h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0] # blue
            g = image[row, col, 1] # green
            r = image[row, col, 2] # red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])
    return image

def get_img(input_dir):
    img_path_list = []
    for (root_path,dirname,filenames) in os.walk(input_dir):
        for filename in filenames:
            Suffix_name = ['.png', '.jpg', '.tif', '.jpeg']
            if filename.endswith(tuple(Suffix_name)):
                img_path = root_path+"/"+filename
                img_path_list.append(img_path)
    return  img_path_list


class IMG_QUEUE(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        while True:
            try:
                img_path = img_path_list.pop(0)
                q.put(img_path)
            except IndexError:
                break

class IMG_AUG(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)
        self.q = q

    def run(self):
        while True:
            if q.not_empty:
                img_path = q.get()
                try:
                    print("doing...")
                    img_array = cv2.imread(img_path)
                    Affine_transfor_img = Affine_transformation(img_array)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_Affine_transfor.png', Affine_transfor_img)

                    res_rotate = random_rotate_img(img_array)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_rotate_img.png',res_rotate)

                    GAMMA_IMG = random_gamma_transform(img_array, 0.3)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_GAMMA_IMG.png',GAMMA_IMG)

                    res_flip = random_flip_img(img_array)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_flip_img.png',res_flip)

                    G_Noiseimg = gaussian_noise(img_array)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_G_Noise_img.png',G_Noiseimg)

                    HSV_IMG = random_hsv_transform(img_array, 2, 0.3, 0.6)
                    cv2.imwrite(output_dir + "/" + img_path[len(input_dir):-4] + '_HSV_IMG.png',HSV_IMG)
                except:
                    print("图像格式错误！")
                    pass
                q.task_done()
            else:
                break


if __name__ == '__main__':
    input_dir = './cccc'
    output_dir = './eeee'
    start_time = time.time()            # 开始计时
    img_path_list = get_img(input_dir)  # 获取图像数据

    q = queue.Queue(10)                 # 设置队列元素个数
    my_thread = IMG_QUEUE('IMG_QUEUE')  # 实例化
    my_thread.setDaemon(True)           # 设置为守护进程，主线程退出时，子进程也kill掉
    my_thread.start()                   # 启动进程

    for i in range(5):                  # 设置线程个数（批量任务时，线程数不必太大，注意内存及CPU负载）
        mp_thread = IMG_AUG('IMG_AUG')
        mp_thread.setDaemon(True)
        mp_thread.start()
    q.join()                            # 线程阻塞（等待所有子线程处理完成，再退出）
    end_time = time.time()
    print("Total Spend time：", str((end_time - start_time) / 60)[0:6] + "分钟")
```

### 程序3 最省时(同时调用不同函数)

```python
"""
开启多线程：图像增强
"""
import os
import random
import numpy as np
import cv2
import time
import threading

def Affine_transformation(img_array):
    rows, cols = img_array.shape[:2]
    pointsA = np.float32([[30, 80], [180, 60], [80, 230]])  # 左偏
    pointsB = np.float32([[60, 50], [220, 70], [20, 180]])  # 右偏
    pointsC = np.float32([[70, 60], [180, 50], [50, 200]])  # 前偏
    pointsD = np.float32([[40, 50], [210, 60], [70, 180]])  # 后偏

    points1 = np.float32([[50, 50], [200, 50], [50, 200]])
    points2 = random.choice((pointsA, pointsB, pointsC, pointsD))

    matrix = cv2.getAffineTransform(points1, points2)
    Affine_transfor_img = cv2.warpAffine(img_array, matrix, (cols, rows))
    return Affine_transfor_img

def random_rotate_img(img):
    height, width = img.shape[:2]
    degree = random.choice([25, -25, 180])
    # 旋转后的尺寸
    heightNew = int(width * fabs(sin(radians(degree))) + height * fabs(cos(radians(degree))))
    widthNew = int(height * fabs(sin(radians(degree))) + width * fabs(cos(radians(degree))))

    matRotation = cv2.getRotationMatrix2D((width / 2, height / 2), degree, 1)
    matRotation[0, 2] += (widthNew - width) / 2
    matRotation[1, 2] += (heightNew - height) / 2
    res = cv2.warpAffine(img, matRotation, (widthNew, heightNew), borderValue=(0, 0, 0))
    return res

def random_hsv_transform(img, hue_vari, sat_vari, val_vari):
    """
    :param img:
    :param hue_vari: 色调变化比例范围(0,360)
    :param sat_vari: 饱和度变化比例范围(0,1)
    :param val_vari: 明度变化比例范围(0,1)
    :return:
    """
    hue_delta = np.random.randint(-hue_vari, hue_vari)
    sat_mult = 1 + np.random.uniform(-sat_vari, sat_vari)
    val_mult = 1 + np.random.uniform(-val_vari, val_vari)

    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV).astype(np.float)
    img_hsv[:, :, 0] = (img_hsv[:, :, 0] + hue_delta) % 180
    img_hsv[:, :, 1] *= sat_mult
    img_hsv[:, :, 2] *= val_mult
    img_hsv[img_hsv > 255] = 255
    return cv2.cvtColor(np.round(img_hsv).astype(np.uint8), cv2.COLOR_HSV2BGR)

def random_gamma_transform(img, gamma_vari):
    """
    :param img:
    :param gamma_vari:
    :return:
    """
    log_gamma_vari = np.log(gamma_vari)
    alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)
    gamma = np.exp(alpha)
    gamma_table = [np.power(x / 255.0, gamma) * 255.0 for x in range(256)]
    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)
    return cv2.LUT(img, gamma_table)

def random_flip_img(img):
    """
    0 = X axis, 1 = Y axis,  -1 = both
    :param img:
    :return:
    """
    flip_val = [0,1,-1]
    random_flip_val = random.choice(flip_val)
    res = cv2.flip(img, random_flip_val)
    return res

def clamp(pv):     #防止像素溢出
    if pv > 255:
        return 255
    if pv < 0:
        return 0
    else:
        return pv

def gaussian_noise(image):   # 加高斯噪声
    """
    :param image:
    :return:
    """
    h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0] # blue
            g = image[row, col, 1] # green
            r = image[row, col, 2] # red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])
    return image

def get_img(input_dir):
    img_path_list = []
    for (root_path,dirname,filenames) in os.walk(input_dir):
        for filename in filenames:
            img_path = root_path+"/"+filename
            img_path_list.append(img_path)
    return  img_path_list

def mian1(input_dir,output_dir,img_path_list):
    index = 1
    for i in range(len(img_path_list)):
        Suffix_name = ['.png', '.jpg', '.tif', '.jpeg']
        if img_path_list[i].endswith(tuple(Suffix_name)):
            print("线程1 处理图像", img_path_list[i])
            img_array = cv2.imread(img_path_list[i])

            GAMMA_IMG = random_gamma_transform(img_array, 0.3)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_GAMMA_IMG' + str(index) + '.png', GAMMA_IMG)

            G_Noiseimg = gaussian_noise(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_G_Noise_img' + str(index) + '.png', G_Noiseimg)
            index+=1
        else:
            print("图像格式错误！")
            pass
    print("线程1 done!")

def mian2(input_dir,output_dir,img_path_list):
    index = 1
    for i in range(len(img_path_list)):
        Suffix_name = ['.png', '.jpg', '.tif', '.jpeg']
        if img_path_list[i].endswith(tuple(Suffix_name)):
            print("线程2 处理图像", img_path_list[i])
            img_array = cv2.imread(img_path_list[i])
            Affine_transfor_img = Affine_transformation(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_Affine_transfor' + str(index) + '.png', Affine_transfor_img)

            res_flip = random_flip_img(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_flip_img' + str(index) + '.png', res_flip)

            res_rotate = random_rotate_img(img_array)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_rotate_img' + str(index) + '.png', res_rotate)

            HSV_IMG = random_hsv_transform(img_array, 2, 0.3, 0.6)
            cv2.imwrite(output_dir+"/"+img_path_list[i][len(input_dir):-4] + '_HSV_IMG' + str(index) + '.png', HSV_IMG)
            index+=1
        else:
            print("图像格式错误！")
            pass
    print("线程2 done!")


"""
注意输入目录与输出目录不能一样，这样会照成图像出错！
"""
input_dir = "./dddd"
output_dir = "./eeee"
img_path_list = get_img(input_dir)
threads = []
t1 = threading.Thread(target=mian1, args=(input_dir,output_dir,img_path_list,))
threads.append(t1)
t2 = threading.Thread(target=mian2, args=(input_dir,output_dir,img_path_list,))
threads.append(t2)

if __name__ == '__main__':
    start_time = time.time() # 开始计时
    for t in threads:
        t.setDaemon(True)
        t.start()
    for t in threads:
        t.join()

    end_time = time.time()
    print("Total Spend time：", str((end_time - start_time) / 60)[0:6] + "分钟")
```



