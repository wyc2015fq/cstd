# 朴素贝叶斯算法 - wsp_1138886114的博客 - CSDN博客





2018年07月16日 17:55:24[SongpingWang](https://me.csdn.net/wsp_1138886114)阅读数：74标签：[朴素贝叶斯算法](https://so.csdn.net/so/search/s.do?q=朴素贝叶斯算法&t=blog)
个人分类：[机器学习](https://blog.csdn.net/wsp_1138886114/article/category/7692618)











- - - [一、概率基础知识](#一概率基础知识)- - [1.1、条件概率](#11条件概率)
- [1.2、全概率公式](#12全概率公式)
- [1.3、贝叶斯公式](#13贝叶斯公式)
- [1.4、特征条件独立假设](#14特征条件独立假设)
- [1.5、拉普拉斯平滑](#15拉普拉斯平滑)


- [二、朴素贝叶斯分类](#二朴素贝叶斯分类)
- [三、连续变量贝叶斯（高斯分布）](#三连续变量贝叶斯高斯分布)
- [四、优缺点](#四优缺点)
- [五、半朴素贝叶斯分类器](#五半朴素贝叶斯分类器)
- [六、贝叶斯网络结构](#六贝叶斯网络结构)- - [6.1、概念](#61概念)
- [6.2 三种贝叶斯网络结构情况](#62-三种贝叶斯网络结构情况)








### 一、概率基础知识

![这里写图片描述](https://img-blog.csdn.net/20180801095627645?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 1.1、条件概率

```
条件概率是指事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为：P(A|B)，读作“在B条件下A的概率”。
```

![这里写图片描述](https://img-blog.csdn.net/20180715171103829?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 1.2、全概率公式

```
指事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为：P(A|B)，读作“在B条件下A的概率”
```
- 若只有两个事件A，B，那么：
$P(B) = P(A_1B) + P(A_2B) + ··· + P(A_nB)$$~~~~~~~~~= ∑P(A_iB)$$~~~~~~~~~= ∑P(B|A_i)* P(A_i)$
##### 1.3、贝叶斯公式

```
贝叶斯公式是将全概率公式带入到条件概率公式当中，对于事件Ak和事件B有：
```



$P(A_k|B) =\frac{P(A_k)~P(B|A_k)}{∑P(A_i)~P(B|A_i) } ~~~~~（i=1，2，····，n）$

```
对于P(Ak|B)来说，分母 ∑P(B|Ai)*P(Ai) 为一个固定值，因为我们只需要比较P(Ak|B)的大小， 
    所以可以将分母固定值去掉，并不会影响结果。 
    因此，可以得到下面公式：
```



$P(A_k|B) =P(A_k)~P(B|A_k)$
- 后验 = 先验 × 似然函数
P(Ak|B) 后验概率；P(Ak) 先验概率；P(B|Ak) 似然函数
##### 1.4、特征条件独立假设

```
在分类问题中，常常需要把一个事物分到某个类别中。一个事物又有许多属性，即x=(x1,x2,···,xn)。 
常常类别也是多个(y1,y2,···,yk)P(y1|x), P(y2|x),…,P(yk|x)，表示x属于某个分类的概率， 
那么，我们需要找出中最大的那个概率P(yk|x)。
```

##### 1.5、拉普拉斯平滑

```
为了解决零概率的问题，法国数学家拉普拉斯最早提出用加1的方法估计没有出现过的现象的概率， 
所以加法平滑也叫做拉普拉斯平滑。
```

[拉普拉斯平滑详情-请点击](https://blog.csdn.net/wsp_1138886114/article/details/80471061)

### 二、朴素贝叶斯分类

```
对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，
    就认为此待分类项属于哪个类别
```
- ①计算流程：
(1) x = {$a_1,a_2,... a_m$} 为待分类项，每a个为 x 的一个特征属性(2) 有类别集合  $C = \{y_1,y_2,... y_n\} $(3) 计算 $P(y_1|x),P(y_2|x),...P(y_n|x)$(4) 如果 $P(y_k|x) = max{P(y_1|x),P(y_2|x),...P(y_n|x)},则 x \in y_k$
![这里写图片描述](https://img-blog.csdn.net/20180715175006554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)- ②三个阶段：
第一阶段——根据具体情况确定特征属性，对每个特征属性进行适当划分，  

然后由人工对一部分待分类项进行分类，形成训练样本集合。  

这一阶段的输入是**所有待分类数据**，输出是**特征属性和训练样本。**
这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，  

其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。 
- ![这里写图片描述](https://img-blog.csdn.net/20180715175526223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第二阶段——分类器训练阶段，  

这个阶段的任务就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计，并将结果记录。 

其输入是特征属性和训练样本，输出是分类器。 

这一阶段是机械性阶段，根据前面讨论的公式可以由程序自动计算完成。  
第三阶段——应用阶段。  

这个阶段的任务是使用分类器对待分类项进行分类，  

其输入是分类器和待分类项，输出是待分类项与类别的映射关系。 

这一阶段也是机械性阶段，由程序完成。 
### 三、连续变量贝叶斯（高斯分布）

```
当特征属性为连续值时，通常假定其值服从高斯分布（也称正态分布）。即：
```

![这里写图片描述](https://img-blog.csdn.net/2018071518010765?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

    因此只要计算出训练样本中各个类别中此特征项划分的各均值和标准差，代入上述公式即 

可得到需要的估计值。  

均值与标准差的计算在此不再赘述。 
### 四、优缺点
- 优点
1， 算法逻辑简单,易于实现（算法思路很简单，只要使用贝叶斯公式转化即可！）  

2，分类过程中时空开销小（假设特征相互独立，只会涉及到二维存储）- 缺点
1、理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。
2、而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类  

的算法通过考虑部分关联性适度改进。 

### 五、半朴素贝叶斯分类器

```
在朴素的分类中，我们假定了各个属性之间的独立，这是为了计算方便， 
    防止过多的属性之间的依赖导致的大量计算。 
    这正是朴素的含义，虽然朴素贝叶斯的分类效果不错， 
    但是属性之间毕竟是有关联的，某个属性依赖于另外的属性， 

    于是就有了半朴素贝叶斯分类器。
```

![这里写图片描述](https://img-blog.csdn.net/20180715180925465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 确认依赖
1.SOPDE方法。这种方法是假定所有的属性都依赖于共同的一个父属性。
2.TAN方法。每个属性依赖的另外的属性由最大带权生成树来确定。  

（1）先求每个属性之间的互信息来作为他们之间的权值。  

（2）构件完全图。权重是刚才求得的互信息。然后用最大带权生成树算法求得此图  

的最大带权的生成树。  

（3）找一个根变量，然后依次将图变为有向图。  

（4）添加类别y到每个属性的的有向边。
3 . 朴素贝叶斯与两种半朴素贝叶斯分类器所考虑的属性依赖关系，  

假定每个属性仅依赖于其他最多一个属性，称其依赖的这个属性为其超父属性，  

这种关系称为：独依赖估计（ODA）。 

![这里写图片描述](https://img-blog.csdn.net/2018071518132646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


### 六、贝叶斯网络结构

##### 6.1、概念

```
贝叶斯网络（Bayesian Networks）也被称为信念网络（Belif Networks）或者因果网络（Causal Networks）。

    简单说网络结构就是用来描述变量之间相互依赖的关系的结构，提供了一种方便的框架结构来表示因果关系， 
    这使得不确定性推理变得在逻辑上更为清晰、可理解性强。
```

![这里写图片描述](https://img-blog.csdn.net/20180716170558632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180716174628725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
##### 6.2 三种贝叶斯网络结构情况

![这里写图片描述](https://img-blog.csdn.net/20180716175229971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzcF8xMTM4ODg2MTE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)









