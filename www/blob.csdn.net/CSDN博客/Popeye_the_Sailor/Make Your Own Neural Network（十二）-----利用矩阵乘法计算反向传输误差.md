# Make Your Own Neural Network（十二）-----利用矩阵乘法计算反向传输误差 - Popeye_the_Sailor - CSDN博客
2018年05月03日 20:29:37[_Sailor_](https://me.csdn.net/lz0499)阅读数：456

**Make Your Own Neural Network**
**构建你自己的神经网络**
[https://blog.csdn.net/lz0499](https://blog.csdn.net/lz0499)
**作者：lz0499**
**声明：**
1）**Make Your Own Neural Network**翻译自[Tariq Rashid](https://book.douban.com/search/Tariq%20Rashid)编写的神经网络入门书籍。作者的目的是尽可能的少用术语和高深的数学知识，以图文并茂的方式讲解神经网络是如何工作的。任何拥有高中数学水平的人就能够理解神经网络的工作方式。强烈推荐初学者以这本书作为神经网络入门书籍。
2）本文仅供学术交流，非商用。翻译的初衷是一边翻译一边加深对神经网络的理解。
3）由于刚刚接触神经网络这方面的知识，翻译过程中难免有些错误。若发现错误，还请各位前辈指正。谢谢！
4）由于工作原因，我将有选择的按照原文的章节不定期的进行翻译更新。
5）此属于第一版本，若有错误，还需继续修正与增删。
目录：
第一部分：神经网络是如何工作的
[一种简单的预测机](https://mp.csdn.net/postedit/80069089)
[分类即是预测](https://blog.csdn.net/lz0499/article/details/80072948)
[训练一个简单的分类器](https://blog.csdn.net/lz0499/article/details/80086402)
[单个分类器似乎远不够](https://blog.csdn.net/lz0499/article/details/80099968)
[神经元，自然界的计算机](https://blog.csdn.net/lz0499/article/details/80138584)
[通过神经网络的信号](https://blog.csdn.net/lz0499/article/details/80138955)
[矩阵很有用](https://blog.csdn.net/lz0499/article/details/80160354)
[利用矩阵计算三层神经网络的输出结果](https://blog.csdn.net/lz0499/article/details/80160449)
[从多个节点更新权重](https://blog.csdn.net/lz0499/article/details/80172534)
[从多个节点中反向传递误差](https://blog.csdn.net/lz0499/article/details/80172568)
[多层神经网络层反向传输误差](https://blog.csdn.net/lz0499/article/details/80185692)
[利用矩阵乘法计算反向传输误差](https://blog.csdn.net/lz0499/article/details/80185923)
[实际上是如何更新权重（一）](https://blog.csdn.net/lz0499/article/details/80209928)
[实际上是如何更新权重（二）](https://blog.csdn.net/lz0499/article/details/80210590)
[权重更新实例](https://blog.csdn.net/lz0499/article/details/80212695)
**利用矩阵乘法计算反向传输误差**
我们是否可以使用矩阵的乘法简化方向传输误差的计算呢？前面小节中，我们利用矩阵的乘法简化计算了神经网络输出层的结果，那么我们可以同样使用矩阵的乘法计算方向传输的误差。
为了验证方向传输误差是否可以使用更为简洁的矩阵乘法，让我们利用一些符号写出其计算过程。把误差反向传输的计算利用矩阵乘法表示出来，一方面其计算过程看起来更为简洁，另一方面可以使得计算机更为有效的计算出反向传输的结果，因为反向传输法中有许多类似的重复计算过程，而计算机恰好能够高效的计算其结果。
我们从神经网络最后的输出层输出误差开始。输出层只有两个节点，我们标记这两个节点的误差分别为：e1和e2。
![](https://img-blog.csdn.net/20180503202258272)
下一步我们需要构建出隐藏层的误差结果。听起来似乎很难，但是让我们一步一步来计算。第一步，我们首先计算隐藏层第一个节点的误差。如果你观察上一小节中的图表，可以发现隐藏层第一个节点的误差是由两部分组成，分别来之与之相邻输出层节点的部分误差，即e1*w11/w11+w21+e2*w12/W12+W22，同理，我们可以得出隐藏层第二个节点的误差为e1*w21/w11+w21+e2*w22/W12+W21。
因此，对于隐藏层的误差我们有如下矩阵：
![](https://img-blog.csdn.net/20180503202728258)
如果我们能够把已知的矩阵重新改写为一个简单的矩阵乘法，那将是一件很棒的事。这些已知的矩阵包括权重矩阵、误差矩阵，输入信号矩阵。如果我们能够把这些矩阵改写为简单的矩阵相乘的形式，那么将极大的方便计算。
遗憾的是我们不能简单的把这些矩阵改写为矩阵的乘法运算。怎么办？我们确实像把这些矩阵写成矩阵相乘的形式。办法还是有的。
让我们在重新观察上面的式子。我们可以观察到：输出误差与相连权重的乘积是计算隐藏层误差的关键。如果连接权重越大，其反向传播给隐藏层相连节点的误差也越大。这是很关键的一步。上式底部类似一种归一化因子。如果我们忽略这个因子，只保存反向传输的缩放因子，那么，我们可以改下上式为：
![](https://img-blog.csdn.net/20180503202758982)
上式的权重矩阵，有点像我们之前前向传播中计算的矩阵，只不过矩阵中的元素按照对角线镜像交换了一下。所以原先在矩阵右上角的元素现在在矩阵的左下角，原先左下角的元素现在在矩阵的右上角。这种变化称之为矩阵的置换，记为wT。
下述两个例子阐释了矩阵置换的操作。从例子中可以得到，即使是矩阵行和列大小不等，依旧是可以进行矩阵的置换操作。
![](https://img-blog.csdn.net/20180503202840984)
因此，通过矩阵置换操作，我们利用矩阵的简单乘法计算隐藏层的误差大小。即
![](https://img-blog.csdn.net/20180503202911446)
很厉害！但是我们把归一化因子忽略掉这样可行吗？结果显示这种方法和我们之前不会略归一化因子计算的最终结果是一样的。既然这种方法简单又可行，那么我们将继续沿用这种方法计算。
至此，我们已经进了一大步了。

