# Make Your Own Neural Network（一）-----一种简单的预测机 - Popeye_the_Sailor - CSDN博客
2018年04月24日 21:33:20[_Sailor_](https://me.csdn.net/lz0499)阅读数：407
**Make Your Own Neural Network**
**构建你自己的神经网络**
[https://blog.csdn.net/lz0499](https://blog.csdn.net/lz0499)
**作者：lz0499**
**声明：**
1）**Make Your Own Neural Network**翻译自[Tariq Rashid](https://book.douban.com/search/Tariq%20Rashid)编写的神经网络入门书籍。作者的目的是尽可能的少用术语和高深的数学知识，以图文并茂的方式讲解神经网络是如何工作的。任何拥有高中数学水平的人就能够理解神经网络的工作方式。强烈推荐初学者以这本书作为神经网络入门书籍。
2）本文仅供学术交流，非商用。翻译的初衷是一边翻译一边加深对神经网络的理解。
3）由于刚刚接触神经网络这方面的知识，翻译过程中难免有些错误。若发现错误，还请各位前辈指正。谢谢！
4）由于工作原因，我将有选择的按照原文的章节不定期的进行翻译更新。
5）此属于第一版本，若有错误，还需继续修正与增删。
目录：
第一部分：神经网络是如何工作的
[一种简单的预测机](https://mp.csdn.net/postedit/80069089)
[分类即是预测](https://blog.csdn.net/lz0499/article/details/80072948)
[训练一个简单的分类器](https://blog.csdn.net/lz0499/article/details/80086402)
[单个分类器似乎远不够](https://blog.csdn.net/lz0499/article/details/80099968)
[神经元，自然界的计算机](https://blog.csdn.net/lz0499/article/details/80138584)
[通过神经网络的信号](https://blog.csdn.net/lz0499/article/details/80138955)
[矩阵很有用](https://blog.csdn.net/lz0499/article/details/80160354)
[利用矩阵计算三层神经网络的输出结果](https://blog.csdn.net/lz0499/article/details/80160449)
[从多个节点更新权重](https://blog.csdn.net/lz0499/article/details/80172534)
[从多个节点中反向传递误差](https://blog.csdn.net/lz0499/article/details/80172568)
[多层神经网络层反向传输误差](https://blog.csdn.net/lz0499/article/details/80185692)
[利用矩阵乘法计算反向传输误差](https://blog.csdn.net/lz0499/article/details/80185923)
[实际上是如何更新权重（一）](https://blog.csdn.net/lz0499/article/details/80209928)
[实际上是如何更新权重（二）](https://blog.csdn.net/lz0499/article/details/80210590)
[权重更新实例](https://blog.csdn.net/lz0499/article/details/80212695)
**第一部分 神经网络是如何工作的**
**一种简单的预测机**
想象一种原始的机器，它输入一个问题，进行相关“思考”，最后输出一个答案。就像上一个例子中一样，我们通过眼睛输入相应的视觉信号，再经过我们的大脑分析获取的视觉信息，最后得出相应的结论。诸如，视觉场景中有哪些物体。下图表示的是这种思考过程：
![](https://img-blog.csdn.net/20180424212621653)
计算机不会像人一样思考，因此，我们用更恰当的词汇描述上述计算机的“思考”过程如下图所示：
![](https://img-blog.csdn.net/20180424212634573)
计算机获取一些输入信号，经过一些计算最后输出一个答案。如下图所示，假设计算机输入是一个“3*4”的命令，计算机可能把相应的乘法操作转换为比较简单的一系列加法操作，最后输出答案12.
![](https://img-blog.csdn.net/20180424212645344)
“就这么简单”，你可能会纳闷。是的。我们先通过这种简单而熟悉的例子引入一系列后续我们将要学习的神经网络知识概念。
那我们把问题稍稍复杂化！   
想象一台机器能够把千米换算成米，如下图所示：
![](https://img-blog.csdn.net/20180424212706246)
假设我们并不知道千米转换成米的公式。我们仅仅知道千米和米之间存在线性关系。这意味着，当我们成倍改变以米为单位的一个距离数值时，那么同样的距离，以千米为单位时也将成倍的改变。这个很好理解。这千米和米之间线性关系给我们的直觉感受。
千米和米两者之间的这种线性关系，给了我们如何对两者进行转换的一个线索。即“米=千米*c”，c是一个常量。现在我们并不知道这个常量值是多少。
另外一条线索是，我们有两组千米和米相对应数值的表格。如下所示：
|测试例子|千米|米|
|----|----|----|
|1|0|0|
|2|100|62.137|
利用上面的一些线索，我们该如何计算出常数c的值呢？让我们随机取一个值。就假设c=0.5,然后我们看看会发生什么！
![](https://img-blog.csdn.net/20180424212851935)
因此，我们有关系式米=千米*c。假设千米为100，c为0.5，则输出50米。
Ok.对于随机取的C=0.5来说，结果还不算坏。但是，我们知道这不是一个正确的数值，因为在上述表格第二个例子告诉我们答案应该是62.137.
我们差了12.137.这是误差，是由计算出来的数值和真实数值之间的差值。即
误差=实际值-计算值
                                                                                      =62.137-50
                                                                                      =12.137
![](https://img-blog.csdn.net/20180424212951801)
有误差，我们该如何是好呢？我们知道我们计算出来的值是错误的，而且还错的比较大。与其瞪着这个误差露出绝望的神情，我们还不如利用这个误差做点什么。我们可以利用这个误差作为指导再重新计算c值.
我们再次观察这个误差值，由于千米和米之间存在线性的关系：米= 千米*c，因此，当我们增加常量c时，输出也应该同样增加。
让我们把c值从0.5增加到0.6，然后看看会发生什么。
![](https://img-blog.csdn.net/20180424213004618)
现在c设置为0.6，所以米 = 千米*0.6= 60。嗯，这个答案比第一次的答案更加接近实际值。我们显然进步了一点。
现在的误差2.137已经小很多了.是否我们还可以再进一步减小误差呢？
从上述推到过程中我们使用了误差对c值进行调整。我们想把输出50再提高一点，所以我们提高了一点c值。
让我们放下用代数的思考方式计算c的确切值，转而继续使用上一步中的方式改变c值。我们在按照上一步的做法再做一遍。输出值60仍然比实际值要小。那么，我们继续改变c的值，由0.6改变到0.7，看看会发生什么！
![](https://img-blog.csdn.net/20180424213139301)
噢，糟糕！我们走的太远，计算出来得值已经超过了正确的值。之前的误差是2.137，而现在的误差是-7.863。负号表示的是我们越过了真实值，记住误差的计算公式是：误差=真实值-计算值。
好吧！既然c = 0.6要好于c = 0.7，我们应该在c取0.6的时候感到高兴，毕竟误差已经比较小了，并且准备结束计算。但是，我们再想想，0.6到0.7之前还有许多数，最佳的答案会不会介于它们两者之间呢？那为什么我们不再小一点改变c值呢？比如所从0.6改变为0.61。很好，那我们继续尝试之前的方法，看看结果如何？
![](https://img-blog.csdn.net/20180424213237356)
喔！结果很不错呀！比之前的结果更加好。计算出来的值61，与实际值62.137仅仅相差1.137。
因此最后一次尝试告诉我们，我们应该缓慢的改变c值，已达到较好的结果。如果输出的计算值已经接近实际值，即误差将会越来越小时，我们不应该较大的增加c值，这样我们就避免了计算出来得值超过了实际值，就像我们之前计算的那样。
我们没花多少心思就计算出来了比较好的c值。通过上述计算，我们应该形成这种意识：一点一点，连续的改变数值，这样我们将得到比较精确的答案。
我们刚刚做的，你也许会觉得太简单。但实际上已经非常接近神经网络学习的核心计算方式了。
我们应该总结下：我们刚刚解决的问题并不像在学校里一步到位解决数学或科学问题那样。相反，我们采取了另外一种不同的解决方法，这种方法我们称之为迭代，即不断的重复，一点一点靠近正确答案。
