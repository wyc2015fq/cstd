# 用平均的方法去除噪声 - Popeye_the_Sailor - CSDN博客
2018年08月19日 20:28:24[_Sailor_](https://me.csdn.net/lz0499)阅读数：1054
##                                          用平均的方法去除噪声
### **技术****/****方法**
### **什么？平均？你是说滤波？**
并不是！这种方法并不使用任何滤波（去噪）算法对图像进行处理。实际上，这种方法与滤波相反：你可以获得更为清晰的图像！
在平均法中，我们假设有一系列同一场景的一些图像，只不过每一幅图像具有不同的“噪声模式”。
一旦我们拥有多幅同一场场景的图像，是的，这种你在学校就学过的平均方法：相加之后除以图像的数量。
### **准备开始实验**
首先，我们必须获取到多幅图像，每一幅图像中都有一些噪声。我们使用Photoshop以及自动选择模式生成25幅图像，每一幅图像中添加8%的高斯噪声。
### **开始编码**
首先，确保你包含了OpenCV库中的cv.lib cvaux.lib cxcore.lib highgui.lib文件。
```cpp
#include <cv.h>
#include <highgui.h>
```
现在，主函数为：
```cpp
int main()
{
    IplImage* imgRed[25];
    IplImage* imgGreen[25];
    IplImage* imgBlue[25];
```
我们一开始定义了三个数组，用以包含25幅图像每一个通道。我们现在载入25幅图像。
```cpp
for(int i=0;i<25;i++)
    {
        IplImage* img;
        char filename[150];
        sprintf(filename, "%d.jpg", (i+1));
        img = cvLoadImage(filename);
        imgRed[i] = cvCreateImage(cvGetSize(img), 8, 1);
        imgGreen[i] = cvCreateImage(cvGetSize(img), 8, 1);
        imgBlue[i] = cvCreateImage(cvGetSize(img), 8, 1);
        cvSplit(img, imgRed[i], imgGreen[i], imgBlue[i], NULL);
        cvReleaseImage(&img);
    }
```
让我们一行一行查看上述代码。我们首先创建一个循环，在循环中我们创建保存图像的临时变量，随后，我们输入载入图像的名称。载入图像的名称可以是1.JPG 2.JPG等等，之后我们载入图像到 img变量。
下一步，我们分配了三个通道的内存。随后，我们把载入的图像分离成三个通道的图像，分别保存在刚刚分配的三个通道内存中。
现在，我们在添加如下代码段：
```cpp
CvSize imgSize = cvGetSize(imgRed[0]);
    IplImage* imgResultRed = cvCreateImage(imgSize, 8, 1);
    IplImage* imgResultGreen = cvCreateImage(imgSize, 8, 1);
    IplImage* imgResultBlue = cvCreateImage(imgSize, 8, 1);
    IplImage* imgResult = cvCreateImage(imgSize, 8, 3);
```
我们再次分配了三个通道的内存，用以保存平均法去噪的图像结果。
现在，实现平均去噪的方法：
```cpp
for(int y=0;y<imgSize.height;y++)
    {
        for(int x=0;x<imgSize.width;x++)
        {
            int theSumRed=0;
            int theSumGreen=0;
            int theSumBlue=0;
            for(int i=0;i<25;i++)
            {
                theSumRed+=cvGetReal2D(imgRed[i], y, x);
                theSumGreen+=cvGetReal2D(imgGreen[i], y, x);
                theSumBlue+=cvGetReal2D(imgBlue[i], y, x);
            }
            theSumRed = (float)theSumRed/25.0f;
            theSumGreen = (float)theSumGreen/25.0f;
            theSumBlue = (float)theSumBlue/25.0f;
            cvSetReal2D(imgResultRed, y, x, theSumRed);
            cvSetReal2D(imgResultGreen, y, x, theSumGreen);
            cvSetReal2D(imgResultBlue, y, x, theSumBlue);
        }
    }
```
我们获取每一幅图像的每一个像素，然后我们定义像素的和，用以存放25幅噪声图像的每一个通道的像素和。随后，我们把每一个通道的像素和除以图像的数量，然后在把三通道的图像进行合并，生成最终的图像。
很简单？下面试图像的输出结果：
![很多噪声的图像](https://img-blog.csdn.net/2018081920052970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)很多噪声的原始图像
![噪声都去哪呢？](https://img-blog.csdn.net/20180819200633596?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)结果图像。噪声都去哪呢？
### **理论知识**
很奇妙是吧！？这仅仅使用了25幅图像的平均结果，如果图像越多，去噪效果越好。
图像中的噪声是随机的，有高斯随机噪声以及其他一些噪声。如下图是高斯噪声。
![](https://img-blog.csdn.net/20180819202434418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)高斯噪声图像
假设我们把每一个像素的灰度值相加，之后再除以总的像素值，那么最终得到的结果将会是0或者近似0的结果
因此，如果我们把多幅不同模式的噪声图像没一个像素相加，之后在除以总的像素数量，那么，最终将使得噪声消除掉。
### **数学公式：**
我们用gi代表25幅图像，因此，gi就是原始图像和噪声图像的和。即：
![](https://img-blog.csdn.net/2018081920202625?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
我们使用的平均方法可以表示为：
![](https://img-blog.csdn.net/20180819202058528?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
我们把k（实际实验是25幅）幅图像相加，然后在除以k。由高斯分布可知：
![](https://img-blog.csdn.net/20180819202223326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
因此，通过上述方法，我们最后得的结果即为f(x,y),即图像的原始数据。
**更多图像将得到更佳的效果：**
![](https://img-blog.csdn.net/20180819202416506?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)原始图像
![](https://img-blog.csdn.net/20180819202523514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)两幅图像的平均结果
![](https://img-blog.csdn.net/20180819202611269?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)五幅图像的评价结果
![](https://img-blog.csdn.net/20180819202643317?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)十五幅图像的评价结果
![](https://img-blog.csdn.net/20180819202714730?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)二十五幅图像的评价结果
翻译自：[http://aishack.in/tutorials/noise-reduction-averaging-theory/](http://aishack.in/tutorials/noise-reduction-averaging-theory/)
