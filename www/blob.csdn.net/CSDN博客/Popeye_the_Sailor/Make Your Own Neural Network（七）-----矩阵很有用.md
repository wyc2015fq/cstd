# Make Your Own Neural Network（七）-----矩阵很有用 - Popeye_the_Sailor - CSDN博客
2018年05月01日 22:20:08[_Sailor_](https://me.csdn.net/lz0499)阅读数：236
**Make Your Own Neural Network**
**构建你自己的神经网络**
[https://blog.csdn.net/lz0499](https://blog.csdn.net/lz0499)
**作者：lz0499**
**声明：**
1）**Make Your Own Neural Network**翻译自[Tariq Rashid](https://book.douban.com/search/Tariq%20Rashid)编写的神经网络入门书籍。作者的目的是尽可能的少用术语和高深的数学知识，以图文并茂的方式讲解神经网络是如何工作的。任何拥有高中数学水平的人就能够理解神经网络的工作方式。强烈推荐初学者以这本书作为神经网络入门书籍。
2）本文仅供学术交流，非商用。翻译的初衷是一边翻译一边加深对神经网络的理解。
3）由于刚刚接触神经网络这方面的知识，翻译过程中难免有些错误。若发现错误，还请各位前辈指正。谢谢！
4）由于工作原因，我将有选择的按照原文的章节不定期的进行翻译更新。
5）此属于第一版本，若有错误，还需继续修正与增删。
目录：
第一部分：神经网络是如何工作的
[一种简单的预测机](https://mp.csdn.net/postedit/80069089)
[分类即是预测](https://blog.csdn.net/lz0499/article/details/80072948)
[训练一个简单的分类器](https://blog.csdn.net/lz0499/article/details/80086402)
[单个分类器似乎远不够](https://blog.csdn.net/lz0499/article/details/80099968)
[神经元，自然界的计算机](https://blog.csdn.net/lz0499/article/details/80138584)
[通过神经网络的信号](https://blog.csdn.net/lz0499/article/details/80138955)
[矩阵很有用](https://blog.csdn.net/lz0499/article/details/80160354)
[利用矩阵计算三层神经网络的输出结果](https://blog.csdn.net/lz0499/article/details/80160449)
[从多个节点更新权重](https://blog.csdn.net/lz0499/article/details/80172534)
[从多个节点中反向传递误差](https://blog.csdn.net/lz0499/article/details/80172568)
[多层神经网络层反向传输误差](https://blog.csdn.net/lz0499/article/details/80185692)
[利用矩阵乘法计算反向传输误差](https://blog.csdn.net/lz0499/article/details/80185923)
[实际上是如何更新权重（一）](https://blog.csdn.net/lz0499/article/details/80209928)
[实际上是如何更新权重（二）](https://blog.csdn.net/lz0499/article/details/80210590)
[权重更新实例](https://blog.csdn.net/lz0499/article/details/80212695)
**矩阵很有用**
之前我们计算了两层神经网络每层两个节点的最终输出结果。很好，但是想象一下我们用同样的方法计算每层拥有100个节点的五层神经网络！？光是想象输入信号与各种权重的组合以及经过激活函数之后，那手动计算量，可能会让人发疯。
所以矩阵究竟能帮上什么呢？矩阵可以从两方面帮助我们。首先，矩阵能够用一种简单的公式压缩神经网络中各种计算。这对人类来说很有帮助，毕竟人类并不喜欢太多枯燥的计算，并且计算过程中，还会引入一些人为的错误。第二个好处是，许多计算机编程语言能够很好的理解矩阵，由于实际计算涉及到很多重复的计算，而计算机拥有很好的计算能力，能够很迅速的计算出结果。
简而言之，矩阵能够让我们方便的表达出神经网络的计算过程；而计算机能够快速而有效的帮助我们计算出最终的结果。
现在我们知道为什么我们要回过头来复习矩阵了吧！尽管你在学校学习矩阵的时候可能有段痛苦的经历。但是，我想还是让我们重新开始揭开矩阵的神秘面纱吧！
矩阵仅仅是一种用矩形网格把数字括起来的表格。这就是矩阵，它并没有其他更为复杂的含义。
如果你用过spreadsheet，你应该对网格括起来的数字感到并不陌生。有些人称之为表格，我们称之为矩阵。以下表示的是用spreadsheet括起来的一些数字。
![](https://img-blog.csdn.net/20180501221511279)
这就是矩阵—一种表格或是用网格的数字。就像下面的图示表示的是2*3大小的矩阵。
先用行再用列表示矩阵很方便或者说是一种习惯，所以上述的矩阵并不是3*2的矩阵而是2*3的矩阵。
![](https://img-blog.csdn.net/20180501221420623)
上图矩阵中，有些人用方括号括起来数字，而我们使用圆括号括起数字。这只是表达方式的不一样而已。
实际上，括起来的不一定是数字，也可以是给出一些名字的数目，这些数目并不一定赋给数值。所以下图的矩阵中，括起来的是一种拥有一定含义并拥有一定数值的变量，只不过我们还没有说明它们是什么而已。
![](https://img-blog.csdn.net/2018050122155082)
当我们计算矩阵乘法的时候，我们会看到矩阵变得非常有用。你可能在学校记得如何计算矩阵的乘法，如果没有，我们可以再复习一下。
下图表示的是两个矩阵相乘之后的结果。
![](https://img-blog.csdn.net/20180501221619659)
你可以看到，我们并不是把矩阵对应的数字进行相乘。实际上，矩阵乘法拥有它自己的规则。
你可以通过上面的例子看出来矩阵相乘究竟是如何计算的。如果没有可以再看看下图中高亮部分的计算过程。
![](https://img-blog.csdn.net/20180501221648210)
你可以看到，左边矩阵的第一行与右边矩阵的第一列中的数值分别对应相乘，并把最后的结果作为最后矩阵的第一行第一个元素。矩阵其他元素的结果我们可以从图中看出也是左边矩阵对应行的各个元素与右边对应列中各元素相乘再相加之后的结果。
不同大小的矩阵相乘，其两个相乘矩阵的大小是由一定限制的。你并不能把任意大小的矩阵相乘。实际上，如果你需要进行矩阵的乘法运算，必须保证相乘的第一个矩阵的行大小和相乘的第二个矩阵的列大小相等。
在一些教程中，你会发现这种矩阵相乘的运算也被称之为点乘或者说内积。实际上，对于矩阵还有其他乘法运算，比如说叉积，但是，当前我们仅仅限于矩阵的点乘运算。
让我们用更有意义的单词取代我们神经网络数值。相乘矩阵中的第二个矩阵为列矩阵，其两矩阵的乘法运算依旧还是之前的方法。如下图所示：
![](https://img-blog.csdn.net/20180501221728605)
很神奇不是！
第一个矩阵包含的是两层神经网络中节点对应的权重，第二个矩阵包含的是神经网络的第一层的输入信号。矩阵相乘的结果就是输入到第二层神经网络节点的输入信号的加权和。仔细查看，我们能够发现这点。输出结果中的第一个节点的数值是第一个输入信号与权重W1,1相乘加上第二个输入信号与权重W1,2相乘的和。这个加权和也是sigmoid激活函数中X的数值的大小。
下面图示中能够更好地表达出其计算过程。
![](https://img-blog.csdn.net/2018050122180022)
这可真有用。
为什么呢？因为我们可以把神经网络中所涉及到的所有计算过程用一个公式就可以完美的表达出：
![](https://img-blog.csdn.net/20180501221830407)
其中，**W**表示的是权重矩阵，**I**表示的是输入信号矩阵。**X**表示的是输入到第二层神经网络的结果。矩阵变量通常用实体表示，因为，矩阵中的变量不仅仅表示单个数字，也可能表示多个数字或变量。
现在，我们并不需要关注每一层神经网络中包含有多少个节点。如果我们包含更多的节点，上述公式中只需要把相应的矩阵增大就是，我们并不需要再写那种又长又麻烦的计算公式，不管神经网络中拥有多少层神经网络结构，我们只需要写一个公式**W*I**即可。
如果计算机编程语言能够很好的理解矩阵的表示方法，那么我们能够通过计算机来替代我们计算神经网络中复杂而又冗长的计算。
真是太神奇了！只要花点时间理解矩阵乘法，我们就能够获得一种强大的工具，用以计算神经网络中所涉及到的复杂运算。
那么激活函数怎么办？这个比较简单，且并不涉及到矩阵的乘法运算。我们只需把矩阵**X**中的各个元素输入到激活函数即可。
这听起来太简单了吧！不过，实际上也确实是这么计算的。我们不再单个单个计算输入信号与对应权重的乘积，因为我们已经使用矩阵计算出了输入信号的加权和。所以，对于两层的神经网络而言，最后的输出结果为：
![](https://img-blog.csdn.net/20180501221928262)
这个用实体表示的**O**是一个矩阵，表示的是神经网络最后一层的输出结果。
表达式**X=W*I**计算的是神经网络中当前层到下一层的加权和。比如说，我们有三层神经网络，当我们计算出神经网络中第一层到第二层的结果时，再计算出最后的结果时，我们仅仅需要把第二层的结果作为第三层的输入信号，再求各个权重与对应信号的加权和，然后把最后的结果输入到sigmoid函数中做一个阈值判断，输出神经网络最后的输出结果。
理论已经有了。让我们以每层三个节点，共三层神经网络为例，开始实际计算一下最后的输出结果。

