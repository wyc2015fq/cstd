# Make Your Own Neural Network（三）-----训练一个简单的分类器 - Popeye_the_Sailor - CSDN博客
2018年04月25日 22:11:38[_Sailor_](https://me.csdn.net/lz0499)阅读数：512

**Make Your Own Neural Network**
**构建你自己的神经网络**
[https://blog.csdn.net/lz0499](https://blog.csdn.net/lz0499)
**作者：lz0499**
**声明：**
1）**Make Your Own Neural Network**翻译自[Tariq Rashid](https://book.douban.com/search/Tariq%20Rashid)编写的神经网络入门书籍。作者的目的是尽可能的少用术语和高深的数学知识，以图文并茂的方式讲解神经网络是如何工作的。任何拥有高中数学水平的人就能够理解神经网络的工作方式。强烈推荐初学者以这本书作为神经网络入门书籍。
2）本文仅供学术交流，非商用。翻译的初衷是一边翻译一边加深对神经网络的理解。
3）由于刚刚接触神经网络这方面的知识，翻译过程中难免有些错误。若发现错误，还请各位前辈指正。谢谢！
4）由于工作原因，我将有选择的按照原文的章节不定期的进行翻译更新。
5）此属于第一版本，若有错误，还需继续修正与增删。
目录：
第一部分：神经网络是如何工作的
[一种简单的预测机](https://mp.csdn.net/postedit/80069089)
[分类即是预测](https://blog.csdn.net/lz0499/article/details/80072948)
[训练一个简单的分类器](https://blog.csdn.net/lz0499/article/details/80086402)
[单个分类器似乎远不够](https://blog.csdn.net/lz0499/article/details/80099968)
[神经元，自然界的计算机](https://blog.csdn.net/lz0499/article/details/80138584)
[通过神经网络的信号](https://blog.csdn.net/lz0499/article/details/80138955)
[矩阵很有用](https://blog.csdn.net/lz0499/article/details/80160354)
[利用矩阵计算三层神经网络的输出结果](https://blog.csdn.net/lz0499/article/details/80160449)
[从多个节点更新权重](https://blog.csdn.net/lz0499/article/details/80172534)
[从多个节点中反向传递误差](https://blog.csdn.net/lz0499/article/details/80172568)
[多层神经网络层反向传输误差](https://blog.csdn.net/lz0499/article/details/80185692)
[利用矩阵乘法计算反向传输误差](https://blog.csdn.net/lz0499/article/details/80185923)
[实际上是如何更新权重（一）](https://blog.csdn.net/lz0499/article/details/80209928)
[实际上是如何更新权重（二）](https://blog.csdn.net/lz0499/article/details/80210590)
[权重更新实例](https://blog.csdn.net/lz0499/article/details/80212695)
[](https://blog.csdn.net/lz0499/article/details/80086402)
**第一部分 神经网络是如何工作的**
**训练一个简单的分类器**
我们想训练我们的线性分类器正确的把昆虫分类为毛毛虫或者瓢虫。我们从上一小节可知，只需要在昆虫身长和体宽的坐标系中改变直线的斜率就可以把两种类型的昆虫分类。
那我们该如何改变斜率呢？
与其提出一些数学理论解决这个问题，还不如从直觉下手解决这个问题。
我们确实需要一些样本用来训练。下面表格中的两个样本只是为了保证这个例子足够简单而设置的。
|样本|体宽|身长|昆虫类型|
|----|----|----|----|
|1|3.0|1.0|瓢虫|
|2|1.0|3.0|毛毛虫|
我们有一个身长为3.0，体宽为1.0的毛毛虫样本，同时，我们也有一个身长为1.0，体宽为3.0的瓢虫样本。
这些样本就我们而言是真实的样本。这些样本能够用来修改分类函数的斜率。真实的样本用来训练预测机和分类器，这些样本称之为训练数据。
让我们在坐标系画出这两个训练数据。
![](https://img-blog.csdn.net/2018042521504967)
让我们从任意位置画一条随机的分类直线。就像前面小结描述的千米转换为米的预测机一样，我们可以定义这条分类直线为：
![](https://img-blog.csdn.net/20180425215308583)
我们使用y和x替代长和宽，是因为严格意义上来说，这条直线并不是预测机。它不想之前千米转换成米的预测机，并没有把长度转换为宽度，而是一条分类线，一个分类器。
你也可能注意到y=Ax比y=Ax+B这种类型的直线要简单很多。那是为了保证这个分类器例子足够简单。非零B意味着这条分类直线不经过坐标得原点，这点对分类器例子而言一点帮助也没有。
我们观察到参数A控制了直线的斜率。A越大，斜率越大。
让我们从A=0.25开始。此时这条分类线为。在坐标系中画出这条直线如下图所示：
![](https://img-blog.csdn.net/20180425215431522)
从图中我们可以观察到，这条直线y=0.25x并不是一条很好的分类直线。它没有把两种昆虫区分开来。因此，我们不能说“如果昆虫位于直线的上方，那么这类昆虫就是毛毛虫”，因为瓢虫也是位于直线上方。
因此，我们需要向上移动直线。我们需要抑制从坐标图中画出一条合适的分类直线。我们想找到一种重复的操作，以及一系列的计算机指令用来找到合适的分类直线。这一系列的操作我们称之为算法。
让我们来看看第一个训练样本数据：宽度为3.0，长度为1.0的瓢虫。如果我们使用x=3.0带入直线y=Ax，我们可以得到：
y=0.25*3.0=0.75
这个函数，使用随机的一个初始化参数A=0.25，计算出体宽为3.0的昆虫的身长为0.75,。但实际上我们知道这个计算值比真实值较小。因为，给出的训练样本数据中对应的身长为1.0.
所以就像之前预测机中的例子一样，我们有一个差值，一个误差。同样的，我们可以利用这个误差值来指导我们该如何调整参数A。
开始调整A之前，我们应该想想y应该是多少。如果y=1.0,那么直线将刚好穿过坐标系中的点(x,y)=(3.0,1.0)。这是一个位于直线上敏感的点，但是我们需要找的点。我们需要找到一条位于该点上方的直线。为什么呢？因为我们想一条直线，使得坐标系中瓢虫坐标得点位于该直线之下而不是刚刚在直线上。这条直线必须区分瓢虫和毛毛虫，而不是根据昆虫的体宽预测身长。
假设当x=3.0时，y=1.1。y值仅仅比1.0大一点点。我们也可以设置y为1.2或1.3,但是我们不应该设置y为10或100，因为这样选取的直线在坐标系中都在毛毛虫和瓢虫坐标点之上，对分类而言一点作用也没有。
所以，当目标值y=1.1时，误差E为：
误差=目标值-计算值，即E=1.1-0.75。如下图所示：
![](https://img-blog.csdn.net/20180425215644672)
现在，我们该如何利用误差指导我们更好的修改参数A呢？这是一个重要问题！
让我们回退一步，再好好想想这个问题。我们想利用误差E来修正参数A。这两者的关系是怎样的呢？我们必须搞清楚。如果我们知道了这两者的关系，那么，我们就能知道改变其中一个值将如何影响另外一个值。
让我们以线性函数开始：
y=Ax
我们已经了解到随机的一个初始值A计算出来一个错误的答案y，y值本应该是训练数据中的值。假设正确的目标值为t，为了获得t值，我们必须一点一点调整A。用数学公式表示为：
![](https://img-blog.csdn.net/20180425215817662)
让我们画出相应的示意图。
![](https://img-blog.csdn.net/20180425215909679)
我们可以看到新的斜率为![](https://img-blog.csdn.net/20180425220053281)。我们知道误差E是以当前A的猜测参数计算出来的值与真实值之间的差值。即E=t-y。
让我们更加清楚的描述为：
![](https://img-blog.csdn.net/20180425220107402)
哦！很令人惊讶。误差E与的关系如此简单。太简单了以至于我以为计算出错了。实际上确实就是这么简单。既然求出了两者之间的关系，那么余下的工作就简单多了。
我们想知道，通过误差E的相关信息，如何改变A以得到一条较好的分类效果直线。我们重新调整上述的关系式：
![](https://img-blog.csdn.net/20180425220132652)
就是这个关系。这个神奇的表达式就是我们需要寻找的。从表达是可以看出，我们可以利用误差在斜率A的基础上增加的数量改变分类直线的斜率A。
误差在斜率A的基础上增加![](https://img-blog.csdn.net/2018042522030293)的数量改变分类直线的斜率A。
就让我们开始吧！更新一下初始的斜率。
当x=3.0时，误差E=0.35.通过上式可知![](https://img-blog.csdn.net/20180425220132652)=0.35/3=0.1167。这意味着我们必须增加0.1167改变当前的A。即最新的修正值为![](https://img-blog.csdn.net/2018042522042944)=0.25+0.1167=0.3667。把最新修改的A代入原始直线方程中，得到了我们期望的数值y=1.1。
厉害了！我们做到了。在上述方法中，我们通过误差来调整参数A以得到我们期望的计算值。
让我们趁热打铁！
我们已经使用了一个训练数据，让我们在从另外一个训练数据开始。我们已经知道当x=1.0时，y=3.0。
让我们来看看当输入为x=1.0时，带入最新的斜率A=0.3667的线性函数中，我们能够得到y=1.0*0.3667=0.3667。这个数据与之前表格中第二个训练数据y=3.0差别很大呀！
同样的，我们理想中的分类直线不应该刚刚穿过训练数据点，而是应该在这些训练数据点之上或之下。因此，我们应该重新设置目标值y=2.9。这样这个训练数据就在直线之上。所以，我们得到误差为E=2.9-0.3667=2.5333。
这个误差有点大。就像第一个训练数据一样，让我们再重新更新下A值。![](https://img-blog.csdn.net/20180425220536806)=2.5333/1.0=2.5333。这意味着最新的A值应该为0.3667+2.5333=2.9。这意味着，当x=1.0时，带入到最新更新的线性函数中，我们将得到答案y=2.9。这已经与实际值很接近了。
通过上述两个训练数据的训练，我们得到了最后的直线。下图所示，表示的是由初始的函数经过第一个训练数据之后，得到了第一条分类直线，最后再通过训练数据二的训练，得到最后的分类直线。
![](https://img-blog.csdn.net/20180425220713781)
等等。怎么回事！仔细查看上述图例，我们似乎并没有按照我们预期改变分类直线的斜率。因为，最后的分类直线并不能很好的把毛毛虫和瓢虫区分开来。
但是我们确实可以通过改变斜率得到实际值呀？
这是怎么回事呢？如果我们继续使用训练数据进行斜率的更新，最后我们得到的分类直线将比较靠近最后的训练数据。通过上述方法，实际上我们丢弃了前面训练数据的更新值，而仅仅从最后的训练数据得到更新值。
那么，我们应该如何避免这个问题呢?
很简单。这也是机器学习中的一个重要思维方法。我们应该平滑的更新参数。即我们一点一点的修改参数，而不是直接就更新到最小的参数A。我们只是一点一点更新参数A的一小部分![](https://img-blog.csdn.net/20180425220758719)。这样，我们就可以朝着训练数据指导的方向微小的更新参数A。
这种平滑变化的方式，还有一个强大而实用的作用。当训练数据不能确信的时候，或者训练数据中含有误差或者错误时，这种平滑的方式抑制误差或噪声的影响。
好的！既然这样。那我们以下面这种方式平滑更新参数A：
![](https://img-blog.csdn.net/20180425220839627)
这个平滑系数称之为学习率，我们用L表示。假设我们从L=0.5开始。这意味着我们仅仅更新![](https://img-blog.csdn.net/20180425220918382)最新的一半。
我们有初始参数A=0.25,第一个训练数据得到的y=0.25*3.0=0.75,实际期望的数值为1.1。根据上述公式可知![](https://img-blog.csdn.net/20180425220934685)=0.5*0.35/3.0=0.0583.所以，我们更新A到0.25+0.0583=0.3083.
用最新的参数A，我们可以从训练数据一中知道，当x=3.0时，y=0.3083*3.0=0.9250。这条分类直线位于第一个训练数据之下，但是对于第一次校正来说，还不算很差,至少它是从初始位置沿着正确的方向在改变。
让我们接着计算。对于第二个训练数据而言，当x=1.0,A=0.3083，得到y=0.3083。而实际期望的数值为2.9。所以误差为2.9-0.3083=2.5917. ![](https://img-blog.csdn.net/20180425221019590)=0.5*2.5917/1.0=1.2958.故最小的参数A=0.3083+1.2958=1.6042。让我们再用图示的方式表示初始分类函数，第一次修改的分类函数和第二次修正之后的分类函数：
![](https://img-blog.csdn.net/20180425221036143)
效果还不错。
即使只用两个训练数据，使用较为简单的迭代方法，我们也能得到较好的分类直线y=Ax,其中A= 1.6042.
通过上述例子，我们了解到了一种从训练样本中学习自动更新参数得方法。
太棒了！


