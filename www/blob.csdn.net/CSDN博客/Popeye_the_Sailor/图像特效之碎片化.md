# 图像特效之碎片化 - Popeye_the_Sailor - CSDN博客
2017年10月14日 21:16:17[_Sailor_](https://me.csdn.net/lz0499)阅读数：966
## 图像特效之碎片化
### 1.算法原理
     关于碎片滤镜的原理，网络上可找到的资料为：将图像创建四个相互偏移的副本，产生类似重影的效果。
      就凭上述一句话，我们就可以动手了。
      分析：通过上述几幅图像的比较，特别是眼睛部位，可以看出处理的图应该看得出像是单眼变成了4个眼睛，因此，网络上的说法可靠。
      那么偏移的中心在哪里，偏移的数量又是多少呢，4个偏移，分别是往那些方向偏移呢，这些问题也很简单，可以那PS做验证:
      具体步骤如下：打开一幅图像，在图像颜色比较单调的地方（比如上述美女的手臂处）填充一处2*2像素的红色，然后复制图层，对复制后的图层进行碎片滤镜处理，并调整图层透明度为50%，局部放大可得到如下图像：
![](https://img-blog.csdn.net/20171014211745558)
       如此效果，则可轻易得出结论：
       偏移的中心就是以每个像素为中心，4个偏移分别以中心对称，斜45度均匀圆周布置，水平和垂直偏移各45度，偏移量4个像素。
       那么如何叠加的问题应该可以猜测，是取四次偏移后累加值的平均值。
       针对如此思路，我写出如下算法：
### 2.关键代码实现
```cpp
int Fragment(IMAGE_TYPE *BMP24_img)
{
	DWORD width,height,i,j,XX,YY,bfsize,Speed,dst_index,src_index;
	WORD  biBitCount,SumB,SumG,SumR;
	T_U8 *dst,*bmp,*img_data;
	int pix,R,G,B,PixR,PixG,PixB,OffsetX[4] = {4, -4, -4, 4 },OffsetY[4] = {-4, -4, 4, 4},direct;
	T_U32 line_byte,Imgindex;
	
	
	BITMAPFILEHEADER bf;
	BITMAPINFOHEADER bi;
	
	FILE *FragmentPicture_fp = fopen("Fragment.bmp","wb");
	
	if(NULL == FragmentPicture_fp)
	{
		printf("Can't open Fragment.bmp\n");
		return -1;
	}
	
	memset(&bf, 0, sizeof(bf));
	memset(&bi, 0, sizeof(bi));
	
	bmp = BMP24_img;
	memcpy(&bf,bmp,14);
	memcpy(&bi,&bmp[14],40);
	
	fwrite(&bf,sizeof(BITMAPFILEHEADER),1,FragmentPicture_fp);
	fwrite(&bi,sizeof(BITMAPINFOHEADER),1,FragmentPicture_fp);
	
	height = bi.biHeight;
	width  = bi.biWidth;
	bfsize = bf.bfSize;
	biBitCount = bi.biBitCount;
	line_byte = WIDTHBYTES(width*bi.biBitCount);
	img_data = bmp+54;
	
	dst = (T_U8 *)malloc(line_byte*height);
	memset(dst,0,line_byte*height);
	memcpy(dst,img_data,line_byte*height);
	for(i = 0;i < height;i++)
	{
		Speed = line_byte*i;
		for(j = 0;j < width;j++)
		{
			SumB = 0;
			SumG = 0;
			SumR = 0;
			for(direct = 0; direct < 4;direct++)
			{
				XX = OffsetX[direct]+j;
				YY = OffsetY[direct]+i;
				if(XX < 0)
					XX = 0;
				if(XX >= width)
					XX = width - 1;
				if(YY < 0)
					YY = 0;
				if(YY >= height)
					YY = height - 1;
				dst_index = YY * line_byte+3*XX;
				SumB += dst[dst_index];
				SumG += dst[dst_index+1];
				SumR += dst[dst_index+2];
			}
			img_data[Speed] = (T_U8)(SumB>>2);
			img_data[Speed+1] = (T_U8)(SumG>>2);
			img_data[Speed+2] = (T_U8)(SumR>>2);
			Speed += 3;
		}
	}
	fwrite(img_data,line_byte*height,1,FragmentPicture_fp);
	fclose(FragmentPicture_fp);
	FragmentPicture_fp = NULL;
	free(dst);
	return 0;
}
```
### 3.图像效果
![](https://img-blog.csdn.net/20171014212052207)![](https://img-blog.csdn.net/20171014212252715)
![](https://img-blog.csdn.net/20171014212915705)![](https://img-blog.csdn.net/20171014213044222)
参考文献：
[PhotoShop算法原理解析系列 - 像素化---》碎片。](http://www.cnblogs.com/Imageshop/p/3173090.html)
