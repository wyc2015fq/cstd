# 关于高斯滤波的一些理解 - Popeye_the_Sailor - CSDN博客
置顶2017年01月04日 07:44:34[_Sailor_](https://me.csdn.net/lz0499)阅读数：29967标签：[图像处理 高斯滤波](https://so.csdn.net/so/search/s.do?q=图像处理 高斯滤波&t=blog)
个人分类：[图像基础算法处理](https://blog.csdn.net/lz0499/article/category/6663615)
##      滤波算法简介
         图像处理中，常用的滤波算法有均值滤波、中值滤波以及高斯滤波等。均值滤波使用模板内所有像素的平均值代替模板中心像素灰度值，这种方法易收到噪声的干扰，不能完全消除噪声，只能相对减弱噪声；中值滤波计算模板内所有像素中的中值，并用所计算出来的中值体改模板中心像素的灰度值，这种方法对噪声不是那么敏感，能够较好的消除椒盐噪声，但是容易导致图像的不连续性。高斯滤波对图像邻域内像素进行平滑时，邻域内不同位置的像素被赋予不同的权值，对图像进行平滑的同时，同时能够更多的保留图像的总体灰度分布特征。
##      高斯滤波
        数值图像处理中，高斯滤波主要可以使用两种方法实现。一种是离散化窗口滑窗卷积，另一种方法是通过傅里叶变化。在这我主要想说说第一种方法的高斯滤波。离散化窗口滑窗卷积的时，主要利用的是高斯核，高斯核一般是一个奇数的大小的高斯模板。常用的高斯模板有如下几种形式：
![](https://img-blog.csdn.net/20170104082145549)
       上图所示是常用的两种高斯模板， 左侧是常用的3*3的高斯模板，右侧是常用的5*5高斯模板。那么，上述高斯模板中的参数是怎么得到的呢？这是我第一次接触高斯滤波时，一直不太明白的问题。经过一段时间的学习，查阅资料。才渐渐明白高斯模板中的参数是如何得到的！
       高斯模板中的参数是通过高斯函数计算出来的。计算高斯模板参数时，通过如下公式：
![](https://img-blog.csdn.net/20170104083209100)
    x的平方和y的平方分别表示的是邻域内其他像素与邻域内中心像素的距离，Sigmma代表的是标准差。
![](https://img-blog.csdn.net/20170104084419840)
    如上图所示由二维高斯图像可知，标准差越小，二维高斯图像越窄小，平滑效果不明显；标准差越大，而为高斯图像越矮宽，滤波效果比较明显。主要代码如下：
```cpp
double weight;
	double sum = 0;
	double Sigmma = 1;
	double Gaussian_Temp[SIZE][SIZE] = {0};
	int i,j;
	weight = 2*PI*Sigmma*Sigmma;
	for(i =0;i <SIZE;i++)
	{
		for(j = 0;j < SIZE;j++)
		{
			Gaussian_Temp[i][j] =exp(-((i-SIZE/2)*(i-SIZE/2)+(j-SIZE/2)*(j-SIZE/2))/(2.0*Sigmma*Sigmma));
			sum += Gaussian_Temp[i][j];
		}
	}
	for(i = 0; i < SIZE;i++)
	{
			for(j = 0;j < SIZE;j++)
		{
			Gaussian_Temp[i][j] = Gaussian_Temp[i][j]/sum;//归一化处理
			printf("%f ",Gaussian_Temp[i][j]);
		}
			printf("\n");
	}
```
        以5*5高斯模板为例，计算出来的高斯模板值为：
![](https://img-blog.csdn.net/20170104085621525)
        计算出来的结果与上图5*5的高斯模板有一定差异，为什么会不一样呢？查阅资料，解释到：高斯模板实际上也就是模拟高斯函数的特征，具有对称性并且数值由中心向四周不断减小，上述图像中的5*5这个模板刚好符合这样的特性，并且非常简单，容易被大家接受，于是就比较经典。也就是说上述图像中5*5的高斯模板只是对二维高斯函数理论上计算出来的值的一种近似处理，如何从理论上的计算出来的值得到图片中5*5的高斯模板呢？我是这么理解高斯模板中各个参数得由来，如何从理论值得到高斯模板中的值还不太清楚！！
      此外，计算高斯模板参数时，需要归一化处理，为什么需要进行归一化处理呢？我的理解如下：
![](https://img-blog.csdn.net/20170104090705352)
      这是一维高斯函数概率密度函数图像。横轴表示可能得取值x，竖轴表示概率分布密度F(x)，由高斯概率密度函数可知，那么不难理解这样一个曲线与x轴围成的图形面积为1。在实际应用中，在计算离散近似的时候，在大概3σ距离之外的像素都可以看作不起作用，这些像素的计算也就可以忽略。也就是说，为了尽可能的模拟高斯函数的相关性质，计算高斯模板的时候，计算出来的高斯模板中各个数值其和必须为1，这也就是为什么需要进行归一化的原因。
    高斯函数计算出来的模板之所以归一化，另外一种解释是：归一化之后，通过卷积计算出来的模板中心像素被限制到了0-255的灰度区间中。假若某一邻域内所有像素的灰度值为255，利用该模板进行卷积之后，求得的模板中心像素灰度值仍然为255；假若计算出来的高斯模板参数之和小于1，那么通过该模板进行卷积之后，模板中心像素的灰度值将小于255，偏离了实际的灰度值，产生了误差。
参考文献：
http://lps-683.iteye.com/blog/2251180

