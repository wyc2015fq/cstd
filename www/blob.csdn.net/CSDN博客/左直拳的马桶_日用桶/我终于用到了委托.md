# 我终于用到了委托 - 左直拳的马桶_日用桶 - CSDN博客
2006年06月15日 19:17:00[左直拳](https://me.csdn.net/leftfist)阅读数：2441标签：[object																[null																[c++](https://so.csdn.net/so/search/s.do?q=c++&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=object&t=blog)
个人分类：[.NET](https://blog.csdn.net/leftfist/article/category/94497)
我终于用到了委托
左直拳
。NET带来了一些新的东西，其中委托是一个。
我总觉得委托很神秘，比较难理解。看帮助，查资料，不是语焉不详，就是故弄玄虚，越看越糊涂。有时候，真有点怀疑网上写文章的这些人自己是否真的弄清楚了。
后来编码的时候用到了一下，总算有了点认识。一言以蔽之，委托的作用是使得函数可以当作参数和变量来使用。（今天又查了一下帮助，里面说委托作用类似于“ C++ 中函数指针”，因为我对函数指针不熟，所以，惭愧，怪不得之前不明白）。不过这个函数，其返回值、参数都要跟委托声明的一致才行。就好象螺丝孔，不是所有的螺丝钉都能拧进去，要尺寸大小合适才可以。
定义和使用委托分三个步骤：声明、实例化和调用。举例说明。
假设我们要写一段代码，实现“见人说人话尽人事，见鬼说鬼话怀鬼胎”的功能，怎么办呢？
先实现说话和做事函数。
void SpeakAsHuman(){}//有一说一，说出人话
void SpeakAsGhost{}//经过大脑复杂运算，说出鬼话
void DoAsHuman(){};//尽人事
void DoAsGhost(){};//怀鬼胎
然后使用委托来引用这些函数
//声明一个委托
delegate void myDelegate();
//构造两个委托实例
myDelegate dlSpeak = null;//说话
myDelegate dlDo = null;//做事
//调用
switch( 遇见谁？)
{
case 人:
//看，函数作为参数或对象用于赋值
//这跟平常构造一个变量有什么不同？如 StringBuilder str = new  StringBuilder("Hello World!");
dlSpeak = new myDelegate(SpeakAsHuman);
dlDo = new myDelegate(DoAsHuman);
break;
case 鬼:
dlSpeak = new myDelegate(SpeakAsGhost);
dlDo = new myDelegate(DoAsGhost);
break;
default:
break;
}
这样子处理后，dlSpeak,dlDo在见人或见鬼时，就会有不同的内涵，说话按扭cmdSpeak和做事按扭cmdDo的OnClick事件就容易处理多了：
//点击了说话按扭
private void cmdSpeak_Click(object sender, System.EventArgs e)
{
dlSpeak();
}
//点击了做事按扭
private void cmdDo_Click(object sender, System.EventArgs e)
{
dlDo();
}
可以看见，代码比较简洁，逻辑上也更分明了。对于说话按扭和做事按扭来讲，什么都可以不理会，只须说和做就行，至于说什么，做什么，都已经预先定好。并且这个预先定好不是在开发阶段来设定，而是在运行阶段自行设定，多棒。
假如没有用委托，说话按扭cmdSpeak和做事按扭cmdDo的OnClick事件中肯定要各判断一次，如下：
//点击了说话按扭
private void cmdSpeak_Click(object sender, System.EventArgs e)
{
//调用
switch( 遇见谁？)
{
case 人:
SpeakAsHuman（）;
break;
case 鬼:
SpeakAsGhost();
break;
default:
break;
}
}
//点击了做事按扭
private void cmdDo_Click(object sender, System.EventArgs e)
{
switch(……
}
上面的代码如果分开，说话及做事定义在一个类文件里，而按扭放在一个页面上，可以想见，利用委托，能够屏蔽许多细节，实现很好的封装性。
委托，也许可以理解为“函数的代理”？
