# 执行完毕再往下执行？ - 左直拳的马桶_日用桶 - CSDN博客
2006年03月23日 11:24:00[左直拳](https://me.csdn.net/leftfist)阅读数：1602
执行完毕再往下执行？
左直拳
我写了一段代码，如下：
Busy();
//进行大工作量，耗时的操作
BigSetup();
Free();
其中，函数Busy()的作用是将鼠标光标设为代表等待的沙漏形状，并且显示一幅忙碌的图片，而函数Free()则正好相反，将光标设回默认的箭头状，并显示清闲的图片：
private void Busy()
{
imgEpass.Image = mImgBusy;
this.Cursor = Cursors.WaitCursor;
}
private void Free()
{
imgEpass.Image = mImgFree;
this.Cursor = Cursors.Default;
}
可是，运行的结果与预期有很大落差：图片没有改变，或者说，没有单方面改变现状。
怎会这样。难道系统没等Busy()这个函数执行完，就呼啦啦（大长今？）地一直往前冲？
查帮助，上网搜索，同步、异步、线程、阻塞、……，铺天盖地，头昏脑胀，乱七八糟，却一无所获。我还想到了用Sleep()，死未。
观察程序运行，鼠标的光标确实改变了，而改变鼠标形状的语句放在改变图片之后，也就是说，图片也应该改变了，只是未反映出来。可能是没重绘吧。
修改了一下Busy()和Free()
private void Busy()
{
imgEpass.Image = mImgBusy;
imgEpass.Refresh();
this.Cursor = Cursors.WaitCursor;
}
private void Free()
{
imgEpass.Image = mImgFree;
imgEpass.Refresh();
this.Cursor = Cursors.Default;
}
终于得到了我想要的。
