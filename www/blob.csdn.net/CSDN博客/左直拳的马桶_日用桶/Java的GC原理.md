# Java的GC原理 - 左直拳的马桶_日用桶 - CSDN博客
2018年12月22日 15:05:01[左直拳](https://me.csdn.net/leftfist)阅读数：246
## **一、概述**
Java语言中一个显著的特点就是引入了垃圾回收机制，使c/c++程序员最头疼的内存管理问题迎刃而解，它使得Java程序员在编写程序的时候不用考虑内存管理，JVM替我们完成了这部分工作。
## **二、回收步骤**
JVM的垃圾回收工作主要完成3件事：
```
1、确定哪些内存需要回收？
2、确定什么时候需要执行垃圾回收？
3、如何执行垃圾回收？
```
## **三、何为垃圾？**
不可达的对象会变成垃圾。什么叫做不可达？就是没有办法引用了，引用不了它，不能为我们所用。一个对象有以下情况会变成垃圾：
```
1.对非线程的对象来说，当所有的活动线程都不能访问该对象，则该对象变为垃圾。
2.对线程对象来说，满足上面的条件，且线程未启动或者已停止。
```
## **四、啥时回收？**
时间不确定。
垃圾回收机制是由垃圾收集器（Garbage Collection，即GC）来实现的，GC是后台的守护进程。它的特别之处在于它是一个低优先级进程，但是可以根据内存的使用情况动态调整优先级。因此，GC会在内存中低到一定限度时才自动运行，从而实现对内存的回收。这就是垃圾回收的**时间不确定**的原因。
为何要这样设计？因为GC也是进程，也要消耗CPU等资源，如果执行过于频繁，会对java程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选择了不定期的进行垃圾回收。
## **五、怎样回收？**
说来话长。概括的说，就是：**分代分配内存，分代回收垃圾**。
这里说的内存，主要是指JVM中的堆区，因为对象保存在这里。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181222135506823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZnRmaXN0,size_16,color_FFFFFF,t_70)
*在垃圾回收器回收内存之前，需要一些清理工作。因为垃圾回收器只能回收通过new关键字申请的内存（在堆区），但是堆上的内存并不完全是通过new申请分配的。还有一些本地方法（一般是调用的C方法）。这部分“特殊的内存”如果不手动释放，就会导致内存泄露，而垃圾回收器是无法回收这部分内存的。所以需要在finalize中用本地方法(native method)，如free操作等，再使用gc方法。*
**1、分代分配**
将堆区分为3个区域：
轻生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181222120133305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZnRmaXN0,size_16,color_FFFFFF,t_70)
这三个代里面，`永生代`则对应JVM中的方法区，存放的是类的结构信息，以及运行时常量池之类的东东；而`新生代`和`老年代`分别用于存放不同时期的对象或大小不一的对象。这里面有一系列算法。简而言之，就像人的生命周期一样，新创建的对象放在新生代（比较大也可以直接放到老年代），而新生代又分为伊甸区和两个存活区，对象会在这些区域之间搬来搬去。
经过几轮回收淘汰以后，移到老年代。
**2.分代回收**
新生代：采用停止-复制算法。停止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。
老年代：采用标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。
永久代：不一定需要回收。
