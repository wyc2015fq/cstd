# 用户控件 - 左直拳的马桶_日用桶 - CSDN博客
2006年11月30日 14:33:00[左直拳](https://me.csdn.net/leftfist)阅读数：1515标签：[button																[string																[object																[javascript																[server																[html](https://so.csdn.net/so/search/s.do?q=html&t=blog)](https://so.csdn.net/so/search/s.do?q=server&t=blog)](https://so.csdn.net/so/search/s.do?q=javascript&t=blog)](https://so.csdn.net/so/search/s.do?q=object&t=blog)](https://so.csdn.net/so/search/s.do?q=string&t=blog)](https://so.csdn.net/so/search/s.do?q=button&t=blog)
个人分类：[.NET](https://blog.csdn.net/leftfist/article/category/94497)
用户控件
左直拳
网页页面一些经常用到的，逻辑意义上聚集成一块的HTML标签、控件，甚至包括javascript代码，可以提炼封装成用户控件。
这样做有很多好处：
1、有利于重用
2、封装一些代码，屏蔽一些细节，逻辑清晰，使人能够更专注大方面的问题
3、控件在设计时只须用鼠标拖来拖去，很方便，很爽
4、控件可以应用缓存，使得一些页面能够局部缓存，提高了性能
5、……
编写用户控件很简单，我觉得有两点要注意。
1、控件属性值容易丢失问题。
通常，一个控件都会有属性。如，控件userCtrl有属性Name
private string _Name = “张三”;
public string Name
{
get{ return _Name;}
set{ _Name = value;}
}
由于网页是无状态的，刷新后，如果不在调用页面对userCtrl.Name进行赋值，则Name又重新变回默认值张三了。就是说，用户控件的属性值很容易丢失。当然可以任劳任怨，不厌其烦地在调用页一遍遍地赋值，但终究不是好的办法。
可以将比较重要的属性改用一些系统控件来保存，如HTML的hidden控件。象上面的例子，设置一个
<input type=”hidden” id=”txtName” runat=”server” value=”张三”/>
则上面的属性Name可改为
public string Name
{
get{return txtName.Value;}
set{txtName.Value = value;};
}
这样在页面生存期间，控件的属性Name就不会丢失了。不要用ViewState，因为如果调用页将EnableViewState = false，就不起作用了。
2、在控件里面加入事件功能。
1）、事件的本质是委托。首先，声明一个委托：
publicdelegatevoidClickEventHandler(object sender, EventArgs e);
2）、然后用此委托声明事件：
publiceventClickEventHandler SureClick;
3）、编写事件处理函数
privatevoid OnSureClick(EventArgs e)
{
if (SureClick != null)
{//执行受委托的方法
SureClick(this, e);
}
}
注意if (SureClick != null) 这句，因为SureClick是个委托（也是事件），如果不为空，也就是受到了委托，即调用页面将函数或方法赋给了它。这里这个函数的作用就是去处理调用页面要执行的函数或方法。
4）、在用户控件上加个button
<asp:button id=”Button1” style=”display:none” runat=”server”/>
在控件代码里，有相应的事件：
protectedvoid Button1_Click(object sender, EventArgs e)
{
……
This.OnSureClick(e);//触发事件处理函数
}
5）、在调用页面将待处理的函数或方法赋给SureClick：
<uc2:myCtrlID="MyCtrl1"runat="server"OnSureClick="待处理的函数或方法名"/>
这样子控件就有了事件支持功能。示例中的事件是点击用户控件中那个button，调用页即可得到响应并处理自己要做的事情。
另外，事件参数e的类型可以自己定制。EventArgs是系统给出的类型，如果有需要，也可以换上自己的。比如，可以这样写一个e:
publicclassMyEventArgs : EventArgs
{
privateint _xID = -1;
publicint xID
{
get
{
return _xID;
}
}
public MyEventArgs(int nxID) : base()
{
_xID = nxID;
}
}

