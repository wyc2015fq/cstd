# 注入式开发（二）：.NET 匿名函数 - 左直拳的马桶_日用桶 - CSDN博客
2016年01月08日 19:55:20[左直拳](https://me.csdn.net/leftfist)阅读数：1682
其实匿名函数就是个委托。只不过写起来更简洁。
为啥要用匿名函数呢？只是为了装逼吗？
诺诺诺
比如说，我们写代码，写着写着，发现有2个函数非常相像：
```
string methodA(string data)
{
    相同代码1。。。
    methodA特有部分
    相同代码2。。。
}
string methodB(string data)
{
    相同代码1。。。
    methodB特有部分
    相同代码2。。。
}
```
不行，要重构。如果没有匿名函数，我们应该怎么重构呢？ 
重构方式一，将相同部分分拆出一个个独立的方法
```
void same1(string data){...}
void same2(string data){...}
string methodA(string data)
{
    same1(data);
    methodA特有部分
    same2(data);
}
string methodB(string data)
{
    same1(data);
    methodB特有部分
    same2(data);
}
```
重构方式二，写一个共用方法，然后在该方法里分情况处理原先A和B的特有部分：
```
string same(string data,string methodtype)
{
    相同代码1。。。
    if(methodtype == "A")
        methodA特有部分
    else
        methodB特有部分
    相同代码2。。。
}
string methodA(string data)
{
    return same(data,"A");
}
string methodB(string data)
{
    return same(data,"B");
}
```
重构方式一，多了2个方法；重构方式二，多了一个方法，然后原先的方法还多了一个参数。
下面用匿名函数进行重构
```
delegate string dlgMethod(string data);
string same(string data,dlgMethod dlg)
{
    相同代码1。。。
    //委托dlg处理每个method的特有部分
    dlg(data);
    相同代码2。。。
}
string methodA(string data)
{
    return same(data,(data) =>
    {
        methodA特有部分
    });
}
string methodB(string data)
{
    return same(data,(data) =>
    {
        methodB特有部分
    });
}
```
这种方式，提炼出一个公用方法，然后原先的方法参数不变。更值得一提的是，特有部分在原先每个方法里自行定义，逻辑更加清晰。
我认为，匿名函数比较适合应用在 特殊部分 位于方法的中间位置这种情况，故而很难提炼出一个公用的方法，而不得不提炼出两个。匿名函数本质是一个委托，委托的作用就像一把尖刀插向敌人的胸膛：插进其他对象，插进其他方法。
因此，我将使用委托命名为：注入式开发。
[注入式开发（一）](http://blog.csdn.net/leftfist/article/details/47088657)
