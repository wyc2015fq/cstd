# 设计模式的分类 - 左直拳的马桶_日用桶 - CSDN博客
2017年03月19日 08:28:11[左直拳](https://me.csdn.net/leftfist)阅读数：419
23种设计模式，根据目的分为3类：
```
创建型
结构型
行为型
```
**一、创建型**
关注对象的创建过程。 
**1、抽象工厂**
**2、工厂方法**
**3、建造者**
由指挥者调用具体建造者以得到具体产品。 
这跟策略模式、工厂模式非常相像。策略类是上下文对象决定调用具体策略执行具体任务；工厂模式是调用具体工厂以得到具体产品。
建造者模式：
```java
Builder  builder = new ConcreteBuilder(); //可通过配置文件实现具体建造者
Director director = new  Director(builder);
Product product = director.construct();//得到具体的产品
```
策略模式：
```java
Context context = new Context();  //上下文
AbstractStrategy strategy;  
//采用哪种策略，由上下文决定  
strategy = new ConcreteStrategyA();  
context.setStrategy(strategy);  
context.algorithm();
```
工厂方法模式：
```
IFactory factory;  
//采用哪个工厂，由调用方法决定  
factory = new ConcreteFactoryA();  
IProduct product = factory.Create();
```
但策略模式与建造者模式有什么区别？为何策略模式被划分为行为型？ 
由以上代码可知，策略类得到具体策略后，是执行；而建造者模式是为了得到不同的产品（即对象），所以策略模式是行为型，而建造者模式是创建型。
那建造者模式与工厂模式又区别在哪里？ 
建造者模式将复杂的选择过程（选择建造者或具体工厂）封装起来（即指挥者），因此对客户端而言，代码更简洁，也更能处理复杂的建造选择过程。
**4、原型**
克隆 
**5、单例**
**二、结构型**
关注对象与类的组织。 
**6、适配器**
新增一个类（适配器），让原本两个不能兼容结合的东西通过它可以接合在一起。听上去，这有点象中介者模式和外观模式。它们都是创建了一个原本没有的对象，来结合原本存在的对象。 
适配器模式是两两关系，原本是不能互相发生结合的； 
外观模式是对外提供了一个统一的访问接口，内部的对象不一定有什么相互关系； 
中介者模式是内部对象关系纵横交错，各行其是，为降低复杂度和耦合度，提供一个新对象，大家都通过它来互相访问。
**7、桥接**
处理多维度变化。抽象类处理一个维度，其他维度由其他类实现，然后抽象类关联之。所谓桥接，就是用关联替代继承。桥，就是指关联。
**8、组合**
树
**9、装饰**
装饰模式与桥接模式都是用关联替代继承来扩展功能，但装饰模式用的是依赖注入方式；而桥接模式则是用聚合方式。
**10、外观**
见适配器模式。外观模式对外提供一个统一的访问接口。
**11、享元**
在享元模式中引入了享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。
**12、代理**
访问中间对象来代替直接访问某对象。这很像中介者模式。但中介者模式充当多种对象之间的中介者，而代理模式则是一对一。我感觉中介类只是多个类之间的一种共同接口，而代理类则完全是另一个类的克隆或封装。
**三、行为型**
关注对象之间的交互。 
**13、职责链**
重点在链。一条链，如果本节点处理不了，则传递给下一个节点处理。由本节点决定传给哪一个节点。
**14、命令**
请求发送者（调用者）与请求接收者之间，隔着一个命令。在调用者和接收者之间增加一个命令模式，就是不想让调用者和接收者之间直接发生关系，就是解耦：将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。
这种空降一个类，隔开两方，以利于解耦的模式，有命令模式、中介者模式、适配器模式、外观模式、代理模式。
**15、解释器**
语法机
**16、迭代器**
foreach
**17、中介者**
中介者模式充当多种对象之间的中介者。降低对象之间的耦合度，乃至降低了整个系统的复杂度
**18、备忘录**
游戏存档。包括三部分，存档操作对象（原发器），存档本身，存档存储对象（负责人）。
**19、观察者**
被观察者发生变化的时候，观察者也随之起舞。原理是被观察者有一份观察者名单，可以逐一通知。
**20、状态**
从一个类中，将有关状态的处理分离出来，独立成类，并面向接口编程。作用是可以简化代码，避免过多的条件判断。
**21、策略**
采用哪种策略，由上下文决定 。与工厂、建造者类似。策略模式强调的是选用策略后进行工作，工厂和建造者是返回具体的可工作对象。
**22、模板方法**
可能是最简单的设计模式。就是面向对象中的继承。公用部分放在父类，子类继承父类，然后扩展。呵呵。
**23、访问者**
有访问者和被访问者（元素）两部分。被访问者通常比较恒定，是一个大而全的列表；而访问者则千变万化，他们都来操作这个共同的列表，各取所需。一个栗子就是到医院看病，医生开处方，收费窗口对处方计价收费，药房按处方发药，护理室按处方进行护理。医生、收费窗口、药房、护理室都是访问者，而处方则是被访问者。
访问者模式适合元素比较恒定的情况，而访问者则可以很灵活地增减变动，很好地符合开闭原则。
如果联系到代码的例子，我想到的就是枚举。定义一个枚举，然后按需使用。呵呵，太简单了吧。如果是大的方面讲，就是我们常用的数据查询程序。数据（被访问者，元素）就是这么些，然后程序（访问者）如何查询，如何呈现随你便。
以上总结，我觉得还可以提取出三类： 
一、泛策略类 
工厂、策略、建造者
二、泛中介者 
中介者、适配器、代理、外观、命令
三、泛桥接 
桥接、装饰
