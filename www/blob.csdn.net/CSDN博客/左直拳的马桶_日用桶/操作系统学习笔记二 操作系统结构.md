# 操作系统学习笔记二 操作系统结构 - 左直拳的马桶_日用桶 - CSDN博客
2014年12月23日 20:17:17[左直拳](https://me.csdn.net/leftfist)阅读数：1332
**POSIX**
Portable Operating System Interface 可移植操作系统接口。X表明其对Unix API的传承。Linux逐步地基本实现了这一接口；WINDOWS NT部分地实现。
**系统调用**
用户应用程序调用系统调用接口的API（应用程序接口），系统调用接口截获这个请求，并调用操作系统中相应的系统调用。对于用户应用程序来说，不需要知道这里面的细节，只关心操作结果。
**文件**
文件是一个逻辑概念，属于虚拟设备。想想也是哈
**操作系统开发语言**
Linux、Windows XP主要用C编写，少数设备驱动、寄存器操作用汇编，而不是完全使用汇编。
理由：
1）开发速度快，代码更紧凑，并易于理解和调试
2）应用最新的编译技术，重新编译，可以立刻改进既有的产品
3）更易于移植
4）与汇编相比，可能执行速度会慢一点，增加了存储要求，但在今天，这些都不是问题。并且现代编译技术可以生成优良的代码，在处理复杂性方面，比汇编高手人工写出来的东西效果更佳
5）性能的关键在于数据结构和算法，而不是执行速度更快的汇编代码
6）用高级语言编写出可运行的操作系统以后，可以找出高性能最关键的部分，再用汇编改写
**操作系统结构**
1）简单结构
没有明确、仔细的定义结构和功能划分，不良后果就是系统容易崩溃，或者难以扩展和增强。比如MS-DOS和早期的Unix。
一方面，是因为这些操作系统最初比较简单，功能有限，后来慢慢扩充，功能越来越多，超出了原有的范围；另一方面，也受限于当时的硬件水平。
2）分层
将操作系统分成若干层，最底层为硬件，最高层为用户接口。每层只能利用较低层的功能和服务。
优点在于易于构造和调试；
难点在于如何分层，如何对每一层进行定义，还有层的顺序。
缺点是命令层层传递，效率稍差。
3）微内核
将所有非基本部分从内核中移走，并将它们实现为系统程序或用户程序，这样得到了一个更小的内核。通常，一个微内核包括最小的进程和内存管理、通信功能。
微内核的主要功能是为客户程序、服务程序之间提供通信。客户程序与服务程序不直接交互，通过微内核进行消息传递。天哪，这不就是中介者模式吗？
优点是便于扩充。想增加什么，增加服务程序就可以了，无须更改内核。即使要改内核，改动也不大，因为它很小。另外，服务程序之间区隔得很好，一个有问题，不会影响其他。
缺点是系统功能开销增加（依赖微内核进行通信？），性能有所下降。
4）模块
并不将非基本部分抽走，而是对整个内核进行模块划分，变成一种类似太阳系模式：几个可加载的内核模块围绕着一个核心内核。
注意可加载三个字，意味著可以动态管理；这个管理由核心内核负责。
同时模块间可以互相调用，无须通过核心内核模块进行通信。
**虚拟机**
单个计算机的硬件抽象为不同的执行部件，使得每个独立的执行环境仿佛在自己的计算机上运行一样。
虚拟机有着与硬件相同的接口，除此二外，并没有提供额外的功能。
虚拟机实现有一定难度。因为宿主操作系统有两种模式：用户模式和内核模式，而虚拟机也必须有这两种模式，称为虚拟用户模式和虚拟内核模式。在宿主操作系统上引起从用户模式到内核模式的转换，那么在虚拟机上也要有相应的转换。
虚拟机软件（提供虚拟机服务的软件）本身运行在宿主操作系统的内核模式，而虚拟机运行在用户模式。
相应的实例有
vmWare
java的JVM
.NET的CLR
其中CLR是一种机制，先将.NET源代码编译成中间语言，运行时再结合具体机器编译成本地代码。我觉得这不是一般意义上的虚拟机，因为并没有那种像是运行在自己机器上的幻觉，而是真的运行在自己机器上，只不过运行前在本地编译了而已。
JVM也有类似的一种机制，可以编译成JIT。但JVM也可以是一般意义上的那种虚拟机。
**系统启动**
开机以后，如何装入操作系统？机器怎么知道操作系统的入口在哪里？
绝大多数计算机系统都有一小块代码，称为引导程序，可以定位操作系统内核，将它装入内存，从而开始执行。
如PC，一个简单的引导程序（应该是放在BIOS里）从磁盘上调入一个较复杂的引导程序，再由这个复杂引导程序装入操作系统内核。
引导程序需要完成一系列工作。通常，要先自检，自检硬件吧，自检通过，再能往下执行。系统所有部分都初始化，从CPU寄存器到设备控制器，以及内存。最后，操作系统得以启动。
