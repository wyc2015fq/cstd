# 拆分分区文件组 - 左直拳的马桶_日用桶 - CSDN博客
2013年02月25日 17:07:36[左直拳](https://me.csdn.net/leftfist)阅读数：1912
有些保存分区的文件组太大了，最好拆分一下。
1、首先，要找出该文件组对应的分区号，目的是根据分区号，决定需要设置的新边界值。
2、添加新文件组和文件
3、将新文件组设置为NEXT USED
4、修改分区函数，拆分分区
详细步骤：
1、找出分区号
```
USE [db]
GO
--待分拆文件组
select fg.name
		,sp.destination_id
    from sys.destination_data_spaces sp
    inner join sys.partition_schemes scm on sp.partition_scheme_id = scm.data_space_id
    inner join sys.filegroups fg on fg.data_space_id = sp.data_space_id
    where scm.name='分区方案' 
    and fg.name='文件组逻辑名称';
```
2、设置新边界值
比如找到的分区号为6，对应在分区函数中（假设该分区函数是RANGE LEFT FOR VALUES ），新的边界值，应该落在第5和第6个边界值之间，形成新的第6个边界值。
通常一个分区函数对应的边界值比较多，如果靠数数，万一分区号是几十、甚至上百，怎么数得过来。可以用以下语句进行查找：
```
SELECT Min(分区依据列),MAX(分区依据列) FROM [表名]
WHERE $partition.分区函数(分区依据列) = 分区号
```
但通常表里的记录经过各种查删改操作，已经变得参差不齐，上述语句不一定能得到准备数字，还可以用以下代码：
```
DECLARE @offset INT = 10000;--步长，视具体情况而定
DECLARE @limit INT = 最大边界值;
DECLARE @partitionId INT = 分区号;
DECLARE @min INT = 0,@max INT = 0;
DECLARE @i INT = 0;
WHILE @i < = @limit
BEGIN
    IF $partition.分区函数(@i) = @partitionId AND @min=0 SET @min=@i;
    IF $partition.分区函数(@i) = @partitionId SET @max=@i;
    SET @i = @i + @offset;
END
SELECT @min,@max;
```
3、添加新文件组和文件
```
--文件组
ALTER DATABASE [数据库名] ADD FILEGROUP [新文件组名]
GO
-- 文件
ALTER DATABASE [数据库名]
ADD FILE
(NAME = N'新文件名',FILENAME = N'文件完全路径',SIZE = 3MB,FILEGROWTH = 1MB)
TO FILEGROUP [新文件组名]
GO
```
注意，分区函数如果对应多个分区方案，那么一般应该相应添加多个文件组和文件
4、修改分区方案，将新文件组设置为NEXT USED
```
ALTER PARTITION SCHEME [分区方案名]
	NEXT USED [新文件组名];
GO
```
同样，分区函数如果对应多个分区方案，那么每个分区方案都应该设置
5、修改分区函数
```
ALTER PARTITION FUNCTION 分区函数()
	SPLIT RANGE (新边界值);
```
以上运行完毕，可以重新打开分区函数和分区方案看看。对于 RANGE LEFT FOR VALUES 的分区函数，新文件组会用于保存新边界值左侧的数据，而右侧的数据则由原文件组保存。
