# 哎呀哎呀哎呀~，我爱上了事件 - 左直拳的马桶_日用桶 - CSDN博客
2008年06月10日 15:27:00[左直拳](https://me.csdn.net/leftfist)阅读数：1497
哎呀哎呀哎呀~，我爱上了事件
左直拳
事件对我来说很神秘，不容易理解和掌握。
可是慢慢的用了几次后，认为很好用。我发觉我已经喜欢上它了。
让我们立即开始这段感情吧。
一、为什么要用事件？
第一个反应当然是想获得一个通知。就是说，我希望某个东西执行到某个步骤，就通知我，我好做点什么事情；最初VC里的事件给我的印象就是这样子的。当然C#里也有这样的功能。
第二个，预留一个空间让调用方来执行自己的东西。我目前做得最多的就是在写用户控件的时候，提供事件来让调用这些控件的程序在事件激发时处理自己特定的代码，这些代码是怎么样的，对控件本身来说完全不知情。
二、如何使用事件？
（一）ASP.NET应用
结合写控件来说明。
在用户控件里：
1、先声明一个委托
publicdelegatevoidClickEventHandler(object sender, EventArgs e);
在C#里，事件本质是一个委托。委托的作用是可以将函数或方法当作参数来使用。
2、再用这个委托声明一个事件E
publiceventClickEventHandler MyClick;
3、然后在控件本身的事件中（例如某个按扭被点击）检查事件E是否有被引用，有就执行
protectedvoid btnTest_Click(object sender, EventArgs e)
{
……
if (MyClick != null) MyClick(this, e);
}
这个执行，就是触发调用方的代码。
4、在调用方
页面代码：
<uc4:myCtrlID="MyCtrl1"runat="server"OnMyClick="MyCtrl1_MyClick"/>
注意这里是OnMyClick，多了一个”On”。
服务器代码：
protectedvoid MyCtrl1_MyClick(object sender, EventArgs e)
{
//HELLO WORLD！
}
（二）WINFORM等常规程序应用
我搞了个东西使用了多线程，现在想所有的线程都执行完了以后，返回一个消息，好作些抹屁股的工作。
用事件。
publicclassPThreadInvoke
{
public PThreadInvoke()
{
……
//加入事件
CThreadDo.ThreadFinished += newCThreadDo.FinishEventHandler(CThreadDo_ThreadFinished);
}
//调用该事件的函数 
void CThreadDo_ThreadFinished()
{
//HELLO WORLD
}
//类中类
classCThreadDo
{
publicdelegatevoidFinishEventHandler();
publicstaticeventFinishEventHandler ThreadFinished;
//所有线程执行完
publicvoid ThreadIsOver()
{
……
//触发事件
if ( ThreadFinished != null)
{
ThreadFinished();
}
}
经过测试，事件跟全局静态变量差不多，比如说，就本例子来讲，这个线程不管是用户手工激发，还是用定时器每隔一段时间激发，都能收到ThreadFinish事件。比方说，这个程序一直在后台运行，定时器激发了线程；然后用户打开了界面，很显然，用户使用的实例PThreadInvoke和定时器使用的PThreadInvoke并非同一个，可是定时器开辟的线程完成之后，触发的ThreadFinished事件，在用户使用的实例PThreadInvoke里同样能收到。只要if ( ThreadFinished != null)都可以。
总结：
事件本质是一个委托。由调用方引用（+=），由被调用方触发。
好多东西我都没搞懂，写出来也不知道对不对。谨作总结备忘。
