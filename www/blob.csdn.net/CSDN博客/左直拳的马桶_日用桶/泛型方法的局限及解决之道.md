# 泛型方法的局限及解决之道 - 左直拳的马桶_日用桶 - CSDN博客
2015年11月11日 18:17:07[左直拳](https://me.csdn.net/leftfist)阅读数：2187标签：[泛型																[反射](https://so.csdn.net/so/search/s.do?q=反射&t=blog)](https://so.csdn.net/so/search/s.do?q=泛型&t=blog)
个人分类：[.NET](https://blog.csdn.net/leftfist/article/category/94497)
泛型的优点在于提高了函数的适应性，有利于代码复用。但是，一个支持泛型的方法里面，代表该参数类型未可知，如果要直接使用它的属性，是不行的。因此，这点是泛型的局限，使得这个泛型参数，乃至整个方法，便利性都打了折扣。
由此可知，在支持泛型的方法里面，泛型对象作为参数，主要作用在不同的方法间传来传去，像踢皮球似的。仅此而已。
难道真的不能访问泛型对象的属性吗？
“可以用反射”，西蒙说。
```
//propertyName,待访问的属性名
string getProperty<T>(IList<T> listDB, string propertyName)
        {
            string val = "";
            if (listDB.Count == 0) return val;
            //通过反射获得泛型对象的属性数组
            PropertyInfo[] propertys = listDB[0].GetType().GetProperties();
            int p = 0;
            foreach (PropertyInfo pi in propertys)
            {
                if (pi.Name.Equals(propertyName, comparisonType: StringComparison.CurrentCultureIgnoreCase))
                {//找到propertyName在T属性数组中的下标p
                    break;
                }
                p++;
            }
            if (p == propertys.Length)
            {
                throw new Exception("对象没有相应的属性：" + propertyName);
            }
            foreach (var m in listDB)
            {
                //如此，可访问T的属性矣
                val += propertys[p].GetValue(m).ToString() + ",";
                ...
            }
            return val;
        }
```
泛型赋值：
```
public static T getEmptyReportModel<T>(Report rept) where T : class, new()
{
    var model = new T();
    Type t = typeof(T);
    t.GetProperty("ID").SetValue(model, 1, null);
    t.GetProperty("REPORTID").SetValue(model, rept.ID, null);
    if (t.GetProperty("LOCATION")!=null)
    {
        t.GetProperty("LOCATION").SetValue(model, Convert.ToInt32(rept.NODEID), null);
    }
    t.GetProperty("NOTE").SetValue(model, "无数据更新", null);
    return model;
}
```
猴赛雷。
