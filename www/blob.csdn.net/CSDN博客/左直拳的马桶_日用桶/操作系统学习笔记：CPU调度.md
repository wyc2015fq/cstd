# 操作系统学习笔记：CPU调度 - 左直拳的马桶_日用桶 - CSDN博客
2015年03月19日 00:24:41[左直拳](https://me.csdn.net/leftfist)阅读数：1950
个人分类：[学习笔记																[计算机基础](https://blog.csdn.net/leftfist/article/category/2622721)](https://blog.csdn.net/leftfist/article/category/1790155)
CPU调度的目的在于提高CPU利用率，不让CPU闲着。CPU是宝贵的资源，如果有一个进程，本来在CPU中运行，忽然因为要使用IO资源，于是转而请求IO，这边CPU挂起，造成就绪队列中的其他进程等待，这样就造成了浪费。
一、CPU调度算法
1、先到先服务（FCFS）
谁先请求CPU谁先得到服务，一直到服务完。这应该是最简单的调度了。但效率不高，有些只须很短CPU区间的进程也只能死等，会造成平均等待时间较长。
2、最短作业优先（SJF）
最佳调度算法，平均等待时间最小。问题在于，如何知道下一个CPU区间的长度，或者说，如何知道进程要消耗多少CPU时间？
可以通过一定的算法来预测这个长度。
3、优先级
进程被赋予优先级。优先级高的先获得CPU。
优先级调度可以是抢占式也可以是非抢占式。、
抢占式：优先级高的进程到达就绪队列时，假如正在运行的进程优先级比它低，立刻抢占CPU；
非抢占式：优先级高的进程到达就绪队列时，排在就绪队列头部
缺点是会产生无穷堵塞或饥饿，造成有些低优先级进程无线等待。
解决饥饿问题，是老化。即等待时间越长的进程，其优先级会递增。
4、轮转法（RR）
限定CPU时间片，就绪队列中的进程轮流执行，每个进程执行完毕即退出，否则重新排队。如果时间片足够长，就等于FCFS。
轮转法专为分时系统而设计。
5、多级队列
设置多条、优先级不同的就绪队列，进程散落其中。一旦归入某条队列，不可以转移到别的队列。优先级高的队列先执行，直至为空，才到次优先级的队列。一旦高优先级队列又有新进程进入，马上抢占CPU。
同样，存在饥饿问题。
6、多级反馈队列
同多级队列，但允许进程迁移。假如某个进程消耗CPU时间片次数多，即沉入低优先级队列。可以防止饥饿。
二、多处理器调度
1、非对称多处理和对称多处理
非对称多处理：一个CPU负责调度、IO处理及其他系统活动，而其他CPU只执行用户代码。好处是只有一个CPU访问系统数据，减轻了数据共享的需要。
对称处理（SMP）：每个CPU都可以调度，甚至有私有的就绪队列。算法比较复杂。现代操作系统都支持SMP。
2、处理器亲和性
努力让一个进程只在同一个处理器上运行，就叫处理器亲和性。
主要是因为进程迁移到其他处理器，缓存需要重新构建。所以这是OS极力避免的情况。
亲和性有软硬之分。如果只是努力，而不能保证，则软也；如果硬性规定，则为硬也，如Linux。
3、负载均衡
如何尽快将众多嗷嗷待运的进程放入CPU中运行，以完全利用多CPU的优点，就涉及到负载均衡。
通常有2种方法：
1）推
一个特定任务周期性地检查各个CPU，发现不平衡即进行适当调配
2）拉
CPU空闲时，即主动从其他地方拉一个进程过来运行，。
负载均衡与处理器亲和性是矛盾的。如何取得平衡，有个度的考量。
4、对称多线程（SMT)
多物理CPU同时运行多线程，是为对称多处理器（SMP）；提供多个逻辑CPU，来同时运行多线程，即为对称多线程（SMT，英特尔处理器中称为超线程）。
SMT的思想是同一个物理CPU上生成多个逻辑CPU。
SMT是硬件提供的，而不是软件。
5、线程调度
OS调度的是内核线程。一个用户线程要得到CPU运行，有2个步骤要走：
1）用户线程与内核线程挂钩
2）内核线程获得CPU
用户线程与内核线程的对应关系有一对一，多对一，多对多等关系。在后二者模型中，线程库调度用户线程到一个LWP（轻量级进程）。
但这并不意味着用户线程可以执行。当线程所在进程获得CPU时，进程内的线程还要经过争用，获得CPU。
获得LWP，叫进程竞争范围（PCS）；
获得CPU，叫系统竞争范围（SCS)。
所有的用户线程与内核线程对应的模型中，都需要SCS。一对一模型中，只有SCS。
