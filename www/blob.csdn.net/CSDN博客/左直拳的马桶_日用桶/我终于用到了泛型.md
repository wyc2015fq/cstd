# 我终于用到了泛型 - 左直拳的马桶_日用桶 - CSDN博客
2007年04月30日 16:57:00[左直拳](https://me.csdn.net/leftfist)阅读数：1426
我终于用到了泛型
左直拳
泛型是。NET2。0出现的新东西。惭愧，3。0已经出了很久了，可我现在才开始用。落后啊落后，简直屎一堆。
delegatevoidSetEnableCallback(System.Windows.Forms.Control objCtrl, bool enable);
//声明
privatevoid _SetText<TObject>(TObject objCtrl, string text) 
where TObject : System.Windows.Forms.Control
{
if (objCtrl.InvokeRequired)
{
SetTextCallback d = newSetTextCallback(_SetText);
this.Invoke(d, newobject[] { objCtrl, text });
}
else
{
objCtrl.Text = text;
}
}
//调用
publicint TotalNum
{
set { _SetText<TextBox>(this.txt_Total, value.ToString()); }
}
在声明里面，之所以要限定TObject的类型为窗体控件
where TObject : System.Windows.Forms.Control
是因为不如此，就无法使用象objCtrl.InvokeRequired这些只有窗体控件才会用到的语句。
本来我象是限定为TextBox，Button类型的，语句如下：
privatevoid _SetText<TObject>(TObject objCtrl, string text) 
where TObject : TextBox,Button
但这样始终编译不过去，说是一山不容二虎，类类型只能排在前面，将TextBox排在前面，说Button错；将Button排在前面，说TextBox错。真不知道为什么会有这样的规定。最后只好将它们限定为父类型：Control。
泛型的好处是可以写出适应性极好的代码。据说效率很高，没有类型转换、装箱拆箱带来的性能损失。
大江东去，浪淘尽，
千古风流人物。
故垒西边，人道是，
三国周郎赤壁。
乱石穿空，惊涛拍岸，
卷起千堆屎。
