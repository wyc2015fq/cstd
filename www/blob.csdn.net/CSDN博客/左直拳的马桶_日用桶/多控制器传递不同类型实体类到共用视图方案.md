# 多控制器传递不同类型实体类到共用视图方案 - 左直拳的马桶_日用桶 - CSDN博客
2015年02月14日 17:25:47[左直拳](https://me.csdn.net/leftfist)阅读数：2104
asp.net MVC中，现有多个控制器需要共用同一个视图，并且要传自己的实体类供视图操作。问题是，这些实体类的类型并不相同，里面的属性有部分出入。那么在共用视图的情况下，视图要如何处理这些实体类呢？
我们知道，不管是通过View("视图名",实体类)，还是通过ViewBag传递，在视图中，都需要转换回原先的类型，才能进行使用。现在传递过来的实体类类型不同，那么转换的话，就让人为难了。
当然，通过传递一个额外的类型参数，在视图中加以判断，分别转换，这样是可以的，但总觉有点笨。
有一种方案是：在控制器中，将实体类全部转换为JObject，然后在视图中，统一操作JObject对象。
没代码没J8：
controller：
```
using Newtonsoft.Json.Linq;
public ActionResult ControllerA(int id)
{
    EntityA objA = ... //获取实体类A对象
    return View("PublicView", JObject.FromObject(objA));
}
public ActionResult ControllerB(int id)
{
    EntityB objB = ... //获取实体类B对象
    return View("PublicView", JObject.FromObject(objB));
}
```
view：
```
@model Newtonsoft.Json.Linq.JObject
@using Newtonsoft.Json.Linq;
@{
    Layout = null;
    int id = Model.Value<int>("ID");
    string owner = Model.Value<string>("Owner");
    string createTime = Model.Value<DateTime?>("CreateTime").ToString() ?? "";
}
```
这种方案，除了MVC框架，还适合方法内容雷同，但返回值类型不同的接口编程。
