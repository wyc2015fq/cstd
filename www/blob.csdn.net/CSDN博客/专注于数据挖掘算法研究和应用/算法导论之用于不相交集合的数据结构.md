# 算法导论之用于不相交集合的数据结构 - 专注于数据挖掘算法研究和应用 - CSDN博客





2016年08月12日 10:15:56[fjssharpsword](https://me.csdn.net/fjssharpsword)阅读数：2658
所属专栏：[算法导论专栏](https://blog.csdn.net/column/details/16283.html)









不相交集合，即集合内元素无交集。在一些具体应用中，需将n个不同的元素分成一组不相交的集合。不相交集合的两个重要操作，找出给定元素所属的集合和合并两个集合。为支持不相交集合的操作，需要设计和维护数据结构来满足。导论中给出了链表和有根树两类数据结构来支持不相交集合的操作。

1、不相交集合的基本定义

不相交集合数据结构保持一组不相交的动态集合S={S1, S2,…, Sk}。每个集合通过一个代表来识别，代表即集合中的某个成员。选择代表成员视乎具体应用，如选择最小元素。

集合中的每一个元素是由一个对象表示的。设x表示一个对象，支持以下操作：

1）Make-set(x)：建立一个新的集合，其唯一成员就是x。各集合是不相交的，所以x没有在其他集合中出现过；

2）Union(x,y)：将包含x和y的动态集合（Sx和Sy）合并成一个新的集合（并集SxUSy），当然Sx和Sy是不相交的。

3）Find-set(x)：返回一个指针，指向包含x的唯一集合的代表。

分析不相交集合数据结构运行时间，主要考察两个参数：

1）Make-set操作的次数n；

2）执行Make-set、Union、Find-set操作的总次数m，其中Union操作至多为n-1，因包含Make-set操作，所以m>=n。

2、不相交集合的一个应用

不相交集合数据结构的应用之一：用于确定一个无向图中连通子图的个数。算法上，首先将每个定点v置于各自的集合中，即执行Make-set操作；接着，对每一条边（u,v）进行合并，即Union操作，当然包含u和v的集合是不相交的，对每条边处理后，两个顶点在同一连通子图中的，其对应对象也在同一个集合中；最后，通过Find-set操作好处顶点是否在同一连通子图中。

3、不相交集合链表数据结构

每一个集合用一个链表表示，链表作为不相交集合的数据结构，其每一个对象都包含一个集合成员、一个指向包含下一个集合成员的对象的指针、指向代表的指针；而每个链表都包含head指针和tail指针，head指向链表的代表，tail指向链表中最后的对象。链表中对象以任何次序出现，确保第一个对象就是所在集合的代表即可。

用链表实现不相交集合数据结构，Make-set和Find-set操作都只需O(1)时间。按照上面定义的n和m参数，执行Union操作（作用于n个对象上，包含m个操作序列）的运行时间是![](https://img-blog.csdn.net/20160812101224558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)，一个操作的平摊时间是![](https://img-blog.csdn.net/20160812101250164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)。

我对导论中的链表设计有点疑问，为什么每个对象指向代表的指针，不改为指向下一个对象的指针呢？这样在合并操作时，只要更改一个链表头尾指针，链表中每个对象不用更新。是否有其他因素考虑，比如别的操作性能更好，但暂时没理解到。

对于Union合并操作，还给出一种加权合并启发式策略，就是把较短的表拼接到较长的表。因为Union操作时，要拼接的链表，每个对象都要更新其指向代表对象的指针，这更新就和链表的长度成线性关系，所以短的链表去拼接，时间有优势。应用加权启发式策略，m个操作序列只需要O(m+nlgn)时间。

问题是：如何识别出较短长度的链表？

4、不相交集合有根树数据结构

用有根树表示集合，树中的每个结点都包含集合的一个成员，每棵树表示一个集合，群树构成森林。每棵树的根就是链表的代表，并且指向自己作为父结点。Make-set创建一个颗仅包含一个结点的树。Find-set是沿着父结点指针一直找下去，直至找到树根为止，查找路径上访问过的所有结点构成了查找路径（find path），这里不明白的是，如果有分叉，顺着父结点查找如何找到呢？Union操作使一颗树的根指向另一个树的根。

通过两种启发式策略来改进运行时间：

1）按秩合并：和链表中的加权合并思路一致，将较少结点的树的根指向包含较多结点的树的根。具有较小秩的根在Union操作中药指向具有较大秩的根。

2）路径压缩：在Find-set操作中，使查找路径上的每个结点都指向根节点。这个好理解，就是n个元素的集合，1个根，其他n-1个都是子女，互相构成兄弟，只有2层深度树。

当同时使用按秩合并和路径压缩时，最坏情况运行时间为![](https://img-blog.csdn.net/20160812101331119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)，其中是![](https://img-blog.csdn.net/20160812101446324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)一个增长极其缓慢的函数，在任意可想象的不相交集合数据结构应用中![](https://img-blog.csdn.net/20160812101549153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)。

对作用于n个元素上的m个不相交集合操作，联合使用按秩合并和路径压缩启发式的运行时间是![](https://img-blog.csdn.net/20160812101348464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)界。导论中证明了![](https://img-blog.csdn.net/20160812101510340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)是增长极其缓慢的函数。

证明![](https://img-blog.csdn.net/20160812101413729?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)的界是用平摊分析中的势方法，证明![](https://img-blog.csdn.net/20160812101525090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)是增长极快函数的逆函数。有趣的是这个增长尽快的函数。计算机算法基础，之所以离不开数学，就在于任何算法的合理性（时间界运行性能）都需要数学的证明，当然设计算法（或说是模型）也需要数学基础，否则就是无根之萍。

每种算法，每种数据结构，都尤其特定应用场合，所以在实际应用中，改良甚至创新都是必要的，但都要基于扎实的数学理论基础。一种算法、一种数据结构，可以说是一种模型，是一种在应用中归纳升华出来的一种理论，可以应用于同类场合。当然关乎到数学基本问题，比如集合论对计算机理论的支持。
            


