# 机器学习笔记(十五)规则学习 - 专注于数据挖掘算法研究和应用 - CSDN博客





2017年05月24日 11:40:52[fjssharpsword](https://me.csdn.net/fjssharpsword)阅读数：10609
所属专栏：[机器学习专栏](https://blog.csdn.net/column/details/16315.html)











## 15.规则学习

### 15.1基本概念

机器学习中的规则（rule）通常是指语义明确、能描述数据分布所隐含的客观规律或领域概念、可写成若…则…形式的逻辑规则。规则学习（rulelearning）是从训练数据中学习出一组能用于对未见示例进行判别的规则。

![](https://img-blog.csdn.net/20170524113421900?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




显然，规则集合中的每天规则都可看作一个子模型，规则集合是这些子模型的一个集成。当同一个示例被判别结果不同的多条规则覆盖时，称发生了冲突（conflict），解决冲突的办法称为冲突消解（conflict resolution）。常用的冲突消解策略有投票法、排序法、元规则法等。投票法是将判别相同的规则数最多的结果作为最终结果。排序法是在规则结合上定义一个顺序，在发生冲突时使用排序最前的规则；相应的规则学习过程称为带序规则（ordered rule）学习或优先级规则（priority rule）学习。元规则法是根据领域知识事先设定一些元规则（meta-rule），即关于规则的规则，例如发生冲突时使用长度最小的规则，然后根据元规则的指导来使用规则集。

此外，从训练集学得的规则集合也许不能覆盖所有可能的未见示例；对此，规则学习算法通常惠设置一条默认规则（default rule），由它来处理规则集合未覆盖的样本。

从形式语言表达能力而言，规则可分类两类：

1）命题规则（propositionalrule）

由原子命题（propositionalatom）和逻辑连接词（与、或、非、蕴含）构成的简单陈述句。

2）一阶规则（first-orderrule）

基本成分是能描述事物的属性或关系的原子公式（atomic formula）。如表达父子关系的谓词（predicate）父亲(X,Y)就是原子公式；再比如加一操作add(x)=x+1。

一阶规则能表达复杂的关系，因此也被称为关系型规则（relational rule）。

以西瓜集为例，简单地把属性当作谓词来定义示例与属性值之间的关系，则命题规则集R可改写为一阶规则集R*：

![](https://img-blog.csdn.net/20170524113511187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




显然，从形式语言系统的角度来看，命题规则是一阶规则的特例。因此一阶规则的学习比命题规则要复杂得多。



### 15.2序贯覆盖

规则学习的目标是产生一个能覆盖尽可能多的样例的规则集。最直接的做法是序贯覆盖（sequential covering），即逐条归纳：在训练集上每学到一条规则，就将该规则覆盖的训练样例去除，然后以剩下的训练样例组成训练集重复上述过程。由于每次只处理一部分数据，因此也称为分治（separate-and-conquer）策略。

以命题规则学习为例来考察序贯覆盖法。命题规则的规则体是对样例属性值进行评估的布尔函数，如色泽=青绿、汉唐率≤0.2等，规则头是样例类别。序贯覆盖法的关键是如何从训练集学出单条规则。

![](https://img-blog.csdn.net/20170524113614276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




这种基于穷尽搜索的做法在属性和候选值较多时会由于组合爆炸而不可行。现实任务中一般有两种策略来产生规则：

1）自顶向下（top-down），即从比较一般的规则开始，逐渐增加新文字以缩小规则覆盖范围，直到满足预定条件为止，也称为生成-测试（generate-then-test）法，是规则逐渐特化（specialization）的过程，是从一般到特殊的过程；

2）自底向上（bottom-up），即从比较特殊的规则开始，逐渐删除文字以扩大覆盖范围，直到满足条件为止；也称为数据驱动（data-driven）法，是规则逐渐泛化（generalization）的过程，是从特殊到一般的过程。

自顶向下是覆盖范围从大到小搜索规则，自底向上则正好相反；前者更容易产生泛化性能较好的规则，而后者更适合于训练样本较少的情形；另外，前者对噪声的鲁棒性比后者要强；因此，在命题规则学习中通常使用前者，而后者则在一阶规则学习这类假设空间非常复杂的任务使用较多。

以命题规则学习为例，对于自顶向下的规则生成方法，文中给出了西瓜集例子。例子中规则生成过程设计一个评估规则优劣的标准，例子中给出的标准是：先考虑规则准确率，准确率同时考虑覆盖样例数，再相同时考虑属性次序。现实应用中可根据具体任务情况设计适当的标准。例子中每次仅考虑一个最优文字，过于贪心，容易陷入局部最优，为缓解这个问题，采用集束搜索（beam search），即每轮保留最优的b个逻辑文字，在下一轮均用于构建候选集，再把候选集中最优的b个留待下一轮使用。

序贯覆盖法简单有效，几乎所有规则学习算法都以其为基本框架，也能方便地推广到多分类问题上，只需将每类分别处理即可：当学习关于第c类的规则时，将所有属于类别c的样本作为正例，其他类别的样本作为反例。



### 15.3剪枝优化

规则生成本质上是一个贪心搜索过程，需要一定的机制来缓解过拟合的风险，最常见的做法是剪枝（pruning）。与决策树相似，剪枝可发生在规则生长过程中，即预剪枝；也可发生在规则产生后，即后剪枝。通常是基于某种性能度量指标来评估增/删逻辑文字前后的规则性能，或增/删规则前后的规则集性能，从而判断是否要进行剪枝。

![](https://img-blog.csdn.net/20170524113725831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20170524113815864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




RIPPER中的后处理机制是为了在剪枝的基础上进一步提升性能，对R中的每条规则ri，RIPPER为它产生两个变体：

第一：r*i：基于ri覆盖的样例，用IREP*重新生成一条规则r*i，该规则称为替换规则（replacement rule）；

第二：r**i：基于ri增加文字进行特化，然后再用IREP*剪枝生成一条规则r**i，该规则称为修订规则（revised rule）。

接下来，把r*i和r**i分别于R中除ri之外的规则放在一起，组成规则集R*和R**，将它们与R一起进行比较，选择最优的规则集保留下来。

RIPREP更有效的原因是：最初生成R时，规则是按序生成的，每条规则都没有对其后产生的规则加以考虑，这样的贪心算法本质常导致算法陷入局部最优；而RIPPER的后处理优化过程将R中的所有规则放在一起重新加以优化，恰是通过全局的考虑来缓解贪心算法的局部性，从而往往能获得更好的效果。



### 15.4一阶规则学习

受限于命题逻辑表达能力，命题规则学习难以处理对象之间的关系（relation），而关系信息再很多任务中是很重要的，要用一阶逻辑表示，使用一阶规则学习。

描述了样例间关系的数据称为关系数据（relational data），有原样本属性转化而来的原子公式称为背景知识（backgroundknowledge），而由样本类别转化而来的原子公式称为关系数据样例（examples）。如从西瓜集学出的一阶规则：

![](https://img-blog.csdn.net/20170524113926116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




若允许将目标谓词作为候选文字加入规则体，则FOIL能学出递归规则；若允许将否定形式的文字作为候选，则往往能得到更简洁的规则集。

FOIL可大致看作是命题规则学习与归纳逻辑程序设计之间的过度，其自顶向下的规则生成过程不能支持函数和逻辑表达式嵌套，因此规则表达能力仍有不足；但它是把命题规则学习过程通过变量替换等操作直接转化为一阶规则学习，因此比一般归纳逻辑程序设计技术更高效。



### 15.5归纳逻辑程序设计

归纳逻辑程序设计（Inductive Logic Programming，ILP）在一阶规则学习中引入了函数和逻辑表达式嵌套。这使得，一方面机器学习系统具备了更为强大的表达能力；另一方面ILP可看作用机器学习技术来解决基于背景知识的逻辑程序（logic program）贵南，其学得的规则可被PROLOG等逻辑程序设计语言直接使用。

然后，函数和逻辑表达式嵌套的引入也带来了计算上的巨大挑战。例如，给给定一元谓词P和一元函数f，能组成的文字有P(X)，P(f(X))，P(f(f(X)))等无穷多个，这就是使得规则学习过程中可能的候选原子公式有无穷多个。若仍采用命题逻辑规则或FOIL学习那样自顶向下的规则生成过程，则在增加规则长度时将因无法列举所有候选文字而失败。实际困难还包括，在计算FOIL增益时需对规则覆盖的全部正反例计数，而在引入函数和逻辑表达式嵌套之后也变得不可行。

1）最小一般泛化

归纳逻辑程序设计采用自底向上的规则生成策略，直接将一个或多个正例所对应的具体事实（grounded fact）作为初始规则，再对规则逐步进行泛化以增加对样例的覆盖率。泛化操作主要是两个动作：将规则中的常量替换为逻辑变量，删除规则体中的某个文字。

例子：

更好（1,10）<—根蒂更蜷（1,10）∩声音更沉（1,10）∩脐部更凹（1,10）∩触感更硬（1,10） 

更好（1,15）<—根蒂更蜷（1, 15）∩脐部更凹（1, 15）∩触感更硬（1, 15）

这两条是事实，说明西瓜1比西瓜10、15的特征比较，是特殊的关系数据样例，不具有泛化能力。需要将这样的特殊规则转变为更一般的规则，采用的最基础技术就是最小一般泛化（Least General Generalization，LGG）。

给定一阶公式r1和r2，LGG先找出设计相同谓词的文字，然后对文字中每个位置的常量逐一进行考察，若常量在两个文字中相同则保持不变，记LGG(t,t)=t；否则将它们替换为同一个新变量，并将该替换应用关于公式的所有其他位置，假定这两个不同的常量分别为s、t，新变脸为V，则记为LGG(s,t)=V，并在以后所有出现的LGG(s,t)的位置用V来代替。一句话，常量换变量。

更好（1,Y）<—根蒂更蜷（1,Y）∧声音更沉（1,10）∧脐部更凹（1,Y）∧触感更硬（1,Y） 

更好（1,Y）<—根蒂更蜷（1, Y）∧脐部更凹（1, Y）∧触感更硬（1, Y）

接着，LGG忽略r1和r2中不含共同谓词的文字。显然上面这个例子中，声音更沉谓词就要忽略了。最终两条规则经过LGG的两个步骤，常量换变量和保留交集谓词，就变成：

更好（1,Y）<—根蒂更蜷（1, Y）∧脐部更凹（1, Y）∧触感更硬（1, Y）

这条规则就是可以判断西瓜1是否比其他瓜更好。为提高泛化能力，结合西瓜2的初始规则：

更好（2,10）<—颜色更深（2,10）∧根蒂更蜷（2,10）∧敲声更沉（2,10）∧脐部更凹（2,10）∧触感更硬（2,10）

对这两个规则进行LGG，还是常量换变量和保留交集谓词，最后就变成：

更好（X,Y）<—根蒂更蜷（X, Y）∧脐部更凹（X, Y）∧触感更硬（X, Y）

这条规则就可以用来比较任何两个西瓜的优劣了。

如果在规则中引入非符号，LGG还能进行更复杂的泛化操作。另外，上面例子的初始规则仅包含变量同为（X,Y）的关系，而背景知识应该包含更多的关系，故此ILP系统常采用不用的初始规则选择方法。最常用的是RLGG(relative leastgeneral generalization,RLGG)，在计算LGG时考虑所有的背景知识，将样例e的初始规则定义为e<-K，其中K是背景知识中所有原子的合取。

容易证明，LGG能特化为r1和r2的所有一阶公式中最特殊的一个：不存在既能特化为r1和r2，也能泛化为它们的LGG的一阶公式r*。在归纳逻辑程序设计中，获得LGG之后，可将其看作单条规则加入规则集，并可采用对规则集进行后剪枝来进一步优化。

2）逆归结

在逻辑学中，演绎（deduction）与归纳（induction）是人类认识世界的两种基本方式。演绎是从一般性规律出发来探讨具体事务，而归纳则是从个别事物出发概括出一般性规律。一般数学定理证明是演绎实践的代表，而机器学习显然是属于归纳的范畴。1965年逻辑学家J.A.Robinson提出，一阶谓词演算中的演绎推理能用一条十分简洁的规则描述，这就是数理逻辑中著名的归结原理（resolution principle）；二十年后，计算机科学家S.Muggleton和W.Butine针对归纳推理提出了逆归结（inverse
 resolution），这对归纳逻辑程序设计的发展起到了重要作用。

基于归结原理，可将复杂的逻辑规则与背景知识联系起来化繁为简，从一般到特殊；基于逆归结，可依托背景知识发明新概念和关系，从特殊到一般。以命题演算为例，来说明归结和逆归结。

假设两个逻辑表达式C1和C2成立，其分别包含了互补项L1与L2；不是一般性，令L=L1=﹁L2，C1=A∨L，C2=B∨﹁L。

归结原理是通过演绎消去L而得到归结项C=A∨B。

逆归结的过程相反，是研究在已知C和某个Ci的情况下如何得到Cj（i≠j）：C2=(C-( C1-{L}))∨{﹁L }。

在逻辑推理实践中如何实现逆归结呢？有四种完备的逆归结操作。若以规则形式p←q等价地表达 p∨﹁q，并假定用小写字母表示逻辑文字、大写字母表示合取式组成的逻辑子句，则这四类操作是：

![](https://img-blog.csdn.net/20170524114021871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzc2hhcnBzd29yZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




这里X/Y表示X蕴含Y，即X推出Y。上述规则中，X的子句或是Y的归结项，或是Y的某个子句的等价项；而Y中出现的新逻辑文字则可看作通过归纳学到的新命题。

归结、逆归结都能容易地扩展为一阶逻辑形式，与命题逻辑的主要不同之处在于，一阶逻辑的归结、逆归结通常需进行合一置换操作。

置换（substitution）是用某些项来替换逻辑表达式中的变量。如用⊙={1/X,2/Y}置换C=色泽更深(X,Y)∧敲声更沉(X,Y)可得到C*=C⊙=色泽更深(1,2) ∧敲声更沉(1,2)，其中{X,Y}称为⊙的作用域（domain）。与代数中的置换类似，一阶逻辑中也有复合置换和逆置换。

合一（unification）是用一种变量置换令两个或多个逻辑表达式相等。如对A=色泽更深(1,X)和B=色泽更深(Y,2)，可用⊙={2/X,1/Y}使A⊙=B⊙=色泽更深（1,2），此时称A和B是可合一的（unifiable），称⊙为A和B的合一化子（unifer）。若δ是一组一阶逻辑表达式W的合一化子，且对W的任意合一化子Θ均存在相应的置换λ使Θ=δoλ，则称δ为W的最一般合一置换或最一般合一化子（most general unifier，记为MGU），这是归纳逻辑程序中最重要的概念之一。如色泽更深（1,Y）和色泽更深(X,Y)能被Θ1={1/X}，Θ2={1/X,2/Y}，Θ3={1/Z,Z/X}合一，但仅有Θ1是它们的MGU。

一阶逻辑进行归结时，需利用合一操作来搜索互补项L1与L2。对两个一阶逻辑表达式C1=A∨L1和C2=B∨L2，若存在合一化子Θ使得L1Θ=﹁L2Θ，则可对其进行归结：C=( C1-{ L1})Θ∨( C2-{L2})Θ。

类似地，可利用合一化子将逆归结项扩展到一阶逻辑的逆归结。定义C1=C/ C2和C2=C/C1为归结商（resolution quotient），于是，逆归结的目标就是在已知C和C1时求出归结商C2。对某个L1∈C1，假设ϕ1是一个置换，可使( C1-{ L1}) ϕ1蕴含C，即推出C。这里ϕ1的作用域是C1中所有变量，记vars(C1)，其作用是使C1-{L1}与C中的对应文字能合一。令ϕ2为作用域是vars(L1)-vars(C1-{L1})的置换，L1为归结商C2中将被消去的文字，Θ2是以vars(L2)为作用域的置换，ϕ1和ϕ2共同作用域L1，使得﹁L1
 ϕ1o ϕ2= L2Θ2，于是ϕ1o ϕ2oΘ2为﹁L1与L2的MGU。将前两步的复合置换ϕ1o ϕ2记为Θ1，用Θ2-1表示Θ2的逆置换，则有(﹁L1Θ1) Θ2-1=L2，可得一阶逆归结：C2=(C-( C1-{ L1})Θ1∨{﹁L1Θ1})Θ2-1。在一阶情形下L1、L2、Θ1和Θ2的选择通常都不唯一，需通过其他判断标准来取舍，如覆盖率、准确率、信息熵等。例子可看文中的西瓜集。

逆归结的一大特点就是能自动发明新谓词，这些新谓词可能对应于样例属性和背景知识中不存在的新知识，对知识发现和精化有重要意义。但自动发明的新谓词究竟对应于什么语义，要在任务领域中进一步理解。在现实任务中，ILP系统通常先自底向上生成一组规则，然后再结合最小一般泛化与逆归结进一步学习。

本章总结，规则学习是符号主义学习（symbolism learning）的主要代表，是最早开始研究的机器学习技术之一。规则学习主要提出了命题规则学习、一阶规则学习和归纳逻辑程序设计，并给出序贯覆盖、剪枝优化等技术。ILP复杂度很高，问题规模稍大难以处理，随着统计学习的兴起，规则学习被边缘化；不过在富含结构信息和领域知识的任务中，逻辑表达的重要性凸显，因此结合规则学习和统计学习又抬头。实际上，规则学习应该是最早的机器学习方法，典型就是知识工程与专家系统，而统计学习后面崛起，究竟最终机器学习的根本在规则还在统计，显然仍未有定论。



