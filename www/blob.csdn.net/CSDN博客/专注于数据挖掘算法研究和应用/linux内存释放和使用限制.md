# linux内存释放和使用限制 - 专注于数据挖掘算法研究和应用 - CSDN博客





2017年07月06日 11:24:21[fjssharpsword](https://me.csdn.net/fjssharpsword)阅读数：2391








                
1、内存释放


命令：echo 1 > /proc/sys/vm/drop_caches

解释：
drop_caches的值可以是0-3之间的数字，代表不同的含义：
0：不释放（系统默认值）
1：释放页缓存
2：释放dentries和inodes
3：释放所有缓存 

案例：

```
#free -g
             total       used       free     shared    buffers     cached
Mem:           125         28         97          0          0          3
-/+ buffers/cache:         25        100
Swap:           63          1         62
# echo 3 > /proc/sys/vm/drop_caches
# free -g
             total       used       free     shared    buffers     cached
Mem:           125         27         98          0          0          1
-/+ buffers/cache:         25        100
Swap:           63          1         62
```



2、使用限制

   1)查看某个用户当前使用的总内存大小命令

     #ps   -o rss  aU username  |grep -v RSS|awk 'BEGIN {sum=0}{sum+=$1}END{print sum}'

   1)ulimit -m 参数设置；

   2)/etc/security/limits.conf设置

     如：@users           hard    rss             5000

         限制用户内存使用5M；



     如：

        *       soft    nofile  1048576
*       hard    nofile  1048576
*       soft    nproc   1048576
*       hard    nproc   1048576

        *代表所有用户




回顾下内存运行机制和内存监控




1、内存运行机制

1）物理内存和虚拟内存

物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。



作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。



Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。


2）运行机制特点：

1）Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。



2）Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟 内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需 要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面 文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。



3）交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页 面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽 然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。





2、内存监控-free



```
# free
             total       used       free     shared    buffers     cached
Mem:       3894036    3473544     420492          0      72972    1332348
-/+ buffers/cache:    2068224    1825812
Swap:      4095992     906036    3189956
```


选项的含义：

第一行：

total：物理内存的总大小

used：已经使用的物理内存大小

free：空闲的物理内存大小

shared：多个进程共享的内存大小

buffers/cached：磁盘缓存的大小



第二行Mem：代表物理内存使用情况

第三行(-/+ buffers/cached)：代表磁盘缓存使用状态

第四行：Swap表示交换空间内存使用状态



free命令输出的内存状态，可以通过两个角度来查看：一个是从内核的角度来看，一个是从应用层的角度来看的



1）从内核的角度来查看内存的状态

就是内核目前可以直接分配到，不需要额外的操作，即为上面free命令输出中第二行Mem项的值，可以看出，此系统物理内存有3894036K，空闲的内存只有420492K，也就是40M多一点，我们来做一个这样的计算：

3894036 - 3473544 = 420492

其实就是总的物理内存减去已经使用的物理内存得到的就是空闲的物理内存大小，注意这里的可用内存值420492并不包含处于buffers和cached状态的内存大小。

如果你认为这个系统空闲内存太小，那你就错了，实际上，内核完全控制着内存的使用情况，Linux会在需要内存的时候，或在系统运行逐步推进时，将buffers和cached状态的内存变为free状态的内存，以供系统使用。



2）从应用层的角度来看系统内存的使用状态

也就是Linux上运行的应用程序可以使用的内存大小，即free命令第三行 -/+ buffers/cached 的输出，可以看到，此系统已经使用的内存才2068224K，而空闲的内存达到1825812K，继续做这样一个计算：

420492＋（72972＋1332348）＝1825812

通过这个等式可知，应用程序可用的物理内存值是Mem项的free值加上buffers和cached值之和，也就是说，这个free值是包括buffers和cached项大小的，对于应用程序来说，buffers/cached占有的内存是可用的，因为buffers/cached是为了提高文件读取的性能，当应用程序需要用到内存的时候，buffers/cached会很快地被回收，以供应用程序使用。



3）buffers与cached的异同

在Linux 操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写 数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。然而，如果有大量数据需要从磁盘读取到内存或者由内存写入磁盘时，系统的读写性 能就变得非常低下，因为无论是从磁盘读数据，还是写数据到磁盘，都是一个很消耗时间和资源的过程，在这种情况下，Linux引入了buffers和 cached机制。



buffers与cached都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers 与cached内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操 作系统的性能。但buffers与cached缓冲的内容却是不同的。



buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来给文件做缓冲。更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。





