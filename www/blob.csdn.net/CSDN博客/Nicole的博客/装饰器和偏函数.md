# 装饰器和偏函数 - Nicole的博客 - CSDN博客
2018年05月13日 19:02:41[Nicole_Liang](https://me.csdn.net/weixin_39541558)阅读数：82标签：[装饰器](https://so.csdn.net/so/search/s.do?q=装饰器&t=blog)
个人分类：[python 数据处理](https://blog.csdn.net/weixin_39541558/article/category/7563702)
- - [1. 装饰器](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#1-%E8%A3%85%E9%A5%B0%E5%99%A8)
- [2. 偏函数](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#2-%E5%81%8F%E5%87%BD%E6%95%B0)
- [3. 变量的作用域](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#3-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F)
- [4. 异常处理](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
- [5. 文件读写](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99)- [读文件](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#%E8%AF%BB%E6%96%87%E4%BB%B6)
- [写文件](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#%E5%86%99%E6%96%87%E4%BB%B6)
- [编码与解码](https://blog.csdn.net/Fire_to_cheat_/article/details/79434109#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81)
## 1. 装饰器
概念：是一个闭包，把一个函数当做参数返回一个替代班的函数，本质上就是一个返回函数的函数。
```
def func1():
    print('the bryce is handsome')
def outer(func):
    def inner():
        print('******')
        func()
    return inner
#f是func1的加强版本
f=outer(func1)
f()
```
稍微复杂一点的装饰器：
```
def outer(func):
    def inner(age):
        if age<0:
            age=0
        func(age)
    return inner
# 使用@符号将装饰器应用到函数
@outer #相当于s=outer(say) 
def say(age):
    print("bryce is %d years old "%(age))
s=outer(say)
s(-10)
```
* 通用装饰器*
```
def outer(func):
    def inner(*args,**kwargs):
        #添加修改的功能
```
```
print ('&&&&&&&&&')   
        func(*args,**kwargs)
    return inner
@outer
def say(name,age):   #函数的参数理论上是无限的，但实际上最好不要超过6、7个
    print("my name is %s,i am %d years old "%(name,age))
```
## 2. 偏函数
把一个参数固定住，形成一个新的函数
```
import functools  
int3=functools.partial(int,base=2)   #可以通过调用模块functools来实现偏函数
print(int3("1010"))
```
```
#偏函数
def int2(str,base=2):
    return int(str,base)
print(int2("1010"))
```
## 3. 变量的作用域
局部作用域 
全局作用域 
內建作用域
## 4. 异常处理
` try.....except.....else`
格式：
```
try:
    语句t
except 错误码 as e:
    语句1
except 错误码 as e:
    语句2
......
except 错误码 as e:
    语句n
else:
    语句e
(finally:)
    ***
```
`作用：语句t无论是否有错误都执行最后的语句f`
**注意：else语句可有可无**
**作用：用来检测try语句块中的错误，从而让except语句捕获错误信息并处理**
逻辑：当程序执行try-except-else语句时
1.如果当try“语句t”执行时出现错误，会匹配第一个错误码，如果匹配上则会执行相应的“语句”。
2.如果当try“语句t”执行时出现错误，没有匹配的异常。错误将会被提交到上一层的try语句，或者到程序的最上层。
3.如果当try“语句t”执行没有错误，执行else语句下的“语句e”(前提是错在else语句）
```
try:
    print(3 / 0)
except ZeroDivisionError as e:
    print("除数为0了")
else:
    print("*")
print("*****")
try:
    print(4 / 0)
    print(nums)
except:
    print("程序出现异常")
#使用except带着多种异常
try:
    pass
    print(4 / 0)
    print(nums)
except(ZeroDivisionError, NameError ):
    print("出现了NameError,ZeroDivisionError")
特殊
1、错误其实是class（类），所有的错误都是继承自BaseException，所以在捕获的时候，他捕获了该类型的错误，还把子类一网打尽
try:
    print(5 / 0)
except BaseException as e:
    print("异常1")
except ZeroDivisionError as e:
    print("异常2")
#2、跨越多层调用,main()调用了func2，func2调用func1，func1出现了错误，这时候只要main捕获了就可以处理
def func1(num):
    print(1 / num)
def func2(num):
    func1(num)
def main():
    func2(0)
```
`##main这里捕获错误`
```
try:
    main()
except ZeroDivisionError as e:
    print("******")
try ……except……finally
```
`##3.作用：语句t无论是否有错误都执行最后的语句f`
try: print(1/0)except ZeroDivisionError as e: print("******")finally: print("必须执行我")
**断言：**
```
def function(num,div):
    assert(div!=0),"div不能为0"
    return num/div
print(function(10,0))
```
## 5. 文件读写
### 读文件
（1）打开文件 
open(path,flag[,encoding，errors]) 
path:要打开文件的路径 
flag:打开方式
|r|以只读的方式打开文件，文件的描述符放在文件的开头|
|----|----|
|rb|以二进制格式打开一个文件用于只读，文件的描述符在文件的开头|
|r+|打开一个文件用于**读写**，文件的描述符放在文件的开头|
|w|**打开一个文件只用于写入，如果该文件已经存在则覆盖，若不存在，则创建新文件**|
|wb|打开一个文件只用于写入二进制，如果该文件已经存在则覆盖，若不存在，则创建新文件|
|w+|打开一个文件用于**读写**，如果该文件已经存在则覆盖，若不存在，则创建新文件|
|a|**打开文件用于追加**|
|a+||
encoding:编码方式 ，表示返回的数据采用何种编码方式，一般为utf-8或gbk
errors:错误处理,取值有strict，ignore，当取string时，字符编码出现问题时，会报错，当取ignore时，编码出现问题时程序会忽略
（2）读文件内容 
读取文件的全部内容
```
path=r"C:\Users\92924\Desktop\file.txt"   #如果文件不再工作目录下，需要写出所有的路径
f=open(path,"r",encoding="utf-8",errors="ignore")
str=f.read()
print(str)
```
读取指定字符数
```
path=r"C:\Users\92924\Desktop\file.txt"
f=open(path,"r",encoding="utf-8",errors="ignore")
str=f.read(10)
print(str)
```
读取整行
```
path=r"C:\Users\92924\Desktop\file.txt"
f=open(path,"r",encoding="utf-8",errors="ignore")
str=f.readline()
print(str)
```
读取所有行，并返回列表
```
path=r"C:\Users\92924\Desktop\file.txt"
f=open(path,"r",encoding="utf-8",errors="ignore")
str=f.readlines()
print(str)
```
（3）关闭文件
`f.close()`
完整简洁写法：
```
path=r"C:\Users\92924\Desktop\file.txt"
with open(path,'r',encoding='utf-8')as f:   #with语句让你打开文件并赋值给一个变量，到达该语句的末尾，将自动关闭文件
    print(f.read())
```
### 写文件
（1）将信息写入缓冲区
`f.write("Bryce is a good man")`
(2)刷新缓冲区 
直接将缓冲区的数据立刻写入文件,而不是被动等待自动的刷新。 
（缓冲区满的时候会自动刷新） 
f.flush()
**完整写文件：**
```
with open(path,'a') as f:
    f.write("good man")
```
### 编码与解码
编码：encode（） 
解码：decode（）
