# C++常考面试题 - 别说话写代码的博客 - CSDN博客





2018年12月29日 18:41:16[别说话写代码](https://me.csdn.net/qq_21997625)阅读数：121








转自：[https://www.cnblogs.com/liufei1983/p/7099401.html](https://www.cnblogs.com/liufei1983/p/7099401.html)

**1 new/delete 与 malloc/free的区别**

    运算符是语言自身的特性，有固定的语义，编译器知道意味着什么，由编译器解释语义，生成相应的代码。

    库函数是依赖于库的，一定程度上独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。

     实际中，一些高级点的编译器，都会对库函数进行特别处理。

      malloc/free是库函数，new/delete是C++运算符。对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。

**2 delete与delete[ ] 区别**

     delete只会调用一次析构函数，而delete[] 会调用没一个成员的析构函数。

     delete 与 new 配套使用； delete[] 与new[]配套使用。

     对于内建的简单数据类型，delete和delete[] 功能相同。

     对于复杂数据类型，delete和delete[]不同，前者删除单个对象，后者删除数组。

**3 子类析构时，要调用父类的析构函数吗？**

     析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。

     不用显示调用，自动调用。

**4 多态， 虚函数， 纯虚函数**

多态：不同对象接收相同的消息产生不同的动作。多态包括 **编译时多态**和 **运行时多态**

  　 运行时多态是：通过继承和虚函数来体现的。

       编译时多态：运算符重载上。

虚函数： 在基类中用virtual的成员函数。允许在派生类中对基类的虚函数重新定义。

       基类的虚函数可以有函数体，基类也可以实例化。

       虚函数要有函数体，否则编译过不去。

       虚函数在子类中可以不覆盖。

       构造函数不能是虚函数。

纯虚函数：基类中为其派生类保留一个名字，以便派生类根据需要进行定义。

       包含一个纯虚函数的类是抽象类。

       纯虚函数后面有 = 0；

       抽象类不可以实例化。但可以定义指针。

       如果派生类如果不是先基类的纯虚函数，则仍然是抽象类。

        抽象类可以包含虚函数。

**5 抽象类和接口的区别  **

       在C++里面抽象类就是接口

　    抽象类：定义了纯虚函数的类是抽象类，不能实例化。

        抽象类包括抽象方法(纯虚方法)，也可以包含普通方法。

        抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖。

        虽不能定义抽象类的实例，但是可以定义抽象类的指针。

**6 什么是“引用”？声明和使用“引用”要注意哪些问题？**

**引用的特性**：

                 引用是目标变量的别名，对引用的操作与对变量的操作效果一样。声明引用的时候要必须对其初始化。引用声明完后，相当于目标变量有两个名称，不能  　　 再把引用作为其他变量的别名。

                 引用不是新定义一个变量，它只是表示该引用是目标变量名的一个别名，它本身不是一种数据类型，因此引用不占用存储单元。

                 无法建立数组的引用。因为数组是一个由若干元素组成的集合，无法建立数组的别名。

**引用的作用**：

                 作为函数的参数，以前用值传递，现在用指针或引用。

                 传引用和传指针给函数效果一样的。

                 传递引用，内存中没有生成实参副本，是直接对实参操作。如果传递的是值类型，需要在栈上生成副本，如果是对象，还要调用构造函数。

                  指针调用的时候，其实也会形参分配存储单元，且需要用“指针变量名”的形式运算，容易产生错误并且可读性差；调用的时候，需要用变量的地址作为实             参，调用形式不好看。引用没有这些            问题。

                  引用作为返回值最大的好处是：内存中不会产生副本。

                  但是，引用作为返回值注意事项：

                  A：不能返回局部变量的引用。

                  B：不能返回函数内部new的变量。因为引用仅仅是别名，无法释放内存。

                  C: 可以返回类成员的引用，但是最好是const

                  D : 引用和指针一样，可以产生多态的效果。

**总结**：    

             A: 引用的使用主要用于函数传参，解决大块数据或对象的问题。

             B： 用引用传递函数参数，不产生副本，通过const，保证引用传递的安全性。

             C：比指针的可读性好，

**7 将引用作为函数参数有哪些特点**

（1）与指针调用效果一样。 

（2）引用传参，内存中并没有产生副本。

（3）用指针传递，也要给形参分配存储单元；并且需要使用"*变量的"的形式，可读性差；另外，调用的地方还得用地址作为实参。

**8 什么时候用常引用**

         const int &ra = a;   // 不能通过引用对目标变量的值进行修改，从而使引用的目标成为const的，安全。

         void bar(String &ra)

         bar("AA")  // 这个会报错，因为 ”AA“相当于 const char[], 不能传递给bar函数。

          可以把函数声明为Void bar(Const String &ra)， 上述语句就不会报错。

**9  引用作为函数返回值类型的格式，好处和规则？**

            int &fun(int a) {}

             好处：不会生成副本。

             规则：    不能返回局部变量的引用；不能返回函数内部new分配的内存引用； 如果返回成员的话，返回const'

**10  结构与联合的区别**

联合是公用存储单元的，任何一个时刻只有一个被选中的成员。一旦赋值后，其他成员也覆盖了。

**11 重载(overload)和重写(override)?**

       重载：多个同名函数，参数不同（个数不同，参数类型不同）；是同一层级的函数；静态绑定；编译期绑定。

       重写：子类重新定义父类函数的方法；是动态绑定。

**12  有几种情况用intialization list(初始化列表)而不是assignment(赋值)?**

           当类中含有const成员变量； reference成员变量； 基类构造函数需要初始化列表。

**13  C++是不是类型按群的？**

         不是； 两个不同类型的指针之间可以强制转换。

**14  main函数之前会执行什么代码？**

      全局变量的初始化。

**15　内存分配方式和区别**

　（１）静态存储区：在编译时就分配好，在整个运行期间都存在。比如全局变量，static变量。

　　（２）常量区：　存放常量的，比如字符串常量。

　　（３）堆

　　（４）栈

**１６　BOOL，int，float，指针类型，于”零“的比较语句。**

　　BOOL：　if(!a)  or  if(a)

           int:  if(a == 0)

           float:  const EXPRESSION exp = 0.000001

                     if (a < EXP && a > -EXP)

           指针：  if（ａ　！＝　ＮＵＬＬ）

**17  const 与 #define相比，优点？**

       const:    定义常量；  修饰函数参数；   修饰函数返回值；     修饰类成员函数。

       好处:     const 修饰的有数据类型，而宏没有，所以可以做类型检查；而宏仅作字符替换，无安全检查。

                     const常量可以调试

                     宏有副作用。不加括号的话有副作用。

**18 数组和指针的区别**

     数组要么在静态存储区创建，要么在栈上创建。指针可以随时指向任意类型的内存块。

      char a[] = "khell"; // 栈中分配内存，所以可以修改。

      a[0] = 'x'; // 可以 没有问题

      char *p = "khell";//常量字符串，存储在字符常量区，不可以修改



       p[0] = 'x'; // 编译可以，运行时错误。

       sizeof(a) //是数组的大小；

       sizeof(p) // 是指针的大小4.

       当数组作为函数参数进行传递时，该数组退化成指针

　　void Func(char a[100])

　　{

　　　　cout<< sizeof(a) << endl; // 4 字节而不是100 字节

　　}

        数组名不能自加自减，但是指针可以。

        int a[ ] = {1, 2, 3, 4, 5};

        int *ptr = (int *) (&a + 1)  // a的地址加1后，其实是加了 4*5  = 20那么多**。每次把一个地址加1，都是走数据结构那么大的步长**。

**19 int(*s[10])(int)**

        函数指针数组，S[10]里面每个元素都是函数指针，指向函数的类型是 int  fun(int a)

                  void add(int a, int b)

                   {

                     cout << a + b << endl;

                   }


　　　　　　void (*p1)(int a, int b);

　　　　　　p1 = add;

**20 为什么基类的析构函数是虚函数？**

动态绑定，不会造成潜在的内存泄漏

**21 全局变量和局部变量的区别？如何实现的？操作系统和编译器是怎么知道的?**

  全局变量分配在全局数据段（静态存储区），在程序开始运行时候加载。局部变量则分配在堆栈里面。

**22  内存分配方式**

堆：有内存碎片的问题。一定的算法去找合适的内存。效率低。OS有记录空闲内存地址的链表

栈：专门的寄存器存放栈地址。效率高。有大小限制。

自由存储区：用malloc /free分配释放。 和堆类似。

全局/静态存储区：全局变量，静态变量。

常量存储区：放常量，不允许修改。

int a=0;    全局/静态存储区

char *p1;  全局/静态存储区 

int main() 

{ 

 int b; //栈 

 char s[]="abc"; //栈 

 char *p2; //栈 

 char *p3="123456"; //123456在常量区，p3在栈上。

static int c =0；//全局（静态）初始化区 

 p1 = (char *)malloc(10); //分配得来得10和20字节的区域就在堆区

p2 = (char *)malloc(20); 

 strcpy(p3,"123456"); //123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。 

}

**23 void *(*(*fp1)(int)[10]  / float(*(*fp2)(int, int, int))(int)  /  int (*(*fp3())[10]()**

**24 引用与指针区别**：

　　引用必须初始化，指针不用。

　　引用初始化后不能改变，指针可以改变所指的内容。

　　不存在指向空值的引用，但是存在指向空值的指针。

　　指针可以有多级；引用就一级。

　　指正要解引用，引用不用。

　　引用没有const， 但是指针有。

　　sizeof结果不同。

　　自增的语义不同。

**25 int id[sizeof(unsigned long)] 合法吗？**

可以。数组的大小在编译的时候就要确认。

**26 栈内存与文字常量区域**

       char str1[] = "abc";

　　char str2[] = "abc";

　　const char str3[] = "abc";

　　const char str4[] = "abc";

　　const char *str5 = "abc";

　　const char *str6 = "abc";

　　char *str7 = "abc";

　　char *str8 = "abc";

　　cout << ( str1 == str2 ) << endl;//0 分别指向各自的栈内存

　　cout << ( str3 == str4 ) << endl;//0 分别指向各自的栈内存

　　cout << ( str5 == str6 ) << endl;//1指向文字常量区地址相同

　　cout << ( str7 == str8 ) << endl;//1指向文字常量区地址相同

　　结果是：0 0 1 1

　　解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。

**27 虚函数 VS 纯虚函数**

　　虚函数为了重载和多态，在基类中是有定义的，即便定义为空。在子类中可以重写。

　　纯虚函数在基类中没有定义，必须在子类中实现。

　　多态的基础是继承，需要虚函数的支持。

**28 子类不能继承父类的函数**

　　子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数。

**29 开发中常用的数据结构：**

　　A：数组和链表：

　　　　数组大小不能动态定义。链表和动态分配大小的。 

　　　　数组不适应动态增/减的情况，因为大小固定，一旦定义就不能改变。

　　　　链表适合动态的增加、删除数据。

　　　　数组的随机访问快。

　　　　数组栈中分配； 链表在堆中。

　　B：二叉树遍历：

　　　　先序、中序、后序。

**30 const与static的用法**

　　const：

　　　　修饰类成员变量，成员不可以改。

               修饰函数参数；

               修饰返回值；

　　　　修饰函数，函数不会修改类内的数据成员。不会调用非const成员函数。（在函数末尾，默认是const this指针，不能修改成员）

　　　　const函数只能调用const函数，非const函数可以调用const函数。

　　static：

　　　　局部static变量：局部静态变量，处于内存中的静态存储区；只能初始化一次；作用域是局部。

　　　　全局static变量：全局静态变量，静态存储区；全局静态变量的作用局是声明它的文件，在文件之外是不可见的。其实是从

　　　　定义的地方到文件结尾。


　　类的static成员：类的全局变量，被类的所有独享共享，包括派生类的对象。按照这种方式int base::var = 10;进行

　　初始化，不能在构造函数内初始化，**但是可以用const修饰的static数据成员在类内初始化。**

　　static修饰成员函数，类只有一份，不含this指针。

　　static成员变量定义放在cpp文件中。 const static 可以就地初始化。

**31 类的static变量在什么时候初始化，函数的static变量什么时候初始化？**

         类的静态成员在类实例化之前就存在了； 函数的static变量在执行此函数时进行实例化（第一次调用的时候，只初始化一次）

**32 栈溢出的原因：**

　　栈大小有限制：分过多的数组； 

　　递归调用层太深；

**33 switch参数类型**

　　可以是：byte short int long bool

　　不能是： float double（这种浮点型的不能精确的比较，所以不能） string

　　但是在c++ 11里面， string可以作为switch的条件了。

**35 频繁出现的短小的函数，在c/C++中分别如何实现**

　　c中用宏定义； C++ 内联

**36 C++函数传参数方式**

　　值传递、指针、引用

**37 定义宏注意什么？**

　　定义部分的每个形参和整个表达式都必须用括号括起来。

**38 .h头文件中的ifndef/define/endif作用**

　　防止头文件重复包含

**39 struct VS class**

　　struct的成员默认是共有的，而类的成员默认是私有的。

　　继承的的时候，class默认是私有继承；结构体是共有继承；

　　class还用于定义模板参数，就像typename

**40 系统会自动打开和关闭的三个标准文件是？**

　　在[C语言](http://lib.csdn.net/base/c)中，在程序开始运行时，系统自动打开3个标准文件：标准输入、标准输出、标准出错输出。通常这3个文件都与终端相联系。因此，以前我们所用到的从终端输入或输出都不需要打开终端文件。系统自定义了3个文件指针 stdin、stdout、stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。

　　标准输入流：stdin

       标准输出流：stdout

　　标准错误输出流：stderr

**41 如何判断浮点数是否是0.5**

　　fabs(x - 0.5)< DBL_DEPSILON

**42 内存泄漏？ 指针越界和内存泄漏，有哪些方法？**

　　new/delete, new[]/delete, malloc/free 配套使用

　　对指针赋值的时候，一定要看原来指向的东西是否需要释放

　　指针指向的东西释放后，一定要将指针设置为null。

**43 TCP、UDP差别**

　　TCP： 面向连接， 有保障， 效率低， 基于流的，重要数据

　　udp:    无连接 无保障 效率高 基于数据报文 不重要的数据

**44  #include<file.h> #include "file.h"**

　　前者是从标准库路径寻找

　　后者是从当前工作路径

**45 sizeof**

　　sizeof计算的是栈中分配的内存大小

　　A: 类中static的变量，计算static的时候不算在内

　　B: 指针大小是4个字节。

　　C: char = 1; int = 4; short in = 2; long int = 4; float = 4; double=8, 

　　     string = 4, 空类=1（对象在内存中都有独一无二的地址，空类会隐含的加一个字节）)， 单一继承的空类占一个字节；虚继承涉及的虚指针占4个字节

　　D:数组： 如果指定数组长度，则总字节数=数组长度 * sizeof（元素类型）,如果没有指定长度，则按照实际元素个数；如果是字符数组，则应考虑末尾空字符。

　　E: unsigned影响的只是最高位的意义，数据长度不变，sizeof(unsigned int) = 4

　　F:对函数取sizeof，在编译阶段会被函数返回值的类型代替。

　　G:sizeof不能返回动态数组的大小。

        H：sizeof不能返回外部数组的大小，因为sizeof是编译时常量(函数调用的时候，数组退化成指针)

**38 sizeof VS strlen**

　　sizeof() 返回值类型为size_t(unsigned int) 

　　sizeof是运算符，strlen是函数

　　sizeof的参数可以是类型，变量或函数。而strlen只能用char*做参数，必须以'\0'结尾

　　数组指针作为sizeof参数会退化为指针，但是传递给strlen的无论是数组还是指针不会退化为指针。

　　char *p = "chinaaaa";

　　char q[] = "chinaaaa";

　　cout << sizeof(p) << endl; 4 // 就是指针

　　cout << sizeof(q) << endl; 9

　　cout << strlen(p) << endl; 8 

　　cout << strlen(q) << endl; 8

　　sizeof是编译时常量，而strlen运行的时才会计算处理，而且是字符个数，不算最后的结尾字符。

**39 const用法**
**const常量**：定义的时候必须初始化。const int a 和 int const a 是一个意思。
**const指针**： 常量指针 和 指针常量

　　int a;

　　const int *p = &a; 常量指针，不能通P改变所值对象的值。但是可以其他方式修改。并且指针

　　还可以指向其他的int变量。const int *p 和 int const *p一样。


　　int * const p = &i; 指针常量，p中存放的地址不可以变化，可以通过P改变变量的值，但是指针不能

　　再指向其他的变量。


　    注意const int *p 和 int const *p一样


　　const引用： 可以绑定常量，也可以绑定变量。不能通过这个const引用来改变绑定对象的值。但是变量本身可以改。

　　非const 引用不能与const 对象绑定；但是const 引用可以绑定非const 变量。

**40 空指针和悬挂指针**

　　空指针是等于null的指针； 悬挂指针是delete后没有置空的野指针。

　　A： 空指针可以被delete多次，而野指针多次delete会很不稳定。

　　B： 二者都容易导致程序崩溃。

**41 C++空类，有哪些成员函数？**

　　默认构造函数， 析构函数， 赋值构造函数， 赋值函数。

　　class Empty

　　{ Empty(); // 缺省构造函数,如果用户定义构造函数，就没有这个缺省的了。无this指针。

　　　　// 两种办法初始化：

　　　　　　初始化列表：效率高。常量成员变量/引用类型/无缺省构造函数的类成员，必须用初始化列表，函数体内赋值

　　Empty(const Empty&)     // 拷贝构造函数,直接用对象赋值。必须是引用。注意深拷贝/浅拷贝的问题。

　　　　　　　　　　　　　// 3种情况调用拷贝构造函数 ：　　一个对象初始化另一个对象；

　　　　　　　　　　　　　　　　　　　　　　　　　　　　    函数形参是类对象，调用函数的时候；

　　　　　　　　　　　　　　　　　　　　　　　　　　　　     函数返回值是对象


　　~Empty(); 

　　// 析构函数，无参，无返回值，所以不能重载。


　　Empty& operator=(const Empty&);

　　}

**42 所有的函数都设置为虚函数？**

　　不行。 每个虚函数的对象要维护虚函数表。代价高。

**43 共有继承 受保护继承 私有继承**

　　共有继承：可以访问基类中的公有成员，派生类可以访问公有的和受保护的成员；

　　受保护继承：

　　私有继承：

**44 阻止类实例化**

         抽象基类 或者 构造函数是private

**46 main函数执行之前会执行什么？执行之后还能执行代码吗？**

　　全局对象的构造函数在main函数之前执行。

　　用_onexit注册一个函数,在main执行之后就会调用这个函数.

**47 函数参数入栈的顺？**

　　从右端往左进入栈的。为了支持可变参数(原理要懂得)。

**48 类的static变量的定义和初始化**

 　　static int Sum;//在头文件中声明静态数据成员

　　int Myclass::Sum=0;//定义并初始化静态数据成员，在类的外部。

**49 多态类中虚函数表是compilie-Time 还是 Run-time时建立的**
**虚函数表**是在编译时就建立了，各个虚拟函数这时被组织成了一个虚函数的入口地址的数组。

　　而对象的隐藏成员--**虚函数表指针**是在运行期-也就是构造函数被调用时进行初始化的，这是实现多态的的关键。、

**50 父类写了一个virtual函数，如果子类覆盖它函数不加virtual，可以多态吗？**

　　可以； 子类可写，可不写。

**51 子类的空间中，有无父类的virtual函数，或者私有变量？**

      答：除了static的，其他的都有。

**52 sprintf/strcpy/memcpy**

　　sprintf: 其他字符串或基本类型向字符串的转换功能。是一种格式化。

　　strcpy: 操作的是字符串，从源字符到目的字符串拷贝功能。

　　memcpy:内存拷贝。内存块内容复制。

**53 内联函数在编译时是否做类型检查**

　　内联函数要做类型检查，这是内联函数比宏的优势

**54 c/C++的结构体区别：**

　    　c++的结构体和class几乎一样。结构体可以继承，可以有函数，可以实现多态。

          区别是：结构体成员默认是public的，而类是private的；

                         另外class可以作为模板中的一个关键字 template<Class T>

                         默认的继承访问权限不同，struct是public的继承；class 是private的继承。



　　c 的结构体不具备面向对象的特征，有变量，没有函数，但是可以有函数指针。

**55 如何判断一段程序是C编译程序还是C++编译程序编译的？**

　　#ifdef __cplusplus

　　　　cout << "c++" << endl;

　　#else

　　　　cout << "c";

　　#endif

**56 C ++ 在c基础上加了什么？**

　　A：包含全部的C语言部分。

　　B：面向对象部分，封装，继承，多态。

　　C：泛型编程部分，模板，方便使用。

　　D：STL库。

**57 全局变量和局部变量**

　　分配的区域不同： 全局数据区 vs 栈

　　声明周期不同： 主程序 vs 函数内部

　　可见性不同： 全局 VS 局部

**58 有N个大小不等的自然数(1–N)，请将它们由小到大排序.要求程序算法：时间复杂度为O(n)，空间复杂度为O(1)。**

```cpp
#include <iostream>  
#include <algorithm>  
#include <iterator>  
  
void sort(int*, int);  
int main(){  
    int arr[] = {5,9,3,7,4,2,8,6,1,10};  
    int n = sizeof(arr)/sizeof(int);  
    sort(arr, n);  
    std::copy(arr,arr+n,std::ostream_iterator<int>(std::cout, ","));  
    std::cout << std::endl;  
    return 0;  
}  
  
void   sort(int *arr,   int  n)       
{       
    int count = 0;//此数据不是算法必须，用来计算算法循环次数。  
    int i;  
    int tmp;  
    for(i=0;i<n;++i){  
        while( (i + 1) != arr[i]){  
            tmp = arr[i];  
            arr[i] = arr[tmp-1];  
            arr[tmp-1] = tmp;  
            ++count;  //算法每循环一次加一。  
        }  
    }  
    std::cout << "count = " << count << std::endl; //最后得出的循环次数小于等于n。  
}
```

**59 宏，内联函数，函数 区别**：

　　宏效率高，编译时替换，没有类型检查，可能有副作用。

　　内联函数有类型检查，效率高，替换，当然也有可能不替换。一般函数短可以用内联，长的话编译器可以优化不内联。

　　函数，调用过程入栈、出栈，效率低。

**60 栈， 堆区别**

　　申请方式：自动 vs 手动

　　响应方式： 只要栈没有超过最大，不statck overflow, 就能分配成功 ； 堆，遍历空闲内存地址链表，找到第一个大于申请空间的节点，从空闲链表删除，并                                  且在这个块的首地址处记录分配的大小，以便delete语句正确执行，并且，堆的大小如果大于申请的大小，多余的部分还会记录到空闲链表。

　　申请大小限制：栈的大小有限制； 堆的话比较大。

　　效率：栈快， 自动的； 堆慢，容易产生内存碎片。

　　存储的内容：在函数调用时，先入栈的是函数调用的下一条语句的地址，然后从左到右函数入栈，然后是局部变量

　　　　　　　　静态局部变量不入栈； 堆的头部用一个字节大小存堆的大小。堆中的具体内容程序员安排。

**61 常引用的作用**

　　传递给函数的数据在函数中不被改变

**62 引用与多态的关系？**

        引用和指针可以实现多态。

**63 多态作用**

　　代码模块化，扩展代码模块，实现代码重用。

**64 隐藏**

　　隐藏：派生类的函数屏蔽了同名的基类函数：

　　派生类函数与基类函数同名，参数不同，无论有无virtual关键字，基类函数被隐藏（不是重载）

　　派生类函数与基类函数同名，参数相同，基类无virtual， 基类被隐藏。

**65 a,b两个变量，不用 if,else, 不用switch，不用三目表达式。找到最大的那个？**

找最大的：  (a + b + abs(a-b) )  /  2   

       找最小的：  (  a + b - abs(a-b)  )   / 2 



**66  打印文件名行号**

　　cout << __FILE__ << " " << __LINE__ << endl;

**67 程序在结束的时候，系统会自动析构所有的全局变量。**

       事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样

**68：pragma once ，  ifdefine**

　　#pragma once是编译器相关的，有的编译器支持，有的编译器不支持，具体情况请查看编译器API文档，不过现在大部分编译器都有这个杂注了。

　　#ifndef，#define，#endif是C/C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式

**69: 函数的const参数构成重载函数**

　　如果是值传递的函数，值的const 和非const 不构成重载。

　　如果是引用和指针的可以构成重载。

　　非const 可以调用const。

　　const 不可调用非const的。

　　调用重载函数的时候 会选择最匹配的那个

**70：C++ 全局变量/常量解析**

编译单元：编译成obj文件，然后link成.exe，编译主要是看语法错误；链接主要是重复定义或者没有定义。

　　声明与定义：函数或变量在声明的时候，没有给实际的物理内存空间，它有时候可以保证编译能通过；

                             当函数或变量定义的时候，它就在内存中有了实际的物理空间。声明可以多次，但是定义只能一次。

      extern 作用： 

                   A： extern "C"  void fun(int a, int b），在编译fun这个函数时按照C的规则区翻译相应的函数名，而不是c++. 

                   B： extern作用：你现在编译的文件中，有一个变量或函数虽然在本文件中没有定义，但是在别的文件中定义的全局变量。

　　　　　　    在头文件中： extern int g_int 作用是声明函数或全局变量的作用范围的关键字，其声明的函数或变量

             　　     可以在本模块或其他模块中使用，记住，这是声明不是定义！也就是说b模块引用a 中定义的全局变量或

              　　    函数，它包含a的头文件，就可以在编译阶段通过，b模块在链接的时候从模块a生成的目标代码中找到

             　　     此函数或变量。

                        错误的做法：在stdafx.h中定义int globalINt = 0; 然后在其他.cpp文件中extern int globalINt ;总是提示重复定义。 原因是：.h文件会被包含多次，相当于

                                             定义多次。

                         正确的做法： 不在.h文件中定义， 而是在.cpp文件中定义。在.h文件中声明。这样就是多次声明。 链接的

　　　　　　　　　　　　　时候会找到这个变量的物理地址。



　　　　　　　注意：  int a ； 　　// 这个也是定义，虽然没有给赋值。extern int a 才是声明

        　　                       extern const int globalINt = 1; 　　 //当这个给它赋值了，也可以看做是定义。

                                       只有当extern声明位于函数外部时，才可以含有初始化式。



　　　　　　　　问题1： 一个源文件定义了 char a[6];  另外一个文件用下列语句进行了声明： extern char *a, 这样可以吗？

　　　　　　　　答案：不可以。因为指向类型T的指针并不等价于类型T数组。提示我们：声明和定义要严格一样的格式。



　　　　　　　　问题2： 如果用extern函数的方式引用全局函数，当函数原型修改后，比如加了个参数，编译居然不报告错。

　　　　　　　　解决方案：通常提供函数放在自己的XX.h文件中声明和这个函数，其他的调用方include该头文件，从而省去

　　　　　　　　　　　　　extern这一步，可以避免上述错。



**71： extern "C "**

　　#ifndef XXXXXXX

　　#define XXXXXXX //避免重复包含头文件， #pragma once 可以实现同样的功能


　　#ifdef __CPLUSCPLUS

　　　　extern "C"{

　　#endif

　　　　#ifdef __cplusplus

　　}

　　#endif

　　# endif

**72 C和 c++ 互相调用**

　　因为C++ 重载，而C不重载，函数名编译的结果都不一样。 

　　如果C++ 直接调用C的函数，因为二者编译的不同，就会失败。

　　C++ 调用C： 比在一个.h文件中有个 foo(int),其实现是在 .c中，

　　　　　　　　当C++ 包含这个.h文件的时候就要用extern "C"， 否则编译器编译的不一样，根本调用不到。

　　　　　　　　c++ 调用一个C语言编写的DLL时，当包括.DLL的头文件或声明接口函数时，应加入extern "C"

        c调用C++ ： 非类成员函数的话，就用extern “C”；

                              如果要调用成员函数（虚函数，重载函数），可以提供封装函数，封装函数内部调用实际的东西。

**73 字符数组和字符串    **

        注意最后一个'\0'.

　　char str[10] =  {'a','b','c'}  // 不是以 '\0'结尾

　　char *p = "abc";   // 是以'\0'结尾

**74 static 文件作用域的问题   **

　　当同时编译多个文件时，所有未加static的全局变量和函数都是全局可见的（其他文件加上的extern就行）。

　　用static修饰全局变量，可见性就是本文件，这样可以在不同的源文件中定义同名的函数和变量，不担心冲突。

　　static函数： 主要就是为了隐藏（只在本文件中可以看到）。

　　static变量： 一是隐藏； 另外是保持变量内容的持久。存储在静态区域的变量会在程序刚刚运行时就完成初始化，

　　                       也是唯一的一次初始化（初始化只是一次，但是可以改变值）

　　static 还有一个作用：默认初始化为0，其实全局变量也是这样的。

**75 字节对齐，类对象占据内存**

　　字节对齐好处：为了提高存取效率，读取int类型的时候，一次读取就OK。否则要高低字节拼接才行。

　　字节对齐：有助于加快计算机的取数速度，否则就得多花指令周期了。宽度为2的基本数据类型都位于能被2整除的地址上，

　　　　　　　 4的位于能被4整除的地址上。


　　struct S2

　　{

　　　int i;

　　　char c;

　　};

　　规律：i 的地址低， C的地址高，结构体是往高地址扩展的。

　　A：结构体变量首地址能被其最宽基本类型成员的大小整除。（首地址能整除）

　　B：结构体每个成员相对于结构体首地址的偏移都是成员大小的整数倍，如有需要，会在成员之间加上填充字节。（偏移量能整除）

　　C:  结构体总大小为结构体最宽基本类型成员的整数倍，如有需要，会在最后一个成员之后加上填充字节。（结尾填充）

　　D：如果成员是复合类型，比如另外一个结构体，应该考虑子成员。


　　但是：还有一个影响sizeof的重要参数还没有提及：pack指令。 

　　#paragma pack(n) // n是字节对齐数，取值是1，2，4，8，16； 默认是8

        如果这个值比结构体成员的sizeof小， 那么该成员的偏移量应该以此为准： 也就是结构体成员的偏移量取二者最小值。

　　下面代码演示了：单独对一个结构体的字节对齐方式进行设置。 

　　#pragma pack(push) // 将当前pack设置压栈保存

　　#pragma pack(2)// 必须在结构体定义之前使用

　　struct S1

　　{

　　char c;

　　int i;

　　};

　　struct S3

　　{

　　char c1;

　　S1 s;

　　char c2

　　};

　　pack影响的的是偏移量。

　　注意：空结构体，空对象的占据空间是1个字节。

　　对于联合体： int从首地址开始占据4个自己； char从首地址开始占据2个字节，有重合。

　　＃include <stdio.h>

　　union

　　{

　　　　int i;

　　　　char x[2];

　　}a;

　　void main()

　　{

　　　　a.x[0] =10; 

　　　　a.x[1] =1;

　　　　printf("%d",a.i);

　　}

**76  进程之间通信**

　　消息队列：存放在内核中，是链表的形式。

　　匿名管道：CreatePipe(); 只能本地使用。管道是半双工的。只能是父子进程之间通信

　　命名管道：也是半双工，但是可在无亲缘关系的进程之间通信。可用于网络通信，可以通过名称引用；支持多客户端链接，双向通信；

　　共享内存（内存映射文件）：CreateFileMapping .创建内存映射文件，是多个进程对同一块物理内存的映射。（因为是共享内存的方式，读写之间有冲突）

　　　　　　　　　　　　　　　共享内存的效率是最高的，因为共享一块都能看见的内存，不用多份拷贝，而且访问共享内存相当于内存中区域一样，

　　　　　　　　　　　　　　　不需要通过系统调用或者切入内核来完成。但是需要字节提供同步措施。一般用信号量解决读写冲突。

       socket: 可以跨越机器

**77 类型转换**

　　隐式类型转换：int 类型 和float类型相加，会转成float

　　显式类型转换：static_cast /   dynamic_cast /  const_cast / reinterpret_cast

　　　static_cast: static_cast <type-id> (expression)主要用于非多态类型之间的转化：

　　　　　　　　　 用于类层次结构中，基类和子类之间指针和引用的转换；

　　　　　　　　　 当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；

　　　　　　　　　 当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；

　　　　　　　　　 基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；

　　　　　　　　　  把void指针转换成目标类型的指针，是极其不安全的；

　　　dynamic_cast: dynamic_cast <type-id> (expression)，因为是动态，主要是考虑多态的问题。

　　　　　　　　　　type-id必须是类的指针，类的引用或者是void*， 如果是指针，expression也是指针；如果是引用，expression也是

　　　　　　　　　　引用。主要用于类层次之间的上行/下行转换，以及类之间的交叉转。在类上行转换的时候和static_cast一样；下行

　　　　　　　　　　转换的时候，比static 安全。 多态类型之间转换，主要使用dynamic_cast, 因为类型提供了运行时信息。 

　　　　　　　　　　class b: Public A

　　　　　　　　　　{};

　　　　　　　　　　B *pb = new B;

　　　　　　　　　　A *Pa = dynamic_cast<A*>(pb); //安全的、



　　　　　　　　　　下面是转换成Void*，A和B没有关系，但是都有虚函数

　　　　　　　　　　void *pV = dynamic_cast<void *>(pA); // pV points to an object of A

　　　　　　　　　　pV = dynamic_cast<void *>(pB); // pV points to an object of B

　　　　　　　　　　// 因为向下转换是不安全的，所以dynimac做检查。这就是动态比静态好的原因。

　　　　　　　　　　如果expression是type-id的基类，使用dynamic_cast进行转换时，在运行时就会检查expression是否真正的指向一个type-id类型的对象，如

                                     果是，则能进行正确的转换，获得对应的值；否则返回NULL，如果是引用，则在运行时就会抛出异常


　　　　const_cast: const_cast <type-id> (expression)

　　　　　　　    　const_cast用来将类型的const、volatile和__unaligned属性移除。常量指针被转换成非常量指针，并且仍然指向原来的对象；

　　　　　　　　    常量引用被转换成非常量引用，并且仍然引用原来的对象


　　　　reinterpret_cast: reinterpret_cast <type-id> (expression)：

　　　　　　　　　　允许将任何指针类型转换为其它的指针类型；听起来很强大，但是也很不靠谱。它主要用于将一种数据类型从一种类型

　　　　　　　　　　转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针，在实际开发中，

　　　　　　　　　　先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原来的指针值；特别是开辟了系统全局

　　　　　　　　　　的内存空间，需要在多个应用程序之间使用时，需要彼此共享，传递这个内存空间的指针时，

　　　　　　　　　　就可以将指针转换成整数值，得到以后，再将整数值转换成指针，进行对应的操作。

static_cast和reinterpret_cast的区别主要在于多重继承，比如:

class A {

public:

int m_a;

};


class B {

public:

int m_b;

};


class C : public A, public B {};

那么对于以下代码：

C c;

printf("%p, %p, %p", &c, reinterpret_cast<B*>(&c), static_cast <B*>(&c));

前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。

因此, 你需要谨慎使用 reinterpret_cast.

注意：reinterpret_cast， 操作符修改了操作数类型,但仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换。

**78 虚函数表**

　　注意： 如果没有虚函数，那么就没有这个虚函数表的指针。虚函数表的指针（占4字节大小）影响sizeof的结果。

　　v-Table: 虚函数的地址表。在有虚函数的类实例中，这个表被分配在了这个实例的内存中，当用父类型指针操作

　　　　　　一个子类的时候，这张虚函数表像一个地图一样，指明了实际调用的函数。

　   C++ 编译器保证：虚函数表的指针存在于对象实例中最前面的位置。

　　class Base {

　　public:

　　virtual void f() { cout << "Base::f" << endl; }

　　virtual void g() { cout << "Base::g" << endl; }

　　virtual void h() { cout << "Base::h" << endl; }

　　};

　　typedef void(*Fun)(void);

　　Base base;

　　Fun pFun = NULL;

　　cout << "虚函数表地址" << (int*)(&base)<< endl; 

　　cout << "虚函数表第一个函数地址：" << (int*)*(int*)(&base) << endl;

　　pFun = (Fun)*((int*)*(int*)(&base));

　　pFun();

　　虚函数表最后有一个结尾标志。

　　一般继承(无虚函数覆盖)：

　　总结：A: 虚函数表按照其声明的顺序放在表中。

　　           B: 父类的虚函数在子类的虚函数前面。

　　一般继承（有虚函数覆盖）：

　　总结：子类的覆盖的函数放在原来虚函数的位置。

　　            没有被覆盖的函数依旧。

　　多重继承（无函数覆盖）：情况比较复杂（多张虚函数表，所以也有多个指向不同函数表的指针）

　　总结： 每个父类都有自己的虚表；子类的成员函数放到了第一个父类的虚表中。（所谓的第一个父类是按照声明顺序来判断的。）

*        多重继承（有虚函数覆盖） ：　　多个父类虚函数表中的被覆盖的函数都会替换成子类的函数指针。这样我们就可以任一静态类型的父类来指向子类。　　安全线： 用父类的指针访问子类对象的非覆盖函数，会报错。　　虚函数如果是private的，但是可以通过虚函数表来访问的到的。*

**79 多重继承的二义性**

　　多个父类中有相同名称的变量或者函数。子类中要指明是哪个父类的。

　　子类中同名的函数会覆盖父类的。

        子类如果和父类函数同名但是参数不同，子类会覆盖父类，但是用using （using Base::fun;）是可以实现父类和子类重载的

**80 菱形继承**

　　N是基类（包含a成员和函数display），A和B分别继承N，C继承A和B。 

　　A 和B 中都有a的存储空间。可以通过A和B做限定： c.A::a 和 c.B::display();

**81 为什么用 exit()函数**

　　是历史原因，虽然现在大多数平台下，直接在 main() 函数里面 return 可以退出程序。但是在某些平台下，在 main() 函数里面 return 会导致程序永远不退出（因为代码已经执行完毕，程序却还没有收到要退出的指令）。换句话说，为了兼容性考虑，在特定的平台下，程序最后一行必须使用 exit() 才能正常退出，这是 exit() 存在的重要价值。

exit(1)表示进程非正常退出. 返回 1;

exit(0)表示进程正常退出. 返回 0.

在unix下的多进程中,n是该进程返回给父进程的值

在main函数中exit(0)等价于return 0.

**82 广义表**

非线性的数据结构，是线性表的一种推广。广义表中放松对表元素的原子限制，容许它们

具有自身的结构。人工智能领域的表处理语言LISP语言中，广义表是一种基本的数据结构，

广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。

其中：

①ai 或者是原子或者是一个广义表。

②广义表通常记作：

Ls=( a1，a2，…，ai，…，an)。

③Ls是广义表的名字，n为它的长度。

④若ai是广义表，则称它为Ls的子表。

注意：

①广义表通常用圆括号括起来，用逗号分隔其中的元素。

②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。

③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表尾。

④广义表是递归定义的[1]

① E=()

　　E是一个空表，其长度为0。

② L=(a，b)

　　L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表

③ A=(x，L)=(x，(a，b))

　　A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L。

一个表的"深度"是指表展开后所含括号的层数。

((a,b,(c,(d,e),f)),g) 的深度是4。

广义表的存储结构：

头尾表示法： 表中的数据可能是列表，也可能是单元素，所以节点的结构有两种：一种是表节点，表示列表；另外一种

是元素节点，用来表示单元素。

A：表节点：包括一个指向表头的指针和指向表尾的指针。

B：元素节点：

C：还需要一个标志位，0表示元素；1表示表节点。

孩子兄弟表示法：两种节点形式，一种是有孩子节点，表示列表；另外一种是无孩子节点，用来表示单元素。

在有孩子节点中包括一个指向第一个孩子的指针，和一个指向兄弟节点的指针

无孩子节点中包括一个指向兄弟的指针和该元素的元素值。

为了能区分这两类节点，在节点中还要设置一个标志域：标志1表示有孩子节点，标志0，则

表示无孩子节点。

**83 广义表（（a,b）,c,d）表头和表尾分别是？**

头（a，b） // 第一个

表尾（c，d） // 除了第一个剩下的加上括号就是表尾。

**84 堆和栈区别**

　　A 管理方式： 栈：编译器管理； 堆：程序释放，容易泄露。

　　B 空间大小： 栈：默认是1M， 堆：可以看做没有限制。 

　　C 是否产生碎片：栈：没有碎片。 堆：产生碎片。

　　D 生长方向：栈：向内存地址减小的方向； 堆： 地址增大的方向。

　　E 分配方式： 栈：有静态分配 堆：都是动态分配的。

　　F 分配效率： 栈：寄存器存了栈的地址，压栈/出栈有专门的指令，栈的效率很高。 

　　　　　　　　堆：分配、管理内存的算法复杂，空闲链块查找，合并，用了后，要更新

　　　　空闲链块的记录。效率低。 如果碎片太多，可能还要像OS申请更多内存。



