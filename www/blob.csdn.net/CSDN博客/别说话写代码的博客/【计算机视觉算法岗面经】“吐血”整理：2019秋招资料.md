# 【计算机视觉算法岗面经】“吐血”整理：2019秋招资料 - 别说话写代码的博客 - CSDN博客





2018年10月30日 14:33:34[别说话写代码](https://me.csdn.net/qq_21997625)阅读数：107标签：[秋招面试总结																[算法面试总结](https://so.csdn.net/so/search/s.do?q=算法面试总结&t=blog)](https://so.csdn.net/so/search/s.do?q=秋招面试总结&t=blog)
个人分类：[计算机视觉](https://blog.csdn.net/qq_21997625/article/category/7782165)








转自：[https://blog.csdn.net/liuxiao214/article/details/83043170](https://blog.csdn.net/liuxiao214/article/details/83043170)

感谢整理，侵删

//2018/09/27

兵荒马乱、浩浩荡荡的秋招终于差不多要结束了。

秋招这段时间真是感慨很多，一时得意一时失意，还要平衡一不小心就来的心理落差。

先写点废话吧，毕竟最近感受挺多的，在自己的博客里也不用顾忌措辞。强行给自己灌一波鸡汤~

1、努力永远和收获成正比，即使这个比率很小。一直觉得自己没有特别的天赋，只能一点一点努力，而这点努力还经常被“比你优秀的人比你更努力”所击溃。但这又怎样呢，不努力连现在的自己都超越不了。个人觉得“比上不足”比“比下有余”更有分量。

2、向优秀的人看齐。忘记在哪看的一句话了，“当你超过别人一点点时，他们会嫉妒你，当你超过别人一大截时，他们只会羡慕你”，是啊，因为换位思考放在自己身上也是这样，我会嫉妒何恺明，嫉妒陆奇吗，很明显不会，我只会仰望。还是要脚踏实地啊。

3、对于秋招，运气真的蛮重要。因为你不知道刚好哪次就是你的人生际遇。但运气也是实力的一部分，若不是之前的厚积薄发，若不是敢于尝试，又哪里有这些机会呢。所以要不要海投呢？看你的精力是否支撑这些，看你想得到什么。

好了，下面整理面经。主要是自己整理的一些经常被问到的问题，然后搜集的一些资料（附了很多链接，如果侵权请告知删除），主要分为几大模块：HR面、深度学习、机器学习、图像处理、数学、计算机基础、C++、Python等。看整理的面经长度就知道哪个模块经常被问到了。

再说下面试基本会问的内容，目前个人所碰到的，占比可能有所不同，有些面试官喜欢问项目，有些喜欢问基础。

介绍项目、实习，一般会问很久，在你介绍中会问各种开放性问题；通常我的面试中这个占很大篇幅，60%-90%；

问算法相关，包括ML\DL\图像处理等的基础知识，占40%-60%，其中大概ML40%，DL10%，图像处理10%；

问数学基础，大部分是概率论，占5%；

问语言，C++，STL容器之类的，占10%；python也会问一点；

编程题，一般2、3题；

Linux命令，一般问几个，不经常问到；

1、HR面

自我介绍

你和竞争者相比的优势是什么

实习收获了什么

从实习导师身上学到了什么

导师给你的意见是什么

从面试官身上学到了什么

.秋招意向的企业有哪些

你为什么想来我们公司?

你来了之后的三年怎么打算的?

讲一讲实习公司的产品架构,比如一个新的需求产生到落地的流程是怎样?

优缺点

介绍项目，难点，从中学到什么，重新做如何改进

期望薪资

自己主动学习过哪些知识，通过什么方式学的

后面打算学习什么知识，为什么

英语怎么样

兴趣

竞赛、考研保研

团队合作遇到的分歧

有没有投过其他公司,有拿到offer吗?

项目中怎么分工的，有遇到过水平低的吗，是怎么沟通的

对你帮助很大的一个人

学习的路径，怎么学习

被批评以后的心里状态

课题研究进展以及创新点、课题遇到的困难

实习经历

是否读博

实习时间

最有挫败感的事

三-五年的规划

人生理想

最成功的一件事

小时候印象最深的一件事

2、深度学习

2.1、Inception系列网络

https://blog.csdn.net/liuxiao214/article/details/81914743

2.2、Resnet系列网络

https://blog.csdn.net/liuxiao214/article/details/81914743

https://blog.csdn.net/u014380165/article/details/71667916

2.3、目标检测系列

RCNN

Fast RCNN

ROI Pooling

https://blog.csdn.net/lanran2/article/details/60143861

https://blog.csdn.net/auto1993/article/details/78514071

Faster RCNN

YOLO

SSD

YOLO V2

YOLO V3

SSD V2

FCN

2.4、主流CNN网络在imagenet上的准确率

2.5、attention机制

https://www.zhihu.com/question/68482809/answer/264070398

https://zhuanlan.zhihu.com/p/31547842

https://blog.csdn.net/yideqianfenzhiyi/article/details/79422857

2.7、loss

- triple loss

- center loss：

https://blog.csdn.net/u014380165/article/details/71181256

https://blog.csdn.net/u014380165/article/details/76946339

https://blog.csdn.net/LIYUAN123ZHOUHUI/article/details/77100650?locationNum=7&fps=1

2.8、Normalization

https://blog.csdn.net/liuxiao214/article/details/81037416

Batch Normalization

Layer Normalization

Instance Normalization

Group Normalization

Switchable Normalization

2.9、NLP系列

RNN

LSTM

2.10、优化方法

https://www.baidu.com/link?url=ws6cxNIhWmVA1gbrUgFMRtACQhCMdYvcwZtLWOZfWZ0Iuujyt5Y4w08KNj7gn2ExUBD4jIybSJ8e3xb95cMWcL6hZXEn4IUJ5mRYnPoQbNC&wd=&eqid=ce9adcb10004685c000000035b5d4fb6

https://blog.csdn.net/chenchunyue11/article/details/51290638

SGD

Momentum

RMSprop

Adam

2.11、最优化方法

1、梯度下降

2、牛顿法

3、拟牛顿法

4、共轭梯度法

https://www.cnblogs.com/happylion/p/4172632.html

https://www.cnblogs.com/shixiangwan/p/7532830.html

https://www.cnblogs.com/hlongch/p/5734105.html

https://www.baidu.com/link?url=8EyCqGYnldJzHuqBBGagV9juEA_nhCYvRElM2Tw0lBdewSmc0qshAy_AHAEegO-wT3vLsrcY1xSDdyLOmL09Ltm_UICAFX_C02QdkkSCcWW&wd=&eqid=ce9adcb10004685c000000035b5d4fb6

2.12、上采样、反卷积

https://blog.csdn.net/a_a_ron/article/details/79181108

https://blog.csdn.net/amor_tila/article/details/75635283

https://www.cnblogs.com/cvtoEyes/p/8513958.html

2.13、有哪些激活函数，各自的优缺点

https://blog.csdn.net/nuannuanyingying/article/details/70064353

https://blog.csdn.net/yangdashi888/article/details/78015448

2.14、过拟合是什么，如何处理过拟合

2.15、你认为深度学习是最好的算法吗？有哪些场景不适合深度学习？

2.16、数据不完美问题

数据不均衡问题：

https://www.cnblogs.com/zhaokui/p/5101301.html

数据缺失标签：

2.17、BP算法推导

2.18、全连接层的作用

https://www.zhihu.com/question/41037974

全局平均池化

https://blog.csdn.net/qq_23304241/article/details/80292859

2.19、softmax、softmax loss、cross cronty

https://blog.csdn.net/u014380165/article/details/77284921

https://blog.csdn.net/jasonzzj/article/details/52017438

https://blog.csdn.net/u012494820/article/details/52797916

https://www.zhihu.com/question/41252833

https://zhuanlan.zhihu.com/p/27223959

https://zhuanlan.zhihu.com/p/35709485

2.20、为什么训练不收敛，如何解决

https://www.zhihu.com/question/38035648

https://www.zhihu.com/question/64966457

https://blog.csdn.net/andylei777/article/details/72911189

2.21、不收敛和过拟合的区别

https://blog.csdn.net/limiyudianzi/article/details/79626702

2.22、SGD参数设置，权值衰减是什么意思

http://www.sohu.com/a/209594012_610300

https://www.baidu.com/link?url=qzplPMRt1nQem66hMNLsJIJUxdVz2k5cKuXWw4uiERe2wxPvFB7gmU3NccDyesjd_PX4LIL-8WnLtt5UFqz-nK&wd=&eqid=d2a6ab69000357f3000000045b67f14c

https://zhuanlan.zhihu.com/p/23906526

https://www.zhihu.com/question/24529483

https://zhuanlan.zhihu.com/p/38709373

2.23 LSTM和naive RNN的区别

2.24 人脸识别

2.25 OCR技术

2.26 深度学习在图像领域效果为什么这么好

2.27 DL和ML的区别

统计机器学习需要人工设计特征，特征工程很重要

深度学习可以自动学习特征，特别是在图像、语音、文本方面，这些数据都有局部和整体关系，DL能发挥很大作用。

2.28 卷积实现、反向传播如何做

CNN的核心是什么？卷积操作是怎样进行的？卷积反向传播过程？Tensorflow中卷积操作是怎样实现的？

池化又是怎样操作的，反向传播过程中池化层怎么接受后面传过来的损失的

2.29 conv、pool反向传播怎么做

max 怎么知道坐标

http://www.cnblogs.com/pinard/p/6494810.html

https://www.zhihu.com/question/58716267

https://blog.csdn.net/junmuzi/article/details/53206600

https://blog.csdn.net/Jason_yyz/article/details/80003271

2.30 卷积层参数量、计算量是多少

https://blog.csdn.net/dzkd1768/article/details/72763659

https://blog.csdn.net/mtj66/article/details/80509713

2.31 感受野的计算

https://www.cnblogs.com/objectDetect/p/5947169.html

2.32 轻量型网络

https://blog.csdn.net/liuxiao214/article/details/81875251

mobileNet

https://blog.csdn.net/t800ghb/article/details/78879612

https://blog.csdn.net/wfei101/article/details/78310226

2.33 LSTM用在行为识别为什么不好

https://blog.csdn.net/stdcoutzyx/article/details/79117869

2.34 为什么梯度反方向是函数值下降最快的方向？

https://blog.csdn.net/yizhen_acmer/article/details/54670733

2.35 bagging和dropout

https://blog.csdn.net/m0_37477175/article/details/77145459

bagging：取多组训练数据，用相同的算法训练不同的模型；

dropout：每个batch随机抑制一部分神经元，相当于做了不同的模型；

2.36 ResNext

resnext：https://arxiv.org/pdf/1611.05431.pdf

https://blog.csdn.net/u014380165/article/details/71667916

http://www.360doc.com/content/17/0214/19/36492363_628998225.shtml

https://www.baidu.com/link?url=C2hA3ksVRYT-9cSneynsaSpoTjtwshlHNtfXDWnoag3etKgBs2PJvMV2FGO4Lx8gKe1-DQwPWCRWaZuqxg_wYoj59nf5pIPVCvfQvElxCnW&wd=&eqid=a3c0c32500021e6f000000035b7a3742

2.37 senet

senet：https://arxiv.org/pdf/1709.01507.pdf

https://blog.csdn.net/xjz18298268521/article/details/79078551

http://www.sohu.com/a/161633191_465975

2.38 densenet

densenet：https://arxiv.org/pdf/1608.06993.pdf

https://blog.csdn.net/u014380165/article/details/75142664

https://blog.csdn.net/malele4th/article/details/79429028

2.39 se-resnext

https://yq.aliyun.com/articles/603849#

2.40 各种损失函数 交叉熵多标签分类问题

https://www.jianshu.com/p/ac26866e81bc

https://blog.csdn.net/weixin_37933986/article/details/68488339

https://www.cnblogs.com/houjun/p/8956384.html

https://blog.csdn.net/zhangjunp3/article/details/80467350

smooth l1：

https://www.cnblogs.com/573177885qq/p/6136991.html

triple loss：

https://blog.csdn.net/jcjx0315/article/details/77160273

https://www.jianshu.com/p/46c6f68264a1

https://blog.csdn.net/u011501388/article/details/79206957

center loss

https://blog.csdn.net/u014380165/article/details/76946339

https://blog.csdn.net/wxb1553725576/article/details/80602786

多标签：

http://www.atyun.com/5376.html

https://www.zhihu.com/question/35486862

2.41 线性回归和逻辑回归的区别

https://blog.csdn.net/yunhaitianguang/article/details/43877591

https://blog.csdn.net/viewcode/article/details/8794401

2.42 权重初始化方法有哪些

https://blog.csdn.net/u012328159/article/details/80025785

https://blog.csdn.net/hai008007/article/details/79735491

https://www.baidu.com/link?url=m3U4agdoye6dXuyKQg03ZDbS2sMDDQ1MWsVbqdif7-gwgYj13XK78apTQQy4VgOR0CSLuJpZ4h9vOjJ1nCDSLapS6WwILhv_XbS9FC8kB8S&wd=&eqid=ec827bbf00009ec6000000035b87ad2f

https://blog.csdn.net/fire_light_/article/details/79556192

https://www.cnblogs.com/makefile/p/init-weight.html?utm_source=itdadao&utm_medium=referral

2.43 性能度量方法

2.44 VGG16与resnet152哪个参数量大

https://imlogm.github.io/深度学习/vgg-complexity/

VGG16参数量大，resnet采用了1x1 3x3 1x1卷积方式bottleneck结构

2.45 最小二乘法

https://blog.csdn.net/ACdreamers/article/details/44662633

https://blog.csdn.net/iterate7/article/details/78992015

https://blog.csdn.net/yuxiaoxi21/article/details/71469311

2.46 online hard sample，不均衡样本

标准的faster-RCNN中，假设正样本IOU(0.71.0)。负样本IOU(0.10.3)，hard 负样本IOU(0.0~0.1)。比如实际的RPN网络中，实际最后的anchor经过NMS处理后的负样本是很多的，假如有100000个。而实际训练的正负样本比例为1:3，负样本大概只需要2000-3000个。这时就只选择那些hard负样本，这样实际训练出来的效果最好。

https://blog.csdn.net/qq_16234613/article/details/79794588

https://blog.csdn.net/songhk0209/article/details/71484469

http://www.cnblogs.com/demian/p/9575735.html

2.47 图像库相似度搜索

1、哈希

https://blog.csdn.net/jiandanjinxin/article/details/51281924

2、三种深度学习的方法

https://www.leiphone.com/news/201807/XvuvcU03PkYe7VcQ.html

3、sift特征

https://www.zhihu.com/question/27602122

4、很全的综述文章！！建议看

https://mp.weixin.qq.com/s/sM78DCOK3fuG2JrP2QaSZA

https://mp.weixin.qq.com/s/yzVMDEpwbXVS0y-CwWSBEA

5、一些论文

https://zhuanlan.zhihu.com/p/43569947

https://zhuanlan.zhihu.com/p/34084199

6、深度学习应用

https://www.zhihu.com/question/29467370

2.48 CNN为什么用ReLU，为什么不用sigmoid？

RNNs为什么用tanh不用ReLU？ReLU的问题以及解决方案。

2.49 目标检测 小目标问题

https://www.jianshu.com/p/78f614799cf2

http://blog.51cto.com/yixianwei/2096060

https://blog.csdn.net/maweifei/article/details/81058498

2.50 某个类别准确率不高怎么办，混淆矩阵互分严重怎么办

https://segmentfault.com/q/1010000014379836/

2.51 untrimmed 视频如何处理

可以使用行为检测定位，

https://blog.csdn.net/xiaoxiaowenqiang/article/details/80752849

2.52 精确率很高、召回率很低什么原因，如何解决

数据小物体多，容易漏检，预测的少，但是准

然后就说在多尺度预测，多加anchor之类的

2.53 anchor的意义是什么，为什么不直接用四个坐标做回归

2.54 有个类别的准确率比较低

别的都高，就说明算法没问题，这一类数据有问题

对这个类的数据做一个清洗

2.55 最小二乘法拟合直线，如何拟合直线

2.56 各个框架的比较

https://blog.csdn.net/zuochao_2013/article/details/56024172

https://blog.csdn.net/liyiafeia/article/details/52826600

https://www.cnblogs.com/leoking01/p/7211645.html

2.57 如何用softmax和sigmoid来做多类分类和多标签分类

https://blog.csdn.net/u011734144/article/details/80915559

2.58 小样本学习

https://blog.csdn.net/mao_feng/article/details/78939864

http://www.elecfans.com/d/695496.html

http://chuansong.me/n/2131635951225

2.59 eigenface fisherface

1、eigenface

https://blog.csdn.net/zouxy09/article/details/45276053

https://blog.csdn.net/smartempire/article/details/21406005

2、fisherface

https://blog.csdn.net/smartempire/article/details/23377385

https://www.cnblogs.com/little-monkey/p/8118938.html

常用概念

2.60 移动端应用问题

2.60.1 项目线上部署怎么办？有些包线上好装，但无法访问外网时除了离线安装还有什么办法？

docker虚拟机也可以，直接部署docker

2.60.2 资料

https://www.jianshu.com/p/53db67dd6c14

http://ai.51cto.com/art/201711/558147.htm

https://www.zhihu.com/question/46523847/answer/101665650

https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NTE4NTUwOQ%3D%3D%26mid%3D2650324711%26idx%3D1%26sn%3D8d833edfa7d856f0fc8db1d82ba0ad11%26scene%3D2%26srcid%3D0519F81hMdHH9R2wiQJQyqJ1%26from%3Dtimeline%26isappinstalled%3D0%26pass_ticket%3DrgAiSWRaxw%2BwO2hGFDol0lFn4Hp6VKBfPRJ8zvT0nCp56cPHQwxoOO45ZghhnAGI

https://zhuanlan.zhihu.com/p/31063235

https://zhuanlan.zhihu.com/p/38276869

https://www.zhihu.com/question/57695571/answer/250062833

https://www.zhihu.com/question/40503595

2.60.3 介绍

一些观点：

观点一：

现阶段 app 上使用的深度学习主要有两种模式：

一种是 online 方式：移动端做初步预处理，把数据传到服务器执行深度学习模型，优点是这个方式部署相对简单，现成的框架（caffe，theano，mxnet，Torch) 做下封装就可以直接拿来用，服务器性能大, 能够处理比较大的模型，缺点是必须联网。

另外一种是 offline 方式：在服务器进行训练的过程，在手机上进行预测的过程。

观点二：

做模型压缩。

观点三：

在移动端，直接拿模型来跑肯定不行，除了软件环境，最重要的其实有两个方面：

第一是存储。为了解决这个问题，在DL领域有相当一部分人在做相关的问题，比如二值网络、网络压缩。其目的就是减少模型的参数规模利于存储。将权重怎么存可能也需要各种技巧吧。

第二是计算。这个跟存储和平台也有一定的关系。以上我提到的这两个工作是object detection领域比较新的且能实时处理的工作。在mobile设备上不可能拿模型直接用，要做一下简化和妥协。另外可行的方案是在服务器端跑模型。

另外还有一个比较有意思的工作是最近有一小部分人在做针对神经网络输入的图像采集设备，直接生成神经网络图片。这样就可以直接在输入端上解决存储的问题。

观点四：

注意三点：1、权重存储；2、计算速度；3、功耗。

三点都很重要，可以看看斯坦福William dally组的工作（删减连接、编码存储、混合精度）

观点五：

可是真正的工业界哪里有这么简单？哪里有现成的数据集？数据集怎么构造？如何清洗？数据体量都是上亿 代码写不好 跑不死你？

部门大量工具都是C写的不会C行只会python行吗？这么大数据 不会Hadoop spark搞得定？这么大数据训练 不会参数服务器 不会分布式搞得定？

模型调参就简单？深度学习是黑箱，就更要有比较高的理论水平，否则你连怎么调参的门道都找不到，为什么不收敛，你都想不出来。

模型训练出来就万事大吉了？模型太重速度太慢 不符合业务需求 怎么办？怎么模型压缩？模型怎么上移动端？移动端没有合适的机器学习架构，你能不能写一个？

一个模型上线就完事了？想进一步提高性能，怎么办？是不是要紧跟学术前沿，能读懂paper，快速实验？这对英语和数学编程都有很高要求。

这说的都是深度学习的，然而很多场景是不适合用深度学习的。那决策树模型，进一步的集成学习，随机森林和GBDT你得懂。统计学习的你得懂，贝叶斯SVM和LR你得懂。有些业务还得用HMM，CRF或者NLP的东西。所以还是要先虚心学习一个。

观点六：

1、移动端的训练问题，一般都是用现成的训练好的模型。

2、模型的参数体积问题

3、模型的计算时间问题

当下还是流行使用服务器训练模型，移动端部署模型前向计算。用移动端进行训练现在的移动设备的内存及计算能力都有点吃力。自己大胆做个猜想：将来可以做成通用模型（服务器训练）加个性化模型（手机上训练）。

至于部署到移动端当然还是会涉及到模型压缩及框架选择。

观点七：

个人总结：

1、服务器端跑模型，移动端给结果，这样做必须联网；

2、压缩模型，将参数权重存储在本地。存储问题需要考虑；

3、框架轻量化；

4、卷积硬件计算加速；

5、优化移动端深度学习引擎；

6、一些优化：使用低层语言；缓存友好：少用内存、连续访问、对齐访问、合并访问；多线程：线程开销、动态调度；稀疏化；定点化；包大小；编译优化；代码精简；模型压缩；内存精简；兼容性与可靠性；

2.60.4

SqueezeNet

https://blog.csdn.net/csdnldp/article/details/78648543

https://blog.csdn.net/u011995719/article/details/78908755

mobileNet

https://blog.csdn.net/t800ghb/article/details/78879612

https://blog.csdn.net/wfei101/article/details/78310226

https://blog.csdn.net/u014380165/article/details/72938047

ShuffleNet

https://blog.csdn.net/u011974639/article/details/79200559

https://blog.csdn.net/u014380165/article/details/75137111

Xception

https://blog.csdn.net/u014380165/article/details/75142710

https://www.baidu.com/link?url=ERPMsc_io0x0usMhZdLD5POp-4p3dHyNtg4z92eeNsIpzxbKJMtmEH39A5op8p2XiQ4CWDPMu03Ygbrs8GAOAK&wd=&eqid=e517c5270000c4ed000000035b7a2a44

上述四个模型总结

xception: https://arxiv.org/abs/1610.02357

shufflenet: https://arxiv.org/pdf/1707.01083.pdf

mobilenet: https://arxiv.org/pdf/1704.04861.pdf

squeezenet: https://arxiv.org/pdf/1602.07360.pdf

https://blog.csdn.net/u011995719/article/details/79100582

https://www.sohu.com/a/233688290_500659

2.60.5 deep compression

https://www.sohu.com/a/233688290_500659

https://blog.csdn.net/zijin0802034/article/details/53982812

2.61 GAN

https://zhuanlan.zhihu.com/p/27295635

https://zhuanlan.zhihu.com/p/26491601

https://zhuanlan.zhihu.com/p/28853704

https://zhuanlan.zhihu.com/p/27663439

https://zhuanlan.zhihu.com/p/28731033

https://github.com/hindupuravinash/the-gan-zoo

https://zhuanlan.zhihu.com/p/30107433

2.62 手动实现卷积操作 矩阵相乘

#include <opencv2/opencv.hpp>

#include <opencv2/highgui/highgui.hpp>

#include <opencv2/core/core.hpp>

using namespace  std;

using namespace  cv;

#if 1

Mat Kernel_test_3_3 = (

    Mat_<double>(3, 3) <<

    0, -1, 0,

    -1, 5, -1,

    0, -1, 0);

void Convlution(Mat  InputImage, Mat  OutputImage, Mat kernel)

{

    //计算卷积核的半径

    int sub_x = kernel.cols / 2;

    int sub_y = kernel.rows / 2;

    //遍历图片  

    for (int image_y = 0; image_y < InputImage.rows - 2 * sub_y; image_y++)

    {

        for (int image_x = 0; image_x < InputImage.cols - 2 * sub_x; image_x++)

        {

            int pix_value = 0;

            for (int kernel_y = 0; kernel_y < kernel.rows; kernel_y++)

            {

                for (int kernel_x = 0; kernel_x < kernel.cols; kernel_x++)

                {

                    double  weihgt = kernel.at<double>(kernel_y, kernel_x);

                    int value = (int)InputImage.at<uchar>(image_y + kernel_y, image_x + kernel_x);

                    pix_value += weihgt*value;

                }

            }

            OutputImage.at<uchar>(image_y + sub_y, image_x + sub_x) = (uchar)pix_value;

            if ((int)pix_value != (int)saturate_cast<uchar>((int)pix_value))

            {

                //cout<<"没有防溢出"<<(int)pix_value<<endl;

                //cout<<"防溢出"<<(int)saturate_cast<uchar>((int)pix_value)<<endl;

                //cout<<"没有防溢出写入了什么？"<<(int)OutputImage.at<uchar>(image_y+sub_y,image_x+sub_x)<<endl;

                //cout<<endl;

            }

        }

    }

}

int main()

{

    Mat srcImage = imread("1.jpg", 0);

    namedWindow("srcImage", WINDOW_AUTOSIZE);

    imshow("原图", srcImage);

    //filter2D卷积

    Mat dstImage_oprncv(srcImage.rows, srcImage.cols, CV_8UC1, Scalar(0));;

    filter2D(srcImage, dstImage_oprncv, srcImage.depth(), Kernel_test_3_3);

    imshow("filter2D卷积图", dstImage_oprncv);

    imwrite("1.jpg", dstImage_oprncv);

    //自定义卷积

    Mat dstImage_mycov(srcImage.rows, srcImage.cols, CV_8UC1, Scalar(0));

    Convlution(srcImage, dstImage_mycov, Kernel_test_3_3);

    imshow("卷积图3", dstImage_mycov);

    imwrite("2.jpg", dstImage_mycov);

    waitKey(0);

    return 0;

}

#else

#endif

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

2.63 iou和NMS代码

https://blog.csdn.net/sinat_34474705/article/details/80045294

import numpy as np

class Bounding_box:

    def __init__(self, x1, y1, x2, y2, score):

        self.x1 = x1

        self.y1 = y1

        self.x2 = x2

        self.y2 = y2

        self.score = score

def get_iou(boxa, boxb):

    max_x = max(boxa.x1, boxb.x1)

    max_y = max(boxa.y1, boxb.y1)

    min_x = min(boxa.x2, boxb.x2)

    min_y = min(boxa.y2, boxb.y2)

    if min_x <= max_x or min_y <= max_y:

        return 0

    area_i = (min_x - max_x) * (min_y - max_y)

    area_a = (boxa.x2 - boxa.x1) * (boxa.y2 - boxa.y1)

    area_b = (boxb.x2 - boxb.x1) * (boxb.y2 - boxb.y1)

    area_u = area_a + area_b - area_i

    return float(area_i) / float(area_u)

def NMS(box_lists, k):

    box_lists = sorted(box_lists, key=lambda x: x.score, reverse=True)

    NMS_lists = [box_lists[0]]

    temp_lists = []

    for i in range(k):

        for j in range(1, len(box_lists)):

            iou = get_iou(NMS_lists[i], box_lists[j])

            if iou < 0.7:

                temp_lists.append(box_lists[j])

        if len(temp_lists) == 0:

            return NMS_lists

        box_lists = temp_lists

        temp_lists = []

        NMS_lists.append(box_lists[0])

    return NMS_lists

box1 = Bounding_box(13, 22, 268, 367, 0.124648176)

box2 = Bounding_box(18, 27, 294, 400, 0.35818103)

box3 = Bounding_box(234, 123, 466, 678, 0.13638769)

box_lists = [box1, box2, box3]

NMS_list = NMS(box_lists, 2)

print NMS_list

print NMS_list[0].x1

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

3、机器学习

3.1 生成模型与判别模型

判别性模型：

支持向量机SVM

传统的神经网络

线性判别分析

线性回归linear regression

逻辑回归logistics regression

神经网络NN

高斯过程Gaussian process

条件随机场CRF

CART（classification and regression tree）

Boosting

生成型模型：

高斯

朴素贝叶斯Native bAYES

混合多项式

混合高斯模型Gaussians

专家的混合物the mixture of experts model

隐马尔科夫模型HM

马尔科夫随机场Markov random fields

判别式分析

K近邻KNN

sigmoid belief networks

深度信念网络DBN

隐含狄利克雷分布简称LDA（Latent Dirichlet allocation）

3.2 Bagging、ensemble、boosting关系

bagging与dropout关系

https://blog.csdn.net/bymaymay/article/details/77824574

https://blog.csdn.net/u014114990/article/details/50948079

https://blog.csdn.net/taoyanqi8932/article/details/54098100

http://www.cnblogs.com/onemorepoint/p/9264782.html

3.3 L1、L2范数，区别是什么，为什么L1范数会趋于0，而L2范数不会。

https://www.zhihu.com/question/37096933

https://blog.csdn.net/zchang81/article/details/70208061

https://blog.csdn.net/pan060757/article/details/73321681

https://www.cnblogs.com/hellcat/p/7979711.html

3.4 偏差、方差

3.5 衡量距离的公式有哪些？

https://blog.csdn.net/u010910642/article/details/51315517

https://blog.csdn.net/xbinworld/article/details/43612603

https://www.iteblog.com/archives/2317.html

https://my.oschina.net/hunglish/blog/787596

欧氏距离、

余弦相似度距离

KL散度：https://blog.csdn.net/ericcchen/article/details/72357411

3.6 鞍点，如何处理鞍点？

鞍点 （saddle point）的数学含义是： 目标函数在此点上的梯度（一阶导数）值为 0， 但从该点出发的一个方向是函数的极大值点，而在另一个方向是函数的极小值点。

判断鞍点的一个充分条件是：函数在一阶导数为零处（驻点）的黑塞矩阵为不定矩阵。

半正定矩阵： 所有特征值为非负。

半负定矩阵：所有特征值为非正。

不定矩阵：特征值有正有负。

3.7 凸优化

http://www.360doc.com/content/18/0522/09/32196507_756021531.shtml

3.8 集成学习方法有哪些

3.9 最大似然估计和贝叶斯估计

3.10 SVM核函数

https://www.zhihu.com/question/21883548

3.11 监督学习、半监督学习、无监督学习

3.12 KNN

3.13 Logistic Regression

3.14 降维方法有哪些？

3.15 聚类算法有哪些，各自优缺点

3.16 朴素贝叶斯

3.17 决策树

3.18 PCA，SVD分解

3.19 强化学习算法有哪些

3.20 RF、GBDT、XGBoost、lightGBM

https://blog.csdn.net/u014248127/article/details/79015803

https://blog.csdn.net/data_scientist/article/details/79022025

https://blog.csdn.net/qq_28031525/article/details/70207918

https://blog.csdn.net/bbbeoy/article/details/79590981

https://www.cnblogs.com/mata123/p/7440774.html

GBDT原理，和RF的区别

https://www.cnblogs.com/peizhe123/p/5086128.html

https://www.cnblogs.com/ScorpioLu/p/8296994.html

https://www.cnblogs.com/ModifyRong/p/7744987.html

https://www.cnblogs.com/EstherLjy/p/9372414.html

3.21 CART、C4.5、ID3 三种决策树的区别

https://blog.csdn.net/lzzdflg/article/details/78649925

https://blog.csdn.net/qq_27717921/article/details/74784400

https://blog.csdn.net/gamer_gyt/article/details/51242815

https://www.cnblogs.com/itmorn/p/7918797.html

3.22 逻辑回归中sigmoid函数的好处？以及为什么用极大似然？

3.23 特征工程

3.24 线性回归

https://blog.csdn.net/lisi1129/article/details/68925799

https://blog.csdn.net/u012535605/article/details/70919993

3.25 逻辑回归

https://blog.csdn.net/zjuPeco/article/details/77165974

3.26 SVM

https://blog.csdn.net/u012990623/article/details/40272619

4、图像处理

4.1 图像特征提取的算法有哪些，各自优缺点、适用范围

https://blog.csdn.net/xiongchao99/article/details/78776629

4.2 图像边缘检测算法

https://www.jianshu.com/p/2334bee37de5

https://blog.csdn.net/KYJL888/article/details/78253053

Roberts算子

Sobel算子

Prewit算子

Canny算子

4.3 霍夫变换

https://www.cnblogs.com/AndyJee/p/3805594.html

https://blog.csdn.net/m0_37264397/article/details/72729423

4.4 图像保边滤波器

https://blog.csdn.net/Trent1985/article/details/80509232

https://blog.csdn.net/eejieyang/article/details/52333112

https://blog.csdn.net/LG1259156776/article/details/51816875

https://blog.csdn.net/u012968002/article/details/44463229

4.5 图像平移

https://blog.csdn.net/qq_25867649/article/details/52131252

https://blog.csdn.net/linqianbi/article/details/78593203

4.6 图像开操作、闭操作

https://blog.csdn.net/learning_tortosie/article/details/80030201

https://blog.csdn.net/water_93/article/details/50859193

https://www.cnblogs.com/daxiongblog/p/6289551.html

4.7 图像旋转

https://www.cnblogs.com/hustlx/p/5245226.html

4.8 最近邻差值、双线性差值

https://blog.csdn.net/ccblogger/article/details/72918354

4.9 图像重建质量评价指标

https://blog.csdn.net/smallstones/article/details/42198049

4.10 光流法

https://blog.csdn.net/longlovefilm/article/details/79824723

https://www.xuebuyuan.com/3203656.html

4.11 图像去噪的方法

https://blog.csdn.net/eric_e/article/details/79504444

4.12 度量图像patch相似度的方法

https://blog.csdn.net/lg1259156776/article/details/47037583/

https://blog.csdn.net/zchang81/article/details/73275155/

https://blog.csdn.net/yangyangyang20092010/article/details/8472257

4.13 传统图像处理CDC做过吗？

4.14 傅里叶变换

4.15 图像融合算法有哪些？

4.16 图像增强算法有哪些

4.17 图像滤波方法

4.18 直方图均衡化

https://www.cnblogs.com/hustlx/p/5245461.html

https://www.cnblogs.com/tianyalu/p/5687782.html

4.19 手动实现卷积

https://blog.csdn.net/qq_32864683/article/details/79748027

https://blog.csdn.net/chaipp0607/article/details/72236892?locationNum=9&fps=1

4.20 LBP

https://blog.csdn.net/quincuntial/article/details/50541815

4.21 HOG

https://blog.csdn.net/zouxy09/article/details/7929348

https://blog.csdn.net/liulina603/article/details/8291093

4.22 haar

https://blog.csdn.net/soaringlee_fighting/article/details/52708638

https://blog.csdn.net/lanxuecc/article/details/52222369

4.23 Harris角点

https://www.cnblogs.com/polly333/p/5416172.html#

https://blog.csdn.net/lwzkiller/article/details/54633670

4.24 sift

https://blog.csdn.net/jaccen2012/article/details/78643286

https://blog.csdn.net/lyl771857509/article/details/79675137

https://blog.csdn.net/abcjennifer/article/details/7639681

4.25 surf

https://www.cnblogs.com/tornadomeet/archive/2012/08/17/2644903.html

https://blog.csdn.net/lyl771857509/article/details/79675137

https://blog.csdn.net/keith_bb/article/details/70225785

4.26 DCT DFT IDFT

1、DCT

https://www.cnblogs.com/helloforworld/p/5283641.html

https://blog.csdn.net/qq_29573053/article/details/78436325

https://blog.csdn.net/qq_20613513/article/details/78744101

2、

https://blog.csdn.net/IMWTJ123/article/details/79831242

4.27 图像目标检测与跟踪

https://blog.csdn.net/try_again_later/article/details/78621720

4.28 图像中求最值

https://blog.csdn.net/qq_15642411/article/details/80486208

4.29 理解图像中的低频分量和高频分量

https://blog.csdn.net/Chaolei3/article/details/79443520

https://blog.csdn.net/missingu1314/article/details/8675434

5、数学

5.1 概率分布

5.2 期望、方差、协方差、相关系数

5.3 假设检验

https://support.minitab.com/zh-cn/minitab/18/help-and-how-to/statistics/basic-statistics/supporting-topics/basics/what-is-a-hypothesis-test/

https://blog.csdn.net/pipisorry/article/details/51182843

https://blog.csdn.net/YtdxYHZ/article/details/51780310

5.4 54张牌，分3组，大王小王同在一组的概率

分成3份 总的分法 M=(C54，18)(C36，18)(C18，18)

大小王在同一份N=(C3，1)(C52，16)(C36，18)*(C18，18) P=N /M=17/53 。

5.5 最大似然估计、贝叶斯估计

https://blog.csdn.net/bitcarmanlee/article/details/52201858

https://www.cnblogs.com/zjh225901/p/7495505.html

https://blog.csdn.net/feilong_csdn/article/details/61633180

5.6

https://www.nowcoder.com/questionTerminal/836b01b7809248b7b6e9c30495d4680e?from=14pdf

假设一段公路上，1小时内有汽车经过的概率为96%，那么，30分钟内有汽车经过的概率为?

48%

52%

80%

96%

一小时有车的概率 = 1 - 一小时没车的概率 = 1 - 两个半小时都没车的概率 = 1 - （1 - 半小时有车的概率）^2

1-(1-x)^2=0.96

x = 0.8

5.7 三门问题

三个宝箱里有一个宝箱里有宝物，两个是空的，你选了一个，主持人打开剩下2个中的一个发现没有宝物，问你换不换

假设A无，B无，C有，

选A，则主持人只会开B，1/3概率；

选B，则主持人只会开A，1/3概率；

选C，则主持人会开A\B，1/3概率；

可见，不换只有1/3的概率中，换的话，有2/3的概率中；

5.8 概率题：抛一个骰子，直到集齐六面，问抛骰子的期望次数。

5.9 概率题：抛色子连续n次正面向上的期望次数。

5.10 一个人向北走了一公里，向东走了一公里，又向南走了一公里，最后回到了最开始的起点，为什么？

南极点，刚好一个等边三角形；

或者是一个一圈距离刚好是1公里的那个地方。向北走之后，达到那个地方，饶了一圈回到这个地方，再向南走回去。

https://blog.csdn.net/Turinglife/article/details/7358061

从逻辑上来讲，题目从好像缺少了一次向西的过程，才可以回到原地。有没有可能向东1公里还在原地，答案是肯定的，如果有一个纬度，绕其一圈恰好是1公里即可实现，所以这样的点有无穷多个，只要找到那个纬度即可。

5.11 一个四位数abcd，满足abcd * 4 = dcba，求这个数

a9没有进位，且为四位数，a只能为1

d9个位数为1，d只能是9

b9后为个位数（9加任何数进位），这个数只能是1或0，排除1，b=0

c9+8的尾数为0，则c*9个位数为2，c=8

a4没有进位，说明a=1或2，但是d4的个位是a，不可能a=1，所以a=2;

d=a4=8;而且没有进位，说明b4+它的可能进位不超过10；

如果b=0：则c*4的个位需要是7，不存在，不符；

如果b=1：则c*4的个位需要是8，存c=2不符合，c=7符合，所以为2178；

如果b=2:则c*4的个位需要是9，不符；

5.12 概率题：一个家庭有两个孩子，已知其中一个是女孩，求另一个也是女孩的概率

(1/21/2)/(1-1/21/2)

=(1/4)/(3/4)

=1/3

5.13 16个球队中随机选2个，在大量选取后，越强的队越容易被选中

5.14 有一个3L、一个5L的桶，请量出4L的水

5L桶装满水，倒入3L桶；此时5L中有2L水，3L桶中有3L水；

3L桶全部倒走，将5L桶的2L水道入3L桶中，此时5L桶中没有水，3L桶中有2L水；

将5L桶倒满水，然后向3L桶中倒水，此时3L桶水已满，5L桶中还剩4L水。

5.15 把1~9这9个数填入九格宫里,使每一横、竖、斜相等。

https://zhidao.baidu.com/question/329122415632328485.html

5.16 一个圆上随机三个点组成锐角三角形的概率

一个圆周上,随机点三个点,这三个点在同一个半圆上的概率是多少?

三个点在同一个半圆时,形成的三角形为直角或钝角三形（自己想为什么）.

不在同一个半圆时,为锐角三角形.

三点在同一半圆的概率是3/4,所以你这题的答案为1/4.

设在圆上任取的3点是A、B、C。圆心为 O

先假定A、B的位置，设弦AB的圆心角为∠α，且∠α属于[0，π].那么满足锐角三角形的C点就要在AO延长线与BO延长线间，所以C点的取值范围只有圆心为α的弧，即概率为：α/（2π）

对任意A、B的位置，C点的概率为对α/（2π）从[0，π]积分，结果是 π/4

关于为什么C点就要在AO延长线与BO延长线间，因为C点如果不在这之间，则ABC三点就会处于同一个半圆中。而处于同一个半圆中的三个点构成直角或者钝角三角形。

6、计算机基础

6.1 进程线程区别

https://www.cnblogs.com/zhuzhu2016/p/5804875.html

地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。

资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。

　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

线程是处理器调度的基本单位，但是进程不是。

两者均可并发执行。

优缺点：

线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。

进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。

6.2 描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。索引的遵循原则：1、最左侧原则，表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据；2、命名短小原则，索引命名过长会使索引文件变大，损耗内存。

普通索引（由关键字KEY或INDEX定义得到索引）：加快数据的查询速度

唯一索引（由关键字UNIQUE把它定义为唯一索引）：保证数据记录的唯一性

主键：一种特殊的唯一索引，在一张表中只能定义一个主键索引，用来标识唯一一条数据，用PRIMARY KEY创建。

联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。

索引可以极大的提高查询访问速度，但是会降低插入，删除，更新表的速度，因为在执行写操作的时候还要操作索引文件。

6.3 TCP传输的可靠性是如何保证的

TCP提供一种面向连接的、可靠的字节流服务。

　 面向连接：意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP。

TCP通过下列方式来提供可靠性：

1、应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。 (将数据截断为合理的长度)

2、当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

(超时重发)

3、当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒 。 (对于收到的请求，给出确认响应) (之所以推迟，可能是要对包做完整校验)

4、 TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 (校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据)

5、既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 (对失序数据进行重新排序，然后才交给应用层)

6、既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。(对于重复数据，能够丢弃重复数据)

7、TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。(TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出)TCP使用的流量控制协议是可变大小的滑动窗口协议。

字节流服务::

两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。

TCP对字节流的内容不作任何解释:: TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释。

7、C++

7.1 多态是什么，怎么实现

https://www.cnblogs.com/dormant/p/5223215.html

https://www.cnblogs.com/Allen-rg/p/6927129.html

https://blog.csdn.net/xy913741894/article/details/52939323

7.2 static

https://www.cnblogs.com/songdanzju/p/7422380.html

7.3 const

7.4 模板

7.5 静态库和动态库

7.6 多态

7.7 引用和指针

7.8 vector实现原理

https://blog.csdn.net/u012658346/article/details/50725933

https://www.cnblogs.com/laodageblog/p/3777563.html

7.9 C++的特性

http://blog.jobbole.com/44015/

https://www.jianshu.com/p/4f58ebc43b82

7.10 手写代码实现一个string类，手写代码实现智能指针类

7.11 多态和继承，构造函数，析构函数等。

7.12 STL低层实现

https://blog.csdn.net/csnd_ayo/article/details/72574924

https://blog.csdn.net/TQH_Candy/article/details/52387714

https://blog.csdn.net/u011408355/article/details/47957481

8、Python

8.1 函数传参会改变参数本身吗

https://blog.csdn.net/u012614287/article/details/57149290

https://blog.csdn.net/qq915697213/article/details/66972836

8.2 xrange 和 range的区别

8.3 为什么python的多线程鸡肋

https://blog.csdn.net/q_l_s/article/details/58072799

https://blog.csdn.net/syh_486_007/article/details/57405254

https://blog.csdn.net/b9q8e64lo6mm/article/details/81031283

什么是全局解释器锁GIL

Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。

在多线程环境中，Python 虚拟机按以下方式执行：

设置GIL

切换到一个线程去运行

运行：

a. 指定数量的字节码指令，或者

b. 线程主动让出控制（可以调用time.sleep(0)）

把线程设置为睡眠状态

解锁GIL

再次重复以上所有步骤

在调用外部代码（如C/C++扩展函数）的时候，GIL 将会被锁定，直到这个函数结束为止（由于在这期间没有Python 的字节码被运行，所以不会做线程切换）。

全局解释器锁GIL设计理念与限制

GIL的设计简化了CPython的实现，使得对象模型，包括关键的内建类型如字典，都是隐含可以并发访问的。锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。

但是，不论标准的，还是第三方的扩展模块，都被设计成在进行密集计算任务是，释放GIL。

还有，就是在做I/O操作时，GIL总是会被释放。对所有面向I/O 的(会调用内建的操作系统C 代码的)程序来说，GIL 会在这个I/O 调用之前被释放，以允许其它的线程在这个线程等待I/O 的时候运行。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）如果某线程并未使用很多I/O 操作，它会在自己的时间片内一直占用处理器（和GIL）。也就是说，I/O 密集型的Python 程序比计算密集型的程序更能充分利用多线程环境的好处。

8.4 解释性语言、编译型语言的区别，python是哪种

https://blog.csdn.net/u014647208/article/details/78329187

--------------------- 

作者：夏洛的网 

来源：CSDN 

原文：https://blog.csdn.net/liuxiao214/article/details/83043170 

版权声明：本文为博主原创文章，转载请附上博文链接！




