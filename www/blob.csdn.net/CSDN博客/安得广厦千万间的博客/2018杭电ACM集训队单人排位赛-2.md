# 2018杭电ACM集训队单人排位赛 - 2 - 安得广厦千万间的博客 - CSDN博客





2018年07月15日 13:12:31[独-](https://me.csdn.net/qq_41713256)阅读数：267








# Problem A Welcome to the Collegiate Programming Contest



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 102    Accepted Submission(s): 82**





Problem Description

Welcome to take part in the first Guangxi Province Collegiate Programming Contest hold by Guilin University of Electronic Technology. Programming contest is a contest played by three programmers with one computer to solve some coding problems. Here you need to solve n problems and you certainly wish to AC them all. The contest begins!





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be one line.

there is an integer n, which indicates the number of problems of this contest.

It is guaranteed that——

T is about 100,

for 100% cases, 1 <= n <= 20.





Output

As for each case, you need to output a single line.

There should be n “AC” in the line separated by n – 1 blanks, as it is shown in the sample.

Please notice that you shouldn’t print extra blank even in the end of the line.





Sample Input
` `
234





Sample Output
` `
AC AC ACAC AC AC AC





Source
` `
陈都测试1

水题，输出n个AC

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int main()
{
    int n;
    int t;
    scanf( "%d", &t );
    while ( t-- )
    {
        scanf( "%d", &n );
        for(int i=0;i<n-1;i++ ) printf( "AC ");
        printf( "AC\n" );
    }
    return 0;
}
```

# Problem B Practice



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 96    Accepted Submission(s): 79**





Problem Description

Luras is a contestant of the Guangxi Province Collegiate Programming Contest. And she needs to practice before the contest. It is known that there are n problems in her to do list and every problem has its AC time and AC value. Remember, for each problem, only if Luras has spent all the AC time will she gain the AC value. Now there will be m time to practice. Luras could choose way A: solve problems from shorter AC time to longer AC time; or choose way B: solve problems from bigger value to smaller value. In both way, she must stop practicing once she meets a problem which she could not finish. Now could you tell Luras which way should she choose to gain more AC value during time m?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be 3 lines.

In the first line, there are 2 integers n m, which indicates the number of to do list problems, the practice time respectively.

In the second line, there are n positive integers which is the array a[] representing the AC time array.

In the third line, there are n positive integers which is the array b[] representing the AC value array.

It is guaranteed that——

T is about 100

for 100% cases, 1 <= n <= 4, 1 <= m <= 100, 1 <= a[i], b[i] <= 20

And it is guaranteed for any i and j (i != j), a[i] != a[j] and b[i] != b[j].





Output

As for each case, you need to output a single line.

You need to print “A” if only the way A is better;

You need to print “B” if only the way B is better;

You need to print “SAME” if way A is as good as way B.





Sample Input
` `
33 51 2 31 2 33 41 2 33 4 53 41 2 33 2 1





Sample Output
` `
BASAME

给你n道题目的时间以及分值，有2种做题顺序，一种按时间从小到大做，或者按分值从大到小做，要求用哪种顺序。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct node{
  int t,v;
}a[6];
bool cmp(node a,node b)
{
    return a.t<b.t;
}
bool cmp1(node a,node b)
{
    return a.v>b.v;
}
int main()
{
    int t,n,m;
    scanf( "%d", &t);
    while ( t-- )
    {
        scanf( "%d%d", &n,&m );
        for(int i=0;i<n;i++) scanf( "%d", &a[i].t);
        for(int i=0;i<n;i++) scanf( "%d", &a[i].v);
        sort(a,a+n,cmp);
        int numa=0,ansa=0;
        for(int i=0;i<n;i++)
        {
            if( numa+a[i].t<=m)
            {
                numa+=a[i].t;
                ansa+=a[i].v;
            }
            else break;
        }
        sort(a,a+n,cmp1);
        int numb=0,ansb=0;
        for(int i=0;i<n;i++)
        {
            if( numb+a[i].t<=m)
            {
                numb+=a[i].t;
                ansb+=a[i].v;
            }
            else break;
        }
        if( ansa>ansb ) printf( "A\n" );
        else if( ansa<ansb ) printf( "B\n" );
        else printf ("SAME\n");
    }
    return 0;
}
```

# Problem C Team Match



**Time Limit: 2000/1500 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 134    Accepted Submission(s): 41**





Problem Description

The programming competition not only depends on the programmers, but also directed by the coaches. Mr Z is a coach who direct n players to take part in the Guangxi Province Collegiate Programming Contest. We assume that a team is consisted of 3 players whose ability is x, y, z respectively and x >= y >= z. Then the team’s total ability is 3 * x + 2 * y + 1 * z; And for a team, if its ability is not lower than the gold medal level m, the team will certainly win the gold medal. Mr Z would like to match teams to gain as many gold medals as possible, could you tell him how many gold medals it is?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be 2 lines.

In the first line, there are 2 integers n m, which indicate the number of players, the gold medal level respectively. Please remember n is always the multiple of 3.

In the second line, there are n integers which represents everyone’s ability.

It is guaranteed that——

T is about 100.

for 100% cases, 1 <= n <= 15, 1 <= m <= 30, 1 <= a[i] <= 20.





Output

As for each case, you need to output a single line.

There should be an integer in the line which means the gold medal teams Mr Z could match.





Sample Input
` `
26 183 3 3 4 2 26 71 1 1 1 1 1





Sample Output
` `
20

贪心+暴力

给你一些人的能力值，3个人去比赛，最大的能力值*3+最小能力值+剩下能力值*2>=m的最多有几种，每个人只能选一次

先枚举最大的人的能力，在满足条件的情况下 我们优先选第二能力者最低的情况，然后是第三能力值最低的情况，

这样可以使剩下的人能满足条件的可能性最大。

如果选当前最大能力的情况下都没有满足要求的，那么我们就可以跳出循环，因为我们是从大往小枚举的。

最后就是标记这个人有没有被取过。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
bool cmp(int a,int b)
{
    return a>b;
}
int main()
{
    int t,n,m;
    int a[30],vis[30];
    scanf( "%d", &t );
    while ( t-- )
    {
        scanf( "%d%d", &n, &m );
        for(int i=0;i<n;i++ ) scanf( "%d", &a[i] );
        sort(a,a+n,cmp);
        memset(vis,0,sizeof(vis));
        int sum=0;
        for(int i=0;i<n;i++)
        {
            if( vis[i]==1 ) continue;
            int x=-1,y=-1,z=-1;
            for(int j=i+1;j<n;j++)
            {
                if( vis[j]==1 ) continue;
                for(int k=j+1;k<n;k++)
                {
                    if( vis[k]==1 )continue;
                    if( 3*a[i]+2*a[j]+a[k]>=m )
                    {
                        x=i; y=j; z=k;
                    }
                }
            }
            if( x==-1 ) break;
            vis[x]=vis[y]=vis[z]=1;
            sum++;
        }
        printf( "%d\n", sum );
    }
    return 0;
}
```

# Problem D Team Name



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 109    Accepted Submission(s): 60**





Problem Description

After all the teams have been matched, what to do next is of course to think about a nice team name. Now it is known that there are n teams taking part in the Guangxi Province Collegiate Programming Contest. And the name of every team is a string consists of English lower characters. Now Luras needs to get her team name, she doesn’t want the name be any consecutive substring of any other teams. And she prefers shorter names. If there are many choices with the shortest length, she would prefer the one which is the smallest lexicographically. Now could you decide the team name for her? We regard string a is lexicographically smaller than string b if there exists such index j that a[i] == b[i] for all i < j and a[j] < b[j].





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be n + 1 lines.

In the first line, there is one integer n, which indicates the number of teams.

Then there will be n strings of the next n lines, indicate the name of every team in each line.

It is guaranteed that—— 

T is about 100.

for 100% cases, 1 <= n <= 100, 1 <= |s|（the length of s）<= 30.





Output

As for each case, you need to output a single line.

There should be one string in the line which means the name Luras will give to her team.





Sample Input
` `
23abc2abcdefghijklmnopqrstuvwxyzaa





Sample Output
` `
dac





Source
` `
陈都测试1

暴力dfs，竟然没有T。



```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
char s[110][32];
char a[32],ans[32];
int n,flag;
void dfs(int p,int k)
{
    if( flag ) return;
    if( p==k )
    {
        a[k]='\0';
        int f=1;
        for(int i=0;i<n;i++)
            if( strstr(s[i],a) )
            {
                f=0; break;
            }
        if( f==1 )
        {
            strcpy(ans,a);
            flag=1;
        }
        return ;
    }
    for(int i=0;i<26;i++)
    {
        a[p]=i+'a';
        dfs(p+1,k);
    }
}
int main(){
    int t;
    scanf( "%d", &t );
    while ( t--)
    {
        scanf( "%d", &n );
        for(int i=0;i<n;i++) scanf( "%s",s[i] );
        flag=0;
        for(int i=1;i<=31;i++)
        {
            dfs(0,i);
            if( flag ) break;
        }
        printf( "%s\n", ans );
    }
    return 0;
}
```

# Problem E Travel



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 132    Accepted Submission(s): 62**





Problem Description

It is said Guilin's scenery is the best in the world. Now since the first Guangxi Province Collegiate Programming Contest is held in Guilin, Luras decided to travel around Guilin. She knows that there will be n nodes in the travel map. Luras will pick a shortest way to go from node 1 to node n. You are a city designer who could decide if there is a bi-directional edge with the length of 1 between every two nodes. And you hope to build the roads to make the shortest path from 1 to n to be as many as possible. Could you tell Luras how many shortest path could it be at most between node 1 and node n in your final city graph?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be one lines

In the line, there is 1 integer n, which indicates the number of node.

It is guaranteed that——

T is about 100.

for 100% cases, 2 <= n <= 40.





Output

As for each case, you need to output a single line.

There should be one integer in the line which means the maximum shortest path could be between node 1 and node n.





Sample Input
` `
6 2 3 4 5 6 7





Sample Output
` `
1 1 2 3 4 6





Source
` `
陈都测试1

给你n个点，要求1到n节点的最短路径的条数最多。

先构想一个图，起点和终点已经确定，要求最短路尽量多，那么我们就把剩下对的数排成 u列，两列之间的所有点都有连线。

这样最短路径的条数最多，为每一列节点数的乘积，所有列的和为n-2.

于是就变成了一个数论题，一些数的和为k，求他们乘积的最大值。

当k小于等于4时，最大为他本身。

k等于5时：2*3

k等于6时：3*3

k等于7时，3*2*2=3*4

结论是尽量多的拆成3，剩下2个时，乘以2，剩下1个时，乘以4（那一个3过来凑）。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int qpow(int a,int b)
{
    int ans=1;
    while ( b)
    {
        if( b&1 ) ans=ans*a;
        a=a*a;
        b/=2;
    }
    return ans;
}
int main()
{
    int n,t;
    scanf( "%d", &t );
    while ( t-- )
    {
        scanf( "%d", &n );
        n-=2;
        int ans;
        if( n<=4 ) printf( "%d\n",n?n:1);
        else
        {
            int k=n/3;
            if( n%3==0 )
                ans=qpow(3,k);
            else if( n%3==2 )
                ans=qpow(3,k)*2;
            else ans=qpow(3,k-1)*4;
            printf( "%d\n",ans );
        }
    }
    return 0;
}
```

# Problem F Stadium



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 176    Accepted Submission(s): 52**





Problem Description

Before the contest, of course, we should arrange the field first. As the first Guangxi Province Collegiate Programming Contest, the organizer intends to arrange the site as a trapezoidal building. The four sides of the trapezoid are known as a, b, c and d, and if there are many cases, it is the largest area one. Can you figure out the area of this trapezoid?





Input

The first line is an integer T which indicates the case number.

And as for each case,

the first line are four integers a, b, c, d which indicates the four sides of the trapezoid.

It is guaranteed that——

T is about 100.

for 100% cases, 1 <= a, b, c, d <= 10000, and a, b, c, d are all different.





Output

As for each case, you need to output a single line.

There should be an “IMPOSSIBLE” in the line if the four sides can’t form a trapezoid,

or you should output one real number, and round off two decimal places, represents the largest area of the trapezoid.

Assume the answer is ans, you could print by using function printf("%.2f\n", ans); in C++ and some similar functions in other languages.





Sample Input
` `
3 1 2 3 4 1 2 3 5 1 2 3 6





Sample Output
` `
4.71 4.36 IMPOSSIBLE





Source
` `
陈都测试1

给你梯形的4条边，求能组成的最大面积。



判断能否组成梯形的方法跟 三角形一样。

枚举上下底边，然后推公式求出面积。



```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
bool cmp(int a,int b)
{
    return a>b;
}
int main(){
    int n,a[4];
    scanf( "%d", &n );
    while ( n-- )
    {
        scanf( "%d%d%d%d", &a[0], &a[1], &a[2], &a[3] );
        sort(a,a+4);
        if( a[0]+a[1]+a[2]<=a[3])
        {
            printf( "IMPOSSIBLE\n" );
            continue;
        }
        double ans=-1;
        for(int i=0;i<4;i++)
            for(int j=i+1;j<4;j++)
              for(int p=0;p<4;p++)
                for(int q=0;q<4;q++)
              {
                  if( i!=p&&i!=q&&j!=p&&j!=q&&p!=q)
                  {
                      double k=1.0*(a[p]*a[p]-a[q]*a[q])/(a[i]-a[j]);
                      double u=1.0*(a[i]-a[j]-k)/2;
                      if( a[q]>u )
                      {
                          double h=sqrt(a[q]*a[q]-u*u);
                          ans=max(ans,h*(a[i]+a[j])/2);
                      }
                  }
              }
        printf( "%.2f\n", ans );
    }
    return 0;
}
```

# Problem G Balloons



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 120    Accepted Submission(s): 37**





Problem Description

The competition is going. Besides the players, volunteers are busy too, they need to send colorful balloons to the contestants. It is known that the contestants are in a huge room of cartesian coordinate system whose seats are 1000 rows multiplying 1000 columns. Every seat could be empty or corresponds to a team. For every minute, volunteers should send all the balloons together. The volunteers will be told where to send each balloon to. They would like to work efficiently. For two positions (r1, c1) and (r2, c2), if the absolute value of (x1 - x2) is not bigger than k or the absolute value of (y1 – y2) is not bigger than k, the two balloons will be sent by a same volunteer. Could you decide how many volunteers are needed at least to send all the balloons?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be n + 1 lines.

In the first line, there are 2 integers n k, which indicates the number of balloons and the value k.

Then there will be n lines, in every line, there are 2 integers r c which means this balloon will be sent to the r-th row and the c-th column. Please notice that the position could be the same.

It is guaranteed that——

T is about 100.

for 100% cases, 1 <= n <= 10000, 

1 <= k, r, c<= 1000.





Output

As for each case, you need to output a single line.

There should be one integer in the line which means the minimum volunteers are needed.





Sample Input
` `
2 3 5 1 1 10 6 15 20 2 5 1 1 7 7





Sample Output
` `
1 2



并查集：

先对x坐标排序，遍历过去，把距离小于m的合并起来，在对y排序，把距离小于m的合并起来，最后算集合的个数。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct node{
   int x,y,id;
}a[10005];
int f[10005];
int findd(int n)
{
    if( f[n]==n ) return f[n];
    else return f[n]=findd(f[n]);
}
bool cmp(node a,node b)
{
    return a.x<b.x;
}
bool cmp1(node a,node b)
{
    return a.y<b.y;
}
int main(){
    int t, n, m;
    scanf( "%d", &t );
    while ( t-- )
    {
        scanf( "%d%d", &n, &m );
        for(int i=0;i<n;i++) f[i]=i;
        for(int i=0;i<n;i++)
        {
            scanf( "%d%d", &a[i].x, &a[i].y );
            a[i].id=i;
        }
        sort(a,a+n,cmp);
        for(int i=1;i<n;i++)
        {
            if( a[i].x-a[i-1].x<=m)
            {
                int xx=findd(a[i].id);
                int yy=findd(a[i-1].id);
                if( xx!=yy )
                    f[xx]=yy;
            }
        }
        sort(a,a+n,cmp1);
        for(int i=1;i<n;i++)
        {
            if( a[i].y-a[i-1].y<=m)
            {
                int xx=findd(a[i].id);
                int yy=findd(a[i-1].id);
                if( xx!=yy )
                    f[xx]=yy;
            }
        }
        int num=0;
      //  printf( "%d %d\n",findd(0),findd(1) );
        for(int i=0;i<n;i++)
            if( i==findd(i) ) num++;
        printf( "%d\n", num );
    }
    return 0;
}
```



# Problem H Board

**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 82    Accepted Submission(s): 78**






Problem Description

The contest has finished. The work turns into the host now. he needs to read all teams’ names later. We suppose the teams’ names are all single string with only English Characters. Could you help the host to calculate how many English characters should he read in total?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be n + 1 lines.

In the first line, there is 1 integer n, which indicates the number of teams.

Then there will be n strings of the next n lines, indicate the name of every team in each line.

It is guaranteed that——

T is about 100,

for 100% cases, 1 <= n <= 100, 1 <= |s|（the length of s）<= 30.





Output

As for each case, you need to output a single line.

There should be one integer in the line which means the total number of English characters of all teams.





Sample Input
` `
23abbccc2ChikenDinnerNoResponse





Sample Output
` `
622

水题，所有字符串的长度和。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int main()
{
    int t,n;
    char s[110];
    scanf( "%d", &t);
    while ( t-- )
    {
        scanf( "%d", &n );
        int num=0;
        while ( n-- )
        {
            scanf( "%s", s );
            num+=strlen(s);
        }
        printf( "%d\n", num );
    }
    return 0;
}
```

# Problem I Rank LED



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 80    Accepted Submission(s): 27**





Problem Description

The host has released the rank. Everyone’s rank is shown in the LED screen as our Picture. 

![](http://hdu.hustoj.com/data/images/C717-1009-1.jpg)



You could see the light line of number for ‘0’ to ‘9’ is {6、2、5、5、4、5、6、3、7、6} in the order. Luras would like to modify the position of every light line to make her new rank as small as possible while the new rank is also a positive integer without any leading zeros. What’s more, the total number of light lines should be as same as the beginning. Could you tell Luras what the best result she could modify to?





Input

The first line is an integer T which indicates the case number.

And as for each case,  there will be 2 lines.

There is an integer n in the first line which is the length of the number string.

The 2nd line is a number string which is a non-leading zero big positive integer of length n.

It is guaranteed that——

T is about 100.

for 100% cases, 1 <= n <= 100. strings are all non-leading zero number strings.





Output

As for each case, you need to output a single line.

There should be one non-leading zero positive number string in the line which means the best rank Luras could modify to.





Sample Input
` `
3 1 9 2 99 5 10000





Sample Output
` `
6 28 2888



贪心，首先组成的数长度越小越好，在是每一位越小越好，但是首位不能为0.



因为长度最短，我们用8来组成，8需要7根，那么就可以得到数组的长度，

然后从高到低，在不影响数字长度的情况下选择尽量小的数，但是第一位不能为0.

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10] = { 6,2,5,5,4,5,6,3,7,6 };

int Cal( int x )
{
    if ( x%7==0 )
        return x/7;
    else
        return x/7+1;
}

void dfs( int now , int sum , int idx )
{
    if ( now==idx ) return;
    if ( now!=0&&Cal(sum-6)==idx-now-1 )
    {
        printf ( "0" );
        dfs( now+1 , sum-6 , idx );
        return;
    }
    if ( Cal(sum-2)==idx-now-1 )
    {
        printf ( "1" );
        dfs( now+1 , sum-2 , idx );
        return;
    }
    if ( Cal(sum-5)==idx-now-1 )
    {
        printf ( "2" );
        dfs( now+1 , sum-5 , idx );
        return;
    }
    if ( Cal(sum-4)==idx-now-1 )
    {
        printf ( "4" );
        dfs( now+1 , sum-4 , idx );
        return;
    }
    if ( now==0&&Cal(sum-6)==idx-now-1 )
    {
        printf ( "6" );
        dfs( now+1 , sum-6 , idx );
        return;
    }
    if ( Cal(sum-3)==idx-now-1 )
    {
        printf ( "7" );
        dfs( now+1 , sum-3 , idx );
        return;
    }
    if ( Cal(sum-7)==idx-now-1 )
    {
        printf ( "8" );
        dfs( now+1 , sum-7 , idx );
        return;
    }
}

int main()
{
    for ( int T ; scanf ( "%d" , &T )==1 ; )
    {
        while ( T-- )
        {
            int n; scanf ( "%d" , &n );
            int sum = 0; char s[110];
            scanf ( "%s" , s );
            for ( int i=0 ; i<n ; i++ )
                sum += a[s[i]-'0'];
            int idx = Cal(sum);
            dfs ( 0 , sum , idx );
            printf ( "\n" );
        }
    }
    return 0;
}
```

# Problem J Pot



**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 115    Accepted Submission(s): 74**





Problem Description

The rank has been released. Luras is unhappy because she has not achieved her desired result. So she wants to throw her responsibility to her teammates, so it is the same with her teammates, they would also throw their responsibility to her. There are n members of her team, each has committed a certain degree of mistakes which is called "pot." And the severity of the error is called the size of the "pot." If the pot sizes of A and B are x and y respectively (we assume x > y), then A can divert attention by blaming B, making the size of his pot becoming x – y instead of x. 

As it is a team, every member would cooperate together to throw their pots in the best orderly way to make the sum of all pots to be as small as possible. Could you help her calculate what the sum is?





Input

The first line is an integer T which indicates the case number.

And as for each case,

the first line is an integer n which indicates the number of people in her team,

the second line contains n positive integers, which indicates the size of the pot of each person.

It is guaranteed that——

T is less than 100,

for 100% cases, 1 <= n <= 100. 

1 <= the size of the pot of each person <= 100.





Output

As for each case, you need to output a single line.

There should be only one integer in the line which indicates the minimum sum of all pots in the end.





Sample Input
` `
5 3 2 4 6 2 12 18 5 45 12 27 30 18 2 1 2 1 9





Sample Output
` `
6 12 15 2 9



水题，一直减，减到所有数相同为止，输出最后的和。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int a[110];
int bin(int n)
{
    for(int i=0;i<n;i++)
        if( a[i]!=a[0] ) return 1;
    return 0;
}
int main()
{
    int t,n;
    scanf( "%d", &t );
    while ( t-- )
    {
        scanf( "%d", &n );
        for(int i=0;i<n;i++)
            scanf( "%d", &a[i] );
        while ( bin(n) )
        {
            int tmp=1000,pos=-1;
            for(int i=0;i<n;i++)
                if( tmp>a[i] )
            {
                tmp=a[i]; pos=i;
            }
            for(int i=0;i<n;i++)
            {
                if( tmp!=a[i] )
                    a[i]-=tmp;
            }
        }
        printf( "%d\n", a[0]*n );
    }
    return 0;
}
```









