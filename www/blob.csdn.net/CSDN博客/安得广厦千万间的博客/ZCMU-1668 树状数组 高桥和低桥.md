# ZCMU-1668: 树状数组 高桥和低桥 - 安得广厦千万间的博客 - CSDN博客





2018年05月26日 21:19:13[独-](https://me.csdn.net/qq_41713256)阅读数：26








[点击打开链接](http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1668)



## Description


 有个脑筋急转弯是这样的：有距离很近的一高一低两座桥，两次洪水之后高桥被淹了两次，低桥却只被淹了一次，为什么？答案是：因为低桥太低了，第一次洪水退去之后水位依然在低桥之上，所以不算“淹了两次”。举例说明：

假定高桥和低桥的高度分别是5和2，初始水位为1

第一次洪水：水位提高到6（两个桥都被淹），退到2（高桥不再被淹，但低桥仍然被淹）

第二次洪水：水位提高到8（高桥又被淹了），退到3。

没错，文字游戏。关键在于“又”的含义。如果某次洪水退去之后一座桥仍然被淹，那么下次洪水来临水位提高时不能算“又”淹一次。

输入n座桥的高度以及第i次洪水的涨水水位ai和退水水位bi，统计有多少座桥至少被淹了k次。初始水位为1，且每次洪水的涨水水位一定大于上次洪水的退水水位。




## Input


 输入文件最多包含25组测试数据。每组数据第一行为三个整数n, m, k（1<=n,m,k<=105）。第二行为n个整数hi（2<=hi<=108），即各个桥的高度。以下m行每行包含两个整数ai和bi（1<=bi<ai<=108, ai>bi-1）。输入文件不超过5MB。




## Output


 对于每组数据，输出至少被淹k次的桥的个数。




## Sample Input

2 2 2

2 5

6 2

8 3

5 3 2

2 3 4 5 6

5 3

4 2

5 2

## Sample Output

Case 1: 1

Case 2: 3

每次被桥被淹的高度都在一个范围内，桥的高度应该大于上一次洪水退的高度，小于等于这一次洪水的高度。

那么我们就要对桥排序，每次对一段范围内的桥加一，最后统计超过k次的数目。

AC代码：



`#include<iostream>`

`#include<cstring>`

`#include<string.h>`

`#include<cstdio>`

`#include<stack>`

`#include<vector>`

`#include<algorithm>`

`#include<map>`

`#include<cmath>`

`using``namespace``std;`

`typedef``long``long``ll;`

`const``int``mod=1e9;`

`int``h[100010],c[100010];`

`int``n,m,k;`

`int``lowbit(``int``x) {``return``x&(-x); }`

`void``updata(``int``x,``int``v)`

`{`

`    ``for``(``int``i=x;i<=n;i+=lowbit(i))`

`        ``c[i]+=v;`

`}`

`int``getsum(``int``x)`

`{`

`    ``int``sum=0;`

`    ``for``(``int``i=x;i>0;i-=lowbit(i))`

`        ``sum+=c[i];`

`    ``return``sum;`

`}`

`int``main()`

`{`

`    ``int``i,a,b,cc=1;`

`    ``while``(~``scanf``(``"%d%d%d"``,&n,&m,&k))`

`    ``{`

`        ``for``(i=1;i<=n;i++) ``scanf``(``"%d"``,&h[i]);`

`        ``memset``(c,0,``sizeof``(c));`

`        ``sort(h+1,h+1+n);`

`        ``int``u=1;`

`        ``for``(i=0;i<m;i++)`

`        ``{`

`            ``scanf``(``"%d%d"``,&a,&b);`

`            ``int``p1=upper_bound(h+1,h+1+n,u)-h;`

`            ``if``(p1>n) ``continue``;`

`            ``int``p2=upper_bound(h+1,h+1+n,a)-h;`

`            ``u=b;`

`            ``updata(p1,1);`

`            ``updata(p2,-1);`

`        ``}`

`        ``int``ans=0,sum=0;`

`        ``for``(i=1;i<=n;i++)`

`        ``{`



`            ``if``(getsum(i)>=k) ans++;`

`        ``}`

`        ``printf``(``"Case %d: %d\n"``,cc++,ans);`

`    ``}`

`    ``return``0;`

`}`




