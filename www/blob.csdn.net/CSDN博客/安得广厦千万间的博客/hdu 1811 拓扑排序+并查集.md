# hdu 1811 拓扑排序+并查集 - 安得广厦千万间的博客 - CSDN博客





2018年05月28日 15:35:59[独-](https://me.csdn.net/qq_41713256)阅读数：29








题目连接[点击打开链接](http://hdu.hustoj.com/showproblem.php?pid=1811)




自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。

为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。

终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。
同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是"A > B","A = B","A < B"，分别表示A的Rating高于B,等于B,小于B。

现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出"OK"。否则就请你判断出错的原因，到底是因为信息不完全（输出"UNCERTAIN"），还是因为这些信息中包含冲突（输出"CONFLICT"）。
注意，如果信息中同时包含冲突且信息不完全，就输出"CONFLICT"。





Input

本题目包含多组测试，请处理到文件结束。
每组测试第一行包含两个整数N,M(0<=N<=10000,0<=M<=20000),分别表示要排名的人数以及得到的关系数。
接下来有M行，分别表示这些关系





Output

对于每组测试，在一行里按题目要求输出




Sample Input


3 30 > 11 < 20 > 24 41 = 21 > 32 > 00 > 13 31 > 01 > 22 < 1





Sample Output


OKCONFLICT

UNCERTAIN




这里有一个=的情况，就有点麻烦了，用并查集把他们归为一类，最后再用拓扑排序判断3种情况。

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
int x[10010],y[10010],op[10010];
int f[10010],in[10010];
vector<int>edge[10010];
int findd(int n)
{
    if(n==f[n]) return f[n];
    return f[n]=findd(f[n]);
}
int main()
{
    int n,m;
    int a,b,i,j,num;
    char s[5];
    while( ~scanf("%d%d",&n,&m) )
    {
        for( i = 0;i <=n ;i++)
        {
            edge[i].clear();
            f[i]=i;
            in[i]=0;
        }
        num=n;
        for( i = 0 ;i < m; i++)
        {
            scanf("%d %c %d",&x[i],&op[i],&y[i]);
            if(op[i]=='=')
            {
                int xx=findd(x[i]);
                int yy=findd(y[i]);
                if(xx!=yy)
                {
                    f[xx]=yy;
                    num--;
                }
            }
        }
        for( i = 0;i< m; i++ )
        {
            int xx=findd(x[i]);
            int yy=findd(y[i]);
            if(op[i]=='>') edge[xx].push_back(yy), in[yy]++;
            else if( op[i]=='<' ) edge[yy].push_back(xx), in[xx]++;
        }
        queue<int>q;
        for( i = 0 ;i < n ; i++ )
        {
            int ff=findd(i);
            if(in[ff]==0&&i==ff) q.push(i);
        }
        int ss=0;
        while( !q.empty() )
        {
            if(q.size()>1) ss=1;
            int p=q.front(); q.pop();
            num--;
            for(i=0;i<edge[p].size();i++)
            {
                int v=edge[p][i];
                in[v]--;
                if(in[v]==0) q.push(v);
            }
        }
        if(num>0) printf("CONFLICT\n");
        else if(ss) printf("UNCERTAIN\n");
        else printf("OK\n");
    }
}
```




