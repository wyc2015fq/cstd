# ZCMU-1155 树状数组 - 安得广厦千万间的博客 - CSDN博客





2018年05月26日 16:16:48[独-](https://me.csdn.net/qq_41713256)阅读数：30








题目网址：http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1155

此题是树状数组模板题，但是也可以用技巧，好像更快的样子。

先给出树状数组的解

区间更新+单点查询 AC代码：

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9;
int c[1000010];
int n,m;
int lowbit(int x){ return x&(-x); }
void add(int x,int v)
{
    while(x<=n)
    {
        c[x]+=v;
        x+=lowbit(x);
    }
}
int sum(int x)
{
    int res=0;
    while(x)
    {
        res+=c[x];
        x-=lowbit(x);
    }
    return res;
}
int main()
{
    while(scanf("%d",&n)==1)
    {
        if(n==0) break;
        scanf("%d",&m);
        memset(c,0,sizeof(c));
        int a,b;
        while(m--)
        {
            scanf("%d%d",&a,&b);
            add(a,1);
            add(b,-1);
        }
        for(int i=1;i<n;i++) printf("%d ",sum(i));
        printf("%d\n",sum(n));
    }
    return 0;


}

另一种思路：

记录每一个站上车下车的人数。用sum变量记录当前车站的人数，那么下一站的人数就是sum+上次人数-下车人数。

#include<stdio.h>
#include<math.h>
int main(){
     int n;
     while(~scanf("%d",&n)){
        if(n==0) break;
        int s[n+1],x[n+1],sum=0,m,i;
        for(i=0;i<n+1;i++){
            s[i]=0;
            x[i]=0;
        }
        scanf("%d",&m);
        for(i=0;i<m;i++){
            int a,b;
            scanf("%d%d",&a,&b);
            s[a]++;
            x[b]++;
        }
        for(i=1;i<n;i++){
            sum+=s[i];
            sum-=x[i];
            printf("%d ",sum);
        }
        sum+=s[i];
        sum-=x[i];
        printf("%d\n",sum);
     }
    return 0;
}




