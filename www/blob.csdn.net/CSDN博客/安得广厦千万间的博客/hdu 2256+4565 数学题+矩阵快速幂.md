# hdu 2256+4565 数学题+矩阵快速幂 - 安得广厦千万间的博客 - CSDN博客





2018年05月28日 17:09:03[独-](https://me.csdn.net/qq_41713256)阅读数：59








题目：[点击打开链接](http://hdu.hustoj.com/showproblem.php?pid=2256)[点击打开链接](http://hdu.hustoj.com/showproblem.php?pid=4565)

赤裸裸的数学题

![](https://img-blog.csdn.net/20180528170237440)


![](https://img-blog.csdn.net/20180528170840896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzEzMjU2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


直接是矩阵快速幂，答案就是2Xn。

但是这里有一点，有些同学会想。鸡肉Xn和Yn都已经求出来了，那直接用 Xn+Yn*sqrt（b）不就是好了？结果题目良心，连样例都不让你过。因为sqrt（b）是浮点数。你取上限怎么取？，，肯定会有误差。所以不对。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a=5,b=24,m=1024;
struct matx{ ll ar[2][2]; };
matx fx(matx aa,matx bb)
{
    matx ans;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
        {
            ans.ar[i][j]=0;
            for(int k=0;k<2;k++)
             ans.ar[i][j]=(ans.ar[i][j]+aa.ar[i][k]*bb.ar[k][j])%m;
        }
    return ans;
}
ll qu(ll n)
{
    matx di,ans;
    di.ar[0][0]=a; di.ar[0][1]=b;
    di.ar[1][0]=1; di.ar[1][1]=a;
    ans.ar[0][0]=1; ans.ar[0][1]=0;
    ans.ar[1][0]=0; ans.ar[1][1]=1;
    while(n)
    {
        if(n%2==1) ans=fx(ans,di);
        di=fx(di,di);
        n/=2;
    }
    return 2*(ans.ar[0][1]+a*ans.ar[0][0])%m;
}
int main()
{
    int T,n;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        printf("%lld\n",(qu(n-1)-1+m)%m );
    }
    return 0;
}
```




