# ZCMU-1878 寻找道路 搜索题 - 安得广厦千万间的博客 - CSDN博客





2018年06月01日 12:43:33[独-](https://me.csdn.net/qq_41713256)阅读数：54








链接：[点击打开链接](http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1878)




## 1878: 寻找道路
Time Limit: 1 Sec  Memory Limit: 128 MB
Submit: 15  Solved: 10
[[Submit](http://acm.zcmu.edu.cn/JudgeOnline/submitpage.php?id=1878)][[Status](http://acm.zcmu.edu.cn/JudgeOnline/problemstatus.php?id=1878)][[Web Board](http://acm.zcmu.edu.cn/JudgeOnline/bbs.php?pid=1878)]
## Description


**(road.cpp/c/pas)**

**【问题描述】**

在有向图G中，每条边的长度均为1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：

1．路径上的所有点的出边所指向的点都直接或间接与终点连通。

2．在满足条件1的情况下使路径最短。

注意：图G中可能存在重边和自环，题目保证终点没有出边。

请你输出符合条件的路径的长度。



**【输入】**

输入文件名为road.in。

第一行有两个用一个空格隔开的整数n和m，表示图有n个点和m条边。

接下来的m行每行2个整数x、y，之间用一个空格隔开，表示有一条边从点x指向点y。

最后一行有两个用一个空格隔开的整数s、t，表示起点为s，终点为t。



**【输出】**

输出文件名为road.out。

输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1。



【输入输出样例1】
|**road.in**|**road.out**|
|----|----|
|3 21 22 11 3|－1|



**【输入输出样例说明】**

**![](http://acm.zcmu.edu.cn/JudgeOnline/upload/pimg1878_1.png)**

如上图所示，箭头表示有向道路，圆点表示城市。起点1与终点3不连通，所以满足题目描述的路径不存在，故输出-1。



【输入输出样例2】
|**road.in**|**road.out**|
|----|----|
|6 61 21 32 62 54 53 41 5|3|

**【输入输出样例说明】**

![](http://acm.zcmu.edu.cn/JudgeOnline/upload/pimg1878_2.png)

如上图所示，满足条件的路径为1->3->4->5。注意点2不能在答案路径中，因为点2连了一条边到点6，而点6不与终点5连通。



【数据说明】

对于30%的数据，0< n ≤10，0< m ≤20；

对于60%的数据，0< n ≤100，0< m ≤2000；

对于100%的数据，0< n ≤10,000，0< m ≤200,000，0< x,y,s,t≤n，x≠t。


题意很清楚了。求有要求的最短路径。

见一个正图和反图。以终点bfs一遍反图，得到一些符合要求的点。在这些符合要求的点中进行筛选。如果符合要求的点中与不符合要求的点连接，那么这个点就变成不符合要求的了。

看样例2.一开始只有6不符合要交，但是2与6相连，所以2也变成不符合要求的点。

最后以起点跑一边bfs就好了。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=100010;
const ll inf=1e18;
int n,m,b,e;
int can[10010],tmp[10010],vis[10010];
vector<int>e1[10010],e2[10010];
struct node{ int to,len; }now,pre;
void bfs()
{
    can[e]=1;
    queue<int>q;
    q.push(e);
    while(!q.empty())
    {
        int v=q.front(); q.pop();
        for(int i=0;i<e2[v].size();i++)
        {
            int u=e2[v][i];
            if(!can[u])
            {
                can[u]=1;
                q.push(u);
            }
        }
    }
}
int bfs1()
{
    memset(vis,0,sizeof(vis));
    now.to=b; now.len=0;
    vis[b]=1;
    queue<node>q; q.push(now);
    while(!q.empty())
    {
        pre=q.front(); q.pop();
        if(pre.to==e) return pre.len;
        for(int i=0;i<e1[pre.to].size();i++)
        {
            int u=e1[pre.to][i];
            if(!vis[u]&&can[u])
            {
                now.to=u; now.len=pre.len+1;
                q.push(now);
                vis[u]=1;
            }
        }
    }
    return -1;
}
int main()
{
    cin>>n>>m;
    while(m--)
    {
        int x,y;
        cin>>x>>y;
        e1[x].push_back(y);
        e2[y].push_back(x);
    }
    cin>>b>>e;
    memset(can,0,sizeof(can));
    bfs();
    for(int i=0;i<=n;i++) tmp[i]=can[i];
    for(int i=1;i<=n;i++)
    {
        if(!tmp[i]) continue;
        for(int j=0;j<e1[i].size();j++)
        {
            if(tmp[e1[i][j]]==0)
            {
                can[i]=0;
                break;
            }
        }
    }
    cout<<bfs1()<<endl;
    return 0;
}
```



