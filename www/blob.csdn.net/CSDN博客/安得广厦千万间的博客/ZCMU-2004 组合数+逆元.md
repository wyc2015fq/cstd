# ZCMU-2004 组合数+逆元 - 安得广厦千万间的博客 - CSDN博客





2018年06月27日 15:42:49[独-](https://me.csdn.net/qq_41713256)阅读数：52








链接：[点击打开链接](http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=2004)



## 2004: HEX
Time Limit: 4 Sec  Memory Limit: 128 MB
Submit: 7  Solved: 5
[[Submit](http://acm.zcmu.edu.cn/JudgeOnline/submitpage.php?id=2004)][[Status](http://acm.zcmu.edu.cn/JudgeOnline/problemstatus.php?id=2004)][[Web Board](http://acm.zcmu.edu.cn/JudgeOnline/bbs.php?pid=2004)]
## Description

On a plain of hexagonal grid, we define a step as one move from the current grid to the lower/lower-left/lower-right grid. For example, we can move from (1,1) to (2,1), (2,2) or (3,2).
In the following graph we give a demonstrate of how this coordinate system works.

Your task is to calculate how many possible ways can you get to grid(A,B) from gird(1,1), where A and B represent the grid is on the B-th position of the A-th line.

![](http://acm.zcmu.edu.cn/JudgeOnline/upload/pimg2004_1.jpg)



## Input

For each test case, two integers A (1<=A<=100000) and B (1<=B<=A) are given in a line, process till the end of file, the number of test cases is around 1200.

## Output

For each case output one integer in a line, the number of ways to get to the destination MOD 1000000007.

## Sample Input

1 1

3 2

100000 100000

## Sample Output

1

3

1

从（1,1）走到（A,B）一共有多少总方案。

可以左下走（1,0），正下走（2,1），右下走（1,1）。

假设左下走了x次，正下走y次，右下走z次。

那么得到方程。

（1,1）+x*（1,0）+y*（2,1）+z*（1,1）=（a,b）. 


求得

 x+2*y+z=a-1;   y+z=b-1; 

得 

x+y=a-b; y+z=b-1 （ y<=min(a-b,b-1) ）枚举y。

那么左下走了x次，正下走y次，右下走z次这样的走法有多少总方案，其实就是一个组合数。

在（x+y+z）中选出x次走左下那么就是C（x+y+z,x），在剩下的（y+z）中选出y次走正下就是C（y+z，y），

最后剩下的就是走z次右下C（z,z）=1。

所以方案数就是C（x+y+z,x）*C（y+z,y）。然后枚举y全部加起来就好了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
ll d[100010], q[100010];
 
ll quy(ll a)
{
    ll ans=1;
    ll b=mod-2;
    while(b)
    {
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b/=2;
    }
    return ans;
}
void init()
{
    d[0]=1;
    for(int i=1;i<100010;i++) d[i]=d[i-1]*i%mod;
    q[0]=1;
    for(int i=1;i<100010;i++) q[i]=quy(d[i]);
}
ll fx(int n,int m)
{
    if(n==m||m==0) return 1;
    else return d[n]*q[m]%mod*q[n-m]%mod;
}
int main()
{
    init();
    ll a,b;
    while(~scanf("%lld%lld",&a,&b))
    {
        ll aa=a-b;
        ll bb=b-1;
        ll ans=0;
        for(ll y=0;y<=min(aa,bb);y++)
        {
            ans=(ans+fx(aa+bb-y,aa-y)*fx(bb,y))%mod;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```




