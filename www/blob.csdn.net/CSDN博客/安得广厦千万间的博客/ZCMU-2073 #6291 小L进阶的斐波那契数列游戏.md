# ZCMU-2073: #6291. 小L进阶的斐波那契数列游戏 - 安得广厦千万间的博客 - CSDN博客





2018年06月19日 19:32:45[独-](https://me.csdn.net/qq_41713256)阅读数：226








链接[点击打开链接](http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=2073)



## 2073: #6291. 小L进阶的斐波那契数列游戏
Time Limit: 1 Sec  Memory Limit: 128 MB
Submit: 4  Solved: 4
[[Submit](http://acm.zcmu.edu.cn/JudgeOnline/submitpage.php?id=2073)][[Status](http://acm.zcmu.edu.cn/JudgeOnline/problemstatus.php?id=2073)][[Web Board](http://acm.zcmu.edu.cn/JudgeOnline/bbs.php?pid=2073)]
## Description




小L觉得普通斐波那契数列太无聊了，于是他决定研究一下高端玩法，比如斐波那契前n项的平方和。





#### 输入格式



一行一个整数表示n。







#### 输出格式



一行一个整数表示答案，对 1000000007。







#### 样例



#### 样例输入

`4`

#### 样例输出

`15`







#### 数据范围与提示



n≤10^15






矩阵快速幂，关键是如何构造。

A1=A2=1;

An=An-1+An-2（n>2）

 Sn=A1^2+A2^2+......An^2;

所以 Sn=Sn-1+An^2.

       (An+1)^2=(An+An-1)^2=An^2+(An-1)^2+2*An*An-1.

      An*An+1=An*（An+An-1）=An^2+An*An-1

那么：

Sn                  1 1 0 0        Sn-1

An+1             0 1 1 2        An

An^2      =    0 1 0 0     *   An-1 ^2

An*An+1       0 1 0 1       An-1*An

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct node{
    ll ar[4][4];
};
const ll mod=1e9+7;
node fx(node a,node b)
{
    node ans;
    memset(ans.ar,0,sizeof(ans.ar));
    for(int i=0;i<4;i++)
         for(int j=0;j<4;j++)
           for(int k=0;k<4;k++)
             ans.ar[i][j]=(ans.ar[i][j]+a.ar[i][k]*b.ar[k][j])%mod;
    return ans;
}
ll findd(ll n)
{
    node ans,a;
    memset(ans.ar,0,sizeof(ans.ar));
    for(int i=0;i<4;i++) ans.ar[i][i]=1;
    memset(a.ar,0,sizeof(a.ar));
    a.ar[0][1]=a.ar[0][0]=1;
    a.ar[1][1]=a.ar[1][2]=1;a.ar[1][3]=2;
    a.ar[2][1]=1;
    a.ar[3][1]=a.ar[3][3]=1;
    while(n)
    {
        if(n&1) ans=fx(ans,a);
        a=fx(a,a);
        n/=2;
    }
    return ans.ar[0][1];
}
int main()
{
    ll n;
    cin>>n;
    ll ans=findd(n);
    cout<<ans<<endl;
    return 0;
}
```




