# HDU-6287，质因数分解+二分（小技巧）2018女生赛。 - 安得广厦千万间的博客 - CSDN博客





2018年05月28日 15:15:21[独-](https://me.csdn.net/qq_41713256)阅读数：310








题目连接：[点击打开链接](http://hdu.hustoj.com/showproblem.php?pid=6287)





小Q非常喜欢数学，但是他的口算能力非常弱。因此他找到了小T，给了小T一个长度为的正整数序列12，要求小T抛出个问题以训练他的口算能力。

每个问题给出三个正整数，小Q需要通过口算快速判断11是不是的倍数。

小Q迅速地回答了出来，但是小T并不知道正确答案是什么，请写一个程序帮助小T计算这些问题的正确答案。




Input

第一行包含一个正整数110，表示测试数据的组数。

每组数据第一行包含两个正整数1100000，分别表示序列长度以及问题个数。

第二行包含个正整数121100000，表示序列中的每个数。

接下来行，每行三个正整数11100000，表示每个问题。




Output

对于每个问题输出一行，若是倍数，输出Yes，否则输出No。




咋一眼看好像不难，再稍微一想感觉很难，最后仔细一想感觉不是很难。。。。。

就是一个问题，一个数n的质因子大于sqrt（n）的最多只有一个，在看数据范围，小于sqrt（n）的素数只有100个不到。

那么我们就预处理每一个数的质因数，做一个前缀和，在区间内的质因子数是否大于询问数中的质因子数（感觉有点拗口，看代码就很清楚了）。最后对大于sqrt（n）的做一下特殊处理。判断这个区间内的数有没有一个数的质因子（ 大于sqrt（n））等于询问中的质因子，感觉比较有技巧性。先上代码后面来解释这个技巧。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
#include<map>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
int p[400],vis[400],cnt;
int sum[100010][110];
vector<int>vv[100010];
void init()
{
    cnt=0;
    for(int i=2;i<400;i++)
    {
        if(vis[i]==0) p[++cnt]=i;
        for(int j=1;j<=cnt&&p[j]*i<400;j++)
        {
            vis[p[j]*i]=1;
            if(i%p[j]==0) break;
        }
    }
}
int main()
{
    init();
    int T,n,m,x;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        memset(sum,0,sizeof(sum));
        for(int i=0;i<100010;i++) vv[i].clear();
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&x);
            for(int j=1;j<=cnt;j++)
            {
                int c=0;
                while(x%p[j]==0)
                {
                    c++; x/=p[j];
                }
                sum[i][j]=sum[i-1][j]+c;
            }
            if(x>1) vv[x].push_back(i);  //保存哪几个数质因数为x。保存的是下标，这里是单调递增的。
        }
        while(m--)
        {
            int l,r,k;
            scanf("%d%d%d",&l,&r,&k);
            int f=1;
            for(int i=1;i<=cnt;i++)
            {
                int c=0;
                while(k%p[i]==0)
                {
                    c++; k/=p[i];
                }
                if(sum[r][i]-sum[l-1][i]<c)
                {
                    f=0;
                    break;
                }
            }
            if(f==0) printf("No\n");
            else if(k==1) printf("Yes\n");
            else
            {
               int cc=lower_bound(vv[k].begin(),vv[k].end(),l)-vv[k].begin();
               int dd=upper_bound(vv[k].begin(),vv[k].end(),r)-vv[k].begin();  //判断l-r这个区间内是否有k这个质因数。
               if(cc==dd) printf("No\n");
               else printf("Yes\n");
            }
        }
    }
    return 0;

}
```


现在来说这么判断的。在一个单调的数组中判断是否有 l-r的其中一个数。

来自大佬的博客

https://blog.csdn.net/Game_Acm/article/details/80480968 

二分找到 大于等于l 的下标 cc

二分找到大于 r 的下标dd

如果cc==dd那么就不存在。

至于为什么可以这样做。。手动模拟一下和容易发现。






