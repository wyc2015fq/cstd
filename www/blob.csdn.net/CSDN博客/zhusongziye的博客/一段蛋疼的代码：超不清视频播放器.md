# 一段蛋疼的代码：超不清视频播放器 - zhusongziye的博客 - CSDN博客





2018年11月22日 21:08:09[zhusongziye](https://me.csdn.net/zhusongziye)阅读数：52标签：[Python超不清视频播放器](https://so.csdn.net/so/search/s.do?q=Python超不清视频播放器&t=blog)
个人分类：[Python语言](https://blog.csdn.net/zhusongziye/article/category/7131144)









今天分享的这段代码，看起来没啥实际用处，而且有些反潮流，因为现如今大家看视频都追求更高分辨率的超清画质，而我们这个，是**一个“超不清”的视频播放器**：

**在控制台里播放视频，用字符来表示画面**

不过我觉得它至少可以有三个作用：1.用来**练习视频和图像处理**的编程开发；2.**在没有图形界面的服务器上播放视频**（虽然效果不咋地）；3.作为一种独特的**艺术风格化**处理

程序的原理其实很简单，关键是你要理解**计算机中一张图像的组成：一堆像素点。**我们平常说的 1920*1080 之类的分辨率，也就是指这个像素点的多少。我们想做成字符画，也就是考虑如何用不同的字符来表示一个像素。

通常**一个像素点由3个0~255的值表示**，分别表示**红、绿、蓝三种颜色值**，值越大表示颜色越深。但字符画是没有颜色的，所以需要将图像**转成灰度图**，这样就可以跟一组从深到浅的字符形成一种对应关系。比如深的点就是 @，浅色的点就是 .。

一幅图像全部转成字符序列后，就可以直接在控制台输出了。对于一个视频来说，只需要将每一帧都转换后输出，并按照一定的时间间隔清屏、输出下一帧，即可达到我们的需要的效果。

转换后的效果：

![](https://img-blog.csdnimg.cn/20181122210550897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20181122210638479.gif)





代码：

```
# coding: utf8
import cv2 as cv
import os
import time
# 替换字符列表
ascii_char = list(r"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'. ")
char_len = len(ascii_char)
# 加载视频
cap = cv.VideoCapture('video.mp4')
while True:
    # 读取视频每一帧
    hasFrame, frame = cap.read()
    if not hasFrame:
        break
    # 视频长宽
    width = frame.shape[0]
    height = frame.shape[1]
    # 转灰度图
    img_gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    # 缩小图片并调整长宽比
    img_resize = cv.resize(img_gray, (int(width / 10), int(height / 10)))

    text = ''
    # 遍历图片中的像素
    for row in img_resize:
        for pixel in row:
            # 根据像素值，选取对应的字符
            text += ascii_char[int(pixel / 256 * char_len)]
        text += '\n'
    # 清屏
    os.system('cls')  # mac是'clear'
    # 输出生成的字符方阵
    print(text)
    # 适当暂停一下
    time.sleep(0.03)
```

代码不长，稍微解释下其中几处：
- 
**ascii_char** 这个字符序列并不是必须这样，只要大致上满足其中的**字符看起来从深到浅**即可，字符越多越准确，效果就越好。

- 
读取视频使用了** opencv-python**，并直接用它提供的方法转了灰度图，在之前的文章中也有过介绍：[OpenCV-Python，计算机视觉开发利器](http://mp.weixin.qq.com/s?__biz=MjM5MDEyMDk4Mw==&mid=2650167745&idx=1&sn=d2cf47fe9d19b943a9c4112be31a7010&chksm=be4b54b9893cddaf5811b7466707122dc9ceda1bc27cfb7f62d6fd367486df30362222ebef70&scene=21#wechat_redirect)

- 
**resize** 这一步比较重要，因为有的视频分辨率很高，直接一个像素转一个字符的话量太大，所以**先缩小图片**。另一个原因是字符一般都不是正方形，所以在**图片长宽比上要做一定的调****整**，这样最终效果比较好。（实际中要根据你自己控制台中的字体效果来调整缩放比例）

- 
`ascii_char[int(pixel / 256 * char_len)]` 是整个转换的核心，因为一个像素的颜色范围是 0~255，通过 `pixel / 256 * char_len` 可以**将一个像素值对应于字符序列中灰度相当的字符**。

- 
关于输出，有几个值得注意的点：**输出一帧前需要清屏**，不同平台命令有区别；**时间间隔、控制台的字体大小、缩放比例都要根据实际情况作调整**；如果计算时间过长、刷新太慢而屏幕闪烁，可以考虑进一步缩小图片，或者先将所以帧转换完毕后再统一输出。




