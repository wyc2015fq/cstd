# 借持续集成的思想搞接口测试自动化 - zhusongziye的博客 - CSDN博客





2018年04月23日 21:49:22[zhusongziye](https://me.csdn.net/zhusongziye)阅读数：258








## 前言

前段时间的工作中有接触到接口测试，测试代码以maven工程的形式编写，使用testNG测试框架。工作中，每次执行测试都是在IDE里手动执行测试代码，很是麻烦，再考虑到后期的回归测试需要，所以产生了把该接口测试自动化的想法。
最初的做法是将测试数据保存在excel中，测试代码从excel中读取测试数据，然后执行mvn test命令执行测试。但是excel中写测试用例不是很方便，另外，这样简单的测试工具只能在我本机上运行，如果想分享给其他同事也来执行测试的话，就需要在他本机上再重复安装和搭建测试依赖环境，比如maven，java等，且要保证版本一致性，很是麻烦。正好之前有学点docker的知识，为了便于移植，就考虑将测试工具容器化。另外，最近也一直在看有关持续集成和DevOpts相关的东西，感到QA未来的一条发展方向就是DevOpsts，就萌生了把这个接口测试按照持续集成的思想搞一下的念头，也算让自己实践一下，更好的理解该思想。所以这里就分享下自己搭建这套持续集成接口测试自动化的流程，可能会与正宗的持续集成差一点，但大概的思路应该是对的。

## 整体流程

整体的想法是测试数据和测试代码分离，两者之间没有耦合，修改一方不用再修改另一方。另外，由于测试脚本会经常改动，比如testng.xml中会时常更新要执行的测试case，希望每次改动测试脚本后，会自动触发构建测试工作，所以就考虑引入gitlab和jenkins，在每次本地修改过测试脚本后，将测试脚本push到gitlab，jenkins通过webhook检测到gitlab上测试脚本有更新后，触发一个构建job，将测试脚本clone到本地，并执行测试。这样，每更新一次测试代码就触发一次测试，达到了自动化测试的目的，这也是持续集成的思想。
另外，考虑后续的移植方便，将整个流程的各部分容器化，所以就要借助docker。整体流程如下：




![](https://img-blog.csdn.net/20180423212816439?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

整体流程
- 
Test Code
本地的测试脚本，每次修改测试脚本后，push到gitlab上。

- 
Gitlab
利用docker搭建一个gitlab仓库容器，存储测试脚本。这个代码仓库建立起来后，不但自己本地修改测试脚本后可以上传到该仓库，也便于其他同事修改测试脚本后，同样上传到该测试代码仓库来触发自动化测试工作。

- 
Jenkins
利用docker搭建一套Jenkins容器。这里的Jenkins的工作主要为：
① 检测gitlab仓库中测试脚本是否有更新，若有更新则触发一个构建job；
② 在构建job中执行测试工作，包括：
a、将gitlab中更新后的测试脚本下载到执行节点slave上；
b、启动mysql、maven容器，执行测试，收集测试报告。

- 
MySQL
利用docker搭建一套mysql容器，该容器的作用为存储测试数据。

- 
Maven
利用docker搭建一个maven容器，该容器的作用是加载测试脚本（maven工程），读取测试数据（从mysql容器中读取），执行测试（用mvn test调用testNG），生成测试报告。
可以看到，各个部分都是基于docker容器化的，各容器独立存在，互相解耦，且便于各自移植。


## 环境搭建

整套搭建在我本机的虚拟机192.168.201.130上搭建。

#### 1. 下载镜像

下载jenkins，gitlab，maven，mysql镜像。

```
sudo docker pull jenkins/jenkins:lts
sudo docker pull gitlab/gitlab-ce
sudo docker pull maven:3.5.2-jdk-8
sudo docker pull mysql
```

其中jenkins选lts版本，getlab选ce版本，maven选jdk8版本。

#### 2. 编排容器

容器编排采用docker-compose.yml。

##### 2.1 mysql容器

该容器作为测试数据的存储。由于容器中mysql的数据保存在容器的/var/lib/mysql目录下，所以将该目录挂载到宿主机上，这样即使容器被删除，容器中mysql的数据也依然存在，下次再新建容器时，读取宿主机的数据库数据，“之前的数据库就恢复了”。所以，这也是用docker来搭建数据库的好处，可以复制多个相同的数据库。

###### 2.1.1 新建mysql容器
- 
将容器的/var/lib/mysql目录挂载到宿主机的的/home/ivanli/myown/docker_test/docker_mysql/data目录；
注意！必须确保宿主机的挂载目录下是空的，否则mysql容器启动会报错。

- 
mysql容器的3306端口映射到宿主机的3307端口；

- 
设置环境变量MYSQL_ROOT_PASSWORD，该变量的值即为mysql root用户的密码。

`sudo docker run -v -d /home/ivanli/myown/docker_test/docker_mysql/data:/var/lib/mysql --name myMysql -e MYSQL_ROOT_PASSWORD=88888888 -p 3307:3306 mysql`
###### 2.1.2 测试数据存入mysql

作为测试数据保存源，首先要将测试数据（包括测试基础数据和测试用例等）先插入到mysql容器中，完成测试数据库的初始化，这样以后就可用该数据库提供测试数据进行测试工作了。
因为之前在宿主机上搭建了一套mysql，且创建好了数据库、表和数据，这里为了方便，直接将宿主机上mysql的数据库导出，导入进容器的mysql中。
- 
导出宿主机数据库数据

`mysqldump -u root -p --databases lego2TestData > mydb.bak`- 
将数据库文件copy进容器/root目录下

`sudo docker cp  mydb.bak myMysql:/root/`- 
进入mysql容器，导入数据
① 进入mysql容器

`sudo docker exec -it myMysql  /bin/bash`
② 在容器内登录mysql数据库，密码为启动容器时的MYSQL_ROOT_PASSWORD环境变量的值
`docker -u root -p`
③ 新建一个与要导入的数据库同名的数据库
`mysql> create database lego2TestData ;`
④ 导入数据
`mysql> source /root/mydb.bak;`
至此，宿主机数据库就导入到mysql容器中了。
mysql为了安全性，在默认情况下用户只允许在本地登录，即目前该数据库只能在容器内被登录，所以为了在容器外也能远程登录容器内的mysql，要对数据库进行权限设置，这里设置为允许root用户在任何地方进行远程登录，并可对数据库进行任何操作：
`grant all privileges on *.* to 'root'@'%' identified by '88888888' with grant option;`
因为容器中数据库的数据挂载在宿主机上，所以，上面导入的数据库数据在下次容器创建时依然存在。这样，就可以用该容器作为测试数据提供源了。

##### 2.2 maven容器

工作中要测试的代码是java写的，所以测试代码以maven工程的形式编写，然后以挂载的方式，将测试代码挂载进maven容器中，在maven容器中执行测试。

###### 2.2.1 测试代码

测试代码由以下几部分组成：

```
ivanli@ubuntu:~/myown/docker_test/docker_legoTest/testSuites_auto_test$ ll
total 36-rw-rw-r-- 1 ivanli ivanli    2 Nov  7 00:27 :
drwxrwxr-x 5 ivanli ivanli 4096 Nov 14 03:05 ./
drwxrwxr-x 4 ivanli ivanli 4096 Nov  8 22:32 ../
drwxrwxr-x 4 ivanli ivanli 4096 Nov  7 00:27 config/
drwxrwxr-x 2 ivanli ivanli 4096 Nov  7 00:27 lib/
-rw-r--r-- 1 root   root   3987 Nov  7 00:32 pom.xml
-rwxrwxr-x 1 ivanli ivanli  521 Nov  7 00:27 run.sh*
drwxrwxr-x 4 ivanli ivanli 4096 Nov  7 00:27 src/
-rw-rw-r-- 1 ivanli ivanli  309 Nov  7 00:27 testng.xml
```
- 
config 配置文件
与测试工程相关的配置文件存放在这个文件夹，另外，连接mysql容器读取测试数据的配置文件db.properties也存放在此文件夹下，该文件内容为：


```
dbAddr = 192.168.201.130
dbPort = 3307
dbName = lego2TestData
dbUser = root
dbPassword = 88888888
```

其中192.168.201.130为docker宿主机ip。
- 
src 测试代码
测试代码在src/test/java目录下。

- 
pom.xml
测试框架选用testNG，以依赖的形式引入到pom.xml中。
因为testNG原生测试报告页面太low，所以用reportNG来生成测试报告。目前reportNG最高版本不支持中文，在网上down了别人改进的支持中文的reportNG jar包到本地，放入工程${project.basedir}/lib目录下。
另外，测试数据从mysql中读取，所以pom.xml中引入java操作mysql的jar包。
最后，因为要用到的maven容器中的java版本是1.8，所以maven-compiler-plugin插件中要指定java版本为1.8。
相关内容在pom.xml中为：


```
<!-- testng -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>6.10</version>
            <scope>test</scope>
        </dependency>

        <!-- mysql -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.38</version>
        </dependency>

        <!-- 依赖reportNg 关联testNg -->
        <dependency>
            <groupId>org.uncommons</groupId>
            <artifactId>reportng</artifactId>
            <version>1.1.5</version>
            <scope>system</scope>
            <systemPath>${project.basedir}/lib/reportng-1.1.5.jar</systemPath>
        </dependency>

        <dependency>
            <groupId>velocity</groupId>
            <artifactId>velocity</artifactId>
            <version>1.4</version>
        </dependency>

        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
            <version>4.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- 添加插件,添加ReportNg的监听器，修改最后的TestNg的报告 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.18.1</version>
                <configuration>
                    <properties>
                        <property>
                            <name>usedefaultlisteners</name>
                            <value>false</value>
                        </property>
                        <property>
                            <name>listener</name>
                            <value>org.uncommons.reportng.HTMLReporter,
                                org.uncommons.reportng.JUnitXMLReporter</value>
                        </property>
                    </properties>
                    <workingDirectory>target/</workingDirectory>
                    <suiteXmlFiles>
                        <suiteXmlFile>testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                    <forkMode>always</forkMode>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <encoding>utf-8</encoding>
                    <fork>true</fork>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
```
- 
lib 存放本地依赖jar包
这个文件夹只是用来存放上面提到的下载到本地的支持中文的reportNG jar包。其实也可以将该jar包上传到自己的maven私服，然后在pom.xml中引入。这里就放在lib目录下：


```
ivanli@ubuntu:~/myown/docker_test/docker_legoTest/testSuites_auto_test/lib$ ll
total 44drwxrwxr-x 2 ivanli ivanli  4096 Nov  7 00:27 ./
drwxrwxr-x 5 ivanli ivanli  4096 Nov 14 03:05 ../
-rw-rw-r-- 1 ivanli ivanli 34655 Nov  7 00:27 reportng-1.1.5.jar
```
- 
testng.xml 写明测试套件和用例
testng.xml中写入要测试的套件和测试用例，这里就不多说了。

- 
run.sh 测试运行脚本
脚本内容如下：

`#!/bin/bash#  mvn cleanmvn clean# 获取当前脚本所在路径workdir=$(cd $(dirname "$0");pwd)# 配置文件所在路径dbConfig=$workdir'/config/dbconfig/db.properties'scfConfig=$workdir'/config/online/scf.config'# 配置文件复制到下面路径toDbConfigPath=$workdir'/target/config/dbconfig'toScfConfigPath=$workdir'/target/config/online'# 复制配置文件mkdir -p "$toDbConfigPath"mkdir -p "$toScfConfigPath"cp "$dbConfig" "$toDbConfigPath"cp "$scfConfig" "$toScfConfigPath"#  mvn testmvn test`
该脚本主要包含3步：
① mvn clean
清理项目目录下的targer目录。
② 复制配置文件到项目的target目录下
由于编译后的测试代码是去工程的target/config目录下读取配置文件，而步骤①删除了target目录，所以步骤②需要手动新建target目录，并把配置文件复制到该目录下。
③ mvn test
执行测试，mvn test命令将调用testng执行测试。

###### 2.2.2 maven容器编排

由于测试数据从mysql容器中读取，所以测试时，需要mysql容器先启动，再启动maven容器，即maven容器的启动依赖于mysql容器。因此，这里将mysql容器和maven容器放入同一个docker-compose.yml中编排：
- 
docker-compose.yml


```
version: '2'services:
  mysql:
    image: mysql
    ports:
      - "3307:3306"
    container_name: myMySQL
    volumes:
      - "/home/ivanli/myown/docker_test/docker_mysql/data:/var/lib/mysql"
  maven_lego_adServiceTest:
    image: maven
    container_name: maven_lego
    depends_on:
      - mysql
    volumes:      # 将gitlab拉下来的maven工程导入容器中
      - "/home/ivanli/myown/jenkins_node/workspace/lego2_AdServiceTestSuite/testSuites_auto_test:/usr/src/app"
      #  将gitlab拉下来的maven配置文件替换容器的maven配置文件
      - "/home/ivanli/myown/jenkins_node/workspace/lego2_AdServiceTestSuite/dockerMavenConf/settings.xml:/usr/share/maven/conf/settings.xml"
      # 将宿主机目录作为maven仓库，做缓存用
      - "/home/ivanli/myown/.m2/repo:/usr/share/maven/ref"
    entrypoint: ["/usr/src/app/run.sh"]
```

mysql服务的启动，这里不再复述。
maven_lego_adServiceTest服务说明如下：
①  depends_on
因为maven容器要读取mysql中的测试数据，所以要依赖mysql服务先启动。
② volumes挂载
挂载分3部分：
a、将gitlab拉下来（通过jenkins拉代码，拉下的代码所在目录为jenkins执行节点的工作区间）的测试代码maven工程testSuites_auto_test挂载到容器的/usr/src/app目录下；
b、将gitlab拉下来的maven配置文件替换容器的maven配置文件；
c、为了缓存maven容器下载的jar包，这里将maven容器中的maven仓库挂载到宿主机的/home/ivanli/myown/.m2/repo目录下。这样就不用每次启动容器都重新下载引用jar包了，提高测试速度。
③ entrypoint
容器启动后，要执行测试代码中的run.sh脚本执行测试，因为测试代码工程挂载到容器的/usr/src/app目录下，所以这里执行该目录下的run.sh脚本。
- 
容器启动脚本dockerrun.sh
因为希望实际测试时，在开始测时创建容器，测试完成后删除容器，所以将该部分控制命令写入dockerrun.sh中：

`#!/bin/bash -e# 启动maven容器，执行测试sudo docker-compose run -w /usr/src/app maven_lego_adServiceTest# 删除容器sudo docker-compose down`
注意！实际启动容器执行测试的时候，不知为什么不能直接执行entrypoint中写明的/usr/src/app/run.sh脚本，提示在/目录下找不到run.sh的错误。所以在启动maven_lego_adServiceTest服务之前，先通过-w切换工作目录到/usr/src/app目录下，再启动maven_lego_adServiceTest服务，这样就可以成功执行run.sh脚本了。
容器执行测试完毕后，再执行docker-compose down，删除容器。

##### 2.3 gitlab容器

gitlab容器作为远程代码仓库，存放测试代码。

###### 2.3.1 gitlab容器编排
- 
docker-compose.yml


```
version: '2'services:
  gitlab:
    image: gitlab/gitlab-ce
    ports:
      - "8443:443"
      - "8929:80"
      - "2222:22"
    container_name: gitlab
    volumes:
      - "/home/ivanli/myown/docker_test/docker_gitlab/config:/etc/gitlab"
      - "/home/ivanli/myown/docker_test/docker_gitlab/logs:/var/log/gitlab"
      - "/home/ivanli/myown/docker_test/docker_gitlab/data:/var/opt/gitlab"
```

① gitlab容器的https端口映射到宿主机的8443端口，http端口映射到宿主机的8929端口，ssh端口映射到宿主机的2222端口。
② gitlab容器中的/etc/gitlab、/var/log/gitlab和/var/opt/gitlab目录挂载到宿主机上。

###### 2.3.2 配置gitlab
- 
配置gitlab容器的/etc/gitlab/gitlab.rb


首先启动gitlab容器。
`sudo docker-compose up -d`
容器启动后，修改gitlab的配置文件/etc/gitlab/gitlab.rb。因为其所在目录有挂载到宿主机上，所以直接修改宿主机的/home/ivanli/myown/docker_test/docker_gitlab/config/gitlab.rb文件
① 配置http地址
这里配置为docker宿主机ip
`# 配置http协议所使用的访问地址external_url 'http://192.168.201.130'`
② 配置ssh端口号
`### GitLab Shell settings for GitLabgitlab_rails['gitlab_shell_ssh_port'] = 2222`
然后重启gitlab容器。
`sudo docker restart gitlab`
浏览器访问http://192.168.201.130:8929，出现如下页面说明gitlab容器搭建ok。




![](https://img-blog.csdn.net/2018042321284772?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

gitlab页面
- 
配置宿主机ssh免密访问gitlab


① docker宿主机ivanli用户下生成公钥和私钥，一路回车。
`ssh-keygen -t rsa`
② 在gitlab上注册用户并登陆。将公钥内容复制到gitlab用户的settings -> SSH Keys中。




![](https://img-blog.csdn.net/2018042321290260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


添加访问节点机的公钥




③ gitlab上新建项目




![](https://img-blog.csdn.net/20180423212916401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

新建项目


复制建好的项目的ssh地址。


![](https://img-blog.csdn.net/20180423212932839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

项目ssh地址




④ git clone项目到本地
`git config --global user.name "ivanli"git config --global user.email "llf550715487@qq.com"git clone ssh://git@192.168.201.130:2222/ivanli/lego2_AdServiceTestSuite.git`
⑤ git push项目到gitlab
复制测试项目文件到上一步的目录中，然后push文件到gitlab。

```
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ ll
total 28drwxrwxr-x 5 ivanli ivanli 4096 Nov 15 01:51 ./
drwxrwxr-x 4 ivanli ivanli 4096 Nov 15 01:24 ../
-rwxrwxr-x 1 ivanli ivanli  893 Nov 15 01:24 docker-compose.yml*
drwxrwxr-x 2 ivanli ivanli 4096 Nov 15 01:24 dockerMavenConf/
-rwxrwxr-x 1 ivanli ivanli  157 Nov 15 01:24 dockerrun.sh*
drwxrwxr-x 8 ivanli ivanli 4096 Nov 15 01:32 .git/
drwxrwxr-x 7 ivanli ivanli 4096 Nov 15 01:24 testSuites_auto_test/
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git add *
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git commit -m "legoAdServiceTestSuite"ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git push -u origin master
```

然后在gitlab上可以看到push的测试脚本文件。




![](https://img-blog.csdn.net/20180423212946121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

push到gitlab上的文件

##### 2.4 jenkins容器

jenkisn容器负责检测gitlab仓库中测试脚本是否有更新，若有更新则触发一个构建job，将测试脚本下载到执行节点slave上，启动mysql、maven容器，执行测试，收集测试报告。

###### 2.4.1 jenkins容器编排
- 
docker-compose.yml


```
version: '2'services:
  jenkins:
    image: jenkins/jenkins:lts
    ports:
      - "9001:8080"
      - "50000:50000"
    container_name: jenkins_test
    volumes:
      - "/home/ivanli/myown/jenkins_home:/var/jenkins_home"
```

jenkins容器的数据目录/var/jenkins_home挂载到宿主机上。这里注意下！官方的建议是将一个名为jenkins_home的宿主机volume挂载到容器的/var/jenkins_home目录。容器创建后，这个名为jenkins_home的volume会自动在宿主机上被创建。如果要自己将自定义的宿主机目录挂载到容器的/var/jenkins_home，需要注意权限问题，要将宿主机的该目录的所属用户为uid为1000的用户，因为在容器内，/var/jenkins_home目录的所属用户为uid为1000的jenkins用户，所以要保证宿主机的该目录的所属用户也为1000。这里，docker宿主机的ivanli用户uid为1000，所以我挂载了自定义的目录来保存jenkins容器的数据。
映射jenkins的端口到宿主机的9001端口，slave端口映射到宿主机的50000端口。

###### 2.4.2 配置jenkins

首先启动容器。
`sudo docker-compose up -d`- 
将docker宿主机配置为节点


这里我选择将docker宿主机作为jenkins的slave节点。所以首先配置jenkins ssh免密登录docker宿主机，登录用户为宿主机的ivanli用户：
① docker exec进入jenkins容器中，执行：
ssh-keygen -t rsa
一路回车生成jenkins容器的公钥和私钥。
② 将jenkins容器的公钥写进宿主机（192.168.201.130）ivanli用户的~./ssh/authorized_keys中：
`ssh-copy-id -i ~/.ssh/id_rsa.pub ivanli@192.168.201.130`
③ 在jenkins容器中登录宿主机，以便将宿主机的ip写入jenkins容器的~/.ssh/known_hosts文件中：
`ssh ivanli@192.168.201.130`
④ jenkins中新增Credentials
页面如下：
a、Username填入免密登录宿主机的用户ivanli；
b、Private Key中填入jenkins容器生成的私钥。




![](https://img-blog.csdn.net/20180423213049827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

新增Credentials




⑤ jenkins中新增宿主机节点
页面如下：
a、启动方法选SSH；
b、主机填入宿主机ip；
c、Credentials选刚才新建的Credential；
d、Java路径填入宿主机java路径。




![](https://img-blog.csdn.net/20180423213111301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

新增linux节点


然后在jenkins页面中luncher宿主机节点。
- 
安装Gitlab Plugin 和 Gitlab Hook Plugin 插件
要使用jenkins检测gitlab代码是否有更新（push），需要安装Gitlab和Gitlab Hook插件。




![](https://img-blog.csdn.net/20180423213147256?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

gitlab和gitlab hook插件

- 
配置jenkins容器的jenkisn用户ssh免密访问gitlab
① 将jenkins容器jenkins用户生成的公钥复制到gitlab用户的settings -> SSH Keys中，过程同2.4.2节一样，不再复述。
② jenkins中新增Credentials，私钥填入jenkins容器jenkins用户生成的私钥。

- 
配置job
配置一个检测gitlab测试脚本更新及触发构建测试工作的job。
① jenkins中新建job，名为test_git_maven，执行节点选择docker宿主机。




![](https://img-blog.csdn.net/20180423213207279?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

执行节点选择docker宿主机




② 源码管理选择git
页面如下：
a、仓库地址填入项目的ssh地址。注意！填入项目的ssh地址，而不是http地址；
b、Credentials选择之前新增的jenkins容器的jenkins用户的Credential；
c、Branch选择主干master（因为我是将本地代码提交到gitlab的lego2_AdServiceTestSuite项目的主干上）。




![](https://img-blog.csdn.net/20180423213228575?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

源码管理


③ 构建触发器选择Gitlab
页面如下：
复制图中的url。


![](https://img-blog.csdn.net/20180423213258348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

构建触发器




④ 将上步的url粘贴到gitlab项目中的webhook中。Trigger中勾选Push events。这样，本地代码提交到gitlab上后，jenkins就会通过gitlab hook插件检测到gitlab上代码有更新，触发job构建。

![](https://img-blog.csdn.net/20180423213355451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





gitlab项目中添加webhook


⑤ 构建
构建中执行测试项目中的dockerrun.sh脚本。


![](https://img-blog.csdn.net/20180423213418334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

构建


⑥ 构建后操作
构建后发布测试报告，这里就不多说了，具体配置如图：


![](https://img-blog.csdn.net/20180423213441450?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

构建后操作


## 测试

首先分别启动gitlab和jenkins容器：

```
ivanli@ubuntu:~$ sudo docker ps
CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS                  PORTS                                                 NAMES1f6d63de064d        jenkins/jenkins:lts       "/bin/tini -- /usr..."   3 minutes ago       Up 2 minutes            0.0.0.0:50000->50000/tcp, 0.0.0.0:9001->8080/tcp      jenkins_test
fa40db7215e5        gitlab/gitlab-ce:latest   "/assets/wrapper"        47 hours ago        Up 47 hours (healthy)   443/tcp, 0.0.0.0:2222->22/tcp, 0.0.0.0:8929->80/tcp   gitlab
ivanli@ubuntu:~$
```

在本地测试项目中新增一个hello文件，git push到gitlab中，触发jenkins构建job。

```
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ touch hello
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git add hello
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git commit -m "add hello"[master ac113c1] add hello 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 hello
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$ git push -u origin master
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 254 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To ssh://git@192.168.201.130:2222/ivanli/lego2_AdServiceTestSuite.git
   d700f8e..ac113c1  master -> master
Branch master set up to track remote branch master from origin.
ivanli@ubuntu:~/myown/docker_test/docker_gitlabProject/lego2_AdServiceTestSuite$
```

过一会就可以看到，jenkins检测到gitlab上lego2_AdServiceTestSuite项目有代码更新后，自动触发构建：




![](https://img-blog.csdn.net/20180423213454736?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

Started by Gitlab push by ivanli




jenkins job 输出：
可见gitlab上的代码被down到执行节点，然后开始测试，首先创建并启动mysql容器：




![](https://img-blog.csdn.net/20180423213512533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

创建mysql容器


接着创建maven容器，执行测试
，测试结束后，删除容器，jenkins收集测试报告：


![](https://img-blog.csdn.net/20180423213716515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

测试结束，删除容器，收集报告




构建结果：

![](https://img-blog.csdn.net/20180423214051918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





构建结果

![](https://img-blog.csdn.net/20180423214105313?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
测试报告：


![](https://img-blog.csdn.net/20180423214322756?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


测试报告

![](https://img-blog.csdn.net/2018042321452565?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





测试报告


由此，实现了最初的目标，借助持续集成的思想将接口测试自动化。

## 总结

如前言所说，借着之前工作中遇到的接口测试，考虑了怎样将手动执行的接口测试给自动化实现，也考虑如何去实践持续集成的思想，故一步步将整个流程给趟了下来。在这个过程中也学到了不少东西，当然，如果想完完全全的将当前测试工作持续集成化，还有不少的限制和工作去做，这也是需要自己一点点去学习和不断的感悟。
自己毕业也已快2年半了，从一个非科班专业出身的懵懂应届生，也算一点点入门了QA这个职业，也曾经对自身未来的职业发展感到迷茫和彷徨，平时也一点点积累和学习软件测试方面的资料，一点点明确了QA未来的发展方向，测试平台服务化，测试平台智能化，DevOpts这3个方向就是未来除了管理方向外，QA的职业发展方向吧，也希望自己要更加努力一些，跟上行业要求，早日在这3个方向中的1个方向上有所发展。
最后，希望这篇文章能帮助一些初级QA。


作者：Ivanli1990
链接：https://www.jianshu.com/p/9af4a73efc7f



