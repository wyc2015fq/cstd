# 测试用例的设计（黑盒测试） - zhusongziye的博客 - CSDN博客





2018年01月16日 20:51:33[zhusongziye](https://me.csdn.net/zhusongziye)阅读数：202











黑盒测试


等价划分


使用等价划分方法设计测试用例有两个步骤：


1


确定等价类

有效等价类代表对程序的有效输入；无效等价类代表的是其他不正确的任何输入。如果需要，我们还可以将一个等价类划分为更小的一些等价类。


比如，规格说明规定了“请输入书籍的数量（1~99）以及书籍的类型（硬皮、软皮或活页）”。它们对应的等价类分别如下：

书籍数量
![](https://img-blog.csdn.net/20180116204541329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

书籍类型
![](https://img-blog.csdn.net/20180116204558026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)





2


生成测试用例

1. 为每个等价类设置编号。


输入条件

有效等价类

无效等价类


书籍数量


①1≤X≤99


②X<1③x>99


书籍类型


④硬皮⑤软皮


⑥活页


⑦其他

2. 编写测试用例，尽可能多的覆盖尚未被覆盖的有效等价类。直到所有的有效等价类都被测试用例覆盖。测试用例及其覆盖的有效等价类如下：


50，硬皮

50，软皮

50，活页


    覆盖①④


    覆盖①⑤


    覆盖①⑥


3. 编写测试用例，覆盖一个且仅一个尚未被覆盖的无效等价类。直到所有的无效等价类都被测试用例所覆盖。测试用例及其覆盖的无效等价类如下：


-50，硬皮

199，软皮

50，线装


    覆盖②


    覆盖③


    覆盖⑦



用单个的测试用例覆盖无效等价类，是因为有些输入的错误检查可能会屏蔽或取代其他输入的错误检查。比如②⑦，也许程序提示“非法的书籍数量”后，就不会执行对书籍类型的检查了。





边界值分析


经验证明，考虑了边界条件的测试用例比其他没有考虑边界条件的测试用例，具有更高的测试回报率。所谓边界条件，是指输入和输出等价类中恰好处在边界、或超过边界、或在边界以下的状态。


上例中的书籍数量范围是1~99，那么应该针对0，1和99，100的情况分别设计测试用例。
![](https://img-blog.csdn.net/20180116204712240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


从定义可以看出，等价划分只关注输入空间（输入等价类）的不同，边界值分析还需要从输出空间（输出等价类）设计测试用例。举例来说：


某个程序按月计算个人所得税的速算扣除数，且最小金额是0，最大金额是13,505。使用边界值分析法，应该设计测试用例测试速算扣除数结果为0和13505的情况。此外，还应观察是否可能设计出导致速算扣除数为负数，或者超过13505的测试用例。
![](https://img-blog.csdn.net/20180116204723758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



边界值分析法和等价划分重要的区别是，等价划分是从等价类中挑选任意一个元素作为测试数据；边界值分析法考察正处于等价划分边界或在边界附近的状态。





因果图

边界值分析和等价划分的缺点是，未对输入条件的组合情况、输入条件之间的相互制约关系进行分析。



1


因果图的基本关系

恒等（Identify）:若a为1，则b为1；否则b为0。

非（NOT）:若a为1，则b为0；否则b为1。

或（OR）:若a或b或c为1，则d为1；否则d为0。

与（AND）:若a和b和c都为1，则d为1；否则d为0。
![](https://img-blog.csdn.net/20180116204756980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20180116204805294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20180116204814564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20180116204824234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


2


因果图的约束条件

对于输入条件的约束有E、I、O、R四种：


异（E）:E必须总为真，而a、b最多只有一个为1。

或（I）:I为真时，a、b和c中至少有一个必须为1。

唯一（O）:a、b中，有且仅有一个必须为1。

要求（R）:如果a为1，b也必须为1。
![](https://img-blog.csdn.net/20180116204837289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20180116204846967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20180116204856871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20180116204905921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

对于输出结果的约束只有M一种：

屏蔽（M）:如果结果a为0，则b强制为0。
![](https://img-blog.csdn.net/20180116204919416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3


生成测试用例的过程


1. 将规格说明分解为可执行的片段，确定“因”和“果”，同时为每个“因”和“果”都赋予唯一的编号。


所谓“因”，是指一个明确的输入条件等价类。所谓“果”，是指一个输出条件或系统转换（输入对程序或系统状态的延续影响）。


2. 分析规格说明的语义，转换为因果图。


3. 为因果图添加约束条件。


4. 将因果图转换为判定表。


5. 将判定表的每一列转换为一个测试用例。



4


一个简单的例子

规格说明：“第一列中的字符必须是‘A’或‘B’，第二列中的字符必须是一个数字。在这种情况下，对文件进行更新。如果第一个字符不正确，产生提示信息X12。如果第二个字符不是数字，产生提示信息X13。”


（一）分解规格说明，得到“因”如下：



1 —— 第一列的字符是“A”

2 —— 第一列的字符是“B”

3 —— 第二列的字符是一个数字


“果”如下：


70 —— 对文件做了更新


71 —— 产生提示信息X12


72 —— 产生提示信息X13


（二）分析规格说明的语义，并将其转换为因果图如下：
![](https://img-blog.csdn.net/20180116204936936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

（三）原因①和原因②不可能同时成立，为因果图添加对应的约束条件：
![](https://img-blog.csdn.net/20180116204947578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

（四）“因”是条件，“果”是动作。将因果图转换为判定表，每一列代表一个测试用例。

![](https://img-blog.csdn.net/20180116204958963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

（五）将判定表中的列转换为测试用例。



① A，1



② B，1


③ 1，1


④ 1，A


⑤ A，A


⑥ B，B





5


附：将因果图转换为判定表的思路

（以上述的例子来说明）
- 

选择一个“果”作为当前状态。例：71。

- 

对因果图回溯，找出导致该“果”为1的所有因的组合（需要考虑到约束条件）。例：001，000。

- 

在判定表中为每个“因”的组合生成一列。例：（列3）和（列4）。

- 

对于每种“因”的组合，判断所有其他“果”的状态，并放置在对应的每一列中。例：已得在001，000两种组合下结点71的结果为1。判断在“因”为001的组合下，得到70和72的结果为0。判断在“因”为000的组合下，得到70的结果为0，72的结果为1。将“果”的状态填入其对应的列。


对因果图进行回溯时，需要做到以下考虑：


1)  当回溯经过一个结果为1的OR结点时，不要将OR结点的1个以上的输入同时设为1。


2)  当回溯经过一个结果为0的AND结点时，应列举出导致该结果为0的所有输入情况的组合。然而，当该AND结点的一个输入条件为0时，其他输入有一个或更多的1，则不必考虑其他输入为1的所有情况。


3)  当回溯经过一个结果为0的AND结点时，所有输入皆为0的这一种情况应当列举出来。
![](https://img-blog.csdn.net/20180116205016125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

假设我们需要找出下面因果图中，所有导致输出状态为0的输入条件。
![](https://img-blog.csdn.net/20180116205026989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1c29uZ3ppeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

(1)  根据上述第3)条思路，我们只需列出使得结点⑤和结点⑥皆为0的情况。结点①②③④的取值状态为：


0，0，0，0


（5=0，6=0）



(2)  根据第2)条思路，对于结点⑤为1而结点⑥为0的情况，应该列出导致⑥为0的所有输入情况组合。同时，只需列出一种使得⑤为1的情况即可，不需要列出⑤为1时的所有输入情况组合。又根据第1)条思路，当结点⑤为1时，我们不应将结点①和②同时设为1。于是，得到结点①②③④的取值状态：


1，0，0，0


1，0，0，1


1，0，1，0


（5=1，6=0）



（5=1，6=0）


（5=1，6=0）


同样的，对于⑤为0而⑥为1的情况，也只需要列出⑥为1的一种情况即可（尽管在本例中也只有这一种）。


0，0，1，1


（5=0，6=1）



因果图有助于用一个系统的方法选择出高效的测试用例集。它还有一个额外的好处，就是可以指出规格说明的不完整性和二义性。但通常它不能生成全部应该被确定的有效测试用例。


因果图方法没有充分考虑边界条件。建议，最好是单独考虑边界值分析。这不意味着我们要为此增加相应多的测试用例，而是在由因果图生成测试用例时，可以将边界条件分析一并考虑进去。最好的结果是既满足了两方面的目标，又不需要增加新的测试用例。






错误推测


错误猜测是一项依赖于直觉的非正规的过程，其基本思想是人们利用直觉和经验猜测可能犯得错误或错误易发情况的清单，然后编写测试用例来暴露这些错误。


例如，程序输入中出现0这个值，就是一种错误易发情况。因此可以编写测试用例检查特定的输入值中有0，或特定的输出值被强制为0的情况。





同样，在出现输入或输出数目不定的地方，如，对某个列表进行搜索，结果为“空列表”或“只包含一个”条目的列表，也是错误容易发生的情况。





另一个思想是，在阅读规格说明时，联系程序员可能做的假设来确定测试用例。如规格说明中被忽略的一些内容，要么是由于偶然因素，要么是程序员认为其显而易见。


测试策略


测试用例设计方法可以组合为一个整体的策略，因为每一种方法都可以提供一组具体的有用的测试用例，但是都不能提供一个完整的测试用例集。


一组合理的策略如下：

1


如果规格说明包含输入条件组合的情况，应首先使用因果图分析法。



2


任何情况下都应使用边界值分析法。边界值分析法可以产生一系列补充的测试条件，多数甚至全部条件可以被整合到因果图分析中。


3


为输入和输出确定有效和无效等价类，在必要情况下对上面确认的测试用例进行补充。


4


使用错误猜测增加更多的测试用例。


5


针对上述测试用例，检查程序的逻辑结构。如果覆盖准则未能被前四个步骤中确定的测试用例所满足，并且满足准则也并非不可能，那么增加足够数量的测试用例，以使覆盖准则得到满足。




◆来源:图文来自网络，如有侵权请联系删除



黑盒测试


等价划分


使用等价划分方法设计测试用例有两个步骤：


1


确定等价类

**有效等价类**代表对程序的有效输入；**无效等价类**代表的是其他不正确的任何输入。如果需要，我们还可以将一个等价类划分为更小的一些等价类。


比如，规格说明规定了“请输入书籍的数量（1~99）以及书籍的类型（硬皮、软皮或活页）”。它们对应的等价类分别如下：

**书籍数量**
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaY8l5YicXpxce2RAuvMs7ty019oSgUQTcqQbZxdibhIbcmRUfrbVrkZTuA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)
**书籍类型**
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYm4Y3XHicpTScricT65SLqZz8urLPZbMTc7HITDJEwWynQEdicHgRDaWNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)




2


生成测试用例

1. 为每个等价类设置编号。


**输入条件**

**有效等价类**

**无效等价类**


书籍数量


①1≤X≤99


②X<1③x>99


书籍类型


④硬皮⑤软皮


⑥活页


⑦其他

2. 编写测试用例，**尽****可能多的覆盖尚未被覆盖的有效等价类。**直到所有的有效等价类都被测试用例覆盖。测试用例及其覆盖的有效等价类如下：


50，硬皮

50，软皮

50，活页


    覆盖①④


    覆盖①⑤


    覆盖①⑥


3. 编写测试用例，**覆盖一个且仅一个尚未被覆盖的无效等价类。**直到所有的无效等价类都被测试用例所覆盖。测试用例及其覆盖的无效等价类如下：


-50，硬皮

199，软皮

50，线装


    覆盖②


    覆盖③


    覆盖⑦
![](https://mmbiz.qlogo.cn/mmbiz_gif/g05vlhgH9lto2RQnnBEXs4vatuo7k3CVULXYljfYPNJz37EjnQrGsx9hEtPhJonWQ0JQZRZPBMOgA8Qu1b4VBw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

用单个的测试用例覆盖无效等价类，是因为有些输入的错误检查可能会屏蔽或取代其他输入的错误检查。比如②⑦，也许程序提示“非法的书籍数量”后，就不会执行对书籍类型的检查了。





边界值分析


经验证明，考虑了边界条件的测试用例比其他没有考虑边界条件的测试用例，具有更高的测试回报率。所谓边界条件，**是指输入和输出等价类中恰好处在边界、或超过边界、或在边界以下的状态。**


上例中的书籍数量范围是1~99，那么应该针对0，1和99，100的情况分别设计测试用例。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYfkQiaCYNbWP4RR15DdZUtMicM9S7rEjvITGZicHliaVRgeIYRTrLYzHxGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

从定义可以看出，等价划分只关注输入空间（输入等价类）的不同，边界值分析还需要从输出空间（输出等价类）设计测试用例。举例来说：


某个程序按月计算个人所得税的速算扣除数，且最小金额是0，最大金额是13,505。使用边界值分析法，应该设计测试用例测试速算扣除数结果为0和13505的情况。此外，还应观察是否可能设计出导致速算扣除数为负数，或者超过13505的测试用例。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYqv5ez1Q2xsdVPPqFRI6mTe2vbDkSqoIliboRibiaY95bAkYvecWc9kiagw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_gif/g05vlhgH9lto2RQnnBEXs4vatuo7k3CVULXYljfYPNJz37EjnQrGsx9hEtPhJonWQ0JQZRZPBMOgA8Qu1b4VBw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

边界值分析法和等价划分重要的区别是，**等价划分**是从等价类中挑选任意一个元素作为测试数据；**边界值分析法**考察正处于等价划分边界或在边界附近的状态。





因果图

边界值分析和等价划分的缺点是，未对**输入条件的组合情况**、输入条件之间的**相互制约关系**进行分析。



1


因果图的基本关系

**恒等**（Identify）:若a为1，则b为1；否则b为0。

**非**（NOT）:若a为1，则b为0；否则b为1。

**或**（OR）:若a或b或c为1，则d为1；否则d为0。

**与**（AND）:若a和b和c都为1，则d为1；否则d为0。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYic7V6icV2oq7icpicQJa3hCT6WN445BdfewID9WLlLmUXKcj54up2OlP5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaY2814p8FlM3k7xAb1pWsDaUMFlbVKMsAuFUszJUlAIib6TNRqQt5qjLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYCBhvK7qibNjem4PdDnJicF2DMl744GcLjXUXTA9UibqAnpU9KTcZp9Y0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYW5nJmSO0oefjsk4ebPahbALllo7m5a75CtWfUpwsaKHVXD7iaKicHmDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

2


因果图的约束条件

**对于输入条件的约束有E、I、O、R四种：**


**异**（E）:E必须总为真，而a、b最多只有一个为1。

**或**（I）:I为真时，a、b和c中至少有一个必须为1。

**唯一**（O）:a、b中，有且仅有一个必须为1。

**要求**（R）:如果a为1，b也必须为1。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYsArTtoktGPZibaYo5RLX4Lan8PJ4icDXnDmzQmY66WKTTfcHpGoNRGVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYRsZsHZQewnnYQfRlm5Qg2ASc4sqklUASB3qeYRzFWQrgYVzLmuP0rQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aCFdY9n6xrZz5rdk9BNviaYkW7Sr9EB9MmBMwAOfoAdyWk2teuZO4yicdtqib08w8HzsYHRWmZgdyCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aiaevicJFsbq2u0Nxh14xicndldpoticVcFhU3v4q4zj8UEZV0YuY25FHojJ3gt1T54CLL0sFVKInONg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)
**对于输出结果的约束只有M一种：**

**屏蔽**（M）:如果结果a为0，则b强制为0。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aiaevicJFsbq2u0Nxh14xicnd2U5ZHISkQE8qV2IuhOUsHLVuyD1ac5IC7PvhQ05WnXWGgOPxNydq9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

3


生成测试用例的过程


1. 将规格说明分解为可执行的片段，确定“因”和“果”，同时为每个“因”和“果”都赋予唯一的编号。


所谓“因”，是指一个明确的输入条件等价类。所谓“果”，是指一个输出条件或系统转换（输入对程序或系统状态的延续影响）。


2. 分析规格说明的语义，转换为因果图。


3. 为因果图添加约束条件。


4. 将因果图转换为判定表。


5. 将判定表的每一列转换为一个测试用例。



4


一个简单的例子

**规格说明：“***第一列中的字符必须是‘A’或‘B’，第二列中的字符必须是一个数字。在这种情况下，对文件进行更新。如果第一个字符不正确，产生提示信息X12。如果第二个字符不是数字，产生提示信息X13。***”**


（一）分解规格说明，得到“因”如下：



1 —— 第一列的字符是“A”

2 —— 第一列的字符是“B”

3 —— 第二列的字符是一个数字


“果”如下：


70 —— 对文件做了更新


71 —— 产生提示信息X12


72 —— 产生提示信息X13


（二）分析规格说明的语义，并将其转换为因果图如下：
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aiaevicJFsbq2u0Nxh14xicnd9mmxtKIkFzXpabzvKMahNJPd27PWxibyxjhc8d8f1icdnwfnnoiajwBYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

（三）原因①和原因②不可能同时成立，为因果图添加对应的约束条件：
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aiaevicJFsbq2u0Nxh14xicndOdicjicnqIKb8FzX3F5ud7iaTnoh8NBPr8nqicjKwHfuDXMyKCz8iap8Y7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

（四）“因”是条件，“果”是动作。将因果图转换为判定表，每一列代表一个测试用例。

![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8aiaevicJFsbq2u0Nxh14xicndpiahHyH9sicWibyTOzP39NdkyNRmxN7fZuD8g3J6yUftLbhibWqJNBIzXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

（五）将判定表中的列转换为测试用例。



① A，1



② B，1


③ 1，1


④ 1，A


⑤ A，A


⑥ B，B





5


附：将因果图转换为判定表的思路

（以上述的例子来说明）
- 

选择一个“果”作为当前状态。例：71。

- 

对因果图回溯，找出导致该“果”为1的所有因的组合（需要考虑到约束条件）。例：001，000。

- 

在判定表中为每个“因”的组合生成一列。例：（列3）和（列4）。

- 

对于每种“因”的组合，判断所有其他“果”的状态，并放置在对应的每一列中。例：已得在001，000两种组合下结点71的结果为1。判断在“因”为001的组合下，得到70和72的结果为0。判断在“因”为000的组合下，得到70的结果为0，72的结果为1。将“果”的状态填入其对应的列。


**对因果图进行回溯时，需要做到以下考虑：**


1)  当回溯经过一个结果为1的OR结点时，不要将OR结点的1个以上的输入同时设为1。


2)  当回溯经过一个结果为0的AND结点时，应列举出导致该结果为0的所有输入情况的组合。然而，当该AND结点的一个输入条件为0时，其他输入有一个或更多的1，则不必考虑其他输入为1的所有情况。


3)  当回溯经过一个结果为0的AND结点时，所有输入皆为0的这一种情况应当列举出来。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8ZMRCmkpVLOXrSzxYjVbgJhibwvcdMjW7ibdxoKwlC5YbsHX7nKBWs0TIQZxJwZh4ALQ3627EgywWPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

假设我们需要找出下面因果图中，所有导致输出状态为0的输入条件。
![](https://mmbiz.qlogo.cn/mmbiz_png/j8pgMq90y8ZMRCmkpVLOXrSzxYjVbgJhiaibBBnwnI4zMYIicrWk75gcByDlM2QzChJcdRNxqcibNsOQXhhpI8XUGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

(1)  根据上述第3)条思路，我们只需列出使得结点⑤和结点⑥皆为0的情况。结点①②③④的取值状态为：


0，0，0，0


（5=0，6=0）



(2)  根据第2)条思路，对于结点⑤为1而结点⑥为0的情况，应该列出导致⑥为0的所有输入情况组合。同时，只需列出一种使得⑤为1的情况即可，不需要列出⑤为1时的所有输入情况组合。又根据第1)条思路，当结点⑤为1时，我们不应将结点①和②同时设为1。于是，得到结点①②③④的取值状态：


1，0，0，0


1，0，0，1


1，0，1，0


（5=1，6=0）



（5=1，6=0）


（5=1，6=0）


同样的，对于⑤为0而⑥为1的情况，也只需要列出⑥为1的一种情况即可（尽管在本例中也只有这一种）。


0，0，1，1


（5=0，6=1）



因果图有助于用一个系统的方法选择出高效的测试用例集。它还有一个额外的好处，就是可以指出规格说明的**不完整性**和**二义性**。但通常它不能生成全部应该被确定的有效测试用例。
![](https://mmbiz.qlogo.cn/mmbiz_gif/g05vlhgH9lto2RQnnBEXs4vatuo7k3CVULXYljfYPNJz37EjnQrGsx9hEtPhJonWQ0JQZRZPBMOgA8Qu1b4VBw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)
因果图方法没有充分考虑边界条件。建议，最好是单独考虑边界值分析。这不意味着我们要为此增加相应多的测试用例，而是在由因果图生成测试用例时，可以将边界条件分析一并考虑进去。最好的结果是既满足了两方面的目标，又不需要增加新的测试用例。






错误推测


错误猜测是一项依赖于直觉的非正规的过程，其基本思想是人们利用直觉和经验猜测可能犯得错误或错误易发情况的清单，然后编写测试用例来暴露这些错误。


例如，程序输入中出现0这个值，就是一种错误易发情况。因此可以编写测试用例检查特定的输入值中有0，或特定的输出值被强制为0的情况。





同样，在出现输入或输出数目不定的地方，如，对某个列表进行搜索，结果为“空列表”或“只包含一个”条目的列表，也是错误容易发生的情况。





另一个思想是，在阅读规格说明时，联系程序员可能做的假设来确定测试用例。如规格说明中被忽略的一些内容，要么是由于偶然因素，要么是程序员认为其显而易见。


测试策略


测试用例设计方法可以组合为一个整体的策略，因为每一种方法都可以提供一组具体的有用的测试用例，但是都不能提供一个完整的测试用例集。


一组合理的策略如下：

1


如果规格说明包含**输入条件组合**的情况，应首先使用**因果图**分析法。



2


任何情况下都应使用**边界值分析**法。边界值分析法可以产生一系列补充的测试条件，多数甚至全部条件可以被整合到因果图分析中。


3


为输入和输出确定**有效和无效等价类**，在必要情况下对上面确认的测试用例进行补充。


4


使用**错误猜测**增加更多的测试用例。


5


针对上述测试用例，检查程序的**逻辑结构**。如果覆盖准则未能被前四个步骤中确定的测试用例所满足，并且满足准则也并非不可能，那么增加足够数量的测试用例，以使覆盖准则得到满足。




觉得不错记得点赞哦

![](https://mmbiz.qlogo.cn/mmbiz_jpg/eE7oZGQ0ZIZDsk0iazgNZvhJezrwaxF4xHy77IPT1FjLVTS4yiavmQDRmw0a2Xf3eQ0tyt0dgamszicoL5ERDXlLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)◆来源:图文来自网络，如有侵权请联系删除




