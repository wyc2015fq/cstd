# 8-使用QT5的鼠标事件和滚轮事件 - xqhrs232的专栏 - CSDN博客
2018年07月23日 14:44:41[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：68
个人分类：[X11/Qt/Qt quick/Qxml界面技术](https://blog.csdn.net/xqhrs232/article/category/6455019)
原文地址::[https://blog.csdn.net/a3631568/article/details/53898457](https://blog.csdn.net/a3631568/article/details/53898457)
**使用QT5的鼠标事件和滚轮事件**
----完成鼠标左键拖动窗口，双击全屏，滚轮放大缩小窗口大小
         这里使用的是QMouseEvent类里面的鼠标事件，通常进行重定义部件的鼠标事件处理函数来实现自定义的内容操作。同样，鼠标滚轮操作是利用QWheelEvent实现滚轮事件。
其中:
- 
`voidmousePressEvent(QMouseEvent *event);这个是鼠标按下的时候调用该函数`
- 
`voidmouseReleaseEvent(QMouseEvent *event);这个是鼠标松开按键的时候调用`
- 
`voidmouseDoubleClickEvent(QMouseEvent *event);这个是鼠标双击的时候调用`
- 
`voidmouseMoveEvent(QMouseEvent *event);这个是鼠标按下状态中，移动的时候调用`
- 
`void wheelEvent(QWheelEvent*event); 这个是鼠标上下滚轮的时候会调用`
上述鼠标事件并不完全，但是对于一般我们使用完全足够了。
通过重定义上述函数来实现鼠标、滚轮操作后的自定义的内容处理。
现在我们来通过一个具体的程序来看看如何实现的。
**首先，新建工程。**我们先新建一个QT Gui应用，项目名称我命名为QtEvent，其他的全部默认。
**第二步，添加头文件与变量。**我们在mainwindows.h里添加头文件：
#include<QMouseEvent>
#include<QWheelEvent>
然后再添加：
- 
`protected:`
- 
`voidmousePressEvent(QMouseEvent*event);//按下`
- 
`voidmouseMoveEvent(QMouseEvent*event);//按下移动`
- 
`voidmouseReleaseEvent(QMouseEvent*event);//松开`
- 
`voidmouseDoubleClickEvent(QMouseEvent*event);//双击`
- 
`voidwheelEvent(QWheelEvent*event);//滚轮`
- 
- 
`private:`
- 
`QPointoffset;//储存鼠标指针位置与窗口位置的差值`
- 
`QCursorcursor;//创建光标，保存默认光标形状`
其中offset是为了窗口拖动的需要的变量，用于存储鼠标指针位置和窗口位置之间的差值，cursor是为了保存默认光标形状，当拖动窗口的时候光标变为手掌，表示进入拖动状态，如果需要自定义光标图标，也可以用QCursor类。
**第三步，重定义上述声明的鼠标滚轮函数。**
代码如下:
- 
`void MainWindow::mousePressEvent(QMouseEvent*event){`
- 
`if(event->buttons()==Qt::LeftButton){//如果鼠标按下的是左键`
- 
`//则改变鼠标形状为手掌，表示拖动状态。`
- 
`QCursorcursor1;//创建光标对象`
- 
`cursor1.setShape(Qt::OpenHandCursor);//设置光标形态`
- 
`setCursor(cursor1);//使用手掌光标`
- 
- 
`//这里获取指针位置和窗口位置的差值`
- 
`offset=event->globalPos()-this->pos();`
- 
- 
`}`
- 
`}`
- 
`void MainWindow::mouseMoveEvent(QMouseEvent*event){`
- 
`if(event->buttons()==Qt::LeftButton){//如果鼠标按下的是左键`
- 
`QPointtmp;`
- 
`tmp=event->globalPos()-offset;`
- 
`move(tmp);`
- 
`}`
- 
`}`
- 
- 
`void MainWindow::mouseReleaseEvent(QMouseEvent*event){`
- 
`//拖动完成后，光标恢复默认形状`
- 
`setCursor(cursor);`
- 
`//或者直接用自带恢复鼠标指针形状的函数为：QApplication::restoreOverrideCursor();`
- 
`//但是需要前面设置哪个是默认的光标形状，用这个函数setOverrideCursor()函数`
- 
`}`
- 
- 
`void MainWindow::mouseDoubleClickEvent(QMouseEvent*event){`
- 
`if(event->buttons()==Qt::LeftButton){//如果鼠标按下的是左键`
- 
`if(windowState()!=Qt::WindowFullScreen)//如果窗口不是全屏，则让它全屏`
- 
`setWindowState(Qt::WindowFullScreen);`
- 
`else`
- 
`setWindowState(Qt::WindowNoState);//否则恢复以前的大小`
- 
- 
`}`
- 
`}`
- 
`void MainWindow::wheelEvent(QWheelEvent*event){`
- 
`QRecttmp=this->geometry();//获取窗口的位置以及大小并保存在tmp中。`
- 
`if(event->delta()>0){//如果滚轮往上滚`
- 
`tmp.setWidth(tmp.width()+25);//设置宽度为原有基础上+25`
- 
`tmp.setHeight(tmp.height()+15);//设置窗口高度为原有基础上+20`
- 
`this->setGeometry(tmp);//然后设置窗口大小。`
- 
- 
`}else{//同样的`
- 
`tmp.setWidth(tmp.width()-25);`
- 
`tmp.setHeight(tmp.height()-15);`
- 
`//如果缩小之后的窗口不小于设置的最小窗口尺寸，则执行缩放。`
- 
`if(this->minimumSize().height()<tmp.height()&&this->minimumSize().width()<tmp.width())`
- 
`this->setGeometry(tmp);`
- 
- 
`}`
- 
`}`
第四步，最终执行代码：
![](https://img-blog.csdn.net/20161227194159754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTM2MzE1Njg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
**同样的，如果需要用到键盘监听，步骤跟鼠标监听是一个性质，这里就不再描述。**
**这里需要注意的是：全屏模式是会把标题栏都屏蔽掉的，相当于全屏打游戏的那种全屏，如果只需要实现最大化的功能，那么只需要把**WindowFullScreen**改为**WindowMaximized**就可以了。**
**以上代码还可以继续改进：譬如当全屏或者最大化的时候还可以拖动窗口，这显然是不合理的，所以需要进一步在mousePressEvent()和mouseMoveEvent()添加判断，如果为全屏/最大化模式，则不允许拖动。**
**修改代码如下：**
**……..**
**…….**
**…….**
if(event->buttons()==Qt::LeftButton&&windowState()!=Qt::WindowMaximized&&windowState()!=Qt:: WindowFullScreen){
         ……..
}
最后就完善了改进。
如果你觉得系统自带的标题栏太丑或者不符合口味，你可以根据上面的知识自己屏蔽标题栏，然后实现添加或修改最小化、最大化、关闭按钮的个性化外观，最后完成一个如画如诗意一般的窗口。
