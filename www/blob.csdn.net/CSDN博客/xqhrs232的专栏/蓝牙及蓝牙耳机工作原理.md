# 蓝牙及蓝牙耳机工作原理 - xqhrs232的专栏 - CSDN博客
2015年07月01日 15:20:48[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：739
个人分类：[Bluetooth技术](https://blog.csdn.net/xqhrs232/article/category/2908395)
原文地址::[http://wangjiajun53880.blog.163.com/blog/static/117001394201072552925818/](http://wangjiajun53880.blog.163.com/blog/static/117001394201072552925818/)
相关文章
1、蓝牙及蓝牙耳机工作原理  ----[http://www.360doc.com/content/11/0922/13/474846_150340699.shtml](http://www.360doc.com/content/11/0922/13/474846_150340699.shtml)
2、蓝牙的工作原理----[http://blog.csdn.net/zhaoshuzhaoshu/article/details/38893011](http://blog.csdn.net/zhaoshuzhaoshu/article/details/38893011)
3、Bluetooth 硬件错误10050----[http://bbs.csdn.net/topics/350050671](http://bbs.csdn.net/topics/350050671)
4、wince蓝牙硬件错误10050（控制器不存在）解决方法----[http://club.autohome.com.cn/bbs/thread-c-875-38495303-1.html](http://club.autohome.com.cn/bbs/thread-c-875-38495303-1.html)
**1蓝牙技术的特点**
**1.1****蓝牙协议体系结构**
　　整个蓝牙协议体系结构可分为底层硬件模块、中间协议层和高端应用层三大部分。链路管理层(LMP)、基带层(BBP)和蓝牙无线电信道构成蓝牙的底层模块。BBP层负责跳频和蓝牙数据及信息帧的传输。LMP层负责连接的建立和拆除以及链路的安全和控制，它们为上层软件模块提供了不同的访问人口，但是两个模块接口之间的消息和数据传递必须通过蓝牙主机控制器接口的解释才能进行。也就是说，中间协议层包括逻辑链路控制与适配协议(L2CAP)、服务发现协议(SDP)、串口仿真协议(RFCOMM)和电话控制协议规范(TCS)。L2CAP完成数据拆装、服务质量控制、协议复用和组提取等功能，是其他上层协议实现的基础，因此也是蓝牙协议栈的核心部分。SDP为上层应用程序提供一种机制来发现网络中可用的服务及其特性。在蓝牙协议栈的最上部是高端应用层，它对应于各种应用模型的剖面，是剖面的一部分。目前定义了13种剖面。
**1.2 蓝牙低层模块**
　　蓝牙的低层模块是蓝牙技术的核心，是任何蓝牙设备都必须包括的部分。
　　蓝牙工作在2.4GHZ的ISM频段。采用了蓝牙结束的设备讲能够提供高达720kbit/s 的数据交换速率。
　　蓝牙支持电路交换和分组交换两种技术，分别定义了两种链路类型，即面向连接的同步链路(SCO)和面向无连接的异步链路(ACL)。
　　为了在很低的功率状态下也能使蓝牙设备处于连接状态，蓝牙规定了三种节能状态，即停等(Park)状态、保持(Hold)状态和呼吸(Sniff)状态。这几种工作模式按照节能效率以升序排依次是：Sniff模式、Hold模式、Park模式。
　　蓝牙采用三种纠错方案：1/3前向纠错(FEC)、2/3前向纠错和自动重发(ARQ)。前向纠错的目的是减少重发的可能性，但同时也增加了额外开销。然而在一个合理的无错误率环境中，多余的投标会减少输出，故分组定义的本身也保持灵活的方式，因此，在软件中可定义是否采用FEC。一般而言，在信道的噪声干扰比较大时蓝牙系统会使用前向纠错方案，以保证通信质量：对于SCO链路，使用1/3前向纠错；对于ACL链路，使用2/3前向纠错。在无编号的自动请求重发方案中，一个时隙传送的数据必须在下一个时隙得到收到的确认。只有数据在收端通过了报头错误检测和循环冗余校验(CRC)后认为无错时，才向发端发回确认消息，否则返回一个错误消息。
　　蓝牙系统的移动性和开放性使得安全问题变得及其重要。虽然蓝牙系统所采用的调频技术就已经提供了一定的安全保障，但是蓝牙系统仍然需要链路层和应用层的安全管理。在链路层中，蓝牙系统提供了认证、加密和密钥管理等功能。每个用户都有一个个人标识码(PIN),它会被译成128bit的链路密钥(Link
 Key)来进行单双向认证。一旦认证完毕，链路就会以不同长度的密码(Encryphon Key)来加密(此密码以shit为单位增减，最大的长度为128bit)链路层安全机制提供了大量的认证方案和一个灵活的加密方案(即允许协商密码的长度)。当来自不同国家的设备互相通信时，这种机制是极其重要的，因为某些国家会指定最大密码长度。蓝牙系统会选取微微网中各个设备的最小的最大允许密码长度。例如，美国允许128bit的密码长度，而西班牙仅允许48bit，这样当两国的设备互通时，将选择48bit来加密。蓝牙系统也支持高层协议栈的不同应用体内的特殊的安全机制。例如两台计算机在进行商业卡信息交流时，一台计算机就只能访问另一台计算机的该项业务，而无权访问其他业务。蓝牙安全机制依赖PIN在设备间建立信任关系，一旦这种关系建立起来了，这些PIN就可以存储在设备中以便将来更快捷地连接。
**1.3 软件模块**
L2CAP是数据链路层的一部分，位于基带协议之上。L2CAP向上层提供面向连接的和无连接的数据服务，它的功能包括：协议的复用能力、分组的分割和重新组装(Segmentation And Reaassembly)以及提取(Group
 Abstraction)。L2CAP允许高层协议和应用发送和接受高达64K Byte的数据分组。
SDP为应用提供了一个发现可用协议和决定这些可用协议的特性的方法。蓝牙环境下的服务发现与传统的网络环境下的服务发现有很大的不同，在蓝牙环境下，移动的RF环境变化很大，因此业务的参数也是不断变换的。SDP将强调蓝牙环境的独特的特性。蓝牙使用基于客户/服务器机制定义了根据蓝牙服务类型和属性发现服务的方法，还提供了服务浏览的方法。
RFCOMM是射频通信协议，它可以仿真串行电缆接口协议，符合ETSI0710串口仿真协议。通过RFCOMM，蓝牙可以在无线环境下实现对高层协议，如PPP、TCP/IP、WAP等的支持。另外，RFCOMM可以支持AT命令集，从而可以实现移动电话机和传真机及调制解调器之间的无线连接。
　　蓝牙对语音的支持是它与WLAN相区别的一个重要的标志。蓝牙电话控制规范是一个基于ITU-T建议Q.931的采用面向比特的洗衣，它定义了用于蓝牙设备间建立语音和数据呼叫的呼叫控制信令以及用于处理蓝牙TCS设备的移动性管理过程。
**2.语音网关（Audio Gate）**
Windows Embedded CE supports Headset Profile and the Hands-Free Profile by providing the Audio Gateway (AG) service that links Bluetooth devices by using the Winsock interface
 to the Bluetooth Protocol Stack. This service provides the functionality to interface with TAPI to control a cellular phone and route audio to the Bluetooth chip.
The AG service is implemented as a DLL, Btagsvc.dll that resides in Services.exe and can be controlled by external modules through IOCTLs provided by Services.exe.
The AG service supports audio routing by using the audio driver message, WODM_BT_SCO_AUDIO_CONTROL, that routes audio to the Bluetooth chip.
由此可见，微软已经提供了语音网关服务来支持蓝牙耳机，所以，我们要做的也就是将语音网关服务（AG）Enable.
**3.蓝牙耳机的工作原理**
下面重点讲述下蓝牙耳机的工作原理：
关于音频流的蓝牙传输可以通过两个方式：
1)通过PCM接口来传送
2）通过模拟UART来传送
下面分别来讲述：
1）通过PCM接口来传送
通过音频播放器（eg: Media Player）来打开音频文件，调用Audio驱动，音频文件通过解码后，由PCM输出到Host端蓝牙模块的PCM输入端，接着，经过蓝牙模块的处理后，由RF无线模块发送给Client 端蓝牙设备。
Client端蓝牙设备经由无线接收模块后，滤波，稳压，经微处理芯片处理后，直接由Speaker播放。
2）通过模拟UART来传送
通过设置注册表【HKEY_LOCAL_MACHINE\Services\BTAGSVC】   IsEnabled ＝1 使得系统引导时自动加载语音网关（AG）服务。
首先，通过手动配置建立Host端蓝牙设备与Client端蓝牙设备ACL链接（面向无连接的异步链路），接着在Applicaiton或Audio Driver中调用IOCTL_AG_OPEN_AUDIO，重新建立Host端蓝牙设备与Client端蓝牙设备SCO链接（面向连接的同步链路），接着AG自动发送waveOutMessage((HWAVEOUT)i,
 WODM_BT_SCO_AUDIO_CONTROL, 0, TRUE); 从而建立了Audio至蓝牙芯片之间的通道，也即，实现了音频流到蓝牙模块的传送。
然后，经由主机端蓝牙模块将音频流打包经由RF模块发送出去。
客户端蓝牙耳机接收到无线音频包后，滤波，稳压，经微处理芯片处理后，由PCM传送给音频编解码器芯片，最后，由Speaker播放。
下面这段段码是建立Host端蓝牙设备与Client端蓝牙设备SCO链路
HANDLE h = CreateFile(L"BAG0:",0,0,NULL,OPEN_EXISTING,0,NULL);
    if (INVALID_HANDLE_VALUE == h) {
        wprintf(L"Error calling CreateFile on Audio Gateway.\r\n");
        return 0;
    }
if (onaudio==1) {
                wprintf(L"Opening Bluetooth audio...\n");
                BOOL fStatus = DeviceIoControl(h,IOCTL_AG_OPEN_AUDIO,NULL,0,NULL,0,NULL,NULL);
                if (FALSE == fStatus) {
                    wprintf(L"Operation failed: %d.\n", GetLastError());
                }
                else {
                    wprintf(L"Operation successful.\n");   
                }
                CloseHandle(h);
                return 0;
            }
            else if (onaudio==0) {
                wprintf(L"Closing Bluetooth audio...\n");
                BOOL fStatus = DeviceIoControl(h,IOCTL_AG_CLOSE_AUDIO,NULL,0,NULL,0,NULL,NULL);
                if (FALSE == fStatus) {
                    wprintf(L"Operation failed: %d.\n", GetLastError());
                }
                else {
                    wprintf(L"Operation successful.\n");   
                }
                CloseHandle(h);
                return 0;
            }
![Headset and Hands-free Profiles架构图](http://u.jimdo.com/www24/o/s03b0645865ba5a27/img/i43794d642fb92baa/1279280267/std/headset-and-hands-free-profiles%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)Headset
 and Hands-free Profiles架构图
