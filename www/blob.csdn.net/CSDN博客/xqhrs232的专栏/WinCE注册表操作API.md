# WinCE注册表操作API - xqhrs232的专栏 - CSDN博客
2013年08月28日 11:46:23[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：816
原文地址::[http://www.cnblogs.com/cvbnm/articles/1958099.html](http://www.cnblogs.com/cvbnm/articles/1958099.html)
1）WinCE注册表
     注册表是一个系统数据库，保存操作系统配置信息和运作状态。结构基本相同：键名最大长度255个字符、数据最大4k、子键深度最大值16层。
    WinCE支持四个根键：
        HKEY_CLASSES_ROOT，OLE和文件类型匹配配置数据；
        HKEY_LOCAL_MACHINE，硬件和驱动配置数据；
        HKEY_CURRENT_USER，用户配置数据；
        HKEY_USERS，适用于所有用户的数据。
2、WinCE注册表的实现方式
1）基于RAM的注册表
     存放在内存中。如果系统断电，改动都会丢失。优点是读写访问操作非常高效。因此，适用于有电池只热启动的设备。
2）基于Hive的注册表
     存放在文件上，分为几个文件：
        ①Boot Hive，一般只在启动时使用。
        ②System Hive，系统的数据。
        ③User Hive，HKEY_CURRENT_USER的数据，每个用户都有一个User.hv。
     基于Hive的注册表适用于有外存且经常冷启动的设备。Hive把系统数据和用户数据分开存放(单独的User.hv)，这表示可以提供多用户支持。
3、WinCE采用Hive的注册表。
**使用API操作注册表**：
注册表结构：
根键——键（值名，类型【字符串、数值、二进制】，值）
◆  创建一个键
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
HKEY
```
```cpp
hkey
 = NULL;  <br>
```
```cpp
DWORD
```
```cpp
dwRet
 = 0;
```
```cpp
if
```
```cpp
(ERROR_SUCCESS
 == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
```
```cpp
"键名"
```
```cpp
,
 0,
```
```cpp
""
```
```cpp
,
```
```cpp
//类名
```
```cpp
```
```cpp
REG_OPTION_NON_VOLATILE,
```
```cpp
//REG_OPTION_指明键永久保留
```
```cpp
```
```cpp
KEY_READ|KEY_WRITE,
```
```cpp
//KEY_访问模式
```
```cpp
```
```cpp
NULL,
```
```cpp
//安全结构默认
```
```cpp
```
```cpp
&hKey,
 &dwRet
```
```cpp
//打开状态REG_OPENED_EXISTING_KEY
 \ CREATED_NEW_KEY
```
```cpp
```
```cpp
)){
```
```cpp
```
```cpp
//操作hKey
```
```cpp
}
```
◆  打开一个键
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
HKEY
```
```cpp
hkey
 = NULL;
```
```cpp
if
```
```cpp
(ERROR_SUCCESS
 == RegOpenKeyEx(HKEY_CURRENT_USER,
```
```cpp
"键名"
```
```cpp
,
 0, KEY_ALL_ACCESS, &hkey))
```
◆  查询键值【UNICODE、主要类型】
注意：使用RegQueryValueEx时，有个窍门，如果想根据值的长度建立一个buffer(第三个参数）。可以调用两次RegQueryValueEx，第一次让第三个参数设为NULL，此时第四个参数就是值的长度，然后建立这个长度大小的buffer，再重新调用RegQueryValueEx即可。
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
DWORD
```
```cpp
dwtype
 = 0;
```
```cpp
DWORD
```
```cpp
dwlength
 = 0;
```
```cpp
long
```
```cpp
retcode
 = RegQueryValueEx(hkey, _T(
```
```cpp
"键名"
```
```cpp
),
 0, &dwtype, NULL, &dwlength);
```
```cpp
//类型、长度，内容为NULL
```
```cpp
if
```
```cpp
(ERROR_SUCCESS
 == retcode)
```
```cpp
//成功获取长度和类型信息
```
```cpp
{
```
```cpp
```
```cpp
if
```
```cpp
(REG_SZ
 == dwtype || REG_BINARY == dwtype)
```
```cpp
//字符串和二进制类型
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
byte*
 buf = NULL;
```
```cpp
```
```cpp
buf
 =
```
```cpp
new
```
```cpp
byte[dwlength];
```
```cpp
```
```cpp
memset
```
```cpp
(buf,
 0, dwlength);
```
```cpp
```
```cpp
RegQueryValueEx(hkey,
 _T(
```
```cpp
"键名"
```
```cpp
),
 0, &dwtype, buf, &dwlength);
```
```cpp
//内容
```
```cpp
```
```cpp
```
```cpp
if
```
```cpp
(REG_SZ
 == dwtype)
```
```cpp
```
```cpp
std::wcout<<(
```
```cpp
TCHAR
```
```cpp
*)buf;
```
```cpp
```
```cpp
if
```
```cpp
(REG_BINARY
 == dwtype)
```
```cpp
```
```cpp
std::wcout<<buf;
```
```cpp
```
```cpp
delete
```
```cpp
[]buf;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
if
```
```cpp
(REG_DWORD
 == dwtype)
```
```cpp
//数值类型
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
DWORD
```
```cpp
i
 = 0;
```
```cpp
```
```cpp
RegQueryValueEx(hkey,
 _T(
```
```cpp
"键名"
```
```cpp
),
 0, &dwtype, (
```
```cpp
LPBYTE
```
```cpp
)(&i),
 &dwlength);
```
```cpp
//内容
```
```cpp
```
```cpp
std::wcout<<i;
```
```cpp
```
```cpp
}
```
```cpp
}
```
◆  设置键值
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
RegSetValueEx(hkey,
 _T(
```
```cpp
"1"
```
```cpp
),
 0, REG_SZ, (
```
```cpp
LPBYTE
```
```cpp
)_T(
```
```cpp
"内容"
```
```cpp
),
 len));
```
```cpp
//字符串
```
```cpp
DWORD
```
```cpp
dwn;
```
```cpp
int
```
```cpp
ret
 = RegSetValueEx(hkey, _T(
```
```cpp
"1"
```
```cpp
),
 0, REG_DWORD, (
```
```cpp
LPBYTE
```
```cpp
)&dwn,
 4);
```
```cpp
//数值
```
```cpp
byte
 buf[N];
```
```cpp
RegSetValueEx(hkey,
 _T(
```
```cpp
"1"
```
```cpp
),
 0, REG_BINARY, buf, 10);
```
```cpp
//二进制
```
◆  枚举键、值
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
TCHAR
```
```cpp
name[N];
```
```cpp
memset
```
```cpp
(name,
 0, N);
```
```cpp
DWORD
```
```cpp
len1=N;
```
```cpp
while
```
```cpp
((ret
 = RegEnumKey(hkey,i,name,0))==0) {
```
```cpp
```
```cpp
//TCHAR[]
 不用反复memset，每次传字符串末尾会填0
```
```cpp
```
```cpp
++i;
```
```cpp
}
```
```cpp
//接收的空间不够，会返回错误码ret
 —— 注册表名最长255个字节
```
注意：RegEnumValue中有同时为in-out型的参数。查阅MSDN要留意参数类型和方式，对这类参数要注意可能要复位
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
DWORD
```
```cpp
dwtype
 = 0;
```
```cpp
TCHAR
```
```cpp
name[N1];
```
```cpp
memset
```
```cpp
(name,
 0, N1);
```
```cpp
DWORD
```
```cpp
len1
 = N1;
```
```cpp
byte
 value[N2];
```
```cpp
memset
```
```cpp
(value,
 0, N2);
```
```cpp
DWORD
```
```cpp
len2
 = N2;
```
```cpp
int
```
```cpp
i
 = 0;
```
```cpp
long
```
```cpp
ret
 = 0;
```
```cpp
while
```
```cpp
((ret
 = RegEnumValue(hkey, i, name, &len1, 0, &dwtype, value, &len2))==0)
```
```cpp
{
```
```cpp
```
```cpp
//TCHAR[]不用反复memset，原因如前
```
```cpp
```
```cpp
len1
 = N1;
```
```cpp
```
```cpp
//byte[]就要注意，如果实际是字符类型也无妨，如果是二进制码没有结束符，所以提供了len
```
```cpp
```
```cpp
memset
```
```cpp
(value,
 0, LEN2);
```
```cpp
```
```cpp
len2
 = N2;
```
```cpp
```
```cpp
++i;
```
```cpp
}
```
```cpp
//要注意len参数同时是in-out型，调用一次会改变下一次传入的len值，所以每次要复位为原来大小
```
◆  删除键、值
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
RegDeleteValue(hKey,
```
```cpp
"键值名"
```
```cpp
);
```
```cpp
RegDeleteKey(hKey,
```
```cpp
"键名"
```
```cpp
);
```
◆  关闭键
[?](http://www.cnblogs.com/cvbnm/articles/1958099.html#)
```cpp
RegCloseKey(hKey);
```
