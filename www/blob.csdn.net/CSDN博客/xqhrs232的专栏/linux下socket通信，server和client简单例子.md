# linux下socket通信，server和client简单例子 - xqhrs232的专栏 - CSDN博客
2016年04月01日 23:31:32[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：705
个人分类：[Linux/Ubuntu/Fedora](https://blog.csdn.net/xqhrs232/article/category/906931)
原文地址:[http://www.oschina.net/code/snippet_97047_675](http://www.oschina.net/code/snippet_97047_675)
相关文章
1、linux下socket网络通信详解----[http://blog.163.com/linzhigui1988@126/blog/static/1018865812010815104137418/](http://blog.163.com/linzhigui1988@126/blog/static/1018865812010815104137418/)
2、Linux下C语言实现的Socket通信----[http://www.tuicool.com/articles/UNfAVf](http://www.tuicool.com/articles/UNfAVf)
3、[linux c学习笔记----UDP基础客户/服务编程(sendto,recvfrom)](http://lobert.iteye.com/blog/1769618)----[http://lobert.iteye.com/blog/1769618](http://lobert.iteye.com/blog/1769618)
4、[Linux C语言 UDP](http://blog.csdn.net/u013766436/article/details/51113525)----[http://blog.csdn.net/u013766436/article/details/51113525](http://blog.csdn.net/u013766436/article/details/51113525)
5、[Linux C语言 网络编程（二）](http://blog.csdn.net/u013766436/article/details/51113503)----[http://blog.csdn.net/u013766436/article/details/51113503](http://blog.csdn.net/u013766436/article/details/51113503)

### 1. [代码]c代码 server部分     [](http://www.oschina.net/code/snippet_97047_675#938)[](http://www.oschina.net/code/snippet_97047_675#939)[](http://www.oschina.net/code/snippet_97047_675#940)[](http://www.oschina.net/code/piece_full?code=675&piece=938#938)
[?](http://www.oschina.net/code/snippet_97047_675#)
```
```cpp
server.c
```
```cpp
====================================================================
```
```cpp
#include
 <netinet/in.h>    // for sockaddr_in
```
```cpp
#include
 <sys/types.h>    // for socket
```
```cpp
#include
 <sys/socket.h>    // for socket
```
```cpp
#include
 <stdio.h>        // for printf
```
```cpp
#include
 <stdlib.h>        // for exit
```
```cpp
#include
 <string.h>        // for bzero
```
```cpp
/*
```
```cpp
#include
 <sys/types.h>
```
```cpp
#include
 <sys/stat.h>
```
```cpp
#include
 <fcntl.h>
```
```cpp
#include
 <unistd.h>
```
```cpp
*/
```
```cpp
#define
 HELLO_WORLD_SERVER_PORT    6666
```
```cpp
#define
 LENGTH_OF_LISTEN_QUEUE 20
```
```cpp
#define
 BUFFER_SIZE 1024
```
```cpp
#define
 FILE_NAME_MAX_SIZE 512
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
**argv)
```
```cpp
{
```
```cpp
```
```cpp
//设置一个socket地址结构server_addr,代表服务器internet地址,
 端口
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in
 server_addr;
```
```cpp
```
```cpp
bzero(&server_addr,
```
```cpp
sizeof
```
```cpp
(server_addr));
```
```cpp
//把一段内存区的内容全部设置为0
```
```cpp
```
```cpp
server_addr.sin_family
 = AF_INET;
```
```cpp
```
```cpp
server_addr.sin_addr.s_addr
 = htons(INADDR_ANY);
```
```cpp
```
```cpp
server_addr.sin_port
 = htons(HELLO_WORLD_SERVER_PORT);
```
```cpp
```
```cpp
//创建用于internet的流协议(TCP)socket,用server_socket代表服务器socket
```
```cpp
```
```cpp
int
```
```cpp
server_socket
 = socket(PF_INET,SOCK_STREAM,0);
```
```cpp
```
```cpp
if
```
```cpp
(
 server_socket < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Create
 Socket Failed!"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
{
```
```cpp
```
```cpp
int
```
```cpp
opt
 =1;
```
```cpp
```
```cpp
setsockopt(server_socket,SOL_SOCKET,SO_REUSEADDR,&opt,
```
```cpp
sizeof
```
```cpp
(opt));
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
//把socket和socket地址结构联系起来
```
```cpp
```
```cpp
if
```
```cpp
(
 bind(server_socket,(
```
```cpp
struct
```
```cpp
sockaddr*)&server_addr,
```
```cpp
sizeof
```
```cpp
(server_addr)))
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server
 Bind Port : %d Failed!"
```
```cpp
,
 HELLO_WORLD_SERVER_PORT);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//server_socket用于监听
```
```cpp
```
```cpp
if
```
```cpp
(
 listen(server_socket, LENGTH_OF_LISTEN_QUEUE) )
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server
 Listen Failed!"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
while
```
```cpp
(1)
```
```cpp
//服务器端要一直运行
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
//定义客户端的socket地址结构client_addr
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in
 client_addr;
```
```cpp
```
```cpp
socklen_t
 length =
```
```cpp
sizeof
```
```cpp
(client_addr);
```
```cpp
```
```cpp
//接受一个到server_socket代表的socket的一个连接
```
```cpp
```
```cpp
//如果没有连接请求,就等待到有连接请求--这是accept函数的特性
```
```cpp
```
```cpp
//accept函数返回一个新的socket,这个socket(new_server_socket)用于同连接到的客户的通信
```
```cpp
```
```cpp
//new_server_socket代表了服务器和客户端之间的一个通信通道
```
```cpp
```
```cpp
//accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中
```
```cpp
```
```cpp
int
```
```cpp
new_server_socket
 = accept(server_socket,(
```
```cpp
struct
```
```cpp
sockaddr*)&client_addr,&length);
```
```cpp
```
```cpp
if
```
```cpp
(
 new_server_socket < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server
 Accept Failed!\n"
```
```cpp
);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
char
```
```cpp
buffer[BUFFER_SIZE];
```
```cpp
```
```cpp
bzero(buffer,
 BUFFER_SIZE);
```
```cpp
```
```cpp
length
 = recv(new_server_socket,buffer,BUFFER_SIZE,0);
```
```cpp
```
```cpp
if
```
```cpp
(length
 < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server
 Recieve Data Failed!\n"
```
```cpp
);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
char
```
```cpp
file_name[FILE_NAME_MAX_SIZE+1];
```
```cpp
```
```cpp
bzero(file_name,
 FILE_NAME_MAX_SIZE+1);
```
```cpp
```
```cpp
strncpy
```
```cpp
(file_name,
 buffer,
```
```cpp
strlen
```
```cpp
(buffer)>FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:
```
```cpp
strlen
```
```cpp
(buffer));
```
```cpp
//       
 int fp = open(file_name, O_RDONLY);
```
```cpp
//       
 if( fp < 0 )
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"%s\n"
```
```cpp
,file_name);
```
```cpp
```
```cpp
FILE
```
```cpp
*
 fp =
```
```cpp
fopen
```
```cpp
(file_name,
```
```cpp
"r"
```
```cpp
);
```
```cpp
```
```cpp
if
```
```cpp
(NULL
 == fp )
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"File:\t%s
 Not Found\n"
```
```cpp
,
 file_name);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
else
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
bzero(buffer,
 BUFFER_SIZE);
```
```cpp
```
```cpp
int
```
```cpp
file_block_length
 = 0;
```
```cpp
//           
 while( (file_block_length = read(fp,buffer,BUFFER_SIZE))>0)
```
```cpp
```
```cpp
while
```
```cpp
(
 (file_block_length =
```
```cpp
fread
```
```cpp
(buffer,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
char
```
```cpp
),BUFFER_SIZE,fp))>0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"file_block_length
 = %d\n"
```
```cpp
,file_block_length);
```
```cpp
```
```cpp
//发送buffer中的字符串到new_server_socket,实际是给客户端
```
```cpp
```
```cpp
if
```
```cpp
(send(new_server_socket,buffer,file_block_length,0)<0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Send
 File:\t%s Failed\n"
```
```cpp
,
 file_name);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
bzero(buffer,
 BUFFER_SIZE);
```
```cpp
```
```cpp
}
```
```cpp
//           
 close(fp);
```
```cpp
```
```cpp
fclose
```
```cpp
(fp);
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"File:\t%s
 Transfer Finished\n"
```
```cpp
,file_name);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//关闭与客户端的连接
```
```cpp
```
```cpp
close(new_server_socket);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//关闭监听用的socket
```
```cpp
```
```cpp
close(server_socket);
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
### 2. [代码]c代码 client部分     [](http://www.oschina.net/code/snippet_97047_675#938)[](http://www.oschina.net/code/snippet_97047_675#939)[](http://www.oschina.net/code/snippet_97047_675#940)[](http://www.oschina.net/code/piece_full?code=675&piece=939#939)
[?](http://www.oschina.net/code/snippet_97047_675#)
```
```cpp
client.c
```
```cpp
#include
 <netinet/in.h>    // for sockaddr_in
```
```cpp
#include
 <sys/types.h>    // for socket
```
```cpp
#include
 <sys/socket.h>    // for socket
```
```cpp
#include
 <stdio.h>        // for printf
```
```cpp
#include
 <stdlib.h>        // for exit
```
```cpp
#include
 <string.h>        // for bzero
```
```cpp
/*
```
```cpp
#include
 <sys/types.h>
```
```cpp
#include
 <sys/stat.h>
```
```cpp
#include
 <fcntl.h>
```
```cpp
#include
 <unistd.h>
```
```cpp
*/
```
```cpp
#define
 HELLO_WORLD_SERVER_PORT    6666
```
```cpp
#define
 BUFFER_SIZE 1024
```
```cpp
#define
 FILE_NAME_MAX_SIZE 512
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
**argv)
```
```cpp
{
```
```cpp
```
```cpp
if
```
```cpp
(argc
 != 2)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Usage:
 ./%s ServerIPAddress\n"
```
```cpp
,argv[0]);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//设置一个socket地址结构client_addr,代表客户机internet地址,
 端口
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in
 client_addr;
```
```cpp
```
```cpp
bzero(&client_addr,
```
```cpp
sizeof
```
```cpp
(client_addr));
```
```cpp
//把一段内存区的内容全部设置为0
```
```cpp
```
```cpp
client_addr.sin_family
 = AF_INET;
```
```cpp
//internet协议族
```
```cpp
```
```cpp
client_addr.sin_addr.s_addr
 = htons(INADDR_ANY);
```
```cpp
//INADDR_ANY表示自动获取本机地址
```
```cpp
```
```cpp
client_addr.sin_port
 = htons(0);
```
```cpp
//0表示让系统自动分配一个空闲端口
```
```cpp
```
```cpp
//创建用于internet的流协议(TCP)socket,用client_socket代表客户机socket
```
```cpp
```
```cpp
int
```
```cpp
client_socket
 = socket(AF_INET,SOCK_STREAM,0);
```
```cpp
```
```cpp
if
```
```cpp
(
 client_socket < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Create
 Socket Failed!\n"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//把客户机的socket和客户机的socket地址结构联系起来
```
```cpp
```
```cpp
if
```
```cpp
(
 bind(client_socket,(
```
```cpp
struct
```
```cpp
sockaddr*)&client_addr,
```
```cpp
sizeof
```
```cpp
(client_addr)))
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Client
 Bind Port Failed!\n"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
//设置一个socket地址结构server_addr,代表服务器的internet地址,
 端口
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in
 server_addr;
```
```cpp
```
```cpp
bzero(&server_addr,
```
```cpp
sizeof
```
```cpp
(server_addr));
```
```cpp
```
```cpp
server_addr.sin_family
 = AF_INET;
```
```cpp
```
```cpp
if
```
```cpp
(inet_aton(argv[1],&server_addr.sin_addr)
 == 0)
```
```cpp
//服务器的IP地址来自程序的参数
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Server
 IP Address Error!\n"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
server_addr.sin_port
 = htons(HELLO_WORLD_SERVER_PORT);
```
```cpp
```
```cpp
socklen_t
 server_addr_length =
```
```cpp
sizeof
```
```cpp
(server_addr);
```
```cpp
```
```cpp
//向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接
```
```cpp
```
```cpp
if
```
```cpp
(connect(client_socket,(
```
```cpp
struct
```
```cpp
sockaddr*)&server_addr,
 server_addr_length) < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Can
 Not Connect To %s!\n"
```
```cpp
,argv[1]);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
char
```
```cpp
file_name[FILE_NAME_MAX_SIZE+1];
```
```cpp
```
```cpp
bzero(file_name,
 FILE_NAME_MAX_SIZE+1);
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Please
 Input File Name On Server:\t"
```
```cpp
);
```
```cpp
```
```cpp
scanf
```
```cpp
(
```
```cpp
"%s"
```
```cpp
,
 file_name);
```
```cpp
```
```cpp
```
```cpp
char
```
```cpp
buffer[BUFFER_SIZE];
```
```cpp
```
```cpp
bzero(buffer,BUFFER_SIZE);
```
```cpp
```
```cpp
strncpy
```
```cpp
(buffer,
 file_name,
```
```cpp
strlen
```
```cpp
(file_name)>BUFFER_SIZE?BUFFER_SIZE:
```
```cpp
strlen
```
```cpp
(file_name));
```
```cpp
```
```cpp
//向服务器发送buffer中的数据
```
```cpp
```
```cpp
send(client_socket,buffer,BUFFER_SIZE,0);
```
```cpp
//   
 int fp = open(file_name, O_WRONLY|O_CREAT);
```
```cpp
//   
 if( fp < 0 )
```
```cpp
```
```cpp
FILE
```
```cpp
*
 fp =
```
```cpp
fopen
```
```cpp
(file_name,
```
```cpp
"w"
```
```cpp
);
```
```cpp
```
```cpp
if
```
```cpp
(NULL
 == fp )
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"File:\t%s
 Can Not Open To Write\n"
```
```cpp
,
 file_name);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
//从服务器接收数据到buffer中
```
```cpp
```
```cpp
bzero(buffer,BUFFER_SIZE);
```
```cpp
```
```cpp
int
```
```cpp
length
 = 0;
```
```cpp
```
```cpp
while
```
```cpp
(
 length = recv(client_socket,buffer,BUFFER_SIZE,0))
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
if
```
```cpp
(length
 < 0)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Recieve
 Data From Server %s Failed!\n"
```
```cpp
,
 argv[1]);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
//       
 int write_length = write(fp, buffer,length);
```
```cpp
```
```cpp
int
```
```cpp
write_length
 =
```
```cpp
fwrite
```
```cpp
(buffer,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
char
```
```cpp
),length,fp);
```
```cpp
```
```cpp
if
```
```cpp
(write_length<length)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"File:\t%s
 Write Failed\n"
```
```cpp
,
 file_name);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
bzero(buffer,BUFFER_SIZE);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Recieve
 File:\t %s From Server[%s] Finished\n"
```
```cpp
,file_name,
 argv[1]);
```
```cpp
```
```cpp
```
```cpp
close(fp);
```
```cpp
```
```cpp
//关闭socket
```
```cpp
```
```cpp
close(client_socket);
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
### 3. [代码]open等，fopen等说明     跳至[[1]](http://www.oschina.net/code/snippet_97047_675#938)[[2]](http://www.oschina.net/code/snippet_97047_675#939)[[3]](http://www.oschina.net/code/snippet_97047_675#940)[[全屏预览]](http://www.oschina.net/code/piece_full?code=675&piece=940#940)
[?](http://www.oschina.net/code/snippet_97047_675#)
```
```cpp
某些注释部分，open,read,write被
```
```cpp
fopen
```
```cpp
,
```
```cpp
fread
```
```cpp
,
```
```cpp
fwrite
```
```cpp
替换。
```
```cpp
说明一下：
```
```cpp
fopen
```
```cpp
,
```
```cpp
fclose
```
```cpp
,
```
```cpp
fread
```
```cpp
,
```
```cpp
fwrite
```
```cpp
,
```
```cpp
fgetc
```
```cpp
,
```
```cpp
fgets
```
```cpp
,
```
```cpp
fputc
```
```cpp
,
```
```cpp
fputs
```
```cpp
,
```
```cpp
freopen
```
```cpp
,
```
```cpp
fseek
```
```cpp
,
```
```cpp
ftell
```
```cpp
,
```
```cpp
rewind
```
```cpp
等
```
```cpp
缓冲文件系统
```
```cpp
缓冲文件系统的特点是：在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，
```
```cpp
从磁盘文件将数据先读入内存“缓冲区”，
 装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的
```
```cpp
操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存
```
```cpp
“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，
```
```cpp
执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器
 而定。
```
```cpp
open,
 close, read, write,
```
```cpp
getc
```
```cpp
,
```
```cpp
getchar
```
```cpp
,
```
```cpp
putc
```
```cpp
,
```
```cpp
putchar
```
```cpp
等
```
```cpp
非缓冲文件系统
```
```cpp
非缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、
```
```cpp
字符串、格式化数据，也可以读写二进制数
 据。非缓冲文件系统依赖于操作系统，通过操作系统的功能对
```
```cpp
文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度快，
```
```cpp
由于ANSI标准不再包括非缓冲文件系统，因此建议大家最好不要选择它。
```
```cpp
open等属于低级IO，
```
```cpp
fopen
```
```cpp
等是高级IO。
```
```cpp
open等返回一个文件描述符(用户程序区的)，
```
```cpp
fopen
```
```cpp
等返回一个文件指针。
```
```cpp
open等无缓冲，
```
```cpp
fopen
```
```cpp
等有缓冲。
```
```cpp
fopen
```
```cpp
等是在open等的基础上扩充而来的，在大多数情况下，用
```
```cpp
fopen
```
```cpp
等。
```
```cpp
open
 是系统调用 返回的是文件句柄，文件的句柄是文件在文件描述符表里的索引，
```
```cpp
fopen
```
```cpp
是C的库函数，返回的是一个指向文件结构的指针。
```
```
//==========================================================================================================================
//备注::
1>今天测试了一下这段代码，基本可行！！！
