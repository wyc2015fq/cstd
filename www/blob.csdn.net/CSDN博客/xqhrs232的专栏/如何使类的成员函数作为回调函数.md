# 如何使类的成员函数作为回调函数 - xqhrs232的专栏 - CSDN博客
2013年11月14日 20:49:15[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：702
原文地址::[http://www.cnblogs.com/this-543273659/archive/2011/08/17/2143576.html](http://www.cnblogs.com/this-543273659/archive/2011/08/17/2143576.html)
相关网帖
1、如何实现类的成员函数作为回调函数----[http://xingyunbaijunwei.blog.163.com/blog/static/7653806720122212324917/](http://xingyunbaijunwei.blog.163.com/blog/static/7653806720122212324917/)
2、[c++类成员函数作为回调函数](http://blog.csdn.net/bookish_2010_prj/article/details/5602770)----[http://blog.csdn.net/bookish_2010_prj/article/details/5602770](http://blog.csdn.net/bookish_2010_prj/article/details/5602770)
3、将类成员函数用做C回调函数----[http://www.51testing.com/html/38/n-806638.html](http://www.51testing.com/html/38/n-806638.html)
4、[MFC类成员函数作为线程函数的解决办法](http://blog.csdn.net/onezeros/article/details/4948552)----[http://blog.csdn.net/onezeros/article/details/4948552](http://blog.csdn.net/onezeros/article/details/4948552)
如果试图直接使用C++的成员函数作为回调函数将发生错误，甚至编译就不能通过。其错误是普通的C++成员函数都隐含了一个传递函数作为参数，亦即“this”指针，C++通过传递this指针给其成员函数从而实现程序函数可以访问C++的数据成员。这也可以理解为什么C++类的多个实例可以共享成员函数却-有不同的数据成员。由于this指针的作用，使得将一个CALL-BACK型的成员函数作为回调函数安装时就会因为隐含的this指针使得函数参数个数不匹配，从而导致回调函数安装失败。要解决这一问题的关键就是不让this指针起作用，通过采用以下两种典型技术可以解决在C++中使用回调函数所遇到的问题。这种方法具有通用性，适合于任何C++。
 　
1). 不使用成员函数，为了访问类的成员变量，可以使用友元操作符(friend)，在C++中将该函数说明为类的友元即可。 　　
2). 使用静态成员函数，静态成员函数不使用this指针作为隐含参数，这样就可以作为回调函数了。静态成员函数具有两大特点：其一，可以在没有类实例的情况下使用；其二，只能访问静态成员变量和静态成员函数，不能访问非静态成员变量和非静态成员函数。由于在C++中使用类成员函数作为回调函数的目的就是为了访问所有的成员变量和成员函数，如果做不到这一点将不具有实际意义。解决的办法也很简单，就是使用一个静态类指针作为类成员，通过在类创建时初始化该静态指针，如pThis=this，然后在回调函数中通过该静态指针就可以访问所有成员变量和成员函数了。
 这种处理办法适用于只有一个类实例的情况，因为多个类实例将共享静态类成员和静态成员函数，这就导致静态指针指向最后创建的类实例。为了避免这种情况，可以使用回调函数的一个参数来传递this指针，从而实现数据成员共享。这种方法稍稍麻烦，这里就不再赘述。（关于静态方法访问非静态变量和函数的方式请见[http://www.cnblogs.com/this-543273659/archive/2011/08/29/2157966.html](http://www.cnblogs.com/this-543273659/archive/2011/08/29/2157966.html)）
首先明白什么是回调函数：比如说被调函数void callbackf（int n）{}要想作为回调函数的话，callbackf必须作为主调函数的形参出现，如void f（void （*p（int）），int n）形式才行！
 例子：
**例1：**
#include<iostream>
using namespace std;
class A
{
public:
 friend void callback()  //友元函数作为回调函数 friend方式实现
 {
  cout<<"回调函数开始执行了！"<<endl;
 }
};
void f(void (*p)())
 {
  p();
 }
int main()
{
 void (*p)();
 p=callback;
 f(p);
 return 0;
}
**例2：**
#include<iostream>
using namespace std;
class A
{
public:
 static void callback()  //类的成员函数作为回调函数 static方式实现
 {
  cout<<"回调函数开始执行了！"<<endl;
 }
};
void f(void (*p)())
 {
  p();
 }
int main()
{
 void (*p)();
 p=A::callback;
 f(p);
 return 0;
}
还可以把f（）函数设为类的成员函数：
#include<iostream>
using namespace std;
class A
{
public:
 static void callback()  //类的成员函数作为回调函数 static方式实现
 {
  cout<<"回调函数开始执行了！"<<endl;
 }
 void f(void (*p)())
 {
  p();
 }
};
int main()
{
 A a;
 void (*p)();
 p=A::callback;
 a.f(p);
 return 0;
}
