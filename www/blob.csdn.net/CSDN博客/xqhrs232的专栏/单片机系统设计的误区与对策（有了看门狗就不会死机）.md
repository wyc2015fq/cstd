# 单片机系统设计的误区与对策（有了看门狗就不会死机） - xqhrs232的专栏 - CSDN博客
2017年06月28日 23:42:57[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1657
原文地址::[http://blog.sina.com.cn/s/blog_72359bde0101c4gm.html](http://blog.sina.com.cn/s/blog_72359bde0101c4gm.html)
死机是指CPU的程序指针进入一个死循环。无法执行正常的程序流程。其外在表现常常是：正常功能丧失，按键无响应。显示凝固。单片机死机后，只有复位才能走出死循环，执行正常的程序流程。众所周知，克服死机的最有效手段是加看门狗(WatchDog)。
目前用得最广泛的看门狗实际上是一个特殊的定时器DogTimer。DogTimer接固定速率计时，计满预定时间就发出溢出脉冲使单片机复位。如果每次在DogTimer溢出前强行让DogTimer清零，就不会发出溢出脉冲。清零脉冲由CPU发出，在单片机程序中每隔一段语句放一个清DogTimer的语句——FeedDog语句，以保证程序正常运行时DogTimer不会溢出。一旦程序进入一个不含FeedDog语句的死循环，DogTimer将溢出，导致单片机复位，跳出这个死循环。本文称这种看门狗为典型看门狗，典型看门狗已被集成化．如MAX706，MAX791等；还有许多单片机本身集成了这种看门狗，如PIC16C57、MC68HC705等，具体电路可参阅这些芯片的技术资料。
有一个错误观点：加了看门狗．单片机就不会死机。实际上，看门狗有时会完全失效。当程序进入某个死循环，而这个死循环中又包含FeedDog语句，这时DogTimer始终不会溢出，单片机始终得不到复位信号，程序也就始终跳不出这个死循环。针对这一弊端，笔者设计了双时限看门狗和定时复位看门狗。
双时限看门狗有两个定时器：一个为短定时器，一个为长定时器。短定时器定时为T1，长定时器定时为T2，0；长、短定时器的FeedDog是各自独立的。短定时器象典型看门狗那样工作，它保证一般情况下看门狗有快的反应速度；长定时器的定时T2大于CPU执行一个主循环程序的时问，并且每一个主循环才FeedDog一次，用来防止看门狗失效。
这样，当程序进入某个死循环，如果这个死循环包含短定时器FeedDog语句而不包含长定时器FeedDog语句．那么长定时器终将溢出，使单片机复位。巧妙安排长定时器FeedDog语句的位置，可保证出现死机的概率极低。在水轮发电机组微机控制装置中的对比应用证明了这一点。
目前几乎所有的看门狗都是依赖于CPU(依赖于CPU
 FeedDog)。这可以比作：一个保险设备能否起到保险作用还依赖于被它保护的对象的行为。显然，依赖于CPU看门狗是不能保证单片机百分之百不死机的。
在绝对不允许死机的装置中，笔者设汁了一种完全不依赖于CPL]的看门狗——定时复位看门狗。定时复位看门狗的主体也是一个定时器，到预定时间就发出溢出脉冲，此溢出脉冲使单片机强行复位。定时复位看门狗不需要CPU
 FeedDog。
简言之，定时复位看门狗就是定时地让单片机强行复位。这样，即使装置死机，其最大死机时间也不会大于定时器的定时时间。显然，只要硬件完好，这种看门狗百分之百地保证了单片机不会长时间死机。在智能电表(包括IC卡电能表、复费率电能表、多功能电能表)中采用定时复位看门狗，每1秒让CPU强行复位，迄令数十万电表运行了近五年，无一例死机报告。
必须指出，采用这种看门狗，CPU的编程要适应定时复位的环境．保证定时复位不打断那些不能打断的程序．不造成任何误动作。
