# 不成熟的个人资产管理系统（上） - xqhrs232的专栏 - CSDN博客
2018年11月01日 15:42:32[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：144
原文地址::[https://blog.csdn.net/qq953454299/article/details/77503810](https://blog.csdn.net/qq953454299/article/details/77503810)
准备材料：
jar包:c3p0,log4j,mysql-connect-java
配置文件：db.properties;log4j.properties
1
2
项目分包：
所谓三层是指，视图层，服务逻辑层和数据持久层。
这三层将应用程序分化，利用分而治之的思想。
视图层负责与用户交互。
服务层接管用户以及来自其他进程的请求。
并在有需要的时候调用数据持久层完成一整套流程的操作。
根据三层架构模式进行分包：
1
2
3
4
5
6
1. 视图层
com.hpe.view        用户界面
    MainUI  
    UserUI
    AdminUI
1
2
3
4
2. 服务逻辑层
com.hpe.service     业务处理（定义接口）
    IAdminService         --管理员
    IAssetService           --资产
    IBankService            --银行
    IUserService            --用户 
    com.hpe.service.impl      业务处理的实现 
        IAdminServiceImpl
    IAssetServiceImpl
    IBankServiceImpl
    IUserServiceImpl
1
2
3
4
5
6
7
8
9
10
3. 数据持久层
com.hpe.dao     数据库访问（定义接口）
    IAdminDao
    IAssetDao
    IBankDao
    IUserDao
com.hpe.po      实体类
    Admin
    Asset
    Bank
    User
com.hpe.vo      视图类（联表查询实体类）
    BankAndAsset
1
2
3
4
5
6
7
8
9
10
11
12
另：工具类
com.util        常用工具类封装
    DBUtil
    DBDataSource
1
2
3
重点难点
1.DBUtil的使用
private static ThreadLocal<Connection> tl = new ThreadLocal<Connection>();
1
创建一个线程变量对象
    public int execute(String sql) throws Exception {
        return execute(sql,new Object[]{});
    }
1
2
3
关于增删改的方法，参数为String时，返回一个参数为String ,Object[]的重写的方法
    /**
     * 该语句必须是 SQL INSERT、UPDATE 、DELETE 语句
     *      insert into table values(?,?,?,?)
     * @param sql
     * @param paramList：参数，与SQL语句中的占位符一
     * @return
     * @throws Exception
     */
    public int execute(String sql,Object[] paramList) throws Exception {
        if (sql == null || sql.trim().equals("")) {
            //当sql为空时在日志中写入“参数有效”
            //trim()函数移除字符串两侧的空白
            logger.info("parameter is valid!");
        }
        Connection conn = null;
        PreparedStatement pstmt = null;
        int result = 0;
        try {
            conn = getConnection();
            //如果连接为空或sql语句为空，返回null
            //如果不为空，将sql放入PrepareStatement对象中
            pstmt = DBUtil.getPreparedStatement(conn, sql);
            //将ParamList中存储的占位符的值放入pstmt中
            setPreparedStatementParam(pstmt, paramList);
            if (pstmt == null) {
                return -1;
            }
            result = pstmt.executeUpdate();
        } catch (Exception e) {
            logger.info(e.getMessage());
            throw new Exception(e);
        } finally {
            closeStatement(pstmt);
            closeConn(conn);
        }
        return result;
    }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
参数为String，Object的重写的execute()方法，能够实现PreparedStatement对象的实例化，并且将sql语句和占位符的值相对应 
getPrepareStatement(conn,sql)用于创建PreparedStatement对象 
setPrepareStatement(param,paramList)用于将占位符的值和sql语句中的占位符相对应
        if (sql == null || sql.trim().equals("")) {
            logger.info("parameter is valid!");
        }
        PreparedStatement pstmt = null;
        int result = 0;
        try {
            pstmt = DBUtil.getPreparedStatement(conn, sql);
            setPreparedStatementParam(pstmt, paramList);
            if (pstmt == null) {
                return -1;
            }
            result = pstmt.executeUpdate();
        } catch (Exception e) {
            logger.info(e.getMessage());
            throw new Exception(e);
        } finally {
            closeStatement(pstmt);
        }
        return result;
    }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
参数为Connection,String,Object[]的重写的execute()方法，目的是使用同一个连接
“` 
/** 
* insert语句使用，返回新增数据的主键。 
* @param sql 
* @return 
*/ 
public Object execute(Connection conn ,String sql,Object[] paramList,boolean falg) throws Exception{ 
if (sql == null || sql.trim().equals(“”)) { 
logger.info(“parameter is valid!”); 
}
    PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
1
//RETURN_GENERATED_KEYS获取自动生成的键值 
Object id = null; 
try { 
// 指定返回生成的主键 
// 如果使用静态的SQL，则不需要动态插入参数 
setPreparedStatementParam(pstmt, paramList); 
if (pstmt == null) { 
return -1; 
} 
pstmt.executeUpdate(); 
// 检索由于执行此 Statement 对象而创建的所有自动生成的键 
ResultSet rs = pstmt.getGeneratedKeys(); 
if (rs.next()) { 
id = rs.getObject(1); 
System.out.println(“数据主键地址：” + id); 
} 
} catch (Exception e) { 
logger.info(e.getMessage()); 
throw new Exception(e); 
} finally 
closeStatement(pstmt); 
} 
return id; 
是使参数列表不同，没有什么实际意新增义 
这 
个函数用于返回Insert之后自动生成的新增数据的主键；
--------------------- 
作者：晨饰玉梦 
来源：CSDN 
原文：https://blog.csdn.net/qq953454299/article/details/77503810 
版权声明：本文为博主原创文章，转载请附上博文链接！
