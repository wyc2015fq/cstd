# STM32开发指南--第三十二章 红外遥控实验 - xqhrs232的专栏 - CSDN博客
2013年04月11日 14:55:42[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1828
原文地址::[http://bbs.ednchina.com/BLOG_ARTICLE_3011510.HTM](http://bbs.ednchina.com/BLOG_ARTICLE_3011510.HTM)
相关网帖
1、【STM32 .Net MF开发板学习-14】红外遥控器编码识别----[http://blog.chinaaet.com/detail/18141.html](http://blog.chinaaet.com/detail/18141.html)
2、STM32实验21红外遥控实验----[http://wenku.baidu.com/view/2d0b4636a32d7375a417802e](http://wenku.baidu.com/view/2d0b4636a32d7375a417802e)
第三十二章红外遥控实验
        本章，我们将向大家介绍如何通过STM32来解码红外遥控器的信号。ALIENTK战舰STM32开发板标配了红外接收头和一个很小巧的红外遥控器。在本章中，我们将利用STM32的输入捕获功能，解码开发板标配的这个红外遥控器的编码信号，并将解码后的键值TFTLCD模块上显示出来。本章分为如下几个部分：
32.1 红外遥控简介
32.2 硬件设计
32.3 软件设计
32.4 下载验证
32.1红外遥控简介
        红外遥控是一种无线、非接触控制技术，具有抗干扰能力强，信息传输可靠，功耗低，成本低，易实现等显著优点，被诸多电子设备特别是家用电器广泛采用，并越来越多的应用到计算机系统中。
由于红外线遥控不具有像无线电遥控那样穿过障碍物去控制被控对象的能力，所以，在设计红外线遥控器时，不必要像无线电遥控器那样，每套(发射器和接收器)要有不同的遥控频率或编码(否则，就会隔墙控制或干扰邻居的家用电器)，所以同类产品的红外线遥控器，可以有相同的遥控频率或编码，而不会出现遥控信号“串门”的情况。这对于大批量生产以及在家用电器上普及红外线遥控提供了极大的方面。由于红外线为不可见光，因此对环境影响很小，再由红外光波动波长远小于无线电波的波长，所以红外线遥控不会影响其他家用电器，也不会影响临近的无线电设备。
红外遥控的编码目前广泛使用的是：NEC Protocol 的PWM(脉冲宽度调制)和Philips
RC-5 Protocol 的PPM(脉冲位置调制)。ALIENTEK战舰STM32开发板配套的遥控器使用的是NEC协议，其特征如下：
1、8位地址和8位指令长度；
2、地址和命令2次传输（确保可靠性）
3、PWM脉冲位置调制，以发射红外载波的占空比代表“0”和“1”；
4、载波频率为38Khz；
5、位时间为1.125ms或2.25ms；
NEC码的位定义：一个脉冲对应560us的连续载波，一个逻辑1传输需要2.25ms（560us脉冲+1680us低电平），一个逻辑0的传输需要1.125ms（560us脉冲+560us低电平）。而遥控接收头在收到脉冲的时候为低电平，在没有脉冲的时候为高电平，这样，我们在接收头端收到的信号为：逻辑1应该是560us低+1680us高，逻辑0应该是560us低+560us高。
NEC遥控指令的数据格式为：同步码头、地址码、地址反码、控制码、控制反码。同步码由一个9ms的低电平和一个4.5ms的高电平组成，地址码、地址反码、控制码、控制反码均是8位数据格式。按照低位在前，高位在后的顺序发送。采用反码是为了增加传输的可靠性（可用于校验）。
我们遥控器的按键2按下时，从红外接收头端收到的波形如图32.1.1所示：
![](http://www.openedv.com/upload/2013/3/20/01ded9aa7322a48f4572706883e3bb15_363.jpg)
图32.1.1 按键2所对应的红外波形
从图32.1.1中可以看到，其地址码为0，控制码为168。可以看到在100ms之后，我们还收到了几个脉冲，这是NEC码规定的连发码(由9ms低电平+2.5m高电平+0.56ms低电平+97.94ms高电平组成)，如果在一帧数据发送完毕之后，按键仍然没有放开，则发射重复码，即连发码，可以通过统计连发码的次数来标记按键按下的长短/次数。
第十五章我们曾经介绍过利用输入捕获来测量高电平的脉宽，本章解码红外遥控信号，刚好可以利用输入捕获的这个功能来实现遥控解码。关于输入捕获的介绍，请参考第十五章的内容。
32.2 硬件设计
本实验采用定时器的输入捕获功能实现红外解码，本章实验功能简介：开机在LCD上显示一些信息之后，即进入等待红外触发，如过接收到正确的红外信号，则解码，并在LCD上显示键值和所代表的意义，以及按键次数等信息。同样我们也是用LED0来指示程序正在运行。
所要用到的硬件资源如下：
1）  指示灯DS0
2） TFTLCD模块（带触摸屏）
3）  红外接收头
4）  红外遥控器
前两个，在之前的实例已经介绍过了，遥控器属于外部器件，遥控接收头在板子上，与MCU的连接原理图如32.2.1所示：
![](http://www.openedv.com/upload/2013/3/20/3bc8a7e80c574bb95e807d3f907aeb6c_280.png)
                  图32.2.1 红外遥控接收头与STM32的连接电路图
红外遥控接收头连接在STM32的PB9（TIM4_CH4）上。硬件上不需要变动，只要程序将TIM4_CH4设计为输入捕获，然后将收到的脉冲信号解码就可以了。    开发板配套的红外遥控器外观如图32.2.2所示：
![](http://www.openedv.com/upload/2013/3/20/feb4ab9d2a2cdf6ba87c16ba4794f12f_715.jpg)
图32.2.2 红外遥控器
32.3 软件设计
打开上一章的工程，首先在HARDWARE文件夹下新建一个REMOTE的文件夹。然后新建一个remote.c和remote.h的文件保存在REMOTE文件夹下，并将这个文件夹加入头文件包含路径。
打开remote.c文件，输入如下代码：
#include "remote.h"
#include "delay.h"
#include "usart.h"
//红外遥控初始化
//设置IO以及定时器4的输入捕获
void Remote_Init(void)                     
{                                                               
       RCC->APB1ENR|=1<<2;          //TIM4 时钟使能
       RCC->APB2ENR|=1<<3;         //使能PORTB时钟
       GPIOB->CRH&=0XFFFFFF0F;   //PB9 输入
       GPIOB->CRH|=0X00000080;      //上拉输入
       GPIOB->ODR|=1<<9;          //PB9 上拉
       TIM4->ARR=10000;           //设定计数器自动重装值最大10ms溢出
       TIM4->PSC=71;                 //预分频器,1M的计数频率,1us加1. 
  
       TIM4->CCMR2|=1<<8;        //CC4S=01     选择输入端 IC4映射到TI4上
      TIM4->CCMR2|=3<<12;     //IC4F=0011 配置输入滤波器 8个定时器时钟周期滤波
      TIM4->CCMR2|=0<<10;     //IC4PS=00    配置输入分频,不分频
       TIM4->CCER|=0<<13;        //CC4P=0       上升沿捕获
       TIM4->CCER|=1<<12;        //CC4E=1      允许捕获计数器的值到捕获寄存器中
       TIM4->DIER|=1<<4;         //允许CC4IE捕获中断
       TIM4->DIER|=1<<0;         //允许更新中断
       TIM4->CR1|=0x01;           //使能定时器4
      MY_NVIC_Init(1,3,TIM4_IRQChannel,2);//抢占1，子优先级3，组2 
                       
}
//遥控器接收状态
//[7]:收到了引导码标志
//[6]:得到了一个按键的所有信息
//[5]:保留
//[4]:标记上升沿是否已经被捕获
//[3:0]:溢出计时器
u8   RmtSta=0;              
u16 Dval;                     //下降沿时计数器的值
u32 RmtRec=0;      //红外接收到的数据
u8  RmtCnt=0;     //按键按下的次数
//定时器2中断服务程序
void TIM4_IRQHandler(void)
{
//省略代码                        
}
//处理红外键盘
//返回值:
//     0,没有任何按键按下
//其他,按下的按键键值.
u8 Remote_Scan(void)
{        
       u8 sta=0;      
    u8 t1,t2;  
       if(RmtSta&(1<<6))//得到一个按键的所有信息了
       {
           t1=RmtRec>>24;                  //得到地址码
           t2=(RmtRec>>16)&0xff;      //得到地址反码
          if((t1==(u8)~t2)&&t1==REMOTE_ID)//检验遥控识别码(ID)及地址
           {
               t1=RmtRec>>8;
               t2=RmtRec;   
               if(t1==(u8)~t2)sta=t1;//键值正确
              }   
              if((sta==0)||((RmtSta&0X80)==0))//按键数据错误/遥控已经没有按下了
              {
                    RmtSta&=~(1<<6);//清除接收到有效按键标识
                     RmtCnt=0;            //清除按键次数计数器
              }
       }  
    return sta;
}
该部分代码包含3个函数，首先是Remote_Init函数，该函数用于初始化IO口，并配置TIM4_CH4为输入捕获，并设置其相关参数。TIM4_IRQHandler函数是TIM4的中断服务函数，在该函数里面，实现对红外信号的高电平脉冲的捕获，同时根据我们之前简介的协议内容来解码 ，该函数用到几个全局变量，用于辅助解码，并存储解码结果。最后是Remote_Scan函数，该函用来扫描解码结果，相当于我们的按键扫描，输入捕获解码的红外数据，通过该函数传送给其他程序。
保存remote.c，然后把该文件加入HARDWARE组下。接下来打开remote.h在该文件里面加入如下代码：
//省略代码 
这里的REMOTE_ID就是我们开发板配套的遥控器的识别码，对于其他遥控器可能不一样,只要修改这个为你所使用的遥控器的一致就可以了。其他是一些函数的声明，我们保存此部分代码，然后在test.c里面修改主函数如下：
int main(void)
{            
        //省略部分代码
}
至此，我们的软件设计部分就结束了。
32.4 下载验证
在代码编译成功之后，我们通过下载代码到ALIENTEK战舰STM32开发板上，可以看到LCD显示如图32.4.1所示的内容：
![](http://www.openedv.com/upload/2013/3/20/e117190caf612f8c3b53081eee3d2dd2_344.jpg)
图32.4.1 程序运行效果图
此时我们通过遥控器按下不同的按键，则可以看到LCD上显示了不同按键的键值以及按键次数和对应的遥控器上的符号。如图32.4.2所示：
![](http://www.openedv.com/upload/2013/3/20/ea946bf1692eff9c00cefe64e8538f2a_490.jpg)
图32.4.2 解码成功
[实验27 红外遥控实验.rar](http://bbs.ednchina.com/BLOG_ARTICLE_3011510.HTM#)下载次数： 6
标签：   [stm32](http://bbs.ednchina.com/TAGS/BLOG/stm32.HTM)[开发板](http://bbs.ednchina.com/TAGS/BLOG/%BF%AA%B7%A2%B0%E5.HTM)[战舰](http://bbs.ednchina.com/TAGS/BLOG/%D5%BD%BD%A2.HTM)[stm32开发指南](http://bbs.ednchina.com/TAGS/BLOG/stm32%BF%AA%B7%A2%D6%B8%C4%CF.HTM)[红外遥控器](http://bbs.ednchina.com/TAGS/BLOG/%BA%EC%CD%E2%D2%A3%BF%D8%C6%F7.HTM)
