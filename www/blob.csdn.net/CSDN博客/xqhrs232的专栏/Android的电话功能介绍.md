# Android的电话功能介绍 - xqhrs232的专栏 - CSDN博客
2011年03月15日 17:44:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：641
原文地址::[http://blogold.chinaunix.net/u/23275/showart.php?id=2450772](http://blogold.chinaunix.net/u/23275/showart.php?id=2450772)
|Android的Radio Interface Layer (RIL)提供了电话服务和的radio硬件之间的抽象层。　　Radio Interface Layer RIL(Radio Interface Layer)负责数据的可靠传输、AT命令的发送以及response的解析。应用处理器通过AT命令集与带GPRS功能的无线通讯模块通信。　　AT command由Hayes公司发明，是一个调制解调器制造商采用的一个调制解调器命令语言，每条命令以字母"AT"开头。　　JAVA Framework　　代码的路径为：```frameworks/base/telephony/java/android/telephonyandroid.telephony以及android.telephony.gsm```　　Core native:　　在hardware/ril目录中，提供了对RIL支持的本地代码，包括4个文件夹：```hardware/ril/include　　　　　　　hardware/ril/libril　　　　　　　hardware/ril/reference-ril　　　　　　　hardware/ril/rildkernel Driver```　　在Linux内核的驱动中，提供了相关的驱动程序的支持，可以建立在UART或者SDIO，USB等高速的串行总线上。　　hardware/ril/include/telephony/目录中的ril.h文件是ril部分的基础头文件。　　其中定义的结构体RIL_RadioFunctions如下所示：```typedef struct {　 int version;　 RIL_RequestFunc onRequest;　 RIL_RadioStateRequest onStateRequest;　 RIL_Supports supports;　 RIL_Cancel onCancel;　 RIL_GetVersion getVersion;} RIL_RadioFunctions;```　　RIL_RadioFunctions中包含了几个函数指针的结构体，这实际上是一个移植层的接口，下层的库实现后，由rild守护进程得到这些函数指针，执行对应的函数。几个函数指针的原型为：```typedef void (*RIL_RequestFunc) (int request, void *data,　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　size_t datalen, RIL_Token t);typedef RIL_RadioState (*RIL_RadioStateRequest)();typedef int (*RIL_Supports)(int requestCode);typedef void (*RIL_Cancel)(RIL_Token t);typedef const char * (*RIL_GetVersion) (void);```　　其中最为重要的函数是onRequest()，它是一个请求执行的函数。　　2.1 rild守护进程　　rild 守护进程的文件包含在hardware/ril/rild目录中，其中包含了rild.c和radiooptions.c两个文件，这个目录中的文件经过编译后生成一个可执行程序，这个程序在系统的安装路径在：　　/system/bin/rild　　rild.c是这个守护进程的入口，它具有一个主函数的入口main，执行的过程是将请求转换成AT命令的字符串，给下层的硬件执行。在运行过程中，使用dlopen 打开路径为/system/lib/中名称为libreference-ril.so的动态库，然后从中取出 RIL_Init符号来运行。　　RIL_Init符号是一个函数指针，执行这个函数后，返回的是一个RIL_RadioFunctions类型的指针。得到这个指针后，调用RIL_register()函数，将这个指针注册到libril库之中，然后进入循环。　　事实上，这个守护进程提供了一个申请处理的框架，而具体的功能都是在libril.so和libreference-ril.so中完成的。　　2.2 libreference-ril.so动态库　　libreference-ril.so动态库的路径是：　　hardware/ril/reference-ril　　其中主要的文件是reference-ril.c和atchannel.c。这个库必须实现的是一个名称为RIL_Init的函数，这个函数执行的结果是返回一个RIL_RadioFunctions结构体的指针，指针指向函数指针。　　这个库在执行的过程中需要创建一个线程来执行实际的功能。在执行的过程中，这个库将打开一个/dev/ttySXXX的终端（终端的名字是从上层传入的），然后利用这个终端控制硬件执行。　　2.3 libril.so动态库　　libril.so库的目录是：　　hardware/ril/libril　　　其中主要的文件为ril.cpp，这个库主要需要实现的以下几个接口为：```RIL_startEventLoop(void);void RIL_setcallbacks (const RIL_RadioFunctions *callbacks);RIL_register (const RIL_RadioFunctions *callbacks);RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);void RIL_onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen);RIL_requestTimedCallback (RIL_TimedCallback callback, void *param, const struct timeval *relativeTime);```　　这些函数也是被rild守护进程调用的，不同的vendor可以通过自己的方式实现这几个接口，这样可以保证RIL可以在不同系统的移植。其中 RIL_register()函数把外部的RIL_RadioFunctions结构体注册到这个库之中，在恰当的时候调用相应的函数。在执行的过程中，这个库处理了一些将请求转换成字符串的功能。|Android的Radio Interface Layer (RIL)提供了电话服务和的radio硬件之间的抽象层。　　Radio Interface Layer RIL(Radio Interface Layer)负责数据的可靠传输、AT命令的发送以及response的解析。应用处理器通过AT命令集与带GPRS功能的无线通讯模块通信。　　AT command由Hayes公司发明，是一个调制解调器制造商采用的一个调制解调器命令语言，每条命令以字母"AT"开头。　　JAVA Framework　　代码的路径为：```frameworks/base/telephony/java/android/telephonyandroid.telephony以及android.telephony.gsm```　　Core native:　　在hardware/ril目录中，提供了对RIL支持的本地代码，包括4个文件夹：```hardware/ril/include　　　　　　　hardware/ril/libril　　　　　　　hardware/ril/reference-ril　　　　　　　hardware/ril/rildkernel Driver```　　在Linux内核的驱动中，提供了相关的驱动程序的支持，可以建立在UART或者SDIO，USB等高速的串行总线上。　　hardware/ril/include/telephony/目录中的ril.h文件是ril部分的基础头文件。　　其中定义的结构体RIL_RadioFunctions如下所示：```typedef struct {　 int version;　 RIL_RequestFunc onRequest;　 RIL_RadioStateRequest onStateRequest;　 RIL_Supports supports;　 RIL_Cancel onCancel;　 RIL_GetVersion getVersion;} RIL_RadioFunctions;```　　RIL_RadioFunctions中包含了几个函数指针的结构体，这实际上是一个移植层的接口，下层的库实现后，由rild守护进程得到这些函数指针，执行对应的函数。几个函数指针的原型为：```typedef void (*RIL_RequestFunc) (int request, void *data,　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　size_t datalen, RIL_Token t);typedef RIL_RadioState (*RIL_RadioStateRequest)();typedef int (*RIL_Supports)(int requestCode);typedef void (*RIL_Cancel)(RIL_Token t);typedef const char * (*RIL_GetVersion) (void);```　　其中最为重要的函数是onRequest()，它是一个请求执行的函数。　　2.1 rild守护进程　　rild 守护进程的文件包含在hardware/ril/rild目录中，其中包含了rild.c和radiooptions.c两个文件，这个目录中的文件经过编译后生成一个可执行程序，这个程序在系统的安装路径在：　　/system/bin/rild　　rild.c是这个守护进程的入口，它具有一个主函数的入口main，执行的过程是将请求转换成AT命令的字符串，给下层的硬件执行。在运行过程中，使用dlopen 打开路径为/system/lib/中名称为libreference-ril.so的动态库，然后从中取出 RIL_Init符号来运行。　　RIL_Init符号是一个函数指针，执行这个函数后，返回的是一个RIL_RadioFunctions类型的指针。得到这个指针后，调用RIL_register()函数，将这个指针注册到libril库之中，然后进入循环。　　事实上，这个守护进程提供了一个申请处理的框架，而具体的功能都是在libril.so和libreference-ril.so中完成的。　　2.2 libreference-ril.so动态库　　libreference-ril.so动态库的路径是：　　hardware/ril/reference-ril　　其中主要的文件是reference-ril.c和atchannel.c。这个库必须实现的是一个名称为RIL_Init的函数，这个函数执行的结果是返回一个RIL_RadioFunctions结构体的指针，指针指向函数指针。　　这个库在执行的过程中需要创建一个线程来执行实际的功能。在执行的过程中，这个库将打开一个/dev/ttySXXX的终端（终端的名字是从上层传入的），然后利用这个终端控制硬件执行。　　2.3 libril.so动态库　　libril.so库的目录是：　　hardware/ril/libril　　　其中主要的文件为ril.cpp，这个库主要需要实现的以下几个接口为：```RIL_startEventLoop(void);void RIL_setcallbacks (const RIL_RadioFunctions *callbacks);RIL_register (const RIL_RadioFunctions *callbacks);RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);void RIL_onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen);RIL_requestTimedCallback (RIL_TimedCallback callback, void *param, const struct timeval *relativeTime);```　　这些函数也是被rild守护进程调用的，不同的vendor可以通过自己的方式实现这几个接口，这样可以保证RIL可以在不同系统的移植。其中 RIL_register()函数把外部的RIL_RadioFunctions结构体注册到这个库之中，在恰当的时候调用相应的函数。在执行的过程中，这个库处理了一些将请求转换成字符串的功能。|
|----|----|
|Android的Radio Interface Layer (RIL)提供了电话服务和的radio硬件之间的抽象层。　　Radio Interface Layer RIL(Radio Interface Layer)负责数据的可靠传输、AT命令的发送以及response的解析。应用处理器通过AT命令集与带GPRS功能的无线通讯模块通信。　　AT command由Hayes公司发明，是一个调制解调器制造商采用的一个调制解调器命令语言，每条命令以字母"AT"开头。　　JAVA Framework　　代码的路径为：```frameworks/base/telephony/java/android/telephonyandroid.telephony以及android.telephony.gsm```　　Core native:　　在hardware/ril目录中，提供了对RIL支持的本地代码，包括4个文件夹：```hardware/ril/include　　　　　　　hardware/ril/libril　　　　　　　hardware/ril/reference-ril　　　　　　　hardware/ril/rildkernel Driver```　　在Linux内核的驱动中，提供了相关的驱动程序的支持，可以建立在UART或者SDIO，USB等高速的串行总线上。　　hardware/ril/include/telephony/目录中的ril.h文件是ril部分的基础头文件。　　其中定义的结构体RIL_RadioFunctions如下所示：```typedef struct {　 int version;　 RIL_RequestFunc onRequest;　 RIL_RadioStateRequest onStateRequest;　 RIL_Supports supports;　 RIL_Cancel onCancel;　 RIL_GetVersion getVersion;} RIL_RadioFunctions;```　　RIL_RadioFunctions中包含了几个函数指针的结构体，这实际上是一个移植层的接口，下层的库实现后，由rild守护进程得到这些函数指针，执行对应的函数。几个函数指针的原型为：```typedef void (*RIL_RequestFunc) (int request, void *data,　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　　 　size_t datalen, RIL_Token t);typedef RIL_RadioState (*RIL_RadioStateRequest)();typedef int (*RIL_Supports)(int requestCode);typedef void (*RIL_Cancel)(RIL_Token t);typedef const char * (*RIL_GetVersion) (void);```　　其中最为重要的函数是onRequest()，它是一个请求执行的函数。　　2.1 rild守护进程　　rild 守护进程的文件包含在hardware/ril/rild目录中，其中包含了rild.c和radiooptions.c两个文件，这个目录中的文件经过编译后生成一个可执行程序，这个程序在系统的安装路径在：　　/system/bin/rild　　rild.c是这个守护进程的入口，它具有一个主函数的入口main，执行的过程是将请求转换成AT命令的字符串，给下层的硬件执行。在运行过程中，使用dlopen 打开路径为/system/lib/中名称为libreference-ril.so的动态库，然后从中取出 RIL_Init符号来运行。　　RIL_Init符号是一个函数指针，执行这个函数后，返回的是一个RIL_RadioFunctions类型的指针。得到这个指针后，调用RIL_register()函数，将这个指针注册到libril库之中，然后进入循环。　　事实上，这个守护进程提供了一个申请处理的框架，而具体的功能都是在libril.so和libreference-ril.so中完成的。　　2.2 libreference-ril.so动态库　　libreference-ril.so动态库的路径是：　　hardware/ril/reference-ril　　其中主要的文件是reference-ril.c和atchannel.c。这个库必须实现的是一个名称为RIL_Init的函数，这个函数执行的结果是返回一个RIL_RadioFunctions结构体的指针，指针指向函数指针。　　这个库在执行的过程中需要创建一个线程来执行实际的功能。在执行的过程中，这个库将打开一个/dev/ttySXXX的终端（终端的名字是从上层传入的），然后利用这个终端控制硬件执行。　　2.3 libril.so动态库　　libril.so库的目录是：　　hardware/ril/libril　　　其中主要的文件为ril.cpp，这个库主要需要实现的以下几个接口为：```RIL_startEventLoop(void);void RIL_setcallbacks (const RIL_RadioFunctions *callbacks);RIL_register (const RIL_RadioFunctions *callbacks);RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);void RIL_onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen);RIL_requestTimedCallback (RIL_TimedCallback callback, void *param, const struct timeval *relativeTime);```　　这些函数也是被rild守护进程调用的，不同的vendor可以通过自己的方式实现这几个接口，这样可以保证RIL可以在不同系统的移植。其中 RIL_register()函数把外部的RIL_RadioFunctions结构体注册到这个库之中，在恰当的时候调用相应的函数。在执行的过程中，这个库处理了一些将请求转换成字符串的功能。| |
|**原文地址**[http://blog.chinaunix.net/u3/93670/showart_2238543.html](http://blog.chinaunix.net/u3/93670/showart_2238543.html)| |
