# 触摸屏驱动分析: (本机驱动) - xqhrs232的专栏 - CSDN博客
2010年02月26日 16:04:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1040标签：[user																[wince																[null																[interface																[callback																[活动](https://so.csdn.net/so/search/s.do?q=活动&t=blog)](https://so.csdn.net/so/search/s.do?q=callback&t=blog)](https://so.csdn.net/so/search/s.do?q=interface&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=wince&t=blog)](https://so.csdn.net/so/search/s.do?q=user&t=blog)
个人分类：[WINCE](https://blog.csdn.net/xqhrs232/article/category/906924)
触摸屏驱动为本机驱动，由微软提供有通用层 MDD，我们只需要编写PDD层就可以了。触摸屏驱动由GWES 加载，GWES 通过MDD层的DDI设备驱动程序接口函数（Device Driver Interface,DDI），实现和驱动程序的交互，而PDD层则通过实现DDSI接口函数（Device Driver Service Provider Interface, DDSI），来完成对系统的支持和对硬件的控制。他们的关系是：MDD 链接PDD 层并定义它希望调用的函数接口：设备驱动程序提供器接口。同时MDD
 把不同的函数集提供给操作系统。
Windows CE 的触摸屏驱动链接了tch_cal.lib 和tchmdd.lib 两个静态链接库。
所以在编写source檔时，要记得加上:
SOURCELIBS= /
            $(_COMMONOAKROOT)/lib/$(_CPUINDPATH)/tch_cal.lib /
            $(_COMMONOAKROOT)/lib/$(_CPUINDPATH)/tchmdd.lib  
标准接口声明(touch.def檔中声明)
       TouchPanelGetDeviceCaps;
       TouchPanelEnable;
       TouchPanelDisable;
       TouchPanelSetMode;
       TouchPanelReadCalibrationPoint;
       TouchPanelReadCalibrationAbort;
       TouchPanelSetCalibration;
       TouchPanelCalibrateAPoint;
       TouchPanelPowerHandler;
详解：
DDI界面是在WINCE500/PUBLIC/COMMON/OAK/DRIVERS/TOUCH/TCHMAIN中的tchmain.c檔中实现，在此檔中，MDD通过调用PDD的DDSI接口来实现DDI函数.
DDI 接口包括 TouchPanelGetDeviceCaps、
TouchPanelEnable、
TouchPanelDisable、
TouchPanelSetMode、
TouchPanelReadCalibrationPoint、TouchPanelReadCalibrationAbort、
TouchPanelSetCalibration、
TouchPanelCalibrateAPoint、
TouchPanelPowerHandler。
PDD层是我们真正要写的，直接与所要驱动的硬件相关。
DDSI 接口包括：
DdsiTouchPanelAttach、
DdsiTouchPanelDetach、
DdsiTouchPanelDisable、
DdsiTouchPanelEnable、
DdsiTouchPanelGetDeviceCaps、
DdsiTouchPanelGetPoint、
DdsiTouchPanelPowerHandler。
我们现在重点讲PDD层要实现的DDSI函数。
DdsiTouchPanelEnable
 由TouchPanelEnable调用
1:创建事件hTouchPanelEvent 和hCalibrationSampleAvailable。
2: 检查并初始化所需的中断gIntrTouch（触摸屏中断）和
gIntrTouchChanged（定时器中断）
3: 创建一个ISR 线程TouchPanelpISR
4:
DdsiTouchPanelDisable、
DdsiTouchPanelGetPoint:
 函数获取当前触摸屏位置和状态信息；
DdsiTouchPanelGetDeviceCaps
 询问校正点数
由TouchPanelGetDeviceCaps调用
MDD分析：
在PDD层的档与MDD与的檔之间，通过共同包含头檔tchddsi.h。来实现中逻辑中断号的通用，中断的传递等。在WINCE5.0中，tchddsi.h文件放在D:/WINCE500/PUBLIC/COMMON/OAK/INC 中，如有必要，可进行修改
接口函数声明也在该目录的touch.def文件中
摘自tchddsi.h
//定义触摸中断和 定时器中断 的逻辑中断号
extern DWORD gIntrTouch;
extern DWORD gIntrTouchChanged;
在文件tchmail.c 中，
1：TouchPanelEnable函数主要做以下工作
//把中断与事件关联
InterruptInitialize(gIntrTouch, hTouchPanelEvent, NULL, 0)
InterruptInitialize( gIntrTouchChanged, hTouchPanelEvent, NULL, 0)
//创建ISR线程
hThread = CreateThread( NULL, 0, TouchPanelpISR, 0, 0, NULL)
// 获得线程优先权
TouchPanelpGetPriority(&gThreadPriority, &gThreadHighPriority);
// 设置线程优先权
CeSetThreadPriority(hThread, gThreadPriority);
2：TouchPanelGetDeviceCaps函数：
MDD层给系统发消息
MDD层是通过PFN_TOUCH_PANEL_CALLBACK    v_pfnPointCallback;
结构给系统发的消息
3:TouchPanelpAttach函数：
 主要是生成一个事件hTouchPanelEvent。
hCalibrationSampleAvailable
hTouchPanelEvent = CreateEvent( NULL,
                            FALSE,     //  Not manual reset
                            FALSE,     //  Not signalled
                            NULL);
4: TouchPanelReadCalibrationPoint 函数
用于屏幕校准, 读取相应的触摸屏坐标值/。
TouchPanelReadCalibrationAbort(void); 终止当前活动的校准活动()
5:TouchPanelSetCalibration  
  处理上面TouchPanelReadCalibrationPoint 函数读来的校准数据，该函数将产生校准基准参数,
TouchPanelSetCalibration 函数执行的动作是一套数学算法，具体内容为:
在触摸屏数据与其位置偏移关系且屏幕像素与其位置偏移关系同为线性关
系假设情况下，触摸屏返回的位置信息与像素位置信息之间成2D 坐标变换关系。
则对于触摸屏按下点的触摸屏坐标(Tx,Ty)与其在显示设备位置关系上匹配的点
的屏幕坐标(Sx,Sy)之间的转换关系，可以通过下述坐标变换表示：
Sx = A1*Tx + B1*Ty + C1
Sy = A2*Tx + B2*Ty + C2
TouchPanelSetCalibration 的具体工作就是通过校准的动作获取的屏幕坐标
和触摸屏坐标TouchCoordinate 来确定A1，B1，C1 和A2, B2, C2。
消息定义：在文件 pegc_def.h 中有各种消息的定义，如有必要，可以修改，以合已用
// TOUCH handler wnd messages
#define WM_STUB_REGISTWND       WM_USER+1
#define WM_STUB_UNREGISTWND     WM_USER+2
#define WM_STUB_SETVALUE        WM_USER+3
#define WM_STUB_GETVALUE        WM_USER+4
#define WM_STUB_RESET           WM_USER+5
#define WM_STUB_EVENT           WM_USER+6
#define WM_STUB_GETFOCUSWND     WM_USER+7
#define WM_STUB_FOCUSBACK       WM_USER+8
#define WM_STUB_GETLASTTOUCHFOCUSWND     WM_USER+9
#define WM_STUB_GETVERSION      WM_USER+10
#define WM_STUB_TABLET          WM_USER+11
#define WM_STUBHOOK_GETFOCUS     WM_USER+3000
#define WM_STUBHOOK_READY        WM_USER+3001
启动流程：
本文来自CSDN博客，转载请标明出处：[http://blog.csdn.net/ok138ok/archive/2009/08/01/4399110.aspx](http://blog.csdn.net/ok138ok/archive/2009/08/01/4399110.aspx)
本文来自CSDN博客，转载请标明出处：[http://blog.csdn.net/ok138ok/archive/2009/08/01/4399110.aspx](http://blog.csdn.net/ok138ok/archive/2009/08/01/4399110.aspx)
