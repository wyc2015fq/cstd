# linux下c++编程环境搭建，运行过程以及调试 - xqhrs232的专栏 - CSDN博客
2016年05月03日 22:17:28[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1308
原文地址::[http://my.oschina.net/hnuweiwei/blog/227276](http://my.oschina.net/hnuweiwei/blog/227276)
相关文章
1、
# [linux环境下的c++编程](http://blog.csdn.net/netanimals/article/details/6446174)----[http://blog.csdn.net/netanimals/article/details/6446174](http://blog.csdn.net/netanimals/article/details/6446174)
# 摘要linux下c++编程环境搭建，运行过程以及调试[linux](http://www.oschina.net/search?scope=blog&q=linux)[c++](http://www.oschina.net/search?scope=blog&q=c%2B%2B)[环境配置](http://www.oschina.net/search?scope=blog&q=%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE)[运行过程](http://www.oschina.net/search?scope=blog&q=%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B)[调试](http://www.oschina.net/search?scope=blog&q=%E8%B0%83%E8%AF%95)[gdb](http://www.oschina.net/search?scope=blog&q=gdb)[g++](http://www.oschina.net/search?scope=blog&q=g%2B%2B)目录[-]- [安装g++环境](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_1)- [c/c++运行流程分解](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_2)- [预处理阶段](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h2_3)- [编译阶段](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h2_4)- [汇编阶段](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h2_5)- [生成执行文件](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h2_6)- [运行result](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h2_7)- [头文件与源文件](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_8)- [分离式编译](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_9)- [makefile](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_10)- [GDB调试](http://my.oschina.net/hnuweiwei/blog/227276#OSC_h1_11)# 安装g++环境安装两个RPM包即可搞定[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost Desktop]``# rpm -ivh /home/weiwei/Desktop/libstdc++-devel-4.4.5-6.el6.i686.rpm ``[root@localhost Desktop]``# rpm -ivh /home/weiwei/Desktop/gcc-c++-4.4.5-6.el6.i686.rpm````查看g++是否安装成功[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost Desktop]``# g++ -v``Using built-``in``specs.``Target: i686-redhat-linux``Configured with: ..``/configure``--prefix=``/usr``--mandir=``/usr/share/man``--infodir=``/usr/share/info``--with-bugurl=http:``//bugzilla``.redhat.com``/bugzilla``--``enable``-bootstrap --``enable``-shared --``enable``-threads=posix --``enable``-checking=release --with-system-zlib --``enable``-__cxa_atexit --disable-libunwind-exceptions --``enable``-gnu-unique-object --``enable``-languages=c,c++,objc,obj-c++,java,fortran,ada --``enable``-java-awt=gtk --disable-dssi --with-java-home=``/usr/lib/jvm/java-1``.5.0-gcj-1.5.0.0``/jre``--``enable``-libgcj-multifile --``enable``-java-maintainer-mode --with-ecj-jar=``/usr/share/java/eclipse-ecj``.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch=i686 --build=i686-redhat-linux``Thread model: posix``gcc``version 4.4.5 20110214 (Red Hat 4.4.5-6) (GCC)````gcc与g++的区别gcc可以用来编译C或者C++,但他只能编译c++源文件，不能自动和C++程序使用的库连接，g++可以实现C++程序的编译和链接，其实他也是调用gcc来编译的,要编译c++代码生成可执行文件要用 g++编写一个简单的c++程序[?](http://my.oschina.net/hnuweiwei/blog/227276#)``````cpp// myfirst.cpp--displays a message``````cpp#include <iostream>      // make definitions visible``````cppusing``````cppnamespace``````cppstd;``````cppint``````cppmain()``````cpp// function header``````cpp{``````cpp// start of function body``````cpp``````cppcout <<``````cpp"Come up and C++ me some time."``````cpp;``````cpp// message``````cpp``````cppcout << endl;``````cpp// start a new line``````cpp``````cppcout <<``````cpp"You won't regret it!"``````cpp<< endl;``````cpp// more output``````cpp``````cppreturn``````cpp10;``````cpp// terminate main() 返回值为0代表成功，非0返回值的含义由系统自定义``````cpp}``````cpp// end of function body``````打开命令窗口进行编译[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost Desktop]``# g++ -o test1 test.cpp````-o test1 test.cpp 从test.cpp编译生成test1文件，test1为可执行文件，没有后缀如果不写-o test1 会默认生成一个a.out可执行文件![](http://static.oschina.net/uploads/space/2014/0427/183539_iVjV_81653.gif)执行可执行文件[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost Desktop]``# ./a.out``Come up and C++ me some ``time``.``You won't regret it!````获取main函数返回值[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost Desktop]``# echo $?``10````# c/c++运行流程分解## 预处理阶段对c源文件预处理生成中间文件e.i[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ -E funcuse.c -o e.i````## 编译阶段对预处理文件进行处理生成汇编语言文件e.s[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ -S e.i -o e.s````上述两部可以直接合并为[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ -s e.i -o e.s````## 汇编阶段生成目标文件，目标文件是机器代码，但不能执行，必须将目标文件与其他目标文件或库文件连接生成可执行的二进制文件才能执行[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ -c e.s -o e.o````## 生成执行文件[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ e.o -o result````## 运行result[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# ./result````在linux操作系统中运行程序必须指定程序所在的目录，除非程序的目录已经列在PATH环境变量中，所以程序前必须加./注：echo $?  显示main函数的返回值（int型）如果想让编译和运行同时进行可以采用如下命令：gcc funcuse.c -o result && ./result&&表示如果成功就。。。如果编译成功，会直接运行程序可以将上述所有步骤合并写为[?](http://my.oschina.net/hnuweiwei/blog/227276#)````g++ funcuse.c -o result````或[?](http://my.oschina.net/hnuweiwei/blog/227276#)````g++  -o result funcuse.c````直接生成可执行文件# 头文件与源文件    程序如果复杂的话，程序的各个部分会分别存储在不同的文件中，按照逻辑进行划分。来自：[http://www.cnblogs.com/lidabo/archive/2012/04/17/2454568.html](http://www.cnblogs.com/lidabo/archive/2012/04/17/2454568.html)头文件的作用就是被其他的.cpp包含,本身并不参与编译，但实际上它们的内容却在多个.cpp文件中得到了 编译.头文件中应该只放变量和函数的声明，而不能放它们的定义这个规则是有三个例外的- 头文件中可以写const对象的定义- 头文件中可 以写内联函数（inline）的定义- 头文件中可以写类 （class）的定义# 分离式编译如果将程序分成若干子程序，怎样在linux下进行编译呢？下面以求圆的面积为例来说明Circle.h[?](http://my.oschina.net/hnuweiwei/blog/227276#)``````cpp#ifndef CIRCLE_H``````cpp#define CIRCLE_H``````cppclass``````cppCircle``````cpp{``````cpp``````cppprivate``````cpp:``````cpp``````cppdouble``````cppr;``````cpp``````cpppublic``````cpp:``````cpp``````cppCircle();``````cpp``````cppCircle(``````cppdouble``````cppR);``````cpp``````cppdouble``````cppArea();``````cpp};``````cpp#endif``````Circle.cpp[?](http://my.oschina.net/hnuweiwei/blog/227276#)``````cpp#include "Circle.h"``````cpp#include <iostream>``````cppusing``````cppnamespace``````cppstd;``````cppCircle::Circle()``````cpp{``````cpp``````cppthis``````cpp->r=5.0;``````cpp}``````cppCircle::Circle(``````cppdouble``````cppR)``````cpp{``````cpp``````cppthis``````cpp->r=R;``````cpp}``````cppdouble``````cppCircle:: Area()``````cpp{``````cpp``````cppreturn``````cpp3.14*r*r;``````cpp}``````main.cpp[?](http://my.oschina.net/hnuweiwei/blog/227276#)``````cpp#include "Circle.h"``````cpp#include <iostream>``````cppusing``````cppnamespace``````cppstd;``````cppint``````cppmain(``````cppint``````cppargc,``````cppchar``````cpp*argv[])``````cpp{``````cpp``````cppCircle c(3);``````cpp``````cppcout<<``````cpp"Area="``````cpp<<c.Area()<<endl;``````cpp``````cppreturn``````cpp0;``````cpp}``````编译[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost cpp]``# g++ -c Circle.cpp -o Circle.o``[root@localhost cpp]``# g++ -c main.cpp -o main.o``[root@localhost cpp]``# g++ main.o Circle.o -o main``[root@localhost cpp]``# ./main``Area=28.26````-c命令表示编译，头文件不许显式编译，但实际已经编译。如果只修改了一个源文件，只需要编译改动的文件# makefile但如果我们的程序有几百个源程序的时候，怎么办？难道也要编译器重新一个一个的编译？makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率[?](http://my.oschina.net/hnuweiwei/blog/227276#)````#此行为注释``main: main.o Circle.o``    ``g++ main.o Circle.o -o main``Circle.o:Circle.cpp``    ``g++ -c Circle.cpp -o Circle.o``main.o:main.cpp``    ``g++ -c main.cpp -o main.o````注意：g++命令开头的行前面必须有tab空格，不然会报错： *** missing separator.  Stop如果将名字命名为Makefile或makefile，只需要在命令行下敲入make就可以进行自动化编译[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost cpp]``# make``g++ -c main.cpp -o main.o``g++ -c Circle.cpp -o Circle.o``g++ main.o Circle.o -o main``[root@localhost cpp]``# ./main``Area=28.26````参考：[http://blog.163.com/dong_box/blog/static/2625977820103310933870/](http://blog.163.com/dong_box/blog/static/2625977820103310933870/)[[精华] 跟我一起写 Makefile - ChinaUnix.net](http://www.chinaunix.net/old_jh/23/408225.html)[编写Makefile - 学习，思考，记录，分享。 - 博客频道 - CSDN.NET](http://blog.csdn.net/livelylittlefish/article/details/3854220)# GDB调试启动gdb[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# gdb``GNU ``gdb``(GDB) Red Hat Enterprise Linux (7.2-48.el6)``Copyright (C) 2010 Free Software Foundation, Inc.``License GPLv3+: GNU GPL version 3 or later <http:``//gnu``.org``/licenses/gpl``.html>``This is ``free``software: you are ``free``to change and redistribute it.``There is NO WARRANTY, to the extent permitted by law.  Type ``"show copying"``and ``"show warranty"``for``details.``This GDB was configured as ``"i686-redhat-linux-gnu"``.``For bug reporting instructions, please see:``<http:``//www``.gnu.org``/software/gdb/bugs/``>.````调试前要先进性编译连接[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# g++ -g funcuse.c -o dbug````进行调试[?](http://my.oschina.net/hnuweiwei/blog/227276#)````[root@localhost c]``# gdb dbug``Reading symbols from ``/home/weiwei/Desktop/c/dbug``...``done``.````列出代码[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) list````1````#include<stdio.h>````2``````3   int main(){``````4````for``(int i=0 ; i<5; i++){````5````printf``(``"this is %d\n"``,i);````6       }``````7````return``0;````8   }``````[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) list 3,5````3   int main(){``````4````for``(int i=0 ; i<5; i++){````5````printf``(``"this is %d\n"``,i);````执行程序[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) run``Starting program: ``/home/weiwei/Desktop/c/dbug``this is 0``this is 1``this is 2``this is 3``this is 4````设置断点[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) ``break``5``Breakpoint 1 at 0x8048487: ``file``funcuse.c, line 5.````运行[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) r``Starting program: ``/home/weiwei/Desktop/c/dbug``Breakpoint 1, main () at funcuse.c:5````5````printf``(``"this is %d\n"``,i);``Missing separate debuginfos, use: debuginfo-``install``glibc-2.12-1.25.el6.i686 libgcc-4.4.5-6.el6.i686 libstdc++-4.4.5-6.el6.i686````到断点处程序停止，继续运行输入continue[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) c``Continuing.``this is 0``Breakpoint 1, main () at funcuse.c:5````5````printf``(``"this is %d\n"``,i);``(``gdb``) c``Continuing.``this is 1``Breakpoint 1, main () at funcuse.c:5````5````printf``(``"this is %d\n"``,i);``(``gdb``) c``Continuing.``this is 2````监测某一个值[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) ``watch``i``Hardware watchpoint 2: i````[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) c``Continuing.``this is 3``Hardware watchpoint 2: i``Old value = 3``New value = 4``0x080484a0 ``in``main () at funcuse.c:4````4````for``(int i=0 ; i<5; i++){````查看某一个特定的变量[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) print i````自动显示变量的值，每次运行到断点处都会自动显示[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) display i````查看当前自动显示的所有变量[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) info display``Auto-display expressions now ``in``effect:``Num Enb Expression``1:   y  i````查看变量类型[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) whatis i``type``= int````单步执行，step进入函数内部( 使用return命令跳出来 ，跳出前可以使用finish执行完函数体)，next把函数当成一条语句不进入函数内部[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) step  ``(``gdb``) next````删除编号为1的断点[?](http://my.oschina.net/hnuweiwei/blog/227276#)````(``gdb``) delete 1````
