# 设备驱动程序通知应用程序的几种方法 - xqhrs232的专栏 - CSDN博客
2015年04月02日 16:49:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：709
个人分类：[WINCE](https://blog.csdn.net/xqhrs232/article/category/906924)
原文地址::[http://blog.chinaunix.net/uid-20801390-id-1839284.html](http://blog.chinaunix.net/uid-20801390-id-1839284.html)
相关文章
1、[驱动程序如何发通知给应用程序](http://blog.csdn.net/91program/article/details/2539594)----[http://blog.csdn.net/91program/article/details/2539594](http://blog.csdn.net/91program/article/details/2539594)
2、[驱动程序通知应用程序读取数据的方法总结](http://blog.csdn.net/yyylll62803112/article/details/21609681)----[http://blog.csdn.net/yyylll62803112/article/details/21609681](http://blog.csdn.net/yyylll62803112/article/details/21609681)
3、[linux中驱动异步通知应用程序的方法](http://blog.chinaunix.net/uid-21714580-id-119967.html) ----[http://blog.chinaunix.net/uid-21714580-id-119967.html](http://blog.chinaunix.net/uid-21714580-id-119967.html)
4、[驱动程序异步通知应用程序，数据是否可读](http://blog.csdn.net/adc0809608/article/details/7368119)----[http://blog.csdn.net/adc0809608/article/details/7368119](http://blog.csdn.net/adc0809608/article/details/7368119)
设备驱动程序通知应用程序的几种方法
摘要 在目前流行的Windows操作系统中,设备驱动程序是操纵硬件的最底层软件接口。为了共享在设备驱动程序设计过程中的经验,给出设备驱动程序通知应用程序的5种方法,详细说明每种方法的原理和实现过程,并给出实现的部分核心代码。希望能够给设备驱动程序的设计者提供一些帮助。
关键词 设备驱动程序 异步I/O Virtual Device Driver（VxD） Windows Driver Model（WDM）
　　在DOS操作系统中,应用程序可以直接与硬件打交道,包括I/O端口读写、中断请求与响应以及DMA操作等[1]。这种对硬件过于直接的操作方式给软件设计提供了一定的便利,但也有它自身的一些缺点。首先,一些非法操作有可能改写某些硬件寄存器的内容,导致操作系统崩溃,从而使操作系统变得不安全,性能不稳定;其次,应用程序的可移植性变差。为了保证操作系统的安全性和稳定性以及应用程序的可移植性,Windows操作系统不允许应用程序直接访问系统的硬件资源,而是必须借助于相应的设备驱动程序。设备驱动程序可以直接操作硬件,如果应用程序和设备驱动程序之间实现了双向通信,也就达到了应用程序控制底层硬件设备的目的。它们之间的通信包括两个方面：一方面是应用程序传送给设备驱动程序的数据;另一方面是设备驱动程序发送给应用程序的消息。前者的实现较容易,通过CreateFile()函数获取设备驱动程序的句柄后,就可以使用Win32函数,如DeviceIoControl()、ReadFile()或WriteFile()等实现应用程序与设备驱动程序之间的通信[2]。DDK和MSDN对它们有详细的描述,读者可以参考相关资料。后者的实现远比前者复杂,同时介绍这方面情况的文章较少。这不等于说它不重要,相反,它在有些应用场合发挥着重要的作用。例如,在数据采集系统中,应用程序向设备驱动程序发送采集数据的命令后,建立一个辅助线程等待数据采集完成,而应用程序本身则可继续干其它的工作。设备驱动程序完成数据的采集工作后,需要马上通知应用程序,以便应用程序能够及时将数据取走并进行处理。诸如此类情况,不一而足。
　　鉴于设备驱动程序通知应用程序的重要性,作者结合一些经验和已有的资料[3~5],对它进行了总结,归纳出5种方法：异步过程调用(APC)、事件方式（VxD）、消息方式、异步I/O方式和事件方式(WDM)。下面分别说明这几种方式的原理,并给出实现的部分源代码。
1  异步过程调用(APC)
　　Win32应用程序使用CreateFile()函数动态加载设备驱动程序,然后定义一个回调函数backFunc(),并且将回调函数的地址&backFunc()作为参数,通过DeviceIoControl()传送给设备驱动程序。设备驱动程序获得回调函数的地址后,将它保存在一个全局变量（如callback）中,同时调用Get_Cur_Thread_Handle()函数获取它的应用程序线程的句柄,并且将该句柄保存在一个全局变量（如appthread）中。当条件成熟时,设备驱动程序调用_VWIN32_QueueUserApc()函数,向Win32应用程序发送消息。这个函数带有三个参数：第一个参数为回调函数的地址（已经注册）;第二个参数为传递给回调函数的消息;第三个参数为调用者的线程句柄（已经注册）。Win32应用程序收到消息后,自动调用回调函数（实际是由设备驱动程序调用）。回调函数的输入参数是由设备驱动程序填入的,回调函数在这里主要是对消息进行处理。
2  事件方式（VxD）
　　首先,Win32应用程序创建一个事件的句柄,称其为Ring3句柄。由于虚拟设备驱动程序使用事件的Ring0句柄,因此,需要创建Ring0句柄。用LoadLibrary()函数加载未公开的动态链接库Kernel32.dll,获得动态链接库的句柄。然后,调用GetProcAddress(), 找到函数OpenVxDHandle()在动态链接库中的位置。接着,用OpenVxDHandle()函数将Ring3事件句柄转化为Ring0事件句柄。Win32应用程序用CreateFile()函数加载设备驱动程序。如果加载成功,则调用DeviceIoControl()函数将Ring0事件句柄传给VxD;同时,创建一个辅助线程等待信号变成有信号状态,本身则可去干其它的事情。当条件成熟时,VxD置Ring0事件为有信号状态（调用_VWIN32_SetWin32Event()函数）,这马上触发对应的Ring3事件为有信号状态。一旦Ring3事件句柄为有信号状态,Win32应用程序的辅助线程就对这个消息进行相应的处理。
3  消息方式
　　Win32应用程序调用CreateFile()函数动态加载虚拟设备驱动程序。加载成功后,通过调用DeviceIoControl()函数将窗体句柄传送给VxD,VxD利用这个句柄向窗体发消息。当条件满足时,VxD调用SHELL_PostMessage()函数向Win32应用程序发送消息。要让该函数使用成功,必须用#define来自定义一个消息,并且也要照样在应用程序中定义它;还要在消息循环中使用ON_MESSAGE()来定义消息对应的消息处理函数,以便消息产生时,能够调用消息处理函数。SHELL_PostMessage()函数的第一个参数为Win32窗体句柄,第二个参数为消息ID号,第三、四个参数为发送给消息处理函数的参数,第五、六个参数为回调函数和传给它的参数。Win32应用程序收到消息后,对消息进行处理。
4  异步I/O方式
　　Win32应用程序首先调用CreateFile()函数加载设备驱动程序。在调用该函数时,将倒数第2个参数设置为FILE_ATTRIBUTE_NORMAL FILE_FLAG_ OVERLAPPED,表示以后可以对文件进行重叠I/O操作。当设备驱动程序文件创建成功后,创建一个初始态为无信号、需要手动复位的事件,并且将这个事件传给类型为OVERLAPPED的数据结构（如Overlapped）。然后,将Overlapped作为一个参数,传给DeviceIoControl()函数。设备驱动程序把这个I/O请求包（IRP）设置为挂起状态,并且设置一个取消例程。如果当前IRP队列为空,则将这个IRP传送给StartIo()例程;否则,将它放到IRP队列中。设备驱动程序做完这些工作后,结束这个DeviceIoControl()的处理,于是Win32应用程序可能不等待IRP处理完,就从DeviceIoControl()的调用中返回。通过判断返回值,得到IRP的处理情况。如果当前IRP处于挂起状态,则主程序先做一些其它的工作,然后调用WaitForSingleObject()或WaitForMultipleObject()函数等待Overlapped中的事件成为有信号状态。设备驱动程序在适当的时候处理排队的IRP,处理完成后,调用IoCompleteRequest()函数。该函数将Overlapped中的事件设置为有信号状态。Win32应用程序对这个事件马上进行响应,退出等待状态,并且将事件复位为无信号状态,然后调用GetOverlappedResult()函数获取IRP的处理结果。
5  事件方式（WDM）
　　Win32应用程序首先创建一个事件,然后将该事件句柄传给设备驱动程序,接着创建一个辅助线程,等待事件的有信号状态,自己则接着干其它事情。设备驱动程序获得该事件的句柄后,将它转换成能够使用的事件指针,并且把它寄存起来,以便后面使用。当条件具备后,设备驱动程序将事件设置为有信号状态,这样应用程序的辅助线程马上知道这个消息,于是进行相应的处理。当设备驱动程序不再使用这个事件时,应该解除该事件的指针。
　　本刊网络补充版（http://www.dpj.com.cn）中,介绍了各部分实现的部分代码。
结语
　　在目前流行的Windows操作系统中,设备驱动程序是操纵硬件的最底层软件接口。它向上提供与硬件无关的用户接口,向下直接进行I/O、硬件中断、DMA和内存访问等操作。它将应用程序与硬件细节屏蔽开来,使软件不依赖于硬件并且可在多个不同的平台之间移植。本文介绍了5种设备驱动程序通知应用程序的方法,其中前3种方法主要用于VxD中,后2种方法主要用于WDM。这5种方法都经过实际测试。测试结果表明,它们都能够达到设备驱动程序通知应用程序的目的。
参考文献
1  欧青立,徐建波,李方敏,等. 虚拟设备驱动程序VxD的研究与开发[J]. 计算机工程,2003,28(3): 45~46
2  (美)Chris Cant. Windows WDM设备驱动程序开发指南[M]. 孙义, 马莉波, 国雪飞等译. 北京: 机械工业出版社, 2000. 20~50
3  Karen Hazzan. Windows VxD与设备驱动权威指南[M]. 孙喜明译. 北京: 中国电力出版社, 1999. 28~100
4  Walter Oney. Programming the Microsoft Windows Driver Model[M]. （美）Microsoft Press, 1999. 35~180
5  李和平. 基于DSP的ICT图像重建系统研究[D]. 北京: 北京航空航天大学机械工程及自动化学院, 2002
周正干  博士、教授,主要研究方向为计算机测控技术和数字图像处理技术。
李和平  硕士,研究方向为数据采集与图像处理。
安振刚  博士后,研究方向为机电控制及自动化。
