# MFC中CString.Format的详细用法 - xqhrs232的专栏 - CSDN博客
2013年07月01日 14:30:27[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：465
个人分类：[C/C++/VC++/VS](https://blog.csdn.net/xqhrs232/article/category/906934)
原文地址::[http://blog.csdn.net/wangkaishou/article/details/5846152](http://blog.csdn.net/wangkaishou/article/details/5846152)
在MFC程序中，使用CString来处理字符串是一个很不错的选择。CString既可以处理Unicode标准的字符串，也可以处理ANSI标准的字符串。CString的Format方法给我们进行字符串的转换带来了很大的方便，比如常见的int、float和double这些数字类型转换为CString字符串只需一行代码就可以实现。
　　先看看Format用于转换的格式字符：
　　%c                 单个字符
　　%d                 十进制整数(int)
　　%ld                十进制整数(long)
　　%f                 十进制浮点数(float)
　　%lf                十进制浮点数(double)
　　%o                 八进制数
　　%s                 字符串
　　%u                 无符号十进制数
　　%x                 十六进制数
　　1、int转换为CString：
　　CString str;
　　int number=15;
　　//str="15"
　　str.Format(_T("%d"),number);
　　//str=" 15"(前面有两个空格；4表示将占用4位，如果数字超过4位将输出所有数字，不会截断)
　　str.Format(_T("%4d"),number);
　　//str="0015"(.4表示将占用4位，如果数字超过4位将输出所有数字，不会截断)
　　str.Format(_T("%.4d"),number);
　　long转换为CString的方法与上面相似，只需要把%d改为%ld就可以了。
　　2、double转换为CString：
　　CString str;
　　double num=1.46;
　　//str="1.46"
　　str.Format(_T("%lf"),num);
　　//str="1.5"(.1表示小数点后留1位，小数点后超过1位则四舍五入)
　　str.Format(_T("%.1lf"),num);
　　//str="1.4600"
　　str.Format(_T("%.4f"),num);
　　//str=" 1.4600"(前面有1个空格)
　　str.Format(_T("%7.4f"),num);
　　float转换为CString的方法也同上面相似，将lf%改为f%就可以了。
　　3、将十进制数转换为八进制：
　　CString str;
　　int num=255;
　　//str="377"
　　str.Format(_T("%o"),num);
　　//str="00000377"
　　str.Format(_T("%.8o"),num);
Format是一个很常用，却又似乎很烦的方法，以下是它的完整概貌，以供大家查询之用：  
格式化字符串forma("%d",12)意思是将一个整形的格式化的字符(我认为是保持其形状不变) 
1).格式说明总是以%字符开始,以下是不同类型数据的格式方式%号后的说明: 
d输出带符号十进制数 
o输出无符号八进制数 
x输出无符号十六进制数 
u输出无符号数 
c输出单个字符 
s输出一串字符 
f输出实数（6位小数） 
e以指数形式输出实数 
g选用f与e格式中输出宽度较小的格式，不输出0 
ld输入输出long型数据 
lf输入输出double型数据 
m数据输出宽度为m 
.n输出小数位数为n 
一、字符串 
首先看它的声明：  
function Format(const Format: string; const Args: array of const): string; overload;  
事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的，  
但并不多用，所以这里只对第一个介绍：  
function Format(const Format: string; const Args: array of const): string; overload;  
Format参数是一个格式字符串，用于格式化Args里面的值的。Args又是什么呢，  
它是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。  
如以下例子：  
Format("my name is %6s","wind");  
返回后就是  
my name is wind  
现在来看Format参数的详细情况：  
Format里面可以写普通的字符串，比如"my name is"  
但有些格式指令字符具有特殊意义，比如"%6s"  
格式指令具有以下的形式：  
"%" [index ":"] ["-"] [width] ["." prec] type  
它是以"%"开始,而以type结束，type表示一个具体的类型。中间是用来  
格式化type类型的指令字符，是可选的。  
先来看看type,type可以是以下字符：  
d 十制数，表示一个整型值  
u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时  
是一个2的32次方减去这个绝对值的数  
如：Format("this is %u",-2);  
返回的是：this is 4294967294  
f 对应浮点数  
e 科学表示法，对应整型数和浮点数，  
比如Format("this is %e",-2.22);  
返回的是：this is -2.220000E+000  
等一下再说明如果将数的精度缩小  
g 这个只能对应浮点型，且它会将值中多余的数去掉  
比如Format("this is %g",02.200);  
返回的是：this is 2.2  
n 只能对应浮点型，将值转化为号码的形式。看一个例子就明白了  
Format("this is %n",4552.2176);  
返回的是this is 4,552.22  
注意有两点，一是只表示到小数后两位，等一下说怎么消除这种情况  
二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的  
m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化  
另外它只对应于浮点值  
Format("this is %m",9552.21);  
返回：this is ￥9,552.21  
p 对应于指针类型，返回的值是指针的地址，以十六进制的形式来表示  
例如：  
Format("this is %p",p);  
Edit1的内容是：this is 0012F548  
s 对应字符串类型，不用多说了吧  
x 必须是一个整形值，以十六进制的形式返回  
Format("this is %X",15);  
返回是：this is F  
类型讲述完毕，下面介绍格式化Type的指令：  
[index ":"] 这个要怎么表达呢，看一个例子  
Format("this is %d %d",12,13);  
其中第一个%d的索引是0，第二个%d是1，所以字符显示的时候  
是这样 this is 12 13  
而如果你这样定义：  
Format("this is %1:d %0:d",12,13);  
那么返回的字符串就变成了  
this is 13 12  
现在明白了吗，[index ":"] 中的index指示Args中参数显示的  
顺序  
还有一种情况，如果这样Format("%d %d %d %0:d %d", 1, 2, 3, 4) ; 
将返回1 2 3 1 2。  
如果你想返回的是1 2 3 1 4，必须这样定：  
Format("%d %d %d %0:d %3:d", 1, 2, 3, 4) ; 
但用的时候要注意，索引不能超出Args中的个数，不然会引起异常  
如Format("this is %2:d %0:d",12,13);  //error
由于Args中只有12 13 两个数，所以Index只能是0或1，这里为2就错了  
[width] 指定将被格式化的值占的宽度，看一个例子就明白了  
Format("this is %4d",12);  
输出是：this is 12  
这个是比较容易，不过如果Width的值小于参数的长度，则没有效果。  
如：Format("this is %1d",12);  
输出是：this is 12  
["-"] 这个指定参数向左齐，和[width]合在一起最可以看到效果：  
Format("this is %-4d,yes",12);  
输出是：this is 12 ,yes  
["." prec] 指定精度，对于浮点数效果最佳：  
Format('this is %.2f',['1.1234]);  
输出 this is 1.12  
Format('this is %.7f',['1.1234]);  
输了 this is 1.1234000  
而对于整型数，如果prec比如整型的位数小，则没有效果  
反之比整形值的位数大，则会在整型值的前面以0补之  
Format('this is %.7d',[1234]);  
输出是：this is 0001234]  
对于字符型，刚好和整型值相反，如果prec比字符串型的长度大  
则没有效果，反之比字符串型的长度小，则会截断尾部的字符  
Format('this is %.2s',['1234']);  
输出是 this is 12  
而上面说的这个例子：  
Format('this is %e',[-2.22]);  
返回的是：this is -2.22000000000000E+000  
怎么去掉多余的0呢，这个就行啦  
Format('this is %.2e',[-2.22]);  
好了，第一个总算讲完了，应该对他的应用很熟悉了吧  
m_result.Format("您选的城市是:/r/n %s,/r/n您选的人是:/r/n%s",city1 +  city2 +  city3,people); 
  UpdateData(0);
格式小结： 
（1）最常用的格式是%d，含义是以10进制形式打印一个整数。 
如果输出的整数是负数，则，输出的第一个字符就是‘-’号 
（2）%u格式与%d格式类似，只不过要求打印无符号10进制整数。 
（3）%o格式请求输出8进制整数 
（4）%x和%X格式请求输出16进制整数。 
%x格式中用小写字母a,b,c,d,e,f来表示10到15之间的数 
%X格式中用大写字母A,B,C,D,E,F来表示10到15之间的数 
共同点：8进制和16进制整数总是作为无符号数处理的。 
（5）%s格式用于打印字符串，与之对应的参数应该是一个字符指针，待输出的字符始于该指针所指向的地址，直到出现一个空字符（'/0'） 
才终止。 
（6）%c格式用于打印单个字符：例如： 
printf("%c",c); 等价于 putchar©; 
（7）%g,%f和%e这三个格式用于打印浮点值。 
%g格式用于打印那些不需要按列对齐的浮点数特别有用。其作用有二： 
一，去掉该数尾多余的零（没有达到六位的数） 
二，保留六位有效数字（多余六位的） 
%e格式用于打印浮点数时，一律显示地使用指数形式：例如：输出圆周率时是：3.141593e+00 
两者的区别： 
%g格式打印出的数是总共6位有效数字 
%e格式打印出小数点后的6位有效数字 
%f禁止使用指数形式来表示浮点数。因此圆周率输出为：3.141593 
（但注意它的精度要求：也是小数点后6位有效数字） 
（8）%%格式用于打印一个%字符。 
（9）%E和%G只是在输出时用大写字母（E）代替了小写字母(e) 
另外需要注意的一些知识点: 
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ 
对齐规则： 
（1）当指定宽度大于要输出位数时，数右对齐，左端补空格 
当前缀'-'号时，想要数左对齐，右端补空格 
大大的前提：只有当“指定宽度”存在时，前缀'-'才有意义。 
经验：一般来说，左端对齐的形式看上去要美观整齐一点。 
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ 
输出正负号的技巧：（记住）例如： 
printf("%+d %+d %+d/n",-5,0,5); 
只要在中间加个“+”号就行。作用是输出符号位（即，数的正负号） 
如果不希望正数的前面出现‘+’号，可用下面的方法 
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ 
只要在中间加个“ ”号（即：空格）就行。（记住）例如： 
作用：如果一个数是非负数，就在它的前面插入一个空格。 
int i; 
for(i=-3;i<=3;i++) 
 printf("% d/n",i); //注意%和d之间有一个空格 
输出结果如下： 
-3 
-2 
-1 
0 
1 
2 
3 
问题：如果‘+’和‘ ’同时出现在“中间”时，要以‘+’为准。 
两个符号的共同点：用于对齐输出的数：（尤其对于小数来说） 
 两种格式：%+e和% e 
C语言中基本的输入输出函数有： 
putchar ():把变量中的一个字符常量输出到显示器屏幕上; 
getchar ();从键盘上输入一个字符常量,此常量就是该函数的值; 
printf ();把键盘中的各类数据,加以格式控制输出到显示器屏幕上; 
scanf ();从键盘上输入各类数据,并存放到程序变量中; 
puts ():把数组变量中的一个字符串常量输出到显示器屏幕上; 
gets ():从键盘上输入一个字符串常量并放到程序的数组中. 
sscanf(); 从一个字符串中提取各类数据。 
 putchar() 和 getchar() 顾名思议就是从输入流中获取一个字符和输出一个字符，比较简单，不再多讲。 
例子如下： 
char c = getchar(); 
putchar©; 
 格式化输入输出scanf()和printf()是最有用的，所以重点讲一下。 
printf(): 
一般形式: 
printf("格式控制".输出列表);  
eg : printf("a=%d,b=%f,c=%c/n",a,b,c); 
1;格式控制. 
格式控制是用双引号括起来的字符串,也称"转换控制字符串",它包含以下两部分信息. 
格式说明：由"%"和格式字符组成,如%d,%f,%c,他的作用是把输出数据转换为指定格式输出,格式的说明总是由"%"字符开始的.
普通字符：需要原样输出的字符,或者是一些有特殊含义的字符，如/n,/t。 
2;输出列表 
就是需要输出的一些数据,也可以是表达式,如果在函数中需要输出多个变量或表达式,则要用逗号隔开. 
 一些特殊字符的输出： 
单引号，双引号，和反斜杠的输出在前面加转义字符”/” 
如：”/’” , “/”” , “//” 
%的输出用两个连在一起的%%，即printf(“%%”); 
常用的格式说明如下: 
格式字符 
d 以十进制形式输出带符号整数(正数不输出符号)  
o 以八进制形式输出无符号整数(不输出前缀O)  
x 以十六进制形式输出无符号整数(不输出前缀OX)  
u 以十进制形式输出无符号整数  
f 以小数形式输出单精度实数  
lf以小数形式输出双精度实数 
e 以指数形式输出单、双精度实数  
g 以%f%e中较短的输出宽度输出单、双精度实数  
c 输出单个字符  
s 输出字符串  
 这里强调一下：网上很多文章都说f 和lf是一样的，即不管单精度，双精度浮点数，都可以用f, 但我在POJ上做过测试，输出Double时用f确实也可以 ，但读入时，用f就报WA，所以大家如果对Double进行读写的话，都用lf吧。 
说到Double，再啰嗦一句，建议大家要用到浮点数时都用Double，不要用float，因为在很多情况下，float精度不够会导致WA。 
特殊： 
对64位整数的输入输出，在POJ上的C++环境下(即VC)，64位整数是： 
__int64 （注意int前面是两个下划线） 
输入输出格式为”%I64d”. 
在G++环境下(即Dev C++) 64位整数是 
long long 
输入输出格式为”%lld”. 
输出宽度 
　　用十进制整数来表示输出的最少位数。 注意若实际位数多于定义的宽度，则按实际位数输出， 若实际位数少于定义的宽度则补以空格或0。 
精度 
　 精度格式符以“.”开头，后跟十进制整数。意义是：如果输出数字，则表示小数的位数；如果输出的是字符， 则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。 
标志格式字符  
- 结果左对齐，右边填空格  
+ 输出符号(正号或负号)空格输出值为正时冠以空格，为负时冠以负号 
例如： 
double c=24212345.24232; 
printf(“%020.4”); 表示输出精确到小数点后4位，输出占20位，若有空余的位补0. 
 scanf： 
scanf的很多用法都是和printf对应的，故不再赘述。 
说一下scanf一个特别好用的地方，就是可以滤去一些不想要的东西。 
举例说明如下： 
比如输入为日期 yyyy-mm-dd，就可以这样写： 
int year,moth,day; 
scanf(“%d-%d-%d”,&year,&moth,&day); 
再比如： 
scanf("%3d %*3d %2d",&m,&n); 输入113 118 69回车(系统将113赋予m,将69赋予n,因为*号表示跳过它相应的数据所以118不赋予任何变量) 
puts()用的不多，且基本都能用printf()代替，故不再多说。 
gets()是从输入流中获取一行字符串放入字符数组中: 
char in[100]; 
gets(in); 
大家可能最容易出错的地方就是字符串的输入，所以强调一下： 
能进行字符，字符串输入的有： 
getchar(), scanf(“%c”); scanf(“%s”), gets() 
其中getchar() 和 scanf(“%c”)的功能是一样的。 
需要注意的是，这两个函数读入的是输入流中当前位置的字符， 
比如： 
 scanf(“%d”,&n); 
 c = getchar(); 
假设输入 67/ (假设“/”代表回车)，则第一个scanf读入一个整数67后，当前输入流的位置是67之后，即指向回车符，所以第二个getchar()读入的就是一个回车符了，即 c = ‘/n’。 
同样，gets()也是从当前位置读入一行字符串。 
比如： 
scanf(“%d”,&n); 
gets(str); 
此时读入字符数组中的字符串就是“/n” 了 
所以通常在用scanf读入一个非字符串的类型之后，如果要读入字符，或字符数组，都用一个额外的getchar()把回车符读掉，若后面跟的不止一个回车符，可能还有多余的空格的话，就用gets()读掉。 
 和以上不同的是，scanf(“%s”) 读入的时候是会忽略掉空格，回车和制表符的。并且以空格，回车和制表符作为字符串结束的标志。 
 经常会有这样的题，输入第一行是一个整数，接下来每行的第一个是一个字符，用来表示某种操作，后面再跟一些数据，比如： 
4 
A 100 2 
B 23 
A 23 89 
B 34 
像这种输入就需要小心，读入字符时不要读成回车符。 
为了防止意外，我一般是这样处理这类输入的： 
char model[2]; 
Scanf(“%d”,&n); 
for(…,…,…){ 
 scanf(“%s”,model); 
 if(model[0] == ‘A’){ 
} 
else{ 
} 
} 
 sscanf(): 
sscanf()经常用来分解字符串，功能非常强大，但很多功能都需要正则表达式的知识，所以就介绍一下最简单的几种用法，大家如果想了解更多的话，自己去网上找吧。 
1. 
char str[100],str1[100],str2[100]; 
gets(str); 
sscanf(str,”%s%s”,str1,str2); 
将读入的一整行字符串按空格，制表符或回车符分割成两个字符串。 
2 
取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。 
　　sscanf("123456 ", "%4s", str);
