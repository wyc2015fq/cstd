# ISO14443-4块传输的实现（卡） - xqhrs232的专栏 - CSDN博客
2015年04月23日 10:43:39[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1633
原文地址::[http://blog.sina.com.cn/s/blog_a20257d80101cju7.html](http://blog.sina.com.cn/s/blog_a20257d80101cju7.html)
相关文章
1、
## ISO14443-4块传输协议的实现
 ----[http://blog.sina.com.cn/s/blog_a20257d80101cju3.html](http://blog.sina.com.cn/s/blog_a20257d80101cju3.html)
贴上自己的代码，目前测试通过，但我感觉结构不是很好，希望和大家交流共同提高。
.H文件
#define  ACKN          -1
#define  ACKY          -2
#define  RESEND        -3
#define  ONSENDNEXT    -4
#define  SENDDEL        -5
#define  SENDWTX        -6
#define  DONOTHING        -12
#define  BLOCK_MASK       0XC0
#define  IBLOCK           0X00
#define  RBLOCK           0X80
#define  SBLOCK           0XC0
#define  NACK_MASK        0X10
#define  CID_MASK         0X08
#define  BNUM_MASK        0X01
#define  WTX_DEL_MASK     0X30
#define  LINK_MASK        0X10
#define  WTX     0X30
#define  DELSECT          0X00 
.c文件
unsigned char near     CCID;
unsigned char near  Frame_Data_Len_Card;
unsigned char  near currentflag;
unsigned char  near lastframe[64];
unsigned char  near lastframelen;
unsigned char  near PBuffer[270],CardBuffer[270];
unsigned short near PBufferLength,PBufferPoint,CardBufPoint,CardBufferLength;
bit cblock_num,CCid_En; 
unsigned char AckN(void)
{
  unsigned char near buf[4];
  buf[0] = 0XA2|cblock_num;
  buf[0] = CCid_En?buf[0]|0x08:buf[0];
  buf[1] = CCID;
  WriteCardFifo(buf,2);  
  SetRecvOrSend(START_SEND_AND_RECV);
//  PutDatUart(buf, 2);
  return OK; 
}
unsigned char AckY(void)
{
  unsigned char near buf[4];
  cblock_num=!cblock_num;
  buf[0] = 0XA2|cblock_num;
  buf[0] = CCid_En?buf[0]|0x08:buf[0];
  buf[1] = CCID;  
  WriteCardFifo(buf,(unsigned char)((unsigned char)CCid_En+1));
//  PutDatUart(buf, 2); 
  return SetRecvOrSend(START_SEND_AND_RECV);
}
char CardRecvFrameProcess(unsigned char *tempbuf,unsigned char inlen)
{
   unsigned short near len;
   unsigned char near PCB;
   unsigned char near Cid;
   unsigned char near lastflag = currentflag;
   len = inlen;
   if(len==0)
   {
      return DONOTHING;
   } 
   PCB = tempbuf[0];
   Cid = PCB&CID_MASK;
   if(((CCid_En==1)&&(CCID!=0)&&(Cid==0)) || ((CCid_En==0)&&(Cid==1))) return DONOTHING; 
   if((PCB&BLOCK_MASK) ==IBLOCK)//i-block
   {
     if(PCB&CID_MASK)//带CID时，长度应该不少于2字节
     {
        if(len<=2) return DONOTHING;
     }
     else //不带CID时长度不应少于1个字节
     {
        if(len<2)  return DONOTHING;
     }       
     if((PCB&0X02)!=0X02) return DONOTHING;
     currentflag = PCB & LINK_MASK;                                       
     if(currentflag) 
     {             
       if(lastflag)
       {
          if((PBufferLength + len - 1 - (unsigned char)CCid_En)>BUFFERLENGTH)
