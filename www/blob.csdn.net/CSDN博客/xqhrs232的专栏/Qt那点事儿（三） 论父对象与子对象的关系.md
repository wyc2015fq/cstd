# Qt那点事儿（三） 论父对象与子对象的关系 - xqhrs232的专栏 - CSDN博客
2016年10月14日 22:54:45[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1531
原文地址::[http://www.cnblogs.com/andreitang/archive/2011/08/25/2128508.html](http://www.cnblogs.com/andreitang/archive/2011/08/25/2128508.html)
相关文章
1、[Qt那点事儿（一）](http://www.cnblogs.com/andreitang/archive/2011/08/03/2125815.html)----[http://www.cnblogs.com/andreitang/archive/2011/08/03/2125815.html](http://www.cnblogs.com/andreitang/archive/2011/08/03/2125815.html)
2、[Qt那点事儿（二）](http://www.cnblogs.com/andreitang/archive/2011/08/08/2128505.html)----[http://www.cnblogs.com/andreitang/archive/2011/08/08/2128505.html](http://www.cnblogs.com/andreitang/archive/2011/08/08/2128505.html)
# 第三回 父与子
70后的道友都应该看过这么一部片子叫做<<父子情深>>。讲述的是一个小男孩患了绝症,父亲为了满足他的愿望,让已关门的游乐园为他们父子俩重新开放。在游乐园尽情地玩耍后,最后小孩子在父亲的怀中安详地闭上了眼睛。缓缓转动的摩天轮,配着淡淡忧伤的曲调,这一刻哥泪流满面。谁说世上只有妈妈好,父爱也顶半边天。此时台下的众多男道友热泪盈眶，不约而同地起立鼓掌。史上最大的冤屈，终于得以昭雪。
但是人世间这种真挚的父爱也存在于Qt中吗？ 对此，从小缺乏父爱的张无忌小友给出了自己的答案，
```
```cpp
#include
 <QDebug>
```
```cpp
#include
 <QThread>
```
```cpp
class
```
```cpp
MyTestA
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
};
```
```cpp
class
```
```cpp
MyTestB
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestB(QObject
 *parent):QObject(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
extern
```
```cpp
MyTestB
 *g_pMyTestB;
```
```cpp
extern
```
```cpp
MyTestA
 *g_pMyTestA;
```
```cpp
class
```
```cpp
MyTestC
 :
```
```cpp
public
```
```cpp
QThread
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestC():QThread(NULL)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
void
```
```cpp
run()
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
exec();
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[])
```
```cpp
{
```
```cpp
```
```cpp
QApplication
 app(argc, argv);
```
```cpp
```
```cpp
MyTestA
 a;
```
```cpp
```
```cpp
MyTestB
 b(&a);
```
```cpp
```
```cpp
MyTestC
 c;
```
```cpp
```
```cpp
c.start();
```
```cpp
```
```cpp
a.moveToThread(&c);
```
```cpp
```
```cpp
if
```
```cpp
(a.
```
```cpp
thread
```
```cpp
()
 == b.
```
```cpp
thread
```
```cpp
()
 && a.
```
```cpp
thread
```
```cpp
()!=app.
```
```cpp
thread
```
```cpp
())
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"Both
 parent and son have the same thread"
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
app.exec();
```
```cpp
}
```
```
从容地按下了F5之后，只见输出窗口妥妥地输出了"Both parent and son have the same thread".
**在Qt中，当一个对象被移到另一个线程时，他的所有子对象也会一并转移到另外那个线程。**
一人移民，全家无忧阿。在场的一些兼职移民中介的道友叹道，简直就是一个经典的家庭移民案例。不愧是家有一父，如有一宝啊。
紧接着只见张无忌，对此代码稍作了修改，
```
```cpp
class
```
```cpp
MyTestA
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
};
```
```cpp
class
```
```cpp
MyTestB
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestB(QObject
 *parent):QObject(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
extern
```
```cpp
MyTestB
 *g_pMyTestB;
```
```cpp
extern
```
```cpp
MyTestA
 *g_pMyTestA;
```
```cpp
class
```
```cpp
MyTestC
 :
```
```cpp
public
```
```cpp
QThread
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestC():QThread(NULL)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
void
```
```cpp
run()
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
g_pMyTestA->moveToThread(
```
```cpp
this
```
```cpp
);
```
```cpp
```
```cpp
exec();
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
MyTestB
 *g_pMyTestB = NULL;
```
```cpp
MyTestA
 *g_pMyTestA = NULL;
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[])
```
```cpp
{
```
```cpp
```
```cpp
QApplication
 app(argc, argv);
```
```cpp
```
```cpp
MyTestA
 a;
```
```cpp
```
```cpp
g_pMyTestA
 = &a;
```
```cpp
```
```cpp
MyTestB
 b(&a);
```
```cpp
```
```cpp
MyTestC
 c;
```
```cpp
```
```cpp
c.start();
```
```cpp
```
```cpp
return
```
```cpp
app.exec();
```
```cpp
}
```
```
却见output窗口打出,
"QObject::moveToThread: Current thread (0x2ff944) is not the object's thread (0x357b20).
 Cannot move to target thread (0x2ff944)"
**在Qt中，如果要切换对象的线程，不能到了目标线程里再调用moveToThread,此举会导致切换线程失败。**
众人皆称，移民要合法，偷渡要不得啊。
就在众人嗟叹时，年轻气盛的无忌小友，又刷刷的写下了以下代码，
```
```cpp
#include
 <QThread>
```
```cpp
class
```
```cpp
MyTestA
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
};
```
```cpp
class
```
```cpp
MyTestB
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestB(QObject
 *parent):QObject(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
extern
```
```cpp
MyTestB
 *g_pMyTestB;
```
```cpp
extern
```
```cpp
MyTestA
 *g_pMyTestA;
```
```cpp
class
```
```cpp
MyTestC
 :
```
```cpp
public
```
```cpp
QThread
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestC(QObject
 *parent):QThread(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
class
```
```cpp
MyTest
 :
```
```cpp
public
```
```cpp
QDialog
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTest(QWidget
 *parent = 0, Qt::WFlags flags = 0);
```
```cpp
```
```cpp
~MyTest();
```
```cpp
protected
```
```cpp
slots:
```
```cpp
```
```cpp
void
```
```cpp
onClick();
```
```cpp
private
```
```cpp
:
```
```cpp
```
```cpp
Ui::MyTestClass
 ui;
```
```cpp
};
```
```cpp
/////////////////////////////////////////
```
```cpp
MyTest::MyTest(QWidget
 *parent, Qt::WFlags flags)
```
```cpp
```
```cpp
:
 QDialog(parent, flags)
```
```cpp
{
```
```cpp
```
```cpp
ui.setupUi(
```
```cpp
this
```
```cpp
);
```
```cpp
```
```cpp
//set
 the window to be the top window
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>
```
```cpp
this
```
```cpp
->setWindowFlags(windowFlags()|Qt::WindowStaysOnTopHint);</span>
```
```cpp
}
```
```cpp
MyTest::~MyTest()
```
```cpp
{
```
```cpp
}
```
```cpp
void
```
```cpp
MyTest::onClick()
```
```cpp
{
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>QMessageBox
 box(
```
```cpp
this
```
```cpp
);</span>
```
```cpp
```
```cpp
box.setText(
```
```cpp
"i
 am at the top"
```
```cpp
);
```
```cpp
```
```cpp
box.exec();
```
```cpp
}
```
```cpp
//////////////////main.cpp///////////////////////
```
```cpp
MyTestB
 *g_pMyTestB = NULL;
```
```cpp
MyTestA
 *g_pMyTestA = NULL;
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[])
```
```cpp
{
```
```cpp
```
```cpp
QApplication
 app(argc, argv);
```
```cpp
```
```cpp
MyTestA
 a;
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>MyTestB
 *pB =
```
```cpp
new
```
```cpp
MyTestB(&a);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>
 pB->setObjectName(
```
```cpp
"MyTestB"
```
```cpp
);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>
 MyTestC *pC =
```
```cpp
new
```
```cpp
MyTestC(&a);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>pC->setObjectName(
```
```cpp
"MyTestC"
```
```cpp
);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>pC
 =
```
```cpp
new
```
```cpp
MyTestC(&a);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>pC->setObjectName(
```
```cpp
"MyTestC1"
```
```cpp
);</span>
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>QList<QObject*>
 list = a.findChildren<QObject*>();</span>
```
```cpp
```
```cpp
QList<QObject*>::iterator
 it;
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"All
 the son list: "
```
```cpp
<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
for
```
```cpp
(it
 = list.begin(); it != list.end() ; it++)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
qDebug()<<(*it)->objectName()<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"============================"
```
```cpp
<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>QList<MyTestC*>
 listC = a.findChildren<MyTestC*>();</span>
```
```cpp
```
```cpp
QList<MyTestC*>::iterator
 itC;
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"MyTestC
 list: "
```
```cpp
<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
for
```
```cpp
(itC
 = listC.begin(); itC != listC.end() ; itC++)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
qDebug()<<(*itC)->objectName()<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"============================"
```
```cpp
<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
<span
 style=
```
```cpp
"color:
 #ff0000;"
```
```cpp
>
 MyTestC *pC1 = a.findChild<MyTestC*>(
```
```cpp
"MyTestC1"
```
```cpp
);</span>
```
```cpp
```
```cpp
if
```
```cpp
(pC1)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
qDebug()<<
```
```cpp
"MyTestC1
 has been found"
```
```cpp
<<
```
```cpp
"\r\n"
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
MyTest
 win;
```
```cpp
```
```cpp
win.show();
```
```cpp
```
```cpp
return
```
```cpp
app.exec();
```
```cpp
}
```
```
然后销魂的转身一点，只见
![](http://pic002.cnblogs.com/images/2011/320623/2011082410021554.png)
**在Qt中，我们可以通过findChild,findChildren,qFindChild,qFindChildren,来遍历所有的子对象，同时我们可以通过指定类型，来得到所有的指定类型的子对象，当然也可以通过对象名字来索引。比如m_dlg.findChildren<QPushButton*>();通过这个函数我们可以轻松的遍历出对话框中所有的QPushButton子对象，这样对我们诸如换语言的操作提供了便利。换句话说，Qt的父对象也起到了一个容器的作用，我们有时可以利用这一点，把父对象作为一个容器处理。**
众人不禁赞道，知子莫如父啊。
无忌小友看在眼里，喜在心头。只见他又继续点击F5,弹出了一个对话框，
![](http://pic002.cnblogs.com/images/2011/320623/2011082411264738.png)
此对话框设置了Top属性，使之能够在所有其它应用程序窗口之上(this->setWindowFlags(windowFlags()|Qt::WindowStaysOnTopHint);)。然后又点击了PushButton，弹出了一子对话框。只见子对话框也自动继承了父窗口的属性，成为了Top window。
**在Qt中，我们只需在父窗口设置某些属性（比如Top，bottom），子窗口将自动获得这些属性，使开发者不用为了保持子窗口与父窗口的一致性，每个窗口一个一个去设置。提高了开发效率。**
众人皆叹，有父如此，子欲何求。老子干活，儿子享福啊。此时一股浓浓的父爱弥漫在武当大殿中。谁说父爱不顶半边天？此时的男道友们心潮澎湃，激动之余不禁拨通了"流言终结者"的制作组电话。
而反观另外一些道友，眼看她们引以为傲的优势，将被击得荡然无存。她们不甘心失败，一遍遍的看着代码，企图找出一丝破绽来。终于，一位女道友面带冷笑，指着代码说道，“无忌道友，此程序好似有内存泄露，不知对否”。众人心头一紧，Qt往日的无耻又浮现在了人们心头。
但见无忌小友手持羽扇，迎风而立，露出招牌般的正太式微笑，徐徐说道，“早知道友会有此一问。”接着从怀中取出一本写有”九阳真经“的古籍，翻了开来。只见一幅制作精美具有扶桑画风的彩图映入了众人的眼帘，图下面写着”伴我成长的女人们“。张无忌脸色一红，尴尬地咳嗽了一声，又继续翻到了下一页，只见上面写着，
```
```cpp
QObject::~QObject()
```
```cpp
{
```
```cpp
```
```cpp
.
 . . . . .
```
```cpp
```
```cpp
if
```
```cpp
(!d->children.isEmpty())
```
```cpp
```
```cpp
d->deleteChildren();
```
```cpp
```
```cpp
```
```cpp
.
 . . . . .
```
```cpp
}
```
```cpp
void
```
```cpp
QObjectPrivate::deleteChildren()
```
```cpp
{
```
```cpp
```
```cpp
const
```
```cpp
bool
```
```cpp
reallyWasDeleted
 = wasDeleted;
```
```cpp
```
```cpp
wasDeleted
 =
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
//
 delete children objects
```
```cpp
```
```cpp
//
 don't use qDeleteAll as the destructor of the child might
```
```cpp
```
```cpp
//
 delete siblings
```
```cpp
```
```cpp
for
```
```cpp
(
```
```cpp
int
```
```cpp
i
 = 0; i < children.count(); ++i) {
```
```cpp
```
```cpp
currentChildBeingDeleted
 = children.at(i);
```
```cpp
```
```cpp
children[i]
 = 0;
```
```cpp
```
```cpp
delete
```
```cpp
currentChildBeingDeleted;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
children.clear();
```
```cpp
```
```cpp
currentChildBeingDeleted
 = 0;
```
```cpp
```
```cpp
wasDeleted
 = reallyWasDeleted;
```
```cpp
}
```
```cpp
```
```
**在Qt中，当以QObject为父类的对象析构时，他会自动删除它所包含的所有子对象，实现了简单的垃圾回收机制，避免了内存泄露。所以开发时可以考虑，每个new出来的对象尽量设置父对象，这样即使未显示调用delete，只要保证父对象被析构，就能避免内存泄露。**
武当大殿沸腾了，观众们被Qt父子情深般的精彩表演深深震撼了。”学Qt，得永生“的口号响彻云霄（春哥泪流满面）。《流言终结者》主持人杰米和亚当宣布，人类史上最大的流言"父子不如X子亲"终结了。节目赞助商Intel鉴于此期节目在CCAV上99.99%的收视率，以4.44亿RMB天价强行插入了一条广告“Intel，给Qt一颗奔腾的芯”。
而Qt的代言人无忌小友，获得了道教界一年一度以道家镇教之宝命名的，最高荣誉“八卦”奖。当从道教最高精神领袖“张三丰”手中接过雕有“冠希”前辈手拿camera的小金像，正要发表获奖感言的时侯，一道剑光闪过。
正所谓伯乐不常有，但搅屎棍却常在。
只见人见人怕，鬼见鬼愁，考试只给59分的灭绝师太，手握倚天剑，刷刷的修改了张无忌的代码。
```
```cpp
class
```
```cpp
MyTestA
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
};
```
```cpp
class
```
```cpp
MyTestB
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestB(QObject
 *parent):QObject(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
extern
```
```cpp
MyTestB
 *g_pMyTestB;
```
```cpp
extern
```
```cpp
MyTestA
 *g_pMyTestA;
```
```cpp
class
```
```cpp
MyTestC
 :
```
```cpp
public
```
```cpp
QThread
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestC():QThread(NULL)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
void
```
```cpp
run()
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
exec();
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
MyTestB
 *g_pMyTestB = NULL;
```
```cpp
MyTestA
 *g_pMyTestA = NULL;
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[])
```
```cpp
{
```
```cpp
```
```cpp
QApplication
 app(argc, argv);
```
```cpp
```
```cpp
MyTestA
 a;
```
```cpp
```
```cpp
MyTestB
 b(&a);
```
```cpp
```
```cpp
MyTestC
 c;
```
```cpp
```
```cpp
c.start();
```
```cpp
```
```cpp
b.moveToThread(&c);
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
app.exec();
```
```cpp
}
```
```
执行此段代码后，众人皆惊。只见output窗口输出了“QObject::moveToThread: Cannot move objects with a parent”。
灭绝师太斜眼冷笑道：“黄口小儿，安能善言人伦乎？ “
**由此可见Qt中，子对象不能脱离父对象，单独切换到与父对象不同的线程中。**
此时的张无忌面色惨白。但灭绝师太誓将张无忌搞臭到底，以不负灭绝的美名。只见她又修改了一段代码，
```cpp
class
```
```cpp
MyTestA
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
};
```
```cpp
class
```
```cpp
MyTestB
 :
```
```cpp
public
```
```cpp
QObject
```
```cpp
{
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestB(QObject
 *parent):QObject(parent)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
extern
```
```cpp
MyTestB
 *g_pMyTestB;
```
```cpp
extern
```
```cpp
MyTestA
 *g_pMyTestA;
```
```cpp
class
```
```cpp
MyTestC
 :
```
```cpp
public
```
```cpp
QThread
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MyTestC():QThread(NULL)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
void
```
```cpp
run()
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
exec();
```
```cpp
```
```cpp
}
```
```cpp
};
```
```cpp
MyTestB
 *g_pMyTestB = NULL;
```
```cpp
MyTestA
 *g_pMyTestA = NULL;
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[])
```
```cpp
{
```
```cpp
```
```cpp
QApplication
 app(argc, argv);
```
```cpp
```
```cpp
MyTestA
 *pA =
```
```cpp
new
```
```cpp
MyTestA;
```
```cpp
```
```cpp
MyTestB
 *pB =
```
```cpp
new
```
```cpp
MyTestB(pA);
```
```cpp
```
```cpp
delete
```
```cpp
pA;
```
```cpp
```
```cpp
delete
```
```cpp
pB;
```
```cpp
```
```cpp
```
```cpp
}
```
只见程序蹦出了警告对话框，
![](http://pic002.cnblogs.com/images/2011/320623/2011082418310555.png)
程序直接崩溃了。与之同时崩溃的，还有众男道友的心。
而张无忌啪跌坐在地上，万念俱灰。与霆锋哥相拥痛哭，为什么上一辈的悲剧，又在我们身上重演。
**对于Qt子对象而言，不能在父对象删除后，再删除自己。因为父对象析构时，会删除所有的子对象，此时子对象再删除，会引起二次析构。**
**所以如果子对象要切换到另一个线程或者避免被父对象删除，则需要调用setParent(NULL),解除父子关系。**
灭绝师太仰天长笑道“Qt名为父子，实乃黑帮。”
太史公评曰：“一入Q门深似海，从此萧郎是路人”。
瑟瑟风中，只见张无忌将自己多年的呕心力作<<我与Qt之间不得不说的故事>>付之一炬，飘然而去。从此之后，弃码从武，苦练九阳真经，终成一代大侠，名满江湖，这当然都是后话。
欲知后事如何，请听下回分解。
