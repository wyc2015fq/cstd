# 编译成release版本与debug版本的程序有何执行上的区别？ - xqhrs232的专栏 - CSDN博客
2014年01月24日 17:31:32[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：733
个人分类：[C/C++/VC++/VS](https://blog.csdn.net/xqhrs232/article/category/906934)
原文地址::[http://blog.csdn.net/lingxiu0613/article/details/7924755](http://blog.csdn.net/lingxiu0613/article/details/7924755)
相关网帖
1、[Debug 和 Release 编译方式的本质区别](http://blog.csdn.net/lingxiu0613/article/details/7924730)----[http://blog.csdn.net/lingxiu0613/article/details/7924730](http://blog.csdn.net/lingxiu0613/article/details/7924730)
2、[Debug调试运行正常，但在Release模式下退出程序时报错](http://blog.csdn.net/lingxiu0613/article/details/7924722)----[http://blog.csdn.net/lingxiu0613/article/details/7924722](http://blog.csdn.net/lingxiu0613/article/details/7924722)
1.   变量。   
    大家都知道，debug跟release在初始化变量时所做的操作是不同的，debug是将每个字节位都赋成0xcc(注1)，而release的赋值近似于随机(我想是直接从内存中分配的，没有初始化过)。这样就明确了，如果你的程序中的某个变量没被初始化就被引用，就很有可能出现异常：用作控制变量将导致流程导向不一致；用作数组下标将会使程序崩溃；更加可能是造成其他变量的不准确而引起其他的错误。所以在声明变量后马上对其初始化一个默认的值是最简单有效的办法，否则项目大了你找都没地方找。代码存在错误在debug方式下可能会忽略而不被察觉到，如debug方式下数组越界也大多不会出错，在release中就暴露出来了，这个找起来就比较难了:(
   还是自己多加注意吧   
  2.   自定义消息的消息参数。   
    MFC为我们提供了很好的消息机制，更增加了自定义消息，好处我就不用多说了。这也存在debug跟release的问题吗？答案是肯定的。在自定义消息的函数体声明时，时常会看到这样的写法：afx_msg   LRESULT   OnMessageOwn();   Debug情况下一般不会有任何问题，而当你在Release下且多线程或进程间使用了消息传递时就会导致无效句柄之类的错误。导致这个错误直接原因是消息体的参数没有添加，即应该写成：afx_msg
   LRESULT   OnMessageOwn(WPARAM   wparam,   LPARAM   lparam);   (注2)   
  3.   release模式下不出错，但debug模式下报错。   
    这种情况下大多也是因为代码书写不正确引起的，查看MFC的源码，可以发现好多ASSERT的语句(断言)，这个宏只是在debug模式下才有效，那么就清楚了，release版不报错是忽略了错误而不是没有错误，这可能存在很大的隐患，因为是Debug模式下，比较方便调试，好好的检查自己的代码，再此就不多说了。
   
  4.   ASSERT,   VERIFY,   TRACE..........调试宏   
  这种情况很容易解释。举个例子：请在VC下输入ASSERT然后选中按F12跳到宏定义的地方，这里你就能够发现Debug中ASSERT要执行AfxAssertFailedLine，而Release下的宏定义却为"#define   ASSERT(f)   ((void)0)"。所以注意在这些调试宏的语句不要用程序相关变量如i++写操作的语句。VERIFY是个例外，"#define
   VERIFY(f)   ((void)(f))"，即执行，这里的作用就不多追究了，有兴趣可自己研究:)。   
  总结：   
    Debug与Release不同的问题在刚开始编写代码时会经常发生，99%是因为你的代码书写错误而导致的，所以不要动不动就说系统问题或编译器问题，努力找找自己的原因才是根本。我从前就常常遇到这情况，经历过一次次的教训后我就开始注意了，现在我所写过的代码我已经好久没遇到这种问题了。下面是几个避免的方面，即使没有这种问题也应注意一下：
   
  1.   注意变量的初始化，尤其是指针变量，数组变量的初始化(很大的情况下另作考虑了)。   
  2.   自定义消息及其他声明的标准写法   
  3.   使用调试宏时使用后最好注释掉   
  4.   尽量使用try   -   catch(...)   
  5.   尽量使用模块，不但表达清楚而且方便调试。   
  注1：   
  afc(afc)   网友提供：   
    debug版初始化成0xcc是因为0xcc在x86下是一条int   3单步中断指令，这样程序如果跑飞了遇到0xcc就会停下来，这和单片机编程时一般将没用的代码空间填入jmp   0000语句是一样地   
  注2：   
    不知大家有没有遇到过这种情况，具体原因我也不太清楚，是不是调用时按着默认的参数多分配了WPARAM+LPARAM的空间而破坏了应用程序的内存空间?还请高手来补充。   
  NightWolf   网友提供：我遇见过，好像是在函数调用的时候参数入栈的问题。因为MFC的消息使用宏写的，所以如果定义了OnMessage()的函数，编译能够通过，但是调用一次后，堆栈指针发生了偏移。然后就。。。 
//=====================================================================================================
1》2014--1--24  今天就遇到了下面的问题
volatile 型变量：volatile 告诉编译器该变量可能被程序之外的未知方式修改（如系统、其他进程和线程）。优化程序为了使程序性能提高，常把一些变量放在寄存器中（类似于
 register 关键字），而其他进程只能对该变量所在的内存进行修改，而寄存器中的值没变。如果你的程序是多线程的，或者你发现某个变量的值与预期的不符而你确信已正确的设置了，则很可能遇到这样的问题。这种错误有时会表现为程序在最快优化出错而最小优化正常。把你认为可疑的变量加上 volatile 试试。

