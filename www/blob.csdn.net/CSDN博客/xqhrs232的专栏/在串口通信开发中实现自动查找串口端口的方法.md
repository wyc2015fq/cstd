# 在串口通信开发中实现自动查找串口端口的方法 - xqhrs232的专栏 - CSDN博客
2017年07月06日 11:25:19[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：435
原文地址::[http://blog.chinaunix.net/uid-20672257-id-2973926.html](http://blog.chinaunix.net/uid-20672257-id-2973926.html)
相关文章
1、[串口编程-枚举遍历串口、获取PC所有串口名称、遍历注册表项、RegEnumValue用法](http://www.cnblogs.com/code7854/p/4287650.html)----[http://www.cnblogs.com/code7854/p/4287650.html](http://www.cnblogs.com/code7854/p/4287650.html)

开发工具：visual studio 2010
本机可用串口信息如下：
![](http://blog.chinaunix.net/attachment/201110/18/20672257_1318908059JlKG.jpg)
1 、查询注册表 
查询注册表的方法是比较常见的方法，通过查看“ HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM ”项来获取串口信息。该方法就是使用编程方法读取注册表内信息，相当于用户通过在运行框内输入 ”regedit” （或 regedit32 ）直接打开注册表。源代码如下：
 int i = 0; 
 CHAR Name[25]; 
 UCHAR szPortName[25]; 
 LONG Status; 
 DWORD dwIndex = 0; 
 DWORD dwName; 
 DWORD dwSizeofPortName; 
 DWORD Type;
 HKEY hKey; 
 CString   strSerialList[256];  // 临时定义 256 个字符串组，因为系统最多也就 256 个 
 LPCTSTR data_Set="HARDWARE\\DEVICEMAP\\SERIALCOMM\\";
 dwName = sizeof(Name); 
 dwSizeofPortName = sizeof(szPortName);
 //long ret0 = (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKey)); 
 long ret0 = RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKey); //打开一个制定的注册表键,成功返回ERROR_SUCCESS即“0”值
 if(ret0 == ERROR_SUCCESS) 
 {
  do 
  { 
   Status = RegEnumValue(hKey, dwIndex++, Name, &dwName, NULL, &Type, szPortName, &dwSizeofPortName);//读取键值 
   if((Status == ERROR_SUCCESS)||(Status == ERROR_MORE_DATA)) 
   { 
    strSerialList[i] = CString(szPortName);       // 串口字符串保存 
    printf("serial:%s\n",strSerialList[i]);
    i++;// 串口计数 
   } 
   //每读取一次dwName和dwSizeofPortName都会被修改 
  //注意一定要重置,否则会出现很离奇的错误,本人就试过因没有重置,出现先插入串口号大的（如COM4）,再插入串口号小的（如COM3），此时虽能发现两个串口，但都是同一串口号（COM4）的问题，同时也读不了COM大于10以上的串口 
   dwName = sizeof(Name); 
   dwSizeofPortName = sizeof(szPortName); 
  } while((Status == ERROR_SUCCESS)||(Status == ERROR_MORE_DATA)); 
  RegCloseKey(hKey); 
 }
调试输出信息如下：
![](http://blog.chinaunix.net/attachment/201110/18/20672257_1318908586EueF.jpg)
该方法在 1ms内即可完成查找；同时也可解决 usb 转串口设备的问题，比较实用，唯一缺点是，如果用户在装某些软硬件时在注册表中注册了虚拟串口之类的，用此法枚举得到的该类串口实际上是不能当串口用的。 
2、使用 SetupAPI 函数集的方法
此种方法是最简单的方法，之所以简单是因为已经有人将复杂的代码封装起来了，只需像傻子一样调用就可以完成工作了，具体的说明请看 [http://www.codeguru.com/Cpp/W-P/system/hardwareinformation/article.php/c5721/](http://www.codeguru.com/Cpp/W-P/system/hardwareinformation/article.php/c5721/) ，使用该方法要在你的程序中，添加“
 EnumSerial.cpp ”和“ EnumSerial.h ”两个文件，并且将 Setupapi.lib 包含进你的工程，方法在项目属性－配置属性－连接器－输入－附加依赖项中添加setupapi.lib，然后在EnumSerial.cpp中添加包含"setupapi.h" ，你的应用程序添加包含EnumSerial.h头文件就行了，
下面给出调用该方法的例子代码：
      int m_nSerialPortNum(0);// 串口计数 
       CString          strSerialList[256];  // 临时定义 256 个字符串组 
       CArray<SSerInfo,SSerInfo&> asi; 
       EnumSerialPorts(asi,TRUE);// 参数为 TRUE 时枚举当前可以打开的串口， 
// 否则枚举所有串口 
       m_nSerialPortNum = asi.GetSize(); 
       for (int i=0; i<asi.GetSize(); i++) 
       { 
              CString str = asi[i].strFriendlyName; 
     printf("serialinfo:%s\n",str);
       }
调试输出信息如下：
![](http://blog.chinaunix.net/attachment/201110/18/20672257_1318907643i2bi.jpg)
该方法查找一个串口就要 15ms 左右，但可以看到该方法获取的串口完完全全就是硬件设备管理器中的串口。
3、使用 EnumPort 方法
该方法调用 EnumPort （） API 函数，该函数本身就是枚举电脑端口用的，它枚举的并非只有串口，所以必须对其所得串口进行分析选择，使用这种方法要在源码中添加#include <winspool.h>头文件
以下是源代码：
       int i=0;
       int m_nSerialPortNum(0);// 串口计数 
       CString          strSerialList[256];  // 临时定义 256 个字符串组 
       LPBYTE pBite  = NULL; 
       DWORD pcbNeeded = 0;  // bytes received or required 
       DWORD pcReturned = 0;  // number of ports received 
       m_nSerialPortNum = 0;
       // 获取端口信息，能得到端口信息的大小 pcbNeeded 
       EnumPorts(NULL, 2, pBite, 0, &pcbNeeded, &pcReturned); 
       pBite = new BYTE[pcbNeeded]; 
       // 枚举端口，能得到端口的具体信息 pBite 以及端口的的个数 pcReturned
       EnumPorts(NULL, 2, pBite, pcbNeeded, &pcbNeeded, &pcReturned); 
       PORT_INFO_2 *pPort; 
       pPort = (PORT_INFO_2*)pBite; 
       for ( i = 0; i < pcReturned; i++) 
       { 
              CString str = pPort[i].pPortName; 
     printf("hardwareinfo:%s\n",str);
              // 串口信息的具体确定 
              if (str.Left(3) == "COM") 
              {                   
                     strSerialList[m_nSerialPortNum] = str.Left(strlen(str) - 1); 
                     //CString temp = str.Right(strlen(str) - 3);// 下面两行注释获取串口序号用 
                     //m_nSerialPortNo[m_nSerialPortNum] = atoi(temp.Left(strlen(temp) - 1)); 
      printf("serialinfo:%s\n",strSerialList[m_nSerialPortNum]);
                     m_nSerialPortNum++;       
              } 
       }
调试输出信息如下：
![](http://blog.chinaunix.net/attachment/201110/18/20672257_1318908203446Y.jpg)
可以看出该方法除了串口，还可以枚举所有的并口和打印机等接口，而且能找到虚拟串口（这些串口有些未使用时，在注册表和硬件设备管理器中是不能取得的）。但是该方法稍微耗时些，大概需要几十 ms ，主要问题是该方法有些 usb 串口并不能查到，系统中没有的串口它都例出来了，所以该方法并不可靠。
4、依次打开串口的方法
该方法就是中规中矩的依次打开串口，看打开是否成功来判断串口的有无，一般查找一个串口就要 15ms 左右
以上方法个人觉得可取的是第一、二种方法。最可靠的是第二种方法。

