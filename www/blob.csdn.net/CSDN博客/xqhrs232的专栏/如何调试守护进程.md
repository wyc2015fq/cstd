# 如何调试守护进程 - xqhrs232的专栏 - CSDN博客
2012年04月23日 22:49:30[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：919标签：[fp																[终端																[file																[工作																[im																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=im&t=blog)](https://so.csdn.net/so/search/s.do?q=工作&t=blog)](https://so.csdn.net/so/search/s.do?q=file&t=blog)](https://so.csdn.net/so/search/s.do?q=终端&t=blog)](https://so.csdn.net/so/search/s.do?q=fp&t=blog)
个人分类：[Linux/Ubuntu/Fedora](https://blog.csdn.net/xqhrs232/article/category/906931)
原文地址::[http://sealbird.iteye.com/blog/868220](http://sealbird.iteye.com/blog/868220)
**如何调试守护进程**
我写了个守护进程,可是如何用gdb 调试呢，我试了attach pid 方法 可是他不能让程序停住呀。 
如何调试守护进程 
**ctrl+c就停住了 **
如何调试守护进程 
realy? 
如何调试守护进程 
**守护进程通常都要通过一个daemon_init()类似的函数将进程转换为守护进程,你可以先将这个转换注释，将其作为一个普通进程调试，调试好了之后再转换为守护进程**。
如何调试守护进程 
不错当前我就是这么做的  可是 你不知道。。 守护进程有些其他的特性 如 程序中用了大量的 字符操作 而且屏幕输出过多的话 就造成了溢出 （一开始没有想把它作为守护进程）  这我就想知道 为什么 守护进程中 的标准输出会造成溢出（大量的）他为什么会把 要输出到一个不存在的stdout设备上的信息写到了内存里地址里面。。
如何调试守护进程 
高手们 怎么调呀  哭了 
如何调试守护进程 
呀，这就哭了？ 
**如何调试守护进程 正在运行的守护进程，可以用 gdb 进程程序名 进程程序pid 来调试 如果在gdb下运行调试子进程，在gdb 下运行命令，set follow-fork-mode child 。 **
如何调试守护进程 
**我太谢谢你的回帖了 **
C++代码 ![复制代码](http://sealbird.iteye.com/images/icon_copy.gif)![收藏代码](http://sealbird.iteye.com/images/icon_star.png)![](http://sealbird.iteye.com/images/spinner.gif)
-  #include <unistd.h> 
-     #include <signal.h> 
-     #include <sys/param.h> 
-     #include <sys/types.h> 
-     #include <sys/stat.h> 
- 
-    #include <stdio.h> 
-    #include <time.h> 
- void init_daemon(void);//守护进程初始化函数
- main(){   
- FILE *fp;   
- time_t t;   
-     init_daemon();//初始化为Daemon 
- while(1)//每隔一分钟向test.log报告运行状态
-     {   
-         sleep(2);//睡眠一分钟 
- if((fp=fopen("test.log","a"))>=0){   
-             t=time(0);   
-             fprintf(fp,"Im here at %sn",asctime(localtime(&t)) );   
-             fclose(fp);   
-         }   
- 
-   }   
- 
- }   
- 
- void init_daemon(void)   
-     {   
- int pid;   
- int i;   
- if(pid=fork())   
-             exit(0);//是父进程，结束父进程 
- elseif(pid<0)   
-             exit(1);//fork失败，退出//是第一子进程，后台继续执行 
-         setsid();//第一子进程成为新的会话组长和进程组长//并与控制终端分离 
- if(pid=fork())   
-             exit(0);//是第一子进程，结束第一子进程 
- elseif(pid<0)   
-             exit(1);//fork失败，退出//是第二子进程，继续//第二子进程不再是会话组长
- for(i=0;i<NOFILE;++i)//关闭打开的文件描述符
-             close(i);   
-         chdir("/cygdrive/e/tmp");//改变工作目录到/tmpumask(0);//重设文件创建掩模
- return;   
-     }    
- 
- 
- //nIm here at Tue Jan 11 12:21:06 2011
 #include <unistd.h>
	#include <signal.h>
	#include <sys/param.h>
	#include <sys/types.h>
	#include <sys/stat.h>
   #include <stdio.h>
   #include <time.h>
void init_daemon(void);//守护进程初始化函数
main(){
	FILE *fp;
	time_t t;
	init_daemon();//初始化为Daemon
	while(1)//每隔一分钟向test.log报告运行状态
	{
		sleep(2);//睡眠一分钟
		if((fp=fopen("test.log","a"))>=0){
			t=time(0);
			fprintf(fp,"Im here at %sn",asctime(localtime(&t)) );
			fclose(fp);
		}
	
  }
}
void init_daemon(void)
	{
		int pid;
		int i;
		if(pid=fork())
			exit(0);//是父进程，结束父进程
		else if(pid<0)
			exit(1);//fork失败，退出//是第一子进程，后台继续执行
		setsid();//第一子进程成为新的会话组长和进程组长//并与控制终端分离
		if(pid=fork())
			exit(0);//是第一子进程，结束第一子进程
		else if(pid<0)
			exit(1);//fork失败，退出//是第二子进程，继续//第二子进程不再是会话组长
		for(i=0;i<NOFILE;++i)//关闭打开的文件描述符
			close(i);
		chdir("/cygdrive/e/tmp");//改变工作目录到/tmpumask(0);//重设文件创建掩模
		return;
	} 
	//nIm here at Tue Jan 11 12:21:06 2011
- [testforkone.rar](http://dl.iteye.com/topics/download/46d7aa86-7ab7-38de-b3f8-0af0c49fe501) (748 Bytes)
- 下载次数: 0 

