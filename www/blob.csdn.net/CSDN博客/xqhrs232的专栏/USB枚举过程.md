# USB枚举过程 - xqhrs232的专栏 - CSDN博客
2016年10月02日 15:59:55[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：218
个人分类：[各种电子元器件/硬件技术](https://blog.csdn.net/xqhrs232/article/category/6300755)
原文地址::[http://blog.csdn.net/myarrow/article/details/8270029](http://blog.csdn.net/myarrow/article/details/8270029)
相关文章
1、[USB设备被识别流程](http://blog.csdn.net/myarrow/article/details/8286876)----[http://blog.csdn.net/myarrow/article/details/8286876](http://blog.csdn.net/myarrow/article/details/8286876)
## 1. 枚举是什么?
       枚举就是从设备读取一些信息，知道设备是什么样的设备，如何进行通信，这样主机就可以根据这些信息来加载合适的驱动程序。调试USB设备，很重要的一点就是USB的枚举过程，只要枚举成功了，那么就已经成功大半了。
       USB架构中， hub负责检测设备的连接和断开，利用其中断IN端点(Interrupt IN Endpoint)来向主机（Host）报告。在系统启动时，主机轮询它的根hub（RootHub）的状态看是否有设备（包括子hub和子hub上的设备）连接。USB总线拓扑结构见下图（最顶端为主机的RootHub）：
![](https://img-my.csdn.net/uploads/201212/12/1355300555_4018.PNG)
**USB总线拓扑结构**
        一旦获悉有新设备连接上来，主机就会发送一系列的请求(Resqusts)给设备所挂载到的hub，再由hub建立起一条连接主机（Host）和设备（Device）之间的通信通道。然后主机以控制传输(Control Transfer)的方式，通过端点0(Endpoint 0)对设备发送各种请求，设备收到主机发来的请求后回复相应的信息，进行枚举（Enumerate）操作。所有的USB设备必须支持标准请求（StandardRequests），控制传输方式（ControlTransfer）和端点0（Endpoint
 0）。
       在讲解枚举之前，先大概说说USB的一种传输模式——控制传输。这种传输在USB中是非常重要的，它要保证数据的正确性，在设备的枚举过程中都是使用控制传输的。控制传输分为三个阶段：①建立阶段。②数据阶段。③确认阶段。
        建立（setup）阶段：都是由USB主机发起，它是一个setup数据包，里面包含一些数据请求的命令以及一些数据。如果建立阶段是输入请求，那么数据阶段就要输入数据；如果建立阶段是输出请求，那么数据阶段就要输出数据。如果在数据阶段，即便不需要传送数据，也要发一个0长度的数据包。数据阶段过后就是确认阶段。确认阶段刚好跟数据阶段相反，如果是输入请求，则它是一个输出数据包；如果是输出请求，则它是一个输入数据包。确认阶段用来确认数据的正确传输。
### 1.1 通信传输流
![](https://img-my.csdn.net/uploads/201212/13/1355359835_4592.PNG)
### 1.2 设备状态图
![](https://img-my.csdn.net/uploads/201212/13/1355359971_7246.PNG)
![](https://img-my.csdn.net/uploads/201212/13/1355360099_3789.PNG)
###  1.3 状态详解
**       1) 连接(Attached)**       设备可以连接到USB或者从USB上拔出.USB设备从总线上拨出后的状态在规范没定义,只说明一旦USB连到总线要求的操作以及属性.
**       2) 上电(Powered)**       USB设备的电源可来自外部电源，也可从USB接口的集线器而来。电源来自外部电源的USB设备被称作自给电源式的(self-powered)。尽管自给电源式的USB设备可能在连接上USB接口以前可能已经带电，但它们直到连线上USB接口后才能被看作是加电状态(Powered state)。而这时候VBUS已经对设备产生作用了.
一个设备可能有既支持自给电源的，同时也支持总线电源式的配置。有一些支持其中的一种，而另一些设备配置可能只有在自给电源下才能被使用。设备对电源支持的能力是通过配置描述表(configuration descriptor)来反映的。当前的电源供给形式被作为设备状态的一部分被反映出来。设备可在任何时候改变它们的供电来源，比如说：从自给式向总线式改变，如果一个配置同时支持两种模式，那此状态的最大电源需求就是指设备在两种模式下从VBUS上获取电能的最大值。设备必须以此最大电源作为参照，而究竟处于何状态是不考虑的。如果有一配置仅支持一种电源模式，那么电源模式的改变会使得设备失去当前配置与地址，返回加电状态。如果一个设备是自给电源式，并且当前配置需要大于100mA电流，那么如果此设备转到了总线电源式，它必须返回地址状态(Address
 state)。自给电源式集线器使用VBUS来为集线控制器(Hub controller)提供电源，因而可以仍然保持配置状态(Configured state)，尽管自给电源停止提供电源。
**      3)默认状态(Default)**
      设备上电后,它不响应任何总线处理,直到总线接收到复位信号为止.接收到复位信号后,用默认的地址可以对设备寻址.
       当用复位过程完成后,USB设备在正确的速度下操作(即低速/全速/高速).低速和全速的数据选择由设备的终端电阻决定.能进行高速操作的设备决定它是否在复位的过程的一部分执行高速操作.
        能进行高速操作的设备在全速的电气环境中操作时,必须能以全速成功复位.设备成功复位后,设备必须成功响应设备和配置描述符请求,并且返回适当的信息.当在全速下工作时,设备可能或者不能支持预定义的功能.
**       4) 地址(Address) **       所有的USB设备在加电复位以后都使用缺省地址。每一设备在连接或复位后由主机分配一个唯一的地址。当USB设备处于挂起状态时，它保持这个地址不变。
        USB设备只对缺省通道(Pipe)请求发生响应，而不管设备是否已经被分配地址或在使用缺省地址。
**        5) 配置状态( Configured )**        在USB设备正常工作以前，设备必须被正确配置。从设备的角度来看，配置包括一个将非零值写入设备配置寄存器的操作。配置一个设备或改变一个可变的设备设置会使得与这个相关接口的终端结点的所有的状态与配置值被设成缺省值。这包括将正在使用(date toggle)的结点(end point)的 (Date toggle)被设置成DATA0。
**        6) 挂起状态**        为节省电源，USB设备在探测不到总线传输时自动进入中止状态。当中止时，USB设备保持本身的内部状态，包括它的地址及配置。
        所有的设备在一段特定的时间内探测不到总线活动时必须进入中止态。不管设备是被分配了非缺省的地址或者是被配置了，已经连接的设备必须在任何加电的时刻随时准备中止。总线活动的中止可能是因为主机本身进入了中止状态。另外，USB设备必须在所连接的集线器端口失效时进入中止态。这就是所指的选择性中止(Selective suspend)。
       USB设备在总线活动来到时结束中止态。USB设备也可以远程唤醒的电流信号来请求主机退出中止态或选择性中止态。具体设备具有的远程唤醒的能力是可选的，也就是说，如果一个设备有远程唤醒的能力，此设备必须能让主机控制此能力的有效与否。当设备复位时，远程唤醒能力必须被禁止。
## 2. 枚举步骤
       USB协议定义了设备的6种状态，仅在枚举过程中，设备就经历了4个状态的迁移：**上电状态(Powered)，默认状态(Default)，地址状态(Address)和配置状态(Configured)**（其他两种是连接状态和挂起状态（Suspend））。
### 2.1 用户把USB设备插入USB端口或给系统启动时设备上电
      这里指的USB端口指的是主机下的根hub或主机下行端口上的hub端口。Hub给端口供电，连接着的设备处于上电状态。此时，USB设备处于加电状态，它所连接的端口是无效的。
### 2.2 Hub监测它各个端口数据线上(D+/D-)的电压
在hub端，数据线D+和D-都有一个阻值在14.25k到24.8k的下拉电阻Rpd，而在设备端，D+（全速，高速）和D-（低速）上有一个1.5k的上拉电阻Rpu。当设备插入到hub端口时，有上拉电阻的一根数据线被拉高到幅值的90%的电压（大致是3V）。hub检测到它的一根数据线是高电平，就认为是有设备插入，并能根据是D+还是D-被拉高来判断到底是什么设备（全速/低速）插入端口（全速、高速设备的区分在我将来的文章中描述）。如下图。
![](https://img-my.csdn.net/uploads/201212/12/1355301403_8272.PNG)
**    USB全速/高速设备上电连接**
       检测到设备后，hub继续给设备供电，但并不急于与设备进行USB传输。
USB接口定义如下图所示：
![](https://img-my.csdn.net/uploads/201212/25/1356406281_2638.jpg)
### 2.3 Host了解连接的设备
      每个hub利用它自己的中断端点向主机报告它的各个端口的状态（对于这个过程，设备是看不到的，也不必关心），报告的内容只是hub端口的设备连接／断开的事件。如果有连接／断开事件发生，那么host会发送一个 Get_Port_Status请求(request)给hub以了解此次状态改变的确切含义。Get_Port_Status等请求属于所有hub都要求支持的hub类标准请求（standard
 hub-class requests）。
### 2.4 Hub检测所插入的设备是高速还是低速设备
    hub通过检测USB总线空闲(Idle)时差分线的高低电压来判断所连接设备的速度类型，当host发来Get_Port_Status请求时，hub就可以将此设备的速度类型信息回复给host。USB 2.0规范要求速度检测要先于复位（Reset）操作。
### 2.5 hub复位设备
      主机一旦得知新设备已连上以后，它至少等待100ms以使得插入操作的完成以及设备电源稳定工作。然后主机控制器就向hub发出一个 Set_Port_Feature请求让hub复位其管理的端口(刚才设备插上的端口)。hub通过驱动数据线到复位状态(D+和D-全为低电平 )，并持续至少10ms。当然，hub不会把这样的复位信号发送给其他已有设备连接的端口，所以其他连在该hub上的设备自然看不到复位信号，不受影响。
### 2.6 Host检测所连接的全速设备是否是支持高速模式
       因为根据USB 2.0协议，高速（High Speed）设备在初始时是默认全速（Full Speed ）状态运行，所以对于一个支持USB 2.0的高速hub，当它发现它的端口连接的是一个全速设备时，会进行高速检测，看看目前这个设备是否还支持高速传输，如果是，那就切到高速信号模式，否则就一直在全速状态下工作。
       同样的，从设备的角度来看，如果是一个高速设备，在刚连接bub或上电时只能用全速信号模式运行（根据USB 2.0协议，高速设备必须向下兼容USB 1.1的全速模式）。随后hub会进行高速检测，之后这个设备才会切换到高速模式下工作。假如所连接的hub不支持USB 2.0，即不是高速hub，不能进行高速检测，设备将一直以全速工作。
### 2.7 Hub建立设备和主机之间的信息通道
   主机不停地向hub发送Get_Port_Status请求，以查询设备是否复位成功。Hub返回的报告信息中有专门的一位用来标志设备的复位状态。
       当hub撤销了复位信号，设备就处于默认／空闲状态（Default state），准备接收主机发来的请求。设备和主机之间的通信通过控制传输，默认地址0，端点号0进行。此时，设备能从总线上得到的最大电流是100mA。(**所有的USB设备在总线复位后其地址都为0，这样主机就可以跟那些刚刚插入的设备通过地址0通信**。)
### 2.8 主机发送Get_Descriptor请求获取默认管道的最大包长度
       默认管道（Default Pipe）在设备一端来看就是端点0。主机此时发送的请求是默认地址0，端点0，虽然所有未分配地址的设备都是通过地址0来获取主机发来的请求，但由于枚举过程不是多个设备并行处理，而是一次枚举一个设备的方式进行，所以不会发生多个设备同时响应主机发来的请求。
      设备描述符的第8字节代表设备端点0的最大包大小。虽然说设备所返回的设备描述符（Device Descriptor）长度只有18字节，但系统也不在乎，此时，描述符的长度信息对它来说是最重要的，其他的瞄一眼就过了。当完成第一次的控制传输后，也就是完成控制传输的状态阶段，系统会要求hub对设备进行再一次的复位操作（USB规范里面可没这要求）。再次复位的目的是使设备进入一个确定的状态。
### 2.9 主机给设备分配一个地址
       主机控制器通过Set_Address请求向设备分配一个唯一的地址。在完成这次传输之后，设备进入地址状态（Address state），之后就启用新地址继续与主机通信。这个地址对于设备来说是终生制的，设备在，地址在；设备消失（被拔出，复位，系统重启），地址被收回。同一个设备当再次被枚举后得到的地址不一定是上次那个了。
### 2.10 主机获取设备的信息
       主机发送 Get_Descriptor请求到新地址读取设备描述符，这次主机发送Get_Descriptor请求可算是诚心，它会认真解析设备描述符的内容。设备描述符内信息包括端点0的最大包长度，设备所支持的配置（Configuration）个数，设备类型，VID（Vendor ID，由USB-IF分配）， PID（Product ID，由厂商自己定制）等信息。Get_Descriptor请求(Device
 type)和设备描述符（已抹去VID，PID等信息）见下图：
![](https://img-my.csdn.net/uploads/201212/12/1355303700_3000.PNG)
**标准Get_Descriptor请求**
![](https://img-my.csdn.net/uploads/201212/12/1355303825_8002.PNG)
** 设备描述符（Device Descriptor）**
      之后主机发送Get_Descriptor请求，读取配置描述符（Configuration Descriptor），字符串等，逐一了解设备更详细的信息。事实上，对于配置描述符的标准请求中，有时wLength一项会大于实际配置描述符的长度（9字节），比如255。这样的效果便是：主机发送了一个Get_Descriptor_Configuration 的请求，设备会把接口描述符，端点描述符等后续描述符一并回给主机，主机则根据描述符头部的标志判断送上来的具体是何种描述符。
     接下来，主机就会获取配置描述符。配置描述符总共为9字节。主机在获取到配置描述符后，根据里面的配置集合总长度，再获取配置集合。配置集合包括配置描述符，接口描述符，端点描符等等。
     如果有字符串描述符的话，还要获取字符串描述符。另外HID设备还有HID描述符等。
### 2.11  主机给设备挂载驱动（复合设备除外）
      主机通过解析描述符后对设备有了足够的了解，会选择一个最合适的驱动给设备。  然后tell the world（announce_device）说明设备已经找到了，最后调用设备模型提供的接口device_add将设备添加到 usb 总线的设备列表里，然后 usb总线会遍历驱动列表里的每个驱动，调用自己的 match（usb_device_match） 函数看它们和你的设备或接口是否匹配，匹配的话调用device_bind_driver函数，现在就将控制权交到设备驱动了。   
     对于复合设备，通常应该是不同的接口（Interface）配置给不同的驱动，因此，需要等到当设备被配置并把接口使能后才可以把驱动挂载上去。
     设备-配置-接口-端点关系见下图：
![](https://img-my.csdn.net/uploads/201212/12/1355305100_6757.PNG)
**USB 设备-配置-接口-端点关系**
    实际情况没有上述关系复杂。一般来说，一个设备就一个配置，一个接口，如果设备是多功能符合设备，则有多个接口。端点一般都有好几个，比如Mass Storage设备一般就有两个端点（控制端点0除外）。
### 2.12 设备驱动选择一个配置
     驱动（注意，这里是驱动，之后的事情都是有驱动来接管负责与设备的通信）根据前面设备回复的信息，发送Set_Configuration请求来正式确定选择设备的哪个配置（Configuration）作为工作配置（对于大多数设备来说，一般只有一个配置被定义）。至此，设备处于配置状态(Configured)，当然，设备也应该使能它的各个接口（Interface）。
    对于复合设备，主机会在这个时候根据设备接口信息，给它们挂载驱动。
##  3. 控制传输
     控制传输是最重要和最复杂的一种传输类型，其中使用了一个8字节大小的DATA0数据包，这8个字节的数据包是主机用来发送**控制阶段**中的请求命令，而这些请求命令是主机配置USB设备的关键。
![](https://img-my.csdn.net/uploads/201212/13/1355362719_4354.PNG)
**1) bmRequestType(向谁请求)**
    D7：传输方向
            0=主机至设备；1=设备至主机
    D6..5：命令类型
           D6D5=00：标准请求命令； D6D5=01：类请求命令；
           D6D5=10：用户定义命令； D6D5=11：保留。
    D4..0：接受者类型
          0=设备；1=接口 ；
          2=端点；3=其它
          4..31 保留
       这个域表明此请求的特性。特别地，这个域表明了第二阶段控制传输方向。如果wLength域被设作0的话，表明没有数据传送阶段，那Direction位就会被忽略.
       USB说明定义了一系列所有设备必须支持的标准请求。这些请求见下面的表<Standard Device Requests>。另外，一个设备类可定义更多的请求。设备厂商也可定义设备支持的请求.
       请求可被导引到设备，设备接口，或某一个设备端结点(endpoint)上。这个请求域也指定了接收者。当指定的是接口或端结点(endpoint)时，wIndex域指出那个接口或端节点。
**2) bmRequest(什么请求)**
       这个域标识特别的请求。bmRequestType域的Type字段可修改此域的含义。本文仅定义Type 字段为0即标准设备请求时bRequest域值的含义。
**3) wValue域 **    此域用来传送当前请求的参数，随请求不同而变。
**4) wIndex域 **    当bmRequestType的Recipient字段为接口或端点时，wIndex域用来表明是哪一个接口或端结。
**5) wLength域**    这个域表明第二阶段的数据传输长度。传输方向由bmRequstType域的Direction位指出。wLength域为0则表明无数据传输。在输入请求下，设备返回的数据长度不应多于wLength，但可以少于。在输出请求下，wLength指出主机发出的确切数据量。如果主机发送多于wLength的数据，设备做出的响应是无定义的。
### 3.1 标准设备请求
![](https://img-my.csdn.net/uploads/201212/13/1355364057_1552.PNG)
### 3.2 标准请求码(bRequest的值)
![](https://img-my.csdn.net/uploads/201212/13/1355369950_1416.PNG)
### 3.3 描述符类型
![](https://img-my.csdn.net/uploads/201212/13/1355370024_1450.PNG)
### 3.4 GET_DESCRIPTOR(读取描述符)
     这个请求返回存在的**描述符**.
![](https://img-my.csdn.net/uploads/201212/13/1355370335_4447.PNG)
**  wValue域：**
        高一字节：标识描述表类型(Descriptor Types)
        低一字节：表示描述符号的索引，将几个类型相同的描述符应用到设备中时，描述符索引用于选择一个特定的描述符（只能是配置和字符串描述符）。
        例如：设备可以用几个配置描述符。对于其他可以通过GetDescriptor()请求取得的标准描述符来说，描述符的索引须为0。描述符索引值的范围从0开始到设备使用该类型描述符的数量减1。
**wIndex域：**
       标识字串描述表的语言(Language ID)，如果是其它语言的话就设为0。
**wLength域：**
      表示要返回多少字节。如果描述表长度大于wLength域值，那么只有描述表的初始部分被返回。如果描述表比wLength域值小，则发送一个短包来标志传输的结束。一个短包被定义成一个长度短于最大负载长度或一个空(NULL)包。
       这个标准请求包括3种描述符：设备(也就是设备的限定符)、配置(也就是其他速度配置)、及字符串。能进行高速操作的设备支持设备限定描述符返回有关设备不支持的速度信息(包括默认端点的wMaxPacketSize和其他速度配置的数量)。
       其他速度配置用与配置描述符相同的结构返回信息，但如果设备在其他速度下操作则返回配置信息。请求配置描述符将返回配置描述符，所有接口描述符和在这个请求中所有接口的端点描述符。
       第一个接口描述符的设备请求会一次返回配置描述表，所有的接口描述表和所有接口的端节点的描述表。第一个接口描述符紧跟着配置描述符号，第一个接口的端节点的描述符号随后。如果有其它的接口与端节点，它们的描述符欲跟在第一个接口与端节点描述符之后。与类有关的描述符，和/或厂商定义的描述符跟在标准描述符之后.
        所有的设备必须提供一个设备描述符并且至少一个配置描述符，如果一个设备不支持一个请求的描述符，则返回请求错误。
    •缺省状态：此请求合法。
    •地址状态：此请求合法。
    •配置状态：此请求合法。
###  3.5 GET_INTERFACE(取得接口)
      这个请求向指定接口返回选中的备用设备。
      一些USB设备有接口设置互斥的配置。这个请求允许主机确定当前选定的备用设置。如果wValue或者wLength的值与上面指定的不一致，那么设备的行为没有定义；如果指定的接口不存在，那么设备将用请求错误响应。
     •默认状态：当设备处于默认状态时接收到这个请求，设备的行为没  有定义
     •地址状态：设备给出请求错误
     •配置状态：当设备处于配置状态时，这是一个有效的请求


