# 可变参函数的定义和使用 - xqhrs232的专栏 - CSDN博客
2016年10月19日 14:59:49[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：380
原文地址::[http://www.cnblogs.com/MarvinGeng/archive/2012/07/19/2598923.html](http://www.cnblogs.com/MarvinGeng/archive/2012/07/19/2598923.html)
相关文章
1、linux c程序调用open函数为什么两个或三个参数都可以？----[http://bbs.csdn.net/topics/390901940](http://bbs.csdn.net/topics/390901940)
实现一个加法函数(fnAdd), 要求参数个数由使用者确定. 
比如,这个加法函数要做到: 
fnAdd(1,2,0)返回值是3 
fnAdd(1,2,5,0)返回值是8 
fnAdd(1,2,4,5,0)返回值是12 
------------------------------------------------------
#include <stdio.h> 
#include <conio.h> 
#include <stdarg.h>    ////用变参函数所必须的 
////C99 标准，不能在老的编译器下通过。是我的设计的核心 
#define fnAdd(...) _fnAdd(0,__VA_ARGS__)     
///实际调用的函数，start是用来得到函数参数地址的，没有实际意义 
int _fnAdd(int start,...) 
{ 
///关于va_list va_start和va_end请参看相关资料，或者直接看stdarg.h也可以。 
///比较好理解，只有一点，最上面那个 
///define是为了字节对齐用的。其实没有什么意义。 
///如果做成template，把va_arg中的int和返回的sum的类型参数化，就更通用了 
     va_list arg_ptr; 
     int sum=0,t=0; 
     va_start(arg_ptr,start);             ///得到参数表的首地址 
     while(t=va_arg(arg_ptr,int))sum+=t; ////不知道有没有比这还好的写法，想了半天没有想出来。 
     va_end(arg_ptr);                     ///把arg_ptr=NULL 
     return sum;         
} 
////网友写的，可能调试很好用。   
////思路也很好，因为参数都是int，所以干脆第一个也是int，这样。。。大家自己可以想明白吧。 
////我觉得比我的那个要好。 
int __fnAdd(int start,...) 
{ 
     va_list arg_ptr; 
     int sum=0; 
     int nArgValue =start;   /////第一个参数直接加进去了。我觉得也可以。 
     int nArgCout=0; 
     va_start(arg_ptr,start); 
     do {sum+=nArgValue; 
        ++nArgCout; 
printf("the %d th arg: %d\n",nArgCout,nArgValue); 
printf("\n"); 
nArgValue = va_arg(arg_ptr,int); 
     } while(nArgValue != 0); 
     printf("\n"); 
     printf("the sum= %d\n",sum); 
va_end(arg_ptr); 
     return sum; 
} 
int main() 
{ 
///试用了一下，在dev-cpp下成功，但不能在turboc 2.0下用， 
printf("%d\n",fnAdd(1,2,3,0); 
printf("%d\n",fnAdd(1,2,3,5,0); 
getch(); 
return 0; 
}
-----------------------------------------------------------
__cdecl 的参数传递使用栈方式，入栈顺序是从右往左，他支持可变的参数个数。 
由于支持可变的参数个数，函数无法校正栈顶，所以这个活就留给了调用者。 
可变参数的使用很危险，如果不知道怎样结束的话，va_arg_arg宏会执行到出现内存访问错误为止， 而且对参数的类型控制和识别也很麻烦。 
我所说的危险在于开发者对参数的操作和处理上。 
在实现可变参数的函数时，由于其特殊性，导致参数的个数未知，如果要处理每一个参数就需要知道参数的个数，在printf函数实现中，是通过检查’%’的个数而得知参数的个数，在这个例子中，我用’\0’标记了参数的结束。在这些方式中，无一不是使用指针进行数据的读取，而且，如果操作不慎，导致指针越界，指向了参数表之外，这时候编译器不会报告任何错误，而这类错误不但后果严重，而且错误隐蔽，很难查到。 
多参函数的优点是使用灵活，定参函数的优点是稳定，高效。 
在实际开发中，多参函数通常可以改用定参函数实现，所以，我的建议是，若非万不得已，尽量少定义多参函数。 
下划线没有任何意义，只是内部函数的一般表示方法。如果被.h文件包起来看，对用户来说就只有一个fnAdd（）函数，隐藏了具体的实现细节。因为实际的实现最前面有个无用的参数，对用户来说是不雅的，仅此而以。 
任何技术都有自己的用处，只要用的适当的地方就好，没有什么别的要求，只要最终实现的代码简洁，高效，这才是最重要的。 
---------------------------------------------------------------
[转帖]可变参数学习笔记 
前言：本文在很大程度上改编自网友kevintz的"C语言中可变参数的用法"一文，在行文之前先向这位前辈表示真诚的敬意和感谢。 
一、什么是可变参数 
我们在C语言编程中有时会遇到一些参数个数可变的函数,例如printf()函数,其函数原型为: 
int printf( const char* format, ...); 
它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的（用三个点"…"做参数占位符）,实际调用时可以有以下的形式: 
     printf("%d",i); 
     printf("%s",s); 
     printf("the number is %d ,string is:%s", i, s);     
以上这些东西已为大家所熟悉。但是究竟如何写可变参数的C函数以及这些可变参数的函数编译器是如何实现，这个问题却一直困扰了我好久。本文就这个问题进行一些探讨,希望能对大家有些帮助. 
二、写一个简单的可变参数的C函数 
先看例子程序。该函数至少有一个整数参数,其后占位符…，表示后面参数的个数不定. 在这个例子里，所有的输入参数必须都是整数，函数的功能只是打印所有参数的值. 
函数代码如下： 
//示例代码1：可变参数函数的使用 
#include "stdio.h" 
#include "stdarg.h" 
void simple_va_fun(int start, ...) 
{ 
     va_list arg_ptr; 
     int nArgValue =start; 
     int nArgCout=0;      //可变参数的数目 
     va_start(arg_ptr,start); //以固定参数的地址为起点确定变参的内存起始地址。 
     do { 
        ++nArgCout; 
         printf("the %d th arg: %d\n",nArgCout,nArgValue);      //输出各参数的值 
         nArgValue = va_arg(arg_ptr,int);                     //得到下一个可变参数的值 
     } while(nArgValue != -1);                 
     return; 
} 
int main(int argc, char* argv[]) 
{ 
     simple_va_fun(100,-1); 
     simple_va_fun(100,200,-1); 
     return 0; 
} 
下面解释一下这些代码 
从这个函数的实现可以看到,我们使用可变参数应该有以下步骤: 
⑴由于在程序中将用到以下这些宏: 
     void va_start( va_list arg_ptr, prev_param ); 
     type va_arg( va_list arg_ptr, type ); 
     void va_end( va_list arg_ptr ); 
va在这里是variable-argument(可变参数)的意思. 
这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件. 
⑵函数里首先定义一个va_list型的变量,这里是arg_ptr,这个变量是存储参数地址的指针.因为得到参数的地址之后，再结合参数的类型，才能得到参数的值。 
⑶然后用va_start宏初始化⑵中定义的变量arg_ptr,这个宏的第二个参数是可变参数列表的前一个参数,即最后一个固定参数. 
⑷然后依次用va_arg宏使arg_ptr返回可变参数的地址,得到这个地址之后，结合参数的类型，就可以得到参数的值。 
⑸设定结束条件，这里的条件就是判断参数值是否为-1。注意被调的函数在调用时是不知道可变参数的正确数目的，程序员必须自己在代码中指明结束条件。至于为什么它不会知道参数的数目，读者在看完这几个宏的内部实现机制后，自然就会明白。 
(二)可变参数在编译器中的处理 
我们知道va_start,va_arg,va_end是在stdarg.h中被定义成宏的, 由于1)硬件平台的不同 2)编译器的不同,所以定义的宏也有所不同,下面看一下VC++6.0中stdarg.h里的代码（文件的路径为VC安装目录下的\vc98\include\stdarg.h） 
     typedef char *   va_list; 
     #define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) 
     #define va_start(ap,v)   ( ap = (va_list)&v + _INTSIZEOF(v) ) 
     #define va_arg(ap,t)     ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) ) 
     #define va_end(ap)       ( ap = (va_list)0 ) 
下面我们解释这些代码的含义： 
1、首先把va_list被定义成char*，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void*的 
2、定义_INTSIZEOF(n)主要是为了某些需要内存的对齐的系统.这个宏的目的是为了得到最后一个固定参数的实际内存大小。在我的机器上直接用sizeof运算符来代替，对程序的运行结构也没有影响。（后文将看到我自己的实现）。 
3、va_start的定义为 &v+_INTSIZEOF(v) ,这里&v是最后一个固定参数的起始地址，再加上其实际占用大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址,有了这个地址，以后的事情就简单了。 
这里要知道两个事情： 
     ⑴在intel+windows的机器上，函数栈的方向是向下的，栈顶指针的内存地址低于栈底指针，所以先进栈的数据是存放在内存的高地址处。 
     (2)在VC等绝大多数C编译器中，默认情况下，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：最后一个固定参数的地址位于第一个可变参数之下，并且是连续存储的。 
|--------------------------| 
|   最后一个可变参数              |    ->高内存地址处 
|--------------------------| 
|--------------------------| 
|   第N个可变参数               |      ->va_arg(arg_ptr,int)后arg_ptr所指的地方, 
|                                |      即第N个可变参数的地址。 
|--------------- |      
|--------------------------| 
|   第一个可变参数                |      ->va_start(arg_ptr,start)后arg_ptr所指的地方 
|                                |      即第一个可变参数的地址 
|--------------- |      
|------------------------ --| 
|                                | 
|   最后一个固定参数              |     -> start的起始地址 
|-------------- -|        ................. 
|-------------------------- | 
|                                |   
|--------------- |   -> 低内存地址处 
(4) va_arg():有了va_start的良好基础，我们取得了第一个可变参数的地址，在va_arg()里的任务就是根据指定的参数类型取得本参数的值，并且把指针调到下一个参数的起始地址。 
因此，现在再来看va_arg()的实现就应该心中有数了： 
     #define va_arg(ap,t)     ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) ) 
这个宏做了两个事情， 
    ①用用户输入的类型名对参数地址进行强制类型转换，得到用户所需要的值 
    ②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。 
(5)va_end宏的解释：x86平台定义为ap=(char*)0;使ap不再 指向堆栈,而是跟NULL一样.有些直接定义为((void*)0),这样编译器不会为va_end产生代码,例如gcc在linux的x86平台就是这样定义的. 在这里大家要注意一个问题:由于参数的地址用于va_start宏,所以参数不能声明为寄存器变量或作为函数或数组类型. 关于va_start, va_arg, va_end的描述就是这些了,我们要注意的 是不同的操作系统和硬件平台的定义有些不同,但原理却是相似的. 
(三)可变参数在编程中要注意的问题 
因为va_start, va_arg, va_end等定义成宏,所以它显得很愚蠢, 可变参数的类型和个数完全在该函数中由程序代码控制,它并不能智能 地识别不同参数的个数和类型. 有人会问:那么printf中不是实现了智能识别参数吗?那是因为函数 printf是从固定参数format字符串来分析出参数的类型,再调用va_arg 的来获取可变参数的.也就是说,你想实现智能识别可变参数的话是要通过在自己的程序里作判断来实现的. 例如，在C的经典教材《the c programming language》的7.3节中就给出了一个printf的可能实现方式，由于篇幅原因这里不再叙述。 
（四）小结: 
1、标准C库的中的三个宏的作用只是用来确定可变参数列表中每个参数的内存地址，编译器是不知道参数的实际数目的。 
2、在实际应用的代码中，程序员必须自己考虑确定参数数目的办法，如 
⑴在固定参数中设标志-- printf函数就是用这个办法。后面也有例子。 
⑵在预先设定一个特殊的结束标记，就是说多输入一个可变参数，调用时要将最后一个可变参数的值设置成这个特殊的值，在函数体中根据这个值判断是否达到参数的结尾。本文前面的代码就是采用这个办法. 
无论采用哪种办法，程序员都应该在文档中告诉调用者自己的约定。 
3、实现可变参数的要点就是想办法取得每个参数的地址，取得地址的办法由以下几个因素决定： 
①函数栈的生长方向 
②参数的入栈顺序 
③CPU的对齐方式 
④内存地址的表达方式 
结合源代码，我们可以看出va_list的实现是由④决定的，_INTSIZEOF(n)的引入则是由③决定的，他和①②又一起决定了va_start的实现，最后va_end的存在则是良好编程风格的体现，将不再使用的指针设为NULL,这样可以防止以后的误操作。 
4、取得地址后，再结合参数的类型，程序员就可以正确的处理参数了。理解了以上要点，相信稍有经验的读者就可以写出适合于自己机器的实现来。下面就是一个例子 
（五）扩展--自己实现简单的可变参数的函数。 
下面是一个简单的printf函数的实现，参考了<The C Programming Language>中的156页的例子，读者可以结合书上的代码与本文参照。 
#include "stdio.h" 
#include "stdlib.h" 
void myprintf(char* fmt, ...)         //一个简单的类似于printf的实现，//参数必须都是int 类型 
{ 
     char* pArg=NULL;                //等价于原来的va_list 
     char c; 
     pArg = (char*) &fmt;     //注意不要写成p = fmt !!因为这里要对//参数取址，而不是取值 
     pArg += sizeof(fmt);          //等价于原来的va_start           
    do 
     { 
         c =*fmt; 
         if (c != ’%’) 
         { 
             putchar(c);             //照原样输出字符 
         } 
         else 
{ 
//按格式字符输出数据 
             switch(*++fmt) 
{ 
             case ’d’: 
                 printf("%d",*((int*)pArg));            
                 break; 
             case ’x’: 
                 printf("%#x",*((int*)pArg)); 
                 break; 
             default: 
                 break; 
             } 
             pArg += sizeof(int);                //等价于原来的va_arg 
         } 
         ++fmt; 
     }while (*fmt != ’\0’); 
     pArg = NULL;                                //等价于va_end 
     return; } 
int main(int argc, char* argv[]) 
{ 
     int i = 1234; 
     int j = 5678; 
     myprintf("the first test:i=%d\n",i,j); 
     myprintf("the secend test:i=%d; %x;j=%d;\n",i,0xabcd,j); 
     system("pause"); 
     return 0; 
} 
在intel+win2k+vc6的机器执行结果如下： 
the first test:i=1234 
the secend test:i=1234; 0xabcd;j=5678;
