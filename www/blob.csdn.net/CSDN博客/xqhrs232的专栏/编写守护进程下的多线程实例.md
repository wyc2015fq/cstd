# 编写守护进程下的多线程实例 - xqhrs232的专栏 - CSDN博客
2011年03月15日 15:35:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：783
原文地址::[http://hi.baidu.com/lsdyst/blog/item/d887858aa5f56ed9fc1f1010.html](http://hi.baidu.com/lsdyst/blog/item/d887858aa5f56ed9fc1f1010.html)

#ifndef PTHREAD_ZHXF
#define PTHREAD_ZHXF
#include <pthread.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>
#include <signal.h> 
#include <sys/file.h>
#include <syslog.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/select.h>
#include <sys/socket.h> 
#include <netinet/in.h>
#define BUFFER_SIZE 2048
int pthread_num=16;     //线程个数
int pthread_F[17]={0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};//线程运行标志，为-1时停止,为0时运行
unsigned char server_ip[17][16]={{"192.168.1.101"},{"192.168.1.102"},{"192.168.1.106"},{"127.0.0.1"}};
int server_port[17]={1000,1000,1000,100};
int revTimeOut[17]={0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
pthread_t pthread_t_zhxf[16];
pthread_attr_t pthread_attr_zhxf;
//PTHREAD_MUTEX_INITIALIZER为函数宏,也可用初始化锁的相关函数实现
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
void unBlockConnect(int id,int sockfd);
void *thread_function(void* pthread_ID);
void unBlockConnect(int id,int sockfd)
{
struct timeval timeout;
int maxfd,error,len,ret,val,n;
fd_set rset,wset; 
bzero(&timeout,sizeof(timeout));
FD_ZERO(&rset);
FD_ZERO(&wset);
FD_SET(sockfd,&rset);
FD_SET(sockfd,&wset);
maxfd = sockfd+1;
//设置一个socket地址结构server_addr,代表服务器的internet地址, 端口
struct sockaddr_in server_addr;
bzero(&server_addr,sizeof(server_addr));
server_addr.sin_family = AF_INET;
if(inet_aton(server_ip[id],&server_addr.sin_addr) == 0)
{
   printf("Server IP Address Error!/n");
   close(sockfd);
   pthread_F[id]=-1;
   pthread_exit(NULL);
}
server_addr.sin_port = htons(server_port[id]);
socklen_t server_addr_length = sizeof(server_addr);
val=fcntl(sockfd,F_GETFL,0);
fcntl(sockfd, F_SETFL, val|O_NONBLOCK);//设置异步CONNECT
connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));
timeout.tv_sec = 5;
timeout.tv_usec = 0;
if((n = select(maxfd, &rset, &wset, NULL, &timeout)) == 0)
{
   shutdown(sockfd, 2);   //关闭sockfd
   close(sockfd);    //清除sockfd
   pthread_F[id]=-1;
   pthread_exit(NULL);
}
fcntl(sockfd, F_SETFL, val); //恢复成阻塞的Socket
}
void * receive_from_server(int id)
{
sleep(1);  
struct sockaddr_in client_addr;
bzero(&client_addr,sizeof(client_addr)); //把一段内存区的内容全部设置为0
client_addr.sin_family = AF_INET;    //internet协议族
client_addr.sin_addr.s_addr = htons(INADDR_ANY);//INADDR_ANY表示自动获取本机地址
client_addr.sin_port = htons(0);    //0表示让系统自动分配一个空闲端口
//创建用于internet的流协议(TCP)socket,用client_socket代表客户机socket
int client_socket = socket(AF_INET,SOCK_STREAM,0);
if(client_socket < 0)
{
   printf("Create Socket Failed!/n");
   char Create_Socket_E[] = "Create Socket Failed!/0";
   pthread_F[id]=-1;
   close(client_socket);
   pthread_exit(NULL);
}
//把客户机的socket和客户机的socket地址结构联系起来
if( bind(client_socket,(struct sockaddr*)&client_addr,sizeof(client_addr)))
{
   printf("Client Bind Port Failed!/n"); 
   close(client_socket);
   pthread_F[id]=-1;
   pthread_exit(NULL);
} 
//开始计时
unBlockConnect(id, client_socket);//调用非阻塞CONNECT函数
//向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接 
char buffer[BUFFER_SIZE];
fd_set fds;
struct timeval timeout;//超时设置
timeout.tv_sec = 0;
timeout.tv_usec = 10;
while(1)
{
   FD_ZERO(&fds);
   FD_SET(client_socket, &fds); 
   if(pthread_F[id] == 0)//为-1时退出Socket线程
   {
    switch(select(client_socket+1, &fds, NULL, NULL, &timeout))
    {
     case -1:
      break;//连接终止
     case 0:
      revTimeOut[id]=-1;break;//超时退出
     default:
      if(FD_ISSET(client_socket, &fds))
      {
       bzero(buffer, sizeof(buffer));
       //从服务器接收数据到buffer中
       int length = recv(client_socket, buffer, BUFFER_SIZE, 0);
       if(length <= 0)
       {    
        pthread_F[id]=-1;
        close(client_socket);
        pthread_exit(NULL);
       }
       //标志收到数据
       revTimeOut[id]=0;
       printf("thread:%d, Data From Server , buffer length={%d}/t/n",id,length);
       //开始计时
       clock_t start,finish;
       double duration;
       start = clock();
       //()调用数据处理函数 
       //结束计时  
       finish = clock();
       duration = (double)(finish - start)/CLOCKS_PER_SEC;
       //printf("/nDataDispose duration is {%f}/n/n",duration );
      }
    }
   }
   else//超时，结束线程
   {
    break;
   }
}
//printf("close client_socket : %d !/n",id);
close(client_socket);
pthread_F[id]=-1;
pthread_exit(NULL);
}
//-------------------------------------TCP服务---------------------------------
int receive_from_server_TCP(int id)
{
while(1)
{
   printf("pthread_ID=%d is running receive_from_server_TCP/n",id);
   sleep(1);
   if(pthread_F[id]==-1)
   {
    pthread_exit((void *)id);
    printf("pthread_ID=%d has exit/n",id);
    return -1;
   }
}
return 0;
}
//-------------------------------------UDP服务-------------------------------------------------
int receive_from_server_UDP(int id)
{
while(1)
{
   printf("pthread_ID=%d is running receive_from_server_UDP/n",id);
   sleep(1);
   if(pthread_F[id]==-1)
   {
    pthread_exit((void *)id);
    printf("pthread_ID=%d has exit/n",id);
    return -1;
   }
}
return 0;
}
//-----------------------------------监控各线程的运行状态-----------------------------------------------
int pthread_status(int id)
{ 
int i;
while(1)
{ 
   //printf("pthread_status %d is working /n",id);
   sleep(1);
   for(i=1;i<16;i++)
   {
   printf("pthread_status %d is working pthread_F[%d]=%d/n",id,i,pthread_F[i]);
    if(pthread_F[i]==-1)
    {
     printf("pthread_ID %d has exit /n",i);
        printf("pthread create %d /n",i);
        if(pthread_create(&pthread_t_zhxf[i],&pthread_attr_zhxf,thread_function,(void*)i)<0)   //创建pthread_num个线程
        {
        printf("pthread_create pt[%d] failed/n",i); 
        } 
     else
     {
      pthread_F[i]=0;
     }
    }
   }
}
return 0;
}
//-----------------------------------线程要做的事情------------------------------------------
void *thread_function(void* pthread_ID)
{ 
int id=(int)pthread_ID;
switch(id)
{
   case 1:receive_from_server_TCP(id);break;
   case 2:receive_from_server_UDP(id);break;
   case 3:receive_from_server(id);break;
   case 4:receive_from_server_TCP(id);break;
   case 5:receive_from_server_TCP(id);break;
   case 6:receive_from_server_TCP(id);break;
   case 7:receive_from_server_TCP(id);break;
   case 8:receive_from_server_TCP(id);break;
   case 9:receive_from_server_TCP(id);break;
   case 10:receive_from_server_TCP(id);break;
   case 11:receive_from_server_TCP(id);break;
   case 12:receive_from_server_TCP(id);break;
   case 13:receive_from_server_TCP(id);break;
   case 14:receive_from_server_TCP(id);break;
   case 15:receive_from_server_TCP(id);break;
   case 16:pthread_status(id);break;
}
}
//---------------------------------线程初始化并创建----------------------------------------------------
int pthread_init_create(int pthread_num)
{ 
int j;
   //初始化线程属性结构体
if(pthread_attr_init(&pthread_attr_zhxf)!=0)
{
   printf("pthread_attr_init failed!/n");
   return -1;
}
for(j=1;j<=pthread_num;j++)
{ 
      printf("pthread create %d /n",j);
      if(pthread_create(&pthread_t_zhxf[j],&pthread_attr_zhxf,thread_function,(void*)j)<0)   //创建pthread_num个线程
      {
       printf("pthread_create pt[%d] failed/n",j); 
      } 
   else
   {
    pthread_F[j]=0;
   }
}
pthread_join(pthread_t_zhxf[1],NULL);//等待pthread_num号进程退出
while(1)
sleep(5);
return 0;
}
int daemon_init(void)
{
int i=0, j, k;
pid_t pid;
//signal(SIGPIPE,sigroutine);
//signal(SIGPIPE, SIG_IGN);
if((pid = fork()) < 0)
{
   return -1;
}
else if(pid != 0)
{
   sleep(10);
   printf("parent thread main has quit!/n");
   exit(0);
}
setsid();
chdir("/");
umask(0);
return 0; 
}
int main(void)
{ 
//daemon_init();
pthread_init_create(pthread_num);
return 0;
}
#endif

