# 用GDI绘制旋转的长方体 - xqhrs232的专栏 - CSDN博客
2010年07月08日 10:14:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1602
原文地址::[http://simplesource.blog.163.com/blog/static/10341406200911269325863/](http://simplesource.blog.163.com/blog/static/10341406200911269325863/)
　如果要绘制一个具有3D透视效果的长方体完全不需要动用OpenGL、D3D这样的大型3D工具，因为长方体的各个面的遮掩效果比较简单，不需要用到高度矩阵，只需要简单的计算就可以实现。
　　我们可以借用3D渲染引擎的法线思想来决定那个面需要绘制。在OpenGL、D3D所描述的3D世界中，每个面都有一个法线，法线决定了这个面的阴影着色和是否需要绘制。D3D可以设置参数只绘制那些“正面”朝向用户的平面。如果用这个方法来绘制长方体的各个平面，则可以简单的解决各个面的遮掩关系。我们只需要绘制那些法线的Z坐标小于0的平面，来实现绘制长方体。如图：
![用GDI绘制旋转的长方体 - 简单代码 - 简单代码](http://img.bimg.126.net/photo/zE7mGnamDu-j1JRoBSMnGA==/4823073725937580443.jpg)
　　以上图的阴影平面为例，它的法线向量(F)就是向量0->4(A)和向量0->3(B)的叉积（F=A×B），我们不关注这个向量的X和Y坐标的值，只需要Z坐标的值，因为我们只要决定法线是否向着用户就可以了。计算法线Ｚ坐标的公式：
　　Fz=Ax*By-Ay*Bx
　　实现３Ｄ透视效果方法则更简单了，3D透视效果说白了就是远大近小，为什么会造成这样一个效果呢？这是因为光线是直线传播的，如果以用户的眼睛为原点，那么我们所看到的世界就是一个圆锥体，如图：
[](http://img.bimg.126.net/photo/nmNYzcMG0Pkcy8DCRJa-dw==/4823073725937580524.jpg)[](http://img.bimg.126.net/photo/h86-rSxzBfMs0uPttmq3nw==/4823073725937580516.jpg)
![用GDI绘制旋转的长方体 - 简单代码 - 简单代码](http://img.bimg.126.net/photo/HR4nsXlSOy9XUd0C2MDmmg==/5386305154335682381.jpg)
　　我们要计算的是立体物体的AB点在银幕中的映射A'B'，这个可以利用相似三角形的性质来解决。计算公式如下： 
A'x=Ax*f/(f+Az) 
A'y=Ay*f/(f+Az)
**程序截图:**
![用GDI绘制旋转的长方体 - 简单代码 - 简单代码](http://img.bimg.126.net/photo/XJ4lrR-n6hDbMC54xlMm1Q==/4823073725937580546.jpg)
　　第一个立方体用了前一篇博客中提到的三角形贴图函数，第二个立方体则只是简单的使用了GDI的多边形绘制工具Polygon函数。
**程序和源代码下载**
**[**RotateBox.rar**](http://files.cnblogs.com/simplesource/RotateBox.rar)**
PS:三角形贴图函数直接用到3D绘制中会引起失真，这是因为3D世界中单个三角形平面还是具有3D透视效果的缘故，而我的贴图函数则没有考虑这个问题。
PPS:正考虑把三角形贴图函数运用到以前写的一个小程序中，试试是否能够提高程序运行速度。
