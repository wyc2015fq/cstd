# WINCE6模块的安全性----签名/证书 - xqhrs232的专栏 - CSDN博客
2013年10月23日 16:00:33[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1161
原文地址::[http://www.52rd.com/Blog/Archive_Thread.asp?SID=12930](http://www.52rd.com/Blog/Archive_Thread.asp?SID=12930)
相关文章
1、wince6.0 A8平台加密，签名可执行文件后还是无法运行 ----[http://bbs.csdn.net/topics/390509632](http://bbs.csdn.net/topics/390509632)
在 CE 6.0之前的Windows CE发布版本中, 有个信任的概念与每一个模块相关联(该模块可以是dll，也可以是exe). 每一个模块可以被分类为:
具有 “full trust” 的权限: 一种签名证书的dll/exe就是这种情况，该证书是与存储在设备上的特权证书相关联的. 这种情况下，该模块允许被装载，而且模块代码也允许调用系统中所有的APIs.
具有 “run”权限: 另一种签名证书的dll/exe就是这种情况，该证书是与存储在设备上的非特权证书相关联的. 这种情况下，模块允许被装载，但调用一定的API 是不允许的 (例如 SetKMode).
没有权限: 这种情况下dll/exe 可能签名了一个证书，但这个证书不是存储在设备上的证书，或者该模块根本就没有被签名，而模块又是要被装载到一个信任机制使能的系统.
正如上面所说的，模块信任完全是由证书来管理的. 一般缺省没有证书子系统在映像中的嵌入式系统，也可以这些在ROM的模块对API的调用.
对于CE 6.0, 模块信任的概念稍微有不同，而且实际上分成两个部分:
装载权限: 该权限用来决定是否可以装载某一模块(例如当一个应用程序调用CreateProcess 或 LoadLibrary 来启动或装载一个模块). 这个决定是基于证书模块是否已经构建进了设备. 后面我将对这一点稍做下解释.
API权限: 该权限用来决定一模块的代码是否可以调用一定的APIs，这些 APIs都被标记了只能运行在内核模式. 这个决定是基于模块是装载在哪里的. 任何装载在0x8000_0000之上的代码是被认为运行在内核模式的，而任何装载在该地址之下的代码则被认为运行在用户模式. 所以一个模块是否可以调用一定的APIs，纯粹是依赖于模块所装载的地址，而与该模块所关联的证书是毫无关系的.
现在让我们来进一步看看CE 6.0 中的“Load Privilege”. 在 CE 6.0中, 对一个模块的装载权限是基于以下规则的:
任何在文件上具有ROM属性置位的模块都被认为是完全信任的.
任何签名了一个证书的模块，而且该证书链上了一个存储在设备上的codesign证书也被认为是完全信任的.
而所有其它模块则被认为是 “untrusted”.
基于上面的规则, CE6设备可以构建的方法有：
情况 1: 如果 OEM 想用CE6.0来开发一个closed box 方案, 一种可能的方法是
使能映像中的SYSGEN_CERTMOD
不要加任何certificates到存储在设备上的codesign
确保所有需要运行在该closed box 系统上的模块都在ROM中.
一旦映像是用上面的属性来构建的, 则第三方的应用程序或模块是不能装载到该系统上.
情况2: 如果 OEM 想要用CE6.0来开发一个semi-closed box方案,在该方案中只有签名了模块可以被装载在该系统中, 该方法是:
在映像中使能 SYSGEN_CERTMOD
增加一个或多个证书到存储在设备上的codesign
确保所有要运行在该系统上的模块或者在ROM中，或者被签名了一个证书，该证书可以链上存储在该设备上的codesign 某一证书.
如果OEM想要为它们的设备发布一个SDK，以让ISVs可以针对它们的平台开发应用程序，这将是一个很好的方案. 通过强制该应用程序签名了一个OEM证书, OEMs就可以控制允许运行在该设备上的应用程序.
情况 3: 如果OEM 想要用CE6.0开发一个完全开放的方案, 则正确的方法是:
确保在映像中没有将SYSGEN_CERTMOD置位.
在这种情况下，在系统中的所有模块都会被认为具有装载的权限，因此任何要装载模块的试图都会被正常的处理. 注意SYSGEN_CERTMOD只是管理了一个模块的装载权限. 一旦模块被装载了，该模块可以调用的APIs是依赖于在该模块中运行的线程是在何种模式(是内核模式，还是用户模式). 这是由模块所装载的地址空间决定的.
我希望大家现在能够搞清楚了在CE6.0映像中certmod所扮演的角色.
如何替换证书模块:
在public\common\oak\drivers\security\certmod\dll中缺省的sources文件列出了DLLENTRY 为 "DllMain". 对于CE构建来说，这不是个问题，因为使用特定于public\common\cesysgen\makefile 中的设置会设置好正确的DLLENTRY. 所发如果你打算替换certmod 为你自己的证书模块, 请确保将该DLLENTRY 设置为 "_DllMainCRTStartup". 这个替换会要求evgen (它是certmod 所要链接的库)
 ，这样当certmod.dll 装载时，就会被正确地初始化
//========================================================
备注::
1>用微软makecert，cert2spc ，pvk2pfx 工具产生私钥和证书----这些工具的路径--D:\Program Files\Microsoft Visual Studio 8\Common7\Tools\Bin
2>通过signtool.exe对ce下的应用测试程序签名，平台加密是通过使能环境变量SYSGEN_CERTMOD
# wince6.0 A8
在 CE 6.0之前的Windows CE发布版本中, 有个信任的概念与每一个模块相关联(该模块可以是dll，也可以是exe). 每一个模块可以被分类为:
- 具有 “full trust” 的权限: 一种签名证书的dll/exe就是这种情况，该证书是与存储在设备上的特权证书相关联的. 这种情况下，该模块允许被装载，而且模块代码也允许调用系统中所有的APIs.
- 具有 “run”权限: 另一种签名证书的dll/exe就是这种情况，该证书是与存储在设备上的非特权证书相关联的. 这种情况下，模块允许被装载，但调用一定的API是不允许的 (例如 SetKMode).
- 没有权限: 这种情况下dll/exe 可能签名了一个证书，但这个证书不是存储在设备上的证书，或者该模块根本就没有被签名，而模块又是要被装载到一个信任机制使能的系统.
正如上面所说的，模块信任完全是由证书来管理的. 一般缺省没有证书子系统在映像中的嵌入式系统，也可以这些在ROM的模块对API的调用.
对于CE 6.0, 模块信任的概念稍微有不同，而且实际上分成两个部分:
- **装载权限**: 该权限用来决定是否可以装载某一模块(例如当一个应用程序调用CreateProcess 或 LoadLibrary 来启动或装载一个模块). 这个决定是基于证书模块是否已经构建进了设备. 后面我将对这一点稍做下解释.
- **API权限**: 该权限用来决定一模块的代码是否可以调用一定的APIs，这些 APIs都被标记了只能运行在内核模式. 这个决定是基于模块是装载在哪里的. 任何装载在0x8000_0000之上的代码是被认为运行在内核模式的，而任何装载在该地址之下的代码则被认为运行在用户模式. 所以一个模块是否可以调用一定的APIs，纯粹是依赖于模块所装载的地址，而与该模块所关联的证书是毫无关系的.
现在让我们来进一步看看CE 6.0 中的“Load Privilege”. 在 CE 6.0中, 对一个模块的装载权限是基于以下规则的:
- 任何在文件上具有ROM属性置位的模块都被认为是完全信任的.
- 任何签名了一个证书的模块，而且该证书链上了一个存储在设备上的codesign证书也被认为是完全信任的.
- 而所有其它模块则被认为是 “untrusted”.
基于上面的规则, CE6设备可以构建的方法有：
**情况 1**: 如果 OEM 想用CE6.0来开发一个closed box 方案, 一种可能的方法是
- 使能映像中的SYSGEN_CERTMOD
- 不要加任何certificates到存储在设备上的codesign
- 确保所有需要运行在该closed box 系统上的模块都在ROM中.
一旦映像是用上面的属性来构建的, 则第三方的应用程序或模块是不能装载到该系统上.
**情况2**: 如果 OEM 想要用CE6.0来开发一个semi-closed box方案,在该方案中只有签名了模块可以被装载在该系统中, 该方法是:
- 在映像中使能 SYSGEN_CERTMOD
- 增加一个或多个证书到存储在设备上的codesign
- 确保所有要运行在该系统上的模块或者在ROM中，或者被签名了一个证书，该证书可以链上存储在该设备上的codesign 某一证书.
如果OEM想要为它们的设备发布一个SDK，以让ISVs可以针对它们的平台开发应用程序，这将是一个很好的方案. 通过强制该应用程序签名了一个OEM证书, OEMs就可以控制允许运行在该设备上的应用程序.
**情况 3**: 如果OEM 想要用CE6.0开发一个完全开放的方案, 则正确的方法是:
- 确保在映像中没有将SYSGEN_CERTMOD置位.
在这种情况下，在系统中的所有模块都会被认为具有装载的权限，因此任何要装载模块的试图都会被正常的处理. 注意SYSGEN_CERTMOD只是管理了一个模块的装载权限. 一旦模块被装载了，该模块可以调用的APIs是依赖于在该模块中运行的线程是在何种模式(是内核模式，还是用户模式). 这是由模块所装载的地址空间决定的.
我希望大家现在能够搞清楚了在CE6.0映像中certmod所扮演的角色.
**如何替换证书模块:**
在public\common\oak\drivers\security\certmod\dll中缺省的sources文件列出了DLLENTRY 为 "DllMain". 对于CE构建来说，这不是个问题，因为使用特定于public\common\cesysgen\makefile 中的设置会设置好正确的DLLENTRY. 所发如果你打算替换certmod 为你自己的证书模块, 请确保将该DLLENTRY 设置为 "_DllMainCRTStartup". 这个替换会要求evgen (它是certmod 所要链接的库) ，这样当certmod.dll 装载时，就会被正确地初始化平台加密，签名可执行文件后还是无法运行 
