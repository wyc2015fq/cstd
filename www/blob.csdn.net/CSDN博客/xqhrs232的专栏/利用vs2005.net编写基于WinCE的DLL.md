# 利用vs2005.net编写基于WinCE的DLL - xqhrs232的专栏 - CSDN博客
2010年03月03日 10:39:00[xqhrs232](https://me.csdn.net/xqhrs232)阅读数：1892
原文地址：：[http://blog.chinaunix.net/u1/36075/showart.php?id=277565](http://blog.chinaunix.net/u1/36075/showart.php?id=277565)
**1 动态链接库简介**
**1.1、DLL概述**
动态链接库（Dynamic Link Library，简称DLL）是一些编译过的可执行的程序模块，可以在应用程序中或其他DLL中被调用。DLL的应用非常广泛，可以实现多个应用程序的代码和资源共享，是WinCE程序设计中的一个非常重要的组成部分。
DLL设计程序的优点：
·共享代码、资源和数据。DLL作为一种基于Windows的程序模块，不仅可以包含可执行的代码，还可以包括数据和各种资源等，扩大了库文件的使用范围；
·可将系统模块化，方便升级。
·隐藏实现的细节。在某些情况下，用户可能想隐藏例程的细节，可以采用DLL来实现，DLL的例程可以被应用程序访问，而不显示其中代码的细节。
·DLL与语言无关
**1.2、DLL的调用**
不论使用何种语言对编译好的DLL进行调用时，基本上都有两种调用方式，即静态调用方式和动态调用方式。静态调用方式由编译系统完成对DLL的加载和应用程序结束时DLL卸载的编码（如还有其它程序使用该DLL，则Windows对DLL的应用记录减1，直到所有相关程序都结束对该DLL的使用时才释放它），简单实用，但不够灵活，只能满足一般要求。动态调用方式是由编程者用API函数加载和卸载DLL来达到调用DLL的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。
**1.2.1 DLL的静态调用**
DLL的静态调用由编译系统完成对DLL的加载和应用程序结束时DLL卸载，在EVC或VS.net中静态调用DLL非常简单，首先将动态链接库的.LIB文件加入到应用程序的工程中，然后在使用DLL中的函数文件里引用DLL的头文件（.h）即可。
当开发人员通过静态方式编译并生成应用程序时，应用程序中的调用函数与LIB文件中的导出符号相匹配，这些符号或标示进入到生成的EXE文件中。当应用程序运行过程中需要加载DLL文件时，操作系统将根据这些信息查寻并加载DLL，然后通过符号或标示实现对DLL函数的动态链接。当加载应用程序的EXE文件时，所有被应用程序调用的DLL文件都被加载到内存中，这时可执行程序直接通过函数名调用DLL的输出函数，其调用方法与调用程序内部函数相同。
**1.2.2 DLL的动态调用**
动态调用方式是由编程者用API函数加载和卸载DLL来达到调用DLL的目的，动态调用是指在应用程序中使用LoadLibrary函数或MFC提供的AfxLoadLibrary函数显式调用自己所需要的动态链接库，动态链接库的文件名就是上面两个函数的参数，然后在使用GetProAddress()函数获取所需要引入的函数。完成上述操作后，应用程序可以调用引入的函数。在应用程序退出之前，应该使用FreeLibrary函数或MFC提供的AfxFreeLibrary函数来释放动态链接库。
**2 动态链接的实现**
**2.1 动态链接库的创建**
（1）新建一个基于Smart
 Device的 MFC Smart Device DLL，将项目名称设为DllTest，如图8-1所示。
图8 -1新建DLL项目
单击OK，此时将出现DLL的支持平台对话框，选择所支持的平台，由于本实验的DLL动态库使用XBASE270目标板，所以选择XBASE270平台。如图8-2所示。
图8 -2 DLL项目的平台选择
单击Next，将出现DLL的类型选择（如图8-3所示），选中MFC
 Extension DLL，按Finish可完成DLL向导工作。此时向导将自动生成DLL基本框架。
图 8-3 DLL类型选择对话框
（2）每个DLL必须有一个入口点，这就如如同使用C语言编写的应用程序必须有一个main函数一样，DllMain是一个默认的入口函数，它负责初始化和结束工作，当一个新的线程访问DLL时，都会调用DllMain函数。
打开利用向导生成的DllTest.cpp文件，即可看到DllMain函数的实现。
extern"C" BOOL APIENTRY DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
// Remove this if you use lpReserved
UNREFERENCED_PARAMETER(lpReserved);
if (dwReason == DLL_PROCESS_ATTACH)
{
TRACE0("DllTest.DLL Initializing!/n");
// Extension DLL one-time initialization
if (!AfxInitExtensionModule(DllTestDLL,
reinterpret_cast<HMODULE>(hInstance)))
return 0;
new CDynLinkLibrary(DllTestDLL);
}
elseif (dwReason == DLL_PROCESS_DETACH)
{
TRACE0("DllTest.DLL Terminating!/n");
// Terminate the library before destructors are called
AfxTermExtensionModule(DllTestDLL);
}
return 1;// ok
}
（3）输出函数的实现方法
DLL中导出函数的声明有两种方式：一种方法在函数名称声明中加上修饰符__declspec(dllexport)，表示输出，此外，还有一种修饰符extern "C" __declspec(dllexport)，也表示输出，而且该类DLL不仅可以被C++调用，还可以被C调用。在C++下定义C函数时，需要加上extern
 "C"关键字。下面为DLL测试程序的输出函数的声明。（在DllTest.h文件中）。
#ifdef DLLTEST_EXPORTS
#define DLLTEST_API
__declspec(dllexport)
#else
#define DLLTEST_API
__declspec(dllimport)
#endif
extern"C"
{
void DLLTEST_API SetLight(unsignedchar data);
void DLLTEST_API Ledshift(int shiftdir ,int count);
void DLLTEST_API LedControl(DWORD dwCode,int shiftdir=-1);
}
导出函数另外一种方式是采用模块定义(.def)
文件声明，.def文件为链接器提供了有关被链接程序的导出、属性及其他方面的信息。（DllTest.def的内容）
; DllTest.def : Declares the module parameters for the DLL.
LIBRARY"DllTest"
EXPORTS
SetLight 
Ledshift
LedControl
采用模块定义.def导出函数声明，如果要求导出函数能够被C语言掉用，必须在函数的实现前加extern "C"进行修饰。
extern"C"void SetLight(unsignedchar data)
{
if(m_bShiftRunning)
{
m_bStop=TRUE;
Sleep(500);
}
*pLightReg=~data;
}
**2.2 动态链接库的调用步骤**
（1）静态调用DLL的步骤
利用VS2005.net生成一个DLL调用测试应用程序TestDll.sln，并将上述编译好的DllTest.dll和DllTest.lib文件拷贝到本工程的目录下。然后使用VS2005.net的Project|DllTest
 Properties属性设置中，选中Linker，在Linker的Input选项的Additional
 Dependencies中输入DllTest.lib如图8-4所示
图 8-4
静态调用操作界面
如果在DLL的函数的导出采用头文件的实现方法，必须将DLL的头文件DllTest.h拷贝到在调用DLL的工程中，并在实现文件中引用DllTest.h文件，代码如下：
#include"DllTest.h"
这样就可以使用DLL的导出函数。
如果采用模块（.def）导出DLL中实现函数，则必须在调用DLL的实现文件声明导入函数，代码如下：
extern"C"void__declspec(dllimport) SetLight(unsignedchar data);
extern"C"void__declspec(dllimport) Ledshift(int shiftdir ,int count);
extern"C"void__declspec(dllimport) LedControl(DWORD dwCode,int shiftdir=-1);
（2）动态调用DLL的步骤
动态调用方式是使用LoadLibrary API函数加载DLL，然后在使用GetProAddress()函数获取所需要引入的函数。
具体实现方式：
·添加DllTest动态链接库工程的实现函数的定义，代码如下：
typedefvoid (*pLedControl) (DWORD,int);
typedefvoid (*pSetLight) (unsignedchar);
typedefvoid (*pLedShift) (int,int);
·利用LoadLibrary API函数动态加载动态链接库，代码的黑体部分；
BOOL CTestDllDlg::OnInitDialog()
{
CDialog::OnInitDialog();
SetIcon(m_hIcon, TRUE);// Set big icon
SetIcon(m_hIcon, FALSE);// Set small icon
**hModule=LoadLibrary(_T("DllTest.dll"));**
**if(hModule==NULL)**
**MessageBox(_T("Load Dll file failed"),_T("System Information"),MB_OK|MB_ICONERROR);**
return TRUE;// return TRUEunless you set the focus to a control
}
·利用GetProcAddress API函数获取需要引用的函数，代码如下：
void CTestDllDlg::OnBnClickedbtnstop()
{
**pLedControl LedControl =(pLedControl)GetProcAddress (hModule,_T("LedControl"));**
if(LedControl==NULL)
MessageBox(_T("Load LedControl function failed"),_T("System Information"),MB_OK|MB_ICONERROR);
else
LedControl(2,-1);
}
