# linux系统文件描述符file descriptor与inode的相关知识 - 右上角同学的专栏 - CSDN博客
2016年08月01日 20:30:43[右上角徐](https://me.csdn.net/u011032983)阅读数：181
转自： [http://blog.csdn.net/simba888888/article/details/8806654](http://blog.csdn.net/simba888888/article/details/8806654)
每个进程在Linux内核中都有一个task_struct结构体来维护进程相关的 信息,称为进程描述符(Process Descriptor),而在操作系统理论中称为进程控制块 (PCB,Process Control Block)。task_struct中有一个指针(struct
 files_struct *files; )指向files_struct结构体,称为文件 描述符表,其中每个表项包含一个指向已打开的文件的指针,如下图所示。
![](https://img-my.csdn.net/uploads/201304/15/1366040853_7047.png)
         用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引 (即0、1、2、3这些数字),这些索引就称为文件描述符(File Descriptor),用int 型变量保存。 当调用open 打开一个文件或创建一个新文件时,内核分配一个文件描述符并返回给用户程序,该文件描述符表项中的指针指向新打开的文件。当读写文件时,用户程序把文件描述符传给read 或write ,内核根据文件描述符找到相应的表项,再通过表项中的指针找到相应的文件。
       已打开的文件在内核中用file 结构体表示,文件描述符表中的指针指向file 结构体。在file 结构体中维护File Status Flag(file 结构体的成员f_flags)和当前读写位置(file 结构体 的成员f_pos )。在下图中,进程1和进程2都打开同一文件,但是对应不同的file 结构体,因此可 以有不同的File Status Flag和读写位置。file 结构体中比较重要的成员还有f_count,表示引用计
 数(Reference Count),如dup 、fork 等系统调用会导致多个文件描述符指向同一 个file 结构体,例如有fd1 和fd2 都引用同一个file 结构体,那么它的引用计数就是2, 当close(fd1) 时并不会释放file 结构体,而只是把引用计数减到1,如果再close(fd2) ,引用计数 就会减到0同时释放file 结构体,这才真的关闭了文件。 每个file 结构体都指向一个file_operations
 结构体,这个结构体的成员都是函数指针,指向实现 各种文件操作的内核函数。比如在用户程序中read 一个文件描述符,read 通过系统调用进入内核, 然后找到这个文件描述符所指向的file 结构体,找到file 结构体所指向的file_operations 结构 体,调用它的read 成员所指向的内核函数(如内核代码中实现函数可能为sys_read())以完成用户请求。在用户程序中调 用lseek 、read 、write
 、ioctl 、open 等函数,最终都由内核调用file_operations 的各成员所指向 的内核函数完成用户请求。file_operations 结构体中的release成员用于完成用户程序的close 请 求,之所以叫release而不叫close 是因为它不一定真的关闭文件,而是减少引用计数,只有引用计 数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说,read 、write 等文件操作的步骤 和方法应该是一样的,调用的函数应该是相同的,所以图中的三个打开文件的file 结构体指向同一
 个file_operations 结构体。如果打开一个字符设备文件,那么它的read,write 操作肯定和常规文 件不一样,不是读写磁盘的数据块而是读写硬件设备,所以file 结构体应该指向不同 的file_operations 结构体,其中的各种文件操作函数由该设备的驱动程序实现。 
![](https://img-my.csdn.net/uploads/201304/15/1366041111_3148.png)
       每个file 结构体都有一个指向dentry结构体的指针,“dentry”是directory entry(目录项)的缩写。 我们传给open 、stat 等函数的参数的是一个路径,如/home/akaedu/a ,需要根据路径找到文件 的inode。为了减少读盘次数,内核缓存了目录的树状结构,称为dentry
 cache,其中每个节点是一 个dentry结构体,只要沿着路径各部分的dentry搜索即可,从根目录/找到home 目录,然后找 到akaedu目录,然后找到文件a。dentry cache只保存最近访问过的目录项,如果要找的目录项 在cache中没有,就要从磁盘读到内存中。 
每个dentry结构体都有一个指针指向inode 结构体。inode 结构体保存着从磁盘inode读上来的信 息。在上图的例子中,有两个dentry,分别表示/home/akaedu/a 和/home/akaedu/b ,它们都指向同 一个inode,说明这两个文件互为硬链接。inode 结构体中保存着从磁盘分区的inode读上来信息, 例如所有者、文件大小、文件类型和权限位等。每个inode 结构体都有一个指向inode_operations结 构体的指针,后者也是一组函数指针指向一些完成文件目录操作的内核函数。 
![inode和dentry](http://www.daoluan.net/blog/wp-content/uploads/2012/07/inodedentry_thumb.jpg)
    这张图再次描述了fd-dentry->inode superblock 和file物理存储的一个映射关系。
       和file_operations 不同,inode_operations所指向的不是针对某一个文件进行操作的函数,而是影 响文件和目录布局的函数,例如添加删除文件和目录、跟踪符号链接等等,属于同一文件系统的 各inode 结构体可以指向同一个inode_operations结构体。 inode 结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块
 读上来的信息,例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指 向dentry的指针,表示这个文件系统的根目录被mount 到哪里,在上图的例子中这个分区 被mount 到/home 目录下。 
        file 、dentry、inode 、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来 说,在磁盘存储布局上也有inode和超级块的概念,所以很容易和VFS中的概念建立对应关系。而 另外一些文件系统格式来自非UNIX系统(例如Windows的FAT32、NTFS),可能没有inode或超 级块这样的概念,但为了能mount 到Linux系统,也只好在驱动程序中硬凑一下,在Linux下
 看FAT32和NTFS分区会发现权限位是错的,所有文件都是rwxrwxrwx ,因为它们本来就没 有inode和权限位的概念,这是硬凑出来的。
        在UNIX系统中,用户通过终端登录系统后得到一个Shell进程,这个终端成为Shell进程的控制终端 (Controlling Terminal),控制终端是保存在PCB中的信息,而我们知 道fork 会复制PCB中的信息,因此由Shell进程启动的其它进程的控制终端也是这个终端。
默认情况 下(没有重定向),每个进程的标准输入(stdin)、标准输出(stdout)和标准错误输出(stderr)都指向控制终端,因为在程序启动时(在main 函数还 没开始执行之前)会自动把控制终端打开三次,分别赋给三个FILE *指 针stdin 、stdout和stderr,这三个文件指针是libc 中定义的全局变量,这三个文件的描述符分别是0、1、2,保存在相应的FILE
 结构体中。进程从标准输入读也就是读用户的键盘输入,进程往标准输出或标准错误输出写也就是输出到显示器上
头文件unistd.h 中有如下的宏定义来表示这三个文件描述符: 
#define STDIN_FILENO 0 
#define STDOUT_FILENO 1 
#define STDERR_FILENO 2
       每个进程都可以通过一个特殊的设备文件/dev/tty(字符设备c) 访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件,/dev/tty 提供了一个通用的接口,一个进程要访问它的控制终端既可以通过/dev/tty 也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名,该文件描述符必须指向一个终端设备而不 能是任意文件。不同的终端所对应的设备文件名可以是/dev/pts/?, /dev/tty?等
simba@simba-Aspire-4752:~$ ls -l /dev/tty 
crw-rw-rw- 1 root tty 5, 0 Jan 29 09:46 /dev/tty 
       开头的c表示文件类型是字符设备。中间的5, 0是它的设备号,主设备号5,次设备号0,主设备号 标识内核中的一个设备驱动程序,次设备号标识该设备驱动程序管理的一个设备。内核通过设备号 找到相应的驱动程序,完成对该设备的操作。我们知道常规文件的这一列应该显示文件尺寸,而设 备文件的这一列显示设备号,这表明设备文件是没有文件尺寸这个属性的,因为设备文件在磁盘上 不保存数据,对设备文件做读写操作并不是读写磁盘上的数据,而是在读写设备。
       由open 返回的文件描述符一定是该进程尚未使用的最小描述符。由于程序启动时自动打开文件描述符0、1、2,因此第一次调用open打开文件通常会返回描述符3,再调用open 就会返回4。可以利用 这一点在标准输入、标准输出或标准错误输出上打开一个新文件,实现重定向的功能。例如,首先 调用close 关闭文件描述符1,然后调用open 打开一个常规文件,则一定会返回文件描述符1,这时候标准输出就不再是终端,而是一个常规文件了,再调用printf就不会打印到屏幕上,而是写到这
 个文件中了。
      需要说明的是,当一个进程终止时,内核对该进程所有尚未关闭的 文件描述符调用close 关闭,所以即使用户程序不调用close ,在终止时内核也会自动关闭它打开的 所有文件。但是对于一个长年累月运行的程序(比如网络服务器),打开的文件描述符一定要记得 关闭,否则随着打开的文件越来越多,会占用大量文件描述符和系统资源。
------------------------------------------------------------------------------------------------------------------------------------
传统的Unix既有v节点（vnode）也有i节点（inode），vnode的数据结构中包含了inode信息。但在Linux中没有使用vnode，而使用了通用inode。“实现虽不同，但在概念上是一样的。”
vnode (“virtual node”)仅在文件打开的时候，才出现的；而inode定位文件在磁盘的位置，它的信息本身是存储在磁盘等上的，当打开文件的时候从磁盘上读入内存。
![](https://img-blog.csdn.net/20130512235852220)
inode结构体记录了很多关于文件的信息，比如文件长度，文件所在的设备，文件的物理位置，创建、修改和更新时间等等，特别的，它不包含文件名！目录下的所有文件名和目录名都存储在目录的数据块中，即如下图的目录块。对于常规文件，文件的数据存储在数据块中，一个文件通常占用一个inode，但往往要占用多个数据块，数据块是在分区进行文件系统格式化时所指定的“最小存储单位”，块的大小为扇区的2^n倍，一个扇区512B。
![](https://img-blog.csdn.net/20130513000042334)
- 
如果多个inode指向同一个数据块的时候，是不是就可以实现熟悉的链接了？！这就是软连接的原理，新建一个文件（一个符号链接文件，文件的属性中有明确说明它是一个符号链接文件），为需要链接的文件分配一个新的inode，然后指向同一个数据块。当我们用ls
 查看某个目录或文件时，如果加上-i 参数，就可以看到inode节点了；比如ls -li lsfile.sh ，最前面的数值就是inode信息。
- 
多个文件共用一个inode，同样可以实现链接？！这就是硬链接的原理，inode中有链接计数器，当增加一个文件指向这个inode时，计数器增1。特别的，当计数器为0时候，文件才真正从磁盘删除。即ls -l 命令输出中的第二栏。
