# 笔试题-白盒测试实例--逻辑覆盖测试 - 右上角同学的专栏 - CSDN博客
2016年08月04日 21:44:40[右上角徐](https://me.csdn.net/u011032983)阅读数：4956
个人分类：[软件测试相关																[常见笔试题目相关](https://blog.csdn.net/u011032983/article/category/6342904)](https://blog.csdn.net/u011032983/article/category/6290481)
白盒测试实例--逻辑覆盖测试 
作者：www.test-edu.net  发布时间：2015-04-07  浏览次数：4880 次 
本文转自：http://www.test-edu.com/softwareinfo.asp?id=1001&nid=5182
     逻辑覆盖测试是通过对程序逻辑结构的遍历实现程序的覆盖。从覆盖源代码的不同程度可以分为以下六个标准：语句覆盖、判定覆盖（又称为分支覆盖）、条件覆盖、判定-条件覆盖（又称为分支-条件覆盖）、条件组合覆盖和路径覆盖。
       先看一下具体例子的源代码（C语言）：
- /*
-  *  白盒测试逻辑覆盖测试范例
-  *  作者：胡添发（hutianfa@126.com）
-  */
- int logicExample(int x, int y)
- {
- int magic=0;
- if(x>0 && y>0)
-     {
-         magic = x+y+10; // 语句块1 
-     }
- else
-     {
-         magic = x+y-10; // 语句块2
-     }
- 
- if(magic < 0)
-     {
-         magic = 0;         // 语句块3
-     }
- return magic;       // 语句块4
- }
    一般做白盒测试不会直接根据源代码，而是根据流程图来设计测试用例和编写测试代码，在没有设计文档时，要根据源代码画出流程图：
![白盒测试流程图](http://www.test-edu.com/jtkd/uploadfile/image/2015-4//2015471346442887.jpg)
白盒测试流程图
做好了上面的准备工作，接下来就开始讲解六个逻辑覆盖标准：
一、语句覆盖
1、概念：
    设计足够多的测试用例，使得被测试程序中的每条可执行语句至少被执行一次。在本例中，可执行语句是指语句块1到语句块4中的语句。
2、测试用例：
{x=3, y=3}可以执行到语句块1和语句块4，所走的路径：a-b-e-f
{x=-3, y=0}可以执行到语句块2、语句块3和语句块4，所走的路径：a-c-d-f
这样，通过两个测试用例即达到了语句覆盖的标准，当然，测试用例（测试用例组）并不是唯一的。
3、测试的充分性：
    假设第一个判断语句if(x>0 && y>0)中的“&&”被程序员错误地写成了“||”，即if(x>0 || y>0)，使用上面设计出来的一组测试用例来进行测试，仍然可以达到100%的语句覆盖，所以语句覆盖无法发现上述的逻辑错误。
在六种逻辑覆盖标准中，语句覆盖标准是最弱的。
二、判断覆盖（分支覆盖）
1、概念：
设计足够多的测试用例，使得被测试程序中的每个判断的“真”、“假”分支至少被执行一次。在本例中共有两个判断if(x>0 && y>0)（记为P1）和if(magic < 0)（记为P2）。
2、测试用例：
|数据|P1|P2|路径|
|----|----|----|----|
|{x=3, y=3}|T|F|a-b-e-f|
|{x=-3, y=0}|F|T|a-c-d-f|
    两个判断的取真、假分支都已经被执行过，所以满足了判断覆盖的标准。
3、测试的充分性：
    假设第一个判断语句if(x>0 && y>0)中的“&&”被程序员错误地写成了“||”，即if(x>0 || y>0)，使用上面设计出来的一组测试用例来进行测试，仍然可以达到100%的判定覆盖，所以判定覆盖也无法发现上述的逻辑错误。
    跟语句覆盖相比：由于可执行语句要不就在判定的真分支，要不就在假分支上，所以，只要满足了判定覆盖标准就一定满足语句覆盖标准，反之则不然。因此，判定覆盖比语句覆盖更强。
    三、条件覆盖
    1、概念：
    设计足够多的测试用例，使得被测试程序中的每个判断语句中的每个逻辑条件的可能值至少被满足一次。
也可以描述成：
    设计足够多的测试用例，使得被测试程序中的每个逻辑条件的可能值至少被满足一次。
    在本例中有两个判断if(x>0 && y>0)（记为P1）和if(magic < 0)（记为P2），共计三个条件x>0（记为C1）、y>0（记为C2）和magic<0（记为C3）。
    2、测试用例：
|数据|C1|C2|C3|P1|P2|路径|
|----|----|----|----|----|----|----|
|{x=3, y=3}|T|T|T|T|F|a-b-e-f|
|{x=-3, y=0}|F|F|F|F|T|a-c-d-f|
    三个条件的各种可能取值都满足了一次，因此，达到了100%条件覆盖的标准。
    3、测试的充分性：
    上面的测试用例同时也到达了100%判定覆盖的标准，但并不能保证达到100%条件覆盖标准的测试用例（组）都能到达100%的判定覆盖标准，看下面的例子：
|数据|C1|C2|C3|P1|P2|路径|
|----|----|----|----|----|----|----|
|{x=3, y=0}|T|F|T|F|F|a-c-e-f|
|{x=-3, y=5}|F|T|F|F|F|a-c-e-f|
    既然条件覆盖标准不能100%达到判定覆盖的标准，也就不一定能够达到100%的语句覆盖标准了。
    四、判定-条件覆盖（分支-条件覆盖）
    1、概念：
    设计足够多的测试用例，使得被测试程序中的每个判断本身的判定结果（真假）至少满足一次，同时，每个逻辑条件的可能值也至少被满足一次。即同时满足100%判定覆盖和100%条件覆盖的标准。
    2、测试用例：
|数据|C1|C2|C3|P1|P2|路径|
|----|----|----|----|----|----|----|
|{x=3, y=3}|T|T|T|T|F|a-b-e-f|
|{x=-3, y=0}|F|F|F|F|T|a-c-d-f|
    所有条件的可能取值都满足了一次，而且所有的判断本身的判定结果也都满足了一次。
    3、测试的充分性：
    达到100%判定-条件覆盖标准一定能够达到100%条件覆盖、100%判定覆盖和100%语句覆盖。
    五、条件组合覆盖
    1、概念：
    设计足够多的测试用例，使得被测试程序中的每个判断的所有可能条件取值的组合至少被满足一次。
注意：
    a、条件组合只针对同一个判断语句内存在多个条件的情况，让这些条件的取值进行笛卡尔乘积组合。
    b、不同的判断语句内的条件取值之间无需组合。
    c、对于单条件的判断语句，只需要满足自己的所有取值即可。
    2、测试用例：
|数据|C1|C2|C3|P1|P2|路径|
|----|----|----|----|----|----|----|
|{x=-3, y=0}|F|F|F|F|F|a-c-e-f|
|{x=-3, y=2}|F|T|F|F|F|a-c-e-f|
|{x=-3, y=0}|T|F|F|F|F|a-c-e-f|
|{x=3, y=3}|T|T|T|T|T|a-b-d-f|
    C1和C2处于同一判断语句中，它们的所有取值的组合都被满足了一次。
    3、测试的充分性：
    100%满足条件组合标准一定满足100%条件覆盖标准和100%判定覆盖标准。
    但上面的例子中，只走了两条路径a-c-e-f和a-b-d-f，而本例的程序存在三条路径。
    六、路径覆盖
    1、概念：
    设计足够多的测试用例，使得被测试程序中的每条路径至少被覆盖一次。
    2、测试用例：
|数据|C1|C2|C3|P1|P2|路径|
|----|----|----|----|----|----|----|
|{x=3, y=5}|T|T|T|T|T|a-b-d-f|
|{x=0, y=2}|F|T|T|F|T|a-c-d-f|
|这条路径不可能||||||a-b-e-f|
|{x=-8, y=3}|F|T|F|F|F|a-c-e-f|
    所有可能的路径都满足过一次。
    3、测试的充分性：
    由上表可见，100%满足路径覆盖，但并不一定能100%满足条件覆盖（C2只取到了真），但一定能100%满足判定覆盖标准（因为路径就是从判断的某条分支走的）
    七、六种逻辑覆盖的强弱关系
    在外面很多的教程都认为这六种逻辑覆盖从弱到强的排列顺序是：
    语句覆盖->判定覆盖->条件覆盖->判定-条件覆盖->条件组合覆盖->路径覆盖
    但经过上面的分析，它们之间的关系实际上可以用下图表示：
![白盒测试](http://www.test-edu.com/jtkd/uploadfile/image/2015-4//2015471350255104.jpg)
