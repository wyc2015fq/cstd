# 锦标赛排序和堆排序 - 右上角同学的专栏 - CSDN博客
2016年07月24日 22:14:57[右上角徐](https://me.csdn.net/u011032983)阅读数：283
个人分类：[剑指offer																[数据结构](https://blog.csdn.net/u011032983/article/category/6328409)](https://blog.csdn.net/u011032983/article/category/6290473)
[锦标赛排序和堆排序](http://blog.csdn.net/wincol/article/details/4812976)
本文转自：http://blog.csdn.net/wincol/article/details/4812976
1964年，堆排序被提出，它改善了锦标赛排序的种种缺点。
**锦标赛排序：**
锦标赛排序，也称为树形选择排序（Tree Selection Sort），是一种按照锦标赛的思想进行选择排序的方法。
首先对n个记录进行两两比较，然后优胜者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。这个过程可 以用一棵有n个叶子结点的完全二叉树表示。根节点中的关键字即为叶子结点中的最小关键字。在输出最小关键字之后，根据关系的可传递性，欲选出次小关键字， 仅需将叶子结点中的最小关键字改为“最大值”，如∞，然后从该叶子结点开始，和其左（右）兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键 字，则根结点的关键字即为次小关键字。
这种算法的缺点在于：辅助存储空间较多、最大值进行多余的比较。
为了弥补这些缺点，1964年，堆排序诞生。
**堆排序：**
堆排序（Heap Sort）只需要一个记录大小的辅助空间。
堆排序的定义如下：n个元素的序列，当且仅当满足“**任何一个非终端结点的值都大于等于（或小于等于）它左右孩子的值**”时，称之为堆。若序列{k1,k2,…,kn}是堆，则**堆顶元素（即完全二叉树的根）必为序列中n个元素的最小值（或最大值）**。
若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为**堆排序。**
**到目前为止，实现堆排序还需要解决两个问题：**
**问题2的解决方法是** ：假设输出堆顶元素之后，以堆中最后一个元素替代之，此时根结点的左、右子树均为堆，则仅需自上至下进行调整即可。我们称自堆顶至叶子的调整过程为“**筛选** ”。
（1）如何由一个无序序列建成一个堆？
（2）如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？
**问题1的解决方法是** ：从一个无序序列建堆的过程就是一个反复“筛选”的过程。若将此序列看成是一个完全二叉树，则最后一个非终端结点是第⌞n/2⌟个元素，由此“筛选”只需从第⌞n/2⌟个元素开始。
堆排序方法对记录数较少的文件并不值得提倡，但对n较大的文件还是很有效的。
堆排序在最坏情况下的时间复杂度也为O(nlogn)，相对于快速排序来说，这是堆排序的最大优点。
**堆排序源代码：**
#include <stdio.h>
/***********************************
* 功能：调整堆
* 参数：arr - 指向堆的根的指针
*       m - 堆中待调整的节点
*       n - 堆中元素的个数
************************************/
void heap_adjust(int *arr, int m, int n)
{
int i;
arr[0] = arr[m];
for(i=2*m; i<=n; i*=2)
{
   if(i<n && arr[i]<arr[i+1])
    i++;
   if(arr[0]>=arr[i])
    break;
   arr[m] = arr[i];
   m = i;
}
arr[m] = arr[0];
}
void heap_sort(int *arr, int arrsize)
{
int i, tmp;
//建立大顶堆
for(i=arrsize/2; i>0; i--)
{
   heap_adjust(arr, i, arrsize);
}
//输出堆顶元素
for(i=arrsize; i>1; i--)
{
   tmp = arr[1];
   arr[1] = arr[i];
   arr[i] = tmp;
   heap_adjust(arr, 1, i-1);
}
}
int main(void)
{
   int arr[10]={0,4,2,5,1,8,7,9};
        int arrsize=7;
        int i;
        printf("Quick Sort:/n");
        heap_sort(arr,arrsize);
        printf("Sorted array: ");
        for(i=1;i<=arrsize;i++)
        {
                printf("%d ",arr[i]);
        }
        printf("/n");
        return 0;
}
