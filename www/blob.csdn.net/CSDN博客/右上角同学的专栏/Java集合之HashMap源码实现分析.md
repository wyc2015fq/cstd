# Java集合之HashMap源码实现分析 - 右上角同学的专栏 - CSDN博客
2016年08月22日 00:20:58[右上角徐](https://me.csdn.net/u011032983)阅读数：457
# [Java集合之HashMap源码实现分析](http://www.cnblogs.com/zhangminghui/p/4184489.html)
本文转自：http://www.cnblogs.com/zhangminghui/p/4184489.html
## 　　1.简介
　　通过上面的一篇随笔我们知道了HashSet的底层是采用Map实现的，那么Map是什么？它的底层又是如何实现的呢？这下我们来分析下源码，看看具体的结构与实现。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。Map.Entry是其的内部类，描述Map中的按键/数值对。需要指出的是Map,允许null的键也允许null的值。它的实现主要有HashMap和sortedMap,其中SortedMap扩展了Map使按键保持升序排列，下面我们简要分析下HashMap的具体实现。首先给出一个应用举例：
```
```java
package
```
```java
com.test.collections;
```
```java
import
```
```java
java.util.Collection;
```
```java
import
```
```java
java.util.HashMap;
```
```java
import
```
```java
java.util.Map;
```
```java
import
```
```java
java.util.Set;
```
```java
public
```
```java
class
```
```java
HashMapTest
 {
```
```java
```
```java
/**
```
```java
```
```java
*
 @param args
```
```java
```
```java
*/
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
//
 TODO Auto-generated method stub
```
```java
```
```java
Map<String,String>
 map =
```
```java
new
```
```java
HashMap<String,String>();
```
```java
```
```java
map.put(
```
```java
"A"
```
```java
,
```
```java
"A"
```
```java
);
```
```java
```
```java
map.put(
```
```java
"D"
```
```java
,
```
```java
"D"
```
```java
);
```
```java
```
```java
map.put(
```
```java
"S"
```
```java
,
```
```java
"S"
```
```java
);
```
```java
```
```java
map.put(
```
```java
"C"
```
```java
,
```
```java
"C"
```
```java
);
```
```java
```
```java
map.put(
```
```java
"B"
```
```java
,
```
```java
"B"
```
```java
);
```
```java
```
```java
map.put(
```
```java
"W"
```
```java
,
```
```java
"W"
```
```java
);
```
```java
```
```java
```
```java
System.out.println(map.size());
```
```java
```
```java
System.out.println(map.isEmpty());
```
```java
```
```java
System.out.println(map.containsKey(
```
```java
"A"
```
```java
));
```
```java
//boolean
```
```java
```
```java
System.out.println(map.containsValue(
```
```java
"A"
```
```java
));;
```
```java
//boolean
```
```java
```
```java
System.out.println(map.get(
```
```java
"A"
```
```java
));
```
```java
```
```java
System.out.println(map.remove(
```
```java
"A"
```
```java
));
```
```java
```
```java
map.putAll(map);
```
```java
```
```java
Set<String>
 keySet = map.keySet();
```
```java
```
```java
Collection<String> 
 values = map.values();
```
```java
```
```java
Set<Map.Entry<String,
 String>> entry = map.entrySet();
```
```java
```
```java
map.clear();
```
```java
```
```java
}
```
```java
}
```
```
## 　　2.继承结构
　　HashMap直接继承了AbstractMap类，实现了Map<K,V>, Cloneable, Serializable接口，除了这些继承和实现外，它还有一些重要的属性值。简单看一下：
　　　　DEFAULT_INITIAL_CAPACITY：默认的初始化容量（16）；
　　　　MAXIMUM_CAPACITY：能够允许的最大容量（1 << 30）；
　　　　DEFAULT_LOAD_FACTOR：缺省的加载因子（0.75）；
　　　　Entry[] table：存储具体的值。
　　　　transient int size：记录Map的大小。
　　　　final float loadFactor：加载因子。
上面的属性中除了一个Entry类型，这个是什么意思呢。原来这里面就是维护Map键值的类，用来存储Map的具体值的，让我们来看下它的具体实现结构：
```
```java
static
```
```java
class
```
```java
Entry<K,V>
```
```java
implements
```
```java
Map.Entry<K,V>
 {
```
```java
```
```java
final
```
```java
K
 key;
```
```java
```
```java
V
 value;
```
```java
```
```java
Entry<K,V>
 next;
```
```java
```
```java
final
```
```java
int
```
```java
hash;
```
```java
```
```java
/**
```
```java
```
```java
*
 Creates new entry.
```
```java
```
```java
*/
```
```java
```
```java
Entry(
```
```java
int
```
```java
h,
 K k, V v, Entry<K,V> n) {
```
```java
```
```java
value
 = v;
```
```java
```
```java
next
 = n;
```
```java
```
```java
key
 = k;
```
```java
```
```java
hash
 = h;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
K
 getKey() {
```
```java
```
```java
return
```
```java
key;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
V
 getValue() {
```
```java
```
```java
return
```
```java
value;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
V
 setValue(V newValue) {
```
```java
```
```java
V
 oldValue = value;
```
```java
```
```java
value
 = newValue;
```
```java
```
```java
return
```
```java
oldValue;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
boolean
```
```java
equals(Object
 o) {
```
```java
```
```java
if
```
```java
(!(o
```
```java
instanceof
```
```java
Map.Entry))
```
```java
```
```java
return
```
```java
false
```
```java
;
```
```java
```
```java
Map.Entry
 e = (Map.Entry)o;
```
```java
```
```java
Object
 k1 = getKey();
```
```java
```
```java
Object
 k2 = e.getKey();
```
```java
```
```java
if
```
```java
(k1
 == k2 || (k1 !=
```
```java
null
```
```java
&&
 k1.equals(k2))) {
```
```java
```
```java
Object
 v1 = getValue();
```
```java
```
```java
Object
 v2 = e.getValue();
```
```java
```
```java
if
```
```java
(v1
 == v2 || (v1 !=
```
```java
null
```
```java
&&
 v1.equals(v2)))
```
```java
```
```java
return
```
```java
true
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
false
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
int
```
```java
hashCode()
 {
```
```java
```
```java
return
```
```java
(key==
```
```java
null
```
```java
?
```
```java
0
```
```java
:
 key.hashCode()) ^
```
```java
```
```java
(value==
```
```java
null
```
```java
?
```
```java
0
```
```java
:
 value.hashCode());
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
final
```
```java
String
 toString() {
```
```java
```
```java
return
```
```java
getKey()
 +
```
```java
"="
```
```java
+
 getValue();
```
```java
```
```java
}
```
```java
```
```java
/**
```
```java
```
```java
*
 This method is invoked whenever the value in an entry is
```
```java
```
```java
*
 overwritten by an invocation of put(k,v) for a key k that's already
```
```java
```
```java
*
 in the HashMap.
```
```java
```
```java
*/
```
```java
```
```java
void
```
```java
recordAccess(HashMap<K,V>
 m) {
```
```java
```
```java
}
```
```java
```
```java
/**
```
```java
```
```java
*
 This method is invoked whenever the entry is
```
```java
```
```java
*
 removed from the table.
```
```java
```
```java
*/
```
```java
```
```java
void
```
```java
recordRemoval(HashMap<K,V>
 m) {
```
```java
```
```java
}
```
```java
```
```java
}
```
```
　　Entry<K,V> 实现了Map接口中的内部接口Map.Entry<K,V>，key,value分别用来存储键值的， Entry<K,V> next还指向了下一个节点的指针，说明Map的存储空间不是连续的可以使分散的。Hash属性说明键的位置是根据Hash值算出来的。需要注意的是这是作为HashMap的内部类出现的。此外还有内部类KeySet，Values、EntrySet、ValueIterator、KeyIterator、EntryIterator不过通过类名称就可以知道他们的具体作用了吧。
### 3.源码解析
### 　　a:构造函数
```
```java
public
```
```java
HashMap(
```
```java
int
```
```java
initialCapacity,
```
```java
float
```
```java
loadFactor)
 {
```
```java
```
```java
if
```
```java
(initialCapacity
 <
```
```java
0
```
```java
)
```
```java
```
```java
throw
```
```java
new
```
```java
IllegalArgumentException(
```
```java
"Illegal
 initial capacity: "
```
```java
+
```
```java
```
```java
initialCapacity);
```
```java
```
```java
if
```
```java
(initialCapacity
 > MAXIMUM_CAPACITY)
```
```java
```
```java
initialCapacity
 = MAXIMUM_CAPACITY;
```
```java
```
```java
if
```
```java
(loadFactor
 <=
```
```java
0
```
```java
||
 Float.isNaN(loadFactor))
```
```java
```
```java
throw
```
```java
new
```
```java
IllegalArgumentException(
```
```java
"Illegal
 load factor: "
```
```java
+
```
```java
```
```java
loadFactor);
```
```java
```
```java
//
 Find a power of 2 >= initialCapacity
```
```java
```
```java
int
```
```java
capacity
 =
```
```java
1
```
```java
;
```
```java
```
```java
while
```
```java
(capacity
 < initialCapacity)
```
```java
```
```java
capacity
 <<=
```
```java
1
```
```java
;
```
```java
```
```java
this
```
```java
.loadFactor
 = loadFactor;
```
```java
```
```java
threshold
 = (
```
```java
int
```
```java
)(capacity
 * loadFactor);
```
```java
```
```java
table
 =
```
```java
new
```
```java
Entry[capacity];
```
```java
```
```java
init();
```
```java
```
```java
}
```
```java
public
```
```java
HashMap(
```
```java
int
```
```java
initialCapacity)
 {
```
```java
```
```java
this
```
```java
(initialCapacity,
 DEFAULT_LOAD_FACTOR);
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
HashMap()
 {
```
```java
```
```java
this
```
```java
.loadFactor
 = DEFAULT_LOAD_FACTOR;
```
```java
```
```java
threshold
 = (
```
```java
int
```
```java
)(DEFAULT_INITIAL_CAPACITY
 * DEFAULT_LOAD_FACTOR);
```
```java
```
```java
table
 =
```
```java
new
```
```java
Entry[DEFAULT_INITIAL_CAPACITY];
```
```java
```
```java
init();
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
HashMap(Map<?
```
```java
extends
```
```java
K,
 ?
```
```java
extends
```
```java
V>
 m) {
```
```java
```
```java
this
```
```java
(Math.max((
```
```java
int
```
```java
)
 (m.size() / DEFAULT_LOAD_FACTOR) +
```
```java
1
```
```java
,
```
```java
```
```java
DEFAULT_INITIAL_CAPACITY),
 DEFAULT_LOAD_FACTOR);
```
```java
```
```java
putAllForCreate(m);
```
```java
```
```java
}
```
```java
```
```java
void
```
```java
init()
 {
```
```java
```
```java
}
```
```java
```
```java
private
```
```java
void
```
```java
putAllForCreate(Map<?
```
```java
extends
```
```java
K,
 ?
```
```java
extends
```
```java
V>
 m) {
```
```java
```
```java
for
```
```java
(Iterator<?
```
```java
extends
```
```java
Map.Entry<?
```
```java
extends
```
```java
K,
 ?
```
```java
extends
```
```java
V>>
 i = m.entrySet().iterator(); i.hasNext(); ) {
```
```java
```
```java
Map.Entry<?
```
```java
extends
```
```java
K,
 ?
```
```java
extends
```
```java
V>
 e = i.next();
```
```java
```
```java
putForCreate(e.getKey(),
 e.getValue());
```
```java
```
```java
}
```
```java
```
```java
}
```
```
　　构造方法只需要说明第一个的即可，其他的都是传递一些缺省的参数值然后调用第一个构造方法实现具体的操作。重点看下第一个构造方法。它首先判断一下传入的容量是否合法以及加载因子是否合法。如果容量操作最大值是需要将它重置的，但是如果传入的值为负数是要抛出异常的。然后根据容量与加载因子的乘积得出临界值并且赋值给属性threshold，然后通过 table = new Entry[capacity]分配存储空间，完成了构造过程。Init()方法为空，不知道做了什么事情。
### 2.hash(int  h)
```
```java
static
```
```java
int
```
```java
hash(
```
```java
int
```
```java
h)
 {
```
```java
```
```java
//
 This function ensures that hashCodes that differ only by
```
```java
```
```java
//
 constant multiples at each bit position have a bounded
```
```java
```
```java
//
 number of collisions (approximately 8 at default load factor).
```
```java
```
```java
h
 ^= (h >>>
```
```java
20
```
```java
)
 ^ (h >>>
```
```java
12
```
```java
);
```
```java
```
```java
return
```
```java
h
 ^ (h >>>
```
```java
7
```
```java
)
 ^ (h >>>
```
```java
4
```
```java
);
```
```java
```
```java
}
```
```
　　根据Hash 值确定键的位置，如果传入的为null,那么返回的hash值就是为0，索引值就是0.
### 3.size(),isEmpty()
```
```java
public
```
```java
int
```
```java
size()
 {
```
```java
```
```java
return
```
```java
size;
```
```java
```
```java
}
```
```java
```
```java
/**
```
```java
```
```java
*
 Returns <tt>true</tt> if this map contains no key-value mappings.
```
```java
```
```java
*
```
```java
```
```java
*
 @return <tt>true</tt> if this map contains no key-value mappings
```
```java
```
```java
*/
```
```java
```
```java
public
```
```java
boolean
```
```java
isEmpty()
 {
```
```java
```
```java
return
```
```java
size
 ==
```
```java
0
```
```java
;
```
```java
```
```java
}
```
```
　　Map大小就是直接返回属性值size的值，判断是否为空就是如果size为0说明为空否则不为空。
### 4.get(Object)
```
```java
public
```
```java
V
 get(Object key) {
```
```java
```
```java
if
```
```java
(key
 ==
```
```java
null
```
```java
)
```
```java
```
```java
return
```
```java
getForNullKey();
```
```java
```
```java
int
```
```java
hash
 = hash(key.hashCode());
```
```java
```
```java
for
```
```java
(Entry<K,V>
 e = table[indexFor(hash, table.length)];
```
```java
```
```java
e
 !=
```
```java
null
```
```java
;
```
```java
```
```java
e
 = e.next) {
```
```java
```
```java
Object
 k;
```
```java
```
```java
if
```
```java
(e.hash
 == hash && ((k = e.key) == key || key.equals(k)))
```
```java
```
```java
return
```
```java
e.value;
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
null
```
```java
;
```
```java
}
```
```
　　根据键返回对应的值，首先判断键是否为null，如果为空的话就调用getForNullKey(）返回空键对应的值只会有一个。其实也就是返回Map的第一个值，因为null对应的hash值为0，存储位置就是第一个。然后调用hash（）方法返回唯一对应的hash值，然后再循环遍历这个Map，如果发现Hash值相等就直接返回它的值，如果没有发现对应的值就返回null.
### 5.containsKey(Object ）
```
```java
public
```
```java
boolean
```
```java
containsKey(Object
 key) {
```
```java
```
```java
return
```
```java
getEntry(key)
 !=
```
```java
null
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
final
```
```java
Entry<K,V>
 getEntry(Object key) {
```
```java
```
```java
int
```
```java
hash
 = (key ==
```
```java
null
```
```java
)
 ?
```
```java
0
```
```java
:
 hash(key.hashCode());
```
```java
```
```java
for
```
```java
(Entry<K,V>
 e = table[indexFor(hash, table.length)];
```
```java
```
```java
e
 !=
```
```java
null
```
```java
;
```
```java
```
```java
e
 = e.next) {
```
```java
```
```java
Object
 k;
```
```java
```
```java
if
```
```java
(e.hash
 == hash &&
```
```java
```
```java
((k
 = e.key) == key || (key !=
```
```java
null
```
```java
&&
 key.equals(k))))
```
```java
```
```java
return
```
```java
e;
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
null
```
```java
;
```
```java
```
```java
}
```
```
　　判断是否含有某个值就是首先获取这个值，如果获取的值不为空就说么这个对象是存在的。获取key的方法是根据getKey()方法来实现的。首先获取Hash值，然后遍历循环这个Entry数组，如果遇到键相同就返回否则就返回为null.
### 6.put(K，V)
```
```java
public
```
```java
V
 put(K key, V value) {
```
```java
```
```java
if
```
```java
(key
 ==
```
```java
null
```
```java
)
```
```java
```
```java
return
```
```java
putForNullKey(value);
```
```java
```
```java
int
```
```java
hash
 = hash(key.hashCode());
```
```java
```
```java
int
```
```java
i
 = indexFor(hash, table.length);
```
```java
```
```java
for
```
```java
(Entry<K,V>
 e = table[i]; e !=
```
```java
null
```
```java
;
 e = e.next) {
```
```java
```
```java
Object
 k;
```
```java
```
```java
if
```
```java
(e.hash
 == hash && ((k = e.key) == key || key.equals(k))) {
```
```java
```
```java
V
 oldValue = e.value;
```
```java
```
```java
e.value
 = value;
```
```java
```
```java
e.recordAccess(
```
```java
this
```
```java
);
```
```java
```
```java
return
```
```java
oldValue;
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
modCount++;
```
```java
```
```java
addEntry(hash,
 key, value, i);
```
```java
```
```java
return
```
```java
null
```
```java
;
```
```java
```
```java
}
```
```java
void
```
```java
addEntry(
```
```java
int
```
```java
hash,
 K key, V value,
```
```java
int
```
```java
bucketIndex)
 {
```
```java
```
```java
Entry<K,V>
 e = table[bucketIndex];
```
```java
```
```java
table[bucketIndex]
 =
```
```java
new
```
```java
Entry<K,V>(hash,
 key, value, e);
```
```java
```
```java
if
```
```java
(size++
 >= threshold)
```
```java
```
```java
resize(
```
```java
2
```
```java
*
 table.length);
```
```java
```
```java
}
```
```java
```
```java
void
```
```java
resize(
```
```java
int
```
```java
newCapacity)
 {
```
```java
```
```java
Entry[]
 oldTable = table;
```
```java
```
```java
int
```
```java
oldCapacity
 = oldTable.length;
```
```java
```
```java
if
```
```java
(oldCapacity
 == MAXIMUM_CAPACITY) {
```
```java
```
```java
threshold
 = Integer.MAX_VALUE;
```
```java
```
```java
return
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
Entry[]
 newTable =
```
```java
new
```
```java
Entry[newCapacity];
```
```java
```
```java
transfer(newTable);
```
```java
```
```java
table
 = newTable;
```
```java
```
```java
threshold
 = (
```
```java
int
```
```java
)(newCapacity
 * loadFactor);
```
```java
```
```java
}
```
```
　　我们是通过put（K,V）方法来添加对象到Map中的，首先判断传入的Key是否为null，如果为null就直接调用putForNullKey(value)方法将null的键对应上值。如果不为空就首先获取K对应的Hash值,然后遍历循环这个Map，如果值已经存在就更新覆盖value并且返回返回老的value，否则的话就调用addEntry(hash, key, value, i);插入新值。插入及很简单了，New一个Entry对象然后确定数组位置指定值即可。
## 4.其他
　　HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量是哈希表中数据的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的数目。
