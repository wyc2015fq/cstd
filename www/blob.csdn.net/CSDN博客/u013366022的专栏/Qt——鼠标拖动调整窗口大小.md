# Qt——鼠标拖动调整窗口大小 - u013366022的专栏 - CSDN博客
2016年09月05日 17:21:12[slitaz](https://me.csdn.net/u013366022)阅读数：5067
要求：鼠标移到界面边角时，鼠标样式相应地发生改变。
# 实现方法一：
重写mouseMoveEvent，如果鼠标没有按下，则根据鼠标在界面上的位置设置鼠标样式，如果鼠标按下，则根据位置判断该怎样调整界面大小，或者是拖动界面。思路如上，实现起来很简单。但是存在一个问题，如果界面中放了一些其它控件，比如listWidget，此时鼠标在界面边缘移动速度稍微快一些，mouseMoveEvent就会被子控件截获了，鼠标样式不会改变，对于该方法的这个问题，我还没想到好的解决办法。
# 实现方法二：
在Qt中处理windows事件，具体实现如下，参考网上一些内容，我顺便修改优化了一下，源代码如下：
```
```cpp
#ifndef
 MBASEWIDGET_H
```
```cpp
#define
 MBASEWIDGET_H
```
```cpp
#include
 <QtWidgets/QWidget>
```
```cpp
#include
 "windows.h"
```
```cpp
class
```
```cpp
MBaseWidget
 :
```
```cpp
public
```
```cpp
QWidget
```
```cpp
{
```
```cpp
```
```cpp
Q_OBJECT
```
```cpp
public
```
```cpp
:
```
```cpp
```
```cpp
MBaseWidget(QWidget
 *parent);
```
```cpp
```
```cpp
~MBaseWidget();
```
```cpp
```
```cpp
void
```
```cpp
setMarginWidth(
```
```cpp
const
```
```cpp
int
```
```cpp
&);
```
```cpp
//设置鼠标可以在界面边缘多大范围内拖动改变界面大小
```
```cpp
```
```cpp
void
```
```cpp
serResizable(
```
```cpp
bool
```
```cpp
);
```
```cpp
//设置是否可以拖动改变大小
```
```cpp
protected
```
```cpp
:
```
```cpp
```
```cpp
bool
```
```cpp
nativeEvent(
```
```cpp
const
```
```cpp
QByteArray
 & eventType,
```
```cpp
void
```
```cpp
*
 message,
```
```cpp
long
```
```cpp
*
 result);
```
```cpp
```
```cpp
bool
```
```cpp
winEvent(MSG
 *message,
```
```cpp
long
```
```cpp
*result);
```
```cpp
private
```
```cpp
:
```
```cpp
```
```cpp
int
```
```cpp
m_iMarginWidth;
```
```cpp
```
```cpp
bool
```
```cpp
m_bCanResize;
```
```cpp
};
```
```cpp
#endif
 // MBASEWIDGET_H
```
```
```
```cpp
#include
 "MBaseWidget.h"
```
```cpp
#include
 "windowsx.h"
```
```cpp
MBaseWidget::MBaseWidget(QWidget
 *parent)
```
```cpp
```
```cpp
:
 QWidget(parent)
```
```cpp
{
```
```cpp
```
```cpp
m_iMarginWidth
 = 3;
```
```cpp
```
```cpp
m_bCanResize
 =
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
setWindowFlags(Qt::FramelessWindowHint);
```
```cpp
}
```
```cpp
MBaseWidget::~MBaseWidget()
```
```cpp
{
```
```cpp
}
```
```cpp
void
```
```cpp
MBaseWidget::setMarginWidth(
```
```cpp
const
```
```cpp
int
```
```cpp
&iWidth)
```
```cpp
{
```
```cpp
```
```cpp
m_iMarginWidth
 = iWidth;
```
```cpp
}
```
```cpp
void
```
```cpp
MBaseWidget::serResizable(
```
```cpp
bool
```
```cpp
bCanResize)
```
```cpp
{
```
```cpp
```
```cpp
m_bCanResize
 = bCanResize;
```
```cpp
}
```
```cpp
//处理windows事件，在QT5中，被函数nativeEvent取代
```
```cpp
bool
```
```cpp
MBaseWidget::winEvent(MSG
 *message,
```
```cpp
long
```
```cpp
*result)
```
```cpp
{
```
```cpp
```
```cpp
switch
```
```cpp
(message->message)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
case
```
```cpp
WM_NCHITTEST:
```
```cpp
```
```cpp
int
```
```cpp
iPosX
 = GET_X_LPARAM(message->lParam) -
```
```cpp
this
```
```cpp
->frameGeometry().x();
```
```cpp
//鼠标位置x
```
```cpp
```
```cpp
int
```
```cpp
iPosY
 = GET_Y_LPARAM(message->lParam) -
```
```cpp
this
```
```cpp
->frameGeometry().y();
```
```cpp
//鼠标位置y
```
```cpp
```
```cpp
*result
 = HTCAPTION;
```
```cpp
```
```cpp
if
```
```cpp
(!m_bCanResize)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
//返回为真，此时仍可拖动，但无法改变大小
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
if
```
```cpp
(iPosX
 >= 0 && iPosX <= m_iMarginWidth)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTLEFT;
```
```cpp
//左
```
```cpp
```
```cpp
int
```
```cpp
iHeight
 =
```
```cpp
this
```
```cpp
->height();
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= 0 && iPosY <= m_iMarginWidth)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTTOPLEFT;
```
```cpp
//左上
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= iHeight - m_iMarginWidth && iPosY <= iHeight)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTBOTTOMLEFT;
```
```cpp
//左下
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
int
```
```cpp
iWidth
 =
```
```cpp
this
```
```cpp
->width();
```
```cpp
```
```cpp
int
```
```cpp
iHeight
 =
```
```cpp
this
```
```cpp
->height();
```
```cpp
```
```cpp
if
```
```cpp
(iPosX
 >= iWidth - m_iMarginWidth && iPosX <= iWidth)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTRIGHT;
```
```cpp
//右
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= 0 && iPosY <= m_iMarginWidth)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTTOPRIGHT;
```
```cpp
//右上
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= iHeight - m_iMarginWidth && iPosY <= iHeight)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTBOTTOMRIGHT;
```
```cpp
//右下
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= 0 && iPosY <= m_iMarginWidth)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTTOP;
```
```cpp
//上
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
if
```
```cpp
(iPosY
 >= iHeight - m_iMarginWidth && iPosY <= iHeight)
```
```cpp
```
```cpp
{
```
```cpp
```
```cpp
*result
 = HTBOTTOM;
```
```cpp
//下
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
true
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
false
```
```cpp
;
```
```cpp
}
```
```cpp
bool
```
```cpp
MBaseWidget::nativeEvent(
```
```cpp
const
```
```cpp
QByteArray
 &eventType,
```
```cpp
void
```
```cpp
*message,
```
```cpp
long
```
```cpp
*result)
```
```cpp
{
```
```cpp
```
```cpp
return
```
```cpp
winEvent((MSG*)message,
 result);
```
```cpp
}
```
```
这种方法是借助windows来实现的，所以受系统的限制，比如，拖动放大到与屏幕一样大时，就不能继续放大了，而且其它类直接继承这个类可能会出现问题。
# 实现方法三：
既然通过mouseMoveEvent不能解决鼠标的样式问题，那么可以考虑通过其它事件来实现，下面是我实现的一个类，包括头文件、dll和lib文件。
在VS中项目属性-链接器中进行相关配置即可。
[点击下载](http://files.cnblogs.com/files/hellovenus/MoveWidget.zip)
