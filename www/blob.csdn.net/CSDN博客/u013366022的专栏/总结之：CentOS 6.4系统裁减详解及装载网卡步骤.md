# 总结之：CentOS 6.4系统裁减详解及装载网卡步骤 - u013366022的专栏 - CSDN博客
2014年12月09日 16:44:33[slitaz](https://me.csdn.net/u013366022)阅读数：390
原创作品，允许转载，转载时请务必以超链接形式标明文章 [原始出处](http://tanxw.blog.51cto.com/4309543/1368801) 、作者信息和本声明。否则将追究法律责任。[http://tanxw.blog.51cto.com/4309543/1368801](http://tanxw.blog.51cto.com/4309543/1368801)
前言
   随着接触Linux的慢慢深入、对Linux也有了一个基本认识了吧，慢慢的接触系统内核、系统配置文件、在了解Linux的系统启动流程后，现在来总结一下一个简单的Linux系统的裁减方法和步骤，一个只有内核文件和几个简单的命令的小Linux系统，现在就开始以下裁减：
正文 
   首先在一个虚拟机上新增一块硬盘、这样等裁减好了之后可以把这块硬盘挂载到别的虚拟机上去、运行自已裁减的那个Linux系统；
![wKioL1MW6cOB-EHAAAGPeEDJ9iQ811.jpg](http://s3.51cto.com/wyfs02/M00/1C/61/wKioL1MW6cOB-EHAAAGPeEDJ9iQ811.jpg)
![wKioL1MW6cejrXyuAAIgtdPsFkM192.jpg](http://s3.51cto.com/wyfs02/M01/1C/61/wKioL1MW6cejrXyuAAIgtdPsFkM192.jpg)
![wKiom1MW6e-B2P3OAAF9-XUwsEc625.jpg](http://s3.51cto.com/wyfs02/M00/1C/60/wKiom1MW6e-B2P3OAAF9-XUwsEc625.jpg)
![wKioL1MW6c6Ss1qjAAEZKYfTnis903.jpg](http://s3.51cto.com/wyfs02/M00/1C/61/wKioL1MW6c6Ss1qjAAEZKYfTnis903.jpg)
![wKioL1MW6duSTyg1AAEumrbayV0149.jpg](http://s3.51cto.com/wyfs02/M02/1C/61/wKioL1MW6duSTyg1AAEumrbayV0149.jpg)
   添加完硬盘后就启动虚拟机了；    
   查找一下刚才添加的硬盘：
   # fdisk -l /dev/sd[a-z]
![wKioL1MW6mzz2W_CAAD0OCsStpg036.jpg](http://s3.51cto.com/wyfs02/M00/1C/62/wKioL1MW6mzz2W_CAAD0OCsStpg036.jpg)
   添加完硬盘之后就应该分区格式化硬盘了;
   # fdisk /dev/sdb
   这里就自己分区好了、很简单的、比windows简单多了！！！
   分区完后就给这两个分区格式化了；
   格式化指定文件系统类型为ext4
   # mke2fs -t ext4 /dev/sdb1
   # mke2fs -t ext4 /dev/sdb2
![wKioL1MW6xyAIpb_AAB97b2jK_Y110.jpg](http://s3.51cto.com/wyfs02/M00/1C/62/wKioL1MW6xyAIpb_AAB97b2jK_Y110.jpg)
   格式化完了之后就看到刚才分的两个分区列表了；
   而后在/mnt目录下创建两个目录分别挂载到刚分好的那两个分区上去：
   # mkdir -pv /mnt/{boot,sysroot}
   挂载目录/mnt/boot到/dev/sdb1分区上去；
   挂载目录/mnt/sysroot到/dev/sdb2分区上去；
   # mount /dev/sdb1 /mnt/boot/
   # mount /dev/sdb2 /mnt/sysroot/
![wKiom1MW64viHnRKAAEdUcbC910790.jpg](http://s3.51cto.com/wyfs02/M01/1C/62/wKiom1MW64viHnRKAAEdUcbC910790.jpg)
   而后就往sdb上安装grub；
   创建的boot在哪就指定到哪个路径下去，然后再指定安装在哪块硬盘上,grub安装完之后就会生成/mnt/boot/grub/目录、grub目录下就会生成相关的文件
   # grub-install --root-directory=/mnt /dev/sdb
![wKiom1MW67_RaaJFAAE0HARIVEs807.jpg](http://s3.51cto.com/wyfs02/M01/1C/62/wKiom1MW67_RaaJFAAE0HARIVEs807.jpg)
![wKiom1MW7DbCm7Z-AADhvPLKxe8781.jpg](http://s3.51cto.com/wyfs02/M02/1C/62/wKiom1MW7DbCm7Z-AADhvPLKxe8781.jpg)
   现在我们把宿主机里的内核文件给sdb拷贝一份到/mnt/boot/目录下，名字我们就叫mvlinuz、版本号我们就不带了、init文件也拷贝一份到/mnt/boot/目录下，名字就简单的改为initramfs.img
   # cp /boot/vmlinuz-2.6.32-431.el6.x86_64 /mnt/boot/vmlinuz
   # cp /boot/initramfs-2.6.32-431.el6.x86_64.img /mnt/boot/initramfs.img
![wKiom1MW7FXwj2gKAADiJhm3tYc730.jpg](http://s3.51cto.com/wyfs02/M02/1C/62/wKiom1MW7FXwj2gKAADiJhm3tYc730.jpg)
   完整的linux有哪些目录呢、那我们就得来创建一下这些个目录了;之前我们挂载的那个sysroot的目录都没有到、那我们就在这个目录下创建这些目录、切换到/mnt/sysroot/下：
   # mkdir -pv /etc/rc.d root boot dev proc sys tmp var usr srv lib lib64 bin sbin home mnt media
![wKiom1MW7KXhuVHdAABPNoOCSS4284.jpg](http://s3.51cto.com/wyfs02/M01/1C/62/wKiom1MW7KXhuVHdAABPNoOCSS4284.jpg)
   到这里了、如果我们的第二块硬盘上再有个可执行程序是不是就可以运行了呢、那我们不仿移植一些程序到我们的第二块硬盘上去、我们之前写了一个移植可执行程序的脚本、包括程序所依赖的库文件也一并移植过去了、代码如下：
```
```bash
#!/bin/bash
```
```bash
#
```
```bash
#定义目标目录、也就是要拷贝到的那个目录
```
```bash
target=
```
```bash
/mnt/sysroot
```
```bash
#声明清理命令的方法
```
```bash
clearCmd()
 {
```
```bash
```
```bash
#判断命令是否存在、如果不存在就提示没有找到命令
```
```bash
```
```bash
if
```
```bash
which
```
```bash
$cmd
 &>
```
```bash
/dev/null
```
```bash
;
```
```bash
then
```
```bash
```
```bash
#获取命令的路径
```
```bash
```
```bash
cmdPath=`
```
```bash
which
```
```bash
--skip-
```
```bash
alias
```
```bash
$cmd`
```
```bash
```
```bash
else
```
```bash
```
```bash
echo
```
```bash
"No
 such command"
```
```bash
```
```bash
return
```
```bash
5
```
```bash
```
```bash
fi
```
```bash
}
```
```bash
#定义拷贝命令的方法
```
```bash
cmdCopy()
 {
```
```bash
```
```bash
#获取命令路径、只取目录部分
```
```bash
```
```bash
cmdDir=`
```
```bash
dirname
```
```bash
$1`
```
```bash
```
```bash
#判断目录是否存在、不否在就创建
```
```bash
```
```bash
[
 -d ${target}${cmdDir} ] ||
```
```bash
mkdir
```
```bash
-p
 ${target}${cmdDir}
```
```bash
```
```bash
#判断要拷贝的命令否存在在、不存在就拷贝
```
```bash
```
```bash
[
 -f ${target}${1} ] ||
```
```bash
cp
```
```bash
$1
 ${target}${cmdDir}
```
```bash
}
```
```bash
#定义拷贝库文件的方法
```
```bash
libCopy()
 {
```
```bash
```
```bash
#循环所有获得的命令所依赖的所有库文件
```
```bash
```
```bash
for
```
```bash
lib
```
```bash
in
```
```bash
`ldd
 $1 |
```
```bash
grep
```
```bash
-o
```
```bash
"/[^[:space:]]\{1,\}"
```
```bash
`;
```
```bash
do
```
```bash
```
```bash
#取得库文件的目录
```
```bash
```
```bash
libDir=`
```
```bash
dirname
```
```bash
$lib`
```
```bash
```
```bash
#判断库文件的目录是否存在、不存在则创建
```
```bash
```
```bash
[
 -d ${target}${libDir} ] ||
```
```bash
mkdir
```
```bash
-p
 ${target}${libDir}
```
```bash
```
```bash
#判断库文件是否已经存在、不存在就拷贝
```
```bash
```
```bash
[
 -f ${target}${lib} ] ||
```
```bash
cp
```
```bash
$lib
 ${target}${libDir}
```
```bash
```
```bash
done
```
```bash
}
```
```bash
#循环让用户输入要拷贝的命令
```
```bash
while
```
```bash
true
```
```bash
;
```
```bash
do
```
```bash
```
```bash
read
```
```bash
-p
```
```bash
"Enter
 a command: "
```
```bash
cmd
```
```bash
```
```bash
if
```
```bash
[
```
```bash
"$cmd"
```
```bash
==
```
```bash
'quit'
```
```bash
]
 ;
```
```bash
then
```
```bash
```
```bash
echo
```
```bash
"quit"
```
```bash
```
```bash
exit
```
```bash
0
```
```bash
```
```bash
fi
```
```bash
```
```bash
#调用清理命令方法
```
```bash
```
```bash
clearCmd
 $cmd
```
```bash
```
```bash
[
 $? -
```
```bash
eq
```
```bash
5
 ] &&
```
```bash
continue
```
```bash
```
```bash
#调用拷贝命令和库文件的方法
```
```bash
```
```bash
cmdCopy
 $cmdPath
```
```bash
```
```bash
libCopy
 $cmdPath
```
```bash
done
```
```
![wKioL1MW77zCBKyQAAFBsoEDZCE400.jpg](http://s3.51cto.com/wyfs02/M01/1C/66/wKioL1MW77zCBKyQAAFBsoEDZCE400.jpg)
![wKioL1MW8B-SiUDtAACmR-uljKg736.jpg](http://s3.51cto.com/wyfs02/M02/1C/66/wKioL1MW8B-SiUDtAACmR-uljKg736.jpg)
   接着切换到/mnt/sysroot/bin/目录下、给bash创建一个软链接、因为系统默认找shell都是找sh
   # ln -sv bash sh    
   现在我们切换到/mnt/sysroot/目录试一下看就知道了：
   # chroot /mnt/sysroot/
![wKiom1MW8L3gz8-gAACRqZOTlL8973.jpg](http://s3.51cto.com/wyfs02/M02/1C/66/wKiom1MW8L3gz8-gAACRqZOTlL8973.jpg)
   看、我们的小根可以用了    
   这里我们再提供一个init脚本给这个小系统，在/sbin/目录下，这个init要通过调用/etc/inittab这个配置文件，然后再去执行/etc/rc.d/rc.sysinit下的初始化脚本、这样的话那我们就把初始化脚本的内容拿到init里来执行；
   这个脚本到底要做哪些操作呢：
   # vim /mnt/sysroot/sbin/init
```
```bash
#!/bin/bash
```
```bash
#
```
```bash
#打印欢迎信息
```
```bash
echo
```
```bash
-e
```
```bash
"\tWecome
 to \033[34m Mini Linux-2.6 OS\033[0m"
```
```bash
#挂载两个伪文件系统；-t后面跟文件系统类型
```
```bash
mount
```
```bash
-n
 -t proc proc
```
```bash
/proc
```
```bash
mount
```
```bash
-n
 -t sysfs sysfs
```
```bash
/sys
```
```bash
```
```bash
#启动后再以读写方式重新挂载/dev/sda2上,这样的话就要把宿主机关机再后再新运行这个小系统了
```
```bash
mount
```
```bash
-n
 -o remount,rw
```
```bash
/dev/sda2
```
```bash
/
```
```bash
#运行bin下的bash
```
```bash
/bin/bash
```
```
   保存退出后给init一个可执行权限：
   chmod +x /mnt/sysroot/sbin/init
   此时我们就要给这块硬盘上的小系统提供一个grub的配置文件了，如果不写这个配置文件也可以启动、但一进入就会进到grub小shell中让你配置系统的grub信息；
   # vim /mnt/boot/grub/grub.conf
```
```bash
default=0
```
```bash
timeout=5
```
```bash
title
 Mini Linux OS
```
```bash
```
```bash
root(hd0,0)
```
```bash
```
```bash
kernel
```
```bash
/vmlinuz
```
```bash
ro
 root=
```
```bash
/dev/sda2
```
```bash
selinux=0
 init=
```
```bash
/sbin/init
```
```bash
```
```bash
initrd
```
```bash
/initramfs
```
```bash
.img
```
```
   OK，保存退出！        
   同步一下到对应的磁盘上：
   # sync    
   经过以上的操作、下面我们就来创建一个新的虚拟机、然后选择虚拟机使用我们刚才装小系统的那块硬盘、CentOS_SecondSCSI.vmdk；
![wKioL1MW8-CD_ojRAAH2able-f0277.jpg](http://s3.51cto.com/wyfs02/M02/1C/69/wKioL1MW8-CD_ojRAAH2able-f0277.jpg)
   好了、我们把已经运行的虚拟机都挂载起，运行我们刚才创建好的那个有CentOS_SecondSCSI.vmdk磁盘的虚拟机，到这里我们就看到我们裁减的小系统跑起来了、看到我们自己定义的Min Linux-2.6 OS了！    ![wKioL1MW9GLQHBi0AABl_cHytmI133.jpg](http://s3.51cto.com/wyfs02/M01/1C/69/wKioL1MW9GLQHBi0AABl_cHytmI133.jpg)
进到我们的小系统里去了：
![wKiom1MXATDhooQGAABLZHNpUzs579.jpg](http://s3.51cto.com/wyfs02/M01/1C/72/wKiom1MXATDhooQGAABLZHNpUzs579.jpg)
   接下来我们要在小系统里装载网卡、但是要确保被装载的网卡驱动没有使用、我们可以用lsmod这个命令查看一下：这里以e1000为例来说明问题、我这里的虚拟机上已经装有了、那我就先卸载了再装载上去：
   在宿主机上查看当前内核装载的模块信息：
   # lsmod
   卸载e1000网卡驱动：
   # modprobe -r e1000
   要装载的话用下面命令即可：
   # modprobe e1000
   那怎么样把e1000的内核模块拷贝到我们的小系统里面里、让他装上去、并且启用网络功能呢、首先确保我们系统中的piv4没有做成模块，这里我们的ipv4没有做成模块、那就去移植这个模块吧：
   首先给他创建一个目录、切换到/mnt/sysroot/lib目录中：
   # mkdir modules
   再拷贝我们系统上的内核模块到这个目录里去
   # cp /lib/modules/2.6.32-431.el6.x86_64/kernel/drivers/net/e1000/e1000.ko /mnt/sysroot/lib/modules/
   再移植一些所需要用到的命令：insmod、rmmod、ifconfig、ip、ping
   OK、同步一下我们就可以重新启动小系统了
   # sync
   进到小系统里、敲命令吧；
   # insmod /lib/modules/e1000.ko
   # ifocnfig eth0 176.16.251.100/16
   # ping -c 3 176.16.251.100
![wKioL1MXAfLx2_ZuAAFwEvAOYU4644.jpg](http://s3.51cto.com/wyfs02/M02/1C/73/wKioL1MXAfLx2_ZuAAFwEvAOYU4644.jpg)
![wKiom1MXA0LRw9JvAADu3n6P1sw699.jpg](http://s3.51cto.com/wyfs02/M02/1C/73/wKiom1MXA0LRw9JvAADu3n6P1sw699.jpg)
![wKioL1MXAxzjKk7rAAFg5pXqsEk919.jpg](http://s3.51cto.com/wyfs02/M01/1C/74/wKioL1MXAxzjKk7rAAFg5pXqsEk919.jpg)
   好了、到这里我们就基本完成了小系统的裁减了、要想装载更多的功能、后面可以自己再添加、想装什么就装什么、要想系统启动就有网络那可以在init中设置一下、在init中加上ifconfig eth0 176.16.251.100/16就可以了、init要写得更好自己后期再慢慢改吧、加慢判断和显示颜色什么的等等：
结语：
   好像东西很多的样子、其实也不是很多了、可能我比较啰嗦、噼里啪啦的写了一大堆吧、其实操作也不多、就是要理清步骤就很清晰了、不是吗、好吧、就到此结束吧、人无完人、有错或有什么不妥还望大神指点哦！
