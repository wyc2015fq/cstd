# 利用正则表达式排除特定字符串 - z69183787的专栏 - CSDN博客
2016年12月24日 10:32:07[OkidoGreen](https://me.csdn.net/z69183787)阅读数：9796
个人分类：[正则表达式](https://blog.csdn.net/z69183787/article/category/2175421)

可参考：http://blog.csdn.net/zxy6173/article/details/4229719
正则在线测试：http://www.regexpal.com/
匹配log中包含ERROR但不包含XXX字符串的 log
^.*ERROR(?!.*exceed.*)
exceed可替换为任意字符串
核心：使用了正则表达式 预搜索与反向预搜索的功能
阅读目录
- [查找不以baidu开头的字符串](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_label0)
- [查找不以com结尾的字符串](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_label1)
- [查找不含有if的行](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_label2)
[回到顶部](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_labelTop)
### 查找不以baidu开头的字符串
baidu.com
sina.com.cn
正则：^(?!baidu).*$  匹配结果就是第2行，也就是第1行被排除了
这里使用了零宽度断言(?!exp),注意，我们有一个向前查找的语法(也叫顺序环视)  (?=exp)
(?=exp) 会查找exp之前的【位置】如果将等号换成感叹号，就变成了否定语义，也就是说查找的位置的后面不能是exp
一般情况下?!要与特定的锚点相结合，例如^行开头或者$行结尾，那么上面的例子的意思如下：
^(?!baidu).*$ 先匹配一个行开头的位置，并且要求接下来的位置的后面不是baidu这个字符串。这样由于第一行^之后的位置后面是baidu所以匹配失败，被排除在外了。
[回到顶部](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_labelTop)
### 查找不以com结尾的字符串
www.sina.com.cn
www.educ.org
www.hao.cc
www.baidu.com
www.123.com
正则 ^.*?(?<!com)$  匹配前3行结果。
如果查找以com结尾的字符串则使用正则 ^.*?(?<=com)$或者 ^.*?com$  
对正则表达式的解释：^.*?(?<!com)$
首先匹配行开头，然后是 .*? 这个是忽略优先，也就是优先忽略不匹配任何字符，(?<!com) 这个是一个逆序环视的否定形式，意思是匹配一个位置此位置的前面不能是字符串com，最后是一个行结束。对于www.123.com来说，首先匹配行首，接着匹配w后面的位置，发现前面不是com，所以成功但紧接着要匹配行尾，失败，回溯让.*? 匹配一个w符号，接着(?<com)匹配第二个w后面的位置，发现前面也不是com匹配成功，紧接着要匹配$对应的行尾失败，一直到.*?匹配了www.baidu.com的时候，此时(?<!com)匹配m后面的位置，此时此位置的前面是com匹配直接失败,接着.*?匹配行末尾，(?<!com)匹配$后面的位置，显然这次也失败了，所以整个全局匹配都失败。 
 www.123.com被排除到匹配之外。这里的.*后面加不加问号结果都一样。
[回到顶部](http://www.cnblogs.com/wangqiguo/archive/2012/05/08/2486548.html#_labelTop)
### 查找不含有if的行
if (a>b)
printf("hello");
else if(a<b)
printf("hello2");
else
printf("hello3");
正则 ^([^f]|[^i]f)+$
其实这个匹配也是一个排除型字符串的匹配，但是不同于上面两种，因为这里的if可能既不在行开头，也不在行结尾，而是在字符串中间这样就给匹配带来了麻烦，在正则表达式中没有提供类似排除的功能。我们最容易想到的就是下面的正则：
^[^if]+$ 这种写法看起来是那么回事，但是排除型字符组排除的是i和f两个字符，而不是if这个字符串，所以这个正则表达式匹配的是那些既没有i字符也不包含f字符的字符串。但是如果字符串中有一个i或多个i或者有一个或多个f，或者i和f字符都有只不过没有连在一起。这些情况都是我们需要匹配的情况，而我们不能匹配的情况是那些包含if字符串的行，而不是包含i或f字符的行，所以这种写法漏洞很大。
^.*(?!if).*$ 这种写法使用了零宽度断言，表面意思看起来好像是说 任意字符+非if+任意字符 组成了整个字符串，但是仔细研究匹配过程就知道这个是错的，(?if)匹配的是一个位置，所以对于字符串aifb他也是可以匹配到的，而实际上这样的字符正是我们不要的。按照这个正则表达式，对于aifb 首先匹配行首，其次.*是贪婪模式(匹配优先)，会一直匹配到字符串的末尾(此时传动装置定位在$位置前面)，此时(?!if)需要匹配一个位置，这个位置的后面不能是if，这个时候正好位置在b字符的后面，符合匹配条件，紧接着匹配行尾，到这里整个全局匹配成功。
也就是说对于一个字符串例如我要排除abc这个字串，那么对于任意一个字符串   helloworld abc helloworld 在匹配的时候(?!abc)可以匹配h、e、l、l、o、w、o、r、l、d等这些字符后面的位置，都是成功的。所以匹配根本还没有进行到abc这个地方，(?!abc)就会匹配成功。这个时候根本起不到排除的作用，为什么上面的第1和第2个例子可以呢，因为他们的位置有行首和行尾限定。例如我要匹配行首不是abc的话，那么此时^(?!abc) 这个时候(?!abc)实际上在匹配的时候其传动装置的位置被行首进行了限定,所以对于那些以abc开头的字符串来说就会匹配失败了。
对于正则表达式^.*(?!abc).*$怎么能让第一个.*匹配到 helloworldabcxxx中的helloworld的问题。
对于上面的题目，我们的答案是^([^f]|[^i]f)+$  其实就将所有的匹配分成了2种情况，一种情况是假设字符串中没有f字符，    自然就不可能有if字符串了，这种情况下匹配的字符串中是不可能有if的。第二种情况就是有f字符，但是我们要求此时f的前面不能是i，所以在有f和没有f两种情况都考虑到的情况下，这个正则就应该可以满足所有的情况了。
其实这个问题的解答是不完美的，对于排除的字符串if只有2个字符i和f字符，我们可以使用这种方式，但是如果我们要排除的是字符串helloworld，这种方法显然就不实用了，那要考虑到多少种情况呢?
排除不含有某字符串的最终方案：在这种情况下我们使用  ^(?!.*helloworld).*$  正则表达式  我们将第一个.*移到了零宽度断言的里面。在匹配的时候首先匹配行首的位置，然后接下来是匹配行首后面的位置，要求此位置的后面不能是    .*helloworld 匹配的字符串，说白了要求此位置的后面不能是xxxxxxxxxxxxxxxxxxhelloworld
 类似的字符串，这样就排除了从行首开始后面含有helloworld的情况了。
**预搜索：**
在看正则的时候中碰到一个这样的正则问题.
将 一句SQL语句中的“select”和“from” 之间的字符替换为 “count(*)”
问题很简单,我的答案是
代 码:
<?php
$sql = "select uid,sas,fd from asdf";
echo preg_replace("/select(.+?)from/i",'select count(*) from',$sql);
?>
但是看了别人的答案却十分的简单
代码:
echo preg_replace("/(?<=select).+?(?=from)/i",' count(*) ',$sql);
其中的?<=让我很不解.从资料上查得到:
代码:
(?<=select).+?(?=from)表示的是匹配从select开始到from结束中间的数据.
正向预搜索："(?=xxxxx)"，"(?!xxxxx)"
反向预搜索："(?<=xxxxx)"，"(?<!xxxxx)"
正向预搜索："(?=xxxxx)"，"(?!xxxxx)"
格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的 "缝隙" 或者 "两头" 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 "\b"，本身不匹配任何字符。"\b" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
举例1：表达式 "Windows (?=NT|XP)" 在匹配 "Windows 98, Windows NT, Windows 2000" 时，将只匹配 "Windows NT" 中的 "Windows "，其他的 "Windows " 字样则不被匹配。
举例2：表达式 "(\w)((?=\1\1\1)(\1))+" 在匹配字符串 "aaa ffffff 999999999" 时，将可以匹配6个"f"的前4个，可以匹配9个"9"的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当 然，这个表达式可以不这样写，在此的目的是作为演示之用。
格式："(?!xxxxx)"，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。
举例3：表达式 "((?!\bstop\b).)+" 在匹配 "fdjka ljfdl stop fjdsla fdj" 时，将从头一直匹配到 "stop" 之前的位置，如果字符串中没有 "stop"，则匹配整个字符串。
举例4：表达式 "do(?!\w)" 在匹配字符串 "done, do, dog" 时，只能匹配 "do"。在本条举例中，"do" 后边使用 "(?!\w)" 和使用 "\b" 效果是一样的。
反向预搜索："(?<=xxxxx)"，"(?<!xxxxx)"
这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 "左侧"，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 "正向预搜索" 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。
举例5：表达式 "(?<=\d{4})\d+(?=\d{4})" 在匹配 "1234567890123456" 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。
