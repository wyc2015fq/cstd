# 同步异步阻塞非阻塞Reactor模式和Proactor模式 （目前JAVA的NIO就属于同步非阻塞IO） - z69183787的专栏 - CSDN博客
2016年09月20日 11:31:35[OkidoGreen](https://me.csdn.net/z69183787)阅读数：1374
在高性能的 I/O 设计中，有两个比较著名的模式 Reactor 和 Proactor 模式，其中 Reactor 模式用于同步 I/O ，而 Proactor 运用于异步 I/O 操作。
       在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步 , 同步和异步 是针对应用程序和内核的交互而言的 ，同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会 立即 返回一个状态值。
   一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 IO
    同步阻塞 IO ：
   在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。 JAVA传统的 IO 模型属于此种方式！
    同步非阻塞 IO:
在此种方式下，用户进程发起一个 IO 操作以后 边可 返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO 。
    异步阻塞 IO ：
   此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！
    异步非阻塞 IO:
   在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为 真正的 IO读取或者写入操作已经由 内核完成了。目前 Java 中还没有支持此种 IO 模型。
搞清楚了以上概念以后，我们再回过头来看看， Reactor 模式和 Proactor 模式。
首先来看看 Reactor 模式， Reactor 模式应用于同步 I/O 的场景。我们分别以读操作和写操作为例来看看 Reactor 中的具体步骤：
读取操作 ：
1.  应用程序注册读就需事件和相关联的事件处理器
2.  事件分离器等待事件的发生
3.  当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器
4.  事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理
写入操作类似于读取操作，只不过第一步注册的是写 就绪 事件。
下面我们来看看 Proactor 模式中读取操作和写入操作的过程：
读取操作：
1.  应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取 就绪 事件，而是关注读取完成事件，这是区别于 Reactor 的关键。
2.  事件分离器等待读取操作完成事件
3.  在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于 Reactor 的一点， Proactor 中，应用程序需要传递缓存区。
4.  事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。
Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。
从上面可以看出， Reactor 和 Proactor 模式的主要区别就是真正的读取和写入操作是有谁来完成的， Reactor 中需要应用程序自己读取或者写入数据，而 Proactor 模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的 IO 设备 .
          综上所述，同步和异步是相对于应用和内核的交互方式而言的，同步 需要主动去询问，而异步的时候内核在 IO 事件发生的时候通知应用程序，而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。
