# 1,2,3…n*n 的数字按照顺时针螺旋的形式打印成矩阵（递归） - z69183787的专栏 - CSDN博客
2017年03月24日 13:54:25[OkidoGreen](https://me.csdn.net/z69183787)阅读数：837
题目：1,2,3…n*n 的数字按照顺时针螺旋的形式打印成矩阵，如下：
输入数字2，则程序输出：
1 2
4 3
输入数字3，则程序输出：
1 2 3
8 9 4
7 6 5
输入数字4， 则程序输出：
1     2    3    4
12  13  14  5
11  16  15  6
10   9    8   7
此题我的解题方法是递归，递归函数的作用就是打印当前圈，然后通过递归调用逐层打印内层，直到打印结束。程序相对比较简单，所以就不加注释了……
```cpp
#include <iostream> 
#include <string>  
  
using namespace std;  
  
void fuck(int a[][21],int num,int start_position,int n){  
    int i,x,y;  
    if(n==0)return;  
    if(n==1){  
        a[start_position][start_position]=num;  
        return ;  
    }  
    x=y=start_position;  
    a[x][y]=num;
    num++;  
    for(i=0;i<n-1;++i){  
        ++y;  
        a[x][y]=num;  
        num++;  
    }  
    for(i=0;i<n-1;++i){  
        ++x;  
        a[x][y]=num;  
        num++;  
    }  
    for(i=0;i<n-1;++i){  
        --y;  
        a[x][y]=num;  
        num++;  
    }  
    for(i=0;i<n-2;++i){  
        --x;  
        a[x][y]=num;  
        num++;  
    }  
    fuck(a,num,start_position+1,n-2);  
}  
  
int main(){  
    int n;  
    int a[21][21];  
    cin>>n;  
    fuck(a,1,0,n);  
    for(int i=0;i<n;++i){  
        for(int j=0;j<n;++j){  
            cout<<a[i][j]<<"\t";  
        }  
        cout<<endl;  
    }  
    return 0;  
}
```
java：
```java
//matrix
    public static void main(String[] args){
        System.out.println("\t" +33);
        System.out.println(1 + "\t" +33);
        System.out.println(13 + "\t" +33);
        Scanner in = new Scanner(System.in);
        int size = in.nextInt();
        in.close();
        int[][] result = new int[size][size];
        matrix(result,1,0,size);
        for(int i=0;i<size;++i){
            for(int j=0;j<size;++j){
                System.out.print(result[i][j] + "\t");
            }
            System.out.println();
        }
    }
    public static void matrix(int[][] result,int value,int startPosition,int level){
        int x = startPosition;
        int y = startPosition;
        int n = value;
        if(level == 0){
            return;
        }
        if(level == 1){
            result[x][y] = n;
            return;
        }
        //normal situation
        result[x][y] = n++;
        for(int i=0;i<level-1;i++){
            result[x][++y] = n++;
        }
        for(int i=0;i<level-1;i++){
            result[++x][y] = n++;
        }
        for(int i=0;i<level-1;i++){
            result[x][--y] = n++;
        }
        for(int i=0;i<level-2;i++){
            result[--x][y] = n++;
        }
        matrix(result,n,startPosition+1,level-2);
    }
```
当然也可以转化为非递归式，这样，只要把递归写成圈数的循环即可。
非遞歸
```java
import java.util.Scanner;
 
public class SnakeMatrix {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); //首先输入矩阵的维数
        int a[][] = new int[n][n]; //存储所有元素的二维数组
        int count = 1; //计数器，每走一步加一
 
 //把二维数组从外到内一层一层剥开，按照上、右、下、左的顺序走
// 注意临界值条件,尤其是拐角别重叠覆盖
  
        for (int i = 0; i < n/2+1; i++) {
            //up
            for (int j = i; j < n-i; j++){
                a[i][j]= count++;
            }
            //right
            for (int j = i+1; j < n-i; j++){
                a[j][n-i-1]= count++;
            }
            //down
            for (int j = n-i-2; j >=i; j--){
                a[n-i-1][j]= count++;
            }
            //left
            for (int j = n-i-2; j >i; j--){
                a[j][i]= count++;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(a[i][j]+"\t");//将上面的for循环产生的数，进行遍历输出
                if(j==n-1)//拐角处
                System.out.println();
            }
        }
    }
 
}
```
