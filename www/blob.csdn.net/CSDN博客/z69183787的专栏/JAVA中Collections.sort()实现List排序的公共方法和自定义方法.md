# JAVA中Collections.sort()实现List排序的公共方法和自定义方法 - z69183787的专栏 - CSDN博客
2015年07月08日 15:25:00[OkidoGreen](https://me.csdn.net/z69183787)阅读数：2551
本文是受开源中国中的一篇文章启发而写（找不到连接了，所以暂时木法贴出来,一旦找到立马贴出来），个别内容参考了开源中国会员的讨论，感谢！
1.java提供的默认list排序方法
主要代码：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
List<String>
 list =
```
```java
new
```
```java
ArrayList();
```
```java
list.add(
```
```java
"刘媛媛"
```
```java
);
```
```java
list.add(
```
```java
"王硕"
```
```java
);
```
```java
list.add(
```
```java
"李明"
```
```java
);
```
```java
list.add(
```
```java
"刘迪"
```
```java
);
```
```java
list.add(
```
```java
"刘布"
```
```java
);
```
```java
//升序
```
```java
Collections.sort(list,Collator.getInstance(java.util.Locale.CHINA));
```
```java
//注意：是根据的汉字的拼音的字母排序的，而不是根据汉字一般的排序方法
```
```java
for
```
```java
(
```
```java
int
```
```java
i=
```
```java
0
```
```java
;i<list.size();i++)
```
```java
{
```
```java
```
```java
System.out.print(list.get(i));
```
```java
}
```
```java
System.out.println(
```
```java
""
```
```java
);
```
```java
//降序
```
```java
Collections.reverse(list);
```
```java
//不指定排序规则时，也是按照字母的来排序的
```
```java
for
```
```java
(
```
```java
int
```
```java
i=
```
```java
0
```
```java
;i<list.size();i++)
```
```java
{
```
```java
```
```java
System.out.print(list.get(i));
```
```java
}
```
```
输出结果：
李明刘布刘迪刘媛媛王硕
王硕刘媛媛刘迪刘布李明
2.自定义的排序规则：
第一种是model类实现Comparable接口，重写重写int compareTo(Object o)方法
model类：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
public
```
```java
class
```
```java
StudentDTO
```
```java
implements
```
```java
Comparable
```
```java
{
```
```java
```
```java
private
```
```java
String name;
```
```java
```
```java
private
```
```java
int
```
```java
age;
```
```java
```
```java
public
```
```java
String getName()
```
```java
```
```java
{
```
```java
```
```java
return
```
```java
name;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
setName(String name)
```
```java
```
```java
{
```
```java
```
```java
this
```
```java
.name
 = name;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
ObjType getType()
```
```java
```
```java
{
```
```java
```
```java
return
```
```java
type;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
setAge(
```
```java
int
```
```java
age)
```
```java
```
```java
{
```
```java
```
```java
this
```
```java
.age=
 age;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
int
```
```java
compareTo(Object o)
```
```java
```
```java
{
```
```java
```
```java
StudentDTO
 sdto = (StudentDTO)o;
```
```java
```
```java
int
```
```java
otherAge = sdto.getAge();
```
```java
```
```java
//note:
 enum-type's comparation depend on types' list order of enum method
```
```java
```
```java
//so,
 if compared property is enum-type ,then its comparationfollow ObjEnum.objType order
```
```java
```
```java
return
```
```java
this
```
```java
.age.compareTo(otherAge);
```
```java
```
```java
}
```
```java
}
```
```
主方法：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)
```
```java
{
```
```java
```
```java
List<StudentDTO>
 studentList =
```
```java
new
```
```java
ArrayList();
```
```java
```
```java
StudentDTO
 s1 =
```
```java
new
```
```java
StudentDTO ();
```
```java
```
```java
s.setName(
```
```java
"yuanyuan"
```
```java
);
```
```java
```
```java
s.setAge(
```
```java
22
```
```java
);
```
```java
```
```java
studentList.add(s1);
```
```java
```
```java
StudentDTO
 s1 =
```
```java
new
```
```java
StudentDTO ();
```
```java
```
```java
s.setName(
```
```java
"lily"
```
```java
);
```
```java
```
```java
s.setAge(
```
```java
23
```
```java
);
```
```java
```
```java
studentList.add(s2);
```
```java
```
```java
Collections.sort(studentList);
```
```java
//按照age升序
 22，23，
```
```java
```
```java
Collections.reverse(studentList);
```
```java
//按照age降序
 23,22
```
```java
}
```
```
第二种是比较器类实现Comparator接口，重写int compare(Object o1, Object o2)方法；
model类：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
public
```
```java
class
```
```java
StudentDTO
```
```java
implements
```
```java
Comparable
```
```java
{
```
```java
```
```java
private
```
```java
String name;
```
```java
```
```java
private
```
```java
int
```
```java
age;
```
```java
```
```java
public
```
```java
String getName()
```
```java
```
```java
{
```
```java
```
```java
return
```
```java
name;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
setName(String name)
```
```java
```
```java
{
```
```java
```
```java
this
```
```java
.name
 = name;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
ObjType getType()
```
```java
```
```java
{
```
```java
```
```java
return
```
```java
type;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
setAge(
```
```java
int
```
```java
age)
```
```java
```
```java
{
```
```java
```
```java
this
```
```java
.age=
 age;
```
```java
```
```java
}
```
```java
}
```
```
比较器类：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
class
```
```java
MyCompartor
```
```java
implements
```
```java
Comparator
```
```java
{
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
int
```
```java
compare(Object o1, Object o2)
```
```java
```
```java
{
```
```java
```
```java
StudentDTO
 sdto1= (StudentDTO )o1;
```
```java
```
```java
StudentDTO
 sdto2= (StudentDTO )o2;
```
```java
```
```java
return
```
```java
sdto1.getAge.compareTo(stdo2.getAge())
```
```java
```
```java
}
```
```java
}
```
```
主方法：
[?](http://my.oschina.net/liuyuanyuangogo/blog/151628#)
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args)
```
```java
{
```
```java
```
```java
List<StudentDTO>
 studentList =
```
```java
new
```
```java
ArrayList();
```
```java
```
```java
StudentDTO
 s1 =
```
```java
new
```
```java
StudentDTO ();
```
```java
```
```java
s.setName(
```
```java
"yuanyuan"
```
```java
);
```
```java
```
```java
s.setAge(
```
```java
22
```
```java
);
```
```java
```
```java
studentList.add(s1);
```
```java
```
```java
StudentDTO
 s1 =
```
```java
new
```
```java
StudentDTO ();
```
```java
```
```java
s.setName(
```
```java
"lily"
```
```java
);
```
```java
```
```java
s.setAge(
```
```java
23
```
```java
);
```
```java
```
```java
studentList.add(s2);
```
```java
```
```java
MyComparetor
 mc =
```
```java
new
```
```java
MyComparetor();
```
```java
```
```java
Collections.sort(studentList,mc);
```
```java
//按照age升序
 22，23
```
```java
```
```java
Collections.reverse(studentList,mc);
```
```java
//按照age降序
 23,22
```
```java
}
```
```
附注：
1.对于数组的排序方法如下：
String[] names = {"王林",  "杨宝", "李镇", "刘迪", "刘波"};  
Arrays.sort(names, com.ibm.icu.text.Collator.getInstance(com.ibm.icu.util.ULocale.SIMPLIFIED_CHINESE));//升序;   
System.out.println(Arrays.toString(names));      
2.对于汉字的排序：可以尝试使用ICU4J会得到更好的结果，特别是姓为某些生僻字的时候，
用com.ibm.icu.text.Collator替换java.text.Collator，用com.ibm.icu.util.ULocale替换java.util.Locale
3.对于枚举类型的enum1.compareTo（enum2）是按照枚举类型值在定义时的先后顺序比较的，越后面的越大，而不是按照值的字母先后顺序比较的。
