# 加载一个类时，其内部类是否同时被加载?静态内部类单例模式 - z69183787的专栏 - CSDN博客
2017年03月18日 21:45:59[OkidoGreen](https://me.csdn.net/z69183787)阅读数：464
加载一个类时，其内部类是否同时被加载？下面我们做一个实验来看一下。 
Java代码  
- publicclass Outer {  
- static {  
-         System.out.println("load outer class...");  
-     }  
- 
- //静态内部类
- staticclass StaticInner {  
- static {  
-             System.out.println("load static inner class...");  
-         }  
- 
- staticvoid staticInnerMethod() {  
-             System.out.println("static inner method...");  
-         }  
-     }  
- 
- publicstaticvoid main(String[] args) {  
-         Outer outer = new Outer();      //此刻其内部类是否也会被加载？
-          System.out.println("===========分割线===========");  
-         Outer.StaticInner.staticInnerMethod();      //调用内部类的静态方法
-     }  
- }  
运行结果： 
load outer class... 
==========分割线========== 
load static inner class... 
static inner method... 
    调用构造方法时，外部类Outer被加载，但这时其静态内部类StaticInner却未被加载。直到调用该内部类的静态方法（在分割线以下），StaticInner才被加载。可以做类似的实验验证非静态内部类的情况。 
结论：加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。
    根据内部类不会在其外部类被加载的同时被加载的事实，我们可以引申出单例模式的一种实现方式： 
Java代码  
- publicclass Singleton {  
- private Singleton() {}  
- 
- staticclass SingletonHolder {  
- privatestaticfinal Singleton instance = new Singleton();  
-     }  
- 
- publicstatic Singleton getInstance() {  
- return SingletonHolder.instance;  
-     }  
- }  
    该实现方式比较简单，而且既实现了由前述事实所保证的惰性初始化（Lazy-Initialazation），又由JVM保证了多线程并发访问的正确性。
