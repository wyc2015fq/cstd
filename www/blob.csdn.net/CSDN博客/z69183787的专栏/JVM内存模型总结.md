# JVM内存模型总结 - z69183787的专栏 - CSDN博客
2019年01月23日 16:48:31[OkidoGreen](https://me.csdn.net/z69183787)阅读数：67
个人分类：[Jvm-内存模型分析](https://blog.csdn.net/z69183787/article/category/2275953)
[https://blog.csdn.net/u011972171/article/details/80398771](https://blog.csdn.net/u011972171/article/details/80398771)
**JVM内存模型**：
![](https://img-blog.csdn.net/20180521220215992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5NzIxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
从这张图中很直观的看到，程序计数器，虚拟机栈，native栈是线程私有的，堆是线程共有的，现在详细介绍JVM各个区块。
1. **堆（Heap）**
       是java虚拟机所管理的内存中**最大的**一块内存区域，也是被各个**线程共享**的内存区域，该内存区域**存放了对象实例及数组（但不是所有的对象实例都在堆中）**。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置（**最大最小值都要小于1G**），前者为启动时申请的最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存,默认为物理内存的1/4，**默认当空余堆内存小于40%时**，JVM会**增大**堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当**空余堆内存大于70%**时，JVM会**减小**堆内存的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，当然为了避免在运行时频繁调整Heap的大小，**通常-Xms与-Xmx的值设成一样**。堆内存 = 新生代+老生代+持久代。在我们垃圾回收的时候，我们往往将堆内存分成**新生代和老生代（大小比例1：2）**，新生代中由Eden和Survivor0，Survivor1组成，**三者的比例是8：1：1**，新生代的回收机制采用**复制算法**，在Minor GC的时候，我们**都留一个存活区**用来存放存活的对象，真正进行的区域是Eden+其中一个存活区，当我们的对象时长超过一定年龄时（默认**15**，可以通过参数设置），将会把对象放入老生代，当然大的对象会直接进入老生代。老生代采用的回收算法是**标记整理算法。（更详细的内容将后续文章详细介绍GC回收）**
2. **方法区（Method Area）**
   方法区也称"**永久代**"，它用于**存储虚拟机加载的类信息、常量、静态变量**、是各个**线程共享的内存区域**。默认最小值为16MB，最大值为64MB（64位JVM由于指针膨胀，默认是85M），可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。它是**一片连续的堆空间**，永久代的**垃圾收集是和老年代(old generation)捆绑在一起的**，因此**无论谁满**了，**都会触发永久代和老年代的垃圾收集**。不过，一个明显的问题是，当JVM加载的类信息容量超过了参数-XX：MaxPermSize设定的值时，应用将会报OOM的错误。参数是通过-XX:PermSize和-XX：MaxPermSize来设定的
     运行时常量池(Runtime Constant Pool)：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于**存放编译器生成的各种符号引用**，这部分内容将在**类加载后**放到方法区的运行时常量池中。
** 从JDK7开始移除永久代（但并没有移除，还是存在），贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。从JDK8开始使用元空间（Metaspace），元空间的大小受本地内存限制，新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。**
 具体的可以查看这篇文章：https://blog.csdn.net/zhushuai1221/article/details/52122880 （Java 8: 从永久代（PermGen）到元空间（Metaspace））
3.**虚拟机栈(JVM Stack)**
     描述的是**java方法执行的内存模型**：每个**方法被执行的时候都会创建一个"栈帧"**,用于**存储局部变量表(包括参数)、操作栈、方法出口**等信息。每个方法被调用到执行完的过程，就**对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**。**声明周期与线程相同，是线程私有的**。栈帧由三部分组成：局部变量区、操作数栈、帧数据区。局部变量区被组织为以一个字长为单位、从0开始计数的数组，和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的，可以看作为临时数据的存储区域。除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。
**局部变量表: 存放**了编译器可知的各种**基本数据类型**、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表**所需的内存空间**在**编译期间完成分配**，当进入一个方法时，这个方法需要在栈帧中**分配多大的局部变量是完全确定**的，在**运行期间**栈帧**不会改变局部变量表的大小空间**。
4.**本地方法栈(Native Stack)**
       与虚拟机栈基本类似，区别在于**虚拟机栈为虚拟机执行的java方法服务**，而**本地方法栈则是为Native方法服务**。(栈的空间大小远远小于堆)
5.**程序计数器（PC Register）**
是**最小的一块内存区域**，它的**作用**是**当前线程所执行的字节码的行号指示器**，在虚拟机的模型里，字节码解释器工作时就是通过**改变这个计数器的值来选取下一条需要执行的字节码指令**，**分支**、**循环、异常处理、线程恢复**等基础功能都需要**依赖计数器**完成。
6.**直接内存**
    直接内存并**不是虚拟机内存的一部分**，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小.
