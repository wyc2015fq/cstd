# 关于BeanCopier的一些思考 - z69183787的专栏 - CSDN博客
2017年09月20日 15:22:11[OkidoGreen](https://me.csdn.net/z69183787)阅读数：518
在做业务的时候，我们有时为了隔离变化，会将DAO查询出来的Entity，和对外提供的DTO隔离开来。大概90%的时候，它们的结构都是类似的，但是我们很不喜欢写很多冗长的b.setF1(a.getF1())这样的代码，于是我们需要BeanCopier来帮助我们。
在做业务的时候，我们有时为了隔离变化，会将DAO查询出来的Entity，和对外提供的DTO隔离开来。大概90%的时候，它们的结构都是类似的，但是我们很不喜欢写很多冗长的b.setF1(a.getF1())这样的代码，于是我们需要BeanCopier来帮助我们。
`BeanCopier`其实已经有很多开源版本，例如[DozerMapper](https://github.com/DozerMapper/dozer)、[Apache
 BeanUtils](http://commons.apache.org/proper/commons-beanutils/)、[Spring](https://spring.io/)、[Jodd
 BeanUtils](http://jodd.org/doc/beanutil.html)甚至是[Cglib](https://github.com/cglib/cglib)都提供了这样的功能。在比较这些工具之前，我想先提提我对BeanCopier的一些要求。
## 1. 性能
BeanCopier是一个很常用的操作，如果是一个批量的请求，就更加明显了。使用效率太低的库不太划算，我对这些工具做了一个对比：Copy一个简单Bean 1,000,000次，计算总耗时（测试代码在[这里](https://github.com/code4craft/abc/blob/master/src/test/java/us/codecraft/abc/performance/BeanCopierPerformanceTest.java)）。比较结果如下：
```
```java
1
```
```java
,
```
```java
000
```
```java
,
```
```java
000
```
```java
round
```
```java
jdk
 set/get takes 17ms
```
```java
cglib
 takes 117ms
```
```java
jodd
 takes 5309ms
```
```java
dozer
 mapper takes 2336ms
```
```java
apche
 beanutils takes 6264ms
```
```
其中jdk的直接写set/get是最快的，所以在性能要求高的场景下倒是不妨自己写。另外这样写也是对[重构](http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=importnew-23&linkCode=as2&camp=536&creative=3200&creativeASIN=B003BY6PLK)比较友好，这是其他几个工具都做不到的。
其次是用了字节码生成的cglib，然后将其他的库远远甩在后面。其他的库性能相差不大，大约1000次拷贝会消耗数毫秒时间，对于性能敏感的应用，特别是一些批量请求，消耗还是比较大的。
## 2. 内聚性
其实Bean Copy可以扩展到更一般的情况：我们需要对两个类似的Bean做转换，输入是一个Bean，输出是另外一个类似的Bean。这种逻辑里，除了简单的字段拷贝，可能也会有一些计算逻辑，甚至还会依赖一些外部数据源，而我们还希望最好把转换的逻辑都放在一起，同时也起到规范业务的作用。
`DozerMapper`在这条路上走的很远。它通过XML/API/Annotation的方式，支持简单形式的转换、映射，从而更好的处理一些字段不一样的情况，用意就是一个Mapper搞定一切。例如下面的例子，可以将不同名称的字段进行映射。
```
```xml
<?
```
```xml
xml
```
```xml
version
```
```xml
=
```
```xml
"1.0"
```
```xml
encoding
```
```xml
=
```
```xml
"UTF-8"
```
```xml
?>
```
```xml
<
```
```xml
mappings
```
```xml
xmlns
```
```xml
=
```
```xml
"http://dozer.sourceforge.net"
```
```xml
```
```xml
xmlns:xsi
```
```xml
=
```
```xml
"http://www.w3.org/2001/XMLSchema-instance"
```
```xml
```
```xml
xsi:schemaLocation="http://dozer.sourceforge.net
```
```xml
http://dozer.sourceforge.net/schema/beanmapping.xsd">
```
```xml
```
```xml
<
```
```xml
mapping
```
```xml
>
```
```xml
```
```xml
<
```
```xml
class-a
```
```xml
>org.dozer.vo.TestObject</
```
```xml
class-a
```
```xml
>
```
```xml
```
```xml
<
```
```xml
class-b
```
```xml
>org.dozer.vo.TestObjectPrime</
```
```xml
class-b
```
```xml
>
```
```xml
```
```xml
<
```
```xml
field
```
```xml
>
```
```xml
```
```xml
<
```
```xml
a
```
```xml
>one</
```
```xml
a
```
```xml
>
```
```xml
```
```xml
<
```
```xml
b
```
```xml
>onePrime</
```
```xml
b
```
```xml
>
```
```xml
```
```xml
</
```
```xml
field
```
```xml
>
```
```xml
```
```xml
</
```
```xml
mapping
```
```xml
>
```
```xml
```
```xml
<
```
```xml
mapping
```
```xml
wildcard
```
```xml
=
```
```xml
"false"
```
```xml
>
```
```xml
```
```xml
<
```
```xml
class-a
```
```xml
>org.dozer.vo.TestObjectFoo</
```
```xml
class-a
```
```xml
>
```
```xml
```
```xml
<
```
```xml
class-b
```
```xml
>org.dozer.vo.TestObjectFooPrime</
```
```xml
class-b
```
```xml
>
```
```xml
```
```xml
<
```
```xml
field
```
```xml
>
```
```xml
```
```xml
<
```
```xml
a
```
```xml
>oneFoo</
```
```xml
a
```
```xml
>
```
```xml
```
```xml
<
```
```xml
b
```
```xml
>oneFooPrime</
```
```xml
b
```
```xml
>
```
```xml
```
```xml
</
```
```xml
field
```
```xml
>
```
```xml
```
```xml
</
```
```xml
mapping
```
```xml
>
```
```xml
</
```
```xml
mappings
```
```xml
>
```
```
但是，假设我们的场景不是需要整合很多项目，而是自己制定规范和数据模型，这时我们真的需要这样的转换么？我认为一开始就应该把相同的字段给予相同的名字，这样无论是对于理解、后续维护都会方便很多。即使这种不同名的情况存在，我们也不应该提倡。所以花这么大的力气去做字段的映射，增加了复杂度，我认为并不划算。这个时候，我们需要的是仅仅对同名字段进行拷贝，其他属性交由手动处理。
至此，一个BeanCopier就大体成型了：
```
```java
public
```
```java
class
```
```java
BeanCopier<F,T> {
```
```java
private
```
```java
net.sf.cglib.beans.BeanCopier beanCopier;
```
```java
protected
```
```java
net.sf.cglib.beans.BeanCopier getBeanCopier() {
```
```java
```
```java
return
```
```java
beanCopier;
```
```java
}
```
```java
protected
```
```java
void
```
```java
init(){
```
```java
```
```java
this
```
```java
.beanCopier
 = net.sf.cglib.beans.BeanCopier.create(sourceClass, targetClass,
```
```java
false
```
```java
);
```
```java
}
```
```java
private
```
```java
Class<T> targetClass;
```
```java
private
```
```java
Class<F> sourceClass;
```
```java
protected
```
```java
Class<T> getTargetClass() {
```
```java
```
```java
return
```
```java
targetClass;
```
```java
}
```
```java
protected
```
```java
Class<F> getSourceClass() {
```
```java
```
```java
return
```
```java
sourceClass;
```
```java
}
```
```java
public
```
```java
void
```
```java
setTargetClass(Class<T> targetClass) {
```
```java
```
```java
this
```
```java
.targetClass
 = targetClass;
```
```java
}
```
```java
public
```
```java
void
```
```java
setSourceClass(Class<F> sourceClass) {
```
```java
```
```java
this
```
```java
.sourceClass
 = sourceClass;
```
```java
}
```
```java
public
```
```java
T afterCopy(F source, T target){
```
```java
```
```java
return
```
```java
target;
```
```java
}
```
```java
public
```
```java
T copy(F input) {
```
```java
```
```java
try
```
```java
{
```
```java
```
```java
T
 o = targetClass.newInstance();
```
```java
```
```java
beanCopier.copy(input,
 o,
```
```java
null
```
```java
);
```
```java
```
```java
return
```
```java
afterCopy(input, o);
```
```java
```
```java
}
```
```java
catch
```
```java
(Exception e) {
```
```java
```
```java
throw
```
```java
new
```
```java
RuntimeException(
```
```java
"create
 object fail, class:"
```
```java
+ targetClass.getName() +
```
```java
"
 "
```
```java
,
 e);
```
```java
```
```java
}
```
```java
}
```
```java
@Override
```
```java
public
```
```java
T apply(F input) {
```
```java
```
```java
return
```
```java
copy(input);
```
```java
}
```
```java
}
```
```
另外，很多情况下，我们不止是对字段值进行拷贝，还会有一些数据转换的需要。例如：将Entity的瘦模型中关联的一些数据，从简单的数据库关联外键变为一个完整的Entity，最后再整合成一个DTO。
这种情况下，我们的BeanCopyier还需要一些外部数据。在Spring中，我们会希望它去依赖DAO或者外部Service之类的Bean。于是我们还可以用Spring来配置它。
```
```java
@Service
```
```java
public
```
```java
class
```
```java
A2BBeanCopier
```
```java
extends
```
```java
BeanCopier<A,B> {
```
```java
```
```java
@PostConstruct
```
```java
```
```java
public
```
```java
void
```
```java
init(){
```
```java
```
```java
setSourceClass(A.
```
```java
class
```
```java
);
```
```java
```
```java
setTargetClass(B.
```
```java
class
```
```java
);
```
```java
```
```java
super
```
```java
.init();
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
B afterCopy(A source, B target) {
```
```java
```
```java
target.setF5(
```
```java
"aaa"
```
```java
);
```
```java
```
```java
//Call
 some service
```
```java
```
```java
return
```
```java
target;
```
```java
```
```java
}
```
```java
}
```
```
