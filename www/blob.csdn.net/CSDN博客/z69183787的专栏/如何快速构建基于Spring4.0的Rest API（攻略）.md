# 如何快速构建基于Spring4.0的Rest API（攻略） - z69183787的专栏 - CSDN博客
2015年10月03日 21:42:12[OkidoGreen](https://me.csdn.net/z69183787)阅读数：1031
这是关于使用Spring MVC创建Web API的另一个教程。这并不是一个非常精细的教程，而仅仅是一个演习（攻略）。本教程旨在创建一个提供服务器端API的应用，并且使用Mongo作为它的数据库，使用Spring Security作为安全框架。
准备开始——POM
由于我是一个maven脑残粉，所以这个项目还是基于maven的。现在Spring 4.0 RC2已经发布了，所以我决定使用最新的依赖管理工具。本文使用的pom.xml如下：使用这个配置创建Spring MVC应用确实非常简单。这里面比较新鲜的东西就是dependencyManagement 元素。详解猛戳这儿：[http://spring.io/blog/2013/12/03/spring-framework-4-0-rc2-available](http://spring.io/blog/2013/12/03/spring-framework-4-0-rc2-available)
配置
这个应用可以使用JavaConfig完成配置。我把它切分为下面几个部分：
ServicesConfig（服务配置）
无需扫描组件，配置真的非常简单：
```
```java
@Configuration
```
```java
public
```
```java
class
```
```java
ServicesConfig {
```
```java
```
```java
@Autowired
```
```java
```
```java
private
```
```java
AccountRepository accountRepository;
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
UserService userService() {
```
```java
```
```java
return
```
```java
new
```
```java
UserService(accountRepository);
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
PasswordEncoder passwordEncoder() {
```
```java
```
```java
return
```
```java
NoOpPasswordEncoder.getInstance();
```
```java
```
```java
}
```
```java
}
```
```
PersistenceConfig（持久层配置）
我们想要一个配置了所有可用仓库的MONGODB配置。在这个简单的应用中我们只用了一个仓库，所以配置也非常的简单：
```
```java
@Configuration
```
```java
class
```
```java
PersistenceConfig {
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
AccountRepository accountRepository()
```
```java
throws
```
```java
UnknownHostException {
```
```java
```
```java
return
```
```java
new
```
```java
MongoAccountRepository(mongoTemplate());
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
MongoDbFactory mongoDbFactory()
```
```java
throws
```
```java
UnknownHostException {
```
```java
```
```java
return
```
```java
new
```
```java
SimpleMongoDbFactory(
```
```java
new
```
```java
Mongo(),
```
```java
"r"
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
MongoTemplate mongoTemplate()
```
```java
throws
```
```java
UnknownHostException {
```
```java
```
```java
MongoTemplate
 template =
```
```java
new
```
```java
MongoTemplate(mongoDbFactory(), mongoConverter());
```
```java
```
```java
return
```
```java
template;
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
MongoTypeMapper mongoTypeMapper() {
```
```java
```
```java
return
```
```java
new
```
```java
DefaultMongoTypeMapper(
```
```java
null
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
MongoMappingContext mongoMappingContext() {
```
```java
```
```java
return
```
```java
new
```
```java
MongoMappingContext();
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
```
```java
public
```
```java
MappingMongoConverter mongoConverter()
```
```java
throws
```
```java
UnknownHostException {
```
```java
```
```java
MappingMongoConverter
 converter =
```
```java
new
```
```java
MappingMongoConverter(mongoDbFactory(), mongoMappingContext());
```
```java
```
```java
converter.setTypeMapper(mongoTypeMapper());
```
```java
```
```java
return
```
```java
converter;
```
```java
```
```java
}
```
```java
}
```
```
SecurityConfig（安全配置）
理论上，Spring Security 3.2完全可以使用JavaConfig。但对于我这也仅仅是一个理论，所以这里还是选择xml配置的方式：
```
```java
@Configuration
```
```java
@ImportResource
```
```java
(
```
```java
"classpath:spring-security-context.xml"
```
```java
)
```
```java
public
```
```java
class
```
```java
SecurityConfig {}
```
```
使用这个xml就让API能使用基本的安全机制了。
WebAppInitializer（初始化）
我们不想使用web.xml，所以使用下面的代码配置整个应用：
```
```java
@Order
```
```java
(
```
```java
2
```
```java
)
```
```java
public
```
```java
class
```
```java
WebAppInitializer
```
```java
extends
```
```java
AbstractAnnotationConfigDispatcherServletInitializer {
```
```java
```
```java
@Override
```
```java
```
```java
protected
```
```java
String[] getServletMappings() {
```
```java
```
```java
return
```
```java
new
```
```java
String[]{
```
```java
"/"
```
```java
};
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
protected
```
```java
Class[] getRootConfigClasses() {
```
```java
```
```java
return
```
```java
new
```
```java
Class[] {ServicesConfig.
```
```java
class
```
```java
,
 PersistenceConfig.
```
```java
class
```
```java
,
 SecurityConfig.
```
```java
class
```
```java
};
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
protected
```
```java
Class[] getServletConfigClasses() {
```
```java
```
```java
return
```
```java
new
```
```java
Class[] {WebMvcConfig.
```
```java
class
```
```java
};
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
protected
```
```java
Filter[] getServletFilters() {
```
```java
```
```java
CharacterEncodingFilter
 characterEncodingFilter =
```
```java
new
```
```java
CharacterEncodingFilter();
```
```java
```
```java
characterEncodingFilter.setEncoding(
```
```java
"UTF-8"
```
```java
);
```
```java
```
```java
characterEncodingFilter.setForceEncoding(
```
```java
true
```
```java
);
```
```java
```
```java
return
```
```java
new
```
```java
Filter[] {characterEncodingFilter};
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
protected
```
```java
void
```
```java
customizeRegistration(ServletRegistration.Dynamic registration) {
```
```java
```
```java
registration.setInitParameter(
```
```java
"spring.profiles.active"
```
```java
,
```
```java
"default"
```
```java
);
```
```java
```
```java
}
```
```java
}
```
```
WebAppSecurityInitializer （安全配置初始化）
相对于Spring3，可以使用下面这种更加新颖的特性来完成配置：
```
```java
@Order
```
```java
(
```
```java
1
```
```java
)
```
```java
public
```
```java
class
```
```java
WebAppSecurityInitializer
```
```java
extends
```
```java
AbstractSecurityWebApplicationInitializer {}
```
```
WebMvcConfig （Mvc配置）
调度控制器配置。这个也非常简单，仅仅包含了构建一个简单API的最重要配置：
```
```java
@Configuration
```
```java
@ComponentScan
```
```java
(basePackages
 = {
```
```java
"pl.codeleak.r"
```
```java
}, includeFilters = {
```
```java
@Filter
```
```java
(value
 = Controller.
```
```java
class
```
```java
)})
```
```java
public
```
```java
class
```
```java
WebMvcConfig
```
```java
extends
```
```java
WebMvcConfigurationSupport {
```
```java
```
```java
private
```
```java
static
```
```java
final
```
```java
String MESSAGE_SOURCE =
```
```java
"/WEB-INF/i18n/messages"
```
```java
;
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
RequestMappingHandlerMapping requestMappingHandlerMapping() {
```
```java
```
```java
RequestMappingHandlerMapping
 requestMappingHandlerMapping =
```
```java
super
```
```java
.requestMappingHandlerMapping();
```
```java
```
```java
requestMappingHandlerMapping.setUseSuffixPatternMatch(
```
```java
false
```
```java
);
```
```java
```
```java
requestMappingHandlerMapping.setUseTrailingSlashMatch(
```
```java
false
```
```java
);
```
```java
```
```java
return
```
```java
requestMappingHandlerMapping;
```
```java
```
```java
}
```
```java
```
```java
@Bean
```
```java
(name
 =
```
```java
"messageSource"
```
```java
)
```
```java
```
```java
public
```
```java
MessageSource messageSource() {
```
```java
```
```java
ReloadableResourceBundleMessageSource
 messageSource =
```
```java
new
```
```java
ReloadableResourceBundleMessageSource();
```
```java
```
```java
messageSource.setBasename(MESSAGE_SOURCE);
```
```java
```
```java
messageSource.setCacheSeconds(
```
```java
5
```
```java
);
```
```java
```
```java
return
```
```java
messageSource;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
Validator getValidator() {
```
```java
```
```java
LocalValidatorFactoryBean
 validator =
```
```java
new
```
```java
LocalValidatorFactoryBean();
```
```java
```
```java
validator.setValidationMessageSource(messageSource());
```
```java
```
```java
return
```
```java
validator;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
void
```
```java
configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
```
```java
```
```java
configurer.enable();
```
```java
```
```java
}
```
```java
}
```
```
这就是需要的配置，非常简单吧！
IndexController （INDEX控制器）
为了验证这个配置是正确的，我创建了一个IndexController。功能非常简单，只是简单地返回“Hello World”，示例代码如下：
```
```java
@Controller
```
```java
@RequestMapping
```
```java
(
```
```java
"/"
```
```java
)
```
```java
public
```
```java
class
```
```java
IndexController {
```
```java
```
```java
@RequestMapping
```
```java
```
```java
@ResponseBody
```
```java
```
```java
public
```
```java
String index() {
```
```java
```
```java
return
```
```java
"This is an API endpoint."
```
```java
;
```
```java
```
```java
}
```
```java
}
```
```
如果运行一下这个应用，就能够在浏览器中看到返回的“Hello World”文本。
构建API
UserService
为了完成Spring安全框架配置，还需要完成另一个部分：实现之前创建的UserService。
```
```java
public
```
```java
class
```
```java
UserService
```
```java
implements
```
```java
UserDetailsService {
```
```java
```
```java
private
```
```java
AccountRepository accountRepository;
```
```java
```
```java
public
```
```java
UserService(AccountRepository accountRepository) {
```
```java
```
```java
this
```
```java
.accountRepository
 = accountRepository;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
UserDetails loadUserByUsername(String username)
```
```java
throws
```
```java
UsernameNotFoundException {
```
```java
```
```java
Account
 account = accountRepository.findByEmail(username);
```
```java
```
```java
if
```
```java
(account
 ==
```
```java
null
```
```java
)
 {
```
```java
```
```java
throw
```
```java
new
```
```java
UsernameNotFoundException(
```
```java
"user
 not found"
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
return
```
```java
createUser(account);
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
signin(Account account) {
```
```java
```
```java
SecurityContextHolder.getContext().setAuthentication(authenticate(account));
```
```java
```
```java
}
```
```java
```
```java
private
```
```java
Authentication authenticate(Account account) {
```
```java
```
```java
return
```
```java
new
```
```java
UsernamePasswordAuthenticationToken(createUser(account),
```
```java
null
```
```java
,
 Collections.singleton(createAuthority(account)));
```
```java
```
```java
}
```
```java
```
```java
private
```
```java
User createUser(Account account) {
```
```java
```
```java
return
```
```java
new
```
```java
User(account.getEmail(), account.getPassword(), Collections.singleton(createAuthority(account)));
```
```java
```
```java
}
```
```java
```
```java
private
```
```java
GrantedAuthority createAuthority(Account account) {
```
```java
```
```java
return
```
```java
new
```
```java
SimpleGrantedAuthority(account.getRole());
```
```java
```
```java
}
```
```java
}
```
```
构建一个API节点需要处理三个方法：获取当前登陆用户、获取所有用户（可能不是太安全）、创建一个新账户。那么我们就按照这个步骤来进行吧。
Account
Account 将会是我们的第一个Mongo文档。同样也是非常简单：
```
```java
@SuppressWarnings
```
```java
(
```
```java
"serial"
```
```java
)
```
```java
@Document
```
```java
public
```
```java
class
```
```java
Account
```
```java
implements
```
```java
java.io.Serializable {
```
```java
```
```java
@Id
```
```java
```
```java
private
```
```java
String objectId;
```
```java
```
```java
@Email
```
```java
```
```java
@Indexed
```
```java
(unique
 =
```
```java
true
```
```java
)
```
```java
```
```java
private
```
```java
String email;
```
```java
```
```java
@JsonIgnore
```
```java
```
```java
@NotBlank
```
```java
```
```java
private
```
```java
String password;
```
```java
```
```java
private
```
```java
String role =
```
```java
"ROLE_USER"
```
```java
;
```
```java
```
```java
private
```
```java
Account() {
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
Account(String email, String password, String role) {
```
```java
```
```java
this
```
```java
.email
 = email;
```
```java
```
```java
this
```
```java
.password
 = password;
```
```java
```
```java
this
```
```java
.role
 = role;
```
```java
```
```java
}
```
```java
```
```java
//
 getters and setters
```
```java
}
```
```
Repository
先创建一个接口：
```
```java
public
```
```java
interface
```
```java
AccountRepository {
```
```java
```
```java
Account
 save(Account account);
```
```java
```
```java
List
 findAll();
```
```java
```
```java
Account
 findByEmail(String email);
```
```java
}
```
```
接下来创建它的Mongo实现：
```
```java
public
```
```java
class
```
```java
MongoAccountRepository
```
```java
implements
```
```java
AccountRepository {
```
```java
```
```java
private
```
```java
MongoTemplate mongoTemplate;
```
```java
```
```java
public
```
```java
MongoAccountRepository(MongoTemplate mongoTemplate) {
```
```java
```
```java
this
```
```java
.mongoTemplate
 = mongoTemplate;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
Account save(Account account) {
```
```java
```
```java
mongoTemplate.save(account);
```
```java
```
```java
return
```
```java
account;
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
List findAll() {
```
```java
```
```java
return
```
```java
mongoTemplate.findAll(Account.
```
```java
class
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
public
```
```java
Account findByEmail(String email) {
```
```java
```
```java
return
```
```java
mongoTemplate.findOne(Query.query(Criteria.where(
```
```java
"email"
```
```java
).is(email)),
 Account.
```
```java
class
```
```java
);
```
```java
```
```java
}
```
```java
}
```
```
API控制器
功能快要完成了。我们需要将内容提供给用户，所以需要创建自己的节点：
```
```java
@Controller
```
```java
@RequestMapping
```
```java
(
```
```java
"api/account"
```
```java
)
```
```java
class
```
```java
AccountController {
```
```java
```
```java
private
```
```java
AccountRepository accountRepository;
```
```java
```
```java
@Autowired
```
```java
```
```java
public
```
```java
AccountController(AccountRepository accountRepository) {
```
```java
```
```java
this
```
```java
.accountRepository
 = accountRepository;
```
```java
```
```java
}
```
```java
```
```java
@RequestMapping
```
```java
(value
 =
```
```java
"current"
```
```java
,
 method = RequestMethod.GET)
```
```java
```
```java
@ResponseStatus
```
```java
(value
 = HttpStatus.OK)
```
```java
```
```java
@ResponseBody
```
```java
```
```java
@PreAuthorize
```
```java
(value
 =
```
```java
"isAuthenticated()"
```
```java
)
```
```java
```
```java
public
```
```java
Account current(Principal principal) {
```
```java
```
```java
Assert.notNull(principal);
```
```java
```
```java
return
```
```java
accountRepository.findByEmail(principal.getName());
```
```java
```
```java
}
```
```java
```
```java
@RequestMapping
```
```java
(method
 = RequestMethod.GET)
```
```java
```
```java
@ResponseStatus
```
```java
(value
 = HttpStatus.OK)
```
```java
```
```java
@ResponseBody
```
```java
```
```java
@PreAuthorize
```
```java
(value
 =
```
```java
"isAuthenticated()"
```
```java
)
```
```java
```
```java
public
```
```java
Accounts list() {
```
```java
```
```java
List
 accounts = accountRepository.findAll();
```
```java
```
```java
return
```
```java
new
```
```java
Accounts(accounts);
```
```java
```
```java
}
```
```java
```
```java
@RequestMapping
```
```java
(method
 = RequestMethod.POST)
```
```java
```
```java
@ResponseStatus
```
```java
(value
 = HttpStatus.CREATED)
```
```java
```
```java
@ResponseBody
```
```java
```
```java
@PreAuthorize
```
```java
(value
 =
```
```java
"permitAll()"
```
```java
)
```
```java
```
```java
public
```
```java
Account create(
```
```java
@Valid
```
```java
Account account) {
```
```java
```
```java
accountRepository.save(account);
```
```java
```
```java
return
```
```java
account;
```
```java
```
```java
}
```
```java
```
```java
private
```
```java
class
```
```java
Accounts
```
```java
extends
```
```java
ArrayList {
```
```java
```
```java
public
```
```java
Accounts(List accounts) {
```
```java
```
```java
super
```
```java
(accounts);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
我希望你能明白：因为需要直接连接数据库，所以没有对密码进行编码。如果你比较在意这些小细节，那么可以稍后修改。目前这种方式是OK的。
完成
最后我考虑到还需要一个错误处理器，这样用户就可以看到JSON格式的错误信息而不是HTML。使用Spring Mvc以及@ControllerAdvice很容易实现这一点：
```
```java
@ControllerAdvice
```
```java
public
```
```java
class
```
```java
ErrorHandler {
```
```java
```
```java
@ExceptionHandler
```
```java
(value
 = Exception.
```
```java
class
```
```java
)
```
```java
```
```java
@ResponseStatus
```
```java
(HttpStatus.BAD_REQUEST)
```
```java
```
```java
@ResponseBody
```
```java
```
```java
public
```
```java
ErrorResponse errorResponse(Exception exception) {
```
```java
```
```java
return
```
```java
new
```
```java
ErrorResponse(exception.getMessage());
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
ErrorResponse {
```
```java
```
```java
private
```
```java
String message;
```
```java
```
```java
public
```
```java
ErrorResponse(String message) {
```
```java
```
```java
this
```
```java
.message
 = message;
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
String getMessage() {
```
```java
```
```java
return
```
```java
message;
```
```java
```
```java
}
```
```java
}
```
```
如果你想了解关于Spring4 中@ControllerAdvice的用法，请点击以下[链接](http://blog.codeleak.pl/2013/11/controlleradvice-improvements-in-spring.html%E3%80%82)。
测试一下这个app
作为一个单元测试极客，本来应该先创建一个单元测试。但是……这次哥想用用新的工具：Postman（Chrome 插件），所以请往下看我是怎么做的：
获取所有account（非授权）
![](http://www.importnew.com/wp-content/uploads/2013/12/300x202xgna1-300x202.png.pagespeed.ic_.WM76cPEhpn.jpg)
提交account（无需授权）
![](http://www.importnew.com/wp-content/uploads/2013/12/300x226xgna2-300x226.png.pagespeed.ic_.8c24SUBITf.jpg)
获取所有account（已授权）
![](http://www.importnew.com/wp-content/uploads/2013/12/300x226xgna3-300x226.png.pagespeed.ic_.vWqZLwHrf-.jpg)
获取当前account（已授权）
![](http://www.importnew.com/wp-content/uploads/2013/12/gna4-300x226.png.jpg)
结束语
以上就是所有内容，希望你能像我一样喜欢这种创建项目的方式。创建这个项目以及写这篇文章总共花了我大概三个钟头。其中绝大多数时间是配置安全框架（我希望它在Java中能够更加彻底），以及编写这篇攻略。
