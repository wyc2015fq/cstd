# 观察者模式与事件驱动模式实例比较 - z69183787的专栏 - CSDN博客
2017年05月16日 11:22:29[OkidoGreen](https://me.csdn.net/z69183787)阅读数：764
观察者模式所涉及的角色有：
　　●　　**抽象主题(Subject)角色：**抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。
　　●　　**具体主题(ConcreteSubject)角色：**将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。
　　●　　**抽象观察者(Observer)角色：**为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。
　　●　　**具体观察者(ConcreteObserver)角色：**存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。
### 　　源代码
　　　　抽象主题角色类
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
public abstract class Subject {
    /**
     * 用来保存注册的观察者对象
     */
    private    List<Observer> list = new ArrayList<Observer>();
    /**
     * 注册观察者对象
     * @param observer    观察者对象
     */
    public void attach(Observer observer){
        
        list.add(observer);
        System.out.println("Attached an observer");
    }
    /**
     * 删除观察者对象
     * @param observer    观察者对象
     */
    public void detach(Observer observer){
        
        list.remove(observer);
    }
    /**
     * 通知所有注册的观察者对象
     */
    public void nodifyObservers(String newState){
        
        for(Observer observer : list){
            observer.update(newState);
        }
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)
```
　　具体主题角色类
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
public class ConcreteSubject extends Subject{
    
    private String state;
    
    public String getState() {
        return state;
    }
    public void change(String newState){
        state = newState;
        System.out.println("主题状态为：" + state);
        //状态发生改变，通知各个观察者
        this.nodifyObservers(state);
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)
```
　　抽象观察者角色类
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
public interface Observer {
    /**
     * 更新接口
     * @param state    更新的状态
     */
    public void update(String state);
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)
```
　　具体观察者角色类
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
public class ConcreteObserver implements Observer {
    //观察者的状态
    private String observerState;
    
    @Override
    public void update(String state) {
        /**
         * 更新观察者的状态，使其与目标的状态保持一致
         */
        observerState = state;
        System.out.println("状态为："+observerState);
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)
```
　　客户端类
```
![复制代码](http://common.cnblogs.com/images/copycode.gif)
public class Client {
    public static void main(String[] args) {
        //创建主题对象
        ConcreteSubject subject = new ConcreteSubject();
        //创建观察者对象
        Observer observer = new ConcreteObserver();
        //将观察者对象登记到主题对象上
        subject.attach(observer);
        //改变主题对象的状态
        subject.change("new state");
    }
}
![复制代码](http://common.cnblogs.com/images/copycode.gif)
```
　　运行结果如下
　　在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。
　　这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。
[Java](http://lib.csdn.net/base/javase)事件机制包括三个部分：事件、事件监听器、事件源。
1、事件。一般继承自java.util.EventObject类，封装了事件源对象及跟事件相关的信息。
com.javaedu.event.CusEvent类
Java代码  ![收藏代码](http://ericliu1986.iteye.com/images/icon_star.png)
- package com.javaedu.event;  
- 
- import java.util.EventObject;  
- 
- /**
-  * 事件类,用于封装事件源及一些与事件相关的参数.
-  * @author Eric
-  */
- publicclass CusEvent extends EventObject {  
- privatestaticfinallong serialVersionUID = 1L;  
- private Object source;//事件源
- 
- public CusEvent(Object source){  
- super(source);  
- this.source = source;  
-     }  
- 
- public Object getSource() {  
- return source;  
-     }  
- 
- publicvoid setSource(Object source) {  
- this.source = source;  
-     }  
- }  
2、事件监听器。实现java.util.EventListener接口,注册在事件源上,当事件源的属性或状态改变时,取得相应的监听器调用其内部的回调方法。
com.javaedu.event.CusEventListener类
Java代码  ![收藏代码](http://ericliu1986.iteye.com/images/icon_star.png)
- package com.javaedu.event;  
- 
- import java.util.EventListener;  
- 
- /**
-  * 事件监听器，实现java.util.EventListener接口。定义回调方法，将你想要做的事
-  * 放到这个方法下,因为事件源发生相应的事件时会调用这个方法。
-  * @author Eric
-  */
- publicclass CusEventListener implements EventListener {  
- 
- //事件发生后的回调方法
- publicvoid fireCusEvent(CusEvent e){  
-         EventSourceObjecteObject = (EventSourceObject)e.getSource();  
-         System.out.println("My name has been changed!");  
-         System.out.println("I got a new name,named \""+eObject.getName()+"\"");    }  
- }  
3、事件源。事件发生的地方，由于事件源的某项属性或状态发生了改变(比如BUTTON被单击、TEXTBOX的值发生改变等等)导致某项事件发生。换句话说就是生成了相应的事件对象。因为事件监听器要注册在事件源上,所以事件源类中应该要有盛装监听器的容器(List,Set等等)。
 com.javaedu.event.EventSourceObject类
Java代码  ![收藏代码](http://ericliu1986.iteye.com/images/icon_star.png)
- package com.javaedu.event;  
- 
- import java.util.HashSet;  
- import java.util.Iterator;  
- import java.util.Set;  
- 
- /**
-  * 事件源.
-  * @author Eric
-  */
- publicclass EventSourceObject {  
- private String name;  
- //监听器容器
- private Set<CusEventListener> listener;  
- public EventSourceObject(){  
- this.listener = new HashSet<CusEventListener>();  
- this.name = "defaultname";  
-     }  
- //给事件源注册监听器
- publicvoid addCusListener(CusEventListener cel){  
- this.listener.add(cel);  
-     }  
- //当事件发生时,通知注册在该事件源上的所有监听器做出相应的反应（调用回调方法）
- protectedvoid notifies(){  
-         CusEventListener cel = null;  
-         Iterator<CusEventListener> iterator = this.listener.iterator();  
- while(iterator.hasNext()){  
-             cel = iterator.next();  
-             cel.fireCusEvent(new CusEvent(this));  
-         }  
-     }  
- public String getName() {  
- return name;  
-     }  
- //模拟事件触发器，当成员变量name的值发生变化时，触发事件。
- publicvoid setName(String name) {  
- if(!this.name.equals(name)){  
- this.name = name;  
-             notifies();  
-         }        
-     }  
- }  
下面是主方法类
 com.javaedu.event.MainTest类、
Java代码  ![收藏代码](http://ericliu1986.iteye.com/images/icon_star.png)
- package com.javaedu.event;  
- 
- publicclass MainTest {  
- 
- /**
-      * @param args
-      */
- publicstaticvoid main(String[] args) {  
-         EventSourceObject object = new EventSourceObject();  
- //注册监听器
-         object.addCusListener(new CusEventListener(){  
- @Override
- publicvoid fireCusEvent(CusEvent e) {  
- super.fireCusEvent(e);  
-             }  
-         });  
- //触发事件
-         object.setName("eric");  
-     }  
- }  
