# 漫画算法：辗转相除法是什么鬼？ - z69183787的专栏 - CSDN博客
2017年03月21日 15:16:33[OkidoGreen](https://me.csdn.net/z69183787)阅读数：770
http://blog.jobbole.com/106315/
![](https://img-blog.csdn.net/20170321153658706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejY5MTgzNzg3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
小灰的思路十分简单。他使用暴力枚举的方法，试图寻找到一个合适的整数 i，看看这个整数能否被两个整型参数numberA和numberB同时整除。
这个整数 i 从2开始循环累加，一直累加到 numberA 和 numberB 中较小参数的一半为止。循环结束后，上一次寻找到的能够被两数整除的最大 i 值，就是两数的最大公约数。
辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。它是已知最古老的算法， 其可追溯至公元前300年前。
这条算法基于一个定理：两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。比如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最大公约数。
有了这条定理，求出最大公约数就简单了。我们可以使用递归的方法来把问题逐步简化。
首先，我们先计算出a除以b的余数c，把问题转化成求出b和c的最大公约数；然后计算出b除以c的余数d，把问题转化成求出c和d的最大公约数；再然后计算出c除以d的余数e，把问题转化成求出d和e的最大公约数……
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。
五分钟后，小灰改好了代码……
![](https://img-blog.csdn.net/20170321153832222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejY5MTgzNzg3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
更相减损术， 出自于中国古代的《九章算术》，也是一种求最大公约数的算法。
他的原理更加简单：两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。比如10和25，25减去10的差是15,那么10和25的最大公约数，等同于10和15的最大公约数。
由此，我们同样可以通过递归来简化问题。首先，我们先计算出a和b的差值c（假设a>b），把问题转化成求出b和c的最大公约数；然后计算出c和b的差值d（假设c>b），把问题转化成求出b和d的最大公约数；再然后计算出b和d的差值e（假设b>d），把问题转化成求出d和e的最大公约数……
以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的两个数。
五分钟后，小灰重写了代码……
![](https://img-blog.csdn.net/20170321154708154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejY5MTgzNzg3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论。其中gcb(a,b)的意思是a,b的最大公约数函数：
当a和b均为偶数，gcb(a,b) = 2*gcb(a/2, b/2) = 2*gcb(a>>1, b>>1)
当a为偶数，b为奇数，gcb(a,b) = gcb(a/2, b) = gcb(a>>1, b)
当a为奇数，b为偶数，gcb(a,b) = gcb(a, b/2) = gcb(a, b>>1)
当a和b均为奇数，利用更相减损术运算一次，gcb(a,b) = gcb(b, a-b)， 此时a-b必然是偶数，又可以继续进行移位运算。
比如计算10和25的最大公约数的步骤如下：
- 整数10通过移位，可以转换成求5和25的最大公约数
- 利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数
- 整数20通过移位，可以转换成求5和10的最大公约数
- 整数10通过移位，可以转换成求5和5的最大公约数
- 利用更相减损法，因为两数相等，所以最大公约数是5
在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。
![](https://img-blog.csdn.net/20170321154745930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvejY5MTgzNzg3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
最后总结一下上述所有解法的时间复杂度：
1.暴力枚举法：时间复杂度是O(min(a, b)))
2.辗转相除法：时间复杂度不太好计算，可以近似为O(log(min(a, b)))，但是取模运算性能较差。
3.更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为O(max(a, b)))
4.更相减损术与移位结合：不但避免了取模运算，而且算法性能稳定，时间复杂度为O(log(max(a, b)))
本文原本只写到辗转相除法就终告结束，后来网友们指出还有更优化的解法，看来自己还是才疏学浅，很感谢大家指出问题。另外，方法的参数默认必定是正整数，所以在代码中省去了合法性检查。
文中描述的更相减损术是简化了的方式。在九章算术原文中多了一步验证：如果两数都是偶数，计算差值之前会首先让两个数都折半，使得计算次数更少。这种方法做到了部分优化，但古人似乎没想到一奇一偶的情况也是可以优化的。
