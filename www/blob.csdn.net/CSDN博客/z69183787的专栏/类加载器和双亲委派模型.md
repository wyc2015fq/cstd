# 类加载器和双亲委派模型 - z69183787的专栏 - CSDN博客
2016年06月13日 14:43:35[OkidoGreen](https://me.csdn.net/z69183787)阅读数：960
**类加载器按照层次，从顶层到底层，分为以下三种**：
 （1）启动类加载器（Bootstrap ClassLoader）
  这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。
 （2）扩展类加载器（Extension ClassLoader）
  这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
 （3）应用程序类加载器（Application ClassLoader）
  这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器
**类加载的双亲委派模型**  双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码
  工作过程：
   如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，
   只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载
  好处：
   Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，它放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类
   判断两个类是否相同是通过classloader.class这种方式进行的，所以哪怕是同一个class文件如果被两个classloader加载，那么他们也是不同的类
** 实现自己的加载器**  只需要继承ClassLoader，并覆盖findClass方法。
  在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载
  参考：[http://blog.csdn.net/altchen/article/details/328698](http://blog.csdn.net/altchen/article/details/328698)
类加载器如何识别
  通过findLoadedClass来识别是否已经加载某个类，这个方法是findLoadedClass0的一个包装类，而findLoadedClass0是一个native方法
