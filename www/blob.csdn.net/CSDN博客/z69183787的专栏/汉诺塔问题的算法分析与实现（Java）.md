# 汉诺塔问题的算法分析与实现（Java） - z69183787的专栏 - CSDN博客
2018年04月08日 15:26:53[OkidoGreen](https://me.csdn.net/z69183787)阅读数：122
个人分类：[算法](https://blog.csdn.net/z69183787/article/category/2176993)
[http://www.cnblogs.com/chenying99/p/3675843.html](http://www.cnblogs.com/chenying99/p/3675843.html)
汉诺塔问题是源于印度一个古老传说的益智玩具。要求将圆盘从A柱移动到C柱规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
可以先通过3个盘子的hanoi游戏得出其算法步骤如下：
if n=1 , 直接将圆盘移到c棒
if n>1 , 
将A棒上的n-1个圆盘移到B棒上
将A棒上的1个圆盘移到C棒上
将B棒上的n-1个圆盘移到C棒上 
![](https://images0.cnblogs.com/i/106545/201404/202311420578694.jpg)
（图：3个盘子时第一步和第二步如上图所示） 
用Java的实现代码如下
```
```java
package
```
```java
cn.myseu.test.hanoi;
```
```java
public
```
```java
class
```
```java
Hanoi
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
hanoi(
```
```java
3
```
```java
,
```
```java
'A'
```
```java
,
```
```java
'B'
```
```java
,
```
```java
'C'
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
```
```java
/**
```
```java
```
```java
*
 the implementation of hanoi, move all the plates from stick-src to stick-dest
```
```java
```
```java
*
 @param n the amount of plates
```
```java
```
```java
*
 @param src the first stick
```
```java
```
```java
*
 @param assist the middle stick
```
```java
```
```java
*
 @param dest the destination stick
```
```java
```
```java
*/
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
hanoi(
```
```java
int
```
```java
n,
```
```java
char
```
```java
src,
```
```java
char
```
```java
mid,
```
```java
char
```
```java
dest){
```
```java
```
```java
if
```
```java
(n==
```
```java
1
```
```java
){
```
```java
```
```java
move(src,dest);
```
```java
```
```java
}
```
```java
```
```java
else
```
```java
{
```
```java
```
```java
//move
 n-1 plates from stick-src to stick-mid ,assisted by stick-dest
```
```java
```
```java
hanoi(n-
```
```java
1
```
```java
,src,dest,mid);
```
```java
```
```java
//move
 the left 1 plate to the stick-dest directly
```
```java
```
```java
move(src,dest);
```
```java
```
```java
//move
 the left n-1 plates from stick-mid to sitck-dest
```
```java
```
```java
hanoi(n-
```
```java
1
```
```java
,mid,src,dest);
```
```java
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
move(
```
```java
char
```
```java
src,
```
```java
char
```
```java
dest){
```
```java
```
```java
System.out.println(
```
```java
"Move
 the plate from "
```
```java
+
 src +
```
```java
"
 to "
```
```java
+
```
```java
"
 dest "
```
```java
);
```
```java
```
```java
}
```
```java
}
```
```
算法分析：
n = 1 时，只需要移动一次即可完成任务
n > 1 时，需要 (2^n -1) 次，该算法的时间效率为O(2^n)
补充一句：
对时间效率为指数级的O(2^n)算法，以及数量级等同于O(2^n)的O(n!)算法，用现在的计算机处理无法得到结果
