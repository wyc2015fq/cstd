# AOP 之 6.1 AOP基础 ——跟我学spring3 - z69183787的专栏 - CSDN博客
2013年12月05日 15:48:56[OkidoGreen](https://me.csdn.net/z69183787)阅读数：864
### 6.1.1  AOP是什么
        考虑这样一个问题：需要对系统中的某些业务做日志记录，比如支付系统中的支付业务需要记录支付相关日志，对于支付系统可能相当复杂，比如可能有自己的支付系统，也可能引入第三方支付平台，面对这样的支付系统该如何解决呢？
- 传统解决方案：
              1）日志部分提前公共类LogUtils，定义“longPayBegin”方法用于记录支付开始日志，“logPayEnd”用于记录支付结果：
![](http://sishuok.com/forum/upload/2012/2/21/c3927e17d7bae5694338798df3589567__1.JPG)
              2）支付部分，定义IPayService接口并定义支付方法“pay”，并定义了两个实现：“PointPayService”表示积分支付，“RMBPayService”表示人民币支付；并且在每个支付实现中支付逻辑和记录日志：
![](http://sishuok.com/forum/upload/2012/2/21/4213c0ed5f313b4532b7daa0412515cf__2.JPG)
              3）支付实现很明显有重复代码，这个重复很明显可以使用模板设计模式消除重复：
![](http://sishuok.com/forum/upload/2012/2/21/0793d54a596babc3dbc4d3c7c46b1501__3.JPG)
4）到此我们设计了一个可以复用的接口；但大家觉得这样记录日志会很好吗，有没有更好的解决方案？
如果对积分支付方式添加统计功能，比如在支付时记录下用户总积分数、当前消费的积分数，那我们该如何做呢？直接修改源代码添加日志记录，这完全违背了面向对象最重要的原则之一：开闭原则（对扩展开放，对修改关闭）？
- 更好的解决方案：在我们的支付组件中由于使用了日志组件，即日志模块横切于支付组件，在传统程序设计中很难将日志组件分离出来，即不耦合我们的支付组件；因此面向方面编程AOP就诞生了，它能分离我们的组件，使组件完全不耦合:
1）采用面向方面编程后，我们的支付组件看起来如下所示，代码中不再有日志组件的任何东西；
![](http://sishuok.com/forum/upload/2012/2/21/e2e5d8296fca9b8bd78b4baf0e228898__4.JPG)
2）所以日志相关的提取到一个切面中，AOP实现者会在合适的时候将日志功能织入到我们的支付组件中去，从而完全解耦支付组件和日志组件。
![](http://sishuok.com/forum/upload/2012/2/21/ff4df8e93fc5e70116f6345bdb655371__5.JPG)
看到这大家可能不是很理解，没关系，先往下看。
> 
面向方面编程(AOP)：也可称为面向切面编程，是一种编程范式，提供从另一个角度来考虑程序结构从而完善面向对象编程(OOP)。
       在进行OOP开发时，都是基于对组件（比如类）进行开发，然后对组件进行组合，OOP最大问题就是无法解耦组件进行开发，比如我们上边举例，而AOP就是为了克服这个问题而出现的，它来进行这种耦合的分离。
       AOP为开发者提供一种进行横切关注点（比如日志关注点横切了支付关注点）分离并织入的机制，把横切关注点分离，然后通过某种技术织入到系统中，从而无耦合的完成了我们的功能。
### 6.1.2  能干什么
       AOP主要用于横切关注点分离和织入，因此需要理解横切关注点和织入：
- 关注点：可以认为是所关注的任何东西，比如上边的支付组件；
- 关注点分离：将问题细化从而单独部分，即可以理解为不可再分割的组件，如上边的日志组件和支付组件；
- 横切关注点：一个组件无法完成需要的功能，需要其他组件协作完成，如日志组件横切于支付组件；
- 织入：横切关注点分离后，需要通过某种技术将横切关注点融合到系统中从而完成需要的功能，因此需要织入，织入可能在编译期、加载期、运行期等进行。
横切关注点可能包含很多，比如非业务的：日志、事务处理、缓存、性能统计、权限控制等等这些非业务的基础功能；还可能是业务的：如某个业务组件横切于多个模块。如图6-1
![](http://sishuok.com/forum/upload/2012/2/21/cefb51a30cc92efc92d0cf70da7d64b7__6.JPG)
图6-1 关注点与横切关注点
       传统支付形式，流水方式：
![](http://sishuok.com/forum/upload/2012/2/21/434713b10afdae912314c9764ed440e7__7.JPG)
       面向切面方式，先将横切关注点分离，再将横切关注点织入到支付系统中：
![](http://sishuok.com/forum/upload/2012/2/21/464cf273a447ba45ba074d6b0ed672dc__8.JPG)
AOP能干什么：
- 用于横切关注点的分离和织入横切关注点到系统；比如上边提到的日志等等；
- 完善OOP；
- 降低组件和模块之间的耦合性；
- 使系统容易扩展；
- 而且由于关注点分离从而可以获得组件的更好复用。
### 6.1.3  AOP的基本概念
       在进行AOP开发前，先熟悉几个概念：
- 连接点（Jointpoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为“在哪里干”；
- 切入点（Pointcut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在哪里干的集合”；
- 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”；
- 方面/切面（Aspect）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”；
- 引入（inter-type declaration）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“干什么（引入什么）”；
- 目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁干”；
- AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。
- 织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。
在AOP中，通过切入点选择目标对象的连接点，然后在目标对象的相应连接点处织入通知，而切入点和通知就是切面（横切关注点），而在目标对象连接点处应用切面的实现方式是通过AOP代理对象，如图6-2所示。
![](http://sishuok.com/forum/upload/2012/2/21/84c94f56f613014442301bee234480f7__9.JPG)
图6-2 概念关系
接下来再让我们具体看看Spring有哪些通知类型：
- 前置通知（Before Advice）:在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。
- 后置通知（After Advice）:在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：
- 后置返回通知（After returning Advice）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。
- 后置异常通知（After throwing Advice）: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。
- 后置最终通知（After finally Advice）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。
- 环绕通知（Around Advices）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。
各种通知类型在UML序列图中的位置如图6-3所示：
![](http://sishuok.com/forum/upload/2012/2/21/b4447d0a13f6fcfd520bdbb14076c625__10.JPG)
图6-3 通知类型
### 6.1.4  AOP代理
       AOP代理就是AOP框架通过代理模式创建的对象，Spring使用JDK动态代理或CGLIB代理来实现，Spring缺省使用JDK动态代理来实现，从而任何接口都可别代理，如果被代理的对象实现不是接口将默认使用CGLIB代理，不过CGLIB代理当然也可应用到接口。
AOP代理的目的就是将切面织入到目标对象。
       概念都将完了，接下来让我们看一下AOP的 HelloWorld!吧。
原创内容 转自请注明出处【[http://sishuok.com/forum/blogPost/list/2466.html](http://sishuok.com/forum/blogPost/list/2466.html)】
