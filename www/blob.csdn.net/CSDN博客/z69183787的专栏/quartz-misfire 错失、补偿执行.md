# quartz-misfire 错失、补偿执行 - z69183787的专栏 - CSDN博客
2018年04月28日 20:54:34[OkidoGreen](https://me.csdn.net/z69183787)阅读数：219
[https://www.cnblogs.com/skyLogin/p/6927629.html](https://www.cnblogs.com/skyLogin/p/6927629.html)
调度(scheduleJob)或恢复调度(resumeTrigger,resumeJob)后不同的misfire对应的处理规则
misfire产生的条件是：到了该触发执行时上一个执行还未完成，且线程池中没有空闲线程可以使用（或有空闲线程可以使用但job设置为@DisallowConcurrentExecution）且过期时间已经超过misfireThreshold就认为是misfire了，错失触发了
比如：13:07:24开始执行，重复执行5次，开始执行时，quartz已经计算好每次调度的时间刻，分别如下：
03:33:36，03:33:39，03:33:42，03:33:45，03:33:48，03:33:51
如果第一次执行时间为11s，到03:33:47结束，03:33:47减去03:33:39的时间间隔是8s，如果misfireThreshold设置的时间小于等于8s间隔，则认为是misfire了，如果大于8s间隔，则认为没有misfire。
## CronTrigger 
```
```java
CronScheduleBuilder
 csb = CronScheduleBuilder.cronSchedule(
```
```java
"0/5
 * * * * ?"
```
```java
);
```
```java
csb.withMisfireHandlingInstructionDoNothing();
```
```java
csb.withMisfireHandlingInstructionFireAndProceed();(默认)
```
```java
csb.withMisfireHandlingInstructionIgnoreMisfires();
```
```
```
```java
withMisfireHandlingInstructionDoNothing
```
```java
——不触发立即执行
```
```java
——等待下次Cron触发频率到达时刻开始按照Cron频率依次执行
```
```
```
```java
withMisfireHandlingInstructionIgnoreMisfires
```
```java
——以错过的第一个频率时间立刻开始执行
```
```java
——重做错过的所有频率周期后
```
```java
——当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行
```
```
```
```java
withMisfireHandlingInstructionFireAndProceed（默认）
```
```java
——以当前时间为触发频率立刻触发一次执行
```
```java
——然后按照Cron频率依次执行
```
```
## SimpleTrigger 
```
```java
SimpleScheduleBuilder
 ssb = SimpleScheduleBuilder.simpleSchedule();
```
```java
ssb.withMisfireHandlingInstructionFireNow();
```
```java
ssb.withMisfireHandlingInstructionIgnoreMisfires();
```
```java
ssb.withMisfireHandlingInstructionNextWithExistingCount();
```
```java
ssb.withMisfireHandlingInstructionNextWithRemainingCount();
```
```java
ssb.withMisfireHandlingInstructionNowWithExistingCount();　　（默认）
```
```java
ssb.withMisfireHandlingInstructionNowWithRemainingCount();
```
```
```
```java
withMisfireHandlingInstructionFireNow
```
```java
——以当前时间为触发频率立即触发执行
```
```java
——执行至FinalTIme的剩余周期次数
```
```java
——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到
```
```java
——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值
```
```
```
```java
withMisfireHandlingInstructionIgnoreMisfires
```
```java
——以错过的第一个频率时间立刻开始执行
```
```java
——重做错过的所有频率周期
```
```java
——当下一次触发频率发生时间大于当前时间以后，按照Interval的依次执行剩下的频率
```
```java
——共执行RepeatCount+
```
```java
1
```
```java
次
```
```
```
```java
withMisfireHandlingInstructionNextWithExistingCount
```
```java
——不触发立即执行
```
```java
——等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数
```
```java
——以startTime为基准计算周期频率，并得到FinalTime
```
```java
——即使中间出现pause，resume以后保持FinalTime时间不变
```
```
```
```java
withMisfireHandlingInstructionNextWithRemainingCount
```
```java
——不触发立即执行
```
```java
——等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数
```
```java
——以startTime为基准计算周期频率，并得到FinalTime
```
```java
——即使中间出现pause，resume以后保持FinalTime时间不变
```
```
```
```java
withMisfireHandlingInstructionNowWithExistingCount（默认）
```
```java
——以当前时间为触发频率立即触发执行
```
```java
——执行至FinalTIme的剩余周期次数
```
```java
——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到
```
```java
——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值
```
```
```
```java
withMisfireHandlingInstructionNowWithRemainingCount
```
```java
——以当前时间为触发频率立即触发执行
```
```java
——执行至FinalTIme的剩余周期次数
```
```java
——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到
```
```java
——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值
```
```java
MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT
```
```java
——此指令导致trigger忘记原始设置的starttime和repeat-count
```
```java
——触发器的repeat-count将被设置为剩余的次数
```
```java
——这样会导致后面无法获得原始设定的starttime和repeat-count值
```
```
## misfireHandler线程
下面这些原因可能造成 misfired job:
- 系统因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；
- Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；
- 线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；
- 有状态任务在下次触发时间到达时，上次执行还没有结束；为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW线程默认1分钟执行一次；在一个事务中，默认一次最多recovery
 20个；
执行流程：
- 若配置(默认为true，可配置)成获取锁前先检查是否有需要recovery的trigger，先获取misfireCount；
- 获取TRIGGER_ACCESS锁；
- hasMisfiredTriggersInState：获取misfired的trigger，默认一个事务里只能最大20个misfired trigger（可配置），misfired判断依据：status=waiting,next_fire_time < current_time-misfirethreshold(可配置，默认1min)
- notifyTriggerListenersMisfired
- updateAfterMisfire:获取misfire策略(默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW)，根据策略更新nextFireTime；
- 将nextFireTime等更新到trigger表；
- commit connection，释放锁
- 如果还有更多的misfired，sleep短暂时间(为了集群负载均衡)，否则sleep misfirethreshold时间，后继续轮询；
misfireHandler线程执行流程如下图所示：
![](https://images2015.cnblogs.com/blog/1125107/201706/1125107-20170606092819028-1448288817.png)
