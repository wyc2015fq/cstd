# java中的内部类总结 - z69183787的专栏 - CSDN博客
2014年08月22日 14:00:50[OkidoGreen](https://me.csdn.net/z69183787)阅读数：803
内部类不是很好理解，但说白了其实也就是一个类中还包含着另外一个类
如同一个人是由大脑、肢体、器官等身体结果组成，而内部类相当于其中的某个器官之一，例如心脏：它也有自己的属性和行为（血液、跳动）
显然，此处不能单方面用属性或者方法表示一个心脏，而需要一个类
而心脏又在人体当中，正如同是内部类在外部内当中
#### 实例1：内部类的基本结构
```
```java
//外部类
```
```java
class
```
```java
Out
 {
```
```java
```
```java
private
```
```java
int
```
```java
age
 =
```
```java
12
```
```java
;
```
```java
```
```java
```
```java
//内部类
```
```java
```
```java
class
```
```java
In
 {
```
```java
```
```java
public
```
```java
void
```
```java
print()
 {
```
```java
```
```java
System.out.println(age);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
Demo
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
Out.In
 in =
```
```java
new
```
```java
Out().
```
```java
new
```
```java
In();
```
```java
```
```java
in.print();
```
```java
```
```java
//或者采用下种方式访问
```
```java
```
```java
/*
```
```java
```
```java
Out
 out = new Out();
```
```java
```
```java
Out.In
 in = out.new In();
```
```java
```
```java
in.print();
```
```java
```
```java
*/
```
```java
```
```java
}
```
```java
}
```
```
运行结果：12
从上面的例子不难看出，内部类其实严重破坏了良好的代码结构，但为什么还要使用内部类呢？
因为内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点
如同心脏可以直接访问身体的血液，而不是通过医生来抽血
程序编译过后会产生两个.class文件，分别是Out.class和Out$In.class
其中$代表了上面程序中Out.In中的那个 .
Out.In in = new Out().new In()可以用来生成内部类的对象，这种方法存在两个小知识点需要注意
　　1.开头的Out是为了标明需要生成的内部类对象在哪个外部类当中
　　2.必须先有外部类的对象才能生成内部类的对象，因为内部类的作用就是为了访问外部类中的成员变量
#### 实例2：内部类中的变量访问形式
```
```java
class
```
```java
Out
 {
```
```java
```
```java
private
```
```java
int
```
```java
age
 =
```
```java
12
```
```java
;
```
```java
```
```java
```
```java
class
```
```java
In
 {
```
```java
```
```java
private
```
```java
int
```
```java
age
 =
```
```java
13
```
```java
;
```
```java
```
```java
public
```
```java
void
```
```java
print()
 {
```
```java
```
```java
int
```
```java
age
 =
```
```java
14
```
```java
;
```
```java
```
```java
System.out.println(
```
```java
"局部变量："
```
```java
+
 age);
```
```java
```
```java
System.out.println(
```
```java
"内部类变量："
```
```java
+
```
```java
this
```
```java
.age);
```
```java
```
```java
System.out.println(
```
```java
"外部类变量："
```
```java
+
 Out.
```
```java
this
```
```java
.age);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
Demo
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
Out.In
 in =
```
```java
new
```
```java
Out().
```
```java
new
```
```java
In();
```
```java
```
```java
in.print();
```
```java
```
```java
}
```
```java
}
```
```
运行结果：
局部变量：14
内部类变量：13
外部类变量：12
从实例1中可以发现，内部类在没有同名成员变量和局部变量的情况下，内部类会直接访问外部类的成员变量，而无需指定Out.this.属性名
否则，内部类中的局部变量会覆盖外部类的成员变量
而访问内部类本身的成员变量可用this.属性名，访问外部类的成员变量需要使用Out.this.属性名
#### 实例3：静态内部类
```
```java
class
```
```java
Out
 {
```
```java
```
```java
private
```
```java
static
```
```java
int
```
```java
age
 =
```
```java
12
```
```java
;
```
```java
```
```java
```
```java
static
```
```java
class
```
```java
In
 {
```
```java
```
```java
public
```
```java
void
```
```java
print()
 {
```
```java
```
```java
System.out.println(age);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
Demo
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
Out.In
 in =
```
```java
new
```
```java
Out.In();
```
```java
```
```java
in.print();
```
```java
```
```java
}
```
```java
}
```
```
运行结果：12
可以看到，如果用static 将内部内静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性
其次，因为内部类被静态化，因此Out.In可以当做一个整体看，可以直接new 出内部类的对象（通过类名访问static，生不生成外部类对象都没关系）
#### 实例4：私有内部类
```
```java
class
```
```java
Out
 {
```
```java
```
```java
private
```
```java
int
```
```java
age
 =
```
```java
12
```
```java
;
```
```java
```
```java
```
```java
private
```
```java
class
```
```java
In
 {
```
```java
```
```java
public
```
```java
void
```
```java
print()
 {
```
```java
```
```java
System.out.println(age);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
public
```
```java
void
```
```java
outPrint()
 {
```
```java
```
```java
new
```
```java
In().print();
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
Demo
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
//此方法无效
```
```java
```
```java
/*
```
```java
```
```java
Out.In
 in = new Out().new In();
```
```java
```
```java
in.print();
```
```java
```
```java
*/
```
```java
```
```java
Out
 out =
```
```java
new
```
```java
Out();
```
```java
```
```java
out.outPrint();
```
```java
```
```java
}
```
```java
}
```
```
运行结果：12
如果一个内部类只希望被外部类中的方法操作，那么可以使用private声明内部类
上面的代码中，我们必须在Out类里面生成In类的对象进行操作，而无法再使用Out.In in = new Out().new In() 生成内部类的对象
也就是说，此时的内部类只有外部类可控制
如同是，我的心脏只能由我的身体控制，其他人无法直接访问它
#### 实例5：方法内部类
```
```java
class
```
```java
Out
 {
```
```java
```
```java
private
```
```java
int
```
```java
age
 =
```
```java
12
```
```java
;
```
```java
```
```java
public
```
```java
void
```
```java
Print(
```
```java
final
```
```java
int
```
```java
x)
 {
```
```java
```
```java
class
```
```java
In
 {
```
```java
```
```java
public
```
```java
void
```
```java
inPrint()
 {
```
```java
```
```java
System.out.println(x);
```
```java
```
```java
System.out.println(age);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
new
```
```java
In().inPrint();
```
```java
```
```java
}
```
```java
}
```
```java
public
```
```java
class
```
```java
Demo
 {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[]
 args) {
```
```java
```
```java
Out
 out =
```
```java
new
```
```java
Out();
```
```java
```
```java
out.Print(
```
```java
3
```
```java
);
```
```java
```
```java
}
```
```java
}
```
```
运行结果：
3
12
在上面的代码中，我们将内部类移到了外部类的方法中，然后在外部类的方法中再生成一个内部类对象去调用内部类方法
如果此时我们需要往外部类的方法中传入参数，那么外部类的方法形参必须使用final定义
至于final在这里并没有特殊含义，只是一种表示形式而已
