# Java注解教程：自定义注解示例，利用反射进行解析 - z69183787的专栏 - CSDN博客
2016年05月12日 15:43:43[OkidoGreen](https://me.csdn.net/z69183787)阅读数：918
Java注解能够提供代码的相关信息，同时对于所注解的代码结构又没有直接影响。在这篇教程中，我们将学习Java注解，如何编写自定义注解，注解的使用，以及如何使用反射解析注解。
注解是Java 1.5引入的，目前已被广泛应用于各种Java框架，如Hibernate，[Jersey](http://www.journaldev.com/498/rest-using-jersey-complete-tutorial-with-jaxb-exception-handling-and-client-program)，Spring。注解相当于是一种嵌入在程序中的元数据，可以使用注解解析工具或编译器对其进行解析，也可以指定注解在编译期或运行期有效。
在注解诞生之前，程序的元数据存在的形式仅限于java注释或javadoc，但注解可以提供更多功能，它不仅包含元数据，还能作用于运行期，注解解析器能够使用注解决定处理流程。举个例子，在[Jersey
 webservice](http://www.journaldev.com/498/rest-using-jersey-complete-tutorial-with-jaxb-exception-handling-and-client-program)中，我们在一个方法上添加了PATH注解和URI字符串，在运行期，jersey会对其进行解析，并决定作用于指定URI模式的方法。
在Java中创建自定义注解
创建自定义注解与编写接口很相似，除了它的接口关键字前有个@符号。我们可以在注解中定义方法，先来看个例子，之后我们会继续讨论它的特性。
```
```java
package
```
```java
com.journaldev.annotations;
```
```java
import
```
```java
java.lang.annotation.Documented;
```
```java
import
```
```java
java.lang.annotation.ElementType;
```
```java
import
```
```java
java.lang.annotation.Inherited;
```
```java
import
```
```java
java.lang.annotation.Retention;
```
```java
import
```
```java
java.lang.annotation.RetentionPolicy;
```
```java
import
```
```java
java.lang.annotation.Target;
```
```java
@Documented
```
```java
@Target
```
```java
(ElementType.METHOD)
```
```java
@Inherited
```
```java
@Retention
```
```java
(RetentionPolicy.RUNTIME)
```
```java
public
```
```java
@interface
```
```java
MethodInfo{
```
```java
```
```java
String
 author()
```
```java
default
```
```java
"Pankaj"
```
```java
;
```
```java
```
```java
String
 date();
```
```java
```
```java
int
```
```java
revision()
```
```java
default
```
```java
1
```
```java
;
```
```java
```
```java
String
 comments();
```
```java
}
```
```
- 注解方法不能有参数。
- 注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组。
- 注解方法可以包含默认值。
- 注解可以包含与其绑定的元注解，元注解为注解提供信息，有四种元注解类型：
1. @Documented – 表示使用该注解的元素应被javadoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分。
2. @Target – 表示支持注解的程序元素的种类，一些可能的值有TYPE, METHOD, CONSTRUCTOR, FIELD等等。如果Target元注解不存在，那么该注解就可以使用在任何程序元素之上。
3. @Inherited – 表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。
4. @Retention – 表示注解类型保留时间的长短，它接收RetentionPolicy参数，可能的值有SOURCE, CLASS, 以及RUNTIME。
Java内置注解
Java提供3种内置注解。
1. @Override – 当我们想要覆盖父类的一个方法时，需要使用该注解告知编译器我们正在覆盖一个方法。这样的话，当父类的方法被删除或修改了，编译器会提示错误信息。大家可以学习一下为什么我们总是应该在覆盖方法时使用[Java覆盖注解](http://www.journaldev.com/817/overriding-methods-in-java-always-use-override-annotation)。
2. @Deprecated – 当我们想要让编译器知道一个方法已经被弃用(deprecate)时，应该使用这个注解。Java推荐在javadoc中提供信息，告知用户为什么这个方法被弃用了，以及替代方法是什么。
3. @SuppressWarnings – 这个注解仅仅是告知编译器，忽略它们产生了特殊警告，比如：在[java泛型](http://www.journaldev.com/1663/java-generics-tutorial-example-class-interface-methods-wildcards-and-much-more)中使用原始类型。它的保持性策略(retention
 policy)是SOURCE，在编译器中将被丢弃。
我们来看一个例子，展示了如何使用内置注解，以及上述示例中提及的自定义注解。
```
```java
package
```
```java
com.journaldev.annotations;
```
```java
import
```
```java
java.io.FileNotFoundException;
```
```java
import
```
```java
java.util.ArrayList;
```
```java
import
```
```java
java.util.List;
```
```java
public
```
```java
class
```
```java
AnnotationExample {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args) {
```
```java
```
```java
}
```
```java
```
```java
@Override
```
```java
```
```java
@MethodInfo
```
```java
(author
 =
```
```java
"Pankaj"
```
```java
,
 comments =
```
```java
"Main
 method"
```
```java
,
 date =
```
```java
"Nov
 17 2012"
```
```java
,
 revision =
```
```java
1
```
```java
)
```
```java
```
```java
public
```
```java
String toString() {
```
```java
```
```java
return
```
```java
"Overriden toString method"
```
```java
;
```
```java
```
```java
}
```
```java
```
```java
@Deprecated
```
```java
```
```java
@MethodInfo
```
```java
(comments
 =
```
```java
"deprecated
 method"
```
```java
,
 date =
```
```java
"Nov
 17 2012"
```
```java
)
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
oldMethod() {
```
```java
```
```java
System.out.println(
```
```java
"old
 method, don't use it."
```
```java
);
```
```java
```
```java
}
```
```java
```
```java
@SuppressWarnings
```
```java
({
```
```java
"unchecked"
```
```java
,
```
```java
"deprecation"
```
```java
})
```
```java
```
```java
@MethodInfo
```
```java
(author
 =
```
```java
"Pankaj"
```
```java
,
 comments =
```
```java
"Main
 method"
```
```java
,
 date =
```
```java
"Nov
 17 2012"
```
```java
,
 revision =
```
```java
10
```
```java
)
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
genericsTest()
```
```java
throws
```
```java
FileNotFoundException {
```
```java
```
```java
List
 l =
```
```java
new
```
```java
ArrayList();
```
```java
```
```java
l.add(
```
```java
"abc"
```
```java
);
```
```java
```
```java
oldMethod();
```
```java
```
```java
}
```
```java
}
```
```
我相信这个例子是很明了的，展示了不同场景下注解的使用方式。
Java注解解析
我们将使用Java反射机制从一个类中解析注解，请记住，注解保持性策略应该是RUNTIME，否则它的信息在运行期无效，我们也不能从中获取任何数据。
```
```java
package
```
```java
com.journaldev.annotations;
```
```java
import
```
```java
java.lang.annotation.Annotation;
```
```java
import
```
```java
java.lang.reflect.Method;
```
```java
public
```
```java
class
```
```java
AnnotationParsing {
```
```java
```
```java
public
```
```java
static
```
```java
void
```
```java
main(String[] args) {
```
```java
```
```java
try
```
```java
{
```
```java
```
```java
for
```
```java
(Method method : AnnotationParsing.
```
```java
class
```
```java
```
```java
.getClassLoader()
```
```java
```
```java
.loadClass((
```
```java
"com.journaldev.annotations.AnnotationExample"
```
```java
))
```
```java
```
```java
.getMethods())
 {
```
```java
```
```java
//
 checks if MethodInfo annotation is present for the method
```
```java
```
```java
if
```
```java
(method
```
```java
```
```java
.isAnnotationPresent(com.journaldev.annotations.MethodInfo.
```
```java
class
```
```java
))
 {
```
```java
```
```java
try
```
```java
{
```
```java
```
```java
//
 iterates all the annotations available in the method
```
```java
```
```java
for
```
```java
(Annotation anno : method.getDeclaredAnnotations()) {
```
```java
```
```java
System.out.println(
```
```java
"Annotation
 in Method '"
```
```java
```
```java
+
 method +
```
```java
"'
 : "
```
```java
+ anno);
```
```java
```
```java
}
```
```java
```
```java
MethodInfo
 methodAnno = method
```
```java
```
```java
.getAnnotation(MethodInfo.
```
```java
class
```
```java
);
```
```java
```
```java
if
```
```java
(methodAnno.revision() ==
```
```java
1
```
```java
)
 {
```
```java
```
```java
System.out.println(
```
```java
"Method
 with revision no 1 = "
```
```java
```
```java
+
 method);
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
catch
```
```java
(Throwable ex) {
```
```java
```
```java
ex.printStackTrace();
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
catch
```
```java
(SecurityException | ClassNotFoundException e) {
```
```java
```
```java
e.printStackTrace();
```
```java
```
```java
}
```
```java
```
```java
}
```
```java
}
```
```
以上程序的输出是：
```
```bash
Annotation
```
```bash
in
```
```bash
Method
```
```bash
'public
 java.lang.String com.journaldev.annotations.AnnotationExample.toString()'
```
```bash
: @com.journaldev.annotations.MethodInfo(author=Pankaj, revision=1, comments=Main method,
```
```bash
date
```
```bash
=Nov
 17 2012)
```
```bash
Method
 with revision no 1 = public java.lang.String com.journaldev.annotations.AnnotationExample.toString()
```
```bash
Annotation
```
```bash
in
```
```bash
Method
```
```bash
'public
 static void com.journaldev.annotations.AnnotationExample.oldMethod()'
```
```bash
: @java.lang.Deprecated()
```
```bash
Annotation
```
```bash
in
```
```bash
Method
```
```bash
'public
 static void com.journaldev.annotations.AnnotationExample.oldMethod()'
```
```bash
: @com.journaldev.annotations.MethodInfo(author=Pankaj, revision=1, comments=deprecated method,
```
```bash
date
```
```bash
=Nov
 17 2012)
```
```bash
Method
 with revision no 1 = public static void com.journaldev.annotations.AnnotationExample.oldMethod()
```
```bash
Annotation
```
```bash
in
```
```bash
Method
```
```bash
'public
 static void com.journaldev.annotations.AnnotationExample.genericsTest() throws java.io.FileNotFoundException'
```
```bash
: @com.journaldev.annotations.MethodInfo(author=Pankaj, revision=10, comments=Main method,
```
```bash
date
```
```bash
=Nov
 17 2012)
```
```
注解API非常强大，被广泛应用于各种Java框架，如Spring，Hibernate，JUnit。可以查看《[Java中的反射](http://www.journaldev.com/1789/java-reflection-tutorial-for-classes-methods-fields-constructors-annotations-and-much-more)》获得更多信息。
这就是java注解教程的全部内容了，我希望你能从中学到一些东西。
原文链接： [Journaldev](http://www.journaldev.com/721/java-annotations-tutorial-with-custom-annotation-example-and-parsing-using-reflection) 翻译： [ImportNew.com](http://www.importnew.com/)- [Justin
 Wu](http://www.importnew.com/author/mybreeze77)
译文链接： [http://www.importnew.com/14479.html](http://www.importnew.com/14479.html)
