# float 和 double的精度和范围 - 战斗蜗牛的专栏 - CSDN博客





2012年11月19日 11:00:15[vbskj](https://me.csdn.net/vbskj)阅读数：811









1. 范围

  float和double的范围是由指数的位数来决定的。
  float的指数位有8位，而double的指数位有11位，分布如下：
  float：
  1bit（符号位） 8bits（指数位） 23bits（尾数位）
![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/1263277f7545a64129388a0e.jpg)





  double：
  1bit（符号位） 11bits（指数位） 52bits（尾数位）

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/0b9a0708c552be79e824880e.jpg)



  于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。

  其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。

  float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。








2.  精度
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。

  float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也**即float的精度为6~7位有效数字**；

  double：2^52 = 4503599627370496，一共16位，同理，**double的精度为15~16位**。




=======================================




R32.24和R64.53的存储方式都是用科学计数法来存储数据的，比如8.25用十进制的科学计数法表示就为:8.25*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/bd8d1f30064e19d0a8018e0e.jpg),而120.5可以表示为:1.205*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/7c91b899586bed416f068c0e.jpg),
 这些小学的知识就不用多说了吧。而我们傻蛋计算机根本不认识十进制的数据，他只认识0，1，所以在计算机存储中，首先要将上面的数更改为二进制的科学计数 法表示，8.25用二进制表示可表示为1000.01,我靠，不会连这都不会转换吧?那我估计要没辙了。120.5用二进制表示为：1110110.1用 二进制的科学计数法表示1000.01可以表示为1.0001*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/3cb44c089d6cbcdc0b7b820e.jpg),1110110.1可以表示为1.1101101*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/fbb31d95ff11a3417af4800e.jpg),任何一个数都的科学计数法表示都为1.xxx*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/9fce02088c9eab9863d9860e.jpg),
 尾数部分就可以表示为xxxx,第一位都是1嘛，干嘛还要表示呀？可以将小数点前面的1省略，所以23bit的尾数部分，可以表示的精度却变成了 24bit，道理就是在这里，那24bit能精确到小数点后几位呢，我们知道9的二进制表示为1001，所以4bit能精确十进制中的1位小数点， 24bit就能使float能精确到小数点后6位，而对于指数部分，因为指数可正可负，8位的指数位能表示的指数范围就应该为:-127-128了，所以 指数部分的存储采用移位存储，存储的数据为元数据+127，下面就看看8.25和120.5在内存中真正的存储方式。


     首先看下8.25，用二进制的科学计数法表示为:1.0001*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/ee410ad19bb3539a562c840e.jpg)


按照上面的存储方式，符号位为:0，表示为正，指数位为:3+127=130 ,位数部分为,故8.25的存储方式如下图所示:

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/f76cf2d3ac46b096a8ec9a0e.jpg)


而单精度浮点数120.5的存储方式如下图所示:

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/c29911df54862b5a6227980e.jpg)


那 么如果给出内存中一段数据，并且告诉你是单精度存储的话，你如何知道该数据的十进制数值呢？其实就是对上面的反推过程，比如给出如下内存 数据：0100001011101101000000000000，首先我们现将该数据分段，0 10000 0101 110 1101 0000 0000 0000 0000，在内存中的存储就为下图所示：

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/3c598a139c4dc399f6039e0e.jpg)


根据我们的计算方式，可以计算出，这样一组数据表示为:1.1101101*![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/f69262d0f66830c6a1ec9c0e.jpg)=120.5


而双精度浮点数的存储和单精度的存储大同小异，不同的是指数部分和尾数部分的位数。所以这里不再详细的介绍双精度的存储方式了，只将120.5的最后存储方式图给出，大家可以仔细想想为何是这样子的

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/62b6918fa387a9b3503d920e.jpg)


下面我就这个基础知识点来解决一个我们的一个疑惑，请看下面一段程序，注意观察输出结果


            float f = 2.2f;


            double d = (double)f;


            Console.WriteLine(d.ToString("0.0000000000000"));


            f = 2.25f;


            d = (double)f;


            Console.WriteLine(d.ToString("0.0000000000000"));


可 能输出的结果让大家疑惑不解，单精度的2.2转换为双精度后，精确到小数点后13位后变为了2.2000000476837，而单精度的 2.25转换为双精度后，变为了2.2500000000000，为何2.2在转换后的数值更改了而2.25却没有更改呢？很奇怪吧？其实通过上面关于两 种存储结果的介绍，我们已经大概能找到答案。首先我们看看2.25的单精度存储方式，很简单 0 1000 0001 001 0000 0000 0000 0000 0000,而2.25的双精度表示为:0 100 0000 0001 0010
 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000,这样2.25在进行强制转换的时候，数值是不会变的，而我们再看看2.2呢，2.2用科学计数法表示应该为：将十进制的小数转换为二进制的小数 的方法为将小数*2，取整数部分，所以0.282=0.4，所以二进制小数第一位为0.4的整数部分0，0.4×2=0.8，第二位为0,0.8*2= 1.6,第三位为1，0.6×2 = 1.2，第四位为1，0.2*2=0.4，第五位为0，这样永远也不可能乘到=1.0，得到的二进制是一个无限循环的排列
 00110011001100110011... ,对于单精度数据来说，尾数只能表示24bit的精度，所以2.2的float存储为:

![float和double的范围和精度(转) - 地瓜爱红薯 - 我的博客](http://hiphotos.baidu.com/wcwh/pic/item/c48826975e859c2454fb960e.jpg)


但 是这样存储方式，换算成十进制的值，却不会是2.2的，应为十进制在转换为二进制的时候可能会不准确，如2.2，而double类型的数 据也存在同样的问题，所以在浮点数表示中会产生些许的误差，在单精度转换为双精度的时候，也会存在误差的问题，对于能够用二进制表示的十进制数据，如 2.25，这个误差就会不存在，所以会出现上面比较奇怪的输出结果。





