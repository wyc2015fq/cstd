# CPU相关的18个概念 - 战斗蜗牛的专栏 - CSDN博客





2014年08月06日 23:10:34[vbskj](https://me.csdn.net/vbskj)阅读数：1183







1.主频 
　　主频也叫时钟频率，单位是MHz，用来表示CPU的运算速度。CPU的主频＝外频×倍频系数。很多人认为主频就决定着CPU的运行速度，这不仅是个片面的，而且对于服务器来讲，这个认识也出现了偏差。至今，没有一条确定的公式能够实现主频和实际的运算速度两者之间的数值关系，即使是两大处理器厂家Intel和AMD，在这点上也存在着很大的争议，我们从Intel的产品的发展趋势，可以看出Intel很注重加强自身主频的发展。像其他的处理器厂家，有人曾经拿过一快1G的全美达来做比较，它的运行效率相当于2G的Intel处理器。 

　　所以，CPU的主频与CPU实际的运算能力是没有直接关系的，主频表示在CPU内数字脉冲信号震荡的速度。在Intel的处理器产品中，我们也可以看到这样的例子：1 GHz Itanium芯片能够表现得差不多跟2.66 GHz Xeon/Opteron一样快，或是1.5 GHz Itanium 2大约跟4 GHz Xeon/Opteron一样快。CPU的运算速度还要看CPU的流水线的各方面的性能指标。 
　　当然，主频和实际的运算速度是有关的，只能说主频仅仅是CPU性能表现的一个方面，而不代表CPU的整体性能。 

　　2.外频 
　　外频是CPU的基准频率，单位也是MHz。CPU的外频决定着整块主板的运行速度。说白了，在台式机中，我们所说的超频，都是超CPU的外频（当然一般情况下，CPU的倍频都是被锁住的）相信这点是很好理解的。但对于服务器CPU来讲，超频是绝对不允许的。前面说到CPU决定着主板的运行速度，两者是同步运行的，如果把服务器CPU超频了，改变了外频，会产生异步运行，（台式机很多主板都支持异步运行）这样会造成整个服务器系统的不稳定。 

　　目前的绝大部分电脑系统中外频也是内存与主板之间的同步运行的速度，在这种方式下，可以理解为CPU的外频直接与内存相连通，实现两者间的同步运行状态。外频与前端总线(FSB)频率很容易被混为一谈，下面的前端总线介绍我们谈谈两者的区别。 

　　3.前端总线(FSB)频率 
　　前端总线(FSB)频率(即总线频率)是直接影响CPU与内存直接数据交换速度。有一条公式可以计算，即数据带宽＝(总线频率×数据带宽)/8，数据传输最大带宽取决于所有同时传输的数据的宽度和传输频率。比方，现在的支持64位的至强Nocona，前端总线是800MHz，按照公式，它的数据传输最大带宽是6.4GB/秒。 

　　外频与前端总线(FSB)频率的区别：前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。也就是说，100MHz外频特指数字脉冲信号在每秒钟震荡一千万次；而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是100MHz×64bit÷8Byte/bit=800MB/s。 

　　其实现在“HyperTransport”构架的出现，让这种实际意义上的前端总线(FSB)频率发生了变化。之前我们知道IA-32架构必须有三大重要的构件：内存控制器Hub (MCH) ,I/O控制器Hub和PCI Hub，像Intel很典型的芯片组 Intel 7501、Intel7505芯片组，为双至强处理器量身定做的，它们所包含的MCH为CPU提供了频率为533MHz的前端总线，配合DDR内存，前端总线带宽可达到4.3GB/秒。但随着处理器性能不断提高同时给系统架构带来了很多问题。而“HyperTransport”构架不但解决了问题，而且更有效地提高了总线带宽，比方AMD
 Opteron处理器，灵活的HyperTransport I/O总线体系结构让它整合了内存控制器，使处理器不通过系统总线传给芯片组而直接和内存交换数据。这样的话，前端总线(FSB)频率在AMD Opteron处理器就不知道从何谈起了。 
　　老图夫原创，欢迎收藏，打击盗版！

　　4、CPU的位和字长 
　　位：在数字电路和电脑技术中采用二进制，代码只有“0”和“1”，其中无论是 “0”或是“1”在CPU中都是 一“位”。 
　　字长：电脑技术中对CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。所以能处理字长为8位数据的CPU通常就叫8位的CPU。同理32位的CPU就能在单位时间内处理字长为32位的二进制数据。字节和字长的区别：由于常用的英文字符用8位二进制就可以表示，所以通常就将8位称为一个字节。字长的长度是不固定的，对于不同的CPU、字长的长度也不一样。8位的CPU一次只能处理一个字节，而32位的CPU一次就能处理4个字节，同理字长为64位的CPU一次可以处理8个字节。 

　　5.倍频系数 
　　倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也越高。但实际上，在相同外频的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间数据传输速度是有限的，一味追求高倍频而得到高主频的CPU就会出现明显的“瓶颈”效应—CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。一般除了工程样版的Intel的CPU都是锁了倍频的，而AMD之前都没有锁
 。
6.缓存 
　　缓存大小也是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频运作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内部读取数据的命中率，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是由于CPU芯片面积和成本的因素来考虑，缓存都很小。 

　　L1　Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般服务器CPU的L1缓存的容量通常在32—256KB。 
　　L2　Cache(二级缓存)是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是512KB，而服务器和工作站上用CPU的L2高速缓存更高达256-1MB，有的高达2MB或者3MB。 

　　L3　Cache(三级缓存)，分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。降低内存延迟和提升大数据量计算能力对游戏都很有帮助。而在服务器领域增加L3缓存在性能方面仍然有显著的提升。比方具有较大L3缓存的配置利用物理内存会更有效，故它比较慢的磁盘I/O子系统可以处理更多的数据请求。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。 

　　其实最早的L3缓存被应用在AMD发布的K6-III处理器上，当时的L3缓存受限于制造工艺，并没有被集成进芯片内部，而是集成在主板上。在只能够和系统总线频率同步的L3缓存同主内存其实差不了多少。后来使用L3缓存的是英特尔为服务器市场所推出的Itanium处理器。接着就是P4EE和至强MP。Intel还打算推出一款9MB
 L3缓存的Itanium2处理器，和以后24MB L3缓存的双核心Itanium2处理器。 

　　但基本上L3缓存对处理器的性能提高显得不是很重要，比方配备1MB L3缓存的Xeon MP处理器却仍然不是Opteron的对手，由此可见前端总线的增加，要比缓存增加带来更有效的性能提升。 
　　 老图夫原创，欢迎收藏，打击盗版！
　　7.CPU扩展指令集 
　　CPU依靠指令来计算和控制系统，每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分，而从具体运用看，如Intel的MMX（Multi Media Extended）、SSE、
 SSE2（Streaming-Single instruction multiple data-Extensions 2）、SEE3和AMD的3DNow!等都是CPU的扩展指令集，分别增强了CPU的多媒体、图形图象和Internet等的处理能力。我们通常会把CPU的扩展指令集称为"CPU的指令集"。SSE3指令集也是目前规模最小的指令集，此前MMX包含有57条命令，SSE包含有50条命令，SSE2包含有144条命令，SSE3包含有13条命令。目前SSE3也是最先进的指令集，英特尔Prescott处理器已经支持SSE3指令集，AMD会在未来双核心处理器当中加入对SSE3指令集的支持，全美达的处理器也将支持这一指令集。 

　　8.CPU内核和I/O工作电压 
　　从586CPU开始，CPU的工作电压分为内核电压和I/O电压两种，通常CPU的核心电压小于等于I/O电压。其中内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低；I/O电压一般都在1.6~5V。低电压能解决耗电过大和发热过高的问题。 

　　9.制造工艺 
　　制造工艺的微米是指IC内电路与电路之间的距离。制造工艺的趋势是向密集度愈高的方向发展。密度愈高的IC电路设计，意味着在同样大小面积的IC中，可以拥有密度更高、功能更复杂的电路设计。现在主要的180nm、130nm、90nm。最近官方已经表示有65nm的制造工艺了。 
10.指令集 

　　（1）CISC指令集 
　　CISC指令集，也称为复杂指令集，英文名是CISC，（Complex Instruction Set Computer的缩写）。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。其实它是英特尔生产的x86系列（也就是IA-32架构）CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的X86-64（也被成AMD64）都是属于CISC的范畴。 

　　要知道什么是指令集还要从当今的X86架构的CPU说起。X86指令集是Intel为其第一块16位CPU(i8086)专门开发的，IBM1981年推出的世界第一台PC机中的CPU—i8088(i8086简化版)使用的也是X86指令，同时电脑中为提高浮点数据处理能力而增加了X87芯片，以后就将X86指令集和X87指令集统称为X86指令集。 
　　虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到过去的PII至强、PIII至强、Pentium 3，最后到今天的Pentium 4系列、至强（不包括至强Nocona），但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集，所以它的CPU仍属于X86系列。由于Intel
 X86系列及其兼容CPU（如AMD Athlon MP、）都使用X86指令集，所以就形成了今天庞大的X86系列及兼容CPU阵容。x86CPU目前主要有intel的服务器CPU和AMD的服务器CPU两类。 

　　（2）RISC指令集 
　　RISC是英文“Reduced Instruction Set Computing ” 的缩写，中文意思是“精简指令集”。它是在CISC指令系统基础上发展起来的，有人对CISC机进行测试表明，各种指令的使用频度相当悬殊，最常使用的是一些比较简单的指令，它们仅占指令总数的20％，但在程序中出现的频度却占80％。复杂的指令系统必然增加微处理器的复杂性，使处理器的研制时间长，成本高。并且复杂指令需要复杂的操作，必然会降低计算机的速度。基于上述原因，20世纪80年代RISC型CPU诞生了，相对于CISC型CPU
 ,RISC型CPU不仅精简了指令系统，还采用了一种叫做“超标量和超流水线结构”，大大增加了并行处理能力。RISC指令集是高性能CPU的发展方向。它与传统的CISC(复杂指令集)相对。相比而言，RISC的指令格式统一，种类比较少，寻址方式也比复杂指令集少。当然处理速度就提高很多了。目前在中高档服务器中普遍采用这一指令系统的CPU，特别是高档服务器全都采用RISC指令系统的CPU。RISC指令系统更加适合高档服务器的操作系统UNIX，现在Linux也属于类似UNIX的操作系统。RISC型CPU与Intel和AMD的CPU在软件和硬件上都不兼容。 

　　目前，在中高档服务器中采用RISC指令的CPU主要有以下几类：PowerPC处理器、SPARC处理器、PA-RISC处理器、MIPS处理器、Alpha处理器。 

　　（3）IA-64 

　　EPIC（Explicitly Parallel Instruction Computers，精确并行指令计算机）是否是RISC和CISC体系的继承者的争论已经有很多，单以EPIC体系来说，它更像Intel的处理器迈向RISC体系的重要步骤。从理论上说，EPIC体系设计的CPU，在相同的主机配置下，处理Windows的应用软件比基于Unix下的应用软件要好得多。 

　　Intel采用EPIC技术的服务器CPU是安腾Itanium（开发代号即Merced）。它是64位处理器，也是IA－64系列中的第一款。微软也已开发了代号为Win64的操作系统，在软件上加以支持。在Intel采用了X86指令集之后，它又转而寻求更先进的64-bit微处理器，Intel这样做的原因是，它们想摆脱容量巨大的x86架构,从而引入精力充沛而又功能强大的指令集，于是采用EPIC指令集的IA-64架构便诞生了。IA-64
 在很多方面来说，都比x86有了长足的进步。突破了传统IA32架构的许多限制，在数据的处理能力，系统的稳定性、安全性、可用性、可观理性等方面获得了突破性的提高。 

　　IA-64微处理器最大的缺陷是它们缺乏与x86的兼容，而Intel为了IA-64处理器能够更好地运行两个朝代的软件，它在IA-64处理器上（Itanium、Itanium2 ……)引入了x86-to-IA-64的解码器，这样就能够把x86指令翻译为IA-64指令。这个解码器并不是最有效率的解码器，也不是运行x86代码的最好途径（最好的途径是直接在x86处理器上运行x86代码），因此Itanium
 和Itanium2在运行x86应用程序时候的性能非常糟糕。这也成为X86-64产生的根本原因。 

　　（4）X86-64 （AMD64 / EM64T） 

　　AMD公司设计，可以在同一时间内处理64位的整数运算，并兼容于X86-32架构。其中支持64位逻辑定址，同时提供转换为32位定址选项；但数据操作指令默认为32位和8位，提供转换成64位和16位的选项；支持常规用途寄存器，如果是32位运算操作，就要将结果扩展成完整的64位。这样，指令中有“直接执行”和“转换执行”的区别，其指令字段是8位或32位，可以避免字段过长。 

　　x86-64（也叫AMD64）的产生也并非空穴来风，x86处理器的32bit寻址空间限制在4GB内存，而IA-64的处理器又不能兼容x86。AMD充分考虑顾客的需求，加强x86指令集的功能，使这套指令集可同时支持64位的运算模式，因此AMD把它们的结构称之为x86-64。在技术上AMD在x86-64架构中为了进行64位运算，AMD为其引入了新增了R8-R15通用寄存器作为原有X86处理器寄存器的扩充，但在而在32位环境下并不完全使用到这些寄存器。原来的寄存器诸如EAX、EBX也由32位扩张至64位。在SSE单元中新加入了8个新寄存器以提供对SSE2的支持。寄存器数量的增加将带来性能的提升。与此同时，为了同时支持32和64位代码及寄存器，x86-64架构允许处理器工作在以下两种模式：Long
 Mode(长模式)和Legacy Mode(遗传模式)，Long模式又分为两种子模式(64bit模式和Compatibility mode兼容模式)。该标准已经被引进在AMD服务器处理器中的Opteron处理器。 

　　而今年也推出了支持64位的EM64T技术，再还没被正式命为EM64T之前是IA32E，这是英特尔64位扩展技术的名字,用来区别X86指令集。Intel的EM64T支持64位sub-mode，和AMD的X86-64技术类似，采用64位的线性平面寻址，加入8个新的通用寄存器（GPRs），还增加8个寄存器支持SSE指令。与AMD相类似，Intel的64位技术将兼容IA32和IA32E，只有在运行64位操作系统下的时候，才将会采用IA32E。IA32E将由2个sub-mode组成：64位sub-mode和32位sub-mode，同AMD64一样是向下兼容的。Intel的EM64T将完全兼容AMD的X86-64技术。现在Nocona处理器已经加入了一些64位技术，Intel的Pentium
 4E处理器也支持64位技术。 

　　应该说，这两者都是兼容x86指令集的64位微处理器架构，但EM64T与AMD64还是有一些不一样的地方，AMD64处理器中的NX位在Intel的处理器中将没有提供。
11.超流水线与超标量 
　　在解释超流水线与超标量前，先了解流水线(pipeline)。流水线是Intel首次在486芯片中开始使用的。流水线的工作方式就象工业生产上的装配流水线。在CPU中由5—6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5—6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。经典奔腾每条整数流水线都分为四级流水，即指令预取、译码、执行、写回结果，浮点流水又分为八级流水。 

　　超标量是通过内置多条流水线来同时执行多个处理器，其实质是以空间换取时间。而超流水线是通过细化流水、提高主频，使得在一个机器周期内完成一个甚至多个操作，其实质是以时间换取空间。例如Pentium 4的流水线就长达20级。将流水线设计的步(级)越长，其完成一条指令的速度越快，因此才能适应工作主频更高的CPU。但是流水线过长也带来了一定副作用，很可能会出现主频较高的CPU实际运算速度较低的现象，Intel的奔腾4就出现了这种情况，虽然它的主频可以高达1.4G以上，但其运算性能却远远比不上AMD
 1.2G的速龙甚至奔腾III。 
　　 老图夫原创，欢迎收藏，打击盗版！
　　12.封装形式 
　　CPU封装是采用特定的材料将CPU芯片或CPU模块固化在其中以防损坏的保护措施，一般必须在封装后CPU才能交付用户使用。CPU的封装方式取决于CPU安装形式和器件集成设计，从大的分类来看通常采用Socket插座进行安装的CPU使用PGA(栅格阵列)方式封装，而采用Slot x槽安装的CPU则全部采用SEC(单边接插盒)的形式封装。现在还有PLGA(Plastic
 Land Grid Array)、OLGA(Organic Land Grid Array)等封装技术。由于市场竞争日益激烈，目前CPU封装技术的发展方向以节约成本为主。 


　　13、多线程 

　　同时多线程Simultaneous multithreading，简称SMT。SMT可通过复制处理器上的结构状态，让同一个处理器上的多个线程同步执行并共享处理器的执行资源，可最大限度地实现宽发射、乱序的超标量处理，提高处理器运算部件的利用率，缓和由于数据相关或Cache未命中带来的访问内存延时。当没有多个线程可用时，SMT处理器几乎和传统的宽发射超标量处理器一样。SMT最具吸引力的是只需小规模改变处理器核心的设计，几乎不用增加额外的成本就可以显著地提升效能。多线程技术则可以为高速的运算核心准备更多的待处理数据，减少运算核心的闲置时间。这对于桌面低端系统来说无疑十分具有吸引力。Intel从3.06GHz
 Pentium 4开始，所有处理器都将支持SMT技术。 

　　14、多核心 

　　多核心，也指单芯片多处理器（Chip multiprocessors，简称CMP）。CMP是由美国斯坦福大学提出的，其思想是将大规模并行处理器中的SMP（对称多处理器）集成到同一芯片内，各个处理器并行执行不同的进程。与CMP比较， SMT处理器结构的灵活性比较突出。但是，当半导体工艺进入0.18微米以后，线延时已经超过了门延迟，要求微处理器的设计通过划分许多规模更小、局部性更好的基本单元结构来进行。相比之下，由于CMP结构已经被划分成多个处理器核来设计，每个核都比较简单，有利于优化设计，因此更有发展前途。目前，IBM
 的Power 4芯片和Sun的 MAJC5200芯片都采用了CMP结构。多核处理器可以在处理器内部共享缓存，提高缓存利用率，同时简化多处理器系统设计的复杂度。 

　　2005年下半年，Intel和AMD的新型处理器也将融入CMP结构。新安腾处理器开发代码为Montecito，采用双核心设计，拥有最少18MB片内缓存，采取90nm工艺制造，它的设计绝对称得上是对当今芯片业的挑战。它的每个单独的核心都拥有独立的L1，L2和L3 cache，包含大约10亿支晶体管。 
　　 老图夫原创，欢迎收藏，打击盗版！
　　15、SMP 

　　SMP（Symmetric Multi-Processing），对称多处理结构的简称，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。在这种技术的支持下，一个服务器系统可以同时运行多个处理器，并共享内存和其他的主机资源。像双至强，也就是我们所说的二路，这是在对称处理器系统中最常见的一种（至强MP可以支持到四路，AMD
 Opteron可以支持1-8路）。也有少数是16路的。但是一般来讲，SMP结构的机器可扩展性较差，很难做到100个以上多处理器，常规的一般是8个到16个，不过这对于多数的用户来说已经够用了。在高性能服务器和工作站级主板架构中最为常见，像UNIX服务器可支持最多256个CPU的系统。 

　　构建一套SMP系统的必要条件是：支持SMP的硬件包括主板和CPU；支持SMP的系统平台，再就是支持SMP的应用软件。 

　　为了能够使得SMP系统发挥高效的性能，操作系统必须支持SMP系统，如WINNT、LINUX、以及UNIX等等32位操作系统。即能够进行多任务和多线程处理。多任务是指操作系统能够在同一时间让不同的CPU完成不同的任务；多线程是指操作系统能够使得不同的CPU并行的完成同一个任务。 

　　要组建SMP系统，对所选的CPU有很高的要求，首先、CPU内部必须内置APIC（Advanced Programmable Interrupt Controllers）单元。Intel 多处理规范的核心就是高级可编程中断控制器（Advanced Programmable Interrupt Controllers--APICs）的使用；再次，相同的产品型号，同样类型的CPU核心，完全相同的运行频率；最后，尽可能保持相同的产品序列编号，因为两个生产批次的CPU作为双处理器运行的时候，有可能会发生一颗CPU负担过高，而另一颗负担很少的情况，无法发挥最大性能，更糟糕的是可能导致死机。 

　　16、NUMA技术 

　　NUMA即非一致访问分布共享存储技术，它是由若干通过高速专用网络连接起来的独立节点构成的系统，各个节点可以是单个的CPU或是SMP系统。在NUMA中，Cache 的一致性有多种解决方案，需要操作系统和特殊软件的支持。图2中是Sequent公司NUMA系统的例子。这里有3个SMP模块用高速专用网络联起来，组成一个节点，每个节点可以有12个CPU。像Sequent的系统最多可以达到64个CPU甚至256个CPU。显然，这是在SMP的基础上，再用NUMA的技术加以扩展，是这两种技术的结合。 
　老图夫原创，欢迎收藏，打击盗版！

　　17、乱序执行技术 

　　乱序执行（out-of-orderexecution），是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据个电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路单元执行，在这期间不按规定顺序执行指令，然后由重新排列单元将各执行单元结果按指令顺序重新排列。采用乱序执行技术的目的是为了使CPU内部电路满负荷运转并相应提高了CPU的运行程序的速度。分枝技术：（branch）指令进行运算时需要等待结果，一般无条件分枝只需要按指令顺序执行，而条件分枝必须根据处理后的结果，再决定是否按原先顺序进行。 

　　18、CPU内部的内存控制器 

　　许多应用程序拥有更为复杂的读取模式（几乎是随机地，特别是当cache hit不可预测的时候），并且没有有效地利用带宽。典型的这类应用程序就是业务处理软件，即使拥有如乱序执行（out of order execution）这样的CPU特性，也会受内存延迟的限制。这样CPU必须得等到运算所需数据被除数装载完成才能执行指令（无论这些数据来自CPU
 cache还是主内存系统）。当前低段系统的内存延迟大约是120－150ns，而CPU速度则达到了3GHz以上，一次单独的内存请求可能会浪费200－300次CPU循环。即使在缓存命中率（cache hit rate）达到99％的情况下，CPU也可能会花50％的时间来等待内存请求的结束－ 比如因为内存延迟的缘故。 

　　你可以看到Opteron整合的内存控制器，它的延迟，与芯片组支持双通道DDR内存控制器的延迟相比来说，是要低很多的。英特尔也按照计划的那样在处理器内部整合内存控制器，这样导致北桥芯片将变得不那么重要。但改变了处理器访问主存的方式，有助于提高带宽、降低内存延时和提升处理器性能。


