# 栈和队列的实现和操作总结 - fanyun的博客 - CSDN博客
2018年10月30日 07:19:55[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：323
### 1.实现一个栈，要求实现Push（出栈）、Pop（入栈）、Min（返回最小值的操作）的时间复杂度为O(1)
对于这个问题，我们都知道，栈的入栈和出栈时间复杂度都是O(1),那么我们所面临的问题就是需要有一个接口来实现返回最小值的操作，且这个操作的时间复杂度必须是O(1)。 
这里有两种思路可供选择： 
（1）前提：这里有一组数据，利用一个栈，将这些数据需要入栈，而在入栈的时候遵循这样的规律，将一个数据入栈时，接下来立刻把当前栈中的最小值也入栈，接着将下一个数据入栈，也遵从上面的规律。 
这种方法是一种以空间换时间的做法。
但是这种方法有一个小小的缺陷，那就是获取栈顶元素时比较尴尬，需要先将最小值出栈，然后获取栈顶元素，然后再将最小值入栈，这种方法比较麻烦。
![这里写图片描述](https://img-blog.csdn.net/20170712004439303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
代码如下：
```
#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
#include <assert.h>
using namespace std;
#include<vector>
#include<stack>
template<class T>
class Stack
{
public:
    void Push(const T& val)
    {
        if (s.empty())
        {
            s.push(val);
            s.push(val);
        }
        else
        {
            T min = s.top();
            if (val < min)
            {
                s.push(val);
                s.push(val);
            }
            else
            {
                s.push(val);
                s.push(min);
            }
        }
    }
    void Pop()
    {
        if (!s.empty())
        {
            s.pop();
            s.pop();
        }
    }
    T Min()
    {
        if (!s.empty())
        {
            return s.top();
        }
        assert(false);
        return 0;
    }
private:
    stack<T> s;
};
```
（2） 
利用两个栈来实现，一个栈用来保存数据，另一个栈用来保存当前数据栈中的最小值。 
缺陷：min栈中会有很多冗余值。
![这里写图片描述](https://img-blog.csdn.net/20170712010827526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
```
template<class T>
class Stack
{
public:
    void Push(const T& val)
    {
        _data.push(val);
        if (_min.empty() || val < _min.top())
        {
            _min.push(val);
        }
        else
        {
            _min.push(_min.top());
        }
    }
    void Pop()
    {
        if (!_data.empty() && !_min.empty())
        {
            _data.pop();
            _min.pop();
        }
    }
    T Min()
    {
        if (!_min.empty())
        {
            return _min.top();
        }
    }
private:
    stack<T> _data;
    stack<T> _min;
};
```
对于上面min栈的冗余值我们还可以进行优化，那就是min栈中记录的最小值如果在data栈中出现两次，那么就在min栈中记录两次该最小值，而如果入data栈中的值大于min栈顶元素时，这时不需要向min栈中push元素。
![这里写图片描述](https://img-blog.csdn.net/20170712012700990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
### 2.使用两个栈实现一个队列
这道题的思路如下： 
我们都知道：栈的特点是后进先出，队列的特点是先进先出。 
那么就需要将一个栈中的数据借助另一个栈不断的倒来倒去，来实现队列的先进先出。
也就是说：将入队和出队操作分开执行，这里的分开指的是在两个栈中分别执行，入队在stack_in栈中也就是所谓的入栈，要出队时，这时判断stack_out栈是否为空，如果为空，则将stack_in栈中的数据前size-1个数据入到stack_out栈中，直接将最后一个数据弹出，也就是所谓的出队，如果不为空时，直接将stack_out栈中的栈顶元素出栈即可。
![这里写图片描述](https://img-blog.csdn.net/20170712013913707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
```
template<class T>
class Queue
{
public:
    void Enqueue(T& x)
    {
        _in.push(x);
    }
    T  Dequeue()
    {
        if (!_out.empty())
        {
            T top = _out.top();
            _out.pop();
            return top;
        }
        else
        {
            size_t size = _in.size();
            while (--size)
            {
                _out.push(_in.top());
                _in.pop();
            }
            if (!_in.empty())
            {
                T top =  _in.top();
                _in.pop();
                return top;
            }
        }
    }
    bool Empty()
    {
        return _in.empty() && _out.empty();
    }
private:
    stack<T>  _in;
    stack<T>  _out;
};
```
### 3. 使用两个队列实现一个栈
思路如下： 
其实和上面第二道题的思路是一样的，入栈操作可以是将数据入到一个队列中，出栈时需要将队列中的前size-1个数据保存到另一个队列中，然后将最后一个数据出队也就是所谓的出栈操作。
![这里写图片描述](https://img-blog.csdn.net/20170712021131806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
```
template<class T>
class Stack
{
public:
    Stack()
    {}
    void Push(const T& val)
    {
        if (q1.empty() && q2.empty())
        {
            q1.push(val);
        }
        else if (q1.empty())
        {
            q2.push(val);
        }
        else
        {
            q1.push(val);
        }
    }
    void Pop()
    {
        if (!q1.empty() && q2.empty())
        {
            size_t size = q1.size();
            while (--size)
            {
                T front = q1.front();
                q2.push(front);
                q1.pop();
            }
            if (!q1.empty())
            {
                q1.pop();
            }
        }
        else//q1为空   q2不空
        {
            size_t size = q2.size();
            while (--size)
            {
                T front = q2.front();
                q1.push(front);
                q2.pop();
            }
            if (!q2.empty())
            {
                q2.pop();
            }
        }
    }
    T& Top()
    {
        if (!q1.empty())
        {
            return q1.back();
        }
        else
        {
            q2.back();
        }
    }
    bool Empty()
    {
        return q1.empty() && q2.empty();
    }
private:
    queue<T> q1;
    queue<T> q2;
};
```
### 4. 元素出栈、入栈顺序的合法性。如入栈的序列（1,2,3,4,5），出栈序列为（4,5,3,2,1）.
思路如下： 
由于栈的特点是后进先出，所以给定一定的序列，它的出栈序列也有一定得规律性，但是元素出栈的时间是随机的，导致出栈序列也不一定，但是还是有一定规律的。
首先：入栈序列的元素个数和出栈序列的元素个数必须相等，才能接着向下判断，否则，出栈顺序肯定不合法。
先入栈序列的元素入栈，然后判断栈是否为空，如果不为空，则取栈顶元素和出栈序列的元素做比较，如果相等，则将栈顶元素出栈，如果不等， 
则继续入栈。 
最终，当栈为空时，就可以判断出栈、入栈的顺序是合法的。
```
bool IsRighting(int* stack_in,int* stack_out,size_t size_in,size_t size_out)
{
    assert(stack_in && stack_out);
    if (size_in != size_out)
    {
        return false;
    }
    stack<int> s;
    size_t i = 0;//标记入栈序列
    size_t j = 0;//标记出栈序列
    for (; i < size_in; ++i)
    {
        s.push(stack_in[i]);
        while (!s.empty() && s.top() == stack_out[j])
        {
            s.pop();
            ++j;
        }
    }
    if (s.empty())
    {
        return true;
    }
    return false;
}
```
### 5. 一个数组实现两个栈
这里提供三种思路： 
前两种因为各种原因被pass掉，只有最后一种方法自己感觉还是挺优的。
![这里写图片描述](https://img-blog.csdn.net/20170713083720470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这种方法的缺陷是：如果一个奇数栈已经满了，而偶数栈只有几个数据或者没有数据时，是最浪费空间的一种做法。 
所以：pass掉该方法。
![这里写图片描述](https://img-blog.csdn.net/20170713084413918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这种方法和上面的方法类似，当左边的栈已满而右边的栈只要几个数据更甚至没有数据时同样很浪费空间，而且当栈已满时不好扩容，因为就是左边栈满而右边栈没有满时数组的容量还是有的，就算扩容后，只不过是更为浪费空间了而已。 
所以：pass掉该方法。
![这里写图片描述](https://img-blog.csdn.net/20170713084400025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ5OTI4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
这种方法是目前我能想到的最优的方法了，而且可以将数组空间的容量得到最大利用。最后当top1和top2相遇的时候，就说明需要扩容了，这时 
重新开辟空间，然后将原数组的值拷贝过来就好。
```
//一个数组实现两个栈
template<class T>
class Stack
{
public:
    Stack(size_t N)
        :_s1(new T[N])
        , _capacity(N)
    {
        _top1 = 0;
        _top2 = _capacity;
    }
    void Pushs1(const T& v)
    {
        _CheckCapacity();
        _s1[_top1] = v;
        ++_top1;
    }
    void Pushs2(const T& v)
    {
        _CheckCapacity();
        --_top2;
        _s1[_top2] = v;
    }
    void Pops1()
    {
        if (_top1 > 0)
        {
            --_top1;
        }
    }
    void Pops2()
    {
        if (_top2 < _capacity)
        {
            ++_top2;
        }
    }
    T& Tops1()
    {
        if (!Emptys1())
            return _s1[_top1 - 1];
    }
    T& Tops2()
    {
        if (!Emptys2());
        return _s1[_top2];
    }
    bool Emptys1()
    {
        return _top1 <= 0;
    }
    bool Emptys2()
    {
        return _top2 >= _capacity;
    }
    ~Stack()
    {
        if (_s1)
        {
            delete[] _s1;
            _s1 = NULL;
        }
    }
private:
    void _CheckCapacity()
    {
        if (_top1 >= _top2)
        {
            int newSize = 2 * _capacity + 3;
            Stack<T> s(newSize);
            while (!Emptys1())
            {
                T top = Tops1();
                Pops1();
                s.Pushs1(top);
            }
            while (!Emptys2())
            {
                T top = Tops2();
                Pops2();
                s.Pushs2(top);
            }
            swap(*this, s);
        }
    }
    T* _s1;
    size_t _top1;
    size_t _top2;
    size_t _capacity;
};
```
