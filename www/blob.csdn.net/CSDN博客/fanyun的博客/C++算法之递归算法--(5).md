# C++算法之递归算法--(5) - fanyun的博客 - CSDN博客
2018年04月16日 20:59:51[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：740
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
    递归算法在C++中是一个比较经典的算法类型，其主要特征就是循环调用，直到达到结束条件为止才结束。
    一般递归算法可以分为两部分：
    1.递归部分：递归调用的程序主体；
    2.递归出口：递归输出条件。
   常用的解决递归问题有：阶乘，汉诺塔，全排列等。
现在举例说明：
   例子1：全排列问题
   什么是全排列问题呢？大家买过体育彩票的应该玩过3D吧？对，给你3个随机数：1、2、3，对其进行排列组合:123、321、213。
```cpp
#include <iostream>   
using namespace std;  
int n = 0;  
  
void swap(char *q ,char *p)  
{   //交换函数 
    int temp;  
    temp= *q;  
    *q = *p;  
    *p = temp;  
}   
   
void perm(char arr[],int k, int m )  
{  
    int i;  
    if(k >m)  
    {  
        for(i = 0 ; i <= m ; i++)  
        {  //递归结束出口，当数列只剩下一个数的时候输出 
            cout<<arr[i]<<" ";  
               
        }  
        cout<<endl;   
    }  
    else  
    {  
        for(i = k ; i <=m;i++)  
        {  //递归部分 
            swap(arr[k],arr[i]);  
            perm(arr,k+1,m);  
            /*把数组看成1｛234｝+2｛134｝+3｛124｝+4｛123｝
			再把｛234｝看成2｛34｝+3｛24｝+4｛23｝
			一直把整体化为部分，一直把大问题分解成小问题。*/ 
            swap(arr[k],arr[i]);  
        }  
    }  
}  
  
int main()  
{  
    char arr[] ="1234";  
    perm(arr,0,3);     
    return 0;  
}
```
例子2：汉诺塔
      有n个盘子， 从小到大 依此从上往下叠放，在1号位。  1号位，2号位，3号位从左到右相邻。现需要将n个盘子，从1号位通过2号位移到3号位，或者从3号位置通过2号移到1号。  移动的过程中，不允许，大盘叠在小盘上。
代码如下：
```cpp
#include<iostream>  
using namespace std;  
void hanoi(int n,char a,char b,char c)  
{  
if(n==1)  
cout<<n<<" "<<a<<" "<<c<<endl;  
else  
{  
hanoi(n-1,a,c,b);  
cout<<n<<" "<<a<<" "<<c<<endl;  
hanoi(n-1,b,a,c);  
}  
}  
int main()  
{  
int n;  
cout<<"输入正整数:"<<endl;  
cin>>n;  
cout<<"结果为"<<endl;  
hanoi(n,'A','B','C');  
/* 
假设有4层，跟全排列差不多的想法，先把他看成3层，再看成2层，而且移动的方法是相同的。*/   
return 0;  
}
```
  例子3：阶乘问题
 n!=n*(n-1)!=n*n-1*(n-2)!=.....
```cpp
long factoria(int n)
{
return n <= 0 ? 1 : factoria(n - 1)*n;
}
```
