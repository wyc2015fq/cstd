# 正向（或者前向）插件系统设计 - fanyun的博客 - CSDN博客
2017年06月30日 20:02:05[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：364
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
       正向插件系统指的是在设计之初就已经定义好了一族用于特定功能的接口，然后通过共享库的形式隔离不同的实现策略，这样做不仅可以做到运行时按需选择实现策略，而且非常有利于功能的模块化测试。这种模式的插件系统是非常常见的，比如Adobe
 PS 对于不同文件格式、不同滤镜等的支持就是采用的就是正向插件系统设计。
      现在我们来看一下这样的计算器程序怎么使用正向插件系统的思想进行实现。首先，我们在源代码中实现一个简单的加法运算：从控制台输入两个数字，然后输出这两个数字的和。
主项目main.c的代码如下：
#include<stdio.h>#include<stdlib.h>#include<dlfcn.h>#include<assert.h>typedefint(*calc_t)(int a,int b);int main(){void*module= dlopen("./libadd.dylib", RTLD_NOW);assert(module!= NULL);calc_t calc =(calc_t) dlsym(module,"calc");assert(calc != NULL);do{int i_first;		printf("input the first number:");		scanf("%d",&i_first);int i_second;		printf("input the second number:");		scanf("%d",&i_second);int i_result =(*calc)(i_first, i_second);		printf("the result is %d\n\n", i_result);}while(true);	dlclose(module);return0;}
libadd项目的add.cpp文件内容如下：
extern"C"int calc(int a,int b){return a + b;}
我们看到程序能够正确的运行，但是现在我们只实现了一个+的插件，我们继续实现-、*、/的插件，其内容分别为：
libminus项目的minus.cpp文件内容如下：
extern"C"int calc(int a,int b){return a - b;}
libmultiply项目的multiply.cpp文件内容如下：
extern"C"int calc(int a,int b){return a * b;}
libdivide项目的divide.cpp文件内容如下：
extern"C"int calc(int a,int b){return a / b;}
修改主项目的main.cpp文件中加载的动态库，可单独测试每一个插件是否正确运行。测试结果是通过。
接下来，我们必须在主项目中管理这些组件，然后根据用户输入的信息动态的选择应该使用的插件。一个简单的版本如下：
#include<stdio.h>#include<stdlib.h>#include<dlfcn.h>#include<assert.h>typedefint(*calc_t)(int a,int b);struct dl_mod {void*module;calc_t calc;} mod[4];int main(int argc,char* argv[]){for(int i =0; i <4; i++){void*module= dlopen(argv[i +1], RTLD_NOW);assert(module!= NULL);calc_t calc =(calc_t) dlsym(module,"calc");assert(calc != NULL);		mod[i].module=module;		mod[i].calc = calc;}do{int i_calc;		printf("select the calculate number:");		scanf("%d",&i_calc);int i_first;		printf("input the first number:");		scanf("%d",&i_first);int i_second;		printf("input the second number:");		scanf("%d",&i_second);int i_result =(*(mod[i_calc].calc))(i_first, i_second);		printf("the result is %d\n\n", i_result);}while(true);for(int i =0; i <4; i++){		dlclose(mod[i].module);}return0;}
当然这个版本有一个比较要命的问题，你必须知道在命令行中输入的组件的顺序，然后才能准确调用那个组件。为了解决这个问题，我们可以给插件增加一些元数据。修改后的版本如下：
libadd项目增加如下代码：
extern"C"char* description(){return"add";}
libminus项目增加如下代码：
extern"C"char* description(){return"minus";}
libmultiply项目增加如下代码：
extern"C"char* description(){return"multiply";}
libdivide项目增加如下代码：
extern"C"char* description(){return"divide";}
主项目的代码如下：
#include<stdio.h>#include<stdlib.h>#include<dlfcn.h>#include<assert.h>typedefchar*(*description_t)();typedefint(*calc_t)(int a,int b);struct dl_mod {void*module;char* desc;calc_t calc;} mod[4];int main(int argc,char* argv[]){for(int i =0; i <4; i++){void*module= dlopen(argv[i +1], RTLD_NOW);assert(module!= NULL);description_t desc =(description_t) dlsym(module,"description");assert(desc != NULL);calc_t calc =(calc_t) dlsym(module,"calc");assert(calc != NULL);		mod[i].module=module;		mod[i].desc =(*desc)();		mod[i].calc = calc;}do{for(int i =0; i <4; i++){			printf("%d:%s\n", i, mod[i].desc);}int i_calc;		printf("select the calculate number:");		scanf("%d",&i_calc);int i_first;		printf("input the first number:");		scanf("%d",&i_first);int i_second;		printf("input the second number:");		scanf("%d",&i_second);int i_result =(*(mod[i_calc].calc))(i_first, i_second);		printf("the result is %d\n\n", i_result);}while(true);for(int i =0; i <4; i++){		dlclose(mod[i].module);}return0;}
运行结果如下：
./calc libadd.dylib libminus.dylib libmultiply.dylib libdivide.dylib0:add1:minus2:multiply3:divideselect the calculate number:0input the first number:3input the second number:4the result is70:add1:minus2:multiply3:divideselect the calculate number:
好了，前向插件系统的设计基本已经都展示完了。当前这是一个简单的实例，简单的接口，简单的管理。
