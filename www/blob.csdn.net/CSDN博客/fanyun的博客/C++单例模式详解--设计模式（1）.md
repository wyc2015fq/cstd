# C++单例模式详解--设计模式（1） - fanyun的博客 - CSDN博客
2016年06月07日 16:53:18[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：753
**Singleton模式来源：         **
       单例模式是设计模式中最简单的形式之一。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，"阻止"所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法(类方法)，因为让类的实例去生成另一个唯一实例毫无意义。
**Singleton模式的实现思路：**
       一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名 称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们 还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。
**Singleton模式需要注意的地方：**
    单例模式在多线程的 应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例， 这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。
**Singleton模式作用：**
       对于系统中的某些类来说，只有一个[实例](http://baike.so.com/doc/6664635-6878463.html)很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务;一个系统只能有一个窗口管理器或文件系统;一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源;如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。
      显然单例模式的要点有三个;一是某个类只能有一个实例;二是它必须自行创建这个实例;三是它必须自行向整个系统提供这个实例。
 从具体实现角度来说，就是以下三点:一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。
      单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例
**Singleton模式示例代码如下：**
**[cpp]**[view plain](http://blog.csdn.net/fanyun_01/article/details/51564872#)[copy](http://blog.csdn.net/fanyun_01/article/details/51564872#)
[print](http://blog.csdn.net/fanyun_01/article/details/51564872#)[?](http://blog.csdn.net/fanyun_01/article/details/51564872#)
- class CSingleton  
- 
- {  
- private:  
- CSingleton() //构造函数是私有的
- {  
- 
- }  
- public:  
- static CSingleton * GetInstance()  
- {  
- static CSingleton *m_pInstance;  
- if(m_pInstance == NULL) //判断是否第一次调用
- m_pInstance = new CSingleton();  
- return m_pInstance;  
- }  
         用户访问唯一实例的方法只有GetInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。
         一般Singleton模式通常有三种形式:
第一种形式:懒汉式，也是常用的形式，什么时候用，再创建，不会出现空耗内存的情况。
/*Eg1*/
**[cpp]**[view plain](http://blog.csdn.net/fanyun_01/article/details/51564872#)[copy](http://blog.csdn.net/fanyun_01/article/details/51564872#)
[print](http://blog.csdn.net/fanyun_01/article/details/51564872#)[?](http://blog.csdn.net/fanyun_01/article/details/51564872#)
- class Test {  
- private Test() {  
-         }  
- publicstatic Test instance = null;  
- publicstatic Test getInstance() {  
- if (instance == null) {  
- //多个线程判断instance都为null时，在执行new操作时多线程会出现重复情况
-                         instance = new Singleton2();  
-                 }  
- return instance;  
-         }  
- }  
/*Eg2*/
**[cpp]**[view plain](http://blog.csdn.net/fanyun_01/article/details/51564872#)[copy](http://blog.csdn.net/fanyun_01/article/details/51564872#)
[print](http://blog.csdn.net/fanyun_01/article/details/51564872#)[?](http://blog.csdn.net/fanyun_01/article/details/51564872#)
- #include <iostream>
- using namestd std;  
- class Singleton{  
- public:  
- static  Singleton& getInstance(void){  
- if(! s_instance)  
-             s_instance = new Singleton;  
- return *s_instance;//不用Singleton,就不创建。
- }  
- private:  
-     Singleton (void){}  
-     Singleton(const Singleton&);  
-     Singleton& operator=(const Singleton&);  
- static Singleton* s_instance;  
- };  
- Singleton* Singleton::s_instance=NULL;  
- int main (void){  
-      Singleton& s1 = Singleton::getInstance ();  
-      Singleton& s2 = Singleton::getInstance ();  
-      cout << &s1 << ' '<< &s2 << ' '<< endl;  
- return  0;  
- }  
优点：
    避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。
缺点：
    懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。
第二种形式:饿汉式,进程一起来，s_instance就存在了，先于main函数构造。
/*Eg1*/
**[cpp]**[view plain](http://blog.csdn.net/fanyun_01/article/details/51564872#)[copy](http://blog.csdn.net/fanyun_01/article/details/51564872#)
[print](http://blog.csdn.net/fanyun_01/article/details/51564872#)[?](http://blog.csdn.net/fanyun_01/article/details/51564872#)
- publicclass Test {  
- private Test() {  
-         }  
- publicstatic Test instance = new Test();  
- public Test getInstance() {  
- return instance;  
-         }  
- }  
/*Eg2*/
**[cpp]**[view plain](http://blog.csdn.net/fanyun_01/article/details/51564872#)[copy](http://blog.csdn.net/fanyun_01/article/details/51564872#)
[print](http://blog.csdn.net/fanyun_01/article/details/51564872#)[?](http://blog.csdn.net/fanyun_01/article/details/51564872#)
- #include <iostream>
- using namestd std;  
- class Singleton{  
- public:  
- static  Singleton& getInstance(void){  
- return s_instance;  
- }  
- private:  
-     Singleton (void){}  
-     Singleton(const Singleton&);  
-     Singleton& operator=(const Singleton&);  
- static Singleton s_instance;  
- };  
- Singleton Singleton::s_instance;  
- int main (void){  
-      Singleton& s1 = Singleton::getInstance ();  
-      Singleton& s2 = Singleton::getInstance ();  
-      cout << &s1 << ' '<< &s2 << ' '<< endl;  
- return  0;  
- }  
优点：
    1.线程安全
    2.在类加载的同时已经创建好一个静态对象，调用时反应速度快
缺点：
    资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化
Singleton模式适用场景：
        单例模式常常与工厂模式结合使用，因为工厂只需要创建产品实例就可以了，在多线程的环境下也不会造成任何的冲突，因此只需要一个工厂实例就可以了。
Singleton模式优缺点总结：
Singleton模式优点：
1.由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。减少了时间和空间的开销（new实例的开销）。
2.提高了封装性，使得外部不易改动实例。
3.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例。
4.避免对共享资源的多重占用。
 Singleton模式缺点：
1.懒汉式是以时间换空间的方式。
2.饿汉式是以空间换时间的方式。
3.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
4.单例类的职责过重，在一定程度上违背了“单一职责原则”。
5.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
Singleton模式的使用总结：
         从上可见，单例模式是最简单的一种设计模式，在实际应用中，有一些对象其实只需要一个，比如：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序对象。这些对象只能够拥有一个实例，如果创建出了多个实例，就会导致一些程序的问题。程序的行为异常，资源使用的过量，或者导致不一致的结果。常用来管理共享的资源，比如数据库的连接或者线程池。
**Singleton模式的适用场景：**
    单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如：
    1.需要频繁实例化然后销毁的对象。
    2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
    3.有状态的工具类对象。
    4.频繁访问数据库或文件的对象。
以下都是单例模式的经典使用场景：
    1.资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。
    2.控制资源的情况下，方便资源之间的互相通信。如线程池等。
应用场景举例：
    1.外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件
    2. Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~
    3. windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
    4. 网站的计数器，一般也是采用单例模式实现，否则难以同步。
    5. 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
    6. Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。
    7. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。
    8. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
    9. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
    10. HttpApplication 也是单位例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例.
