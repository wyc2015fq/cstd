# C++11标准库新加功能详解 - fanyun的博客 - CSDN博客
2016年07月24日 15:57:30[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：3223
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**一、Lambda表达式的引进**
        Lambda表达式的形式是这样的：
[capture](parameters)->return-type{body}
来看个计数某个字符序列中有几个大写字母的例子：
1.intmain()
2.{
3.chars[]="HelloWorld!";
4.intUppercase=0;//modifiedbythelambda
5.for_each(s,s+sizeof(s),[&Uppercase](charc){
6.if(isupper(c))
7.Uppercase++;
8.});
9.cout<<Uppercase<<"uppercaselettersin:"<<s<<endl;
10.}
其中[&Uppercase]中的
 &的意义是 lambda函数体要获取一个 Uppercase引用，以便能够改变它的值，如果没有
 &，那就 Uppercase将以传值的形式传递过去。
**二、自动类型推导和decltype**
在 C++03中，声明对象的同时必须指明其类型，其实大多数情况下，声明对象的同时也会包括一个初始值，C++11在这种情况下就能够让你声明对象时不再指定类型了：
1.autox=0;//0是int类型，所以x也是int类型
2.autoc='a';//char
3.autod=0.5;//double
4.autonational_debt=14400000000000LL;//longlong
这个特性在对象的类型很大很长的时候很有用，如：
1.voidfunc(constvector<int>&vi)
2.{
3.vector<int>::const_iteratorci=vi.begin();
4.}
那个迭代器可以声明为：
1.autoci=vi.begin();
C++11也提供了从对象或表达式中“俘获”类型的机制，新的操作符decltype可以从一个表达式中“俘获”其结果的类型并“返回”：
1.constvector<int>vi;
2.typedefdecltype(vi.begin())CIT;
3.CITanother_const_iterator;
**三、统一的初始化语法**
C++最少有 4种不同的初始化形式，如括号内初始化，见：
1.std::strings("hello");
2.intm=int();//defaultinitialization
还有等号形式的：
1.std::strings="hello";
2.intx=5;
对于 POD集合，又可以用大括号：
1.intarr[4]={0,1,2,3};
2.structtmtoday={0};
最后还有构造函数的成员初始化：
1.structS{
2.intx;
3.S():x(0){}};
这么多初始化形式，不仅菜鸟会搞得很头大，高手也吃不消。更惨的是 C++03中居然不能初始化POD数组的类成员，也不能在使用
 new[]的时候初始 POD数组！C++11就用大括号一统天下了：
1.classC
2.{
3.inta;
4.intb;
5.public:
6.C(inti,intj);
7.};
8.Cc{0,0};//C++11only.相当于Cc(0,0);
9.int*a=newint[3]{1,2,0};/C++11only
10.classX{
11.inta[4];
12.public:
13.X():a{1,2,3,4}{}//C++11,初始化数组成员
14.};
还有一大好事就是对于容器来说，终于可以摆脱push_back()调用了，C++11中可以直观地初始化容器了：
1.//C++11containerinitializer
2.vectorvs<string>={"first","second","third"};
3.mapsingers=
4.{{"LadyGaga","+1(212)555-7890"},
5.{"BeyonceKnowles","+1(212)555-0987"}};
而类中的数据成员初始化也得到了支持：
1.classC
2.{
3.inta=7;//C++11only
4.public:
5.C();
6.};
**四．deleted函数和 defaulted函数**
像以下形式的函数：
1.structA
2.{
3.A()=default;//C++11
4.virtual~A()=default;//C++11
5.};
叫做 defaulted函数，=default;指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。
与 defaulted函数相对的就是
 deleted函数：
1.intfunc()=delete;
这货有一大用途就是实现 noncopyabe防止对象拷贝，要想禁止拷贝，用
 =deleted声明一下两个关键的成员函数就可以了：
structNoCopy
{
NoCopy&operator=(constNoCopy&)=delete;
NoCopy(constNoCopy&)=delete;
};
NoCopya;
NoCopyb(a);//编译错误，拷贝构造函数是deleted函数
nullptr
nullptr是一个新的
 C++关键字，它是空指针常量，它是用来替代高风险的 NULL宏和
 0字面量的。nullptr是强类型的：
voidf(int);//#1
voidf(char*);//#2
//C++03
f(0);//调用的是哪个f?
//C++11
f(nullptr)//毫无疑问，调用的是#2
所有跟指针有关的地方都可以用nullptr，包括函数指针和成员指针：
constchar*pc=str.c_str();//datapointers
if(pc!=nullptr)
cout<<pc<<endl;
int(A::*pmf)()=nullptr;//指向成员函数的指针
void(*pmf)()=nullptr;//指向函数的指针
委托构造函数
C++11中构造函数可以调用同一个类的另一个构造函数：
classM//C++11delegatingconstructors
{
intx,y;
char*p;
public:
M(intv):x(v),y(0),p(newchar[MAX]){}//#1target
M():M(0){cout<<"delegatingctor"<<end;}//#2delegating
#2就是所谓的委托构造函数，调用了真正的构造函数 #1。
右值引用
在 C++03中的引用类型是只绑定左值的，C++11引用一个新的引用类型叫右值引用类型，它是绑定到右值的，如临时对象或字面量。
增加右值引用的主要原因是为了实现 move语义。与传统的拷贝不同，move的意思是目标对象“窃取”原对象的资源，并将源置于“空”状态。当拷贝一个对象时，其实代价昂贵且无必要，move操作就可以替代它。如在
 string交换的时候，使用 move意义就有巨大的性能提升，如原方案是这样的：
voidnaiveswap(string&a,string&b)
{
stringtemp=a;
a=b;
b=temp;
}
这种方案很傻很天真，很慢，因为需要申请内存，然后拷贝字符，而
 move就只需要交换两个数据成员，无须申请、释放内存和拷贝字符数组：
voidmoveswapstr(string&empty,string&filled)
{
//pseudocode,butyougettheidea
size_tsz=empty.size();
constchar*p=empty.data();
//movefilled'sresourcestoempty
empty.setsize(filled.size());
empty.setdata(filled.data());
//filledbecomesempty
filled.setsize(sz);
filled.setdata(p);
}
要实现支持 move的类，需要声明
 move构造函数和 move赋值操作符，如下：
classMovable
{
Movable(Movable&&);//moveconstructor
Movable&&operator=(Movable&&);//moveassignmentoperator
};
C++11的标准库广泛使用
 move语义，很多算法和容器都已经使用 move语义优化过了。
C++11的标准库
除TR1包含的新容器（unordered_set,unordered_map,
 unordered_multiset,和unordered_multimap），还有一些新的库，如正则表达式，tuple，函数对象封装器等。下面介绍一些
 C++11 的标准库新特性：
线程库
从程序员的角度来看，C++11最重要的特性就是并发了。C++11提供了
 thread类，也提供了 promise和 future用以并发环境中的同步，用
 async()函数模板执行并发任务，和 thread_local存储声明为特定线程独占的数据，这里（http://www.devx.com/SpecialReports/Article/38883）有一个简单的
 C++11线程库教程（英文）。
新的智能指针类
          C++98定义的唯一的智能指针类auto_ptr已经被弃用，C++11引入了新的智能针对类shared_ptr和unique_ptr。它们都是标准库的其它组件兼容，可以安全地把智能指针存入标准容器，也可以安全地用标准算法“倒腾”它们。
新的算法
主要是 all_of()、any_of()和
 none_of()，下面是例子：
#include<algorithm>
//C++11code
//arealloftheelementspositive?
all_of(first,first+n,ispositive());//false
//isthereatleastonepositiveelement?
any_of(first,first+n,ispositive());//true
//arenoneoftheelementspositive?
none_of(first,first+n,ispositive());//false
还有一个新的 copy_n：
#include<algorithm>
intsource[5]={0,12,34,50,80};
inttarget[5];
//从source拷贝5个元素到target
copy_n(source,5,target);
iota()算法可以用来创建递增序列，它先把初值赋值给 *first，然后用前置
 ++ 操作符增长初值并赋值到给下一个迭代器指向的元素，如下：
#include<numeric>
inta[5]={0};
charc[3]={0};
iota(a,a+5,10);//changesato{10,11,12,13,14}
iota(c,c+3,'a');//{'a','b','c'}
到现在为至，C++11仍然缺少一些很有用的库如XML
 API，socket，GUI、反射——以及自动垃圾收集。然而现有特性已经让
 C++ 更安全、高效（是的，效率更高了，可以参见 Google的基准测试结果：
[http://www.itproportal.com/2011/06/07/googles-rates-c-most-complex-highest-performing-language/](http://www.itproportal.com/2011/06/07/googles-rates-c-most-complex-highest-performing-language/)
以及更加易于学习和使用。

﻿﻿
