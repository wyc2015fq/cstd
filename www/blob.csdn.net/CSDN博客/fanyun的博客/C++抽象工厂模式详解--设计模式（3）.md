# C++抽象工厂模式详解--设计模式（3） - fanyun的博客 - CSDN博客
2016年06月18日 16:39:27[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：1915标签：[设计模式](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)
个人分类：[C++																[架构设计](https://blog.csdn.net/fanyun_01/article/category/6145183)](https://blog.csdn.net/fanyun_01/article/category/6102444)
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**Abstract Factory模式来源：**
        抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。
**Abstract Factory模式作用：**
通过引进抽象工厂模式，可以处理具有相同（或者相似）等级结构的多个产品族中的产品对象的创建问题。
由于每个具体工厂角色都需要负责两个不同等级结构的产品对象的创建，因此每个工厂角色都需要提供两个工厂方法，分别用于创建两个等级结构的产品。既然每个具体工厂角色都需要实现这两个工厂方法，所以具有一般性，不妨抽象出来，移动到抽象工厂角色中加以声明。为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
**Abstract Factory模式UML结构图****：**
        以股票行情沪深板块行情数据访问为例，行情源访问程序设计，不同的行情访问方式可能不一样，为了抽象对对不同行情的访问，可以将行情源隐藏起来，提供统一的访问方式，用多态进行实现。
![](https://img-blog.csdn.net/20160617134042560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
**Abstract Factory模式构成：**
     工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。
     抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。
     具体产品角色：工厂类所创建的对象就是此角色的实例。由一个具体类实现。
**Abstract Factory模式代码示例：**
```cpp
<span style="font-size:14px;">#include <iostream>
#include <string>
using namespace std;
class Icode
{
public:
	virtual void Getcode()=0;
	virtual void Setcode()=0;
};
class ShenAcode:public Icode
{
public:
	void Getcode()
	{
		cout<<"在ShenA中返回code"<<endl;
	}
	void Setcode()
	{
		cout<<"在ShenA中设置code"<<endl;
	}
};
class ShangAcode:public Icode
{
public:
	void Getcode()
	{
		cout<<"在ShangA中返回code"<<endl;
	}
	void Setcode()
	{
		cout<<"在ShangA中设置code"<<endl;
	}
};
class Iindex
{
public:
	virtual void Getindex()=0;
	virtual void Setindex()=0;
};
class ShenAindex:public Iindex
{
public:
	void Getindex()
	{
		cout<<"在ShenA中返回index"<<endl;
	}
	void Setindex()
	{
		cout<<"在ShenA中设置index"<<endl;
	}
};
class ShangAindex:public Iindex
{
public:
	void Getindex()
	{
		cout<<"在ShangA中返回index"<<endl;
	}
	void Setindex()
	{
		cout<<"在ShangA中设置index"<<endl;
	}
};
class IFactory
{
public:
	virtual Icode *CreateCode()=0;
	virtual Iindex *CreateIndex()=0;
};
class ShenAFactory:public IFactory
{
public:
	Icode *CreateCode() 
	{
		return new ShenAcode();
	}
	Iindex *CreateIndex() 
	{
		return new ShenAindex();
	}
};
class ShangAFactory:public IFactory
{
public:
	Icode *CreateCode()
	{
		return new ShangAcode();
	}
	Iindex *CreateIndex() 
	{
		return new ShangAindex();
	}
};
/*************************************************************/
class DataShangA
{
private:
	static string stock;
	//string stock="ShangA";
public:
	static Icode *CreateCode()
	{
		if(stock=="ShangA")
		{
			return new ShangAcode();
		}
		else if(stock=="ShenA")
		{
			return new ShenAcode();
		}
	}
	static Iindex *CreateIndex()
	{
		if(stock=="ShangA")
		{
			return new ShangAindex();
		}
		else if(stock=="ShenA")
		{
			return new ShenAindex();
		}	
	}
};
string DataShangA::stock="ShenA";
/*************************************************************/
int main()
{
	//IFactory *factory=new ShenAFactory();
	IFactory *factory;
	Icode *code;
	Iindex *index;
	factory=new ShangAFactory();
	code=factory->CreateCode();
	index=factory->CreateIndex();
	
	code->Getcode();
	code->Setcode();
	index->Getindex();
	index->Setindex();
	code=DataShangA::CreateCode();
	index=DataShangA::CreateIndex();
	code->Getcode();
	code->Setcode();
	index->Getindex();
	index->Setindex();
		return 0;
}</span>
```
**Abstract Factory模式优缺点总结：**
优点：
1.它分离了具体的类
2.它使得易于交换产品系列
3.它有利于产品的一致性
缺点：
1.难以支持新种类的产品
