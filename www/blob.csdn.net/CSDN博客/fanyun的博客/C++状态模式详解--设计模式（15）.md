# C++状态模式详解--设计模式（15） - fanyun的博客 - CSDN博客
2016年07月01日 08:51:21[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：2405
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**State模式来源： **
  每个人、事物在不同的状态下会有不同表现（动作），而一个状态又会在不同的表现下转移到下一个不同的状态（State）。最简单的一个生活中的例子就是：地铁入口处，如果你放入正确的地铁票，门就会打开让你通过。在出口处也是验票，如果正确你就可以ok，否则就不让你通过（如果你动作野蛮，或许会有报警（Alarm））。
      有限状态自动机（FSM）也是一个典型的状态不同，对输入有不同的响应（状态转移）。通常我们在实现这类系统会使用到很多的Switch/Case语句，Case某种状态，发生什么动作，Case另外一种状态，则发生另外一种状态。但是这种实现方式至少有以下两个问题：
      (1).当状态数目不是很多的时候，Switch/Case可能可以搞定。但是当状态数目很多的时候（实际系统中也正是如此），维护一大组的Switch/Case语句将是一件异常困难并且容易出错的事情。
      (2).状态逻辑和动作实现没有分离。在很多的系统实现中，动作的实现代码直接写在状态的逻辑当中。这带来的后果就是系统的扩展性和维护得不到保证。
**State模式作用：**
 State模式就是被用来解决上面列出的两个问题的，在State模式中我们将状态逻辑和动作实现进行分离。当一个操作中要维护大量的case分支语句，并且这些分支依赖于对象的状态。State模式将每一个分支都封装到独立的类中。
**State模式UML结构图如图1所示：**
**![](https://img-blog.csdn.net/20160630165148103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**State模式的构成：**
State类：抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。
ConcreteState类：具体状态，每一个子类实现一个与Context的一个状态相关的行为。
Context类：维护一个ConcreteState子类的实例，这个实例定义当前的状态。
State模式的代码示例：
State.h
```cpp
#ifndef _STATE_H_
#define _STATE_H_
class Context;
class State
{
public:
    virtual void Handle(Context* pContext)=0;
    ~State();
protected:
    State();
private:
};
class ConcreteStateA : public State
{
public:
    ConcreteStateA();
    ~ConcreteStateA();
    virtual void Handle(Context* pContext);
protected:
private:
};
class ConcreteStateB : public State
{
public:
    ConcreteStateB();
    ~ConcreteStateB();
    virtual void Handle(Context* pContext);
protected:
private:
};
class ConcreteStateC : public State
{
public:
    ConcreteStateC();
    ~ConcreteStateC();
    virtual void Handle(Context* pContext);
protected:
private:
};
class Context
{
public:
    Context(State* pState);
    ~Context();
    void Request();
    void ChangeState(State* pState);
protected:
private:
    State* _state;
};
#endif
```
**State.cpp**
```cpp
#include "State.h"
#include <iostream>
using namespace std;
State::State()
{}
State::~State()
{}
ConcreteStateA::ConcreteStateA()
{}
ConcreteStateA::~ConcreteStateA()
{}
//执行该状态的行为并改变状态
void ConcreteStateA::Handle(Context* pContext)
{
    cout << "ConcreteStateA" << endl;
    pContext->ChangeState(new ConcreteStateB());
}
ConcreteStateB::ConcreteStateB()
{}
ConcreteStateB::~ConcreteStateB()
{}
//执行该状态的行为并改变状态
void ConcreteStateB::Handle(Context* pContext)
{
    cout << "ConcreteStateB" << endl;
    pContext->ChangeState(new ConcreteStateC());
}
ConcreteStateC::ConcreteStateC()
{}
ConcreteStateC::~ConcreteStateC()
{}
//执行该状态的行为并改变状态
void ConcreteStateC::Handle(Context* pContext)
{
    cout << "ConcreteStateC" << endl;
    pContext->ChangeState(new ConcreteStateA());
}
//定义_state的初始状态
Context::Context(State* pState)
{
    this->_state = pState;
}
Context::~Context()
{}
//对请求做处理，并设置下一状态
void Context::Request()
{
    if(NULL != this->_state)
    {
        this->_state->Handle(this);
    }
}
//改变状态
void Context::ChangeState(State* pState)
{
    this->_state = pState;
}
```
**Main.cpp**
```cpp
#include "State.h"
int main()
{
    State* pState = new ConcreteStateA();
    Context* pContext = new Context(pState);
    pContext->Request();
    pContext->Request();
    pContext->Request();
    pContext->Request();
    pContext->Request();
    return 0;
}
```
State模式使用场景：
State模式的应用也非常广泛，从最高层逻辑用户接口GUI到最底层的通讯协议（例如利用State模式模拟实现一个TCP连接的类。）都有其用武之地。
        State模式和Strategy模式又很大程度上的相似：它们都有一个Context类，都是通过委托（组合）给一个具有多个派生类的多态基类实现Context的算法逻辑。两者最大的差别就是State模式中派生类持有指向Context对象的引用，并通过这个引用调用Context中的方法，但在Strategy模式中就没有这种情况。因此可以说一个State实例同样是Strategy模式的一个实例，反之却不成立。实际上State模式和Strategy模式的区别还在于它们所关注的点不尽相同：State模式主要是要适应对象对于状态改变时的不同处理策略的实现，而Strategy则主要是具体算法和实现接口的解耦（coupling），Strategy模式中并没有状态的概念（虽然很多时候有可以被看作是状态的概念），并且更加不关心状态的改变了。
       State模式很好地实现了对象的状态逻辑和动作实现的分离，状态逻辑分布在State的派生类中实现，而动作实现则可以放在Context类中实现（这也是为什么State派生类需要拥有一个指向Context的指针）。这使得两者的变化相互独立，改变State的状态逻辑可以很容易复用Context的动作，也可以在不影响State派生类的前提下创建Context的子类来更改或替换动作实现。
State模式经典示例：
       允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
1->main()，客户
2->CLiftState，电梯状态抽象类
3->CCloseingState，电梯门关闭
4->COpenningState，电梯门打开
5->CRunningState，电梯运行
6->CStoppingState，电梯停止
7->CContext，电梯的控制面板
       说明：CContext保持电梯的状态，并提供操作的接口函数。当函数被调用时，CContext直接调用当前状态的相应函数。由状态的接口函数来确定是否可以执行这个动作，以及修改状态为执行这个动作后的状态。
       看代码：第一块是不使用模式的做法，第二块是使用模式的做法，在main()函数里会有调用的方式。
```cpp
<span style="font-size:14px;"><span style="font-size:14px;">//ILift.h
#pragma once
class ILift
{
public:
    ILift(void)
    {
    }
    virtual ~ILift(void)
    {
    }
    static const int OPENING_STATE = 1;
    static const int CLOSING_STATE = 2;
    static const int RUNNING_STATE = 3;
    static const int STOPPING_STATE = 4;
    virtual void SetState(int state) = 0;
    virtual void Open() = 0;
    virtual void Close() = 0;
    virtual void Run() = 0;
    virtual void Stop() = 0;
};
//Lift.h
#pragma once
#include "ilift.h"
class CLift :
    public ILift
{
public:
    CLift(void);
    ~CLift(void);
    void SetState(int state);
    void Open();
    void Close();
    void Run();
    void Stop();
private:
    int m_state;
    void OpenWithoutLogic();
    void CloseWithoutLogic();
    void RunWithoutLogic();
    void StopWithoutLogic();
};
//Lift.cpp
#include "StdAfx.h"
#include "Lift.h"
#include <iostream>
using std::cout;
using std::endl;
CLift::CLift(void)
{
    this->m_state = 0;
}
CLift::~CLift(void)
{
}
void CLift::SetState(int state)
{
    this->m_state = state;
}
void CLift::Open()
{
    switch(this->m_state)
    {
    case OPENING_STATE:
        break;
    case CLOSING_STATE:
        this->OpenWithoutLogic();
        this->SetState(OPENING_STATE);
        break;
    case RUNNING_STATE:
        break;
    case STOPPING_STATE:
        this->OpenWithoutLogic();
        this->SetState(OPENING_STATE);
        break;
    }
}
void CLift::Close()
{
    switch(this->m_state)
    {
    case OPENING_STATE:
        this->CloseWithoutLogic();
        this->SetState(CLOSING_STATE);
        break;
    case CLOSING_STATE:
        break;
    case RUNNING_STATE:
        break;
    case STOPPING_STATE:
        break;
    }
}
void CLift::Run()
{
    switch(this->m_state)
    {
    case OPENING_STATE:
        break;
    case CLOSING_STATE:
        this->RunWithoutLogic();
        this->SetState(RUNNING_STATE);
        break;
    case RUNNING_STATE:
        break;
    case STOPPING_STATE:
        this->RunWithoutLogic();
        this->SetState(RUNNING_STATE);
        break;
    }
}
void CLift::Stop()
{
    switch(this->m_state)
    {
    case OPENING_STATE:
        break;
    case CLOSING_STATE:
        this->StopWithoutLogic();
        this->SetState(CLOSING_STATE);
        break;
    case RUNNING_STATE:
        this->StopWithoutLogic();
        this->SetState(CLOSING_STATE);
        break;
    case STOPPING_STATE:
        break;
    }
}
void CLift::OpenWithoutLogic()
{
    cout << "电梯门开启..." << endl;
}
void CLift::CloseWithoutLogic()
{
    cout << "电梯门关闭..." << endl;
}
void CLift::RunWithoutLogic()
{
    cout << "电梯上下跑起来..." << endl;
}
void CLift::StopWithoutLogic()
{
    cout << "电梯停止了..." << endl;
}</span></span>
```
```cpp
<span style="font-size:14px;"><span style="font-size:14px;">//LiftState.h
#pragma once
class CContext;
class CLiftState
{
public:
    CLiftState(void);
    virtual ~CLiftState(void);
    void SetContext(CContext *pContext);
    virtual void Open() = 0;
    virtual void Close() = 0;
    virtual void Run() = 0;
    virtual void Stop() = 0;
protected:
    CContext *m_pContext;
};
//LiftState.cpp
#include "StdAfx.h"
#include "LiftState.h"
CLiftState::CLiftState(void)
{
}
CLiftState::~CLiftState(void)
{
}
void CLiftState::SetContext( CContext *pContext )
{
    m_pContext = pContext;
}
//CloseingState.h
#pragma once
#include "liftstate.h"
class CCloseingState :
    public CLiftState
{
public:
    CCloseingState(void);
    ~CCloseingState(void);
    void Open();
    void Close();
    void Run();
    void Stop();
};
//CloseingState.cpp
#include "StdAfx.h"
#include "CloseingState.h"
#include "Context.h"
#include <iostream>
using std::cout;
using std::endl;
CCloseingState::CCloseingState(void)
{
}
CCloseingState::~CCloseingState(void)
{
}
void CCloseingState::Open()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pOpenningState);
    this->CLiftState::m_pContext->GetLiftState()->Open();
}
void CCloseingState::Close()
{
    cout << "电梯门关闭..." << endl;
}
void CCloseingState::Run()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pRunningState);
    this->CLiftState::m_pContext->GetLiftState()->Run();
}
void CCloseingState::Stop()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pStoppingState);
    this->CLiftState::m_pContext->GetLiftState()->Stop();
}
//OpenningState.h
#pragma once
#include "liftstate.h"
class COpenningState :
    public CLiftState
{
public:
    COpenningState(void);
    ~COpenningState(void);
    void Open();
    void Close();
    void Run();
    void Stop();
};
//OpenningState.cpp
#include "StdAfx.h"
#include "OpenningState.h"
#include "Context.h"
#include <iostream>
using std::cout;
using std::endl;
COpenningState::COpenningState(void)
{
}
COpenningState::~COpenningState(void)
{
}
void COpenningState::Open()
{
    cout << "电梯门开启..." << endl;
}
void COpenningState::Close()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pCloseingState);
    this->CLiftState::m_pContext->GetLiftState()->Close();
}
void COpenningState::Run()
{
    //do nothing
}
void COpenningState::Stop()
{
    //do nothing
}
//RunningState.h
#pragma once
#include "liftstate.h"
class CRunningState :
    public CLiftState
{
public:
    CRunningState(void);
    ~CRunningState(void);
    void Open();
    void Close();
    void Run();
    void Stop();
};
//RunningState.cpp
#include "StdAfx.h"
#include "RunningState.h"
#include "Context.h"
#include <iostream>
using std::cout;
using std::endl;
CRunningState::CRunningState(void)
{
}
CRunningState::~CRunningState(void)
{
}
void CRunningState::Open()
{
    //do nothing
}
void CRunningState::Close()
{
    //do nothing
}
void CRunningState::Run()
{
    cout << "电梯上下跑..." << endl;
}
void CRunningState::Stop()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pStoppingState);
    this->CLiftState::m_pContext->GetLiftState()->Stop();
}
//StoppingState.h
#pragma once
#include "liftstate.h"
class CStoppingState :
    public CLiftState
{
public:
    CStoppingState(void);
    ~CStoppingState(void);
    void Open();
    void Close();
    void Run();
    void Stop();
};
//StoppingState.cpp
#include "StdAfx.h"
#include "StoppingState.h"
#include "Context.h"
#include <iostream>
using std::cout;
using std::endl;
CStoppingState::CStoppingState(void)
{
}
CStoppingState::~CStoppingState(void)
{
}
void CStoppingState::Open()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pOpenningState);
    this->CLiftState::m_pContext->GetLiftState()->Open();
}
void CStoppingState::Close()
{
    //do nothing
}
void CStoppingState::Run()
{
    this->CLiftState::m_pContext->SetLiftState(CContext::pRunningState);
    this->CLiftState::m_pContext->GetLiftState()->Run();
}
void CStoppingState::Stop()
{
    cout << "电梯停止了..." << endl;
}</span></span>
```
```cpp
<span style="font-size:14px;"><span style="font-size:14px;">//Contex.h
#pragma once
#include "LiftState.h"
#include "OpenningState.h"
#include "CloseingState.h"
#include "RunningState.h"
#include "StoppingState.h"
class CContext
{
public:
    CContext(void);
    ~CContext(void);
    static COpenningState *pOpenningState;
    static CCloseingState *pCloseingState;
    static CRunningState *pRunningState;
    static CStoppingState *pStoppingState;
    CLiftState * GetLiftState();
    void SetLiftState(CLiftState *pLiftState);
    void Open();
    void Close();
    void Run();
    void Stop();
private:
    CLiftState *m_pLiftState;
};
//Context.cpp
#include "StdAfx.h"
#include "Context.h"
COpenningState* CContext::pOpenningState = NULL;
CCloseingState* CContext::pCloseingState = NULL;
CRunningState* CContext::pRunningState = NULL;
CStoppingState* CContext::pStoppingState = NULL;
CContext::CContext(void)
{
    m_pLiftState = NULL;
    pOpenningState = new COpenningState();
    pCloseingState = new CCloseingState();
    pRunningState = new CRunningState();
    pStoppingState = new CStoppingState();
}
CContext::~CContext(void)
{
    delete pOpenningState;
    pOpenningState = NULL;
    delete pCloseingState;
    pCloseingState = NULL;
    delete pRunningState;
    pRunningState = NULL;
    delete pStoppingState;
    pStoppingState = NULL;
}
CLiftState * CContext::GetLiftState()
{
    return m_pLiftState;
}
void CContext::SetLiftState(CLiftState *pLiftState)
{
    this->m_pLiftState = pLiftState;
    this->m_pLiftState->SetContext(this);
}
void CContext::Open()
{
    this->m_pLiftState->Open();
}
void CContext::Close()
{
    this->m_pLiftState->Close();
}
void CContext::Run()
{
    this->m_pLiftState->Run();
}
void CContext::Stop()
{
    this->m_pLiftState->Stop();
}
// State.cpp : 定义控制台应用程序的入口点。
#include "stdafx.h"
#include "ILift.h"
#include "Lift.h"
#include "Context.h"
#include "OpenningState.h"
#include "CloseingState.h"
#include "RunningState.h"
#include "StoppingState.h"
#include <iostream>
using std::cout;
using std::endl;
void DoIt()
{
    //ILift.h, Lift.h, Lift.cpp
    ILift *pLift = new CLift();
    pLift->SetState(ILift::STOPPING_STATE);//电梯的初始条件是停止状态。
    pLift->Open();//首先是电梯门开启，人进去
    pLift->Close();//然后电梯门关闭
    pLift->Run();//再然后，电梯跑起来，向上或者向下
    pLift->Stop();//最后到达目的地，电梯停下来
    delete pLift;
}
void DoNew()
{
    //LiftState.h, LiftState.cpp, OpenningState.h, CloseingState.h, RunningState.h, StoppingState.h
    //Context.h, Context.cpp
    CContext context;
    CCloseingState closeingState;
    context.SetLiftState(&closeingState);
    context.Close();
    context.Open();
    context.Run();
    context.Stop();
}
int _tmain(int argc, _TCHAR* argv[])
{
    cout << "----------使用模式之前----------" << endl;
    DoIt();
    cout << "----------使用模式之后----------" << endl;
    DoNew();
    _CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF);
    _CrtDumpMemoryLeaks();
    return 0;
}</span></span>
```
State状态模式的优点:
（1）.状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
（2）.所有状态相关的代码都存在于某个ConcereteState中，所以通过定义新的子类很容易地增加新的状态和转换。
（3）.状态模式通过把各种状态转移逻辑分不到State的子类之间，来减少相互间的依赖。
State状态模式的缺点:
（1）.在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。导致较多的ConcreteState子类
State状态模式使用总结：
      策略模式关注行为的变化,但归根结底只有一个行为,变化的只是行为的实现.客户不关注这些.当新增变化时对客户可以没有任何影响.状态模式同样关注行为的变化,但这个变化是由状态来驱动,一般来说每个状态和行为都不同.新增的状态或行为一般与已有的不同,客户需要关注这些变化.状态模式中State及其子类中的操作都将Context传入作为参数，以便State可以通过这个指针调用Context中的方法，修改状态。而策略模式没有。
