# Linux进程、线程模型详解 - fanyun的博客 - CSDN博客
2019年02月28日 22:53:10[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：53
       在现代操作系统中，进程是资源管理的最小单元；而线程是程序执行的最小单元；进程支持多线程。一个进程的组成实体可以分为两大部分：线程集合和资源集合。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。线程有自己的私有数据：程 序计数器，栈空间以及寄存器。
传统进程的缺点：
        实际项目中有很多需要并发处理的任务，如数据库的服务器端、网络服务器、大容量计算等。一个任务是一个进程，传统的UNIX进程是单线程（执行流）的， 单线程意味着程序必须是顺序执行，单个任务不能并发；既在一个时刻只能运行在一个处理器上，因此不能充分利用多处理器框架的计算机。如果采用多进程的方 法，即把一个任务用多个进程解决，则有如下问题：
a. fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用现代的写时复制(copy-on-write)技术。
b. 各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC技术，如消息传递和共享内存等。
多线程的优缺点：
        线程：其实可以先简单理解成cpu的一个执行流，指令序列。多支持多线程的程序(进程)可以取得真正的并行(parallelism)，且由于共享进程的代码和全局数据，故线程间的通信是方便的。它的缺点也是由于线程共享进程的地址空间，因此可能会导致竞争，因此对某一块有多个线程要访问的数据需要 一些同步技术。
轻量级进程LWP：
        既然称作轻量级进程，可见其本质仍然是进程，与普通进程相比，LWP与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个LWP，这样它们共享大部分资源；LWP有它自己的[进程标识符](http://zh.wikipedia.org/w/index.php?title=%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6&action=edit&redlink=1)，并和其他进程有着[父子关系](http://zh.wikipedia.org/w/index.php?title=%E7%88%B6%E8%BF%9B%E7%A8%8B&action=edit&redlink=1)；这是和[类Unix](http://zh.wikipedia.org/zh-cn/%E7%B1%BBUnix)操作系统的系统调用vfork()生成的进程一样的。LWP由内核管理并像普通进程一样被调度。[Linux内核](http://zh.wikipedia.org/zh-cn/Linux%E5%86%85%E6%A0%B8)是 支持LWP的典型例子。Linux内核在 2.0.x版本就已经实现了轻量进程，应用程序可以通过一个统一的clone()系统调用接口，用不同的参数指 定创建轻量进程还是普通进程，通过参数决定子进程和父进程共享的资源种类和数量，这样就有了轻重之分。在内核中， clone()调用经过参数传递和解释 后会调用do_fork()，这个核内函数同时也是fork()、vfork()系统调用的最终实现。在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息，而这也是它之所以被称为轻量级的原因。因为LWP之间共享它们的大部分资源，所以它在某些应用程序就不适用了；这个时候就要使用多个普通的进程了。例如，为了避免[内存泄漏](http://zh.wikipedia.org/zh-cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)（a process can be replaced by another one）和实现[特权分隔](http://zh.wikipedia.org/w/index.php?title=%E7%89%B9%E6%9D%83%E5%88%86%E9%9A%94&action=edit&redlink=1)（processes can run under other credentials and have other permissions）。
用户线程：
        这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。
![](https://img-blog.csdnimg.cn/20190225120349121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbnl1bl8wMQ==,size_16,color_FFFFFF,t_70)
       上图是最初的一个用户线程模型，从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户空间实现的线程库实现。
      这种模型对应着恐龙书中提到的多对一线程模型，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。
内核线程：
用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。
简单对比两者优劣势：
1）可移植性：因为ULT完全在用户态实现线程，因此也就和具体的内核没有什么关系，可移植性方面ULT略胜一筹；
2）可扩展性：ULT是由用户控制的，因此扩展也就容易；相反，KLT扩展就很不容易，基本上只能受制于具体的操作系统内核；
3）性能：由于ULT的线程是在用户态，对应的内核部分还是一个进程，因此ULT就没有办法利用多处理器的优势，而KLT就可以通过调度将线程分布 在多个处理上运行，这样KLT的性能高得多；另外，一个ULT的线程阻塞，所有的线程都阻塞，而KLT一个线程阻塞不会影响其它线程。
4）编程复杂度：ULT的所有管理工作都要由用户来完成，而KLT仅仅需要调用API接口，因此ULT要比KLT复杂的多。
小结：
           其实最初根本没有线程的概念，只有进程，一个任务一个进程一个执行流，多任务处理机就是多进程。后来提出线程的概念，但是要如何 去实现，这里就有很多种实现方法了，文章看到这里，可以想到两种实现方法，一种就是上面所说的用户线程的方法，其优缺点上文以简述；再有就是用轻量级进程 去模拟，即我们可以把LWP看成是一个线程。就应为这个使得线程和进程的概念混淆了，至少我觉得很多人其实根本就不知道，至少我以前不知道，有人说系统调 度单位是进程，又有人说是线程，其实系统调度的单位一直就没有改变，只是后来部分线程和进程的界限模糊了，至少上文中的用户线程绝对不是调度对象，LWP 模拟的线程却是调度对象。
