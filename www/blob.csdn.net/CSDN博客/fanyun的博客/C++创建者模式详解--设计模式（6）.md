# C++创建者模式详解--设计模式（6） - fanyun的博客 - CSDN博客
2016年06月26日 12:10:19[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：1036
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**Prototype模式来源：**
           关于这个模式，突然想到了小时候看的《西游记》，齐天大圣孙悟空再发飙的时候可以通过自己头上的3根毛立马复制出来成千上万的孙悟空，对付小妖怪很管用（数量最重要）。Prototype模式也正是提供了自我复制的功能，就是说新对象的创建可以通过已有对象进行创建。在C++中拷贝构造函数（CopyConstructor）曾经是很多程序员的噩梦，浅层拷贝和深层拷贝的魔魇也是很多程序员在面试时候的快餐和系统崩溃时候的根源之一。
**Prototype模式作用：**
         用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。Prototype模式提供了一个通过已存在对象进行新对象创建的接口（Clone）， Clone()实现和具体的语言相关，在C++中通过拷贝构造函数实现。
**Prototype模式UML图如图1所示：**
![](https://img-blog.csdn.net/20160626120509449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
**Prototype模式代码示例：**
Prototype.h
```cpp
#ifndef _PROTOTYPE_H_
#define _PROTOTYPE_H_
/*Prototype模式提供了一个通过已存在对象进行新对象创建的接口（Clone）
  Clone()实现和具体的语言相关，在C++中通过拷贝构造函数实现
作用:
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
*/
/*Prototype原型基类，定义Clone接口函数
*/
class Prototype
{
protected:
    Prototype();
public:
    virtual Prototype* Clone() const=0;//定义Clone接口，根据不同的派生类来实例化对象
    virtual ~Prototype();
};
//派生自Prototype，实现其接口函数
class ConcretePrototype1:public Prototype
{
public:
    ConcretePrototype1();//构造函数
    ~ConcretePrototype1();//析构函数
    ConcretePrototype1(const ConcretePrototype1&);//拷贝构造函数
    virtual Prototype* Clone() const;//实现基类定义的Clone接口，内部调用拷贝构造函数实现复制功能
};
//派生自Prototype，实现其接口函数
class ConcretePrototype2:public Prototype
{
public:
    ConcretePrototype2();//构造函数
    ~ConcretePrototype2();//析构函数
    ConcretePrototype2(const ConcretePrototype2&);//拷贝构造函数
    virtual Prototype* Clone() const;//实现基类定义的Clone接口，内部调用拷贝构造函数实现复制功能
};
#endif
```
Prototype.cpp
```cpp
#include "Prototype.h"
#include "iostream"
using namespace std;
//原型模式
Prototype::Prototype()
{
    cout<<"Prototype"<<endl;
}
Prototype::~Prototype()
{
    cout<<"~Prototype"<<endl;
}
//具体原型类1
ConcretePrototype1::ConcretePrototype1()
{
    cout<<"ConcretePrototype1"<<endl;
}
ConcretePrototype1::~ConcretePrototype1()
{
    cout<<"~ConcretePrototype1"<<endl;
}
ConcretePrototype1::ConcretePrototype1(const ConcretePrototype1& cp)
{
    cout<<"ConcretePrototype1 copy"<<endl;
}
Prototype* ConcretePrototype1::Clone() const
{
    return new ConcretePrototype1(*this);
}
//具体原型类2
ConcretePrototype2::ConcretePrototype2()
{
    cout<<"ConcretePrototype2"<<endl;
}
ConcretePrototype2::~ConcretePrototype2()
{
    cout<<"~ConcretePrototype2"<<endl;
}
ConcretePrototype2::ConcretePrototype2(const ConcretePrototype2& cp)
{
    cout<<"ConcretePrototype2 copy"<<endl;
}
Prototype* ConcretePrototype2::Clone() const
{
    return new ConcretePrototype2(*this);
}
```
main.cpp
```cpp
#include "Prototype.h"
#include <iostream>
using namespace std;
int main()
{
    /*原型模式作用：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
      Prototype模式重在从自身复制自己创建新类，隐藏（不需知道）对象创建的细节
    */
    /*1、用原型实例p1指定创建对象的种类ConcretePrototype1 */
    Prototype* p1 = new ConcretePrototype1();
    /*2、通过拷贝这些原型创建新的对象 */
    Prototype* p2 = p1->Clone();
    cout<< "------------------------" << endl;
    Prototype* p3 = new ConcretePrototype2();
    Prototype* p4 = p3->Clone();
    cout<< "------------------------" << endl;
    delete p1;
    delete p2;
    cout<< "------------------------" << endl;
    delete p3;
    delete p4;
    return 0;
}
```
**Prototype模式使用总结：**
       Prototype模式和Builder模式、AbstractFactory模式都是通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），它们之间的区别是：Builder模式重在复杂对象的一步步创建（并不直接返回对象），AbstractFactory模式重在产生多个相互依赖类的对象，而Prototype模式重在从自身复制自己创建新类。
