# C++外观模式详解--设计模式（11） - fanyun的博客 - CSDN博客
2016年06月29日 08:57:54[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：1737
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**Facade模式产生原因：**
        老旧的code(尤其是将C的代码转成C++代码)或者即便不是老旧code，但涉及多个子系统时，除了重写全部代码(对于老旧code而言)，我们还可能采用这样一种策略:重新进行类的设计，将原来分散在源码中的类/结构及方法重新组合，形成新的、统一的接口，供上层应用使用。这在某种意义上与Adapter及Proxy有类似之处，但是，Proxy(代理)注重在为Client-Subject提供一个访问的中间层，如CORBA可为应用程序提供透明访问支持，使应用程序无需去考虑平台及网络造成的差异及其它诸多技术细节;Adapter(适配器)注重对接口的转换与调整;而Facade所面对的往往是多个类或其它程序单元，通过重新组合各类及程序单元，对外提供统一的接口/界面。
Facade模式作用和目的：
        为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一是就是引入一个外观（Facade）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。将各个子系统整合起来作为Facade，提供给客户端使用。
Facade模式使用场景：
（1）.当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。
       （2）.客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。
       （3）.当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。
**Facade模式的UML结构图如图1所示：**
**![](https://img-blog.csdn.net/20160629093702448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**![](https://img-blog.csdn.net/20160629103434810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**Facade模式的构成：**
[外观角色（](http://blog.csdn.net/hguisu/article/details/7533759)Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订了几种功能组合。
[子系统角色（](http://blog.csdn.net/hguisu/article/details/7533759)Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，facade和client角色是未知的，没有Facade的任何相关信息；即没有指向Facade的实例。
[客户角色（](http://blog.csdn.net/hguisu/article/details/7533759)client）：调用facade角色获得完成相应的功能。
**Facade模式的示例代码如下：**
**Facade.h**
```cpp
<span style="font-size:14px;">#ifndef _FACADE_H_
#define _FACADE_H_
class Subsystem1
{
public:
    Subsystem1();
    ~Subsystem1();
    void Operation();
};
class Subsystem2
{
public:
    Subsystem2();
    ~Subsystem2();
    void Operation();
};
class Facade
{
public:
    Facade();
    ~Facade();
    void OperationWrapper();
private:
    Subsystem1* _subsys1;
    Subsystem2* _subsys2;
};
#endif</span>
```
**Facade.cpp**
```cpp
<span style="font-size:14px;">#include "Facade.h"
#include <iostream>
using namespace std;
Subsystem1::Subsystem1()
{}
Subsystem1::~Subsystem1()
{}
void Subsystem1::Operation()
{
    cout << "Subsystem1::Operation" << endl;
}
Subsystem2::Subsystem2()
{}
Subsystem2::~Subsystem2()
{}
void Subsystem2::Operation()
{
    cout << "Subsystem2::Operation" << endl;
}
Facade::Facade()
{
    this->_subsys1 = new Subsystem1();
    this->_subsys2 = new Subsystem2();
}
Facade::~Facade()
{
    delete this->_subsys1;
    delete this->_subsys2;
    this->_subsys1 = NULL;
    this->_subsys2 = NULL;
}
void Facade::OperationWrapper()
{
    this->_subsys1->Operation();
    this->_subsys2->Operation();
}</span>
```
**main.cpp**
```cpp
<span style="font-size:14px;">#include "Facade.h"
int main()
{
    Facade* pFacade = new Facade();
    pFacade->OperationWrapper();
    return 0;
}</span>
```
**Facade模式的优缺点总结：**
**Facade模式的优点：**
1. 松散耦合
外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。即要点2.
2. 简单易用
外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。
3. 更好的划分访问层次
通过合理使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好的隐藏了内部的细节。
Facade模式**的缺点：**
1.过多的或者是不太合理的Facade也容易让人迷惑，到底是调用Facade好呢，还是直接调用模块好。

