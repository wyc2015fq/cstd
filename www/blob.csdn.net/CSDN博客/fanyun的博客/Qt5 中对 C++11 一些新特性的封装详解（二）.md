# Qt5 中对 C++11 一些新特性的封装详解（二） - fanyun的博客 - CSDN博客
置顶2017年08月27日 22:00:40[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：496
所属专栏：[C/C++/C#开发实战365](https://blog.csdn.net/column/details/c-plus-plus-01.html)
**1、static_assert**
       C++11 可通过编译时使用static_assert 来帮助生成更详细的错误信息，在 Qt5 中对应引入了宏 Q_STATIC_ASSERT 和 Q_STATIC_ASSERT_X ，它们可自动判断是否可用 static_assert ，如果不支持则使用其他模板来代替。
Qt 大量的使用了一些宏定义，来避免因为编译器不支持某些 API 时采取的相应措施。
** 2、Override 和 final**
       你在编码的时候是否有过写了错误的虚函数名称，然后做了错误实现的情况？或者忘记了某个常量？现在你可以使用 Q_DECL_OVERRIDE 宏来声明这是一个对虚函数进行定义的方法，来避免上述错误（这个类似 Java 里的 @Override 注解）。
      如果编译器支持的话，这个宏将被新的 override 属性所替代，否则就不做任何处理。如果你使用支持 C++11 的编译器来编译代码时，当你输入错误的名称时就会报编译错误的信息。
```cpp
classMyModel : public QStringListModel {
              //...
         protected:
               Qt::ItemFlags flags ( const QModelIndex& index)  Q_DECL_OVERRIDE;
         };
```
同样，如果我们忘记常量名也会报错：
```cpp
mymodel.h:15:error: `Qt::ItemFlags MyModel::flags(const QModelIndex&)`
          marked override, but does not override
```
 还有另外一个宏 Q_DECL_FINAL 用来替换新的 final 属性，这个用来指定某个虚函数不允许被重写。
**3、Deleted 成员函数**
      新的 Q_DECL_DELETE 宏用来对 delete 属性进行扩展，如果编译器支持 deleted 函数的话。这个用来获取更清楚的编译器错误以避免常见的一些错误。
Deleted 函数用来显式的指定不让编译器自动生成某些函数，例如默认的构造器或者拷贝赋值操作符等。如果使用了 Deleted 函数，那么当你在代码中使用了相应操作就会报错。
 我们在 Q_DISABLE_COPY 宏的示例中使用过 Q_DECL_DELETE，之前是让这些成员函数变成 private，但错误信息就不那么明确了。
**4、Rvalue 引用和移动构造器**
在我的文章 the Qt 4.8 article 中已经解释过 rvalue 引用了。
 因为 Qt5 中的共享类的引用计算器内部做了改变，因此现在可以 add a move constructor for many of them.
 结论
MSVC 默认的支持 C++11 无需设置任何参数，但GCC 和 Clang 需要使用 require-std=c++0x 来启用 C++11 的支持。
 默认情况下，Qt5 自身是要求用 C++11 的参数进行编译的。
 如果你使用 qmake 你可以在 .pro 项目文件中添加如下参数：
     CONFIG+= c++11
 (在 Qt4, 这个参数写法变成gcc:CXXFLAGS += -std=c++0x)
