# C++实现走迷宫算法(2) - fanyun的博客 - CSDN博客
2019年01月31日 19:58:28[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：58标签：[走迷宫算法](https://so.csdn.net/so/search/s.do?q=走迷宫算法&t=blog)
个人分类：[C++																[算法](https://blog.csdn.net/fanyun_01/article/category/7113106)](https://blog.csdn.net/fanyun_01/article/category/6102444)
1.代码实现
```cpp
#include <stdio.h>
#include <stdlib.h>
void visit(int ,int); 
int maze[9][9] = {
    {2, 2, 2, 2, 2, 2, 2, 2, 2}, 
    {2, 0, 0, 0, 0, 0, 0, 0, 2}, 
    {2, 0, 2, 2, 0, 2, 2, 0, 2},
    {2, 0, 2, 0, 0, 2, 0, 0, 2},
    {2, 0, 2, 0, 2, 0, 2, 0, 2},
    {2, 0, 0, 0, 0, 0, 2, 0, 2},
    {2, 2, 0, 2, 2, 0, 2, 2, 2},
    {2, 0, 0, 0, 0, 0, 0, 0, 2},
    {2, 2, 2, 2, 2, 2, 2, 2, 2}
};
int startI = 1, startJ = 1;
int endI = 7, endJ = 7;
int main(void)
{
    int i, j;
    
    printf("显示迷宫: \n");
    for(i = 0; i < 9; i++)
    {
        for(j = 0; j < 9; j++)
        {
            if(maze[i][j] == 2)
                printf("#");
            else
                printf(" ");
        }
        printf("\n");
    }
    visit(startI, startJ);
    return 0;
}
void visit(int i, int j)
{
    int m, n;
    
    maze[i][j] = 1;
    
    if(i == endI && j == endJ)
    {
        printf("\n显示路径：\n");
        for(m = 0; m < 9; m++)
        {
            for(n = 0; n < 9; n++)
            {
                if(maze[m][n] == 2)
                    printf("#");
                else if(maze[m][n] == 1)
                    printf("$");
                else
                    printf(" ");
            }
            printf("\n");
        }
        
    }
    
    if(maze[i][j+1] == 0)
        visit(i, j+1); 
    if(maze[i+1][j] == 0)
        visit(i+1, j);
    if(maze[i][j-1] == 0)
        visit(i, j-1);
    if(maze[i-1][j] == 0)
        visit(i-1, j);
        
    maze[i][j] = 0; 
}
```
2.代码输出
![](https://img-blog.csdnimg.cn/20190131084846602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbnl1bl8wMQ==,size_16,color_FFFFFF,t_70)
