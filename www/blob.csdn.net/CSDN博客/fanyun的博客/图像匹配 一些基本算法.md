# 图像匹配 一些基本算法 - fanyun的博客 - CSDN博客
2018年08月26日 14:28:06[老樊Lu码](https://me.csdn.net/fanyun_01)阅读数：2421
### 简介：
     本文主要介绍几种基于灰度的图像匹配算法：平均绝对差算法（MAD）、绝对误差和算法（SAD）、误差平方和算法（SSD）、平均误差平方和算法（MSD）、归一化积相关算法（NCC）、序贯相似性检测算法（SSDA）、hadamard变换算法（SATD）。下面依次对其进行讲解。
### MAD算法
### 介绍
        平均绝对差算法（Mean Absolute Differences，简称MAD算法），它是Leese在1971年提出的一种匹配算法。是模式识别中常用方法，该算法的思想简单，具有较高的匹配精度，广泛用于图像匹配。
设S(x,y)是大小为mxn的搜索图像，T(x,y)是MxN的模板图像，分别如下图(a)、(b)所示，我们的目的是：在(a)中找到与(b)匹配的区域（黄框所示）。
![](https://img-blog.csdn.net/20150818211742095)
## 算法思路
        在搜索图S中，以(i,j)为左上角，取MxN大小的子图，计算其与模板的相似度；遍历整个搜索图，在所有能够取到的子图中，找到与模板图最相似的子图作为最终匹配结果。
        MAD算法的相似性测度公式如下。显然，平均绝对差D(i,j)越小，表明越相似，故只需找到最小的D(i,j)即可确定能匹配的子图位置：
![](https://img-blog.csdn.net/20150818214921014)
其中：![](https://img-blog.csdn.net/20150818212226893)
## 算法评价：
### 优点：
①思路简单，容易理解（子图与模板图对应位置上，灰度值之差的绝对值总和，再求平均，实质：是计算的是子图与模板图的L1距离的平均值）。
②运算过程简单，匹配精度高。
### 缺点：
①运算量偏大。
②对噪声非常敏感。
———————————————————————————————————————————————————————————————————————————
# SAD算法
## 介绍
        绝对误差和算法（Sum of Absolute Differences，简称SAD算法）。实际上，SAD算法与MAD算法思想几乎是完全一致，只是其相似度测量公式有一点改动（计算的是子图与模板图的L1距离），这里不再赘述。
![](https://img-blog.csdn.net/20150818214931770)
## 算法实现
由于文章所介绍的几个算法非常相似，所以本文仅列出SAD算法的代码，其余算法的实现类似。看别人代码都相对费力，想自己敲也很简单。
### MATLAB代码
```cpp
%%
%绝对误差和算法（SAD）
clear all;
close all;
%%
src=imread('lena.jpg');
[a b d]=size(src);
if d==3
    src=rgb2gray(src);
end
mask=imread('lena_mask.jpg');
[m n d]=size(mask);
if d==3
    mask=rgb2gray(mask);
end
%%
N=n;%模板尺寸，默认模板为正方形
M=a;%代搜索图像尺寸，默认搜索图像为正方形
%%
dst=zeros(M-N,M-N);
for i=1:M-N         %子图选取，每次滑动一个像素
    for j=1:M-N
        temp=src(i:i+N-1,j:j+N-1);%当前子图
        dst(i,j)=dst(i,j)+sum(sum(abs(temp-mask)));
    end
end
abs_min=min(min(dst));
[x,y]=find(dst==abs_min);
figure;
imshow(mask);title('模板');
figure;
imshow(src);
hold on;
rectangle('position',[y,x,N-1,N-1],'edgecolor','r');
hold off;title('搜索图');
```
### 输出结果
![](https://img-blog.csdn.net/20150818223934903)
![](https://img-blog.csdn.net/20150821110607247)
——————————————————————————————————————————————————————————————————————————————
# SSD算法
        误差平方和算法（Sum of Squared Differences，简称SSD算法），也叫差方和算法。实际上，SSD算法与SAD算法如出一辙，只是其相似度测量公式有一点改动（计算的是子图与模板图的L2距离）。这里不再赘述。
![](https://img-blog.csdn.net/20150818215623907)
——————————————————————————————————————————————————————————————————————————————
# MSD算法
        平均误差平方和算法（Mean Square Differences，简称MSD算法），也称均方差算法。实际上，MSD之余SSD，等同于MAD之余SAD（计算的是子图与模板图的L2距离的平均值），故此处不再赘述。
![](https://img-blog.csdn.net/20150818220301475)
————————————————————————————————————————————————————————————————————————————————
# NCC算法
        归一化积相关算法（Normalized Cross Correlation，简称NCC算法），与上面算法相似，依然是利用子图与模板图的灰度，通过归一化的相关性度量公式来计算二者之间的匹配程度。
![](https://img-blog.csdn.net/20150818222646366)
其中，![](https://img-blog.csdn.net/20150818221858518)、![](https://img-blog.csdn.net/20150818221905555)分别表示(i,j)处子图、模板的平均灰度值。
————————————————————————————————————————————————————————————————————————
# SSDA算法
        序贯相似性检测算法（Sequential Similiarity Detection Algorithm，简称SSDA算法），它是由Barnea和Sliverman于1972年，在文章《[A class of algorithms for fast digital image registration](http://wenku.baidu.com/link?url=JSDEw1KddJOr95QbQGDB0eog2iHR9b96IoV9dETiweTqWmpWyEkXqRNynMr4wgEkm3B2gBKDxReELz9KdcLocvZFmij6L7OurSKMlEOLxPi)》中提出的一种匹配算法，是对传统模板匹配算法的改进，比MAD算法快几十到几百倍。
与上述算法假设相同：S(x,y)是mxn的搜索图，T(x,y)是MxN的模板图，![](https://img-blog.csdn.net/20150819105705305)是搜索图中的一个子图（左上角起始位置为(i,j)）。
显然：![](https://img-blog.csdn.net/20150819105445731)，![](https://img-blog.csdn.net/20150819105455262)
SSDA算法描述如下：
①定义绝对误差：
![](https://img-blog.csdn.net/20150819110805481)
其中，带有上划线的分别表示子图、模板的均值：
![](https://img-blog.csdn.net/20150819110816038)
![](https://img-blog.csdn.net/20150819110824919)
实际上，绝对误差就是子图与模板图各自去掉其均值后，对应位置之差的绝对值。
②设定阈值Th；
③在模板图中随机选取不重复的像素点，计算与当前子图的绝对误差，将误差累加，当误差累加值超过了Th时，记下累加次数H，所有子图的累加次数H用一个表R(i,j)来表示。SSDA检测定义为：
![](https://img-blog.csdn.net/20150819112310010)
下图给出了A、B、C三点的误差累计增长曲线，其中A、B两点偏离模板，误差增长得快；C点增长缓慢，说明很可能是匹配点（图中Tk相当于上述的Th，即阈值；I(i,j)相当于上述R(i,j)，即累加次数）。
![](https://img-blog.csdn.net/20150819112904611)
④在计算过程中，随机点的累加误差和超过了阈值（记录累加次数H）后，则放弃当前子图转而对下一个子图进行计算。遍历完所有子图后，选取最大R值所对应的(i,j)子图作为匹配图像【若R存在多个最大值（一般不存在），则取累加误差最小的作为匹配图像】。
        由于随机点累加值超过阈值Th后便结束当前子图的计算，所以不需要计算子图所有像素，大大提高了算法速度；为进一步提高速度，可以先进行粗配准，即：隔行、隔离的选取子图，用上述算法进行粗糙的定位，然后再对定位到的子图，用同样的方法求其8个邻域子图的最大R值作为最终配准图像。这样可以有效的减少子图个数，减少计算量，提高计算速度。
——————————————————————————————————————————————————————————————————————
# SATD算法
       hadamard变换算法（Sum of Absolute Transformed Difference，简称SATD算法），它是经hadamard变换再对绝对值求和算法。hadamard变换等价于把原图像Q矩阵左右分别乘以一个hadamard变换矩阵H。其中，hardamard变换矩阵H的元素都是1或-1，是一个正交矩阵，可以由MATLAB中的hadamard(n)函数生成，n代表n阶方阵。
      SATD算法就是将模板与子图做差后得到的矩阵Q，再对矩阵Q求其hadamard变换（左右同时乘以H，即HQH），对变换都得矩阵求其元素的绝对值之和即SATD值，作为相似度的判别依据。对所有子图都进行如上的变换后，找到SATD值最小的子图，便是最佳匹配。
## MATLAB实现：
```cpp
%//*****************************************   
%//Copyright (c) 2015 Jingshuang Hu   
   
%//@filename:demo.m   
%//@datetime:2015.08.20   
%//@author:HJS   
%//@e-mail:eleftheria@163.com   
%//@blog:http://blog.csdn.net/hujingshuang   
%//*****************************************  
%% 
%//SATD模板匹配算法-哈达姆变换(hadamard)
clear all;
close all;
%%
src=double(rgb2gray(imread('lena.jpg')));%//长宽相等的
mask=double(rgb2gray(imread('lena_mask.jpg')));%//长宽相等的
M=size(src,1);%//搜索图大小
N=size(mask,1);%//模板大小
%%
hdm_matrix=hadamard(N);%//hadamard变换矩阵
hdm=zeros(M-N,M-N);%//保存SATD值
for i=1:M-N
    for j=1:M-N
        temp=(src(i:i+N-1,j:j+N-1)-mask)/256;
        sw=(hdm_matrix*temp*hdm_matrix)/256;
        hdm(i,j)=sum(sum(abs(sw)));
    end
end
min_hdm=min(min(hdm));
[x y]=find(hdm==min_hdm);
figure;imshow(uint8(mask));
title('模板');
figure;imshow(uint8(src));hold on;
rectangle('position',[y,x,N-1,N-1],'edgecolor','r');
title('搜索结果');hold off;
%//完
```
## 输出结果：
![](https://img-blog.csdn.net/20150821110507301)
![](https://img-blog.csdn.net/20150821110607247)
以上便是几种常见的基于灰度的模板匹配算法。
