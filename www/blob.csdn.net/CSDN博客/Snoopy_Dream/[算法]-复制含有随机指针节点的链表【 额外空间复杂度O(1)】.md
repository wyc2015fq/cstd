# [算法] - 复制含有随机指针节点的链表【 额外空间复杂度O(1)】 - Snoopy_Dream - CSDN博客





2019年01月04日 16:16:57[Snoopy_Dream](https://me.csdn.net/e01528)阅读数：43
所属专栏：[编程感悟](https://blog.csdn.net/column/details/31618.html)









**复制含有随机指针节点的链表**

【 题目】 一种特殊的单链表节点类描述如下

```java
class Node {
  int value;
  Node next;
  Node rand;
  Node(int val) {
  value = val;}}
```

rand指针是单链表节点结构中新增的指针， rand可能指向链表中的任意一个节点， 也可能指向null。 给定一个由Node节点类型组成的无环单链表的头节点head， 请实现一个函数完成这个链表的复制， 并返回复制的新链表的头节点。

【 要求】 时间复杂度O(N)， 额外空间复杂度O(1)

### **不考虑空间复杂度**，

我们就利用**哈希表**，其实就是一个普通字典map

首先遍历一遍，存好map。然后找1的next指针发现是2，然后把2的map对应的2‘给1’的next![](https://img-blog.csdnimg.cn/20190104161459579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2UwMTUyOA==,size_16,color_FFFFFF,t_70)

```java
public static class Node {
		public int value;
		public Node next;
		public Node rand;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node copyListWithRand1(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node cur = head;
		while (cur != null) {
			map.put(cur, new Node(cur.value));//克隆节点给mapnew Node(cur.value)
			cur = cur.next;
		}
		cur = head;
		while (cur != null) {
			map.get(cur).next = map.get(cur.next);//新节点的当前的next = 原先的next指向的克隆map节点
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		}
		return map.get(head);//返回头结点的克隆节点
	}
```

### **考虑空间复杂度：不用map**

**利用结构的设计，将map替代**

**成对设计**

**成对儿取出，**

![](https://img-blog.csdnimg.cn/20190104161553982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2UwMTUyOA==,size_16,color_FFFFFF,t_70)

**这样的设计，新节点的next指针就是下下一个node（注意边界），新节点的rand指针就是上一个节点的rand指针的next的node。**

1‘的next指针很好找，**rand指针**，因为**1的rand指针是3**，所以1**’克隆指针就是3的next。**

```java
public static Node copyListWithRand2(Node head) {
		if (head == null) {
			return null;
		}
        // 成对设计
		Node cur = head;//当前 节点 初始化  到头结点 
		Node next = null;
		// copy node and link to every node
		// 1_>2
		// 1_>1'_>2
		while (cur != null) {
			next = cur.next;//记录后面的环境 2
			cur.next = new Node(cur.value);//当前节点的下一个就是克隆的节点
			cur.next.next = next;//当前节点的下下一个，是原先的next 2
			cur = next;//走向下一个节点 2
		}
		cur = head;
		Node curCopy = null;//curCopy就是新节点
		// set copy node rand
		// 1——1'——2-2’
		// 成对取出
		while (cur != null) {
			next = cur.next.next;//记录的下一次的开始的位置，因为成对取出，所以是后后的环境 2，
			curCopy = cur.next;//拷贝的数据本身data是1'
			curCopy.rand = cur.rand != null ? cur.rand.next : null;
			cur = next;
		}
		Node res = head.next;
		cur = head;
		// split 老链表链接好，新联表连接好 重新链接next指针
		while (cur != null) {
			next = cur.next.next;//成对遍历
            
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
            
			cur = next;
		}
		return res;
```





