# [算法] - 二叉树的层宽 （队列 双向链表 HashMap 以及 编程感悟 ） - Snoopy_Dream - CSDN博客





2018年12月20日 12:03:09[Snoopy_Dream](https://me.csdn.net/e01528)阅读数：34
个人分类：[算法 数据结构](https://blog.csdn.net/e01528/article/category/8547486)

所属专栏：[编程感悟](https://blog.csdn.net/column/details/31618.html)









### 基石

**宽度优先用队列，深度优先用栈。**

**二叉树的宽度，指的是最宽的那一层的个数。**

### 例子

            1

      2            3

4       5      6        7

### 辅助数据：
- **一个队列 LinkedList双向链表<Node> queue（先进先出）。**

**队列****的逻辑：1进来，弹出，进来23，出2，进45，出3进 6，（就是弹出的时候如果有左右指针就进队列，然后再弹再进，直到到末尾）**
- **一个hashmap，用于附加Node属性（是哪一层的属性）这样才能统计出每一层有多少个数。**

### 技法感悟思路拨正

我们**需要每一层的层宽**，但是你本身是**没有现成的层宽**。这就需要你**把每一个节点都加一个属于哪一层的属性**。

循环过程：当队列不为空时，每次从队列中弹出一个的时候，就把他的两个孩子，加入到队列中，同时将孩子的层属性（当前层+1）在HashMap中加入put。

那么好，**当前层就需要提前定义了，**就是从HashMap中get这个node的层属性（当然，这就需要你初始化的时候，弄好head的层属性）。**到这里我们就可以每个节点加上了层的属性。（写代码的时候，先按照简单逻辑先写，写的写的发现诶？这个变量上面需要做下赋值改变什么的 。不是从上往下一直走，是一边往下走，还要不断往回走，写下变量的时候，反思一下有没有边界问题。）**

再来，需要**算层宽**了，最笨的想法是，再弄一个队列，把所有node加进去，然后一个一个弹出来，弹出来的时候判断下层的属性是否发生的变化，没有发生变化，层宽+1，发生变化就层是下一层。聪明的办法就是：看到和上面的队列重复使用，可以在上面一不，获取当前层的之后，加入层宽的计算。

### 代码

![](https://img-blog.csdnimg.cn/2018122011382656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2UwMTUyOA==,size_16,color_FFFFFF,t_70)




