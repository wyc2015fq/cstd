# [算法] - 窗口内最大值更新结构【重要】 - Snoopy_Dream - CSDN博客





2019年01月15日 21:30:42[Snoopy_Dream](https://me.csdn.net/e01528)阅读数：49
所属专栏：[编程感悟](https://blog.csdn.net/column/details/31618.html)









**目录**

[1. 由一个代表题目， 引出一种结构](#1.%20%E7%94%B1%E4%B8%80%E4%B8%AA%E4%BB%A3%E8%A1%A8%E9%A2%98%E7%9B%AE%EF%BC%8C%20%E5%BC%95%E5%87%BA%E4%B8%80%E7%A7%8D%E7%BB%93%E6%9E%84)

[2. 窗口内最大值更新结构](#2.%20%E7%AA%97%E5%8F%A3%E5%86%85%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84)

[3. 具体代码](#3.%20%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81)

[4. 上述程序中所学](#4.%20%E4%B8%8A%E8%BF%B0%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%89%80%E5%AD%A6)

### 1. 由一个代表题目， 引出一种结构



【 题目】

有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边， 窗口每次 向右边滑一个位置。例如， 数组为[4,3,5,4,3,3,6,7]， 窗口大小为3时:

[4 3 5]4 3 3 6 7

4[3 5 4]3 3 6 7

4 3[5 4 3]3 6 7

4 3 5[4 3 3]6 7

4 3 5 4[3 3 6]7

4 3 5 4 3[3 6 7]

窗口中最大值为5 窗口中最大值为5 窗口中最大值为5 窗口中最大值为4 窗口中最大值为6窗口中最大值为7

如果数组长度为n， 窗口大小为w， 则一共产生n-w+1个窗口的最大值。

请实现一个函数。 输入:整型数组arr， 窗口大小为w。

输出:一个长度为n-w+1的数组res， res[i]表示每一种窗口状态下的 以本题为例， 结果应该

返回{5,5,5,4,6,7}。 

### 2. 窗口内最大值更新结构

顾名思义，就是指 一个移动的窗口范围内的更新变动的最大值。

一个L，一个R，每次只能向右移动1.

核心是利用双端队列结构（R移动一种情况，L移动一种情况），内部存放数组arr的index位置信息。双端队列的头节点就是当前窗口的最大值。

要求内部： 大————小 排列
- R移动：如果不满足就从尾部弹出数据，直到满足为止。
- L移动：看此时，窗口长度是否超度W，如超过，视为过期，从头部弹出。

![](https://img-blog.csdnimg.cn/20190115210306994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2UwMTUyOA==,size_16,color_FFFFFF,t_70)

### 3. 具体代码

```java
import java.util.LinkedList;//LinkedList双端链表

public class Code01_SlidingWindowMaxArray {

	public static int[] getMaxWindow(int[] arr, int w) {//w窗口大小
		if (arr == null || w < 1 || arr.length < w) {
			return null;
		}
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int[] res = new int[arr.length - w + 1];//总共收集的结果
		int index = 0;//res[index]写入index
		for (int i = 0; i < arr.length; i++) {//i表示窗口R
			//准备存入i位置的arr[i]
			while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {
				qmax.pollLast();//从尾部弹出
			}
			qmax.addLast(i);//加入arr[i]到尾部
			if (qmax.peekFirst() == i - w) {//如果头部已经要过期了  i - w表示过期的下标
				qmax.pollFirst();//如果已经到窗口极限了，弹出头部，L开始右移动
			}
			if (i >= w - 1) {//当窗口已经形成了，记录每一步的res
				res[index++] = arr[qmax.peekFirst()];
			}
		}
		return res;
	}

	// for test
	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int[] arr = { 4, 3, 5, 4, 3, 3, 6, 7 };
		int w = 3;
		printArray(getMaxWindow(arr, w));

	}

}
```

### 4. 上述程序中所学
- **从遍历开始有了i，然后就不要想遍历了，想的是在i处，可能的情况**
- **以本章为例，先用while处理，不满足大——小结构的数据，其实就是在这里体现了这个结构。**
- 通过上面的处理，下面的就可以用直接的逻辑了。

for (int i = 0; i < arr.length; i++) {// i表示窗口R

            //准备存入i位置的arr[i]

            while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {

                qmax.pollLast();//从尾部弹出

            }

            qmax.addLast(i);//加入arr[i]到尾部

            if (qmax.peekFirst() == i - w) {//如果头部已经要过期了  i - w表示过期的下标

                qmax.pollFirst();//如果已经到窗口极限了，弹出头部，L开始右移动

            }

            if (i >= w - 1) {//当窗口已经形成了，记录每一步的res

                res[index++] = arr[qmax.peekFirst()];

            }

        }



