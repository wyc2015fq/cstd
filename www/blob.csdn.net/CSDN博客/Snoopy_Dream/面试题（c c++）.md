# 面试题（c/c++） - Snoopy_Dream - CSDN博客





2018年11月01日 19:15:27[Snoopy_Dream](https://me.csdn.net/e01528)阅读数：391








**目录**

[1，C++中指针和引用的区别](#1%EF%BC%8CC%2B%2B%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)

[2. 堆和栈的区别](#2.%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB)

[3. 变量的声明和定义有什么区别](#3.%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

[4. sizeof和strlen的区别](#4.sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB)

[5. 链表与数组的区别](#5.%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB)

[6. 简述队列和栈的异同](#6.%E7%AE%80%E8%BF%B0%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E5%BC%82%E5%90%8C)

[7. typedef和define有什么区别](#7.typedef%E5%92%8Cdefine%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

[8. 关键字const是什么](#8.%E5%85%B3%E9%94%AE%E5%AD%97const%E6%98%AF%E4%BB%80%E4%B9%88)

[9. static有什么作用](#9.static%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)

[10. 简述指针常量与常量指针区别](#10.%E7%AE%80%E8%BF%B0%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%8C%BA%E5%88%AB)

[11. 如何避免“野指针”](#11.%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E2%80%9C%E9%87%8E%E6%8C%87%E9%92%88%E2%80%9D)

[12. 结构体和共同体的区别。](#12.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E5%90%8C%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82)

[13. static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗。](#13.static%20%E5%92%8Cconst%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E7%B1%BB%E9%87%8C%E9%9D%A2static%E5%92%8Cconst%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%97%E3%80%82)

[14. 什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？](#14.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E9%9D%A2%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%8C%87%E9%92%88%E8%B6%8A%E7%95%8C%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E4%BD%A0%E9%80%9A%E5%B8%B8%E9%87%87%E7%94%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E6%9D%A5%E9%81%BF%E5%85%8D%E5%92%8C%E5%87%8F%E5%B0%91%E8%BF%99%E7%B1%BB%E9%94%99%E8%AF%AF%EF%BC%9F)

15. TCP和UDP通信的差别？

[16. 链表和数组有什么区别](#16.%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

[更多面试参考网址](#%E6%9B%B4%E5%A4%9A%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80)

### 1，C++中指针和引用的区别

注重在理解：

1. 指针从本质上讲是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。而引用是一个别名，对应用的操作与对变量直接操作效果完全相同。它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，切记要对其进行初始化，而且自始至终只能依附于同一个变量，可以认为是“从一而终”。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

2.在C++中，指针和引用经常用于函数的参数传递，指针传递参数和引用传递参数是有本质上的不同的：

    指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

    而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

    引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

为了进一步加深大家对指针和引用的区别，下面我从编译的角度来阐述它们之间的区别：

程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

最后，总结一下指针和引用的相同点和不同点：

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●引用没有const，指针有const，const的指针不可变；

●引用不能为空，指针可以为空；

●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查

### 2.堆和栈的区别

这个网址说的比较细https://blog.csdn.net/hairetz/article/details/4141043/

C/C++编译的程序占用的内存分为以下几个部分  

  1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。      

  2、堆区（heap）—   一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初 始化的全局变量和未初始化的静态变量在相邻的另一块区域。  -   程序结束后由系统释放。  

  4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放  

  5、程序代码区—存放函数体的二进制代码。

### 3.变量的声明和定义有什么区别

一个变量可以在多个地方声明，但只能在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 为变量分配地址和存储空间的称为定义，不分配地址的称为声明。

说明：很多时候一个变量，只是声明，不分配内存空间，知道具体使用时才初始化，分配内存空间，如外部变量。

### 4.sizeof和strlen的区别

sizeof是一个操作符，strlen是库函数。

sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。

编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。

数组做sizeof的参数不退化，传递给strlen就退化为指针了。

注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。

说明：指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是，这个整型数据指向的是一段内存地址。

### 5.链表与数组的区别

数组和链表有以下几点不同：

（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

（4）越界问题：链表不存在越界问题，数组有越界问题。

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。


### 6.简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。

注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。

它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

### 7.typedef和define有什么区别

（1）用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。

（2）执行时间不同：typedef是编译过程的一部分，有类型检查的功能。define是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

（3）作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是正确的。

（4）对指针的操作不同：typedef和define定义的指针时有很大的区别。

注意：typedef定义是语句，因为句尾要加上分号。而define不是语句，千万不能在句尾加分号。

### 8.关键字const是什么

const用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。

说明：const修饰函数参数，是一种编程规范的要求，便于阅读，一看即知这个参数不能被改变，实现时不易出错。

### 9.static有什么作用

static在C中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在C++中新增了两种作用：定义静态数据成员、静态函数成员。

注意：因为static定义的变量分配在静态区，所以其定义的变量的默认值为0，普通变量的默认值为随机数，在定义指针变量时要特别注意。

### 10.简述指针常量与常量指针区别

指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。其实指针常量是唯一的，即NULL；常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

### 11.如何避免“野指针”

“野指针”产生原因及解决办法如下：

（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。

（2）指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。

（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

### 12.结构体和共同体的区别。

定义：

结构体struct：把不同类型的数据组合成一个整体，自定义类型。

共同体union：使几个不同类型的变量共同占用一段内存。

地址：

struct和union都有内存对齐，结构体的内存布局依赖于CPU、操作系统、编译器及编译时的对齐选项。

关于内存对齐，先让我们看四个重要的基本概念：

1.数据类型自身的对齐值：

对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。

2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。

3.指定对齐值：#pragma pack(n)，n=1,2,4,8,16改变系统的对齐系数

4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。



### 13.static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗。

 static的作用：

对变量：

1.局部变量：

在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。

  1）内存中的位置：静态存储区

  2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

  3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。

 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

2.全局变量

在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。

1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）

2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。

注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问，修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。

对类中的：

1.成员变量

用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 。

特点：

        不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。

        静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。

        静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。

2.成员函数

        用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。

        静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不需要加static修饰符。

        在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。

不可以同时用const和static修饰成员函数。

C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。

我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

const的作用：

 1.限定变量为不可修改。

2.限定成员函数不可以修改任何数据成员。

3.const与指针：

const char *p 表示 指向的内容不能改变。

char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。

### 14.什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？

答：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。

使用的时候要记得指针的长度。

malloc的时候得确定在那里free.

对指针赋值的时候应该注意被赋值指针需要不需要释放.

动态分配内存的指针最好不要再次赋值.

### 15.TCP和UDP通信的差别？

答：

1.TCP面向连接， UDP面向无连接的

2.TCP有保障的，UDP传输无保障的

3.TCP是效率低的，UDP效率高的

4.TCP是基于流的，UDP基于数据报文

5.TCP传输重要数据，UDP传输不重要的数据

### 16.链表和数组有什么区别

数组和链表有以下几点不同：

（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

（4）越界问题：链表不存在越界问题，数组有越界问题。

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间


### 更多面试参考网址

https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html

https://www.cnblogs.com/LUO77/p/5771237.html

https://www.cnblogs.com/LUO77/p/5771237.html

---------------------  

作者：向阳-  

来源：CSDN  

原文：https://blog.csdn.net/m0_37407756/article/details/82743019  

版权声明：本文为博主原创文章，转载请附上博文链接！



