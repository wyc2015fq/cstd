# iOS-面试秘籍 - 努力，可能成功！放弃，注定失败！ - CSDN博客
置顶2016年06月08日 10:56:10[上天眷顾我](https://me.csdn.net/qq_30513483)阅读数：856
##### 序言
> 
目前形势，参加到iOS队伍的人是越来越多，甚至已经到供过于求了。今年，找过工作人可能会更深刻地体会到今年的就业形势不容乐观，加之，培训机构一火车地向用人单位输送iOS开发人员，打破了生态圈的动态平衡。矫情一下，言归正传，我奉献一下，为iOS应聘者梳理一下面试题，希望能助一臂之力!
#### 一. OC的理解与特性
- - OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言，
- - Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。
- - **动态类型**：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单来说就是id类型。事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛。静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。
- - **动态绑定**：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。
- - **动态加载**：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retina设备上加载@2x的图片，而在老一些的普通苹设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类。
#### 二: 简述内存管理基本原则
- 
**MRC**：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）。
- 
**ARC**：iOS 5.0之后引用自动管理机制——自动引用计数（ARC），管理机制与手动机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。
- 如果使用alloc、copy(mutableCopy)或者retian一个对象时,你就有义务,向它发送一条release或者autorelease消息。其他方法创建的对象,不需要由你来管理内存。
- 向一个对象发送一条autorelease消息,这个对象并不会立即销毁, 而是将这个对象放入了自动释放池,待池子释放时,它会向池中每一个对象发送 一条release消息,以此来释放对象.
- 向一个对象发送release消息,并不意味着这个对象被销毁了,而是当这个对象的引用计数为0时,系统才会调用dealloc方法,释放该对象和对象本身它所拥有的实例。
#### 三. 内存管理的注意事项
- 如果一个对象有一个_strong类型的指针指向着，找个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil。如果一个指针被指向nil，那么它原来指向的对象就被释放了。当一个视图控制器被释放时，它内部的全局指针会被指向nil。用法“：不管全局变量还是局部变量用_strong描述就行。
- 局部变量：出了作用域，指针会被置为nil。
- 方法内部创建对象，外部使用需要添加_autorelease;
- 连线的时候，用_weak描述。
- 代理使用unsafe_unretained就相当于assign；
- block中为了避免循环引用问题，使用_weak描述；
- 
声明属性时，不要以new开头。如果非要以new开头命名属性的名字，需要自己定制get方法名，如
`@property(getter=theString) NSString * newString;`
- 如果要使用自动释放池，用@autoreleasepool{}
- ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成Core Foundation中的变量需要交换管理权；
- 在非ARC工程中采用ARC去编译某些类：-fobjc-arc。
- 在ARC下的工程采用非ARC去编译某些类：-fno-fobjc-arc。
#### 四. 如何理解MVC设计模式
- MVC是一种架构模式，M表示Model，V表示视图View，C表示控制器Controller：
- Model负责存储、定义、操作数据
- View用来展示书给用户，和用户进行操作交互；
- **Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，Model也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，Model发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。**
#### 五. 如何理解MVVM设计模式
- ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。
- View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。
- 详细可以参考[MVVM随笔](http://www.jianshu.com/p/8e7854e85ca5)
#### 六: Objective-C中是否支持垃圾回收机制？
- 
OC是支持垃圾回收机制的(Garbage collection简称GC),但是apple的移动终端中,是不支持GC的,Mac桌面系统开发中是支持的.
- 
移动终端开发是支持ARC（Automatic Reference Counting)的简称）,ARC是在IOS5之后推出的新技术,它与GC的机制是不同的。我们在编写代码时, 不需要向对象发送release或者autorelease方法,也不可以调用delloc方法,编译器会在合适的位置自动给用户生成release消息(autorelease),ARC 的特点是自动引用技术简化了内存管理的难度.
#### 七: 协议的基本概念和协议中方法默认为什么类型
OC中的协议是一个方法列表,且多少有点相关。它的特点是可以被任何类使用(实现),但它并不是类(这里我们需要注意),自身不会实现这样方法, 而是又其他人来实现协议经常用来实现委托对象(委托设计模式)。如果一个类采用了一个协议,那么它必须实现协议中必须需要实现的方法,在协议中的方法默认是必须实现(@required),添加关键字@optional,表明一旦采用该协议,这些“可选”的方法是可以选择不实现的。
#### 八: 简述类目category优点和缺点
###### 优点：
- 不需要通过增加子类而增加现有类的行为(方法),且类目中的方法与原始类方法基本没有区别;
- 通过类目可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性;
###### 缺点：
- 无法向类目添加实例变量,如果需要添加实例变量,只能通过定义子类的方式;
- 类目中的方法与原始类以及父类方法相比具有更高优先级,如果覆盖父类的方法,可能导致super消息的断裂。因此,最好不要覆盖原始类中的方法。
#### 九: 类别的作用
- 给系统原有类添加方法，不能扩展属性。如果类别中方法的名字跟系统的方法名一样，在调用的时候类别中的方法优先级更高；
- 分散类的实现：如：
`+ (NSIndexPath *)indexPathForRow:(NSInteger)row inSection:(NSInteger)section`
原本属于NSIndexPath的方法，但因为这个方法经常使用的表的时候调用、跟表的关系特别密切，因此把这个方法一类别的形式、声明在UITableView.h中。
- 声明私有方法，某一个方法只实现，不声明，相当于私有方法。
- 类别不能声明变量，类别不可以直接添加属性。property描述setter方法，就不会报错。
#### 十:循环引用的产生原因，以及解决方法
- **产生原因**：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减1。对象A的销毁依赖于对象B的销毁，同时对象B销毁也依赖与对象A的销毁，从而形成**循环引用**，此时，即使外界没有任何指针访问它，它也无法释放。
![](http://upload-images.jianshu.io/upload_images/2092929-c8692f4cc12ba469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
多个对象间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：
![](http://upload-images.jianshu.io/upload_images/2092929-c09cb2806c22bdcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
##### 解决方法：
事先知道存在循环引用的地方，在合理的位置主动断开一个引用，是对象回收；
使用[弱引用](http://www.tuicool.com/articles/NVNrMv7)的方法。
#### 十一: 键路径(keyPath)、键值编码（KVC）、键值观察（KVO）
**键路径 **
- 在一个给定的实体中,同一个属性的所有值具有相同的数据类型。
- 键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。 - 键路径是一个由用点作分隔符的键组成的字符串,用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的,接下来每个键的值也是相对于其前面的性质。
- 键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径,您可以指定对象图中的一个任意深度的路径,使其指向相关对象的特定属性。
**键值编码KVC**
- 键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；
- **KVC的缺点**：一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。
**键值观察KVO**
- 键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码。
- 实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修 改它的实例变量,这样才能被观察者观察到。因此,KVC是KVO的基础。
- **Demo**
比如我自定义的一个button
```
```
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; 
#pragma mark KVO - 
  (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 
{                        
   if ([keyPath isEqualToString:@"highlighted"] ) {
         [self setNeedsDisplay]; 
 }
}
```
```
对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。
#### 十二: KVC机制通过key找到value的原理
- 当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过下面几种不同的方式解析这个调用。
- 首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。
- 补充：KVC查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。
- 设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。
#### 十三: **Objective-C **中如何实现 **KVO**
- 
注册观察者(注意：观察者和被观察者不会被保留也不会被释放)
```
- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath
  options:(NSKeyValueObservingOptions)options context:(void *)context;
```
- 
接收变更通知
```
```
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object 
change:(NSDictionary *)change context:(void *)context;
```
```
- 
移除对象的观察者身份
`- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;`
- 
KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己。
#### 十四: 代理的作用
- 代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性。
- 改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
- 另外一点，代理可以理解为java中的回调监听机制的一种类似。
- 代理的属性常是assign的原因：防止循环引用,以至对象无法得到正确的释放。
#### 十五: NSNotification、Block、Delegate和KVO的区别
- 代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；
- 效率：Delegate比NSNOtification高；
- Delegate和Block一般是一对一的通信；
- Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；
- Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；
#### 十六: Objective-C中可修改和不可以修改类型
- 可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改。
- 比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间
#### 十七: 当我们调用一个静态方法时,需要对对象进行 **release **吗?
不需要,静态方法(类方法)创建一个对象时,对象已被放入自动释放池。在自动释放池被释放时,很有可能被销毁。
#### 十八: 当我们释放我们的对象时,为什么需要调用**[super dealloc]**方法,它的位置又是如何的呢?
- 因为子类的某些实例是继承自父类的,因此需要调用[super dealloc]
方法, 来释放父类拥有的实例,其实也就是子类本身的。一般来说我们优先释放子类拥 有的实例,最后释放父类所拥有的实例
#### 十九: static、self、super关键字的作用
- 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值.
- 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问.
- 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明.
- 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝.
- self:当前消息的接收者。
- super:向父类发送消息。
#### 二十: #include与#import的区别 #import与@class 的区别
- **#include和#import**
其效果相同,都是查询类中定义的行为(方法);
- _ #import: 不会引起交叉编译,确保头文件只会被导入一次；
- @class的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；
- @class比#import编译效率更高。
- **此外@class和#import的主要区别在于解决引用死锁的问题。**
#### 二十一: @public、@protected、@private 它们的含义与作用
- @public:对象的实例变量的作用域在任意地方都可以被访问 ;
- @protected:对象的实例变量作用域在本类和子类都可以被访问 ;
- @private:实例变量的作用域只能在本类(自身)中访问 .
#### 二十二: 解释 **id **类型
任意类型对象，程序运行时才决定对象的类型。
#### 二十三: isMemberOfClass 和 isKindOfClass 联系与区别
- **联系**：两者都能检测一个对象是否是某个类的成员
- **区别**：isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员 ,而isMemberOfClass 只能做到第一点。
- **举例**：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到。
#### 二十四: iOS开发中数据持久性有哪几种?
**数据存储的核心都是写文件。**
- 
属性列表：只有NSString、NSArray、NSDictionary、NSData可writeToFile；存储依旧是plist文件。plist文件可以存储的7中数据类型： array、dictionary、string、bool、data、date、number。
- 
对象序列化（对象归档）：对象序列化通过序列化的形式，键值关系存储到本地，转化成二进制流。通过runtime实现自动化归档/解档，请参考[这个文章](http://www.henishuo.com/runtime-archive-unarchive-automaticly/)。实现NSCoding协议必须实现的两个方法：
2.1.**编码**（对象序列化）：把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData，可以存储到本地；
2.2 **解码**（对象反序列化）：把二进制数据转化为本来的类型。
- 
SQLite 数据库：大量有规律的数据使用数据库。
- CoreData ：通过管理对象进行增、删、查、改操作的。它不是一个数据库，不仅可以使用SQLite数据库来保持数据，也可以使用其他的方式来存储数据。如：XML。
#### 二十五: CoreData的介绍：
- CoreData是面向对象的API，CoreData是iOS中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础。
- CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理、对象关系管理和持久化等方面相关的问题。
- 大多数情况下，我们引用CoreData作为持久化数据的解决方案，并利用它作为持久化数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转换成数据，保存到SQL中，然后将保存后的数据还原成OC对象。
#### 二十六: CoreData的特征：
- 通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量。
- 将对象数据存储在SQLite数据库已获得性能优化。
- 提供NSFetchResultsController类用于管理表视图的数据，即将Core - Data的持久化存储在表视图中，并对这些数据进行管理：增删查改。
管理undo/redo操纵；
- 检查托管对象的属性值是否正确。
#### 二十七: 对象可以被copy的条件
只有实现了NSCopying和NSMutableCopying
协议的类的对象才能被拷贝,分为不可变拷贝和可变拷贝,[具体区别戳这](http://www.jianshu.com/p/f84803356cbb)；
NSCopying
协议方法为：
```
- (id)copyWithZone:(NSZone *)zone { MyObject *copy = [[[self class] allocWithZone:
 zone] init]; copy.username = [self.username copyWithZone:zone]; return copy;}
```
#### 二十八: 自动释放池工作原理
- 自动释放池是NSAutorelease类的一个实例,当向一个对象发送autorelease消息时,该对象会自动入池,待池销毁时,将会向池中所有对象发送一条release消息,释放对象。
- [pool release]、 [pool drain]表示的是池本身不会销毁,而是池子中的临时对象都被发送release,从而将对象销毁。
#### 二十九: 定义属性时,什么时候用assign、retain、copy以及它们的之间的区别
- **assign**:普通赋值,一般常用于基本数据类型,常见委托设计模式, 以此来防止循环引用。(我们称之为弱引用).
- **retain**:保留计数,获得到了对象的所有权,引用计数在原有基础上加1.
- **copy**:一般认为,是在内存中重新开辟了一个新的内存空间,用来 存储新的对象,和原来的对象是两个不同的地址,引用计数分别为1。但是当copy对象为不可变对象时,那么copy的作用相当于retain。因为,这样可以节约内存空间
#### 三十: 堆和栈的区别
- **栈区(stack)**由编译器自动分配释放 ,存放方法(函数)的参数值, 局部变量的值等，栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的。
- **堆区(heap)**一般由程序员分配释放, 若程序员不释放,程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活。
- **碎片问题**：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出.
- **分配方式**：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
- **分配效率**：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。
- **全局区(静态区)**(static),全局变量和静态变量的存储是放在一块 的,初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。
- **文字常量区**—常量字符串就是放在这里的。程序结束后由系统释放。
- **程序代码区**—存放函数体的二进制代码
#### 三十一: 对于单元格重用的理解
当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。
#### 三十二: 线程与进程的区别和联系?
- 一个程序至少要有进城,一个进程至少要有一个线程.
- **进程**:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
- **线程**:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。
- 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
#### 三十三: 多线程编程
- **NSThread**:当需要进行一些耗时操作时会把耗时的操作放到线程中。线程同步：多个线程同时访问一个数据会出问题，NSlock、线程同步块、@synchronized(self){}。
- **NSOperationQueue**操作队列（不需考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation、BSBlockOperation、自定义Operation。创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到操作队列中时，默认会调用main方法。
- **GCD**（`Grand Central Dispatch）宏大的中央调度，串行队列、并发队列、主线程队列；
- **同步和异步**：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个。
- **串行和并行**：串行是多个任务按一定顺序执行，并行是多个任务同时执行；
- 代码是在分线程执行，在主线程中刷新UI。
文／greedyDoor（简书作者）
原文链接：http://www.jianshu.com/p/919921b5d893
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
