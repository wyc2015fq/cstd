# 微信语音连播的实现思路 - 努力，可能成功！放弃，注定失败！ - CSDN博客
置顶2016年07月09日 10:58:43[上天眷顾我](https://me.csdn.net/qq_30513483)阅读数：2811
> 
最近有同学问到了关于微信语音连播的问题，在这里我将自己模仿微信语音连播的核心代码部分开源出来，供大家参考。仔细阅读，按照代码的思路就可以实现语音连播。
基本的思路就是：使用递归思想。点击语音消息，获取cell，判断（1）播放的消息是否正在播放，（2）播放的消息是否是点击的消息；然后进行播放，更新语音动画UI。播放完毕，需要在内存中的messageArray中查找下一条消息，通过消息找到cell，更新cell上的语音动画UI，播放该语音，更新数据库中的标记。然后继续下一条消息的播放。
```
- (void)clickCellVoice:(VMessageEntity *)model
{
    __weak VChatsViewController *weakSelf = self;
 // cell 的点击事件，
    if (model)
    {
        VChatVoiceBaseCell *voiceCell = nil;
        // 在可视化的cell上面用messageId查找与model对应的VChatVoiceBaseCell，
        for (UITableViewCell *cell in [_tableView visibleCells]) {
            if ([cell isKindOfClass:[VChatVoiceBaseCell class]]) {
              VChatVoiceBaseCell *tempVoiceCell  =(VChatVoiceBaseCell *)cell;
                if ( tempVoiceCell.message.messageId == model.messageId) {
                    voiceCell = (VChatVoiceBaseCell *)cell;
                    break;
                }
            }
        }
        if (voiceCell)
        {
            //如果点击的cell的语音文件没有播放，则开始播放，同时开启语音播放动画。
            if (![[VAudioPalyerManager sharedManager] isPlaying]) {
                [voiceCell.playIcon startAnimating];
                 model.voiceMessage.isPlaying = YES;
                [[VAudioPalyerManager sharedManager] playWithfile:model.voiceMessage.voicemd5 
                finishPlaying:^(NSString *fileName,BOOL isFinished) {
                    // 播放完成的回调，停止动画，开始播放下一条
                    [voiceCell.playIcon stopAnimating];
                     model.voiceMessage.isPlaying = NO;
                    if (isFinished) {
                        if (model.messageStatus == VMessageStatusNone && model.readStatus == VMessageNoRead)
                        {
                            [weakSelf playNextUnReadVoiceWithMessageEntity:model];
                        }
                    }
                }];
            }else if([[VAudioPalyerManager sharedManager]isPlaying]
             &&![model.voiceMessage.voicemd5 isEqualToString:[[VAudioPalyerManager sharedManager] currentFileName]]) 
             //如果正在播放，且与当前的文件名不同，停止播放当前的播放效果，播放另外一条。
            {
                [[VAudioPalyerManager sharedManager] stop];
                [voiceCell.playIcon startAnimating];
                 model.voiceMessage.isPlaying = YES;
                [[VAudioPalyerManager sharedManager] playWithfile:model.voiceMessage.voicemd5 
                finishPlaying:^(NSString *fileName, BOOL isFinish) {
                    [voiceCell.playIcon stopAnimating];
                    model.voiceMessage.isPlaying = NO;
                    if (isFinish) {
                        if (model.messageStatus == VMessageStatusNone && model.readStatus == VMessageNoRead)
                        {
                            [weakSelf playNextUnReadVoiceWithMessageEntity:model];
                        }
                    }
                }];
            }else if([[VAudioPalyerManager sharedManager]isPlaying] 
            && [model.voiceMessage.voicemd5 isEqualToString:[[VAudioPalyerManager sharedManager] currentFileName]])
             // 处理当前正在播放的语音，停止当前的语音播放
            {
                [[VAudioPalyerManager sharedManager] stop];
                 model.voiceMessage.isPlaying = NO;
                if([voiceCell.playIcon isAnimating])
                {
                    [voiceCell.playIcon stopAnimating];
                }
            }
        }
     }
}
//递归查找下一条未读语音消息
- (void)playNextUnReadVoiceWithMessageEntity:(VMessageEntity *)model
{
 //找到message在chatArray里面的位置
    model.readStatus = VMessageHaveRead;
    __weak VChatsViewController *weakSelf = self;
    if (model) {
        NSIndexPath *index = [NSIndexPath indexPathForRow:
        [self.messageArray indexOfObject:model] inSection:0];
        if (index)
        {
            for (NSInteger i = index.row+1; i < self.messageArray.count; i++) {
                id tempObj = self.messageArray[i];
                if ([tempObj isKindOfClass:[VMessageEntity class]])
                {
                    VMessageEntity *messageEntity = (VMessageEntity *)tempObj;
                    if (messageEntity.messageType == VMessageTypeVoice && messageEntity.messageStatus == VMessageStatusNone)
                    {//判断是语音消息
                        if (messageEntity.readStatus == VMessageNoRead)
                        {
                            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                                //取到下一条的cell
                                VChatVoiceReceiveCell *voiceBaseCell = nil;
                                for (UITableView *cell in [_tableView visibleCells]) {
                                    if ([cell isKindOfClass:[VChatVoiceReceiveCell class]]) {
                                       VChatVoiceReceiveCell *tempBaseCell  = (VChatVoiceReceiveCell *)cell;
                                        if (tempBaseCell.message.messageId == messageEntity.messageId) {
                                            voiceBaseCell = (VChatVoiceReceiveCell *)cell;//找到cell
                                        }
                                    }
                                }
                                    //找到cell，更新UI
                                    [voiceBaseCell.playIcon startAnimating];
                                    //更新数据库消息的未读状态,去掉未读标记
                                    [voiceBaseCell receiveVoiceCellBeClick];
                                    //更新数据库
[[VMessageManager sharedManager] updateReadStatusWithClientMessageId:
messageEntity.clientMessageId readStatus:VMessageHaveRead userId:messageEntity.sendUserId];
                                    messageEntity.readStatus = VMessageHaveRead;
                                    [weakSelf.messageArray replaceObjectAtIndex:i  withObject:messageEntity];
                                    //进行播放
                                    messageEntity.voiceMessage.isPlaying  = YES;
                                    [[VAudioPalyerManager sharedManager] 
                                    playWithfile:messageEntity.voiceMessage.voicemd5 
                                    finishPlaying:^(NSString *fileName, BOOL isFinish) {
                                        [voiceBaseCell.playIcon stopAnimating];
                                        messageEntity.voiceMessage.isPlaying  = NO;
                                        if (isFinish) {
                                            if (model.messageStatus == VMessageStatusNone)
                                            {
                                                //isFinish == yes 则完整播放,再次调用这个方法
                                                [weakSelf playNextUnReadVoiceWithMessageEntity:model];
                                            }
                                        }
                                    }];
                            });
                            break;
                        }
                    }
                }else{
                    NSLog(@"不是消息类型");
                }
            }
        }
    }
}
```
如有疑问，欢迎加群讨论：iOS--IM即时通讯交流群：551709117
或者
微博私信：[http://weibo.com/490jiulin/home?wvr=5](http://weibo.com/490jiulin/home?wvr=5)
文／九零猴VS久林（简书作者）
原文链接：http://www.jianshu.com/p/1d354feacf3c
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
