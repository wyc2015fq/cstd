# Linux操作系统的BIOS启动流程 - 小灰笔记 - CSDN博客





2017年08月20日 14:25:46[grey_csdn](https://me.csdn.net/grey_csdn)阅读数：579








       要理解大致的启动流程现需要了解几组常用的寄存器：

       1，CS + IP：其中CS是段寄存器，或者是CODE段寄存器，存储的是段的基地址。IP是程序段寄存器的偏移量。两者结合，确定下一条CPU指令的执行地址。

       2，SS + SP：其实，SS是堆栈寄存器，而SP是堆栈寄存器偏移。前者存储的是堆栈的基地址，后者存储的是栈的栈顶。另外，如果使用到了BP，默认的基地址也是SS，通过BP可以访问的不仅仅是栈顶，通过SS和BP可以访问整个堆栈。

       3，DS/ES + 有效地址，这一组寄存器决定是附加数据的。



       上面就是常用的几组寄存器，其中Linux启动阶段关系比较大的还是第一组。

       当电脑启动或者复位的按钮按下的时候，CPU会把CS寄存器设置为0xFFF0，段基地址设置为0xFFFF0000，段长度设置为64KB。而IP被设置为0xFFF0。因此此时CPU的代码指向0xFFFFFFF0，也就是4GB最后64KB的最后64B处。

       上面这段基本上是来自于别人的书籍，但是从理解来看，最初的CS寄存器赋值为0xFFF0我还是没有弄明白什么含义。是完全没有用还是赋值为0xFFF0之后其段基地址的数值就是0xFFFF0000？总体的程序执行位置还是把握住基地址加IP偏移量计算出来应该问题就不大了。

       程序的运行位置正好是现在的系统BIOS的存放位置，而这里会存放一条JMP的指令。跳转到BIOS的程序中的某个位置开始执行。

       BIOS开始执行后，在一系列的硬件检测等操作结束之后，BIOS会把与老机器兼容的程序复制到最低端地址大小为1MB内存的末端64KB区域中。然后跳转到这个地方，让CPU在真是的地址模式下进行运行。而这个1MB内存的末端64KB的区域被称为BIOS的影子区域。

       上面的过程完成之后，BIOS会从硬盘或者其他的设备加载引导程序，程序被加载到内存的0x7c00的地方开始执行。

       这整个过程的流程还是比较清晰的，但是代码实现以及硬件启动软件的模式我还是比较感兴趣，这跟我现在嵌入式软件中遇到的startup是很像的。而这部分的实现，直到现在我都没有弄明白。



