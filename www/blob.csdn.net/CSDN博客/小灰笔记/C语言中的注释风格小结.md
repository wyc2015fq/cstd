# C语言中的注释风格小结 - 小灰笔记 - CSDN博客





2017年04月03日 22:18:34[grey_csdn](https://me.csdn.net/grey_csdn)阅读数：5906
个人分类：[C](https://blog.csdn.net/grey_csdn/article/category/6639462)









       C语言中常用的注释风格有两种，一种是通过如下模式进行一段代码的注释：

/* comment*/

另一种是单行注释符号：

// comment

       学生时代的注释我一般是选用后者，那时候编码量十分有限，即使是简单的小段落注释使用的IDE也支持批量添加单行注释符。而在编码之中，简单的单行注释进行注释的时候键盘的操作更为简单一点。

       不过，工作之后接触了相应的编码规范之后，C语言的注释我基本上放弃了单行注释的方法，最多仅仅在调试的时候做简单的使用。

       其实，单行注释是从C++中借鉴来的，算是C++风格的注释方式。而这种方式在C语言中有时候会带来一定的差异性，甚至是引入难以察觉的Bug。把我自己从网络或者书籍中看到的两个比较典型的方式列述总结一下。

示例1：

#include"stdio.h"



int main(void)

{

       int a = 0;



       a += 5; \

       a = 123;



       printf("value of a: %d\n",a);



       return 0;

}

       代码的编译运行结果如下：

E:\WorkSpace\01_编程语言\01_C语言\exp_26>gcc exp_26.c



E:\WorkSpace\01_编程语言\01_C语言\exp_26>a

value of a: 123

     代码其实很简单，第一次对a进行的数值修改其实是一个没用的冗余代码。如果发现类似的问题，可能进行一下简单的屏蔽，修改代码如下：

#include"stdio.h"



int main(void)

{

       int a = 0;



       //a += 5; \

       a = 123;



       printf("value of a: %d\n",a);



       return 0;

}

       代码的编译运行结果如下：

E:\WorkSpace\01_编程语言\01_C语言\exp_26>gcc exp_26.c



E:\WorkSpace\01_编程语言\01_C语言\exp_26>a

value of a: 0

       这个结果很多时候会出乎很多人的意料，因为发现结果居然不再是123！其实，原因就在于屏蔽的那一行代码最后面多了一个续行的符号。这样使得注释的作用持续到了下一行。其实，很多编译器在这方面都会有相对精准的判断给出提示，比如说我最近在使用的VIM就能够通过颜色的变化提示出第二行也被注释掉了。而擅长语义分析的Source Insight在这方面倒是没有做好，不知道最新推出的V4版本中是否对此有所改进。

示例2：

#include"stdio.h"



int main(void)

{

       int a = 123;

       int b = 23;

       int c;



       c = a //*

                     //*/b

       ;



       printf("value of c:%d",c);



       return 0;

}

       从《C专家编程》中摘出了这个例子，按照书中的介绍，c的赋值运算相关3行在C语言中表示a/b而在C++中表示a。不过，或许是成书时间比较早，自我我的机器以及软件上，这个说法显然是不成立了。即使是咋C语言中，上面的表达式也是表示c = a。不过，程序的可读性确实是给了我们一个不小的挑战。我专门注意了一下编辑器对此的识别，在此环节中，VIM以及Source Insight全都识别准确。值得一提的是，前面的这两个例子如果使用NotePad ++，编辑器的提示也全都是准确的。

       代码的编译执行结果如下;

E:\WorkSpace\01_编程语言\01_C语言\exp_27>gcc exp_27.c



E:\WorkSpace\01_编程语言\01_C语言\exp_27>a

value of c:123

       由此看来，很多嵌入式的编码规范中要求不能够用C++单行注释风格的注释方式还是有一定道理的。虽说是带来了一定的不方便，但是确实是能够避免一些小问题的出现。



