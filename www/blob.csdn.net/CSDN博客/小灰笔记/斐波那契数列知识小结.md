# 斐波那契数列知识小结 - 小灰笔记 - CSDN博客





2017年01月02日 22:44:47[grey_csdn](https://me.csdn.net/grey_csdn)阅读数：536











之前学习Python的时候第一次认真学习了一下斐波那契数列，也是我第一次认真研究了一下编程语言的基础知识。今天依然从Python入手吧，先把之前完成的斐波那契数列函数实现一下。

代码如下：

  1 #!/usr/bin/python

  2 

  3 defFib(n):

  4 if n==0or
 n ==1:

  5 return1

  6 else:

  7 return Fib(n -1) + Fib(n -2)

  8 




程序的执行结果如下：




>>> from fib import *

>>> Fib(1)

1

>>> Fib(2)

2

>>> Fib(3)

3

>>> Fib(10)

89

>>> Fib(24)

75025




按照Mooler老爷子的教程，斐波那契数列跟黄金分割是有一定的关联的。这部分我个人理解起来觉得略微复杂深奥了一点，捡一点自己能够看懂的大致描述应该为：

1,黄金分割求解时采用的迭代语句为 p = p + q的形式；

2,斐波那契数列求解采用的迭代语句为 f(k) = f(k -1) + f(k -2)；

3,黄金分割求解可以采用无穷连分式表示（略）；

如果取Phi为黄金分割连分式的前n项阶段结果，那么Phi = f(n) + f(n -1)，在极限条件下，连续斐波那契数的比值趋近于黄金分割。看结果勉强能够看懂，但是如何通过推导或者是逻辑运算找出斐波那契与黄金分割的关系我个人觉得还是一个比较难的问题。或者说，我自己是毫无头绪。

这里做一个简单的验证吧！

由于之前我简单的做过斐波那契的程序编写与运行，我知道这个递归的层级是有限的。不过为了能够更能够贴近趋近于无穷大时候的效果，开始我选择了两个相对大一点的迭代结果，99与100。简单输入进行计算，计算机运行了漫长的时间还没有给出计算的结果，只好放弃。重新选择了39与40这两个迭代计算结果来做测试：




>>> fib_40 = Fib(40)

>>> fib_39 = Fib(39)

>>> fib_40

165580141

>>> fib_39

102334155

>>> float(fib_40)/float(fib_39)

1.618033988749895




最终的城市结果跟黄金分割的结果确实是比较相近。这个算法描述用MATLAB实现起来也没有什么太大的差异，计算的效率上也一样。不过，采用以下方式实现的MATLAB算法在计算上的效率可谓是“神算”级别。像Fib(100)这样的结果基本上也是瞬间就完成计算，按照教程中的说法，这种运算用到了MATLAB的矩阵运算，因此，虽说在代码形式上比不上递归的方式优雅，但是效率确实得到了大大的提升。




  1 function f = fibonacci(n)

  2 % fibonacci array

  3 % f = fibonacci(n)

  4 f=zeros(n,1);

  5 f(1) =1;f(2)
 =2;

  6 for k =3:n

  7     f(k) = f(k-1)+
 f(k -2);

  8 end




在我看来，这两种方式似乎也没有太大的差异，除了后面这种计算每次的计算结果都以矩阵的形式进行了保存。似乎差异在于，前面的n次以矩阵形式保存的时候只会进行一次运算。使用Python能不能达到这种效果呢？如果使用列表的话似乎困难一些，或许还是得求助于numpy了。回头有时间还是得在numpy上花点时间，毕竟这个包成就了那么多的python包，甚至也在一定程度上成就了python。



