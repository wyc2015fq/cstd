# numpy中的数组切片 - 小灰笔记 - CSDN博客





2017年03月31日 00:27:13[grey_csdn](https://me.csdn.net/grey_csdn)阅读数：1477








       如同python中自带的切片，numpy中也有类似的切片功能。接下来对两个功能进行一下简单的对比。

       首先测试Python自带的功能，在shell窗口中测试如下：

In [1]: data =range(10)



In [2]: data

Out[2]: [0, 1, 2,3, 4, 5, 6, 7, 8, 9]



In [3]: data1 =data[3:7]



In [4]: data1

Out[4]: [3, 4, 5,6]



In [5]: data1[2] =123



In [6]: data1

Out[6]: [3, 4,123, 6]



In [7]: data

Out[7]: [0, 1, 2,3, 4, 5, 6, 7, 8, 9]



In [8]: data[5]=  234



In [9]: data

Out[9]: [0, 1, 2,3, 4, 234, 6, 7, 8, 9]



In [10]: data1

Out[10]: [3, 4,123, 6]

       通过上面的结果可以看出，源数据不会影响切片出来的数据，而切片出来的对象也不会影响源数据。如此看来，切片出来的数据是被复制后重新创建出来的。

       接下来再看一下numpy：

In [11]: data =range(10)



In [12]: data

Out[12]: [0, 1, 2,3, 4, 5, 6, 7, 8, 9]



In [13]: importnumpy as np



In [14]: data

Out[14]: [0, 1, 2,3, 4, 5, 6, 7, 8, 9]



In [15]: np_arr1 =np.array(data)



In [16]: np_arr1

Out[16]: array([0,1, 2, 3, 4, 5, 6, 7, 8, 9])



In [17]: np_arr2 =np_arr1[2:7]



In [18]: np_a

np_arr1 np_arr2



In [18]: np_arr2

Out[18]: array([2,3, 4, 5, 6])



In [19]:np_arr2[1] = 123



In [20]: np_arr2

Out[20]:array([  2, 123,   4,  5,   6])



In [21]: np_arr1

Out[21]:array([  0,   1,  2, 123,   4,   5,  6,   7,   8,  9])



In [22]:np_arr1[5] = 432



In [23]: np_arr1

Out[23]:array([  0,   1,  2, 123,   4, 432,   6,  7,   8,   9])



In [24]: np_arr2

Out[24]:array([  2, 123,   4, 432,  6])

       从上面的结果可以看出，切片后生成的对象可以影响到原来的数据，而原来的数据也可以影响切片后的对象。由此可见，numpy中处理的数据位于同一块内存存储区域之中。而numpy很多时候适用于处理大数据的，而大数据的处理经常进行变动或者进行数据复制创建对计算机硬件的消耗是十分大的。而这也是numpy在处理上的一点独到之处，通过独特的数据结构保证大数据的处理效率。



