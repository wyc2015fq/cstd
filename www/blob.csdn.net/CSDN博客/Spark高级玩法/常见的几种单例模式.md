# 常见的几种单例模式 - Spark高级玩法 - CSDN博客
2018年06月15日 07:18:50[Spark高级玩法](https://me.csdn.net/rlnLo2pNEfx9c)阅读数：150
![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/adI0ApTVBFWhAq0HTOjIF6peFE8P2sYtXLiazPeBDwfw11O3S9qIC3N7T67S5v8EDbwBp8PFLgibMR9pxcicqkzUA/640?wx_fmt=png)
**单例模式：**是一种常用的软件设计模式，在它的核心结构中值包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象实例。
　　对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；售票时，一共有100张票，可有有多个窗口同时售票，但需要保证不要超售（这里的票数余量就是单例，售票涉及到多线程）。如果不是用机制对窗口对象进行唯一化将弹出多个窗口，如果这些窗口显示的都是相同的内容，重复创建就会浪费资源。
**应用场景**（来源：《大话设计模式》）：
　　　　需求：在前端创建工具箱窗口，工具箱要么不出现，出现也只出现一个
　　　　遇到问题：每次点击菜单都会重复创建“工具箱”窗口。
　　　　解决方案一：使用if语句，在每次创建对象的时候首先进行判断是否为null，如果为null再创建对象。
　　　　需求：如果在5个地方需要实例出工具箱窗体
　　　　遇到问题：这个小bug需要改动5个地方，并且代码重复，代码利用率低
　　　　解决方案二：利用单例模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。
　　通过以下几种方式，我们会发现，**所有的单例模式都是使用静态方法进行创建的**，所以**单例对象在内存中静态共享区中存储**。（可参考：https://zhidao.baidu.com/question/2206072272164938188.html）
**单例模式可以分为懒汉式和饿汉式**：
　　　　懒汉式单例模式：在类加载时不初始化。
　　　　饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。
**第一种（懒汉，线程不安全）:**
publicclass SingletonDemo1 {    privatestatic SingletonDemo1 instance;    private SingletonDemo1(){}    publicstatic SingletonDemo1 getInstance(){        if (instance == null) {
            instance = new SingletonDemo1();
        }        return instance;
    }
}
这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。　
**第二种（懒汉，线程安全）：**
publicclass SingletonDemo2 {    privatestatic SingletonDemo2 instance;    private SingletonDemo2(){}    publicstaticsynchronized SingletonDemo2 getInstance(){        if (instance == null) {
            instance = new SingletonDemo2();
        }        return instance;
    }
}
这种写法在getInstance()方法中加入了synchronized锁。能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是效率很低（因为锁），并且大多数情况下不需要同步。
**第三种（饿汉）：**
publicclass SingletonDemo3 {privatestatic SingletonDemo3 instance = new SingletonDemo3();    private SingletonDemo3(){}    publicstatic SingletonDemo3 getInstance(){        return instance;
    }
}
这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，这时候初始化instance显然没有达到lazy loading的效果。
**第四种（**饿**汉，变种）：**
publicclass SingletonDemo4 {    privatestatic SingletonDemo4 instance = null;    static{
        instance = new SingletonDemo4();
    }    private SingletonDemo4(){}    publicstatic SingletonDemo4 getInstance(){        return instance;
    }
}
表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance
**    第五种（静态内部类）：**
publicclass SingletonDemo5 {    privatestaticclass SingletonHolder{        privatestaticfinal SingletonDemo5 instance = new SingletonDemo5();
    }    private SingletonDemo5(){}    publicstaticfinal SingletonDemo5 getInsatance(){        return SingletonHolder.instance;
    }
}
这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方法就显得更合理。
**第六种（枚举）：**
publicenum SingletonDemo6 {
    instance;    publicvoid whateverMethod(){
    }
}
这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。
**第七种（双重校验锁）：**
publicclass SingletonDemo7 {    privatevolatilestatic SingletonDemo7 singletonDemo7;    private SingletonDemo7(){}    publicstatic SingletonDemo7 getSingletonDemo7(){        if (singletonDemo7 == null) {            synchronized (SingletonDemo7.class) {                if (singletonDemo7 == null) {
                    singletonDemo7 = new SingletonDemo7();
                }
            }
        }        return singletonDemo7;
    }
}
这个是第二种方式的升级版，俗称双重检查锁定，详细介绍请查看：http://www.ibm.com/developerworks/cn/java/j-dcl.html
在JDK1.5之后，双重检查锁定才能够正常达到单例效果。
**多线程时的单例**，多线程的程序中，多个线程同时访问该单例，会有可能创建多个实例。这个时候就需要用“锁”将它锁起来。包括锁、死锁、锁之间的通信，关于多线程这部分待后续详解！
参考：http://cantellow.iteye.com/blog/838473
**推荐阅读：**
1，[深入了解Redis内存模型](http://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&mid=2247484935&idx=1&sn=ea9c00d74b899b4088699d7a28b53ab7&chksm=9f38e52fa84f6c39e446e8d08f4bf144b99017c7fa03a61436604b8b2af66a4cbc4acfbec018&scene=21#wechat_redirect)
2，[spark源码系列之累加器实现机制及自定义累加器](http://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&mid=2247484934&idx=1&sn=e44a26a92cc9fc085eb4693665de86d5&chksm=9f38e52ea84f6c38ab71d5359fca7cf4f2f21e6b56ade28164bf76d7574651faafe3be6a5633&scene=21#wechat_redirect)
3，[干货 ：基于用户画像的聚类分析](http://mp.weixin.qq.com/s?__biz=MzA3MDY0NTMxOQ==&mid=2247484928&idx=1&sn=93e3f93431af050af3ce4b34c5f9e760&chksm=9f38e528a84f6c3efe0920e8f010c2c7edf27f5bc7271f2ac86827ae0e0f5b485b0f9da2a4dd&scene=21#wechat_redirect)
![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/adI0ApTVBFWF1rkKibTzeA8PicbicYXBsH26a9PXg2HNnlEt1thHBFxUtEjicACeaSlRWictpPziaMdibXmYq34dWfQ9w/640?wx_fmt=png)
