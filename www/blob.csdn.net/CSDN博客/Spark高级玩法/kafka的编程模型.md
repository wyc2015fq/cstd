# kafka的编程模型 - Spark高级玩法 - CSDN博客
2018年05月27日 00:02:13[Spark高级玩法](https://me.csdn.net/rlnLo2pNEfx9c)阅读数：524
1.kafka消费者编程模型
分区消费模型
组(group)消费模型
# 1.1.分区消费模型
1.1.1.分区消费架构图，每个分区对应一个消费者。
1.1.2.分区消费模型伪代码描述
指定偏移量，用于从上次消费的地方开始消费.
提交offset ，java客户端会自动提交的集群，所以这一步可选。
# 1.2.组(group)消费模型
1.2.1.组消费模型架构图
每个组都消费该topic的全量数据,一条消息会发给groupA和groupB.
1.2.2.组消费模型伪代码：
流数N：表示一个consumer组里面有几个consumer 实例，上例中组A创建2个流，组B创建4个流。
1.2.3.consumer分配算法
当kafka的分区个数大于组A里consumer实例个数时，怎么去分配，以下为分配步骤：
# 1.3.两种消费模型对比
Partition消费模型更加灵活但是：
（1）需要自己处理各种异常情况；
（2）需要自己管理offset(以实现消息传递的其他语义)；
Group消费模型更加简单，但是不灵活：
（1）不需要自己处理异常情况，不需要自己管理offset；
（2）只能实现kafka默认的最少一次消息传递语义；
知识补充：消息传递的3中语义：
至少一次，(消息不会丢,消息者至少得到一次，但有可能会重复，生产者向消费者发送之后，会等待消费者确认，没收到确认会再发) (kafka 默认实现的语义)。
至多一次，(消息会丢)
有且只有一次。
# 1.4.java 客户端参数调优
fetchSize: 从服务器获取单包大小;
bufferSize: kafka客户端缓冲区大小;
group.id: 分组消费时分组名 (指定的每个组将获得全量的数据)
# 2.生产者消费模型
同步生产模型
异步生产模型
# 2.1. 同步生产模型
至少成功一次 ， 发送给kafka消费者
# 2.2.异步生产模型
打包发送给kafka broker。
# 2.3.两种生产模型伪代码描述
main()
创建到kafka broker的连接:KafkaClient(host,port)
选择或者自定义生产者负载均衡算法 partitioner (算法有：hash，轮询，随机)
设置生产者参数 (缓存队列长度，发送时间,同步/异步参数设置)
根据负载均衡算法和设置的生产者参数构造Producer对象
while True
getMessage：从上游获得一条消息
按照kafka要求的消息格式构造kafka消息
根据分区算法得到分区
发送消息
处理异常
# 2.4.两种生产模型对比
同步生产模型:
（1）低消息丢失率；
（2）高消息重复率(由于网络原因，回复确认未收到)；
（3）高延迟 (每发一条消息需要确认)
(使用在不丢消息场景)
异步生产模型:
（1）低延迟;
（2）高发送性能；（每秒一个分区发50万条）
（3）高消息丢失率(无确认机制，发送端队列满了，消息会丢掉;整个队列发送给)
(使用在允许丢消息场景，偶尔丢一条)
# 2.5.java客户端代码实现 （自定义分区）
//同步配置参数：
默认的序列化方式：字节序列化。
设定分区算法:默认是对key进行hash分区算法，可以自定义分区算法。
确认机制 request.require.acks： 合理设置为1; 0: 绝不等确认 1: leader的一个副本收到这条消息，并发回确认 -1： leader的所有副本都收到这条消息，并发回确认
消息是以key-value的形式发送的，key必须要设置。
# 2.6.java客户端参数调优
message.send.max.retries: 发送失败重试次数;
retry.backoff.ms :未接到确认，认为发送失败的时间;
producer.type: 同步发送或者异步发送；
batch.num.messages: 异步发送时，累计最大消息数；
queue.buffering.max.ms:异步发送时，累计最大时间；
本文版本主要是针对0.8.2，配套学习教程，浪尖已经分享到了知识星球。
