# 小话设计模式（十六）中介者模式 - 凯奥斯的注释 - CSDN博客





2016年10月03日 13:20:36[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：1152标签：[Design Pattern																[设计模式																[Meditator																[中介者																[分布](https://so.csdn.net/so/search/s.do?q=分布&t=blog)
个人分类：[设计模式](https://blog.csdn.net/ecidevilin/article/category/6414912)

所属专栏：[小话设计模式](https://blog.csdn.net/column/details/12906.html)](https://so.csdn.net/so/search/s.do?q=中介者&t=blog)




中介者（Mediator）模式用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

以下情况适合使用中介者模式：

1、一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。

2、一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。

3、想定制一个分布在多个类中的行为，而又不想生成太多的子类。




我们可以认为游戏中的寄售商店是一种中介者模式的具体应用，玩家可以在寄售商店里寄售商品，而其他玩家可以购买这些被寄售的商品，寄售商店会把卖出货物的钱转交给寄售者。这样就避免了玩家之间的交互，玩家就不用太关心怎么与其他玩家交易，需要东西的时候，只需要去寄售商店看一看就行了。

本文就以寄售商店为例，寄售商店的定义：



```
public class Consignment
{
	private Dictionary<string, Player> _goods = new Dictionary<string, Player> (); 
	public void Consign(Player player, string obj)
	{
		_goods [obj] = player;
	}
	public void Buy(Player player, string obj)
	{
		if (_goods.ContainsKey (obj)) {
			_goods [obj].GainCoins (10);
			_goods [obj] = null;
			player.LoseCoins (10);
		}
	}
}
```

为了简化代码，这里我们限定每一种商品只能有一个玩家寄售。
玩家的定义：


```
public class Player
{
	Consignment _consignment;
	string _name;
	public Player(string name,Consignment mediator)
	{
		_consignment = mediator;
		_name = name;
	}
	public void GainCoins(int amount)
	{
		//TODO:
		Console.WriteLine(_name + " gain " + amount + " coins.");
	}
	public void LoseCoins(int amount)
	{
		//TODO:
		Console.WriteLine(_name + " lose " + amount + " coins.");
	}
	public void Buy(string obj)
	{
		_consignment.Buy (this, obj);
	}
	public void Consign(string obj)
	{
		_consignment.Consign (this, obj);
	}
}
```

使用：


```
Consignment consignment = new Consignment ();
		Player phox = new Player ("phox", consignment);
		Player cycl = new Player ("cycl", consignment);
		Player iman = new Player ("iman", consignment);
		Player stor = new Player ("stor", consignment);
		phox.Consign ("glasses");
		cycl.Buy ("glasses");
		iman.Consign ("ice");
		stor.Buy ("ice");
```


中介者模式的优点：
1、减少了子类的生成，将分布于多个对象间的行为集中在一起，如果希望改变行为，只需要创建中介者（Meditator）的子类即可，而无需修改同事（Colleague）类。

2、使得同事类之间解耦，同事类之间不必关心彼此如何交互，只需要调用中介者的方法即可。

3、将对象之间如何协作进行了抽象。

4、简化了对象协议，由多对多的交互，转换成一对多的交互，更易于理解维护和扩展。

5、控制集中化，将对象之间交互的复杂性转变为中介者的复杂性。

然而控制集中化也正是中介者的最大的缺点，这样可能会导致中介者变得过于复杂，而难于维护。](https://so.csdn.net/so/search/s.do?q=Meditator&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)](https://so.csdn.net/so/search/s.do?q=Design Pattern&t=blog)




