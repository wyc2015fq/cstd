# 小话设计模式（十）外观模式 - 凯奥斯的注释 - CSDN博客





2016年09月30日 13:33:59[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：1682
所属专栏：[小话设计模式](https://blog.csdn.net/column/details/12906.html)









# 外观（Fascade）模式定义一个高级的接口，将子系统里的一组接口整合起来，提供了一个统一的外观。

在以下情况下可以考虑使用外观模式：

(1)设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。

(2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。

(3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。




举个例子，我们要实现游戏里挂机的功能，在几张地图之间冒险，将掉落的物品卖掉，然后当玩家HP小于一定值的时候，去医院治疗。

首先，游戏里已经定义了玩家类（这里用一个简化的单例类表示，完整单例的写法参考[小话设计模式（一）单例模式](http://blog.csdn.net/ecidevilin/article/details/52595044)）：



```
public class Player
{
	static Player _player = null;
	private Player()
	{
		HP = 100;
	}
	public static Player GetInstance()
	{
		if (_player == null) {
			_player = new Player ();
		}
		return _player;
	}
	public int HP { get; set;}
	public int Coins{ get; set;}
}
```


然后是冒险、当铺和医院，为了方便示例，我们把它们都简化成静态类：



```
public static class Adventure
{
	public static string Explore(int mapId)
	{
		Console.WriteLine ("Explore the map " + mapId);
		Player.GetInstance ().HP -= 10;
		return "stone";
	}
}

public static class PawnShop
{
	public static void Sell(string stuffName)
	{
		Console.WriteLine ("Sell the stuff "+ stuffName);
		Player.GetInstance ().Coins += 10;
	}
}

public static class Hospital
{
	public static void Heal()
	{
		Player player = Player.GetInstance ();
		if (player.Coins >= 20) {
			Console.WriteLine ("Player is recovered");
			Player.GetInstance ().Coins -= 20;
			Player.GetInstance ().HP += 50;
		}
	}
}
```

那么如何完成一个挂机的接口？这里我们使用外观模式：


```
public static class HookFascade
{
	public static void StartToHook(int mapIdStart, int mapIdEnd)
	{
		if (mapIdStart > mapIdEnd) {
			return;
		}
		for (int i = mapIdStart; i <= mapIdEnd; i++) {
			string drop = Adventure.Explore (i);
			PawnShop.Sell (drop);
			if (Player.GetInstance ().HP <= 30) {
				Hospital.Heal ();
			}
		}
	}
}
```

这样我们就完成了一个挂机的功能，使用：

`		HookFascade.StartToHook (1, 10);`

其实我们只做了一件事情，就是把本来写在客户端里的挂机逻辑整合成了一个类的方法。但是使得具体的挂机逻辑对用户透明，实现了用户与Player、Adventure等类之间的松耦合关系。当我们调整挂机逻辑的时候（例如增加了一个召唤兽，或者有些掉落要卖掉而有些不卖），就不需要修改用户的代码。当然缺点也很明显，就是限制了用户的发挥空间。



