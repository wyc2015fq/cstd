# 土圭垚㙓数学课（二）视锥体八个顶点的计算方法 - 凯奥斯的注释 - CSDN博客





2017年09月07日 21:02:49[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：1951
所属专栏：[土圭垚㙓数学课](https://blog.csdn.net/column/details/17239.html)









视锥体是摄像机可见的空间，看上去像截掉顶部的金字塔。视锥体由6个裁剪面围成，构成视锥体的4个侧面称为上左下右面，分别对应屏幕的四个边界。为了防止物体离摄像机过近，设置近切面，同时为了防止物体离摄像机太远而不可见，设置远切面。本文将介绍一下视锥体八个顶点的计算方法。

![](https://img-blog.csdn.net/20170907205314594)


我们就以Unity3D（5.6.0f3）为例。

首先取fov（[fieldOfView](https://docs.unity3d.com/560/Documentation/ScriptReference/Camera-fieldOfView.html)），即摄像机在竖直方向上的张角。


`float fov = Camera.main.fieldOfView;`还有aspect，也就是屏幕的宽高比。



`float asp = Camera.main.aspect;`
然后计算获得一个yf参数，用来表示视锥体的上下侧面与xz平面的偏移量。



`float yf = Mathf.Tan(fov/2 * Mathf.Deg2Rad);`

为什么要除以2？因为我们知道fov是摄像机在竖直方向上的张角，也就是说以xz平面为中心，上下各有fov/2的角度。


然后计算一下xf参数，同理，用来表示视锥体的左右侧面与yz平面的偏移量。


`float xf = yf * asp;`
然后是视锥体四个侧边（也就是不在近平面或原平面上的边）的方向向量。




```
Vector3 f0 = Camera.main.transform.forward - Camera.main.transform.right * xf - Camera.main.transform.up * yf;
Vector3 f1 = Camera.main.transform.forward - Camera.main.transform.right * xf + Camera.main.transform.up * yf;
Vector3 f2 = Camera.main.transform.forward + Camera.main.transform.right * xf - Camera.main.transform.up * yf;
Vector3 f3 = Camera.main.transform.forward + Camera.main.transform.right * xf + Camera.main.transform.up * yf;
```

（他们不是单位向量哦！）

之所以列出这四个向量，是因为他们有时候会特别有用，比如说计算视锥体与一个平面的相交多边形。

需要注意的是这里计算的是世界空间的向量，所以要使用Camera的forward，right和up来计算。既然这么说了，你一定想到了另外一种写法。



```
Matrix4x4 l2w = Camera.main.transform.localToWorldMatrix;
Vector3 f0 = l2w * new Vector3(-xf,-yf,1);
Vector3 f1 = l2w * new Vector3(-xf, yf,1);
Vector3 f2 = l2w * new Vector3( xf,-yf,1);
Vector3 f3 = l2w * new Vector3( xf, yf,1);
```

最后计算出八个顶点：




```
float fcp = Camera.main.farClipPlane;
float ncp = Camera.main.nearClipPlane;
Vector3 cpt = Camera.main.transform.position;
```

```
Vector3 farLeftBottom = cpt + fcp * f0;
Vector3 farLeftTop = cpt + fcp * f1;
Vector3 farRightBotoom = cpt + fcp*f2;
Vector3 farRightTop = cpt + fcp * f3;
```

```
Vector3 nearLeftBottom = cpt + ncp * f0;
Vector3 nearLeftTop = cpt + ncp * f1;
Vector3 nearRightBotoom = cpt + ncp*f2;
Vector3 nearRightTop = cpt + ncp * f3;
```

~~额~完整代码自己拼好吗？亲们？~~






