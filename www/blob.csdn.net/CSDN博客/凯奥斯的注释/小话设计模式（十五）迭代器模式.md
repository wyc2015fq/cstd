# 小话设计模式（十五）迭代器模式 - 凯奥斯的注释 - CSDN博客





2016年10月03日 10:03:55[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：1155
所属专栏：[小话设计模式](https://blog.csdn.net/column/details/12906.html)









# 迭代器（Iterator）模式，又称游标（Cursor）模式，它提供了一种方法，可以顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

虽然C#已经在内部实现了迭代器模式，我们可以使用foreach in很方便的遍历容器中的元素。但是，这样并不该影响我们对Iterator的学习。

本文就实现游戏里的仓库的迭代器作为示例。

仓库定义：



```
public class Inventory
{
	private List<object> _items = new List<object>();
	public object this[int index]
	{
		get { return _items [index];}
		set { _items.Insert (index, value);}
	}
	public int Count
	{
		get { return _items.Count;}
	}
}
```

这里使用了索引器this，用于索引_items（可以参考[C#语法小知识（六）属性与索引器](http://blog.csdn.net/ecidevilin/article/details/52525080)）。
我们再来定义一个迭代器的抽象类：



```
public abstract class Iterator
{
	public abstract object First ();
	public abstract object Next();
	public abstract bool IsDone ();
	public abstract object Current();
}
```
声明了First,IsDone,Next,Current四个方法，如果你熟悉c++里的容器，你可以知道这四个方法分别对应c++迭代器里的begin,end,++,*这些方法或者操作符（operator），虽然具体实现不尽相同，但是功能是对应的。
接着我们实现一个继承自Iterator的派生类，用于遍历仓库：



```
public class InventoryIterator : Iterator
{
	private int _current = 0;
	private Inventory _inventory;
	public InventoryIterator(Inventory inventory)
	{
		_inventory = inventory;
	}
	public override object First()
	{
		_current = 0;
		return _inventory [0];
	}
	public override object Next()
	{
		_current++;
		if (_current < _inventory.Count) {
			return _inventory [_current];
		}
		return null;
	}
	public override bool IsDone()
	{
		return _current >= _inventory.Count;
	}
	public override object Current()
	{
		if (_current < _inventory.Count)
		{
			return _inventory [_current];
		}
		return null;
	}
}
```

使用：


```
Inventory inventory = new Inventory ();
		inventory[0] = "stone";
		inventory[1] = "twig";
		inventory[2] = "log";
		inventory[3] = "carrot";
		InventoryIterator iter = new InventoryIterator (inventory);
		for (iter.First (); !iter.IsDone(); iter.Next ()) {
			Console.WriteLine (iter.Current ());
		}
```

这样我们就完成了对仓库的遍历。



当然我们也可以是实现c#风格的枚举器（IEnumerator）：



```
public class InventoryEnumerator : IEnumerator
{
	private int _current = -1;
	private Inventory _inventory;
	public InventoryEnumerator(Inventory inventory)
	{
		_inventory = inventory;
	}
	public object Current
	{
		get {
			return _inventory [_current];
		}
	}
	public bool MoveNext()
	{
		_current++;
		return _current < _inventory.Count;
	}
	public void Reset()
	{
		_current = -1;
	}
}
```

需要为Inventory添加继承IEnumerable接口，并实现：


```
IEnumerator _enumerator;
	public IEnumerator GetEnumerator()
	{
		if (_enumerator == null) {
			_enumerator = new InventoryEnumerator (this);
		}
		_enumerator.Reset ();
		return _enumerator;
	}
```
（其实还有一种实现方法，就是由InventoryEnumerator来继承IEnumerable，GetEnumerator方法里调用Reset并返回this，与上面的实现各有好处）
这样就可以使用foreach来遍历仓库了：



```
foreach (object obj in inventory) {
			Console.WriteLine (obj);
		}
```



迭代器的优点：

1、支持以不同的方式遍历一个聚合。例如上面的例子我们可以按照从后往前遍历，或者按照字母排序遍历。

2、简化了聚合的接口，聚合本身不再需要实现遍历的接口，而把这些遍历方法放在了类型的外部，由迭代器实现。这样也符合了开闭原则，当需要扩展一个遍历方法的时候，不需要修改被遍历类型的代码。

3、可以同时进行多个遍历。

缺点：

聚合类型需要为迭代器实现额外的接口，而这些接口是公开的（对于C++来讲，一般将迭代器作为友元），这样可能会破坏封装性。



