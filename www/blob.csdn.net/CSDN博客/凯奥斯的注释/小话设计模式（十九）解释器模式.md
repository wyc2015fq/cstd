# 小话设计模式（十九）解释器模式 - 凯奥斯的注释 - CSDN博客





2016年10月04日 19:39:38[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：1078
所属专栏：[小话设计模式](https://blog.csdn.net/column/details/12906.html)









# 解释器（Interpreter）给定一个语言，定义它的文法的一种表示，并且定义一个解释器，这个解释器使用该表示来解释语言中的句子。

很多脚本语言例如Lua、Ruby、Python都是解释器的一种应用。

解释器里可以分为TerminalExpression（终结符表达式）和NonterminalExpression（非终结符表达式），他们都可以用于解释语句。其中NonterminalExpression是聚合的类型，他可以包含一个或者多个终结符表达式或者非终结符表达式。

举一个例子，假设我们在游戏中开放了一种文本命令，可以控制角色的行走。

角色定义如下：



```
public class Player
{
	public int PosX {get; private set;}
	public int PosY {get; private set;}
	public void MoveLeft()
	{
		PosX--;
	}
	public void MoveRight()
	{
		PosX++;
	}
	public void MoveUp()
	{
		PosY++;
	}
	public void MoveDown()
	{
		PosY--;
	}

	public void Attack()
	{
		Console.WriteLine("Attack");
	}

	private static Player _player = new Player ();
	public static Player Instance
	{
		get {
			return _player;
		}
	}
	private Player()
	{
	}
}
```


这里将Player定义成一种简式的单例类（参考[小话设计模式（一）单例模式](http://blog.csdn.net/ecidevilin/article/details/52595044)），方便调用。Player对象可以上下左右移动，并且可以攻击。

上下文定义：



```
public class PlayerContext
{
	public string Text {get;set;}
}
```

用以保存语句，方便解释器解析。
定义一个抽象的表达式类：



```
public abstract class Expression
{
	public static void Interpret(PlayerContext context)
	{
		if (context.Text.Length == 0) {
			return;
		}
		string expStr = context.Text.Split (';')[0];
		string[] strs = expStr.Split (' ');
		string cmd = strs [0];
		string prm = null;
		if (strs.Length > 1) {
			prm = strs [1];
		}
		Expression exp = null;
		switch (cmd) {
		case "Move":
			exp = new MoveExpression ();
			break;
		case "Hit":
			exp = new HitExpression ();
			break;
		}
		if (exp != null) {
			exp.Execute (prm);
		}
		context.Text = context.Text.Remove (0, expStr.Length + 1);
	}
	public abstract void Execute (string prm);
}
```


为了方便使用，我们定义了一个静态方法用以生成对应的表达式对象，这里是类似于简单工厂的实现方法。


实现两个终结符表达式类：



```
public class MoveExpression : Expression
{
	public override void Execute(string prm)
	{
		switch (prm) {
		case "Left":
			Player.Instance.MoveLeft ();
			break;
		case "Right":
			Player.Instance.MoveRight ();
			break;
		case "Up":
			Player.Instance.MoveUp ();
			break;
		case "Down":
			Player.Instance.MoveDown ();
			break;
		}
	}
}

public class HitExpression : Expression
{
	public override void Execute(string prm)
	{
		Player.Instance.Attack ();
	}
}
```
我们也可以实现一个非终结符表达式，它包含了HitExpression和MoveExpression：


```
public class HitAndRunExpression : Expression
{
	private HitExpression _hitExp = new HitExpression();
	private MoveExpression _moveExp = new MoveExpression();
	public override void Execute(string prm)
	{
		_hitExp.Execute (prm);
		_moveExp.Execute (prm);
	}
}
```

需要在Expression的Interpret方法的switch语句里添加：


```
case "Hit&Run":
			exp = new HitAndRunExpression ();
			break;
```

使用：


```
PlayerContext context = new PlayerContext ();
		context.Text = "Move Up;Move Right;Hit&Run Down;";
		while (context.Text.Length > 0) {
			MoveExpression.Interpret (context);
		}
		Console.WriteLine (Player.Instance.PosX);
		Console.WriteLine (Player.Instance.PosY);
```



解释器模式的好处：
1、易于改变和扩展文法。

2、易于实现文法。

缺点：

1、如果文法过于复杂，那么维护和管理这些文法可能会变得很困难。

2、解释执行的效率不会很高。



