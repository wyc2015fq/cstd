# 小话设计模式（二十一）策略模式 - 凯奥斯的注释 - CSDN博客





2016年10月05日 10:43:51[凯奥斯](https://me.csdn.net/ecidevilin)阅读数：913
所属专栏：[小话设计模式](https://blog.csdn.net/column/details/12906.html)









# 策略（Strategy）模式，又称政策（Policy）模式。它定义了一系列算法，将它们一个个封装起来，并且使它们可以相互替换，使得算法可以独立于使用它的用户而变化。

策略模式适用于以下情况：

1、许多相关的类只是行为不同。

2、需要使用一个算法的不同变体。

3、一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。

举个例子，游戏中有多个英雄，每个英雄具有三个属性：力量、敏捷和智力，英雄类型也分为这三种。对于每种类型的英雄，它们都有不同的攻击力算法。

算法接口：



```
public interface IAttackStrategy
{
	int CalculateAttack (Hero hero);
}
```

英雄类型枚举定义：


```
public enum HeroType
{
	Strength,
	Agility,
	Intelligence,
}
```
英雄定义：


```
public class Hero
{
	public int strength {get; private set;}
	public int agility {get; private set;}
	public int intelligence { get; private set;}
	public HeroType heroType {get; private set;}
	private IAttackStrategy _strategy;
	public Hero(int Str, int Agi, int Int, HeroType type)
	{
		strength = Str;
		agility = Agi;
		intelligence = Int;
		ChangeHeroType (type);
	}
	public int CalculateAttack()
	{
		return _strategy.CalculateAttack (this);
	}
	public void ChangeHeroType(HeroType type)
	{
		heroType = type;
		_strategy = StrategyFactory.CreateStrategy (type);
	}
}
```

在构造函数的参数里传入英雄的力量、敏捷、智力和类型，并开放了ChangeHeroType方法用来改变英雄类型（可能会有这样的需求：某些英雄可以变身成其他类型的英雄），以及计算攻击力的方法CalculateAttack。
而StrategyFactory是一个享元工厂（参考[小话设计模式（十一）享元模式](http://blog.csdn.net/ecidevilin/article/details/52717925)），保证所有英雄共用一套算法对象，不会增加额外的对象。具体实现：



```
public static class StrategyFactory
{
	private static Dictionary<HeroType, IAttackStrategy> _strategies = new Dictionary<HeroType, IAttackStrategy>();
	public static IAttackStrategy CreateStrategy(HeroType type)
	{
		if (!_strategies.ContainsKey(type))
		{
			IAttackStrategy ret = null;
			switch (type)
			{
			case HeroType.Strength:
				ret = new StrengthStrategy();
				break;
			case HeroType.Agility:
				ret = new AgilityStrategy();
				break;
			case HeroType.Intelligence:
				ret = new IntelligenceStrategy();
				break;
			}
			_strategies[type] = ret;
		}
		return _strategies[type];
	}
}
```
最后是三个策略类的实现：


```
public class StrengthStrategy : IAttackStrategy
{
	public int CalculateAttack (Hero hero)
	{
		return hero.strength;
	}
}

public class AgilityStrategy : IAttackStrategy
{
	public int CalculateAttack (Hero hero)
	{
		return hero.agility;
	}
}

public class IntelligenceStrategy : IAttackStrategy
{
	public int CalculateAttack (Hero hero)
	{
		return hero.intelligence;
	}
}
```

我们也可以独立的更改策略类的算法，例如智力英雄的攻击力是智力的两倍，或者敏捷英雄的攻击力再额外加上力量的十分之一。再或者我们也可以增加一个算法，例如某个英雄的攻击力会随着血量的下降而增加。而这些改变并不会影响其他的策略类以及上下文Context（本例中的Hero）。
使用：



```
Hero hero = new Hero (5, 2, 10, HeroType.Intelligence);
		Console.WriteLine (hero.CalculateAttack ());
		hero.ChangeHeroType (HeroType.Agility);
		Console.WriteLine (hero.CalculateAttack ());
```



策略模式的优点：

1、定义了一系列可供重用的算法或行为。

2、相对于继承，易于切换、易于理解、易于扩展。

3、消除了一些条件语句。

4、提供了相同行为的不同实现。

不足：

1、用户需要了解Strategy之间的不同。

2、增加了Strategy与Context的通信开销，并且使得二者变得紧耦合。

3、增加了对象的数目（本文示例使用享元模式减轻了这个问题，但是并不一定所有情况下都可以使用享元模式）。






