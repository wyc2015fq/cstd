# hdu2084——数塔 - westbrook1998的博客 - CSDN博客





2018年05月13日 12:38:48[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：23标签：[动态规划																[水题](https://so.csdn.net/so/search/s.do?q=水题&t=blog)](https://so.csdn.net/so/search/s.do?q=动态规划&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：  

  有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？  

  已经告诉你了，这是个DP的题目，你能AC吗? 

  Input 

  输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。  

  Output 

  对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。  

  Sample Input 

  1 

  5 

  7 

  3 8 

  8 1 0  

  2 7 4 4 

  4 5 2 6 5 

  Sample Output 

  30
一道特别简单的dp…却因为自己的脑残wa了两次…一次是没有重新初始化dp数组，一次是输入的for循环居然写成了i<=5…我也是服了我自己

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=105;
int n;
int dp[MAXN][MAXN];
int main(void){
    int t;
    scanf("%d",&t);
    while(t--){
        memset(dp,0,sizeof(dp));
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                scanf("%d",&dp[i][j]);
            }
        }
        for(int i=n-1;i>0;i--){
            for(int j=1;j<=i;j++){
                dp[i][j]+=max(dp[i+1][j],dp[i+1][j+1]);
            }
        }
        printf("%d\n",dp[1][1]);
    }
    return 0;
}
```






