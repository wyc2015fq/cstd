# 牛客练习赛30D——消消乐 - westbrook1998的博客 - CSDN博客





2018年11月03日 20:58:54[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：67








比赛的时候不会做…

然后今天才得知是一道原题，一道二分图最小覆盖点的模板题…

为什么大佬什么算法都会，什么题都做过…
代码：

```
#include <bits/stdc++.h>
using namespace std;
const int N=100050;
const int M=100050;
int n,m;
char s[N];
struct Edge{
    int v,next;
}edge[M];
int cnt,head[N];
void init(){
    cnt=0;
    memset(head,-1,sizeof(head));
}
void addEdge(int u,int v){
    edge[cnt]=Edge{v,head[u]};
    head[u]=cnt++;
}
//Left表示右边点集的左边匹配点
int Left[N],Right[N];
bool T[N],S[N];
bool dfs(int u){
    S[u]=true;
    for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].v;
        if(!T[v]){
            T[v]=true;
            if(Left[v]==-1 || dfs(Left[v])){
                Left[v]=u;
                Right[u]=v;
                return true;
            }
        }
    }
    return false;
}
int hungary(){
    int res=0;
    memset(Left,-1,sizeof(Left));
    memset(Right,-1,sizeof(Right));
    for(int u=1;u<=n;u++){
        memset(T,false,sizeof(T));
        if(dfs(u)){
            res++;
        }
    }
    return res;
}
vector<int> X,Y;
void solve(){
    memset(S,0,sizeof(S));
    memset(T,0,sizeof(T));
    for(int u=1;u<=n;u++){
        if(Right[u]==-1){
            dfs(u);
        }
    }
    for(int u=1;u<=n;u++){
        if(!S[u]){
            X.push_back(u);
        }
    }
    for(int v=1;v<=m;v++){
        if(T[v]){
            Y.push_back(v);
        }
    }
}
int main(void){
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        for(int j=1;j<=m;j++){
            if(s[j]=='*'){
                addEdge(i,j);
            }
        }
    }
    int ans=hungary();
    solve();
    printf("%d\n",ans);
    printf("%d",X.size());
    for(int i=0;i<X.size();i++){
        printf(" %d",X[i]);
    }
    printf("\n");
    printf("%d",Y.size());
    for(int i=0;i<Y.size();i++){
        printf(" %d",Y[i]);
    }
    printf("\n");
    return 0;
}
```




