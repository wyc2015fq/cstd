# 牛客练习赛24A——石子阵列 - westbrook1998的博客 - CSDN博客





2018年08月10日 21:18:15[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：121








> 
链接：[https://www.nowcoder.com/acm/contest/157/A](https://www.nowcoder.com/acm/contest/157/A)

  来源：牛客网 

  题目描述  

  xb有m种石子，每种无限个，Ta想从这些石子中取出n个，并按顺序排列起来，为了好看，相邻的石子不能相同。xb想知道有多少种排列的方法。 

  输入描述: 

  第一行有两个正整数n，m。 

  输出描述: 

  第一行一个整数，表示在m种石子中取出n个的排列方案数模1000000007后的值。 

  示例1 

  输入 

  复制 

  1 1 

  输出 

  复制 

  1 

  示例2 

  输入 

  复制 

  2 3 

  输出 

  复制 

  6 

  示例3 

  输入 

  复制 

  3 3 

  输出 

  复制 

  12 

  备注: 

  对于100%的测试数据： 

  1 ≤ n, m ≤ 1000 

  数据量较大，注意使用更快的输入输出方式。
果然是递推，感觉很熟悉就写出来了 

考虑第`i`个的前两个，比如AB 那么这第i个分两种情况，如果和第`i-2` 个相同，即只有一种选择就是A，如果不与`i-2` 相同，那就应该和`i-1`和`i-2` 都不同，所以有`(m-2)` 种可能，所以递推公式就是 
`a[i]=a[i-1]*(m-1)`
代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
long long dp[1020];
int main(void){
    int n,m;
    scanf("%d%d",&n,&m);
    dp[1]=m;
    for(int i=2;i<=n;i++){
        dp[i]=(dp[i-1]*(m-1))%1000000007;
    }
    printf("%lld\n",dp[n]);
}
```






