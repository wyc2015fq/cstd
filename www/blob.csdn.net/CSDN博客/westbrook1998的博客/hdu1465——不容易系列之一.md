# hdu1465——不容易系列之一 - westbrook1998的博客 - CSDN博客





2018年06月18日 22:44:36[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：50








> 
大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了！  

  做好“一件”事情尚且不易，若想永远成功而总从不失败，那更是难上加难了，就像花钱总是比挣钱容易的道理一样。  

  话虽这样说，我还是要告诉大家，要想失败到一定程度也是不容易的。比如，我高中的时候，就有一个神奇的女生，在英语考试的时候，竟然把40个单项选择题全部做错了！大家都学过概率论，应该知道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一句经典的评语，我们可以这样总结：一个人做错一道选择题并不难，难的是全部做错，一个不对。  

  不幸的是，这种小概率事件又发生了，而且就在我们身边：  

  事情是这样的——HDU有个网名叫做8006的男性同学，结交网友无数，最近该同学玩起了浪漫，同时给n个网友每人写了一封信，这都没什么，要命的是，他竟然把所有的信都装错了信封！注意了，是全部装错哟！  

  现在的问题是：请大家帮可怜的8006同学计算一下，一共有多少种可能的错误方式呢？ 

  Input 

  输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正整数n`（1<n<=20）`，n表示8006的网友的人数。 

  Output 

  对于每行输入请输出可能的错误方式的数量，每个实例的输出占用一行。 

  Sample Input 

  2 

  3 

  Sample Output 

  1 

  2
很明显的一道错位排序的问题 于是想到了离散课本的那个公式 结果因为double精确度有限 WA了 百度查了一下发现还有一个递推公式 Get了 

```
a[1]=0 a[2]=1 

a[i]=(i-1)*(a[i-1]+a[i-2])
```


要好好记起来
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
long long a[25];
void Init(){
    a[1]=0;
    a[2]=1;
    for(int i=3;i<=21;i++){
        a[i]=(i-1)*(a[i-1]+a[i-2]);
    }
}
int main(void){
    Init();
    int n;
    while(~scanf("%d",&n)){
        printf("%lld\n",a[n]);
    }
    return 0;
}
```






