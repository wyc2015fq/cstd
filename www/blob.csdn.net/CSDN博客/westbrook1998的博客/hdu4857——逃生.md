# hdu4857——逃生 - westbrook1998的博客 - CSDN博客





2018年08月13日 13:20:04[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：49








> 
糟糕的事情发生啦，现在大家都忙着逃命。但是逃命的通道很窄，大家只能排成一行。  

  现在有n个人，从1标号到n。同时有一些奇怪的约束条件，每个都形如：a必须在b之前。  

  同时，社会是不平等的，这些人有的穷有的富。1号最富，2号第二富，以此类推。有钱人就贿赂负责人，所以他们有一些好处。  

  负责人现在可以安排大家排队的顺序，由于收了好处，所以他要让1号尽量靠前，如果此时还有多种情况，就再让2号尽量靠前，如果还有多种情况，就让3号尽量靠前，以此类推。  

  那么你就要安排大家的顺序。我们保证一定有解。 

  Input 

  第一行一个整数T(1 <= T <= 5),表示测试数据的个数。  

  然后对于每个测试数据，第一行有两个整数n(1 <= n <= 30000)和m(1 <= m <= 100000)，分别表示人数和约束的个数。  

  然后m行，每行两个整数a和b，表示有一个约束a号必须在b号之前。a和b必然不同。 

  Output 

  对每个测试数据，输出一行排队的顺序，用空格隔开。 

  Sample Input 

  1 

  5 10 

  3 5 

  1 4 

  2 5 

  1 2 

  3 4 

  1 4 

  2 3 

  1 5 

  3 5 

  1 2 

  Sample Output 

  1 2 3 4 5
拓扑排序的问题 但是有了一个条件，就是比如如果1和2之间没有声明特殊的先后关系的话，那么1一定要在2前面，以此类推 

看了网上的题解，发现要反向建图，拓扑排序（优先队列优先级要改变）之后逆向输出

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN=30050;
int topo[MAXN];
int indegree[MAXN];
vector<int> g[MAXN];
int n,m;
int t;
int a,b;
void init(){
    memset(topo,0,sizeof(topo));
    memset(indegree,0,sizeof(topo));
    for(int i=0;i<MAXN;i++){
        g[i].clear();
    }
}
void toposort(){
    int idx=0;
    //反向建图的拓扑排序，这里优先级也要改变
    //举个例子 图：3->1 2  这个如果按正向拓扑 得到的是2 3 1但是这是不满足条件的 题目要求1在2的前面 正确应该是3 1 2
    //正向 第一次队列压入的是3 2 然后取出是2 3最后加入1  所以结果是2 3 1
    //反向 第一次队列压入的是1 2 然后取出是2 1最后加入3  所以结果是2 1 3
    priority_queue<int> que;
    for(int i=1;i<=n;i++){
        if(indegree[i]==0){
            que.push(i);
        }
    }
    while(!que.empty()){
        int tmp=que.top();
        que.pop();
        indegree[tmp]=-1;
        topo[idx++]=tmp;
        int len=g[tmp].size();
        for(int i=0;i<len;i++){
            indegree[g[tmp][i]]--;
            if(indegree[g[tmp][i]]==0){
                que.push(g[tmp][i]);
            }
        }
    }
}
int main(void){
    //freopen("data.txt","r",stdin);
    int t;
    scanf("%d",&t);
    while(t--){
        init();
        scanf("%d%d",&n,&m);
        while(m--){
            scanf("%d%d",&a,&b);
            g[b].push_back(a);
            indegree[a]++;
        }
        toposort();
        //逆序输出
        for(int i=n-1;i>0;i--){
            printf("%d ",topo[i]);
        }
        printf("%d\n",topo[0]);
    }
    return 0;
}
```





