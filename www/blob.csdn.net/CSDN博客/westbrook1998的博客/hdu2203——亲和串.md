# hdu2203——亲和串 - westbrook1998的博客 - CSDN博客





2018年06月24日 13:20:41[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：37标签：[字符串																[KMP](https://so.csdn.net/so/search/s.do?q=KMP&t=blog)](https://so.csdn.net/so/search/s.do?q=字符串&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
问题Eddy也一直在思考，因为他在很小的时候就知道亲和串如何判断了，但是发现，现在长大了却不知道怎么去判断亲和串了，于是他只好又再一次来请教聪明且乐于助人的你来解决这个问题。  

  亲和串的定义是这样的：给定两个字符串s1和s2,如果能通过s1循环移位，使s2包含在s1中，那么我们就说s2 是s1的亲和串。  

  Input 

  本题有多组测试数据，每组数据的第一行包含输入字符串s1,第二行包含输入字符串s2，s1与s2的长度均小于100000。  

  Output 

  如果s2是s1的亲和串，则输出”yes”，反之，输出”no”。每组测试的输出占一行。  

  Sample Input 

  AABCD 

  CDAA 

  ASD 

  ASDF 

  Sample Output 

  yes 

  no
kmp的匹配…kmp还是不怎么理解 思路知道 但是不知道为什么代码那么写。。。。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=100050;
//next[i]表示从0到i这段字符串中最大的相同前后缀字符数
int Next[MAXN];
char s1[MAXN*2];
char s2[MAXN];
void kmp_pre(char pat[],int Next[]){
    int l=strlen(pat);
    int i=0;
    //next数组下标默认从1开始
    //j表示前面字符串前后缀相同的字符个数
    int j=Next[0]=-1;
    //模式字符串遍历一遍
    while(i<l){
        //printf("i=%d j=%d\n",i,j);
        while(-1!=j && pat[i]!=pat[j]){
            //j回到前面
            j=Next[j];
            //printf("next_j:%d\n",j);
        }
        Next[++i]=++j;
    }
}
int kmp_search(char pat[],char str[]){
    int i=0;
    int j=0;
    int m=strlen(str);
    int n=strlen(pat);
    kmp_pre(pat,Next);
    //边界约束
    while(i<m && j<n){
        if(j==-1 || str[i]==pat[j]){
            i++;
            j++;
        }
        else{
            j=Next[j];
        }
    }
    if(j==n){
        return i-n;
    }
    else{
        return -1;
    }
}
int main(void){
    while(~scanf("%s",s1)){
        scanf("%s",s2);
        int l=strlen(s1);
        for(int i=0;i<l;i++){
            s1[l+i]=s1[i];
        }
        int res=kmp_search(s2,s1);
        if(res==-1){
            printf("no\n");
        }
        else{
            printf("yes\n");
        }
    }
    return 0;
}
```






