# hdu1874——畅通工程续 - westbrook1998的博客 - CSDN博客





2018年08月07日 09:55:44[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：102








> 
某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。  

  现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 

  Input 

  本题目包含多组数据，请处理到文件结束。  

  每组数据第一行包含两个正整数N和M`(0<N<200,0<M<1000)`，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。  

  接下来是M行道路信息。每一行有三个整数A,B,X`(0<=A,B<N,A!=B,0<X<10000)`,表示城镇A和城镇B之间有一条长度为X的双向道路。  

  再接下一行有两个整数S,T`(0<=S,T<N)`，分别代表起点和终点。 

  Output 

  对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.  

  Sample Input 

  3 3 

  0 1 1 

  0 2 3 

  1 2 1 

  0 2 

  3 1 

  0 1 1 

  1 2 

  Sample Output 

  2 

  -1
最短路 

还是没注意输入时重边的判断 

直接用floyd
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int N,M;
const int MAXN=205;
const int INF=0x3f3f3f3f;
int d[MAXN][MAXN];
int a,b,x;
void floyd(){
    for(int k=0;k<N;k++){
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
            }
        }
    }
}
int main(void){
    while(~scanf("%d%d",&N,&M)){
        memset(d,INF,sizeof(d));
        for(int i=0;i<N;i++){
            d[i][i]=0;
        }
        while(M--){
            scanf("%d%d%d",&a,&b,&x);
            if(x<d[a][b]){
                d[a][b]=d[b][a]=x;
            }
        }
        floyd();
        int s,e;
        scanf("%d%d",&s,&e);
        if(d[s][e]!=INF){
            printf("%d\n",d[s][e]);
        }
        else{
            printf("-1\n");
        }
    }
    return 0;
}
```






