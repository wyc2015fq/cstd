# hdu2896——病毒侵袭 - westbrook1998的博客 - CSDN博客





2018年08月26日 19:46:48[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：39








> 
当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~  

  但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。  

  万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~  

  Input 

  第一行，一个整数N（1<=N<=500），表示病毒特征码的个数。  

  接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。  

  每个病毒都有一个编号，依此为1—N。  

  不同编号的病毒特征码不会相同。  

  在这之后一行，有一个整数M（1<=M<=1000），表示网站数。  

  接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。  

  每个网站都有一个编号，依此为1—M。  

  以上字符串中字符都是ASCII码可见字符（不包括回车）。  

  Output 

  依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。  

  web 网站编号: 病毒编号 病毒编号 …  

  冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。  

  最后一行输出统计信息，如下格式  

  total: 带病毒网站数  

  冒号后有一个空格。  

  Sample Input 

  3 

  aaa 

  bbb 

  ccc 

  2 

  aaabbbccc 

  bbaacc 

  Sample Output 

  web 1: 1 2 3 

  total: 1
也是ac自动机多模式匹配的题目 

坑了好久 

到最后我也不知道改了什么了 

反正就是莫名其妙的wa 莫名其妙的ac
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <set>
using namespace std;
set<int> res;
char w[205];
char s[10005];
struct Node{
    int cnt;
    Node* fail;
    Node* Next[100];
    Node(){
        cnt=0;
        fail=NULL;
        for(int i=0;i<100;i++){
            Next[i]=NULL;
        }
    }
};
Node* root;
int k=1;
void insert(char* s){
    int l=strlen(s);
    int val;
    Node* p=root;
    for(int i=0;i<l;i++){
        val=s[i]-31;
        if(p->Next[val]==NULL){
            p->Next[val]=new Node();
        }
        p=p->Next[val];
    }
    p->cnt=k++;
}
void getFail(){
    queue<Node*> q;
    for(int i=0;i<100;i++){
        if(root->Next[i]!=NULL){
            root->Next[i]->fail=root;
            q.push(root->Next[i]);
        }
    }
    while(!q.empty()){
        Node* t=q.front();
        q.pop();
        for(int i=0;i<100;i++){
            if(t->Next[i]!=NULL){
                Node* p=t->fail;
                while(p!=NULL){
                    if(p->Next[i]!=NULL){
                        t->Next[i]->fail=p->Next[i];
                        break;
                    }
                    p=p->fail;
                }
                if(p==NULL){
                    t->Next[i]->fail=root;
                }
                q.push(t->Next[i]);
            }
        }
    }
}
void search(char* s){
    res.clear();
    if(root==NULL){
        return;
    }
    int l=strlen(s);
    Node* p=root;
    int val;
    for(int i=0;i<l;i++){
        val=s[i]-31;
        while(!p->Next[val] && p!=root){
            p=p->fail;
        }
        p=p->Next[val];
        if(!p){
            p=root;
        }
        Node* tmp=p;
        while(tmp!=root){
            if(tmp->cnt>0){
                res.insert(tmp->cnt);
            }
            else{
                break;
            }
            tmp=tmp->fail;
        }
    }
}
void clear(Node* &root){
    if(root==NULL){
        return;
    }
    for(int i=0;i<100;i++){
        clear(root->Next[i]);
    }
    root->fail=NULL;
    delete(root);
}
int main(void){
    //freopen("data.txt","r",stdin);
    int n,m;
    root=new Node();
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%s",w);
        insert(w);
    }
    getFail();
    scanf("%d",&m);
    int tol=0;
    for(int i=0;i<m;i++){
        scanf("%s",s);
        search(s);
        if(res.size()>0){
            tol++;
            printf("web %d:",i+1);
            for(set<int>::iterator it=res.begin();it!=res.end();it++){
                printf(" %d",*it);
            }
            printf("\n");
        }
    }
    printf("total: %d\n",tol);
    clear(root);
    return 0;
}
```






