# hdu2066——一个人的旅行 - westbrook1998的博客 - CSDN博客





2018年05月19日 15:59:02[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：37








> 
虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。 

  Input 

  输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；  

  接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=<(a,b)<=1000;a,b 之间可能有多条路)  

  接着的第T+1行有S个数，表示和草儿家相连的城市；  

  接着的第T+2行有D个数，表示草儿想去地方。 

  Output 

  输出草儿能去某个喜欢的城市的最短时间。 

  Sample Input 

  6 2 3 

  1 3 5 

  1 4 7 

  2 8 12 

  3 8 4 

  4 9 12 

  9 10 2 

  1 2 

  8 9 10 

  Sample Output 

  9
最短路问题，这里使用Floyd 但是要小优化一下以及注意一些细节

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=1050;
const int INF=1000050;
int m[MAXN][MAXN];
int S[MAXN];
int D[MAXN];
int main(void){
    int t,s,d;
    int u,v,c;
    int ma=0;
    while(~scanf("%d%d%d",&t,&s,&d)){
        //初始化，注意i==j要初始化为0 节点到本身的距离为0
        for(int i=0;i<MAXN;i++){
            for(int j=0;j<=MAXN;j++){
                if(i==j){
                    m[i][j]=0;
                }
                else{
                    m[i][j]=INF;
                }
            }
        }
        for(int i=0;i<t;i++){
            scanf("%d%d%d",&u,&v,&c);
            //记录最大节点
            ma=max(ma,max(u,v));
            if(c<m[u][v]){
                m[u][v]=m[v][u]=c;
            }
        }
        for(int i=0;i<s;i++){
            scanf("%d",&S[i]);
        }
        for(int i=0;i<d;i++){
            scanf("%d",&D[i]);
        }
        for(int k=1;k<=ma;k++){
            for(int i=1;i<=ma;i++){
                //这里优化，如果i k无通路，省去一个循环
                if(m[i][k]==INF){
                    continue;
                }
                for(int j=1;j<=ma;j++){
                    m[i][j]=min(m[i][j],m[i][k]+m[k][j]);
                }
            }
        }
        int mcost=INF;
        for(int i=0;i<s;i++){
            for(int j=0;j<d;j++){
                mcost=min(mcost,m[S[i]][D[j]]);
            }
        }
        printf("%d\n",mcost);
    }
    return 0;
}
```

这道题其实也可以用Dijkstra, 将起点看为节点0, 然后到临近的城市距离为0, 直接用一次Dijkstra, 哎不熟练导致很多细节没做好，WA了好几次

代码:

```
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=1050;
const int INF=100000050;
int vis[MAXN];
int cost[MAXN][MAXN];
int lowcost[MAXN];
int D[MAXN];
int u,v,c,sa;
int main(void){
    int t,s,d;
    while(~scanf("%d%d%d",&t,&s,&d)){
        for(int i=0;i<MAXN;i++){
            lowcost[i]=INF;
            vis[i]=false;
            for(int j=0;j<MAXN;j++){
                if(i==j){
                    cost[i][j]=0;
                }
                cost[i][j]=INF;
            }
        }
        lowcost[0]=0;
        int ma;
        for(int i=0;i<t;i++){
            scanf("%d%d%d",&u,&v,&c);
            ma=max(ma,max(u,v));
            if(c<cost[u][v]){
                cost[u][v]=cost[v][u]=c;
            }
        }
        for(int i=0;i<s;i++){
            scanf("%d",&sa);
            cost[0][sa]=cost[sa][0]=0;
            lowcost[sa]=0;
        }
        for(int i=0;i<d;i++){
            scanf("%d",&D[i]);
        }
        for(int i=0;i<=ma;i++){
            int k=-1;
            int MIN=INF;
            for(int j=0;j<=ma;j++){
                if(!vis[j] && lowcost[j]<MIN){
                    MIN=lowcost[j];
                    k=j;
                }
            }
            if(k==-1){
                break;
            }
            vis[k]=true;
            for(int j=0;j<=ma;j++){
                if(!vis[j] && lowcost[k]+cost[k][j]<lowcost[j]){
                    lowcost[j]=lowcost[k]+cost[k][j];
                }
            }
        }
        /*
        for(int i=0;i<=ma;i++){
            printf("%d ",lowcost[i]);
        }
        printf("\n");
        */
        int ans=INF;
        for(int i=0;i<d;i++){
            ans=min(ans,lowcost[D[i]]);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```





