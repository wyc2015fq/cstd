# 泛型数组列表的子类型通配符 和父类型通配符 - westbrook1998的博客 - CSDN博客





2018年03月22日 12:56:23[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：84标签：[java																[泛型																[泛型列表																[通配符](https://so.csdn.net/so/search/s.do?q=通配符&t=blog)
个人分类：[java](https://blog.csdn.net/westbrook1998/article/category/7459913)





**?是java泛型中的通配符,它代表java中的`某一个类`,那么`<? extends T>`就代表类型T的某个子类,`<? super T>`就代表类型T的某个父类**

首先定义五个类，继承关系如下

```php
class Thing{}
class Food extends Thing{}
class Fruit extends Food{}
class Apple extends Fruit{}
class BigApple extends Apple{}
```

先使用子类型通配符`<? extends 父类>`

```
public class SonGenericsTest {

    public static void main(String[] args){

        ArrayList<? extends Fruit> fruits=new ArrayList<>();
        //fruits.add(new Food());
        //fruits.add(new Fruit());
        //fruits.add(new Apple());
    }
}
```

显然，编译就直接出错，原因是这里的？ 代表的是Fruit的一个子类，但是却无法确定具体是那个类，因此，无法调用`add`方法，或者说只能`add(null);`

虽然不能`add`，但是却可以`get`，如

```
public class SonGenericsTest {

    public static void main(String[] args){

        ArrayList<? extends Fruit> fruits=new ArrayList<>();
        fruits.add(null);
        Fruit f=fruits.get(0);
    }
}
```

因为`get`的返回值是一个`？ extend 父类` 的对象，即Fruit类的子类，所以无论什么类型，都可以赋给`Fruit`型引用变量（多态）

相反，对于`< ? super 子类 >`来说

```
public class SonGenericsTest {

    public static void main(String[] args){

        ArrayList<? super Fruit> fruits=new ArrayList<>();
        //fruits.add(new Food());
        fruits.add(new Fruit());
        fruits.add(new Apple());
    }
}
```

我们发现，列表可以添加`Fruit`或者`Fruit的子类`，但不可以添加`Fruit的父类`，这里也许会觉得奇怪，`?  super Fruit`不就是代表`Fruit的父类`吗，为什么不能添加呢，其实仔细考虑一下，在存入`Fruit子类`的时候，实际上是进行了隐性的类型转换——`子类转父类`，即 
`fruits.add(new Apple());`

实际上是 
`fruits.add((Fruit)new Apple());`

而至于为什么不能存入`Fruit父类`，道理和`< ? extend 父类>`的差不多，因为无法确定具体是哪一个父类 

显然，`< ? super 子类 >`可以`add`，却不可以`get`，或者说只能用`Object`引用对象来接收获取的对象
```
public class SonGenericsTest {

    public static void main(String[] args){

        ArrayList<? super Fruit> fruits=new ArrayList<>();
        fruits.add(new Fruit());
        fruits.add(new Apple());
        //Fruit f=fruits.get(0);
        Object o=fruits.get(0);
    }
}
```

这里看似很矛盾，其实要记住一个原则**`列表中存放同一种类型对象`**，所以，对于`< ? super Fruit >`列表，你要存入的是`Fruit`的父类，**但是**，你无法保证你存入同一个类型的父类，有可能中间插入一个父父类，编译器也无法确定，所以阻止了这种行为，而只能以存入`Fruit子类`然后隐性转成`Fruit`类再存入列表，然后，在取出的时候，只能将列表中对象转成公共的父类`Object`再取出，但这样会丢失特定类的类型信息

**PECS（Producer Extends Consumer Super）原则**

1. 频繁往外读取内容的，适合用上界Extends。 

2. 经常往里插入的，适合用下界Super。
基本就是这样，这是现学习阶段的简单理解](https://so.csdn.net/so/search/s.do?q=泛型列表&t=blog)](https://so.csdn.net/so/search/s.do?q=泛型&t=blog)](https://so.csdn.net/so/search/s.do?q=java&t=blog)




