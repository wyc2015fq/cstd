# hdu1272——小希的迷宫 - westbrook1998的博客 - CSDN博客





2018年08月17日 19:13:17[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：27标签：[并查集](https://so.csdn.net/so/search/s.do?q=并查集&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。  
![这里写图片描述](https://odzkskevi.qnssl.com/ce3d27d9f95d7ac87d47240232e2e0ba?v=1534469822)

  Input 

  输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。  

  整个文件以两个-1结尾。  

  Output 

  对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。  

  Sample Input 

  6 8  5 3  5 2  6 4 

  5 6  0 0 

  8 1  7 3  6 2  8 9  7 5 

  7 4  7 8  7 6  0 0 

  3 8  6 8  6 4 

  5 3  5 6  5 2  0 0 

  -1 -1 

  Sample Output 

  Yes 

  Yes 

  No
昨天题目没看清，今天看懂了 就是用并查集判断是否有环和是否是单个集合

代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <set>
using namespace std;
const int N=100050;
int uf[N];
int a,b;
int r[N];
int find(int x){
    return uf[x]==x ? x : uf[x]=find(uf[x]);
}
void join(int a,int b){
    int fa=find(a);
    int fb=find(b);
    if(fa!=fb){
        if(r[fa]<r[fb]){
            uf[fa]=fb;
            r[fb]=max(r[fb],r[fa]+1);
        }
        else{
            uf[fb]=fa;
            r[fa]=max(r[fa],r[fb]+1);
        }
    }
}
int main(void){
    //freopen("data.txt","r",stdin);
    int a,b;
    while(~scanf("%d%d",&a,&b)){
        bool flag=false;
        if(a==0 && b==0){
            printf("Yes\n");
            continue;
        }
        set<int> p;
        p.insert(a);
        p.insert(b);
        for(int i=1;i<N;i++){
            uf[i]=i;
            r[i]=1;
        }
        if(a==-1 && b==-1){
            break;
        }
        join(a,b);
        while(scanf("%d%d",&a,&b) && (a || b)){
            p.insert(a);
            p.insert(b);
            //判断是否成环
            if(find(a)!=find(b)){
                join(a,b);
            }
            else{
                flag=1;
            }
        }
        //判断是否连通
        int cnt=0;
        for(set<int>::iterator it=p.begin();it!=p.end();it++){
            if(uf[*it]==*it){
                cnt++;
                if(cnt>1){
                    flag=true;
                    break;
                }
            }
        }
        if(flag){
            printf("No\n");
        }
        else{
            printf("Yes\n");
        }
    }
    return 0;
}
```





