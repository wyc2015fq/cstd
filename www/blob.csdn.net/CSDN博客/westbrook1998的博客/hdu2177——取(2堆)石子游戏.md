# hdu2177——取(2堆)石子游戏 - westbrook1998的博客 - CSDN博客





2018年09月02日 22:16:51[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：33标签：[博弈论](https://so.csdn.net/so/search/s.do?q=博弈论&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取子?  

  Input 

  输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000，且a<=b。a=b=0退出。  

  Output 

  输出也有若干行，如果最后你是败者，则为0，反之，输出1，并输出使你胜的你第1次取石子后剩下的两堆石子的数量x,y,x<=y。如果在任意的一堆中取走石子能胜同时在两堆中同时取走相同数量的石子也能胜，先输出取走相同数量的石子的情况.  

  Sample Input 

  1 2  

  5 8 

  4 7 

  2 2 

  0 0 

  Sample Output 

  0 

  1 

  4 7 

  3 5 

  0 

  1 

  0 0 

  1 2
whythoff博弈的模板题然后加个枚举第一步先手操作再判断

代码：

```
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int main(void){
    int a,b;
    while(~scanf("%d%d",&a,&b)){
        if(a==0 && b==0){
            break;
        }
        if(a>b){
            swap(a,b);
        }
        if(a==floor((b-a)*(sqrt(5.0)+1)/2)){
            printf("0\n");
        }
        else{
            printf("1\n");
            int ta=a;
            int tb=b;
            while(ta-- && tb--){
                //printf("---%d %d\n",ta,tb);
                if(ta==floor((tb-ta)*(sqrt(5.0)+1)/2)){
                    printf("%d %d\n",ta,tb);
                }
            }
            ta=a;
            tb=b;
            while(tb--){
                //printf("--%d %d\n",ta,tb);
                //printf("%d\n",min(ta,tb)==floor((max(ta,tb)-min(ta,tb))*(sqrt(5.0)+1)/2));
                if(min(ta,tb)==floor((max(ta,tb)-min(ta,tb))*(sqrt(5.0)+1)/2)){
                    //printf("zheli\n");
                    printf("%d %d\n",min(ta,tb),max(ta,tb));
                }
            }
        }
    }
    return 0;
}
```





