# hdu2544——最短路 - westbrook1998的博客 - CSDN博客





2018年05月10日 16:20:14[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：41








> 
在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ 


Input 

输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。  

输入保证至少存在1条商店到赛场的路线。  

Output 

对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 

Sample Input 

2 1 

1 2 3 

3 3 

1 2 5 

2 3 5 

3 1 2 

0 0 

Sample Output 

3 

2
这是一道最短路的典型例题，刚好用来联系一下最近学的dijkstra，结果果然练出不少问题出来…

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=1010;
const int INF=0x3f3f3f3f;
bool vis[MAXN];
int cost[MAXN][MAXN];
int lowcost[MAXN];
void Dijkstra(int cost[][MAXN],int lowcost[],int n,int beg){
    for(int i=1;i<=n;i++){
        lowcost[i]=INF;
        vis[i]=false;
    }    
    lowcost[beg]=0;
    for(int j=1;j<=n;j++){
        int k=0;
        int Min=INF;
        for(int i=1;i<=n;i++){
            if(!vis[i] && lowcost[i]<Min){
                Min=lowcost[i];
                k=i;
            }
        }
        if(k==0){
            break;
        }
        vis[k]=true;
        for(int i=1;i<=n;i++){
            //printf("%d %d %d\n",lowcost[k]+cost[k][i]<lowcost[i],lowcost[k]+cost[k][i],lowcost[i]);
            if(!vis[i] && lowcost[k]+cost[k][i]<lowcost[i]){
                lowcost[i]=lowcost[k]+cost[k][i];
            }
        }
    }
}
int main(void){
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        if(n==0 && m==0){
            break;
        }
        //这里要把不相连的节点的cost初始化为INF
        //如果默认为0，会导致后面求最短路出错
        memset(cost,INF,sizeof(cost));
        for(int i=0;i<m;i++){
            int u,v,c;
            scanf("%d%d%d",&u,&v,&c);
            cost[u][v]=c;
            cost[v][u]=c;
        }
        Dijkstra(cost,lowcost,n,1);
        printf("%d\n",lowcost[n]);
    }
    return 0;
}
```

注意要把cost数组初始化为INF，然后就是dijkstra模板了，要多加练习




