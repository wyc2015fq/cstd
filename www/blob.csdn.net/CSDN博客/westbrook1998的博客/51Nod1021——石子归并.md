# 51Nod1021——石子归并 - westbrook1998的博客 - CSDN博客





2018年06月08日 17:07:14[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：93








> 
N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。 

  例如： 1 2 3 4，有不少合并方法 

  1 2 3 4 => 3 3 4(3) => 6 4(9) => 10(19) 

  1 2 3 4 => 1 5 4(5) => 1 9(14) => 10(24) 

  1 2 3 4 => 1 2 7(7) => 3 7(10) => 10(20) 

  括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。 

  Input 

  第1行：N（2 <= N <= 100)  

  第2 - N + 1：N堆石子的数量（1 <= Ai <= 10000) 

  Output 

  输出最小合并代价 

  Sample Input 

  4 

  1 

  2 

  3 

  4 

  Sample Output 

  19
经典的区间dp，要好好背起来 

代码：

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
int n;
int sum[105];
int dp[105][105];
const int INF=0x3f3f3f3f;
int main()
{
   while(scanf("%d",&n)!=EOF)
   {
       memset(dp,0,sizeof(dp));
        memset(sum,0,sizeof(sum));
       int x;
       for(int i=1;i<=n;i++)
       {
           scanf("%d",&x);
           sum[i]=sum[i-1]+x;
       }
       //len表示区间的长度 比如左端点i=1 len=2那么右端点就是1+2-1=2 区间长度就为2
       for(int len=2;len<=n;len++)
       {
           //i为左端点 i+len-1就是右端点 不能越界
           for(int i=1;i+len-1<=n;i++)
           {
               //初始化为INF 保证min函数起作用
               //因为要更新的就是这个区间的值
               dp[i][i+len-1]=INF;
               //k表示区间截断的点
               //从左端点到右端点依次枚举
               for(int k=i;k<=i+len-1;k++)
               {
                   dp[i][i+len-1]=min(dp[i][i+len-1],dp[i][k]+dp[k+1][i+len-1]+sum[i+len-1]-sum[i-1]);
               }
           }
           }
       printf("%d\n",dp[1][n]);
   }
    return 0;
}
```





