# hdu2044——一只小蜜蜂... - westbrook1998的博客 - CSDN博客





2018年07月22日 16:56:02[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：24标签：[递归](https://so.csdn.net/so/search/s.do?q=递归&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。  

  其中，蜂房的结构如下所示。  
![这里写图片描述](https://odzkskevi.qnssl.com/db4917bb4b1bd4e9ccc285a9597f8e31?v=1532202360)

  Input 

  输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b`(0<a<b<50)`。  

  Output 

  对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。  

  Sample Input 

  2 

  1 2 

  3 6 

  Sample Output 

  1 

  3
递推练习 
`arr[i][j]`表示j到i的道路数量

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
long long arr[55][55];
void Init(){
    for(int i=1;i<=50;i++){
        for(int j=i;j>0;j--){
            if(i==j){
                arr[i][j]=0;
            }
            else if(j==i-1){
                arr[i][j]=1;
            }
            else if(j==i-2){
                arr[i][j]=arr[i][j+1]+1;
            }
            else{
                arr[i][j]=arr[i][j+1]+arr[i][j+2];
            }
        }
    }
}
int main(void){
    memset(arr,-1,sizeof(arr));
    Init();
    int t,a,b;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&a,&b);
        printf("%lld\n",arr[b][a]);
    }
    return 0;
}
```





