# hdu3790——最短路径问题 - westbrook1998的博客 - CSDN博客





2018年08月04日 00:07:46[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：34标签：[最短路																[Dijkstra](https://so.csdn.net/so/search/s.do?q=Dijkstra&t=blog)](https://so.csdn.net/so/search/s.do?q=最短路&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 

  Input 

  输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。  
`(1<n<=1000, 0<m<100000, s != t)`

  Output 

  输出 一行有两个数， 最短距离及其花费。 

  Sample Input 

  3 2 

  1 2 5 6 

  2 3 4 5 

  1 3 

  0 0 

  Sample Output 

  9 11
最短路的模板题 多了一个相同路径长度取花费少的要求 就同时求两个最短 然后优先判断路径 路径相同再判断花费去更新lowcost和lowpay 
**有一个不算坑的坑点 就是他妈的路径可能会重复 所以输入的时候要判断 不能直接读取 要判断如果比原有的小 才存入！！！**

然后就直接用邻接矩阵的Dijkstra求 
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,m;
int a,b,d,p;
const int MAXN=1050;
int cost[MAXN][MAXN];
int pay[MAXN][MAXN];
int lowpay[MAXN];
int lowcost[MAXN];
bool vis[MAXN];
const int INF=0x3f3f3f3f;
int s,t;
void Dijkstra(int s){
    for(int i=1;i<=n;i++){
        lowcost[i]=INF;
        lowpay[i]=INF;
        vis[i]=false;
    }
    lowcost[s]=0;
    lowpay[s]=0;
    for(int i=1;i<=n;i++){
        int k=-1;
        int Min=INF;
        for(int j=1;j<=n;j++){
            if(!vis[j] && lowcost[j]<Min){
                Min=lowcost[j];
                k=j;
            }
        }
        if(k==-1){
            break;
        }
        vis[k]=true;
        for(int j=1;j<=n;j++){
            if(!vis[j] && lowcost[k]+cost[k][j]<lowcost[j]){
                lowcost[j]=lowcost[k]+cost[k][j];
                lowpay[j]=lowpay[k]+pay[k][j];
            }
            else if(!vis[j] && lowcost[k]+cost[k][j]==lowcost[j]){
                if(lowpay[k]+pay[k][j]<lowpay[j]){
                    lowpay[j]=lowpay[k]+pay[k][j];
                }
            }
        }
    }
}
int main(void){
    while(~scanf("%d%d",&n,&m)){
        if(n==0 && m==0){
            break;
        }
        memset(cost,INF,sizeof(cost));
        memset(pay,INF,sizeof(pay));
        while(m--){
            scanf("%d%d%d%d",&a,&b,&d,&p);
            if(d<cost[a][b]){
                cost[a][b]=d;
                cost[b][a]=d;
                pay[a][b]=p;
                pay[b][a]=p;
            }
        }
        scanf("%d%d",&s,&t);
        Dijkstra(s);
        printf("%d %d\n",lowcost[t],lowpay[t]);
    }
    return 0;
}
```







