# hdu1280——前m大的数 - westbrook1998的博客 - CSDN博客





2018年07月13日 21:44:41[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：50








> 
还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。  

  给定一个包含N(N<=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M<=1000)并按从大到小的顺序排列。 

  Input 

  输入可能包含多组数据，其中每组数据包括两行：  

  第一行两个数N和M，  

  第二行N个数，表示该序列。  

  Output 

  对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。 

  Sample Input 

  4 4 

  1 2 3 4 

  4 5 

  5 3 6 4 

  Sample Output 

  7 6 5 5 

  11 10 9 9 8
wa了十几次。。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=10000;
int num[3050];
int a[MAXN];
int main(void){
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        memset(a,0,sizeof(a));
        for(int i=0;i<n;i++){
            scanf("%d",&num[i]);
            a[num[i]]++;
        }
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                a[num[i]+num[j]]++;
            }
        }
        int i;
        for(i=MAXN-1;i>0 && m>0;i--){
            if(a[i]>0){
                printf("%d",i);
                a[i]--;
                m--;
                break;
            }
        }
        for(int j=i;j>0 && m>0;j--){
            while(a[j]>0 && m>0){
                printf(" %d",j);
                a[j]--;
                m--;
            }
        }
        printf("\n");
    }
    return 0;
}
```





