# hdu2087——剪花布条 - westbrook1998的博客 - CSDN博客





2018年05月11日 13:47:44[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：52








> 
一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？  

  Input 

  输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。  

  Output 

  输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。  

  Sample Input 

  abcde a3 

  aaaaaa  aa 

  # 

  Sample Output 

  0 

  3
一道裸的KMP模板题，用来熟悉kmp，主要就是注意输入结束的处理，注意这里模式串是不能重叠的，所以没匹配一个之后要将`j设为0`，从头匹配，拓展一下，如果是求可重复的模式串，那就`j=next[j]`即可

代码：

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXN=1050;
char str[MAXN];
char pat[MAXN];
char next[MAXN];
void pre_kmp(char pat[],int len,char next[]){
    int i=0,j=next[0]=-1;
    while(i<len){
        while(-1!=j && pat[i]!=pat[j]){
            j=next[j];
        }
        next[++i]=++j;
    }
}
int kmp_count(char pat[],int n,char str[],int m){
    int count=0;
    int i=0,j=0;
    pre_kmp(pat,n,next);
    while(i<m){
        while(-1!=j && str[i]!=pat[j]){
            j=next[j];
        }
        i++;
        j++;
        if(j>=n){
            count++;
            j=0;
            //j=next[j];
        }
    }
    return count;
}
int main(void){
    while(~scanf("%s",str)){
        if(str[0]=='#'){
            break;
        }
        scanf("%s",pat);
        printf("%d\n",kmp_count(pat,strlen(pat),str,strlen(str)));
    }
    return 0;
}
```





