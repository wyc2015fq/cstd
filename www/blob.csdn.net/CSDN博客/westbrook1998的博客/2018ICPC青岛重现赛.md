# 2018ICPC青岛重现赛 - westbrook1998的博客 - CSDN博客





2018年11月11日 13:27:21[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：108








第二题做了J题，题意是给n本书的价格，然后要从第一本开始买，不够买就跳过，然后给定这个人买的本书，判断这个人最大可能有的钱数

考虑了一下我们只要分情况考虑一下就好了，首先是n==m，能全买的钱肯定是无限大，然后如果价格为0的数量大于m，就是不可能的情况，因为0一定要买

然后就是剩下的情况，把0的全部买了，然后从头开始买，剩下的找到一个最小值把钱数再加上这个数-1即可，因为如果再打就可以买这一本了，所以这是最大的
代码：

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+50;
const ll INF=1e10+10;
int t,n,m;
ll a[N];
bool vis[N];
int main(void){
    scanf("%d",&t);
    while(t--){
        memset(a,0,sizeof(a));
        memset(vis,false,sizeof(vis));
        scanf("%d%d",&n,&m);
        int zero=0;
        for(int i=0;i<n;i++){
            scanf("%lld",&a[i]);
            if(a[i]==0){
                zero++;
            }
        }
        if(n==m){
            printf("Richman\n");
            continue;
        }
        if(zero>m){
            printf("Impossible\n");
        }else{
            m-=zero;
            ll ans=0;
            for(int i=0;i<n && m>=1;i++){
                if(a[i]==0){
                    continue;
                }
                ans+=a[i];
                vis[i]=true;
                m--;
            }
            ll Min=INF;
            for(int i=0;i<n;i++){
                if(a[i]==0 || vis[i]==true){
                    continue;
                }
                if(a[i]<Min){
                    Min=a[i];
                }
            }
            ans+=(Min-1);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```




