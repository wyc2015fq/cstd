# hdu2094——产生冠军 - westbrook1998的博客 - CSDN博客





2018年08月22日 10:42:20[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：25








> 
有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。  

  球赛的规则如下：  

  如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。  

  如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。  

  根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。  

  Input 

  输入含有一些选手群，每群选手都以一个整数n(n<1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。  

  Output 

  对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。  

  Sample Input 

  3 

  Alice Bob 

  Smith John 

  Alice Smith 

  5 

  a c 

  c d 

  d e 

  b e 

  a d 

  0 

  Sample Output 

  Yes 

  No
一开始以为是拓扑排序 百度发现原来是一道水题，其实只要有一个没有输过的就是冠军了 

（有且仅有一个）

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
#include <string>
#include <set>
#include <iostream>
using namespace std;
map<string,int> r;
set<string> s;
int main(void){
    int n;
    string s1,s2;
    while(~scanf("%d",&n) && n){
        r.clear();
        s.clear();
        for(int i=0;i<n;i++){
            cin >> s1 >> s2;
            s.insert(s1);
            s.insert(s2);
            if(r[s2]==0){
                r[s2]=1;
            }
        }
        bool flag=false;
        int cnt=0;
        for(set<string>::iterator it=s.begin();it!=s.end();it++){
            if(r[*it]==0){
                flag=true;
                cnt++;
            }
        }
        if(flag && cnt==1){
            printf("Yes\n");
        }
        else{
            printf("No\n");
        }
    }
    return 0;
}
```





