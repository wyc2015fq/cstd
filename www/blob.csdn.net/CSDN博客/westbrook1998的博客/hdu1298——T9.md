# hdu1298——T9 - westbrook1998的博客 - CSDN博客





2018年08月23日 18:46:14[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：52








> 
A while ago it was quite cumbersome to create a message for the Short Message Service (SMS) on a mobile phone. This was because you only have nine keys and the alphabet has more than nine letters, so most characters could only be entered by pressing one key several times. For example, if you wanted to type “hello” you had to press key 4 twice, key 3 twice, key 5 three times, again key 5 three times, and finally key 6 three times. This procedure is very tedious and keeps many people from using the Short Message Service.  

  This led manufacturers of mobile phones to try and find an easier way to enter text on a mobile phone. The solution they developed is called T9 text input. The “9” in the name means that you can enter almost arbitrary words with just nine keys and without pressing them more than once per character. The idea of the solution is that you simply start typing the keys without repetition, and the software uses a built-in dictionary to look for the “most probable” word matching the input. For example, to enter “hello” you simply press keys 4, 3, 5, 5, and 6 once. Of course, this could also be the input for the word “gdjjm”, but since this is no sensible English word, it can safely be ignored. By ruling out all other “improbable” solutions and only taking proper English words into account, this method can speed up writing of short messages considerably. Of course, if the word is not in the dictionary (like a name) then it has to be typed in manually using key repetition again.  
![这里写图片描述](https://odzkskevi.qnssl.com/97b69b60f293cd43ee8339a43b8ee22f?v=1534702191)

  Figure 8: The Number-keys of a mobile phone. 

  More precisely, with every character typed, the phone will show the most probable combination of characters it has found up to that point. Let us assume that the phone knows about the words “idea” and “hello”, with “idea” occurring more often. Pressing the keys 4, 3, 5, 5, and 6, one after the other, the phone offers you “i”, “id”, then switches to “hel”, “hell”, and finally shows “hello”.  

  Write an implementation of the T9 text input which offers the most probable character combination after every keystroke. The probability of a character combination is defined to be the sum of the probabilities of all words in the dictionary that begin with this character combination. For example, if the dictionary contains three words “hell”, “hello”, and “hellfire”, the probability of the character combination “hell” is the sum of the probabilities of these words. If some combinations have the same probability, your program is to select the first one in alphabetic order. The user should also be able to type the beginning of words. For example, if the word “hello” is in the dictionary, the user can also enter the word “he” by pressing the keys 4 and 3 even if this word is not listed in the dictionary.  

  Input 

  The first line contains the number of scenarios.  

  Each scenario begins with a line containing the number w of distinct words in the dictionary (0<=w<=1000). These words are given in the next w lines. (They are not guaranteed in ascending alphabetic order, although it’s a dictionary.) Every line starts with the word which is a sequence of lowercase letters from the alphabet without whitespace, followed by a space and an integer p, 1<=p<=100, representing the probability of that word. No word will contain more than 100 letters.  

  Following the dictionary, there is a line containing a single integer m. Next follow m lines, each consisting of a sequence of at most 100 decimal digits 2-9, followed by a single 1 meaning “next word”.  

  Output 

  The output for each scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1.  

  For every number sequence s of the scenario, print one line for every keystroke stored in s, except for the 1 at the end. In this line, print the most probable word prefix defined by the probabilities in the dictionary and the T9 selection rules explained above. Whenever none of the words in the dictionary match the given number sequence, print “MANUALLY” instead of a prefix.  

  Terminate the output for every number sequence with a blank line, and print an additional blank line at the end of every scenario.  

  Sample Input 

  2 

  5 

  hell 3 

  hello 4 

  idea 8 

  next 8 

  super 3 

  2 

  435561 

  43321 

  7 

  another 5 

  contest 6 

  follow 3 

  give 13 

  integer 6 

  new 14 

  program 4 

  5 

  77647261 

  6391 

  4681 

  26684371 

  77771 

  Sample Output 

  Scenario #1: 

  i 

  id 

  hel 

  hell 

  hello 

  i 

  id 

  ide 

  idea 

  Scenario #2: 

  p 

  pr 

  pro 

  prog 

  progr 

  progra 

  program 

  n 

  ne 

  new 

  g 

  in 

  int 

  c 

  co 

  con 

  cont 

  anoth 

  anothe 

  another 

  p 

  pr 

  MANUALLY 

  MANUALLY

这题好难啊 

九宫格 然后给一些单词，和对应的权重，然后给一个按键的顺序，求每一次按一个键出来的字符串 

建树不难，就是字典树然后把字符串沿途所有字符都加上权重，但是在搜索的时候，因为一个键有多个字符，而且给的是一个数字串，所以就需要dfs 很强

代码：
```cpp

```
#include <cstdio>#include <algorithm>#include <cstring>#define _clr(x,a) memset(x,a,sizeof(x));usingnamespacestd;
char w[105];
char num[105];
char res[105];
int pb;
int sum;
int _max;
char te[10][5]={{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};
struct Node{
    int p;
    Node* Next[26];
    char ch[105];
    Node(){
        p=0;
        for(int i=0;i<26;i++){
            Next[i]=NULL;
        }
    }
};
Node* root;
void insert(char* s,int pro){
    int val;
    char str[105];
    Node* p=root;
    for(int i=0;s[i];i++){
        val=s[i]-'a';
        if(p->Next[val]==NULL){
            p->Next[val]=new Node();
        }
        p=p->Next[val];
        p->p+=pro;
        str[i]=s[i];
        str[i+1]='\0';
        //保存到该节点的字符串strcpy(p->ch,str);
    }
}
void dfs(Node* po,int cur,int t){
    if(cur==t){
        if(po->p>_max){
            strcpy(res,po->ch);
            _max=po->p;
        }
        return;
    }
    int v=num[cur+1]-'0';
    //printf("v:%d\n",v);int l=strlen(te[v-2]);
    for(int i=0;i<l;i++){
        int val=te[v-2][i]-'a';
        //printf("%c\n",te[v-2][i]);if(po->Next[val]==NULL){
            continue;
        }
        else{
            //printf("dfs %d %c\n",val,'a'+val);
            dfs(po->Next[val],cur+1,t);
        }
    }
}
void clear(Node* root){
    if(root==NULL){
        return;
    }
    else{
        for(int i=0;i<26;i++){
            clear(root->Next[i]);
        }
    }
    delete(root);
}
int main(void){
    //freopen("data.txt","r",stdin);int t;
    scanf("%d",&t);
    for(int c=1;c<=t;c++){
        root=new Node();
        int n;
        scanf("%d",&n);
        for(int i=0;i<n;i++){
            scanf("%s %d",w,&pb);
            insert(w,pb);
        }
        printf("Scenario #%d:\n",c);
        scanf("%d",&n);
        for(int i=0;i<n;i++){
            scanf("%s",num);
            int l=strlen(num);
            for(int j=0;j<l-1;j++){
                _max=-1;
                dfs(root,-1,j);
                if(_max==-1){
                    printf("MANUALLY\n");
                }
                else{
                    printf("%s\n",res);
                }
            }
            if(i!=n-1){
                printf("\n");
            }
        }
        printf("\n\n");
        //clear(root);
    }
    return0;
}





