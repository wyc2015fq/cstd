# 2017年浙江工业大学大学生程序设计迎新赛决赛—网络同步赛G——取数游戏2 - westbrook1998的博客 - CSDN博客





2018年06月08日 15:17:27[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：81








> 
链接：[https://www.nowcoder.com/acm/contest/63/G](https://www.nowcoder.com/acm/contest/63/G)

  来源：牛客网 

  题目描述  

  给定两个长度为n的整数列A和B，每次你可以从A数列的左端或右端取走一个数。假设第i次取走的数为ax，则第i次取走的数的价值vi=bi⋅ax，现在希望你求出∑vi的最大值。 

  输入描述: 

  第一行一个数T，表示有T组数据。 

  对于每组数据，第一行一个整数n， 

  接下来两行分别给出A数列与B数列。 

  输出描述: 

  每一组数据输出一行，最大的∑vi。 

  示例1 

  输入 

  复制 

  2 

  2 

  1 1000 

  2 1 

  5 

  1 3 5 2 4 

  1 2 3 4 5 

  输出 

  复制 

  2001 

  52 

  说明 

  对于第二个样例， 

  第一次从左边取走a1，v1=a1⋅b1=1, 

  第二次从左边取走a2，v2=a2⋅b2=6, 

  第三次从右边取走a5，v3=a5⋅b3=12, 

  第四次从右边取走a4，v4=a4⋅b4=8, 

  第五次取走剩下的a3，v5=a3⋅b5=25。 

  总价值∑vi=1+6+12+8+25=52 

  备注: 

  T≤10 

  1≤n≤103 

  1≤ai,bi≤103
一开始以为是贪心，错了，百度查了发现是区间dp这种东西，学习了一下别人的做法 
`dp[i][j]`表示i到j的v的最大值 

先对dp[i][i]进行初始化 `dp[i][i]=a[i]*b[n-1]`因为当面对i到i这个区间时，b肯定只剩下最后一个数可以选了 

状态转移方程： 
`dp[i][j]=max(dp[i+1][j]+a[i]*b[n-(j-i)-1],dp[i][j-1]+a[j]*b[n-(j-i)-1])`
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=1050;
int a[MAXN];
int b[MAXN];
int dp[MAXN][MAXN];
int main(void){
    int t;
    int n;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n;i++){
            scanf("%d",&a[i]);
        }
        for(int i=0;i<n;i++){
            scanf("%d",&b[i]);
        }
        for(int i=0;i<n;i++){
            dp[i][i]=b[n-1]*a[i];
        }       
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                dp[i][j]=max(dp[i+1][j]+a[i]*b[n-(j-i)-1],dp[i][j-1]+a[j]*b[n-(j-i)-1]);

            }
        }
        printf("%d\n",dp[0][n-1]);
    }
    return 0;
}
```






