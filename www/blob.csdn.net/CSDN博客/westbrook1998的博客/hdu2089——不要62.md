# hdu2089——不要62 - westbrook1998的博客 - CSDN博客





2018年08月22日 22:02:19[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：13标签：[dp																[数位dp](https://so.csdn.net/so/search/s.do?q=数位dp&t=blog)](https://so.csdn.net/so/search/s.do?q=dp&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。  

  杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。  

  不吉利的数字为所有含有4或62的号码。例如：  

  62315 73418 88914  

  都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。  

  你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。  

  Input 

  输入的都是整数对`n、m（0<n≤m<1000000）`，如果遇到都是0的整数对，则输入结束。  

  Output 

  对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。  

  Sample Input 

  1 100 

  0 0 

  Sample Output 

  80
这题很久前就看过了 这次学习了数位dp再来试着做一些 还是wa了很久 对着题解慢慢改对了 

考虑还是不全面

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int dig[10];
//dp[i][0]表示i位数不含62和不含4的个数
//dp[i][1]表示i位数不含62和不含4且最高为是2的个数
//dp[i][0]表示i位数含有62或含有4的个数
long long dp[10][3];
void init(){
    dp[0][0]=1;
    dp[0][1]=0;
    dp[0][2]=0;
    for(int i=1;i<=9;i++){
        dp[i][0]=dp[i-1][0]*9-dp[i-1][1];
        dp[i][1]=dp[i-1][0];
        dp[i][2]=dp[i-1][2]*10+dp[i-1][1]+dp[i-1][0];
    }
}
long long solve(long long n){
    memset(dig,0,sizeof(dig));
    int k=0;
    while(n){
        dig[++k]=n%10;
        n/=10;
    }
    // for(int i=k;i>=1;i--){
    //     printf("%d ",dig[i]);
    // }
    // printf("\n");
    long long ans=0;
    bool flag=false;
    for(int i=k;i>=1;i--){
        ans+=dp[i-1][2]*dig[i];
        if(flag){
            ans+=dp[i-1][0]*dig[i];
        }
        else{
            if(dig[i]>6){
                ans+=dp[i-1][1];
            }
            if(dig[i+1]==6 && dig[i]>2){
                ans+=dp[i][1];
            }
            if(dig[i]>4){
                ans+=dp[i-1][0];
            }
        }
        if(dig[i]==2 && dig[i+1]==6 || dig[i]==4){
            flag=true;
        }
    }
    return ans;
}
int main(void){
    init();
    long long a,b;
    while(~scanf("%lld%lld",&a,&b)){
        if(a==0 && b==0){
            break;
        }
        printf("%lld\n",b+1-a-(solve(b+1)-solve(a)));
    }
    return 0;
}
```






