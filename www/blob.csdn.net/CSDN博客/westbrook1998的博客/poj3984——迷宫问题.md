# poj3984——迷宫问题 - westbrook1998的博客 - CSDN博客





2018年08月11日 19:39:25[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：39标签：[搜索																[dfs](https://so.csdn.net/so/search/s.do?q=dfs&t=blog)](https://so.csdn.net/so/search/s.do?q=搜索&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
定义一个二维数组：  

  int maze[5][5] = { 

      0, 1, 0, 0, 0, 

      0, 1, 0, 1, 0, 

      0, 0, 0, 0, 0, 

      0, 1, 1, 1, 0, 

      0, 0, 0, 1, 0, 

  }; 

  它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 

  Input 

  一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 

  Output 

  左上角到右下角的最短路径，格式如样例所示。 

  Sample Input 

  0 1 0 0 0 

  0 1 0 1 0 

  0 0 0 0 0 

  0 1 1 1 0 

  0 0 0 1 0 

  Sample Output 

  (0, 0) 

  (1, 0) 

  (2, 0) 

  (2, 1) 

  (2, 2) 

  (2, 3) 

  (2, 4) 

  (3, 4) 

  (4, 4)
下午说要练专题 可以两个菜鸡一题都不会，最后一个下午就搞出来这题，用dfs然后记录最短路径

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
int n,m;
const int MAXN=200020;
long long presum[MAXN];
long long b;
int main(void){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&b);
        presum[i]=presum[i-1]+b;
    }
    while(m--){
        scanf("%lld",&b);
        int idx=lower_bound(presum,presum+n,b)-presum;
        printf("%d %lld\n",idx,b-presum[idx-1]);
    }
    return 0;
}
```






