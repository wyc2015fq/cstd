# hdu3068——最长回文 - westbrook1998的博客 - CSDN博客





2018年09月02日 22:14:34[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：25








> 
给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.

回文就是正反读都是一样的字符串,如aba, abba等

Input

输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S

两组case之间由空行隔开(该空行不用处理)

字符串长度len <= 110000

Output

每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.

Sample Input

aaaa

abab

Sample Output

4

3
Manacher算法的模板题 把i写成1 然后tle了一个小时

代码;

```
#include <cstdio>
#include <algorithm>
#include <string>
#include <cstring>
#include <iostream>
using namespace std;
const int N=120000;
int p[N*2];
char s[N*2];
int Manacher(char *s){ 
    int sl=strlen(s);
    for(int i=sl;i>=0;i--){
        s[2*i+2]=s[i];
        s[2*i+1]='#';
    }
    s[0]='$';
    sl=strlen(s);
    //printf("%s\n",s);
    int id=0;
    int mx=0;
    int resL=0;
    for(int i=1;i<sl;i++){
        p[i]=mx>i?min(p[2*id-i],mx-i):1;
        // if(id+p[id]>i){
        //     p[i]=min(p[2*id-i],id+p[id]-i);
        // }
        // else{
        //     p[i]=1;
        // }
        while(s[i+p[i]]==s[i-p[i]]){
            p[i]++;
        }
        if(id+p[id]<i+p[i]){
            mx=i+p[i];
            id=i;
        }
        if(resL<p[i]){
            resL=p[i];
        }
    }
    return resL-1;
}
int main(void){
    while(~scanf("%s",s)){
        printf("%d\n",Manacher(s));
    }
    return 0;
}
```





