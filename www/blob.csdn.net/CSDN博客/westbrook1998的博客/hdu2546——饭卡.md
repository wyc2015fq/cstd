# hdu2546——饭卡 - westbrook1998的博客 - CSDN博客





2018年05月31日 16:19:10[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：91








> 
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。  

  某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。  

  Input 

  多组数据。对于每组数据：  

  第一行为正整数n，表示菜的数量。n<=1000。  

  第二行包括n个正整数，表示每种菜的价格。价格不超过50。  

  第三行包括一个正整数m，表示卡上的余额。m<=1000。  

  n=0表示数据结束。  

  Output 

  对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 

  Sample Input 

  1 

  50 

  5 

  10 

  1 2 3 2 1 1 2 3 2 1 

  50 

  0 

  Sample Output 

  -45 

  32
贪心+01背包的问题，因为只要余额大于5才能买，所以我们就保证到最后无限接近5的时候用来买那个最大价值的菜，这样子就尽量减少浪费了，所以先排序之后，最大价值的菜不算进去来进行一次01背包，最后结果就是原来余额(m+5)减去背包结果(dp[m])再减去最大价值的菜(v[n-1])

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=1050;
int v[MAXN];
int dp[MAXN];
int main(void){
    int n;
    while(~scanf("%d",&n)){
        if(0==n){
            break;
        }
        for(int i=0;i<n;i++){
            scanf("%d",&v[i]);
        }
        int m;
        scanf("%d",&m);
        if(m<5){
            printf("%d\n",m);
            continue;
        }
        m-=5;
        sort(v,v+n);
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n-1;i++){
            for(int j=m;j>=0;j--){
                if(j>=v[i]){
                    dp[j]=max(dp[j],dp[j-v[i]]+v[i]);
                }
            }
        }
        printf("%d\n",m+5-dp[m]-v[n-1]);
    }
    return 0;
}
```





