# hdu6286——2018 - westbrook1998的博客 - CSDN博客





2018年09月01日 22:41:51[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：43标签：[容斥](https://so.csdn.net/so/search/s.do?q=容斥&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
Given a,b,c,d, find out the number of pairs of integers (x,y) where a≤x≤b,c≤y≤d and x⋅y is a multiple of 2018.  

  Input 

  The input consists of several test cases and is terminated by end-of-file.  

  Each test case contains four integers a,b,c,d.  

  Output 

  For each test case, print an integer which denotes the result.  

   Constraint  

  * 1≤a≤b≤109,1≤c≤d≤109  

  * The number of tests cases does not exceed 104.  

  Sample Input 

  1 2 1 2018 

  1 2018 1 2018 

  1 1000000000 1 1000000000 

  Sample Output 

  3 

  6051 

  1485883320325200
注释里写了 就是看左右区间多少个满足条件的数乘起来

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
typedef long long ll;
using namespace std;
//2018的因数只有2018 1009 2 1
//小技巧 用6来代替2018便于理解
//左区间个数      乘     右区间个数
//6的倍数             1的倍数（整个区间）  6的倍数乘以任何数都是6的倍数
//3的倍数（除去6的倍数） 2的倍数
//2的倍数（除去6的倍数） 3的倍数
//剩下的数             6的倍数
void test(){
    for(int i=1;i*i<=2018;i++){
        if(2018%i==0){
            printf("%d\n",i);
            if(2018/i!=i){
                printf("%d\n",2018/i);
            }
        }
    }
}
int main(void){
    //test();
    ll a,b,c,d;
    while(~scanf("%lld%lld%lld%lld",&a,&b,&c,&d)){
        ll ans=0;
        //左6的倍数
        ans+=((b/2018)-((a-1)/2018))*((d-c)+1);
        //左3的倍数
        ans+=((((b/1009)-((a-1)/1009))-((b/2018)-((a-1)/2018)))*((d/2)-((c-1)/2)));
        //左2的倍数
        ans+=((((b/2)-((a-1)/2))-((b/2018)-((a-1)/2018)))*((d/1009)-((c-1)/1009)));
        //剩余的数
        ans+=(b-a+1-(((b/1009)-((a-1)/1009))-((b/2018)-((a-1)/2018)))-(((b/2)-((a-1)/2))-((b/2018)-((a-1)/2018)))-((b/2018)-((a-1)/2018)))*(((d/2018)-((c-1)/2018)));
        printf("%lld\n",ans); 
    }
    return 0;
}
```





