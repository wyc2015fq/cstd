# poj1061——青蛙的约会 - westbrook1998的博客 - CSDN博客





2018年08月30日 22:23:10[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：20标签：[数论																[拓展欧几里德](https://so.csdn.net/so/search/s.do?q=拓展欧几里德&t=blog)](https://so.csdn.net/so/search/s.do?q=数论&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。  

  我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。  

  Input 

  输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。 

  Output 

  输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible” 

  Sample Input 

  1 2 3 4 5 

  Sample Output 

  4
可怕的数论  

这题其实就是 $x+km\equiv y+kn \quad (mod \quad L)$ x y是原来的位置 m n是每步走的距离 k是走多少步后相遇 L是模数也就是纬线长度 

然后化简为$k(m-n)\equiv y-x\quad (mod \quad L)$ 两边式子取模相等 ，也就可以化简为 
$k(m-n)+gL = y-x$   我们就可以看成是解这个二元一次方程$ax+by=c$ 其中$a是m-n \quad b是L \quad c是y-x$

然后我们是通过拓展欧几里德解出$ax+by=gcd(a,b)$ 的一个解，$x0 y0$ 然后乘以$\frac{c}{d}就得到方程ax+by=c的一个解\quad 其中c就是y-x 而d就是gcd(a,b)$

最后就是要注意求出来的解有可能是负数 刚好这个样例就是 也就是两个各退一秒的时间就能相遇（-1s） 所以要 $+b再%b$
代码：

```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
typedef long long ll;
using namespace std;
void extgcd(ll a,ll b,ll &d,ll &x,ll &y){
    if(!b){
        d=a;
        x=1;
        y=0;
    }
    else{
        extgcd(b,a%b,d,y,x);
        y-=x*(a/b);
    }
}
int main(void){
    //freopen("data.txt","r",stdin);
    ll x,y,m,n,L;
    ll x0,y0;
    while(~scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&L)){
        ll a=n-m;
        ll b=L;
        ll c=x-y;
        ll d=0;
        //printf("%lld %lld %lld\n",a,b,c);
        extgcd(a,b,d,x0,y0);
        //printf("%lld %lld %lld\n",d,x0,y0);
        if(c%d){
            printf("Impossible\n");
        }
        else{
            c/=d;
            ll ans=(c*x0%b+b)%b;
            //不取模的话这里x0是-1
            //ans=c*x0;
            //解出来的x0是ax+by=gcd(a,b)的一个解 c*x0才是ax+by=z的一个特解
            //模b也就是模L求出最小整数解
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```







