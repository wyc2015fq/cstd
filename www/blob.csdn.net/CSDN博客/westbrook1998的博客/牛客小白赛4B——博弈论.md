# 牛客小白赛4B——博弈论 - westbrook1998的博客 - CSDN博客





2018年06月17日 10:48:38[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：108








> 
链接：[https://www.nowcoder.com/acm/contest/134/B](https://www.nowcoder.com/acm/contest/134/B)

  来源：牛客网 

  题目描述  

  铁子和顺溜在学习了博弈论的sg函数之后，解决了很多很多博弈题，现在他们遇到了一道难题。 

  给出一个长度为 n 的数列，数列里的每个元素都是个位数，这个数列的每一个连续子数列都能生成 

  一个十进制数，对于子数列a[l~r]，这个十进制数的个位为a[r],十位为a[r - 1]，…，最高位 

  为a[l]。 

  现在铁子需要知道最小的不能被该数列的子数列生成的十进制非负整数是多少？ 

  输入描述: 

  第一行一个数字n。(1 ≤ n ≤ 1000) 

  第二行n个数字di。(0 ≤ di ≤ 9) 

  输出描述: 

  输出一个数字表示答案。 

  示例1 

  输入 

  复制 

  4 

  3 0 1 2 

  输出 

  复制 

  4 

  示例2 

  输入 

  复制 

  10 

  9 8 7 6 5 4 3 2 1 0 

  输出 

  复制 

  11
我他吗怎么这么菜。。。这题首先和博弈无关，就是暴力枚举所有区间可以组成的数字 然后用map存起来 然后再来一个循环判断出结果 

而我犯的错误： 

1 写了一个o(n^2)的函数用来求区间组成的的数字，再加上外面的，妥妥的超时 

2 然后想到了用前一个数*10+当前的数这个想法 以为是dp 结果开了个二维数组，一直没过 

3 然后看题解的结论原来组成的这个数不会超过4位数 所以可以控制位数 也就不可能枚举到1000位的数 
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
const int MAXN=1050;
int a[MAXN];
map<long long , int> res;
int main(void){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=0;i<n;i++){
        long long sum=0;
        for(int j=i;j-i+1<5;j++){
            sum=sum*10+a[j];
            res[sum]=1;
        }
    }
    for(int i=0;i<1050;i++){
        if(!res[i]){
            printf("%d\n",i);
            break;
        }
    }
    return 0;
}
```






