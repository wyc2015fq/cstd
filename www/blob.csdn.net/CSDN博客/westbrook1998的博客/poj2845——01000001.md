# poj2845——01000001 - westbrook1998的博客 - CSDN博客





2018年07月05日 08:41:10[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：61标签：[大数加法](https://so.csdn.net/so/search/s.do?q=大数加法&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
Adding binary numbers is a very simple task, and very similar to the longhand addition of decimal numbers. As with decimal numbers, you start by adding the bits (digits) one column at a time, from right to left. Unlike decimal addition, there is little to memorize in the way of rules for the addition of binary bits: 

     0 + 0 = 0 

     1 + 0 = 1 

     0 + 1 = 1 

     1 + 1 = 10 

     1 + 1 + 1 = 11 

  Just as with decimal addition, when the sum in one column is a two-bit (two-digit) number, the least significant figure is written as part of the total sum and the most significant figure is “carried” to the next left column. Consider the following examples: 

                         11  1 <– Carry bits –> 1   11 

    1001101             1001001                    1000111 

  + 0010010           + 0011001                  + 1010110 

   ——–           ———                  ——— 

    1011111             1100010                   10011101 

  The addition problem on the left did not require any bits to be carried, since the sum of bits in each column was either 1 or 0, not 10 or 11. In the other two problems, there definitely were bits to be carried, but the process of addition is still quite simple. 

  Input 

  The first line of input contains an integer N, ( 1 ≤ N ≤ 1000), which is the number of binary addition problems that follow. Each problem appears on a single line containing two binary values separated by a single space character. The maximum length of each binary value is 80 bits (binary digits). Note: The maximum length result could be 81 bits (binary digits). 

  Output 

  For each binary addition problem, print the problem number, a space, and the binary result of the addition. Extra leading zeroes must be omitted. 

  Sample Input 

  3 

  1001101 10010 

  1001001 11001 

  1000111 1010110 

  Sample Output 

  1 1011111 

  2 1100010 

  3 10011101
两个01字符串的相加 因为没写过这种大数模板 坑了不少地方，包括最后没有考虑到00+00这种情况 不能输出空 而是要输出一个0 总算是AC了

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
using namespace std;
int main(void){
    int t;
    int c=0;
    char s1[100],s2[100];
    int res[100];
    scanf("%d",&t);
    while(t--){
        memset(res,0,sizeof(res));
        scanf("%s%s",s1,s2);
        int len1=strlen(s1);
        int len2=strlen(s2);
        int cnt=0;
        int val=0;
        int k=0;
        while(len1>0 && len2>0){
            len1--;
            len2--;
            val=cnt+(s1[len1]-'0')+(s2[len2]-'0');
            cnt=val/2;
            val%=2;
            res[k++]=val;
        }
        while(len1>0){
            len1--;
            val=(s1[len1]-'0'+cnt);
            cnt=val/2;
            val%=2;
            res[k++]=val;
        }
        while(len2>0){
            len2--;
            val=(s2[len2]-'0'+cnt);
            cnt=val/2;
            val%=2;
            res[k++]=val;
        }
        if(cnt!=0){
            res[k++]=cnt;
        }
        printf("%d ",++c);
        int one_flag=0;
        for(int i=k-1;i>=0;i--){
            if(res[i]==0 && one_flag==0){
                if(i==0){
                    printf("%d",res[i]);
                }
                else{
                    continue;
                }
            }
            else if(res[i]==1){
                one_flag=1;
                printf("%d",res[i]);
            }
            else if(one_flag==1){
                printf("%d",res[i]);
            }
        }
        printf("\n");
    }
    return 0;
}
```





