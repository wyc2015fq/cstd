# 二叉树的三种遍历方式 - westbrook1998的博客 - CSDN博客





2018年04月05日 17:31:16[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：95








### 1. 前（先）序遍历

**先根节点，再左节点，再右节点**

递归方法：

```java
public class Solution {
    /**
     * @param root: A Tree
     * @return: Preorder in ArrayList which contains node values.
     */
    List<Integer> list=new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        list.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return list;
    }
}
```

**因为先序遍历是先访问根节点，再访问左节点，再访问右节点，所以在访问根节点后要将根节点压入栈中保存起来，在访问左节点后可以从栈中弹出根据根节点访问右节点**

基本思路： 

1. 访问根节点r并将r入栈 

2. 如果r的左节点为空，r出栈并将r的右节点设为当前节点 

3. 如果r的左节点非空，则将r的左节点设为当前节点 

非递归方法：
```java
public class Solution {
    /**
     * @param root: A Tree
     * @return: Preorder in ArrayList which contains node values.
     */
    public List<Integer> preorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        //用来临时存储节点的栈
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> list=new ArrayList<>();
        //root不等于null说明还有节点需要遍历
        //栈大小大于0说明栈中还有节点需要取出以遍历它的右节点
        while(root!=null || stack.size()>0){
            //当前节点不等于null
            while(root!=null){
                //先访问该节点
                list.add(root.val);
                //压入栈中，等待访问完左节点后再出栈
                stack.push(root);
                //将左节点设为当前节点，开始下一轮循环
                root=root.left;
            }
            //当循环结束，说明左节点为空（左节点访问结束）
            //如果此时栈大小大于0，说明需要出栈去访问右节点
            if(stack.size()>0){
                //将出栈的节点的右节点设为当前节点，进行遍历
                TreeNode node=stack.pop();
                root=node.right;
            }
        }
        return list;
    }
}
```

### 2. 中序遍历

**先左节点，再根，再右节点**

递归方法：

```java
public class Solution {
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    List<Integer> list=new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
        return list;
    }
}
```

非递归方法：

```java
public class Solution {
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> list=new ArrayList<>();
        while(root!=null || stack.size()>0){
            while(root!=null){
                //与先序遍历的非递归方法类似
                //先序遍历先访问根节点再压入，中序遍历是直接将根节点压入栈，先访问左节点
                stack.push(root);
                root=root.left;
            }
            if(stack.size()>0){   
                TreeNode node=stack.pop();
                //访问弹出的根节点
                list.add(node.val);
                //将右节点设为当前节点
                root=node.right;
            }
        }
        return list;
    }
}
```

### 3. 后序遍历

**先左节点，再右节点，再根**

递归方法：

```java
public class Solution {
    /**
     * @param root: A Tree
     * @return: Postorder in ArrayList which contains node values.
     */
    List<Integer> list=new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        list.add(root.val);
        return list;
    }
}
```

非递归方法： 
**后序遍历的非递归方法相对比较麻烦一些，但总体也是利用栈的出入来记录和保存遍历的路径**

```java
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param root: A Tree
     * @return: Postorder in ArrayList which contains node values.
     */
    public List<Integer> postorderTraversal(TreeNode root) {
        // write your code here
        if(root==null){
            return null;
        }
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> list=new ArrayList<>();
        //保存当前节点
        TreeNode curNode=root;
        //保存上一个已访问节点
        TreeNode lastVisitedNode=null;
        //移动到根节点最左节点作为当前节点
        while(curNode!=null){
            //将路径中的节点依次压入栈中
            stack.push(curNode);
            curNode=curNode.left;
        }
        //如果栈为空说明没有中间节点需要访问
        while(!stack.empty()){
            //弹出节点作为当前节点
            curNode=stack.pop();
            //一个根节点需要被被访问（未被访问）的前提就是：没有右子树或右子树已被访问过  
            if(curNode.right!=null && curNode.right!=lastVisitedNode){
                //说明这个根节点还没需要访问，即是先要访问右节点
                stack.push(curNode);
                //将右节点作为当前节点
                curNode=curNode.right;
                //跟上面一样移动到当前节点最左节点作为当前节点
                while(curNode!=null){
                    //并将路径中节点压入栈中
                    stack.push(curNode);
                    curNode=curNode.left;
                }
            }
            //该节点需要被访问
            else{
                list.add(curNode.val);
                //并将当前节点（已访问）设为上一个访问节点
                lastVisitedNode=curNode;
            }
        }
        return list;
    }
}
```




