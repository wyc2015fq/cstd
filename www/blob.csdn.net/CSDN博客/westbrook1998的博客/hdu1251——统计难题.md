# hdu1251——统计难题 - westbrook1998的博客 - CSDN博客





2018年08月21日 23:25:27[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：18标签：[字符串																[字典树](https://so.csdn.net/so/search/s.do?q=字典树&t=blog)](https://so.csdn.net/so/search/s.do?q=字符串&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).  

  Input 

  输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.  

  注意:本题只有一组测试数据,处理到文件结束.  

  Output 

  对于每个提问,给出以该字符串为前缀的单词的数量.  

  Sample Input 

  banana 

  band 

  bee 

  absolute 

  acm 

  ba 

  b 

  band 

  abc 

  Sample Output 

  2 

  3 

  1 

  0
学了一下简单的字典树 

水一道模板题  字典树还是意外的很好理解的 也很好写

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;
const int N=26;
struct Node{
    //经过该节点的字符串数量
    int cnt;
    Node* Next[N];
    Node(int x):cnt(x){
        for(int i=0;i<N;i++){
            Next[i]=NULL;
        }
    }
};
void insert(Node* &rt,char* s){
    int len=strlen(s);
    int val;
    Node* p=rt;
    for(int i=0;i<len;i++){
        val=s[i]-'a';
        if(p->Next[val]==NULL){
            p->Next[val]=new Node(0);
        }
        p=p->Next[val];
        p->cnt++;
    }
}
int find(Node* &rt,char* s){
    if(rt==NULL){
        return false;
    }
    int len=strlen(s);
    Node* p=rt;
    int val;
    for(int i=0;i<len;i++){
        val=s[i]-'a';
        if(p->Next[val]==NULL){
            return 0;
        }
        p=p->Next[val];
    }
    return p->cnt;
}
int main(void){
    //string s;
    char s[11];
    Node* rt=new Node(0);
    while(cin.getline(s,12)){
        if(strlen(s)==0){
            break;
        }
        insert(rt,s);
    }
    while(cin.getline(s,12)){
        printf("%d\n",find(rt,s));
    }
    free(rt);
    return 0;
}
```






