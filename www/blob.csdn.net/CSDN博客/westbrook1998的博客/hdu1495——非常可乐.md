# hdu1495——非常可乐 - westbrook1998的博客 - CSDN博客





2018年07月05日 20:33:05[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：53标签：[bfs](https://so.csdn.net/so/search/s.do?q=bfs&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S<101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 

  Input 

  三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 

  Output 

  如果能平分的话请输出最少要倒的次数，否则输出”NO”。 

  Sample Input 

  7 4 3 

  4 1 3 

  0 0 0 

  Sample Output 

  NO 

  3
我终于能独立写出一道bfs搜索的题目了！！！ 虽然还是这种简单的倒水问题 经过长时间的爬坑还是写出来了

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
int S,N,M;
int ans;
int vis[105][105][105];
struct node{
    int s,n,m,step;
    node(int _s,int _n,int _m,int _step):s(_s),n(_n),m(_m),step(_step){}
};
void operate(int &s,int &n,int &m,int i){
    switch(i){
        //1-2
        case 1:{
            if(s+n>N){
                s=(s+n)-N;
                n=N;
            }
            else{
                n+=s;
                s=0;
            }
            break;
        }
        //1-3
        case 2:{
            if(s+m>M){
                s=(s+m)-M;
                m=M;
            }
            else{
                m+=s;
                s=0;
            }
            break;
        }
        //2-3
        case 3:{
            if(n+m>M){
                n=(n+m)-M;
                m=M;
            }
            else{
                m+=n;
                n=0;
            }
            break;
        }
        //2-1
        case 4:{
            if(n+s>S){
                n=(n+s)-S;
                s=S;
            }
            else{
                s+=n;
                n=0;
            }
            break;
        }
        //3-1
        case 5:{
            if(m+s>S){
                m=(m+s)-S;
                s=S;
            }
            else{
                s+=m;
                m=0;
            }
            break;
        }
        //3-2
        case 6:{
            if(m+n>N){
                m=(m+n)-N;
                n=N;
            }
            else{
                n+=m;
                m=0;
            }
            break;
        }
    }
}
int bfs(int target){
    memset(vis,0,sizeof(vis));
    queue<node> que;
    que.push(node(S,0,0,0));
    vis[S][0][0]=1;
    while(!que.empty()){
        node tmp=que.front();
        que.pop();
        int ts=tmp.s;
        int tn=tmp.n;
        int tm=tmp.m;
        int tstep=tmp.step;
        //printf("%d %d %d %d\n",ts,tn,tm,tstep);
        if((tn==target && tm==target) || (tm==target && ts==target) || (ts==target && tn==target)){
            return tstep;
        }
        for(int i=1;i<=6;i++){
            int ts=tmp.s;
            int tn=tmp.n;
            int tm=tmp.m;
            int tstep=tmp.step;
            operate(ts,tn,tm,i);
            //printf("%d %d %d %d %d\n",i,ts,tn,tm,tstep);
            if(!vis[ts][tn][tm]){
                que.push(node(ts,tn,tm,tstep+1));
                vis[ts][tn][tm]=1;
            }
        }
    }
    return -1;
}
int main(void){
    while(~scanf("%d%d%d",&S,&N,&M)){
        if(S==0 && N==0 && M==0){
            break;
        }
        int ans=bfs(S/2);
        if(ans==-1 || S%2==1){
            printf("NO\n");
        }
        else{
            printf("%d\n",ans);
        }
    }
    return 0;
}
```





