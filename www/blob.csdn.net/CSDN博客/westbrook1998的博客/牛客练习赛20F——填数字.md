# 牛客练习赛20F——填数字 - westbrook1998的博客 - CSDN博客





2018年06月16日 20:53:18[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：85








> 
链接：[https://www.nowcoder.com/acm/contest/128/F](https://www.nowcoder.com/acm/contest/128/F)

  来源：牛客网 

  题目描述  

  托米发现了一种新的游戏–填数字! 

  每填写一次数字(1≤ i≤9)需要花费ai枚金币,托米总共有n枚金币. 

  托米想知道他能得到的最大数字是多少. 

  如果填不了请输出-1。 

  不需要用完所有金币 

  输入描述: 

  第一行一个数字n,表示金币总数. 

  第二行9个正整数,第i个数字表示填写一次数字i所需要的金币数. 

  输出描述: 

  输出满足条件的最大数字. 

  示例1 

  输入 

  复制 

  5 

  5 4 3 2 1 2 3 4 5 

  输出 

  复制 

  55555 

  示例2 

  输入 

  复制 

  2 

  9 11 1 12 5 8 9 10 6 

  输出 

  复制 

  33 

  示例3 

  输入 

  复制 

  0 

  1 1 1 1 1 1 1 1 1 

  输出 

  复制 

  -1 

  备注: 

  0≤ n≤ 106 

  1≤ ai≤ 105
做不出来 看了一下题解才想通，首先是输入的时候就找出最小的金币和所在的索引，然后n个金币就尽量全部选这个，可以选n/mi，剩下n%mi 然后就依次判断n剩下的金币数能否补上选择其他数的这个差值 a[j]-mi 而这个其他数一定要比mi的数大才有意义，所以从9倒序枚举

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[11];
const int INF=10000007;
int main(void){
    int n;
    while(~scanf("%d",&n)){
        int idx;
        int mi=INF;
        for(int i=1;i<=9;i++){
            scanf("%d",&a[i]);
            if(a[i]<mi){
                mi=a[i];
                idx=i;
            }
        }
        if(n<mi){
            printf("-1\n");
        }
        else{
            int k=n/mi;
            n%=mi;
            for(int i=1;i<=k;i++){
                for(int j=9;j>0;j--){
                //选最小的那个和选j相差的金币数为a[j]-mi 判断n剩下的能否补上这个差值
                    if(n>=a[j]-mi){
                        printf("%d",j);
                        n-=(a[j]-mi);
                        break;
                    }
                }
            }
            printf("\n");
        }
    }
    return 0;
}
```





