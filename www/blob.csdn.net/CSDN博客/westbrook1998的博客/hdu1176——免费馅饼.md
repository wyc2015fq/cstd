# hdu1176——免费馅饼 - westbrook1998的博客 - CSDN博客





2018年08月29日 20:22:31[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：17标签：[dp](https://so.csdn.net/so/search/s.do?q=dp&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)









> 
都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：  

  为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）  

  Input 

  输入数据有多组。每组数据的第一行为以正整数n`(0<n<100000)`，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T`(0<T<100000)`,表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。  

  Output 

  每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。  

  提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。  

  Sample Input 

  6 

  5 1 

  4 1 

  6 1 

  7 2 

  7 2 

  8 3 

  0 

  Sample Output 

  4
一道dp的题目 但是一开始方向搞错了 最后没办法确定第一秒站在5的情况 

应该是反过来dp 

dp[t][i]同样记为开始多少秒后，从该位置开始能接到的馅饼数 

比如第0秒5位置能接到的馅饼，就等于0秒时5位置本身的馅饼，加上1秒时5 6 7位置能接到的馅饼
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n;
int dp[100005][12];
int main(void){
    //freopen("data.txt","r",stdin);
    while(~scanf("%d",&n) && n){
        int x,t;
        int t_max=0;
        memset(dp,0,sizeof(dp));
        while(n--){
            scanf("%d%d",&x,&t);
            dp[t][x]++;
            t_max=max(t_max,t);
        }
        int ans=0;
        //正向dp的话初始位置是5 不知道处理
        // for(int t=1;t<=t_max;t++){
        //     for(int i=0;i<=10;i++){
        //         dp[t][i]+=max(dp[t-1][i-1],max(dp[t-1][i],dp[t-1][i+1]));
        //         printf("%d %d %d\n",t,i,dp[t][i]);
        //     }
        // }
        // printf("%d\n",dp[t_max][5]);
        //不如反过来，dp[t][i]同样记为开始多少秒后，从该位置开始能接到的馅饼数
        //比如第0秒5位置能接到的馅饼，就等于0秒时5位置本身的馅饼，加上1秒时5 6 7位置能接到的馅饼
        for(int t=t_max;t>=0;t--){
            for(int i=0;i<=10;i++){
                dp[t][i]+=max(dp[t+1][i-1],max(dp[t+1][i],dp[t+1][i+1]));
                //printf("%d %d %d\n",t,i,dp[t][i]);
            }
        }
        printf("%d\n",dp[0][5]);
    }
    return 0;
}
```






