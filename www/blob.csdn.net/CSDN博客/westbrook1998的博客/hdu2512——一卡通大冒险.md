# hdu2512——一卡通大冒险 - westbrook1998的博客 - CSDN博客





2018年07月29日 13:15:25[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：70








> 
因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：  

  {{A},{B},{C}} , {{A,B},{C}}, {{B,C},{A}}, {{A,C},{B}} ,{{A,B,C}} 于是，  

  这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。  

  Input 

  包含多组数据，第一行为n，表示接下来有n组数据。以下每行一个数x，表示共有x张一卡通。（1≤x≤2000）.  

  Output 

  对每组数据，输出一行：不同的方法数，因为这个数可能非常大，我们只需要它除以1000的余数。  

  Sample Input 

  4 

  1 

  2 

  3 

  100 

  Sample Output 

  1 

  2 

  5 

  751
数列递推的题目 和组合数也很像 

设`dp[i][j]`表示i张卡分在j本书里的种类数 

所以`dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*j`

即第`i`张卡片相对于前`i-1` 张已放好的卡片来说 有两种情况 一是重新放一本书 那么前面`i-1` 本就要放`j-1` 本书 而如果前面的`i-1` 张卡片放了`j` 本书 那这第`i` 张卡片就要放在这`j` 本书里 有`j` 种情况
代码：

```
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN=2005;
//dp[i][j]表示i张卡分为j本书的情况数
//dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
long long dp[MAXN][MAXN];
void Init(){
    dp[1][1]=1;
    dp[2][1]=1;
    dp[2][2]=1;
    for(int i=3;i<=2000;i++){
        dp[i][1]=1;
        for(int j=2;j<=i;j++){
            dp[i][j]=(dp[i-1][j-1]+dp[i-1][j]*j)%1000;
            //printf("%lld\n",dp[i][j]);
        }
    }
}
int main(void){
    int n;
    int x;
    Init();
    scanf("%d",&n);
    while(n--){
        scanf("%d",&x);
        long long ans=0;
        for(int i=1;i<=x;i++){
            ans=(ans+dp[x][i])%1000;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```






