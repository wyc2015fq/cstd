# hdu6287——口算训练 - westbrook1998的博客 - CSDN博客





2018年07月24日 23:46:32[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：38








> 
小Q非常喜欢数学，但是他的口算能力非常弱。因此他找到了小T，给了小T一个长度为n的正整数序列a1,a2,…,an，要求小T抛出m个问题以训练他的口算能力。  

  每个问题给出三个正整数l,r,d，小Q需要通过口算快速判断al×al+1×…×ar−1×ar是不是d的倍数。  

  小Q迅速地回答了出来，但是小T并不知道正确答案是什么，请写一个程序帮助小T计算这些问题的正确答案。 

  Input 

  第一行包含一个正整数T(1≤T≤10)，表示测试数据的组数。  

  每组数据第一行包含两个正整数n,m(1≤n,m≤100000)，分别表示序列长度以及问题个数。  

  第二行包含n个正整数a1,a2,…,an(1≤ai≤100000)，表示序列中的每个数。  

  接下来m行，每行三个正整数l,r,d(1≤l≤r≤n,1≤d≤100000)，表示每个问题。 

  Output 

  对于每个问题输出一行，若是倍数，输出Yes，否则输出No。 

  Sample Input 

  1 

  5 4 

  6 4 7 2 5 

  1 2 24 

  1 3 18 

  2 5 17 

  3 5 35 

  Sample Output 

  Yes 

  No 

  No 

  Yes
查找区间的数的乘积是否为所给数的倍数，所以可以考虑分解质因数，然后如果所给的数d所分解的所有任意一个质因数的个数小于等于在区间中该质因数的个数，即可以整除

因此用一个vector数组来保存每个质因数的位置 因为质因数是从小到大枚举的，因此每个vector也就排序了，然后用二分(lower_bound和upper_bound)查找出区间中该质因数的个数，再进行判断

在分解质因数时要注意最后一个数的处理 

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int MAXN=100050;
int n,m;
vector<int> G[MAXN];
//分解第idx个数x的质因数
void solve(int idx,int x){
    for(int i=2;i*i<=x;i++){
        while(x%i==0){
            //表示质因数i存在于第idx这个数里
            G[i].push_back(idx);
            x/=i;
        }
    }
    if(x>1){
        G[x].push_back(idx);
    }
}
//查询[l,r]中x的个数
int query(int l,int r,int x){
    //比如两个数4 6 分解之后g[2]={1,1,2} g[3]={2}表示质因数2存在的位置是第1 1 2个数
    //所以如果查询1 2 4 将4分解为两个2 所以要在g[2]里二分查找第一个大于等于l 1这个位置的
    //和第一个大于r 2这个位置的差值 即这个查询区间中该质因数的个数 如果大于等于d的该质因数
    //个数 即可以被d整除
    return upper_bound(G[x].begin(),G[x].end(),r)-lower_bound(G[x].begin(),G[x].end(),l);
}
int main(void){
    int t;
    scanf("%d",&t);
    while(t--){
        for(int i=1;i<MAXN;i++){
            G[i].clear();
        }
        scanf("%d%d",&n,&m);
        int tmp;
        for(int i=1;i<=n;i++){
            scanf("%d",&tmp);
            //不用保存原数组
            solve(i,tmp);
        }
        //printf("%d\n",query(1,2,7));
        while(m--){
            int l,r,x;
            scanf("%d%d%d",&l,&r,&x);
            bool flag=true;
            for(int i=2;i*i<=x;i++){
                int cnt=0;
                while(x%i==0){
                    cnt++;
                    x/=i;
                }
                if(cnt>query(l,r,i)){
                    flag=false;
                    break;
                }
            }
            //注意分解质因数最后剩下的数的处理
            //如果剩下一个x 那么本身就是这个质因数 所以要是1>query(l,r,x)
            if(flag && x>1 && query(l,r,x)<1){
                flag=false;
            }
            if(flag){
                printf("Yes\n");
            }
            else{
                printf("No\n");
            }
        }
    }
    return 0;
}
```





