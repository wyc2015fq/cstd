# hdu1434——幸福列车 - westbrook1998的博客 - CSDN博客





2018年07月27日 12:42:18[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：30








> 
一批幸福的列车即将从杭州驶向幸福的终点站——温州，身为总列车长的linle有一些奇怪的癖好。  

  他会记录下全部乘客的名字（name）和他们的人品值（RP），根据这些将他们排序，并不时地从某辆列车里踢出人品最不好（RP值最低）的一个人，当两个人人品一样不好时，他就会踢出名字难听的人（linle认为按字典顺序，排在越在后面的人名字越难听）。  

  当然出于列车行驶需要，他还会不时的发布一些命令，比如让某个乘客上车，合并某两辆列车等。  

  linle的上一任秘书***因为不能高效地执行他的这些命令而被炒鱿鱼，他现在正在寻觅新的秘书人选，你能不能胜任呢？（谢绝男士，待遇丰厚~~~）  

  Input 

  本题包含多组测试，请处理到文件结束。  

  对于每一组测试，第一行包含两个整数 N ，M ，表示一共有N( N<=10000 ) 辆列车，执行M( M<=10000 )次操作。  

  接下来有 N （从1开始记数）辆列车的信息，每辆列车先有一个数字 Xi(1 <= Xi <= 100 )，表示该列车有Xi个乘客，接下来Xi行乘客信息，每个乘客包含名字（20个字符以内，不包含空白符）和人品（0<= RP <=30000）。  

  再接下来有 M 行操作信息，一共有3种操作，分别为  

  GETON Xi name RP 表示有一个叫name的人品为RP的人登上第Xi列车  

  JOIN Xi Xj 表示有将第Xj辆列车合并到Xi辆列车  

  GETOUT Xi 表示从第Xi辆列车踢出一个人品最差的人  

  测试数据保证每个操作均合法，即不会将已经被合并到其他列车的列车再进行合并，也不会从一辆空列车里踢出乘客  

  Output 

  对于每个 GETOUT 命令，输出被踢出的那个人的名字  

  Sample Input 

  3 5 

  2 

  xhd 0 

  zl 1 

  2 

  8600 1 

  ll 2 

  1 

  Ignatius 3 

  GETOUT 1 

  JOIN 1 2 

  GETOUT 1 

  GETON 3 hoho 2 

  GETOUT 3 

  Sample Output 

  xhd 

  zl 

  hoho 

   Hint 

  Huge input, scanf is recommended. 
用优先队列暴力模拟一发  

注意积累stl的用法 和结构体 
`priority_queue<> push() top() pop()`
代码：

```
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
const int MAXN=10050;
struct node{
    char name[25];
    int rp;
    //重载小于号 改成大于的比较 这样人品值低的在前面
    bool operator < (const node& x) const{
        return rp>x.rp || (rp==x.rp && strcmp(name,x.name)<0);
    }
};
priority_queue<node> t[MAXN];
int main(void){
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        for(int i=0;i<MAXN;i++){
            while(!t[i].empty()){
                t[i].pop();
            }
        }
        for(int i=1;i<=n;i++){
            int p;
            scanf("%d",&p);
            char name[25];
            int rp;
            for(int j=0;j<p;j++){
                scanf("%s %d",name,&rp);
                node tmp;
                tmp.rp=rp;
                strcpy(tmp.name,name);
                t[i].push(tmp);
            }
        }
        char q[10];
        int k;
        char name[25];
        int rp;
        int a,b;
        while(m--){
            scanf("%s",q);
            if(q[0]=='G'){
                if(q[4]=='U'){
                    scanf("%d",&k);
                    printf("%s\n",t[k].top().name);
                    t[k].pop();
                }
                else if(q[4]=='N'){
                    scanf("%d %s %d",&k,name,&rp);
                    node tmp;
                    tmp.rp=rp;
                    strcpy(tmp.name,name);
                    t[k].push(tmp);
                }
            }
            else if(q[0]=='J'){
                scanf("%d%d",&a,&b);
                while(!t[b].empty()){
                    t[a].push(t[b].top());
                    t[b].pop();
                }
            }
        }
    }
    return 0;
}
```






