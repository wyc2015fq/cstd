# hdu3605——病毒侵袭持续中 - westbrook1998的博客 - CSDN博客





2018年08月26日 19:48:02[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：34








> 
小t非常感谢大家帮忙解决了他的上一个问题。然而病毒侵袭持续中。在小t的不懈努力下，他发现了网路中的“万恶之源”。这是一个庞大的病毒网站，他有着好多好多的病毒，但是这个网站包含的病毒很奇怪，这些病毒的特征码很短，而且只包含“英文大写字符”。当然小t好想好想为民除害，但是小t从来不打没有准备的战争。知己知彼，百战不殆，小t首先要做的是知道这个病毒网站特征：包含多少不同的病毒，每种病毒出现了多少次。大家能再帮帮他吗？ 

  Input 

  第一行，一个整数N（1<=N<=1000），表示病毒特征码的个数。  

  接下来N行，每行表示一个病毒特征码，特征码字符串长度在1—50之间，并且只包含“英文大写字符”。任意两个病毒特征码，不会完全相同。  

  在这之后一行，表示“万恶之源”网站源码，源码字符串长度在2000000之内。字符串中字符都是ASCII码可见字符（不包括回车）。  

  Output 

  按以下格式每行一个，输出每个病毒出现次数。未出现的病毒不需要输出。  

  病毒特征码: 出现次数  

  冒号后有一个空格，按病毒特征码的输入顺序进行输出。  

  Sample Input 

  3 

  AA 

  BB 

  CC 

  ooxxCC%dAAAoen….END 

  Sample Output 

  AA: 2 

  CC: 1 

  Hint 

  Hit： 

  题目描述中没有被提及的所有情况都应该进行考虑。比如两个病毒特征码可能有相互包含或者有重叠的特征码段。 

  计数策略也可一定程度上从Sample中推测。
差不多的题目

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <queue>
#include <iostream>
#include <map>
#include <cstring>
#define _clr(x,a) memset(x,a,sizeof(x));
using namespace std;
string w;
int n;
struct Node{
    int idx;
    int cnt;
    string st;
    Node* fail;
    Node* Next[100];
    Node(){
        idx=0;
        cnt=0;
        st="";
        fail=NULL;
        for(int i=0;i<100;i++){
            Next[i]=NULL;
        }
    }
};
map<int,string> ss;
int res[1005];
Node* root;
void insert(string s,int idx){
    int val;
    int l=s.size();
    Node* p=root;
    for(int i=0;i<l;i++){
        val=s[i]-31;
        if(p->Next[val]==NULL){
            p->Next[val]=new Node();
        }
        p=p->Next[val];
    }
    p->cnt++;
    p->st=s;
    p->idx=idx;
}
void getFail(){
    queue<Node*> q;
    for(int i=0;i<100;i++){
        if(root->Next[i]!=NULL){
            root->Next[i]->fail=root;
            q.push(root->Next[i]);
        }
    }
    while(!q.empty()){
        Node* t=q.front();
        q.pop();
        for(int i=0;i<100;i++){
            if(t->Next[i]!=NULL){
                Node* p=t->fail;
                while(p!=NULL){
                    if(p->Next[i]!=NULL){
                        t->Next[i]->fail=p->Next[i];
                        break;
                    }
                    p=p->fail;
                }
                if(p==NULL){
                    t->Next[i]->fail=root;
                }
                q.push(t->Next[i]);
            }
        }
    }
}   
void search(string s){
    int ans=0;
    if(root==NULL){
        return;
    }
    int l=s.size();
    Node* p=root;
    int val;
    for(int i=0;i<l;i++){
        val=s[i]-31;
        while(!p->Next[val] && p!=root){
            p=p->fail;
        }
        p=p->Next[val];
        if(!p){
            p=root;
        }
        Node* tmp=p;
        while(tmp!=root){
            if(tmp->cnt>0){
                res[tmp->idx]++;
            }
            else{
                break;
            }
            tmp=tmp->fail;
        }
    }
}
void clear(Node* root){
    if(root==NULL){
        return;
    }
    for(int i=0;i<100;i++){
        clear(root->Next[i]);
    }
    root->cnt=0;
    root->idx=0;
    root->fail=NULL;
    delete(root);
}
int main(void){
    //freopen("data.txt","r",stdin);
    while(~scanf("%d",&n)){
        ss.clear();
        _clr(res,0);
        root=new Node();
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            cin >> w;
            ss[i]=w;
            insert(w,i);
        }
        getFail();
        cin >> w;
        search(w);
        for(int i=1;i<=n;i++){
            if(res[i]>0){
                cout << ss[i] << ": " << res[i] << endl;
            }
        }
        clear(root);
    }
    return 0;
}
```





