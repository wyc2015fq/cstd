# hdu2082——找单词 - westbrook1998的博客 - CSDN博客





2018年08月24日 18:16:36[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：43








> 
假设有x1个字母A， x2个字母B,….. x26个字母Z，同时假设字母A的价值为1，字母B的价值为2,….. 字母Z的价值为26。那么，对于给定的字母，可以找到多少价值<=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。  

  Input 

  输入首先是一个整数N，代表测试实例的个数。  

  然后包括N行数据，每行包括26个<=20的整数x1,x2,…..x26.  

  Output 

  对于每个测试实例，请输出能找到的总价值<=50的单词数,每个实例的输出占一行。 

  Sample Input 

  2 

  1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 

  9 2 6 2 10 2 2 5 6 1 0 2 7 0 2 2 7 5 10 6 10 2 10 6 1 9 

  Sample Output 

  7 

  379297
用母函数解法 直接套模板 然后26个多项式相乘这样子

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#define _clr(x,a) memset(x,a,sizeof(x));
using namespace std;
const int N=1000000;
long long tmp[N];
long long ans[N];
int main(void){
    int t;
    scanf("%d",&t);
    while(t--){
        _clr(tmp,0);
        _clr(ans,0);
        ans[0]=1;
        int x;
        for(int i=1;i<=26;i++){
            //各个字母的系数
            scanf("%d",&x);
            for(int j=0;j<=50;j++){
                for(int k=0;k<=x && j+k*i<=50;k++){
                    tmp[j+k*i]+=ans[j];
                }
            }
            for(int j=0;j<=50;j++){
                ans[j]=tmp[j];
                tmp[j]=0;
            }
        }
        long long res=0;
        //系数为0不能加进去
        for(int i=1;i<=50;i++){
            res+=ans[i];
        }
        printf("%lld\n",res);
    }
    return 0;
}
```





