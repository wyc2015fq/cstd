# 单例模式——（饿汉模式和懒汉模式） - westbrook1998的博客 - CSDN博客





2018年02月21日 10:34:17[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：111








```java
package com.zxc.singleton;

/**
 * 单例模式：饿汉模式
 * 饿汉模式，无论用户是否需要，只要类记载就会创建该对象实例，始终处于饥饿模式
 */
public class Singleton1 {
    //1.将构造方法私有化，不允许外部直接创建实例
    private Singleton1(){

    }

    //2.创建类的唯一实例
    private static Singleton1 instance =new Singleton1();

    //3.提供一个用于获取实例的方法
    public static Singleton1 getInstance(){
        return instance;
    }
}
package com.zxc.singleton;

/**
 * 单例模式：懒汉模式
 * 懒汉模式，用户需要时才创建实例
 */
public class Singleton2 {
    //1.将构造方法私有化，不允许外部直接创建实例
    private Singleton2(){

    }

    //2.创建类的唯一实例(并没有实例化)
    private static Singleton2 instance;

    //3.提供一个用于获取实例的方法
    public static Singleton2 getInstance(){
        if(instance==null){
            instance=new Singleton2();
        }
        return instance;
    }
}
package com.zxc.singleton;

public class Test {
    public static void main(String[] args){
        Singleton1 s1=Singleton1.getInstance();
        Singleton1 s2=Singleton1.getInstance();
        if(s1==s2){
            System.out.println("同一个实例");
        }
        else{
            System.out.println("不是同一个实例");
        }

        Singleton2 s3=Singleton2.getInstance();
        Singleton2 s4=Singleton2.getInstance();
        if(s3==s4){
            System.out.println("同一个实例");
        }
        else{
            System.out.println("不是同一个实例");
        }
    }
}
package com.zxc.singleton;

public class ThreadTest extends Thread {
    @Override
    public void run() {
        System.out.println(Singleton1.getInstance());
    }

    public static void main(String[] args){
        ThreadTest[] mts = new ThreadTest[5与];
        for(int i = 0 ; i < mts.length ; i++){
            mts[i] = new ThreadTest();
        }

        for (int j = 0; j < mts.length; j++) {
            mts[j].start();
        }
    }
}
//运行结果：（多线程并发下能实现饿汉模式）
com.zxc.singleton.Singleton1@738fbf8
com.zxc.singleton.Singleton1@738fbf8
com.zxc.singleton.Singleton1@738fbf8
com.zxc.singleton.Singleton1@738fbf8
com.zxc.singleton.Singleton1@738fbf8

package com.zxc.singleton;

public class ThreadTest extends Thread {
    @Override
    public void run() {
        System.out.println(Singleton2.getInstance());
    }

    public static void main(String[] args){
        ThreadTest[] mts = new ThreadTest[5与];
        for(int i = 0 ; i < mts.length ; i++){
            mts[i] = new ThreadTest();
        }

        for (int j = 0; j < mts.length; j++) {
            mts[j].start();
        }
    }
}
//运行结果：（在多线程并发下无法实现懒汉模式）
com.zxc.singleton.Singleton2@46600188
com.zxc.singleton.Singleton2@4922dfac
com.zxc.singleton.Singleton2@38474999
com.zxc.singleton.Singleton2@43d3c565
com.zxc.singleton.Singleton2@7584a80f
```

## 解决方案：使用synchronized关键字

### 同步方法

```java
//3.提供一个用于获取实例的方法
    public synchronized static Singleton2 getInstance(){
        try{
            if(instance==null){
                Thread.sleep(300);
                instance=new Singleton2();
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        return instance;
    }
//可以实现
```

### 同步代码块

```
try{
            synchronized (Singleton2.class){
                if(instance==null){
                    Thread.sleep(300);
                    instance=new Singleton2();
                }
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }
//可以实现
```



