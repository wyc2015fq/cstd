# 数串 - westbrook1998的博客 - CSDN博客





2018年05月08日 15:14:19[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：184








> 
设有n个正整数，将他们连接成一排，组成一个最大的多位整数。 

  如:n=3时，3个整数13,312,343,连成的最大整数为34331213。 

  如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。
本来觉得这题应该是很简单的，但还是踩了很多坑…

首先，这些数字串的排序不能简单的用`sort`或者是`strcmp`，`sort`好像可以，不过要自己写一个比较器，麻烦，而`strcmp`刚开始以为可以，然后一直卡在85%，后来在另一个页面能看到出错的样例，一比较，发现了这样的问题，比如29和291，按题目要求最大的排列应该是29291，但是如果简单按照`strcmp`进行冒泡排序，最终是29129，因为`“291”`比`“29”`大，所以这里需要用到strcat这个函数将两个字符串按不同次序连接再比较，这里又有一个坑就是要把字符串先拷贝到一个`temp`里，再进行连接，不然`strcat`会改变原本的字符串，最后排序完的字符串就通过`sprintf(res,"%s%s",res,arr[i])`进行连接了，完成

代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
char res[400];
char arr[110][6];
int main(void){
    int n;
    while(scanf("%d",&n)!=EOF){
        for(int i=0;i<n;i++){
            scanf("%s",&arr[i]);
        }
        char temp1[7]={'\0'};
        char temp2[7]={'\0'};  
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){ 
                strcpy(temp1,arr[i]);
                strcpy(temp2,arr[j]);
                if(strcmp(strcat(temp1,arr[j]),strcat(temp2,arr[i]))<0){
                    char temp[6];
                    strcpy(temp,arr[i]);
                    strcpy(arr[i],arr[j]);
                    strcpy(arr[j],temp);
                }
            }
        }
        memset(res,'\0',sizeof(res));
        for(int i=0;i<n;i++){
            //printf("%s\n",arr[i]);
            sprintf(res,"%s%s",res,arr[i]);
        }
        printf("%s\n",res);
    }
    return 0;
}
```





