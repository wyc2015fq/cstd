# poj1321——棋盘问题 - westbrook1998的博客 - CSDN博客





2018年06月10日 23:10:11[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：38








> 
在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 

  Input 

  输入含有多组测试数据。  

  每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n  

  当为-1 -1时表示输入结束。  

  随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。  

  Output 

  对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。 

  Sample Input 

  2 1
```
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
Sample Output
2
1
```

比较经典的dfs题目，和八皇后问题相似，不过更简单一点，要注意几个for循环的条件，可以手推一下

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
char map[10][10];
//用于标记第i列是否已经放置棋子
int col[10];
int c;
int n,k;
void dfs(int s,int num){
    //列的遍历
    for(int i=0;i<n;i++){
        //如果是棋盘区域# 而且该列col[i]没有放置才继续
        if(map[s][i]=='#' && col[i]==0){
            //num==1说明到这一行只需要放置一个棋子，即一种情况
            if(num==1){
                c++;
            }
            //否则就是说明还需要继续递归找下去
            else{
                //将这一列标记为已放置棋子
                col[i]=1;
                //遍历剩下的所有行，搜索从j行开始放置num-1个棋子的方法
                //这里暂时不知道要怎么更好的解释，不过可以由实例退出这个for循环条件
                //比如第一次进入for循环，j肯定是1+1=2，而如果n和num相等，即这个循环不可能进行，因为这样的情况只能有一种
                //而如果n比num多1,那j在下面的递归中就有多一种选择，就是这样
                for(int j=s+1;j-2<n-num;j++){
                    dfs(j,num-1);
                }
                //记得要将标记重新置为0
                col[i]=0;
            }
        }
    }
}
int main(void){
    while(~scanf("%d%d",&n,&k)){
    if(n==-1 && k==-1){
            break;
        }
        c=0;
        for(int i=0;i<n;i++){
            scanf("%s",map[i]);
            col[i]=0;
        }
        for(int i=0;i<=n-k;i++){
            //表示从第i行开始放置k个棋子
            dfs(i,k);
        }
        printf("%d\n",c);
    }
    return 0;
}
```





