# hdu2102——A计划 - westbrook1998的博客 - CSDN博客





2018年09月02日 22:11:24[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：24








> 
可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。  

  现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。 

  Input 

  输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N*M（1 <= N,M <=10)。T如上所意。接下去的前N*M表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 

  Output 

  如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 

  Sample Input 

  1 

  5 5 14
```
S*#*.
.#...
.....
****.
...#.
..*.P
#.*..
***..
...*.
*.#..
```

> 
Sample Output 

  YES 

  两层地图的一个广搜 细节还是写的不好 
代码：

```cpp
##includeinclude  <cstdio><cstdio>
 ##includeinclude  <algorithm><algorithm>
#include <cstring>
#include <queue>
using namespace std;
struct node{
    int i,j,k,t;
    node(int _i,int _j,int _k,int _t):i(_i),j(_j),k(_k),t(_t){}
};
const int N=12;
char mp[2][N][N];
int n,m,t;
int pi,pj,pk;
bool vis[2][N][N];
int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
bool check(int i,int j,int k){
    if(i<0 || i>=n || j<0 || j>=m || k<0 || k>=2){
        return false;
    }
    return true;
}
bool bfs(){
    memset(vis,false,sizeof(vis));
    queue<node> q;
    q.push(node(0,0,0,0));
    vis[0][0][0]=true;
    node now(0,0,0,0);
    while(!q.empty()){
        node tmp=q.front();
        q.pop();
        int ti=tmp.i;
        int tj=tmp.j;
        int tk=tmp.k;
        int tt=tmp.t;
        if(tt>t){
            return false;
        }
        if(ti==pi && tj==pj && tk==pk){
            //printf("%d %d %d %d\n",ti,tj,tk,tt);
            return tt<=t;
        }
        for(int i=0;i<4;i++){
            now.i=ti+dir[i][0];
            now.j=tj+dir[i][1];
            now.k=tk;
            if(!vis[tk][now.i][now.j] && check(now.i,now.j,now.k) && mp[tk][now.i][now.j]!='*'){
                now.t=tt+1;
                //printf("%d %d %d\n",ti+a,tj+b,tk);
                if(mp[tk][now.i][now.j]=='#'){
                    now.k=1-now.k;
                    if(vis[now.k][now.i][now.j] || mp[now.k][now.i][now.j]=='*' || mp[now.k][now.i][now.j]=='#'){
                        continue;
                    }
                }
                q.push(now);
                vis[now.k][now.i][now.j]=true;
            }
        }
    }
    return false;
}
int main(void){
    //freopen("data.txt","r",stdin);
    int c;
    scanf("%d",&c);
    while(c--){
        scanf("%d%d%d",&n,&m,&t);
        for(int i=0;i<n;i++){
            scanf("%s",mp[0][i]);
            for(int j=0;j<m;j++){
                if(mp[0][i][j]=='P'){
                    pi=i;
                    pj=j;
                    pk=0;
                }
            }
        }
        for(int i=0;i<n;i++){
            scanf("%s",mp[1][i]);
            for(int j=0;j<m;j++){
                if(mp[1][i][j]=='P'){
                    pi=i;
                    pj=j;
                    pk=1;
                }
            }
        }
        if(bfs()){
            printf("YES\n");
        }
        else{
            printf("NO\n");
        }
    }
    return 0;
}
```







