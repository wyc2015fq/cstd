# hdu2065——"红色病毒"问题 - westbrook1998的博客 - CSDN博客





2018年05月17日 14:31:51[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：51








> 
医学界发现的新病毒因其蔓延速度和Internet上传播的”红色病毒”不相上下,被称为”红色病毒”,经研究发现,该病毒及其变种的DNA的一条单链中,胞嘧啶,腺嘧啶均是成对出现的。  

  现在有一长度为N的字符串,满足一下条件:  

  (1) 字符串仅由A,B,C,D四个字母组成;  

  (2) A出现偶数次(也可以不出现);  

  (3) C出现偶数次(也可以不出现);  

  计算满足条件的字符串个数.  

  当N=2时,所有满足条件的字符串有如下6个:BB,BD,DB,DD,AA,CC.  

  由于这个数据肯能非常庞大,你只要给出最后两位数字即可.  

  Input 

  每组输入的第一行是一个整数T,表示测试实例的个数,下面是T行数据,每行一个整数N(1<=N<2^64),当T=0时结束.  

  Output 

  对于每个测试实例,输出字符串个数的最后两位,每组输出后跟一个空行. 

  Sample Input 

  4 

  1 

  4 

  20 

  11 

  3 

  14 

  24 

  6 

  0 

  Sample Output 

  Case 1: 2 

  Case 2: 72 

  Case 3: 32 

  Case 4: 0 

  Case 1: 56 

  Case 2: 72 

  Case 3: 56
找规律题…也可以又什么泰勒级数什么乱七八糟的得到，或者查询OEIS得到规律 

an=pow(2,n-1)+pow(4,n-1) 

用快速幂取模模板加注意细节
代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
long long pow_mod(long a,long long b,long long mod){
    long long res=1;
    a=a%mod;
    while(b>0){
        if(b%2==1){
            res=(res*a)%mod;
        }
        b/=2;
        a=(a*a)%mod;
    }
    return res;
}
int main(void){
    int t;
    while(~scanf("%d",&t)){
        if(t==0){
            break;
        }
        int c=1;
        while(t--){
            long long n;
            scanf("%lld",&n);
            printf("Case %d: %lld\n",c++,(pow_mod(2,n-1,100)+pow_mod(4,n-1,100))%100);
        }
        printf("\n");
    }
    return 0;
}
```






