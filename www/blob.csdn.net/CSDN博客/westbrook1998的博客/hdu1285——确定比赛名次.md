# hdu1285——确定比赛名次 - westbrook1998的博客 - CSDN博客





2018年08月12日 08:09:05[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：36标签：[拓扑排序																[图论](https://so.csdn.net/so/search/s.do?q=图论&t=blog)](https://so.csdn.net/so/search/s.do?q=拓扑排序&t=blog)
个人分类：[ACM练习题](https://blog.csdn.net/westbrook1998/article/category/7652684)








> 
有N个比赛队（1<=N<=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。  

  Input 

  输入有若干组，每组中的第一行为二个数N（1<=N<=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。  

  Output 

  给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。  

  其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。  

  Sample Input 

  4 3 

  1 2 

  2 3 

  4 3 

  Sample Output 

  1 2 4 3
新学了这个拓扑排序的两个模板，感觉还是网上这个比较好理解，紫书的dfs好像不太适用这题 

其实拓扑排序就是一直不断找出入度最小的点，排在前面，然后减少他所连的其他点的入度

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=510;
int map[MAXN][MAXN];
//各个节点的入度，即前驱元，即是否有元素在他前面
int indegree[MAXN];
int topo[MAXN];
int n,m,a,b;
void toposort(){
    int k=0;
    int t=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            //找前驱元为0的点
            if(indegree[j]==0){
                k=j;
                break;
            }
        }
        //printf("%d\n",k);
        topo[t++]=k;
        //已经加入拓扑排序，将入度置为-1，也就是将这个点删除
        indegree[k]=-1;
        for(int j=1;j<=n;j++){
            //所以要将这个点以下的点入度减1
            if(map[k][j]){
                indegree[j]--;
            }
        }
    }
}
int main(void){
    while(~scanf("%d%d",&n,&m)){
        memset(indegree,0,sizeof(indegree));
        memset(map,0,sizeof(map));
        while(m--){
            scanf("%d%d",&a,&b);
            //避免重边输入 导致入度错误
            if(map[a][b]==0){
                map[a][b]=1;
                indegree[b]++;
            }
        }
        toposort();
        for(int i=0;i<n-1;i++){
            printf("%d ",topo[i]);
        }
        printf("%d\n",topo[n-1]);
    }
    return 0;
}
```






