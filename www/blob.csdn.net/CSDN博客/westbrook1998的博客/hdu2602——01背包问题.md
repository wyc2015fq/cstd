# hdu2602——01背包问题 - westbrook1998的博客 - CSDN博客





2018年02月19日 18:57:37[westbrook1998](https://me.csdn.net/westbrook1998)阅读数：67








## 题目：

> 
Problem Description 

  Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave … 

  The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ? 
Input 

  The first line contain a integer T , the number of cases. 

  Followed by T cases , each case three lines , the first line contain two integer N , V, (N <= 1000 , V <= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.
Output 

  One integer per line representing the maximum of the total value (this number will be less than 231).

Sample Input 

  1 

  5 10 

  1 2 3 4 5 

  5 4 3 2 1  
Sample Output 

  14  

Author 

  Teddy  

## 题解：

```cpp
#include <stdio.h>
#include <string.h>
int dp[1001][1001];
int max(int x,int y)
{
    return (x>y?x:y);
}
int main(void)
{
    int t,n,v,i,j;
    int  val[1001],vol[1001];
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&v);
        for(i=1;i<=n;i++)
            scanf("%d",&val[i]);
        for(i=1;i<=n;i++)
            scanf("%d",&vol[i]);
        memset(dp,0,sizeof(dp));
        for(i=1;i<=n;i++)  //记录对应n个骨头在v体积下的最大价值
        {
            for(j=0;j<=v;j++)
            {
                if(vol[i]<=j)
                    dp[i][j]=max(dp[i-1][j],dp[i-1][j-vol[i]]+val[i]);
                    //选择（不放入第五个骨头  或者  先放入第五个骨头）的最大值
                    //如果先放入第五个骨头，即第五个的价值（val[ i ]）加上
                    //减去第五个剩下的空间  [ j-vol[ i ] ]所能得到的最大价值dp[ i-1 ][ j-vol[ i ] ]
                else    
                    dp[i][j]=dp[i-1][j];   
                    //如果当前一个骨头体积就大于总体积，舍弃该骨头，所以该点价值等于上一个i的点的价值

                //两种情况其实可以一起理解，只是当vol[i]>j，就不会存在先放入该骨头的情况，因为如果放入这一个，体积已经满了
            }
        }
        printf("%d\n",dp[n][v]);
    }
    return 0;
}
```

![这里写图片描述](https://img-blog.csdn.net/20180219185646797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VzdGJyb29rMTk5OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

纠结了一个早上才差不多想清楚这种背包问题o(╯□╰)o，怕不是个智障







