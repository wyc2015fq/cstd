# 补码运算 - nosmatch的专栏 - CSDN博客
2010年03月28日 09:29:00[nosmatch](https://me.csdn.net/HDUTigerkin)阅读数：1444
补码(two's complement)
1、在计算机系统中，数值一律用补码来表示（存储）。
　　主要原因：使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理。另外，两个用补
　　码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。
　　2、补码与原码的转换过程几乎是相同的。
　　求给定数值的补码表示分以下两种情况：
（1）正数的补码：与原码相同。
　　【例1】+9的补码是00001001。
（2）负数的补码：符号位为1，其余位为该数绝对值的原码按位取反；然后整个数加1。
　　【例2】求-7的补码。
　　因为给定数是负数，则符号位为“1”。
　　后七位：+7的原码（0000111）→按位取反（1111000）→加1（1111001）
　　所以-7的补码是11111001。
　　已知一个数的补码，求原码的操作分两种情况：
　　（1）如果补码的符号位为“0”，表示是一个正数，其原码就是补码。
　　（2）如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。
　　【例3】已知一个补码为11111001，则原码是10000111（-7）。
　　因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。
　　其余七位1111001取反后为0000110；
　　再加1，所以是10000111。
　　在“闲扯原码、反码、补码”文件中，没有提到一个很重要的概念“模”。我在这里稍微介绍一下“模”
　　的概念：
　　“模”是指一个计量系统的计数范围。如时钟等。计算机也可以看成一个计量机器，它也有一个计量范
　　围，即都存在一个“模”。例如：
　　时钟的计量范围是0～11，模=12。
　　表示n位的计算机计量范围是0～2^(n)-1，模=2^(n)。
　　“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的
　　余数。任何有模的计量器，均可化减法为加法运算。
　　例如： 假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：
　　一种是倒拨4小时，即：10-4=6
　　另一种是顺拨8小时：10+8=12+6=6
　　在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。
　　对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特
　　性。共同的特点是两者相加等于模。
　　对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再
　　加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的
　　模为2^8。 在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以
　　了。把补数用到计算机对数的处理上，就是补码。
　　另外两个概念
　　一的补码(one's complement) 指的是正数=原码,负数=反码
　　而二的补码(two's complement) 指的就是通常所指的补码。
3.补码的绝对值（称为真值）
　　【例4】-65的补码是10111111
　　若直接将10111111转换成十进制，发现结果并不是-65，而是191。
　　事实上，在计算机内，如果是一个二进制数，其最左边的位是1，则我们可以判定它为负数，并且是用补码表示。
　　若要得到一个负二进制数的绝对值（称为真值），只要各位（包括符号位）取反，再加1，就得到真值。
　　如：二进制值：10111111（-65的补码）
　　各位取反：01000000
　　加1：01000001（+65的补码）
　　这里补充补码的代数加减运算：
　　1、补码加法
　　[X+Y]补 = [X]补 + [Y]补
　　【例5】X=+0110011,Y=-0101001，求[X+Y]补
　　[X]补=00110011 [Y]补=11010111
　　[X+Y]补 = [X]补 + [Y]补 = 00110011+11010111=00001010
　　注：因为计算机中运算器的位长是固定的，上述运算中产生的最高位进位将丢掉，所以结果不是
　　100001010，而是00001010。
　　2、补码减法
　　[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补
　　其中[-Y]补称为负补，求负补的方法是：所有位（包括符号位）按位取反；然后整个数加1。
　　【例6】1+（-1） [十进制]
　　1的原码00000001 转换成补码：00000001
　　-1的原码10000001 转换成补码：11111111
　　1+（-1）=0
　　00000001+111111111=00000000
　　00000000转换成十进制为0
　　0=0所以运算正确。
　　这里补充补码的代数解释：
　　任何一个数都可以表示为-a=2^(n-1)-2^(n-1)-a;
　　这个假设a为正数，那么-a就是负数。而根据二进制转十进制数的方法，我们可以把a表示为：a=k0*2^0+k1*2^1+k2*2^2+……+k(n-2)*2^(n-2)
　　这里k0,k1,k2,k(n-2)是1或者0，而且这里设a的二进制位数为n位，即其模为2^(n-1),而2^(n-1)其二项展开是:1+2^0+2^1+2^2+……+2^(n-2)，而式子：-a=2^(n-1)-2^(n-1)-a中，2^(n-1)-a代入a=k0*2^0+k1*2^1+k2*2^2+……+k(n-2)*2^(n-2)和2^(n-1)=1+2^0+2^1+2^2+……+2^(n-2)两式，2^(n-1)-a＝(1-k(n-2))*2^(n-2)+(1-k(n-3))*2^(n-3)+……+(1-k2)*2^2+(1-k1)*2^1+(1-k0)*2^0+1,而这步转化正是取反再加1的规则的代数原理所在。因为这里k0,k1,k2,k3……不是0就是1，所以1－k0,1-k1,1-k2的运算就是二进制下的取反，而为什么要加1，追溯起来就是2^(n-1)的二项展开式最后还有一项1的缘故。而-a=2^(n-1)-2^(n-1)-a中，还有-2^(n-1)这项未解释，这项就是补码里首位的1，首位1在转化为十进制时要乘上2^(n-1)，这正是n位二进制的模。
