# 一条进程的栈区、堆区、数据区和代码区在内存中的映射 - nosmatch的专栏 - CSDN博客
2011年10月22日 16:01:56[nosmatch](https://me.csdn.net/HDUTigerkin)阅读数：426标签：[delete](https://so.csdn.net/so/search/s.do?q=delete&t=blog)
栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。
堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你能够 free和delete它们。
数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。
注意：
1）     堆向高内存地址生长；
2）     栈向低内存地址生长；
3）     堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。
**1、一条进程在内存中的映射**
    假设现在有一个程序，它的函数调用顺序如下：
**main(...) ->; func_1(...) ->; func_2(...) ->; func_3(...)**，即：主函数main调用函数func_1; 函数func_1调用函数func_2; 函数func_2调用函数func_3。
当一个程序被操作系统调入内存运行, 其对应的进程在内存中的映射如下图所示：
![](http://hi.csdn.net/attachment/201110/22/0_13192704997r7F.gif)
注意：
         随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的；
         随着进程中函数调用层数的减少（即各函数调用的返回），栈帧会一块块地被遗弃而向内存的高址方向回缩；
         各函数的栈帧大小随着函数的性质的不同而不等, 由函数的局部变量的数目决定。 
         未初始化数据区(BSS)：用于存放程序的静态变量，这部分内存都是被初始化为零的；而初始化数据区用于存放可执行文件里的初始化数据。这两个区统称为数据区。
         Text(代码区)：是个只读区，存放了程序的代码。任何尝试对该区的写操作会导致段违法出错。代码区是被多个运行该可执行文件的进程所共享的。   
         进程对内存的动态申请是发生在Heap(堆)里的。随着系统动态分配给进程的内存数量的增加，Heap(堆)有可能向高址或低址延伸, 这依赖于不同CPU的实现，但一般来说是向内存的高地址方向增长的。 
         在未初始化数据区（BSS）或者Stack(栈区)的增长耗尽了系统分配给进程的自由内存的情况下，进程将会被阻塞, 重新被操作系统用更大的内存模块来调度运行。
          函数的栈帧：包含了函数的参数(至于被调用函数的参数是放在调用函数的栈帧还是被调用函数栈帧, 则依赖于不同系统的实现)。函数的栈帧中的局部变量以及恢复该函数的主调函数的栈帧(即前一个栈帧)所需要的数据, 包含了主调函数的下一条执行指令的地址。
**2、  函数的栈帧**
函数调用时所建立的栈帧包含下面的信息：
1）     函数的返回地址。返回地址是存放在主调函数的栈帧还是被调用函数的栈帧里，取决于不同系统的实现；
2）     主调函数的栈帧信息, 即栈顶和栈底；
3）     为函数的局部变量分配的栈空间；
4）     为被调用函数的参数分配的空间取决于不同系统的实现。
注意：
         BSS区（未初始化数据段）：并不给该段的数据分配空间，仅仅是记录了数据所需空间的大小。
         DATA（初始化的数据段）：为数据分配空间，数据保存在目标文件中。
