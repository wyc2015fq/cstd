# 局部类和嵌套类(类定义中包含类定义) - nosmatch的专栏 - CSDN博客
2012年05月15日 15:13:06[nosmatch](https://me.csdn.net/HDUTigerkin)阅读数：7271
**局部类**
　　在一个函数体内定义的类称为局部类。局部类中只能使用它的外围作用域中的对象和函数进行联系，因为外围作用域中的变量与该局部类的对象无关。局部类不能被外部所继承。在定义局部类时需要注意：局部类中不能说明静态成员函数，并且所有成员函数都必须定义在类体内。在实践中，局部类是很少使用的。下面是一个局部类的例子。
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)int a;
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)void fun()
![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)staticint s;
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)class A
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)public:
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)void init(int i) ![](http://www.cppblog.com/Images/dot.gif){ s = i; }
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif)　　};
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)　　A m;
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)　　m.init(10);
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)　　}
局部类的另一个用途是用来实现类型转化，如下代码：
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)class Interface
![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)public:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)virtualvoid Fun() =0;  
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)};
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)template <class T, class P>
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)Interface* MakeAdapter(const T& obj, const P& arg)
![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)int x;
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)class Local : public Interface
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)public:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)      Local(const T& obj, const P& arg)
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)         : obj_(obj), arg_(arg) ![](http://www.cppblog.com/Images/dot.gif){}
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)virtualvoid Fun()
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)          x =100;
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)         obj_.Call(arg_);
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif)      }
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)private:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)      T obj_;
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)      P arg_;
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif)   };
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)returnnew Local(obj, arg);
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)}
**嵌套类**
　　在一个类中定义的类称为嵌套类，定义嵌套类的类称为外围类。
　　定义嵌套类的目的在于隐藏类名，减少全局的标识符，从而限制用户能否使用该类建立对象。这样可以提高类的抽象能力，并且强调了两个类(外围类和嵌套类)之间的主从关系。下面是一个嵌套类的例子：
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)class A
![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)public:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)class B
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif)![](http://www.cppblog.com/Images/OutliningIndicators/ContractedSubBlock.gif)![](http://www.cppblog.com/Images/dot.gif){
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)public:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)　　　　　　…
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)private:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)　　　　　　…
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif)　　　　};
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)void f();
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)private:
![](http://www.cppblog.com/Images/OutliningIndicators/InBlock.gif)int a;
![](http://www.cppblog.com/Images/OutliningIndicators/ExpandedBlockEnd.gif)　　}
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)
![](http://www.cppblog.com/Images/OutliningIndicators/None.gif)
　　　其中，类B是一个嵌套类，类A是外围类，类B定义在类A的类体内。
　　对嵌套类的若干说明：
　　1、从作用域的角度看，嵌套类被隐藏在外围类之中，该类名只能在外围类中使用。如果在外围类的作用域内使用该类名时，需要加名字限定。
　　2、从访问权限的角度来看，嵌套类名与它的外围类的对象成员名具有相同的访问权限规则。不能访问嵌套类的对象中的私有成员函数，也不能对外围类的私有部分中的嵌套类建立对象。
　　3、嵌套类中的成员函数可以在它的类体外定义。
　　4、嵌套类中说明的成员不是外围类中对象的成员，反之亦然。嵌套类的成员函数对外围类的成员没有访问权，反之亦然。国此，在分析嵌套类与外围类的成员访问关系时，往往把嵌套类看作非嵌套类来处理。这样，上述的嵌套类可写成如下格式：
　　class A
　　{
　　public:
　　　　void f();
　　private:
　　　　int a;
　　};
　　　　class B
　　{
　　　　public:
　　　　…
　　private:
　　　　…
　　};
　　由引可见，嵌套类仅仅是语法上的嵌入。
　　5、在嵌套类中说明的友元对外围类的成员没有访问权。
　　6、如果嵌套类比较复杂，可以只在外围类中对嵌套类进行说明，关于嵌套的详细的内容可在外围类体外的文件域中进行定义。
