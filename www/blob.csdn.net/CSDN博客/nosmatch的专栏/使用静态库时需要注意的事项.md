# 使用静态库时需要注意的事项 - nosmatch的专栏 - CSDN博客
2012年05月31日 19:09:38[nosmatch](https://me.csdn.net/HDUTigerkin)阅读数：1049
转载：
在linux下c++开发时, 使用静态库时编译时需要注意如下:
**编译时静态库一定要放在最后。**
如：(在-o后面)
gcc test.cpp –o test.exe libexample.a
**使用静态库时一定要连接所有用到的静态库**
如要使用libwinkeemq-cpp.a,由于libwinkeemq-cpp.a用到了libactivemq-cpp.a，
而libactivemq-cpp.a又用到了libpthread.a, libuuid.a等等库,在编译时需要连接所有的库
gcc test.cpp –o test.exe libwinkeemq-cpp.a lib libactivemq-cpp.a libpthrea.a libuuid.a…
**静态库动态库相结合使用**
上面的编译命令可以精简为
gcc test.cpp –L/usr/local/lib –lactivemq-cpp –o test.exe libwinkeemq-cpp.a
**注意多个连接静态库的顺序**
规则：越底层的库放在越后面
如：libactivemq-cpp.a比libwinkeemq-cpp.a更底层
gcc test.cpp –o test libwinkeemq-cpp.a libactivemq-cpp.a…
转载：
    这几天在弄一个东西，相同的文件编译的动态库和静态库，调用动态库没有问题，调用静态库确报错：函数没有定义就引用（undefined reference to ***）。让我无比的郁闷，两个库文件一模一样都是相同的.o文件编译出来的，就是静态库调用的时候报错，而动态库完全正常，无比让人抓狂。
    埋头试了n久结果在一个不经意间发现了问题的所在，无比让人抓狂！！！！！
下面是一个简单的例子，有几个简单的程序文件：bill.c fred.c   lib.h   program.c（这个是主文件）
```
//bill.c
```
```
#include <stdio.h>
void bill(char *arg)
{
    printf("bill: you passed %s/n", arg);
}
```
```
//fred.c
```
```
#include <stdio.h>
void fred(int arg)
{
    printf("fred: you passed %d/n", arg);
}
```
//lib.h
void bill(char *);
void fred(int);
```
//program.c
```
```
#include "lib.h"
int main()
{
    bill("Hello Wold!/n");
    exit(0);
}
```
     总共四个文件，用gcc命令编译bill.c fred.c两个文件成动态库
$ gcc -c bill.c fred.c
$ ar -crv libfoo. bill.o fred.o
    然后编译program.c调用libfoo.a进行链接，看看俩个效果吧，先来正确的，注意program.c libfoo.a的位置：
$ gcc -o test program.c libfoo.a
program.c: 在函数‘main’中:
program.c:6: 警告：隐式声明与内建函数‘exit’不兼容
   下面是链接报错的，其他都一样，只是mian函数文件和静态库文件位置调换了一下，立马报错：
]$ gcc -o test libfoo.a
program.c
program.c: 在函数‘main’中:
program.c:6: 警告：隐式声明与内建函数‘exit’不兼容
/tmp/cc88fWhl.o: In function `main':
program.c:(.text+0x19): undefined reference to `bill'
collect2: ld 返回 1
    这么一个小小的问题害我迷茫了两天，我靠，看来还是要养成好习惯：**永远把含有mian函数的主文件放在编译命令的第二位（第一是定义输入文件名）那就不会出错了。或者是永远把库文件放在编译链接命令的最后。**
**心吧飞梦：**
**1、用静态库编译程序时，需要连接曾经用到的所有静态库，顺序从新到旧；**
**2、编译动态库时，不需要指定其他库的库文件路径，只需要指定其他库的头文件路径即可；**
**3、在生成可执行程序时，需要指定所有动态静态库路径，动态库顺序是从旧到新（越底层越前面），静态库顺序是从新到旧（越底层越后面），总的来说动态库放到静态库前面；**
**4、生成可执行程序时，直接用到的头文件必须包含，涉及的所有库必须包含。**
