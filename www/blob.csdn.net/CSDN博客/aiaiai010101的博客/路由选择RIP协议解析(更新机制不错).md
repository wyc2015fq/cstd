# 路由选择RIP协议解析(更新机制不错) - aiaiai010101的博客 - CSDN博客

2018年11月06日 16:38:28[aiaiai010101](https://me.csdn.net/aiaiai010101)阅读数：73



   这篇对于RIP中路由信息的更新机制说的比较好。可以知道路由器不是单纯选择跳数少的，而是还得考虑到时间因素，同一个相邻路由器两次发来的信息，选择时间上最近的，不是跳数少的。
  
本文转载自：https://blog.csdn.net/qq_33452263/article/details/52109202				
								            
						

# RIP协议解析

## 关于理想路由选择协议的特点：

- 正确性和完整性：沿路由表所指引的路由一定能达到目的网络和目的主机
- 算法简单：不应使网络通信量增加太多额外开销
- 适应通信量和网络拓扑的变化：自适应的改变路由均衡各链路的负载，发生故障或者修理好重运营时能及时的改变路由
- 稳定性：在通信量和网络拓普相对稳定情况下，算法收敛于一个可接受的解
- 公平性：除对少数优先级高的用户都是平等的
- 最佳：某一特定要求下得出的较为合理的选择

## 因此我们将能否根据网络拓扑自适应调整分为静态路由选择策略和静态路由选择策略，因特网采用的是动态，分布式路由选择协议，将互联网分为许多较小的自治系统，记为AS

AS:单一技术管理下的一组路由器，而这些路由器使用AS内部的路由选择协议和共同度量确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由，一个AS对其他AS表现出的是一个单一的和一致的路由选择策略，因此路由选择协议可以分为两大类即
内部网关协议IGP和外部网关协议EGP

![](https://img-blog.csdn.net/20160804010838686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**这里我们先讨论内部网关协议RIP**

- **概念**：RIP协议是一种[内部网关协议](http://baike.baidu.com/view/706465.htm)（IGP），是一种[动态路由选择](http://baike.baidu.com/view/771594.htm)协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的[路由器](http://baike.baidu.com/view/1360.htm)只关心自己周围的[世界](http://baike.baidu.com/subview/8083/7031108.htm)，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了
- **工作原理：**RIP通过广播UDP报文来交换路由信息，每30秒发送一次路由信息更新。RIP提供跳跃计数(hopcount)作为尺度来衡量路由距离，跳跃计数是一个包到达目标所必须经过的路由器的数目。如果到相同目标有二个不等速或不同带宽的路由器，但跳跃计数相同，则RIP认为两个路由是等距离的。RIP最多支持的[跳数](http://baike.baidu.com/view/1421578.htm)为15，即在源和目的网间所要经过的最多路由器的数目为15，跳数16表示不可达。
- **距离向量算法**

**首先来看RIP协议报文格式：**

**![](https://img-blog.csdn.net/20160804012036469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)**

RIP距离向量算法；对每一个相邻路由器发过来的RIP报文进行如下操作

1把 “下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1，每一个项目都 有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X;. 

(便于进行本路由表的更新，假设从位于地址X发来的相邻路由器发来的RIP报文某一个项目是"NET2 ,3, Y",意思是：我经过路由器Y到NET2的距离是3，那么本路由器可推断出，我通过X路由器到达NET2的距离应该是3+1=4)
2对修改后的RIP报文中的每一个项目，进行下述步骤：
若原来的路由表中没有目的  网络N，则把该项目添加到路由表中，否则查看下一跳路由器地址;

(表明这是新的网络，应该加入路由表)

若下一跳路由器地 址是X，则把收到的项目替换原路由表中的项目;

(为什么要替换？，要以最新的地址为准，到目的网络的距离可能增大也可能减小，所以应该以最新的更新)

否则若收到的项目中的距离d小于路 由表中的距离，则进行更新，否则，什么也不做。 

(例如若路由表已有项目"NET2 ,5,P",就要更新为："NET2,4,X",因为距离从5变到4更短了,)
3若三分钟没有收到相邻的路由器的更新路由表，则把相邻路由器记为不可达路由器,即把距离置为16（距离为16表示不可达）。      
4      返回。

流程如下如：

![](https://img-blog.csdn.net/20160804014111806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。
- RIP协议存在的一个问题是：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。以图2为例，设三个路由器都已经建立了各自的路由表，现在路由器R1和网1的连接线路短开。路由器R1发现后，将到网1的距离改为16，并将此信息发给路由器R2。由于路由器R3发给R2的信息是：“到网1经过R2距离为2”，于是R2将此项目更新为“到网1经过R3距离为3”，发给R3。R3再发给R2信息：“到网1经过肉距离为4”。这样一直到距离增大到16时，R2和R3才知道网1是不可达的。RIP协议的这一特点叫做：好消息传播得快，而坏消息传播得慢。像这种网络出故障的传播时间往往需要较长的时间，这是RIP的一个主要缺点。![](https://img-blog.csdn.net/20160804014711177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**个人总结： 本文关于RIP的路由信息更新机制说的不错，注意对于接收到的路由信息，路由器是如何处理的，如果数据库中没有此路由信息中包含的目标IP地址记录，那就把这个路由信息加上去。如果有这个目标IP地址了，不是简单地比较跳数然后选小的更新记录，比较跳数选小的方法有个前提，那就是新收到的信息与之前记录不是同一个路由器发过来的。如果两次是同一个路由器发的，那么不是选择小的，而是选择时间上更新的，哪怕更新的跳数更多。**

