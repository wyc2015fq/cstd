# 两个组合优化问题及算法 - aiaiai010101的博客 - CSDN博客

2017年07月23日 20:44:05[aiaiai010101](https://me.csdn.net/aiaiai010101)阅读数：3491
个人分类：[C++](https://blog.csdn.net/aiaiai010101/article/category/6791855)



最近看到两道编程题,有点意思,不过网上看了一下,虽然有一些人写出了算法,但是感觉算法思想表述的都不够清晰,特别是都是直接上结论,然后证明这么做是对的。

我不大喜欢这种表述方式,尝试着以更容易理解的"顺向思维",没错,不是什么"逆向思维",就是正常的思路来推导一下求解过程.

①把数组排成最小的数

输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组{32, 321}，则输出这两个能排成的最小数字32132。

http://blog.csdn.net/wuzhekai1985/article/details/6704902已经给出了算法过程,并且证明了算法是对的,这算法就是定义a与b的大小关系,若ab<ba,则a<b.然后按照这种定义的顺序把最小的排在最前边就行了.

那么,我们是如何想到这种算法的呢？

首先随便写出一个方案,我们考察这个方案是否能够优化,如果能应该怎么做？

比如给定一个方案bca,我们考虑这个数字能否通过优化变得更小呢？

考虑最简单易行的优化方式----相邻元素交换,如果bca的前两位交换顺序变为cba之后整个数字变小了,那么应该满足什么条件呢？显然,cb<bc即可,那么进一步思考,倘若按照这种规则,凡是相邻元素a,b满足ba<ab就交换顺序变为ab,这样得到的方案是否是最佳方案呢？

倘若是最佳方案,由于最佳方案只有一个,那么这必须要求凡是按照这个原则,任意方案的调整最终都只能变为同一个方案,这时很容易想起“冒泡排序法”,没错,无论什么数列,按照冒泡排序都会变为递增数列,但是冒泡排序法之所以可行,在于比较原则具有传递性,换言之,a<b,而b<c,那么a一定小于c,这保证了最小的元素一定被顶到最前面。

如果本问题中的比较原则也具有传递性,那么任意方案按照“相邻元素调整”的原则进行调整,最后的方案一定是像冒泡排序法一样,"最小的元素"在最前边,按顺序排列,换言之,最终方案顺序具有唯一性.

http://blog.csdn.net/wuzhekai1985/article/details/6704902证明了本问题中的比较也是具有传递性的,换言之,若ab<ba,bc<cb,那么一定有ac<ca.因为比较具有传递性,所以才有“最小的元素”这一说.

这样便可以证明,任意方案都可以在遵循我们制定的比较原则的前提下,通过相邻调整,得到唯一的方案,而相邻调整的过程中,数值是不断变小的.也就是说,这个唯一方案的值小于任一方案.

那么这个唯一方案就是最小的方案.

这问题是个组合优化问题,本质上是一个排序问题。

②资源调度问题

有一台机器，上面有m个储存空间。然后有n个请求，第i个请求计算时需要占 R[i]个空间，储存计算结果则需要占据O[i]个空间（据O[i]个空间（其中O[i]<R[i]）。问怎么安排这n个请求的顺序，使得所有请求都能完成。你的算法也应该能够判断出无论如何都不能处理完的情况。

这个问题乍一看有点晕,差点准备用回溯法配合剪枝函数做了,不过那样效率就相当低下了.

依然是考虑最优组合,okay,还是先给定一个方案,a,b,c,d,e,考虑这个方案能否进一步优化?

依然是通过相邻元素调整来进行优化尝试,先说一下这个问题中,什么叫“更优”,倘若方案A可行,而方案B不可行,那自然是A更优,不过这定义未免过于严格,很难这么泾渭分明,一步达到,若AB都可行,那谁更优呢?

我们给出更优的定义：A可行的可能性比B大.

当然了,本问题也不是概率题,算不出各种方案的概率,这里的可能性大的意思是,若A不可行则B必然不可行.则称为A比B更优.

回到原方案,假设调整了i和j(这两步是相邻的),使得整个方案更优了,那么我们需要考虑这要满足什么条件呢？

进行到i-1这一步的时候剩余空间为M,那么i,j可行意味着：M-O[i]>R[j],即O[i]+R[j]<M.

调整为j,i之后,j之前的步骤没有变化,所以剩余空间还是M,那么j,i可行意味着：M-O[j]>R[i],即O[j]+R[i]<M.

倘若变得更优了,即表示当j,i不可行的时候i,j一定不可行.

这意味着若O[j]+R[i]>M,一定有O[i]+R[j]>M.

i和j什么条件能让这件事情成为必然呢？显然只要O[i]+R[j]>O[j]+R[i]即可,换言之,O[i]-R[i]>O[j]-R[j]即可,定义L[p]=O[p]-R[p],则L[i]>L[j]即可.

这么一来就好办了,把任意方案按照这个原则进行相邻调整,得到的方案一定“越来越优秀”,与上一个问题一样,所有方案都这样调整会“殊途同归”吗？

很显然,本问题的这种比较原则具有传递性,即L[a]<L[b],L[b]<L[c],则一定有L[a]<L[c].

所以任一方案根据L[i]和L[j]的大小进行相邻调整最终得到的方案一定是唯一的,那便是L值由小到大的排列顺序的方案,若此方案不可行,其他方案一定不可行.

此方案即为最佳方案.

可以看到,以上这两个问题其实都是利用相邻元素调整,寻找其中的规律,来直接得到最优方案的,颇多相似之处,一旦找到规律,组合优化就变成了排序问题.

