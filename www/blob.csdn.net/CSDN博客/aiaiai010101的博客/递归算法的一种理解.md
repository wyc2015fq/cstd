# 递归算法的一种理解 - aiaiai010101的博客 - CSDN博客

2017年06月30日 19:13:47[aiaiai010101](https://me.csdn.net/aiaiai010101)阅读数：153



**我的感觉：**

**之前因为一提到递归就是想到斐波那契数列，就认为递归就是每次都返回一个结果，让上一层的使用，但是里面到底是咋一层层的机制并没有搞清楚，今天看了几篇博客之后，有点感觉了，所以成文。**

**递归我们总是说直接或者间接的调用自己，可是这句话永远都是会说，但是自己却没有理解。**

**现在我的想法是可以把递归的调用当成是调用别的函数，因为函数调用的机制是，例如main（）调用其他一个函数sort（）吧，就是先把当前的环境，变量都压入一个栈里保存起来，等sor（）运行完之后，再从栈中取回原来的那些东西，继续往下执行。因此啊 我们可以把函数的递归调用想象成一个函数调用另一个函数，只不过呢是这两个函数完全一样，不一样的地方在于，不一样的输入，不一样的过程，上一个函数总是把调用函数之前的一切压入栈中，还有就是不同的函数调用只是两个函数，而递归调用的函数可能会多一些，大部分都会多，当然如果太多就会造成栈的益处，这也是递归调用的缺点所在。**

**函数调用之前的语句是从上到下的，函数调用之后的语句呢是从下到上的，因为后面的语句肯定要等最下层或者最里面最后调用的那个函数执行之后不再调用了开始执行，然后返回上一层的时候再执行上一层函数调用后面的语句。并且特别注意的是，每次函数返回后直接就是函数调用后面的语句。**

**递归其实就是利用了函数调用的一些特点，很巧妙的不断调用自己，把一个很大的问题分成了很多部分，让每一个函数解决一部分，并且上一层的结果编译器给我们保留了起来，返回的时候还能用。所以递归调用一定要是每深入一层都会把问题变得越来越小，而且最后能解决，不然就会无限制的调用自己，形成一个无限的循环，最后造成栈的溢出，最后程序崩溃。**

**所以使用递归我觉得要注意两点：第一是不是把问题变小了，而且每个问题解决之道是相似的，只是每次输入变小，但是输入的形式上是一样的。第二这个问题到最后是能解决的，也就是说这个循环的递归调用得有一个最终的结果，最后得跳出来，不能调用起来没完没了。**

**还有一个感觉就是吧，递归不能说是一个方法而是一个想法，把一个很大的问题，重复的分解很多小的问题，最后解决掉。有的递归是一种数学推理公式上的递归，比如斐波那契数列，比如动态规划，还有的是[数据结构](http://lib.csdn.net/base/31)方面就是递归定义的，如二叉树的定义，前中后序的遍历啊，等等**

**总结就是:**

１　每一次函数调用都会有一次返回．当程序流执行到某一级递归的结尾处时，它会转移到前一级递归紧接着的后面继续执行．

２　递归函数中，位于递归调用前的语句和各级被调函数具有相同的顺序．如打印语句 #1 位于递归调用语句前，它按照递归调用的顺序被执行了 4 次．

３　每一级的函数调用都有自己的私有变量．

４　递归函数中，位于递归调用语句后的语句的执行顺序和各个被调用函数的顺序相反．

５　虽然每一级递归有自己的变量，但是函数代码并不会得到复制．

６　递归函数中必须包含可以终止递归调用的语句．

下面是个关于递归调用简单但是很能说明问题的例子：

**[cpp]**[view
 plain](http://blog.csdn.net/t0nsha/article/details/5705641#)[copy](http://blog.csdn.net/t0nsha/article/details/5705641#)

- /*递归例子*/
- #include<stdio.h>
- void up_and_down(int);  
- int main(void)  
- {  
-     up_and_down(1);  
- return 0;  
- }  
- void up_and_down(int n)  
- {  
-     printf("Level %d:n location %p/n",n,&n); /* 1 */
- if(n<4)  
-         up_and_down(n+1);  
-     printf("Level %d:n location %p/n",n,&n); /* 2 */
- }  

![save_snippets.png](http://static.blog.csdn.net/images/save_snippets.png)

**输出结果**Level 1:n location 0240FF48

Level 2:n location 0240FF28

Level 3:n location 0240FF08

Level 4:n location 0240FEE8

Level 4:n location 0240FEE8

Level 3:n location 0240FF08

Level 2:n location 0240FF28

Level 1:n location 0240FF48

首先， main() 使用参数 1 调用了函数 up_and_down() ，于是 up_and_down() 中形式参数 n 的值是 1, 故打印语句 #1 输出了 Level1 。然后，由于 n 的数值小于 4 ，所以 up_and_down() （第 1 级）使用参数 n+1 即数值 2 调用了 up_and_down()( 第 2 级 ). 使得 n 在第 2级调用中被赋值 2, 打印语句 #1 输出的是 Level2
 。与之类似，下面的两次调用分别打印出 Level3 和 Level4 。

　当开始执行第 4 级调用时， n 的值是 4 ，因此 if 语句的条件不满足。这时候不再继续调用 up_and_down() 函数。第 4 级调用接着执行打印语句 #2 ，即输出 Level4 ，因为 n 的值是 4 。现在函数需要执行 return 语句，此时第 4 级调用结束，把控制权返回给该函数的调用函数，也就是第 3 级调用函数。第 3 级调用函数中前一个执行过的语句是在 if 语句中进行第 4 级调用。因此，它继续执行其后继代码，即执行打印语句
 #2 ，这将会输出 Level3 ．当第 3 级调用结束后，第 2 级调用函数开始继续执行，即输出Level2 ．依次类推．

　注意，每一级的递归都使用它自己的私有的变量 n ．可以查看地址的值来证明．

通过这个例子我就很明白，递归之间的调用过程，而且启发我以后对感觉怪怪的递归可以打印其递归过程。


再看一个具体的递归函数调用的例子：**以二进制形式输出整数**

**[cpp]**[view
 plain](http://blog.csdn.net/t0nsha/article/details/5705641#)[copy](http://blog.csdn.net/t0nsha/article/details/5705641#)

- /*输入一个整数，输出二进制形式*/
- #include<stdio.h>
- void to_binary(unsigned long n);  
- 
- int main(void)  
- {  
-     unsigned long number;  
-     printf("Enter an integer(q to quit):/n");  
- while(scanf("%ul",&number)==1)  
-     {  
-         printf("Binary equivalent :");  
-         to_binary(number);  
-         putchar('/n');  
-         printf("Enter an integer(q to quit):/n");  
-     }  
-     printf("Done./n");  
- return 0;  
- 
- }  
- void to_binary(unsigned long n)    /*递归函数*/
- {  
- int r;  
-     r=n%2;    /*在递归调用之前计算n%2的数值，然后在递归调用语句之后进行输出．这样
-     　　　　　　计算出的第一个数值反而是在最后一个输出*/
- if(n>=2)  
-         to_binary(n/2);  
-         putchar('0'+r);/*如果r是0，表达式'0'+r就是字符'0'；如果r是1，则表达式的值为
-                        　　　　　　　　　'1'．注意前提是字符'1'的数值编码比字符'0'的数值编码大1．
-         　　　　　　　　　ASCII和EBCDIC这两种编码都满足这个条件．*/
- return;  
- }   

![save_snippets.png](http://static.blog.csdn.net/images/save_snippets.png)

****输出结果****Enter an integer(q to quit):

9

Binary equivalent :1001

Enter an integer(q to quit):

255

Binary equivalent :11111111

Enter an integer(q to quit): 

**通过上面这个题吧，我的启发是：**

**第一：如何改变程序输出的顺序，通过把这个输出摆放的位置即函数调用之前还是之后，这个程序是“输出”，下一个程序就有可能是其他的各种操作。**

**第二：递归和迭代操作的一些关联。递归也是一种循环，是系统或者编译器背后默默支持的，只要符合同样的逻辑形式通过调用自身就可以了，而且它替你保存了好多变量和条件；迭代是需要我们自己操心的，关键是各个变量咋保存，啥时候结束等等需要我们自己操心。**

下面也是一篇很好解释递归的文章。


C通过运行时堆栈支持递归函数的实现。递归函数就是直接或间接调用自身的函数。

     许多教科书都把计算机阶乘和菲波那契数列用来说明递归，非常不幸我们可爱的著名的老潭老师的《C语言程序设计》一书中就是从阶乘的计算开始的函数递归。导致读过这本经书的同学们，看到阶乘计算第一个想法就是递归。但是在阶乘的计算里，递归并没有提供任何优越之处。在菲波那契数列中，它的效率更是低的非常恐怖。

     这里有一个简单的程序，可用于说明递归。程序的目的是把一个整数从二进制形式转换为可打印的字符形式。例如：给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了%d格式码，它就会执行类似处理。

     我们采用的策略是把这个值反复除以10，并打印各个余数。例如，4267除10的余数是7，但是我们不能直接打印这个余数。我们需要打印的是机器字符集中表示数字‘7’的值。在ASCII码中，字符‘7’的值是55，所以我们需要在余数上加上48来获得正确的字符，但是，使用字符常量而不是整型常量可以提高程序的可移植性。‘0’的ASCII码是48，所以我们用余数加上‘0’，所以有下面的关系：
          ‘0’+ 0 =‘0’
          ‘0’+ 1 =‘1’
          ‘0’+ 2 =‘2’
      　　　    ...

　　从这些关系中，我们很容易看出在余数上加上‘0’就可以产生对应字符的代码。接着就打印出余数。下一步再取商的值，4267/10等于426。然后用这个值重复上述步骤。

　　这种处理方法存在的唯一问题是它产生的数字次序正好相反，它们是逆向打印的。所以在我们的程序中使用递归来修正这个问题。

　　我们这个程序中的函数是递归性质的,因为它包含了一个对自身的调用。乍一看，函数似乎永远不会终止。当函数调用时，它将调用自身，第2次调用还将调用自身，以此类推，似乎永远调用下去。这也是我们在刚接触递归时最想不明白的事情。但是，事实上并不会出现这种情况。

　　这个程序的递归实现了某种类型的螺旋状while循环。while循环在循环体每次执行时必须取得某种进展，逐步迫近循环终止条件。递归函数也是如此，它在每次递归调用后必须越来越接近某种限制条件。**当递归函数符合这个限制条件时，它便不在调用自身**。
在程序中，递归函数的限制条件就是变量quotient为零。在每次递归调用之前，我们都把quotient除以10，所以每递归调用一次，它的值就越来越接近零。当它最终变成零时，递归便告终止。

/*接受一个整型值（无符号0，把它转换为字符并打印它，前导零被删除*/

#include <stdio.h>

int binary_to_ascii( unsigned int value)

{
unsigned
 int quotient;

   　　quotient = value / 10;

   　　if( quotient != 0)

       　　　　binary_to_ascii( quotient);

   　　putchar ( value % 10 + '0' );

}

递归是如何帮助我们以正确的顺序打印这些字符呢？下面是这个函数的工作流程。
       1. 将参数值除以10
       2. 如果quotient的值为非零，调用binary-to-ascii打印quotient当前值的各位数字

　　3. 接着，打印步骤1中除法运算的余数

　　注意在第2个步骤中，我们需要打印的是quotient当前值的各位数字。我们所面临的问题和最初的问题完全相同，只是变量quotient的值变小了。我们用刚刚编写的函数（把整数转换为各个数字字符并打印出来）来解决这个问题。由于quotient的值越来越小，所以递归最终会终止。

　　一旦你理解了递归，阅读递归函数最容易的方法不是纠缠于它的执行过程，而是相信递归函数会顺利完成它的任务。如果你的每个步骤正确无误，你的限制条件设置正确，并且每次调用之后更接近限制条件，递归函数总是能正确的完成任务。

　　但是，为了理解递归的工作原理，你需要追踪递归调用的执行过程，所以让我们来进行这项工作。追踪一个递归函数的执行过程的关键是理解函数中所声明的变量是如何存储的。当函数被调用时，它的变量的空间是创建于运行时堆栈上的。以前调用的函数的变量扔保留在堆栈上，但他们被新函数的变量所掩盖，因此是不能被访问的。

　　当递归函数调用自身时，情况于是如此。每进行一次新的调用，都将创建一批变量，他们将掩盖递归函数前一次调用所创建的变量。当我追踪一个递归函数的执行过程时，必须把分数不同次调用的变量区分开来，以避免混淆。

　　程序中的函数有两个变量：参数value和局部变量quotient。下面的一些图显示了堆栈的状态，当前可以访问的变量位于栈顶。所有其他调用的变量饰以灰色的阴影，表示他们不能被当前正在执行的函数访问。
假定我们以4267这个值调用递归函数。当函数刚开始执行时，堆栈的内容如下图所示： 

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/1.JPG)

执行除法之后，堆栈的内容如下：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/2.JPG)

接着，if语句判断出quotient的值非零，所以对该函数执行递归调用。当这个函数第二次被调用之初，堆栈的内容如下：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/3.JPG)

堆栈上创建了一批新的变量，隐藏了前面的那批变量，除非当前这次递归调用返回，否则他们是不能被访问的。再次执行除法运算之后，堆栈的内容如下：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/4.JPG)

quotient的值现在为42，仍然非零，所以需要继续执行递归调用，并再创建一批变量。在执行完这次调用的出发运算之后，堆栈的内容如下：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/5.JPG)

此时，quotient的值还是非零，仍然需要执行递归调用。在执行除法运算之后，堆栈的内容如下：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/6.JPG)

　　不算递归调用语句本身，到目前为止所执行的语句只是除法运算以及对quotient的值进行测试。由于递归调用这些语句重复执行，所以它的效果类似循环：当quotient的值非零时，把它的值作为初始值重新开始循环。但是，递归调用将会保存一些信息（这点与循环不同），也就好是保存在堆栈中的变量值。这些信息很快就会变得非常重要。

　　现在quotient的值变成了零，递归函数便不再调用自身，而是开始打印输出。然后函数返回，并开始销毁堆栈上的变量值。
每次调用putchar得到变量value的最后一个数字，方法是对value进行模10取余运算，其结果是一个0到9之间的整数。把它与字符常量‘0’相加，其结果便是对应于这个数字的ASCII字符，然后把这个字符打印出来。 

输出4：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/6.JPG)

接着函数返回，它的变量从堆栈中销毁。接着，递归函数的前一次调用重新继续执行，她所使用的是自己的变量，他们现在位于堆栈的顶部。因为它的value值是42，所以调用putchar后打印出来的数字是2。

 输出42：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/7.JPG)

接着递归函数的这次调用也返回，它的变量也被销毁，此时位于堆栈顶部的是递归函数再前一次调用的变量。递归调用从这个位置继续执行，这次打印的数字是6。在这次调用返回之前，堆栈的内容如下：

  输出426：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/8.JPG)

现在我们已经展开了整个递归过程，并回到该函数最初的调用。这次调用打印出数字7，也就是它的value参数除10的余数。

  输出4267：

![](http://images.cnblogs.com/cnblogs_com/zhangqqqf/9.JPG)

然后，这个递归函数就彻底返回到其他函数调用它的地点。
如果你把打印出来的字符一个接一个排在一起，出现在打印机或屏幕上，你将看到正确的值：4267
**这个函数可以理解为main调用一次，自身调用三次，走到函数体末尾就是能够结束，当然有ruturn也是可以的。所谓的终止条件其实就是啥时候不再调用自身了，也就是说啥时候把问题解决掉而已。**
汉诺塔问题递归[算法](http://lib.csdn.net/base/31)分析：

　　一个庙里有三个柱子，第一个有64个盘子，从上往下盘子越来越大。要求庙里的老和尚把这64个盘子全部移动到第三个柱子上。移动的时候始终只能小盘子压着大盘子。而且每次只能移动一个。

　　1、此时老和尚（后面我们叫他第一个和尚）觉得很难，所以他想：要是有一个人能把前63个盘子先移动到第二个柱子上，我再把最后一个盘子直接移动到第三个柱子，再让那个人把刚才的前63个盘子从第二个柱子上移动到第三个柱子上，我的任务就完成了，简单。所以他找了比他年轻的和尚（后面我们叫他第二个和尚），命令：

          ① 你丫把前63个盘子移动到第二柱子上

          ② 然后我自己把第64个盘子移动到第三个柱子上后 

          ③ 你把前63个盘子移动到第三柱子上 

      2、第二个和尚接了任务，也觉得很难，所以他也和第一个和尚一样想：要是有一个人能把前62个盘子先移动到第三个柱子上，我再把最后一个盘子直接移动到第二个柱子，再让那个人把刚才的前62个盘子从第三个柱子上移动到第三个柱子上，我的任务就完成了，简单。所以他也找了比他年轻的和尚（后面我们叫他第三和尚），命令： 

          ① 你把前62个盘子移动到第三柱子上 

          ② 然后我自己把第63个盘子移动到第二个柱子上后 

          ③ 你把前62个盘子移动到第二柱子上 

　　3、第三个和尚接了任务，又把移动前61个盘子的任务依葫芦话瓢的交给了第四个和尚，等等递推下去，直到把任务交给了第64个和尚为止（估计第64个和尚很郁闷，没机会也命令下别人，因为到他这里盘子已经只有一个了）。

　　4、到此任务下交完成，到各司其职完成的时候了。完成回推了：
第64个和尚移动第1个盘子，把它移开，然后第63个和尚移动他给自己分配的第2个盘子。
第64个和尚再把第1个盘子移动到第2个盘子上。到这里第64个和尚的任务完成，第63个和尚完成了第62个和尚交给他的任务的第一步。 

　　从上面可以看出，只有第64个和尚的任务完成了，第63个和尚的任务才能完成，只有第2个和尚----第64个和尚的任务完成后，第1个和尚的任务才能完成。这是一个典型的递归问题。 现在我们以有3个盘子来分析：

第1个和尚命令：

          ① 第2个和尚你先把第一柱子前2个盘子移动到第二柱子。（借助第三个柱子）

          ② 第1个和尚我自己把第一柱子最后的盘子移动到第三柱子。
          ③ 第2个和尚你把前2个盘子从第二柱子移动到第三柱子。 

　　　很显然，第二步很容易实现（哎，人总是自私地，把简单留给自己，困难的给别人）。

其中第一步，第2个和尚他有2个盘子，他就命令：

          ① 第3个和尚你把第一柱子第1个盘子移动到第三柱子。（借助第二柱子） 

          ② 第2个和尚我自己把第一柱子第2个盘子移动到第二柱子上。 

          ③ 第3个和尚你把第1个盘子从第三柱子移动到第二柱子。

　　　同样，第二步很容易实现，但第3个和尚他只需要移动1个盘子，所以他也不用在下派任务了。（注意：这就是停止递归的条件，也叫边界值）
第三步可以分解为，第2个和尚还是有2个盘子，命令： 

          ① 第3个和尚你把第二柱子上的第1个盘子移动到第一柱子。

          ② 第2个和尚我把第2个盘子从第二柱子移动到第三柱子。
          ③ 第3个和尚你把第一柱子上的盘子移动到第三柱子。 

分析组合起来就是：1→3 1→2 3→2 借助第三个柱子移动到第二个柱子
 |1→3 自私人留给自己的活| 2→1
 2→3 1→3借助第一个柱子移动到第三个柱子|共需要七步。

如果是4个盘子，则第一个和尚的命令中第1步和第3步各有3个盘子，所以各需要7步，共14步，再加上第1个和尚的1步，所以4个盘子总共需要移动7+1+7=15步，同样，5个盘子需要15+1+15=31步，6个盘子需要31+1+31=64步……由此可以知道，移动n个盘子需要（2的n次方）-1步。

　　　从上面整体综合分析可知把n个盘子从1座（相当第一柱子）移到3座（相当第三柱子）：
（1）把1座上（n-1）个盘子借助3座移到2座。 
（2）把1座上第n个盘子移动3座。 
（3）把2座上（n-1）个盘子借助1座移动3座。 

下面用hanoi（n,a,b,c）表示把1座n个盘子借助2座移动到3座。 

很明显:    (1)步上是 hanoi(n-1,1,3,2) 
               (3)步上是 hanoi(n-1,2,1,3) 
用C语言表示出来，就是：
#include <stdio.h>

int method(int n,char a, char b)

{
printf("number..%d..form..%c..to..%c.."n",n,a,b);
return 0;

}

int hanoi(int n,char a,char b,char c)

{
if( n==1 ) move
 (1,a,c);
else
{
hanoi(n-1,a,c,b);
move(n,a,c);
hanoi(n-1,b,a,c);
};
return 0;

}

int main()

{
int
 num;
scanf("%d",&num);
hanoi(num,'A','B','C');
return 0;

}

