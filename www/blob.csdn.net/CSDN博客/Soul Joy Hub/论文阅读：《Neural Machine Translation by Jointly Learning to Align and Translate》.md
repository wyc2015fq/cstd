# 论文阅读：《Neural Machine Translation by Jointly Learning to Align and Translate》 - Soul Joy Hub - CSDN博客

2018年05月31日 16:51:16[卓寿杰_SoulJoy](https://me.csdn.net/u011239443)阅读数：2516


[https://blog.csdn.net/u011239443/article/details/80521026](https://blog.csdn.net/u011239443/article/details/80521026)

论文地址：[http://pdfs.semanticscholar.org/071b/16f25117fb6133480c6259227d54fc2a5ea0.pdf](http://pdfs.semanticscholar.org/071b/16f25117fb6133480c6259227d54fc2a5ea0.pdf)

# 摘要

神经机器翻译是最近提出的机器翻译方法。与传统的统计机器翻译不同，神经机器翻译的目标是建立一个单一的神经网络，可以共同调整以最大化翻译性能。最近提出的用于神经机器翻译的模型经常属于编码器 - 译码器族，并且将源句子编码成固定长度的矢量，解码器从该矢量生成翻译。在本文中，我们推测使用固定长度向量是提高这种基本编码器 - 解码器架构性能的瓶颈，并且建议通过允许模型自动（软）搜索零件来扩展它的源句子与预测目标词相关，而不必将这些部分明确地形成为硬分段。采用这种新方法，我们实现了与现有最​​先进的基于短语的系统相媲美的英文到法文翻译的翻译性能。此外，定性分析显示模型发现的（软）对齐与我们的直觉非常吻合。

# 1. 介绍

最近由Kalchbrenner和Blunsom（2013），Sutskever（2014）和Cho（2014b）提出的神经机器翻译是一种新兴的机器翻译方法。 与传统的基于短语的翻译系统（参见Koehn等人，2003）不同，它由许多分开调谐的小型子部件组成，神经机器翻译尝试构建和训练单个大型神经网络读取一个句子并输出正确的翻译。

大多数提出的神经机器翻译模型属于一个编码器 - 解码器家族，每种语言都有一个编码器和一个解码器，或者涉及一种语言特定的编码器，然后将这些编码器应用于每个句子，然后将其输出进行比较。 编码器神经网络将源信号读取并编码为固定长度的矢量。 解码器然后从编码矢量输出翻译。 整个编码器 - 译码器系统由编码器和语言对的译码器共同训练，以最大化给定源句子的正确译文的概率。

这种编码器 - 解码器方法的一个潜在问题是神经网络需要能够将源语句的所有必要信息压缩成固定长度的向量。 这可能使神经网络很难处理长句，特别是那些比训练语料库中的句子更长的句子。 Cho等人 表明，当输入句子的长度增加时，基本编码器 - 译码器的性能的确会迅速恶化。

为了解决这个问题，我们引入了一个扩展到编码器 - 解码器模型，学习联合对齐和翻译。 每次提出的模型在翻译中生成一个单词时，它（软）会在源句子中搜索一组位置，其中最相关的信息是集中的。 该模型然后基于与这些源位置和所有先前生成的目标词相关联的上下文向量来预测目标词。

在本文中，我们表明，所提出的联合学习对齐和平移的方法实现了比基本编码器 - 解码器方法显着提高的翻译性能。 用更长的句子来改进这种改进更为明显，但可以用任何长度的句子来观察。 在英文到法文翻译的任务中，所提出的方法通过单一模型实现了与传统的基于短语的系统相当或接近的翻译性能。 此外，定性分析表明，所提出的模型发现源语句和相应的目标语句之间在语言上可信（软）对应。

# 2. 背景：神经机器翻译

从概率的角度来看，翻译等同于找到一个目标句子y，它使给定源句子x的y的条件概率最大化，即$arg max_y p（y | x）$。 在神经机器翻译中，我们拟合参数化模型，以使用并行训练语料库来最大化语句对的条件概率。 一旦通过翻译模型学习了条件分布，给定源句子，可以通过搜索使条件概率最大化的句子来生成相应的翻译。

最近，一些论文提出使用神经网络直接学习这种条件分布。这种神经机器翻译方法典型地由两部分组成，其中第一部分编码源句子x，第二部分解码为目标句子y。 例如，（Cho等，2014a）和（Sutskever等，2014）使用两个循环神经网络（RNN）将可变长度的源语句编码成固定长度的向量并将该向量解码为一个可变长度的目标语句。

尽管是一种相当新颖的方法，神经机器翻译已经显示出有希望的结果。 Sutskever报告说，基于长期短期记忆（LSTM）单位的RNNs的神经机器翻译实现了接近传统的基于短语的机器翻译系统在英语到法语翻译任务上的最新性能。 例如，将现有翻译系统的神经元件添加到短语表中或对候选翻译进行重新排名，可以超越以前的最新性能水平。

## 2.1 RNN编码器 - 解码器

在这里，我们简要地描述由Cho和Sutskever提出的称为RNN编码器 - 解码器的底层框架，我们在该框架上构建了一种能够同时对齐和翻译的新颖架构。

在编码器 - 解码器框架中，编码器将输入句子（向量$x =（x_1，...，x_{T_x}）$的序列）到向量c中。最常见的方法是使用RNN： 
![](https://upload-images.jianshu.io/upload_images/1621805-8dd3a9298f279ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

和 
![](https://upload-images.jianshu.io/upload_images/1621805-c9dbd6e43e4559b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中$h_t∈R_n$是时刻t的隐藏状态，c是隐藏状态序列产生的向量。 f和q是一些非线性函数。例如，Sutskever等人 （2014）使用LSTM作为f和$q（{h_1，...，h_T}）= h_T$。

解码器通常被训练来预测给定上下文向量c和所有先前预测的词${y_1，...，y_{t'-1}}$的下一个词$y_{t'}$。 换言之，解码器通过将联合概率分解成有序条件来定义翻译y上的概率： 
![](https://upload-images.jianshu.io/upload_images/1621805-b17cdab22940c0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中，$y = (y_1, · · · ,y_{T_y})$。使用RNN，每个条件概率被建模为 
![](https://upload-images.jianshu.io/upload_images/1621805-8fbf455666e309a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中g是输出yt概率的非线性潜在多层函数，st是RNN的隐藏状态。 应该注意的是，可以使用其他体系结构，如RNN和解卷积神经网络的混合体（Kalchbrenner和Blunsom，2013）。

# 3 学习对准和翻译

在本节中，我们提出了一种神经机器翻译的新颖架构。 新的体系结构包括一个作为编码器的双向RNN（第3.2节）和一个模拟翻译过程中通过源语句进行搜索的解码器（第3.1节）。

## 3.1 解码器：一般描述

在一个新的模型架构中，我们将方程（2）中的每个条件概率定义为：

![](https://upload-images.jianshu.io/upload_images/1621805-846bc016ed28a290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中$s_i$是时间i的RNN隐藏状态，由 
![](https://upload-images.jianshu.io/upload_images/1621805-d3d4de265000cd2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 
这里可使用LSTM 

应该注意的是，与现有的编码器 - 解码器方法不同（参见等式（2）），这里概率是针对每个目标字$y_i$的不同的上下文向量$c_i$。

上下文向量$c_i$取决于编码器将输入句子映射到的注释序列$（h_1，...，h_{T_x}）$。 每个注释$h_i$都包含有关整个输入序列的信息，重点关注输入序列第i个单词周围的部分。 我们详细解释在下一节中计算注释的方式。

然后，将上下文向量$c_i$计算为这些注释的加权和$h_i$：

![](https://upload-images.jianshu.io/upload_images/1621805-e47bac053acbb17a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

每个注释$h_j$的权重$α_{ij}$由下式计算: 
![](https://upload-images.jianshu.io/upload_images/1621805-d5eb58e647c3553d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中 
![](https://upload-images.jianshu.io/upload_images/1621805-84004781876fb570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

是一个对齐模型，它可以评估位置j周围的输入和位置i的输出匹配程度。 得分基于RNN隐藏状态$s_{i-1}$（就在发射y_i之前，等式（4））和输入语句的第j个注释$h_j$。

> 
对齐模型的设计应考虑到对于$T_x$和$T_y$长度的每个句对，需要评估$T_x×T_y$时间。 为了减少计算量，我们使用单层多层感知器 
![](https://upload-images.jianshu.io/upload_images/1621805-2f8a8b04850ab7e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  其中$W_a∈R^{n×n}，U_a∈R^{n×2n}和v_a∈R^n$是权矩阵。 由于$U_ah_j$不依赖$i$，我们可以预先计算它以最小化计算成本。

我们将对准模型a参数化为与所提出的系统的所有其他部件联合训练的前馈神经网络。 请注意，与传统的机器翻译不同，他的对齐不被视为潜在变量。 相反，对齐模型直接计算软对齐，这可以使成本函数的梯度反向传播。 该梯度可以用于联合训练对齐模型以及整个翻译模型。

我们可以理解将所有注释的加权总和作为计算预期注释的方法，其中期望在可能的对齐上。 令$α_{ij}$为目标单词$y_i$与源词$x_j$对齐或翻译的概率。 然后，第i个上下文向量$c_i$是所有具有概率$α_{ij}$的注释的期望注释。

概率$α_{ij}$或其相关能量$e_{ij}$反映了注释$h_j$相对于先前隐藏状态$s_{i-1}$在决定下一状态$s_i$和生成$y_i$中的重要性。 直观地说，这实现了解码器中的注意力机制。 解码器决定部分源句子要注意。 通过让解码器具有注意力机制，我们可以免除编码器将源句子中的所有信息编码成固定长度矢量的负担。 采用这种新方法，信息可以在整个注释序列中传播，这可以由解码器相应地选择性地取回。

## 3.2 编码器：双向RNN用于注释序列

通常的RNN，在方程 （1）从第一符号$x_1$开始到最后一个$x_{T_x}$为止读取输入序列x。 但是，在提出的方案中，我们希望每个单词的注释不仅总结前面的单词，而且总结下列单词。 因此，我们建议使用最近在语音识别中成功使用的双向RNN（BiRNN，Schuster和Paliwal，1997）（参见例如Graves等，2013）。

BiRNN由前向和后向RNN组成。 正向RNN f读取输入序列（从$x_1$到$x_{T_x}$），并计算一系列前向隐藏状态。 后向RNN f以相反的顺序（从$x_{T_x}$到$x_1$）读取序列，产生一系列后向隐藏状态。

我们通过连接前向隐藏状态和后向隐藏状态来获得每个单词$x_j$的注释。 这样，注释$h_j$包含前面的单词和后面的单词的摘要。 由于RNN倾向于更好地代表最近的输入，所以注释$h_j$将集中在$x_j$周围的单词上。 解码器和对准模型稍后使用该序列的注释来计算上下文向量（等式（5） - （6））。

请参阅图1以了解所提议模型的图解说明。

![](https://upload-images.jianshu.io/upload_images/1621805-95c2156661980e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 
图1：提供模型试图生成第t个目标词$y_t$的图解说明，给出源语句$（x_1，x_2，...，x_T）$。

![](http://upload-images.jianshu.io/upload_images/1621805-e7dd694099f756b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

