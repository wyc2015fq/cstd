# 大端小端格式详解 - Soul Joy Hub - CSDN博客

2017年03月08日 21:43:44[卓寿杰_SoulJoy](https://me.csdn.net/u011239443)阅读数：412标签：[大端小端																[jvm																[网络																[内存																[cpu](https://so.csdn.net/so/search/s.do?q=cpu&t=blog)](https://so.csdn.net/so/search/s.do?q=内存&t=blog)](https://so.csdn.net/so/search/s.do?q=网络&t=blog)](https://so.csdn.net/so/search/s.do?q=jvm&t=blog)](https://so.csdn.net/so/search/s.do?q=大端小端&t=blog)
个人分类：[C/C++																[Java](https://blog.csdn.net/u011239443/article/category/6296471)](https://blog.csdn.net/u011239443/article/category/6268784)


[http://blog.csdn.net/duyiwuer2009/article/details/7455490](http://blog.csdn.net/duyiwuer2009/article/details/7455490)

[http://blog.csdn.net/zhaoshuzhaoshu/article/details/37600857/](http://blog.csdn.net/zhaoshuzhaoshu/article/details/37600857/)


# 1. 什么是大端,什么是小端:

**所谓的大端模式，**是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；（JVM 通常网络传输 都是大端）

**所谓的小端模式，**是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。（ 通常的CPU都是小端 ）

# 2.为什么会有大小端:

为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL
 C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

# 3.大小端在内存中的存放方式举例:

例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
|内存地址|0x4000|0x4001|
|----|----|----|
|存放内容|0x34|0x12|

而在Big-endian模式CPU内存中的存放方式则为：
|内存地址|0x4000|0x4001|
|----|----|----|
|存放内容|0x12|0x34|

32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
|内存地址|0x4000|0x4001|0x4002|0x4003|
|----|----|----|----|----|
|存放内容|0x78|0x56|0x34|0x12|

而在Big-endian模式CPU内存中的存放方式则为：
|内存地址|0x4000|0x4001|0x4002|0x4003|
|----|----|----|----|----|
|存放内容|0x12|0x34|0x56|0x78|

# 4.如何测试编译器是大端还是小端

## C：

```
#include <stdio.h>  
#include <stdlib.h>  

/** 
 * 将字节数组（char[]）转为整形（int） 
 */  
int main()  
{  
    char chArray[] = {0x78,0x56,0x34,0x12};  
    int *p = (int *)chArray;  
    printf("%x\n", *p);  
    return 0;  
}  
// output: 12345678
```

结论：说明 CPU 是小端

## Java：

```java
import java.io.ByteArrayInputStream;  
    import java.io.DataInputStream;  
    import java.io.IOException;  

    public class Test  
    {  
        /** 
         * 将字节数组（byte[]）转为整形(int) 
         */  
        public static void main(String[] args) throws IOException  
        {  
            byte[] byteAr = new byte[4];  
            byteAr[0] = 0x78;  
            byteAr[1] = 0x56;  
            byteAr[2] = 0x34;  
            byteAr[3] = 0x12;  
            ByteArrayInputStream bais = new ByteArrayInputStream(byteAr);  
            DataInputStream dis = new DataInputStream(bais);  
            System.out.println(Integer.toHexString(dis.readInt()));  
        }  
    }  
    // output: 78563412
```

结论：说明 JVM 是大端


