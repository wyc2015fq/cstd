# 深度之眼课程打卡-python入门04 - 去向前方的博客 - CSDN博客





2019年03月11日 20:21:36[Big_quant](https://me.csdn.net/lvsehaiyang1993)阅读数：93








# 目录




### 文章目录
- [目录](#_0)
- [前言](#_3)
- [内容](#_5)
- [数组的创建](#_20)
- [一维数组的创建](#_24)
- [二维数组的创建](#_58)
- [特殊数组](#_79)
- [有关数组的属性和函数](#_101)
- [数组的方法](#_174)
- [数组元素的获取](#_384)
- [二维数组元素的获取：](#_411)
- [布尔索引](#_448)
- [统计函数与线性代数运算](#_651)
- [线性代数运算](#_978)
- [随机数生成](#_1109)
- [正态分布直方图](#_1113)
- [使用二项分布进行赌博](#_1129)




# 前言

为了增加实战经验，选择了开通深度之眼vip，先试试水，效果好的话，推荐给大家。

# 内容

入门第二三课的内容以及在其他bolg里，所以就不打卡了。

本节课主要是联系numpy的相应语法，熟悉相关操作。

Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。
接下面将从这5个方面来介绍numpy模块的内容：

```
1.数组的创建
 2.有关数组的属性和函数
 3.数组元素的获取--普通索引、切片、布尔索引和花式索引
 4.统计函数与线性代数运算
 5.随机数的生成
```

## 数组的创建

numpy中使用array()函数创建数组,array的首个参数一定是一个序列，可以是元组也可以是列表。

### 一维数组的创建

可以使用numpy中的arange()函数创建一维有序数组，它是内置函数range的扩展版。

```
import numpy as np
 ls1 = range(10)
 list(ls1)
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 type(ls1)
<class 'range'>
 ls2 = np.arange(10)
 list(ls2)
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 type(ls2)
<class 'numpy.ndarray'>
```

通过arange生成的序列就不是简简单单的列表类型了，而是一个一维数组。

如果一维数组不是一个规律的有序元素，而是人为的输入，就需要array()函数创建了。

```
arr1 = np.array((1,20,13,28,22))
 arr1
    array([ 1, 20, 13, 28, 22])
 type(arr1)
 <class 'numpy.ndarray'>
```

上面是由元组序列构成的一维数组。

```
arr2 = np.array([1,1,2,3,5,8,13,21])    
arr2
 array([ 1,  1,  2,  3,  5,  8, 13, 21])
 type(arr2)
<class 'numpy.ndarray'>
```

上面是由列表序列构成的一维数组。

### 二维数组的创建

二维数组的创建，其实在就是列表套列表或元组套元组。

```
arr3 = np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144)))
arr3
 array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
```

上面使用元组套元组的方式。

```
arr4 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
arr4
 array([[ 1,  2,  3,  4],
[ 5,  6,  7,  8],
[ 9, 10, 11, 12]])
```

上面使用列表套列表的方式。

对于高维数组在将来的数据分析中用的比较少，这里关于高维数组的创建就不赘述了，构建方法仍然是套的方式。

### 特殊数组

上面所介绍的都是人为设定的一维、二维或高维数组，numpy中也提供了几种特殊的数组，它们是：

```
np.ones(3)  #返回一维元素全为1的数组
array([ 1.,  1.,  1.])
np.ones([3,4])  #返回元素全为1的3×4二维数组
 array([[ 1.,  1.,  1.,  1.],
[ 1.,  1.,  1.,  1.],
[ 1.,  1.,  1.,  1.]])
np.zeros(3) #返回一维元素全为0的数组
 array([ 0.,  0.,  0.])
 np.zeros([3,4]) #返回元素全为0的3×4二维数组
array([[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.]])
 np.empty(3) #返回一维空数组
array([ 0.,  0.,  0.])
np.empty([3,4]) #返回3×4二维空数组
 array([[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.]])
```

### 有关数组的属性和函数

当一个数组构建好后，我们看看关于数组本身的操作又有哪些属性和函数：

```
arr3
array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
arr3.shape  #shape方法返回数组的行数和列数
(3, 4)
 arr3.dtype  #dtype方法返回数组的数据类型
 dtype('int32')
a = arr3.ravel()    #通过ravel的方法将数组拉直（多维数组降为一维数组）
a
array([  1,   1,   2,   3,   5,   8,  13,  21,  34,  55,  89, 144])
b = arr3.flatten()  #通过flatten的方法将数组拉直
b
array([  1,   1,   2,   3,   5,   8,  13,  21,  34,  55,  89, 144])
```

两者的区别在于ravel方法生成的是原数组的视图，无需占有内存空间，但视图的改变会影响到原数组的变化。而flatten方法返回的是真实值，其值的改变并不会影响原数组的更改。

通过下面的例子也许就能明白了：

```
b[:3] = 0
In [32]: arr3
array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
通过更改b的值，原数组没有变化。
```d
In [33]: a[:3] = 0

In [34]: arr3

Out[34]:

array([[  0,   0,   0,   3],

[  5,   8,  13,  21],

[ 34,  55,  89, 144]])
```

a的值变化后，会导致原数组跟着变化。

```
In [35]: arr4

Out[35]:

array([[ 1,  2,  3,  4],

[ 5,  6,  7,  8],

[ 9, 10, 11, 12]])
In [36]: arr4.ndim   #返回数组的维数

Out[36]: 2
In [37]: arr4.size   #返回数组元素的个数

Out[37]: 12

 

In [38]: arr4.T  #返回数组的转置结果

Out[38]:

array([[ 1,  5,  9],

[ 2,  6, 10],

[ 3,  7, 11],

[ 4,  8, 12]])
```

## 数组的方法

如果数组的数据类型为复数的话，real方法可以返回复数的实部，imag方法返回复数的虚部。

介绍完数组的一些方法后，接下来我们看看数组自身有哪些函数可操作：

```
In [39]: len(arr4) #返回数组有多少行

Out[39]: 3

 

In [40]: arr3

Out[40]:

array([[  0,   0,   0,   3],

[  5,   8,  13,  21],

[ 34,  55,  89, 144]])

 

In [41]: arr4

Out[41]:

array([[ 1,  2,  3,  4],

[ 5,  6,  7,  8],

[ 9, 10, 11, 12]])

 

In [42]: np.hstack((arr3,arr4))

Out[42]:

array([[  0,   0,   0,   3,   1,   2,   3,   4],

[  5,   8,  13,  21,   5,   6,   7,   8],

[ 34,  55,  89, 144,   9,  10,  11,  12]])
```

横向拼接arr3和arr4两个数组，但必须满足两个数组的行数相同。

```
In [43]: np.vstack((arr3,arr4))  

Out[43]:

array([[  0,   0,   0,   3],

[  5,   8,  13,  21],

[ 34,  55,  89, 144],

[  1,   2,   3,   4],

[  5,   6,   7,   8],

[  9,  10,  11,  12]])
```

纵向拼接arr3和arr4两个数组，但必须满足两个数组的列数相同。

```
In [44]: np.column_stack((arr3,arr4))    #与hstack函数具有一样的效果

Out[44]:

array([[  0,   0,   0,   3,   1,   2,   3,   4],

[  5,   8,  13,  21,   5,   6,   7,   8],

[ 34,  55,  89, 144,   9,  10,  11,  12]])

 

In [45]: np.row_stack((arr3,arr4))    #与vstack函数具有一样的效果

Out[45]:

array([[  0,   0,   0,   3],

[  5,   8,  13,  21],

[ 34,  55,  89, 144],

[  1,   2,   3,   4],

[  5,   6,   7,   8],

[  9,  10,  11,  12]])
```

reshape()函数和resize()函数可以重新设置数组的行数和列数：

```
In [46]: arr5 = np.array(np.arange(24))

In [47]: arr5    #此为一维数组

Out[47]:

array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,

17, 18, 19, 20, 21, 22, 23])

 

In [48]: a = arr5.reshape(4,6)  

In [49]: a

Out[49]:

array([[ 0,  1,  2,  3,  4,  5],

[ 6,  7,  8,  9, 10, 11],

[12, 13, 14, 15, 16, 17],

[18, 19, 20, 21, 22, 23]])
```

通过reshape函数将一维数组设置为二维数组，且为4行6列的数组。

```
In [50]: a.resize(6,4)  

In [51]: a

Out[51]:

array([[ 0,  1,  2,  3],

[ 4,  5,  6,  7],

[ 8,  9, 10, 11],

[12, 13, 14, 15],

[16, 17, 18, 19],

[20, 21, 22, 23]])
```

通过resize函数会直接改变原数组的形状。

数组转换：tolist将数组转换为列表，astype()强制转换数组的数据类型，下面是两个函数的例子：

```
In [53]: b = a.tolist()

In [54]: b

Out[54]:

[[0, 1, 2, 3],

[4, 5, 6, 7],

[8, 9, 10, 11],

[12, 13, 14, 15],

[16, 17, 18, 19],

[20, 21, 22, 23]]

In [55]: type(b)

Out[55]: list

 

In [56]: c = a.astype(float)

In [57]: c

Out[57]:

array([[  0.,   1.,   2.,   3.],

[  4.,   5.,   6.,   7.],

[  8.,   9.,  10.,  11.],

[ 12.,  13.,  14.,  15.],

[ 16.,  17.,  18.,  19.],

[ 20.,  21.,  22.,  23.]])

 

In [58]: a.dtype

Out[58]: dtype('int32')

In [59]: c.dtype

Out[59]: dtype('float64')
```

## 数组元素的获取

通过索引和切片的方式获取数组元素，一维数组元素的获取与列表、元组的获取方式一样：

```
In [60]: arr7 = np.array(np.arange(10))

In [61]: arr7

Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [62]: arr7[3]     #获取第4个元素

Out[62]: 3
In [63]: arr7[:3]    #获取前3个元素

Out[63]: array([0, 1, 2])
In [64]: arr7[3:]    #获取第4个元素即之后的所有元素

Out[64]: array([3, 4, 5, 6, 7, 8, 9])
In [65]: arr7[-2:]   #获取末尾的2个元素

Out[65]: array([8, 9])
In [66]: arr7[::2]   #从第1个元素开始，获取步长为2的所有元素

Out[66]: array([0, 2, 4, 6, 8])
```

### 二维数组元素的获取：

```
In [67]: arr8 = np.array(np.arange(12)).reshape(3,4)
In [68]: arr8
Out[68]:
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
In [69]: arr8[1]     #返回数组的第2行
Out[69]: array([4, 5, 6, 7])
In [70]: arr8[:2]    #返回数组的前2行
Out[70]:
array([[0, 1, 2, 3],
[4, 5, 6, 7]])
In [71]: arr8[[0,2]]     #返回指定的第1行和第3行
Out[71]:
array([[ 0,  1,  2,  3],
[ 8,  9, 10, 11]])
In [72]: arr8[:,0]  #返回数组的第1列
Out[72]: array([0, 4, 8])
In [73]: arr8[:,-2:]    #返回数组的后2列
Out[73]:
array([[ 2,  3],
[ 6,  7],
[10, 11]])
In [74]: arr8[:,[0,2]]   #返回数组的第1列和第3列
Out[74]:
array([[ 0,  2],
[ 4,  6],
[ 8, 10]])
In [75]: arr8[1,2]   #返回数组中第2行第3列对应的元素

Out[75]: 6
```

### 布尔索引

布尔索引，即索引值为True和False，需要注意的是布尔索引必须输数组对象。

```
In [76]: log = np.array([True,False,False,True,True,False])

In [77]: arr9 = np.array(np.arange(24)).reshape(6,4)

In [78]: arr9

Out[78]:

array([[ 0,  1,  2,  3],

[ 4,  5,  6,  7],

[ 8,  9, 10, 11],

[12, 13, 14, 15],

[16, 17, 18, 19],

[20, 21, 22, 23]])

 

In [79]: arr9[log]   #返回所有为True的对应行

Out[79]:

array([[ 0,  1,  2,  3],

[12, 13, 14, 15],

[16, 17, 18, 19]])

 

In [80]: arr9[-log]  #通过负号筛选出所有为False的对应行

Out[80]:

array([[ 4,  5,  6,  7],

[ 8,  9, 10, 11],

[20, 21, 22, 23]])
```

举一个场景，一维数组表示区域，二维数组表示观测值，如何选取目标区域的观测？

```
In [81]: area = np.array(['A','B','A','C','A','B','D'])

In [82]: area

Out[82]:

array(['A', 'B', 'A', 'C', 'A', 'B', 'D'],

dtype='<U1')

 

In [83]: observes = np.array(np.arange(21)).reshape(7,3)

In [84]: observes

Out[84]:

array([[ 0,  1,  2],

[ 3,  4,  5],

[ 6,  7,  8],

[ 9, 10, 11],

[12, 13, 14],

[15, 16, 17],

[18, 19, 20]])

 

In [85]: observes[area == 'A']

Out[85]:

array([[ 0,  1,  2],

[ 6,  7,  8],

[12, 13, 14]])

返回所有A区域的观测。

 

In [86]: observes[(area == 'A') | (area == 'D')] #条件值需要在&(and),|(or)两端用圆括号括起来

Out[86]:

array([[ 0,  1,  2],

[ 6,  7,  8],

[12, 13, 14],

[18, 19, 20]])

返回所有A区域和D区域的观测。

 

当然，布尔索引也可以与普通索引或切片混合使用：

In [87]: observes[area == 'A'][:,[0,2]]  

Out[87]:

array([[ 0,  2],

[ 6,  8],

[12, 14]])

返回A区域的所有行，且只获取第1列与第3列数据。

 

花式索引：实际上就是将数组作为索引将原数组的元素提取出来

In [88]: arr10 = np.arange(1,29).reshape(7,4)

In [89]: arr10

Out[89]:

array([[ 1,  2,  3,  4],

[ 5,  6,  7,  8],

[ 9, 10, 11, 12],

[13, 14, 15, 16],

[17, 18, 19, 20],

[21, 22, 23, 24],

[25, 26, 27, 28]])

 

In [90]: arr10[[4,1,3,5]]  #按照指定顺序返回指定行

Out[90]:

array([[17, 18, 19, 20],

[ 5,  6,  7,  8],

[13, 14, 15, 16],

[21, 22, 23, 24]])

 

In [91]: arr10[[4,1,5]][:,[0,2,3]] #返回指定的行与列

Out[91]:

array([[17, 19, 20],

[ 5,  7,  8],

[21, 23, 24]])

 

In [92]: arr10[[4,1,5],[0,2,3]]

Out[92]: array([17,  7, 24])
```

请注意！这与上面的返回结果是截然不同的，上面返回的是二维数组，而这条命令返回的是一维数组。

如果想使用比较简单的方式返回指定行以列的二维数组的话，可以使用ix_()函数

```
In [93]: arr10[np.ix_([4,1,5],[0,2,3])]

Out[93]:

array([[17, 19, 20],

[ 5,  7,  8],

[21, 23, 24]])

这与arr10[[4,1,5]][:,[0,2,3]]返回的结果是一致的。
```

## 统计函数与线性代数运算

统计运算中常见的聚合函数有：最小值、最大值、中位数、均值、方差、标准差等。首先来看看数组元素级别的计算：

```
In [94]: arr11 = 5-np.arange(1,13).reshape(4,3)

In [95]: arr12 = np.random.randint(1,10,size = 12).reshape(4,3)

In [96]: arr11

Out[96]:

array([[ 4,  3,  2],

[ 1,  0, -1],

[-2, -3, -4],

[-5, -6, -7]])

 

In [97]: arr12

Out[97]:

array([[1, 3, 7],

[7, 3, 7],

[3, 7, 4],

[6, 1, 2]])

 

In [98]: arr11 ** 2    #计算每个元素的平方

Out[98]:

array([[16,  9,  4],

[ 1,  0,  1],

[ 4,  9, 16],

[25, 36, 49]])

 

In [99]: np.sqrt(arr11)  #计算每个元素的平方根

Out[99]:

array([[ 2.        ,  1.73205081,  1.41421356],

[ 1.        ,  0.        ,         nan],

[        nan,         nan,         nan],

[        nan,         nan,         nan]])
```

由于负值的平方根没有意义，故返回nan。

```
In [100]: np.exp(arr11)   #计算每个元素的指数值

Out[100]:

array([[  5.45981500e+01,   2.00855369e+01,   7.38905610e+00],

[  2.71828183e+00,   1.00000000e+00,   3.67879441e-01],

[  1.35335283e-01,   4.97870684e-02,   1.83156389e-02],

[  6.73794700e-03,   2.47875218e-03,   9.11881966e-04]])

 

In [101]: np.log(arr12)   #计算每个元素的自然对数值

Out[101]:

array([[ 0.        ,  1.09861229,  1.94591015],

[ 1.94591015,  1.09861229,  1.94591015],

[ 1.09861229,  1.94591015,  1.38629436],

[ 1.79175947,  0.        ,  0.69314718]])

 

In [102]: np.abs(arr11)   #计算每个元素的绝对值

Out[102]:

array([[4, 3, 2],

[1, 0, 1],

[2, 3, 4],

[5, 6, 7]])
```

相同形状数组间元素的操作：

```
In [103]: arr11 + arr12   #加

Out[103]:

array([[ 5,  6,  9],

[ 8,  3,  6],

[ 1,  4,  0],

[ 1, -5, -5]])

 

In [104]: arr11 - arr12   #减

Out[104]:

array([[  3,   0,  -5],

[ -6,  -3,  -8],

[ -5, -10,  -8],

[-11,  -7,  -9]])

 

In [105]: arr11 * arr12   #乘

Out[105]:

array([[  4,   9,  14],

[  7,   0,  -7],

[ -6, -21, -16],

[-30,  -6, -14]])

 

In [106]: arr11 / arr12   #除

Out[106]:

array([[ 4.        ,  1.        ,  0.28571429],

[ 0.14285714,  0.        , -0.14285714],

[-0.66666667, -0.42857143, -1.        ],

[-0.83333333, -6.        , -3.5       ]])

 

In [107]: arr11 // arr12  #整除

Out[107]:

array([[ 4,  1,  0],

[ 0,  0, -1],

[-1, -1, -1],

[-1, -6, -4]], dtype=int32)

In [108]: arr11 % arr12   #取余

Out[108]:

array([[0, 0, 2],

[1, 0, 6],

[1, 4, 0],

[1, 0, 1]], dtype=int32)
```

接下来我们看看统计运算函数：

```
In [109]: np.sum(arr11)   #计算所有元素的和

Out[109]: -18

 

In [110]: np.sum(arr11,axis = 0)    #对每一列求和

Out[110]: array([ -2,  -6, -10])

 

In [111]: np.sum(arr11, axis = 1) #对每一行求和

Out[111]: array([  9,   0,  -9, -18])

 

In [112]: np.cumsum(arr11) #对每一个元素求累积和（从上到下，从左到右的元素顺序）

Out[112]: array([  4,   7,   9,  10,  10,   9,   7,   4,   0,  -5, -11, -18], dtype=int32)

 

In [113]: np.cumsum(arr11, axis = 0) #计算每一列的累积和，并返回二维数组

Out[113]:

array([[  4,   3,   2],

[  5,   3,   1],

[  3,   0,  -3],

[ -2,  -6, -10]], dtype=int32)

 

In [114]: np.cumprod(arr11, axis = 1) #计算每一行的累计积，并返回二维数组

Out[114]:

array([[   4,   12,   24],

[   1,    0,    0],

[  -2,    6,  -24],

[  -5,   30, -210]], dtype=int32)

 

In [115]: np.min(arr11)   #计算所有元素的最小值

Out[115]: -7
In [116]: np.max(arr11, axis = 0) #计算每一列的最大值
Out[116]: array([4, 3, 2])
In [117]: np.mean(arr11)  #计算所有元素的均值
Out[117]: -1.5
In [118]: np.mean(arr11, axis = 1) #计算每一行的均值
Out[118]: array([ 3.,  0., -3., -6.])
In [119]: np.median(arr11)   #计算所有元素的中位数
Out[119]: -1.5
In [120]: np.median(arr11, axis = 0)   #计算每一列的中位数
Out[120]: array([-0.5, -1.5, -2.5])
In [121]: np.var(arr12)   #计算所有元素的方差
Out[121]: 5.354166666666667
In [122]: np.std(arr12, axis = 1)   #计算每一行的标准差

Out[122]: array([ 2.49443826,  1.88561808,  1.69967317,  2.1602469 ])
```

numpy中的统计函数运算是非常灵活的，既可以计算所有元素的统计值，也可以计算指定行或列的统计指标。还有其他常用的函数，如符号函数sign，ceil(>=x的最小整数)，floor(<=x的最大整数)，modf(将浮点数的整数部分与小数部分分别存入两个独立的数组)，cos，arccos，sin，arcsin，tan，arctan等。

让我很兴奋的一个函数是where()，它类似于Excel中的if函数，可以进行灵活的变换：

```
In [123]: arr11

Out[123]:

array([[ 4,  3,  2],

[ 1,  0, -1],

[-2, -3, -4],

[-5, -6, -7]])

 

In [124]: np.where(arr11 < 0, 'negtive','positive')

Out[124]:

array([['positive', 'positive', 'positive'],

['positive', 'positive', 'negtive'],

['negtive', 'negtive', 'negtive'],

['negtive', 'negtive', 'negtive']],

dtype='<U8')
```

当然，np.where还可以嵌套使用，完成复杂的运算。

其它函数

```
unique(x):计算x的唯一元素，并返回有序结果

intersect(x,y)：计算x和y的公共元素，即交集

union1d(x,y):计算x和y的并集

setdiff1d(x,y):计算x和y的差集，即元素在x中，不在y中

setxor1d(x,y):计算集合的对称差，即存在于一个数组中，但不同时存在于两个数组中

in1d(x,y):判断x的元素是否包含于y中
```

## 线性代数运算

同样numpu也跟R语言一样，可以非常方便的进行线性代数方面的计算，如行列式、逆、迹、特征根、特征向量等。但需要注意的是，有关线性代数的函数并不在numpy中，而是numpy的子例linalg中。

```
In [125]: arr13 = np.array([[1,2,3,5],[2,4,1,6],[1,1,4,3],[2,5,4,1]])

In [126]: arr13

Out[126]:

array([[1, 2, 3, 5],

[2, 4, 1, 6],

[1, 1, 4, 3],

[2, 5, 4, 1]])

 

In [127]: np.linalg.det(arr13)    #返回方阵的行列式

Out[127]: 51.000000000000021

 

In [128]: np.linalg.inv(arr13)    #返回方阵的逆

Out[128]:

array([[-2.23529412,  1.05882353,  1.70588235, -0.29411765],

[ 0.68627451, -0.25490196, -0.7254902 ,  0.2745098 ],

[ 0.19607843, -0.21568627,  0.07843137,  0.07843137],

[ 0.25490196,  0.01960784, -0.09803922, -0.09803922]])

 

In [129]: np.trace(arr13) #返回方阵的迹（对角线元素之和），注意迹的求解不在linalg子例程中

Out[129]: 10

 

In [130]: np.linalg.eig(arr13)    #返回由特征根和特征向量组成的元组

Out[130]:

(array([ 11.35035004,  -3.99231852,  -0.3732631 ,   3.01523159]),

array([[-0.4754174 , -0.48095078, -0.95004728,  0.19967185],

[-0.60676806, -0.42159999,  0.28426325, -0.67482638],

[-0.36135292, -0.16859677,  0.08708826,  0.70663129],

[-0.52462832,  0.75000995,  0.09497472, -0.07357122]]))

 

In [131]: np.linalg.qr(arr13) #返回方阵的QR分解

Out[131]:

(array([[-0.31622777, -0.07254763, -0.35574573, -0.87645982],

[-0.63245553, -0.14509525,  0.75789308, -0.06741999],

[-0.31622777, -0.79802388, -0.38668014,  0.33709993],

[-0.63245553,  0.580381  , -0.38668014,  0.33709993]]),

array([[-3.16227766, -6.64078309, -5.37587202, -6.95701085],

[ 0.        ,  1.37840488, -1.23330963, -3.04700025],

[ 0.        ,  0.        , -3.40278524,  1.22190924],

[ 0.        ,  0.        ,  0.        , -3.4384193 ]]))

 

In [132]:np.linalg.svd(arr13)    #返回方阵的奇异值分解

Out[132]:

(array([[-0.50908395,  0.27580803,  0.35260559, -0.73514132],

[-0.59475561,  0.4936665 , -0.53555663,  0.34020325],

[-0.39377551, -0.10084917,  0.70979004,  0.57529852],

[-0.48170545, -0.81856751, -0.29162732, -0.11340459]]),

array([ 11.82715609,   4.35052602,   3.17710166,   0.31197297]),

array([[-0.25836994, -0.52417446, -0.47551003, -0.65755329],

[-0.10914615, -0.38326507, -0.54167613,  0.74012294],

[-0.18632462, -0.68784764,  0.69085326,  0.12194478],

[ 0.94160248, -0.32436807, -0.05655931, -0.07050652]]))

 

In [133]: np.dot(arr13,arr13)     #方阵的正真乘积运算

Out[133]:

array([[18, 38, 37, 31],

[23, 51, 38, 43],

[13, 25, 32, 26],

[18, 33, 31, 53]])

 

In [134]:arr14 = np.array([[1,-2,1],[0,2,-8],[-4,5,9]])

In [135]: vector = np.array([0,8,-9])

In [136]: np.linalg.solve(arr14,vector)

Out[136]: array([ 29.,  16.,   3.])
```

## 随机数生成

统计学中经常会讲到数据的分布特征，如正态分布、指数分布、卡方分布、二项分布、泊松分布等，下面就讲讲有关分布的随机数生成。

### 正态分布直方图

```
import matplotlib #用于绘图的模块
 import matplotlib.pylab
 np.random.seed(1234)    #设置随机种子
N = 10000   #随机产生的样本量
 randnorm = np.random.normal(size = N)   #生成正态随机数
 counts, bins, path = matplotlib.pylab.hist(randnorm, bins = np.sqrt(N), normed = True, color = 'blue')  #绘制直方图
以上将直方图的频数和组距存放在counts和bins内。

 sigma = 1; mu = 0
norm_dist = (1/np.sqrt(2*sigma*np.pi))*np.exp(-((bins-mu)**2)/2)    #正态分布密度函数
 matplotlib.pylab.plot(bins,norm_dist,color = 'red') #绘制正态分布密度函数图
```

### 使用二项分布进行赌博

同时抛弃9枚硬币，如果正面朝上少于5枚，则输掉8元，否则就赢8元。如果手中有1000元作为赌资，请问赌博10000次后可能会是什么情况呢？

```
np.random.seed(1234)
binomial = np.random.binomial(9,0.5,10000)  #生成二项分布随机数
money = np.zeros(10000) #生成10000次赌资的列表
money[0] = 1000 #首次赌资为1000元
for i in range(1,10000):
     if binomial[i] < 5:
        money[i] = money[i-1] - 8  
#如果少于5枚正面，则在上一次赌资的基础上输掉8元
else:
money[i] = money[i-1] + 8  
#如果至少5枚正面，则在上一次赌资的基础上赢取8元
 matplotlib.pylab.plot(np.arange(10000), money)
```

###使用随机整数实现随机游走

一个醉汉在原始位置上行走10000步后将会在什么地方呢？如果他每走一步是随机的，即下一步可能是1也可能是-1。

```
In [152]: np.random.seed(1234)    #设定随机种子

In [153]: position = 0    #设置初始位置

In [154]: walk = []   #创建空列表

In [155]: steps = 10000   #假设接下来行走10000步

In [156]: for i in np.arange(steps):

         if np.random.randint(0,2):
             step=1 
         else
             step=-1  #每一步都是随机的

       position = position + step  #对每一步进行累计求和

       walk.append(position)   #确定每一步所在的位置

matplotlib.pylab.plot(np.arange(10000), walk)   #绘制随机游走图
```

上面的代码还可以写成（结合前面所讲的where函数，cumsum函数）：

```
np.random.seed(1234)
step = np.where(np.random.randint(0,2,10000)>0,1,-1)
position = np.cumsum(step)
 matplotlib.pylab.plot(np.arange(10000), position)
```

避免for循环，可以达到同样的效果。




