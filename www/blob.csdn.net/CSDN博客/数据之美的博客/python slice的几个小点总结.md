# python slice的几个小点总结 - 数据之美的博客 - CSDN博客
2017年03月17日 14:23:05[看穿数据之美](https://me.csdn.net/oppo62258801)阅读数：4398
# 最近在看python时发现python中关于序列的操作，尤其slice的用法挺特别的，遂上网又细细查了查资料，感觉这篇文章总结的很好，就转载下来，留个记录。[原文地址](http://shmilyaw-hotmail-com.iteye.com/blog/1782733)
# 问题的起因
    今天在写代码的时候，看到一个比较有意思的写法。假设我们有一个list，它的内容是a = [0, 1, 2, 3, 4, 5, 6, 7, 8 ,9]。如果我们取它反转后的结果，一般我们头脑里默认想到的无非就是reverse这样的方法了。但是它还有一种写法：a[::-1]，输出的结果是和当前的结果相反。在某些情况下，它的应用还是比较有意思的。就想针对这一块总结一下。
# slice在python中的应用
     在[Python](http://lib.csdn.net/base/python)中，list, tuple以及字符串等可以遍历访问的类型都可以应用slice访问。slice本身的意思是指切片，在这些可以遍历访问的类型中截取其中的某些部分。比如如下的代码：
Python代码 
- >>> l = range(10)  
- >>> l  
- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
- >>> l[1:5]  
- [1, 2, 3, 4]  
   首先，我们通过range(10) 生成一个从0到9的列表。在这个列表中取[1:5]的时候返回的是索引1到4的。所以，我们发现他们所取的slice是一个半开半闭的区间。l[a:b]==> l[a, b).
    前面这种情况下，是我们已知列表的长度，然后取他们的某个区段，如果我们不知道列表的长度，或者列表长度的获取比较麻烦呢？如果用其他的语言，我们可能考虑这个列表是否应该有一个list.length之类的属性了。在这里，有另外一个办法来取得：
Python代码 
- >>> l[-1]  
- 9
- >>> l[1:-1]  
- [1, 2, 3, 4, 5, 6, 7, 8]  
- >>> l[2:-2]  
- [2, 3, 4, 5, 6, 7]  
    我们可以看到如果要取列表中的最后一个元素，可以用l[-1]的方式，如果从后面向前，可以依次取l[-2], l[-3]...
    既然我们前面提到，在列表中slice是取的一个前面闭合后面开放的区间，也就是说我在l[a:b]的时候，索引值为b的那个元素是不包含在结果中的。如果我们想要包含后面的值那么该怎么办呢？
    这个问题可以分为几种情况来考虑，一个是加入b本身长度比较小，那么我们取l[a:b+1]就好了。比如说如下：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[1:3]  
- [1, 2]  
- >>> l[1:4]  
- [1, 2, 3]  
 如果我们想把索引值为3的也包含进来，我们就用l[1:4]就行了。那么，对于处在列表末尾的元素呢？用过c, [Java](http://lib.csdn.net/base/javase)开发的人会想到，按照这种方式会不会导致访问数组越界呢？我们试试看吧：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> len(l)  
- 10
- >>> l[1:10]  
- [1, 2, 3, 4, 5, 6, 7, 8, 9]  
- >>> l[1:11]  
- [1, 2, 3, 4, 5, 6, 7, 8, 9]  
- >>> l[1:12]  
- [1, 2, 3, 4, 5, 6, 7, 8, 9]  
    len(l)返回l的长度。我们原来潜意识的认为，既然数组长度为10，那么我们访问的索引最大值也不过为l[9]。实际上，在python这里，可以列出的访问下标值超出数组长度范围，只不过仅仅返回能遍历到的元素而已。
    当然，我们还有另外一种办法：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[1:]  
- [1, 2, 3, 4, 5, 6, 7, 8, 9]  
    这种方式就完全将前面索引到数组末尾的元素都包含进来了。
    这样，我们要包含整个数组中的元素就可以采用如下的几种方式：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[0:]  
- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
- >>> l[:]  
- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
- >>> l  
- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
    从前面我们用l[a:b] 的方式来访问元素来看，我们这里a, b取的值要么满足0<= a <= b 或者 a >= 0 b < 0。实际上，a所对应元素的位置总是在b所对应位置的后面。那么，如果我们把他们的顺序倒过来一下会怎么样呢？比如说：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[5:2]  
- []  
- >>> l[-1:3]  
- []  
    在这里，我们发现，如果实际取的元素先从右边开始然后到左边的话，并不是我们所期望的返回一个倒过来的数组，而是返回一个空的数组。我举的这个例子有什么用呢?别急，看了后面那一节你就知道了。
# 理解extended slice
    前面那一部分相对来说还是比较好理解的。现在，如果我们有一些其他的要求，比如说，我们想返回数组里面索引为奇数的元素，或者索引为偶数的元素，那么该怎么办呢？
我们可以有几种办法来做，其中的一种就是采用extended slice，一个典型的解决方法如下：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[::2]  
- [0, 2, 4, 6, 8]  
- >>> l[1::2]  
- [1, 3, 5, 7, 9]  
- >>>   
    前面这种包含两个冒号的样式是怎么回事呢?
     实际上，我们这边第一个冒号隔开的这两个部分和前面的意思是一样的，就是指定数组中间元素的区间。所以前面第一个l[::2]前面就是指的整个数组的元素。而后面那个部分则是指的一个步长。这表示什么意思呢？就是既然我们前面指定的是整个数组，那么它就是从0开始，然后每次访问后面相邻的元素。而设置为2之后呢，则访问后面和它距离为2的元素，而不是直接相邻的元素。这样，我们也就容易理解l[1::2]，它就是从元素1开始到结尾的元素集合里取间隔为2的这些元素。
    到这一步，就离我们理解前面那个古怪的l[::-1]很接近了。我们前面的这个取步长是将步长设置为正数，所以在取元素的集合里它表示从左到右的取指定步长覆盖的元素。如果我们将步长设置为负数呢？我们来看：
Python代码  ![收藏代码](http://shmilyaw-hotmail-com.iteye.com/images/icon_star.png)
- >>> l[1:9:-1]  
- []  
- >>> l[9:1:-1]  
- [9, 8, 7, 6, 5, 4, 3, 2]  
    有了前面这一部分的代码，相信就不难理解了。我们取区间[1, 9)，结果取步长为-1的时候返回的是一个空的集合。而我们取9到1的时候，步长为-1取出来了倒序的数组。这是因为如果我们指定的步长为负数的话，那么它必须和数据指定的区间方向一致。也就是说，如果我们前面指定的区间是从数组小的索引到大的索引，那么我指定的步长必然也要从小到大。所以必须为正数。而如果我们指定的区间是从后面往前的话，则步长必须指定为负数。否则返回的结果都是空的数组。
# 总结
    有了前面那么多的讨论，我们再来看数组的slice访问。他们无非就是这么几个情况，在l[a:b]的情况下，必须保证a所在的索引位置在前，b所在的索引位置在后，否则返回结果为空。在l[a:b:step]的情况下，我们首先要根据a, b的位置来判断方向，a在前，b在后的话，step应该为正，否则应该为负。不符合这些情况的话，则返回空的数组。也就是说，看a, b的位置来确定方向，不要犯方向性的错误，否则就竹篮打水一场空了:)
