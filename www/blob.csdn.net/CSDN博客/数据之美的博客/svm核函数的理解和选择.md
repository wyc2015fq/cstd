# svm核函数的理解和选择 - 数据之美的博客 - CSDN博客
2018年01月02日 15:55:10[看穿数据之美](https://me.csdn.net/oppo62258801)阅读数：2341
#### 特征空间的隐式映射：核函数
    咱们首先给出核函数的来头：在上文中，我们已经了解到了SVM处理线性可分的情况，而对于非线性的情况，SVM 的处理方法是选择一个核函数 κ(⋅,⋅) ，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。
    此外，因为训练样例一般是不会独立出现的，它们总是以成对样例的内积形式出现，而用对偶形式表示学习器的优势在为在该表示中可调参数的个数不依赖输入属性的个数，通过使用恰当的核函数来替代内积，可以隐式得将非线性的训练数据映射到高维空间，而不增加可调参数的个数(当然，前提是核函数能够计算对应着两个输入特征向量的内积)。
    在线性不可分的情况下，支持向量机首先在低维空间中完成计算，然后通过核函数将输入空间映射到高维特征空间，最终在高维特征空间中构造出最优分离超平面，从而把平面上本身不好分的非线性数据分开。如图7-7所示，一堆数据在二维空间无法划分，从而映射到三维空间里划分：
> 
> 
![](https://img-blog.csdn.net/20140830002108254)
    而在我们遇到核函数之前，如果用原始的方法，那么在用线性学习器学习一个非线性关系，需要选择一个非线性特征集，并且将数据写成新的表达形式，这等价于应用一个固定的非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器，因此，考虑的假设集是这种类型的函数：
> 
> 
> ![](https://img-my.csdn.net/uploads/201206/04/1338740718_7761.JPG)
    这里ϕ：X->F是从输入空间到某个特征空间的映射，这意味着建立非线性学习器分为两步：
- 首先使用一个非线性映射将数据变换到一个特征空间F，
- 然后在特征空间使用线性学习器分类。
    而由于对偶形式就是线性学习器的一个重要性质，这意味着假设可以表达为训练点的线性组合，因此决策规则可以用测试点和训练点的内积来表示：
> 
> 
![](https://img-my.csdn.net/uploads/201206/04/1338741121_9867.JPG)
    如果有一种方式可以在特征空间中直接计算内积〈φ(xi · φ(x)〉，就像在原始输入点的函数中一样，就有可能将两个步骤融合到一起建立一个非线性的学习器，这样直接计算法的方法称为核函数方法：
    核是一个函数K，对所有x，z(-X，满足![](https://img-my.csdn.net/uploads/201206/04/1338741445_1451.JPG)，这里φ是从X到内积特征空间F的映射。
#### 核函数：如何处理非线性数据
    来看个核函数的例子。如下图所示的两类数据，分别分布为两个圆圈的形状，这样的数据本身就是线性不可分的，此时咱们该如何把这两类数据分开呢(下文将会有一个相应的三维空间图)？
![](https://img-my.csdn.net/uploads/201206/03/1338655829_6929.png)
    事实上，上图所述的这个数据集，是用两个半径不同的圆圈加上了少量的噪音生成得到的，所以，一个理想的分界应该是一个“圆圈”而不是一条线（超平面）。如果用  和  来表示这个二维平面的两个坐标的话，我们知道一条二次曲线（圆圈是二次曲线的一种特殊情况）的方程可以写作这样的形式：
> 
> 
> 
![](https://img-blog.csdn.net/20130820145508875)
    注意上面的形式，如果我们构造另外一个五维的空间，其中五个坐标的值分别为 , , , , ，那么显然，上面的方程在新的坐标系下可以写作：
> 
> 
> 
> 
![](https://img-blog.csdn.net/20130820145522437)
    关于新的坐标  ，这正是一个 hyper plane 的方程！也就是说，如果我们做一个映射  ，将  按照上面的规则映射为  ，那么在新的空间中原来的数据将变成线性可分的，从而使用之前我们推导的线性分类算法就可以进行处理了。这正是Kernel 方法处理非线性问题的基本思想。
    再进一步描述 Kernel 的细节之前，不妨再来看看这个例子映射过后的直观例子。当然，你我可能无法把 5 维空间画出来，不过由于我这里生成数据的时候就是用了特殊的情形，具体来说，我这里的超平面实际的方程是这个样子（圆心在  轴上的一个正圆）：
> 
> 
> 
> 
![](https://img-blog.csdn.net/20130820145544562)
    因此我只需要把它映射到 , ,  这样一个三维空间中即可，下图即是映射之后的结果，将坐标轴经过适当的旋转，就可以很明显地看出，数据是可以通过一个平面来分开的(pluskid：下面的gif 动画，先用 Matlab 画出一张张图片，再用 Imagemagick 拼贴成)：
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364952814_3505.gif)
    核函数相当于把原来的分类函数：
> 
> 
![](https://img-my.csdn.net/uploads/201210/25/1351142877_8481.jpg)
    映射成：
> 
> 
![](https://img-my.csdn.net/uploads/201210/25/1351142890_4908.jpg)
    而其中的![](https://img-blog.csdn.net/20131111164022593)可以通过求解如下 dual 问题而得到的：
> 
> 
![](https://img-my.csdn.net/uploads/201210/25/1351142906_9411.jpg)
    这样一来问题就解决了吗？似乎是的：拿到非线性数据，就找一个映射  ，然后一股脑把原来的数据映射到新空间中，再做线性 SVM 即可。不过事实上没有这么简单！其实刚才的方法稍想一下就会发现有问题：在最初的例子里，我们对一个二维空间做映射，选择的新空间是原始空间的所有一阶和二阶的组合，得到了五个维度；如果原始空间是三维，那么我们会得到 19 维的新空间，这个数目是呈爆炸性增长的，这给 的计算带来了非常大的困难，而且如果遇到无穷维的情况，就根本无从计算了。所以就需要 Kernel 出马了。
    不妨还是从最开始的简单例子出发，设两个向量![](https://img-my.csdn.net/uploads/201304/03/1364953480_7616.jpg)和![](https://img-my.csdn.net/uploads/201304/03/1364953493_7554.jpg)，而![](https://img-my.csdn.net/uploads/201304/03/1364953575_7320.jpg)即是到前面说的五维空间的映射，因此映射过后的内积为：
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364953615_2896.jpg)
（公式说明：上面的这两个推导过程中，所说的前面的五维空间的映射，这里说的前面便是文中2.2.1节的所述的映射方式，回顾下之前的映射规则，再看那第一个推导，其实就是计算x1，x2各自的内积，然后相乘相加即可，第二个推导则是直接平方，去掉括号，也很容易推出来）
    另外，我们又注意到：
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364953683_4519.jpg)
二者有很多相似的地方，实际上，我们只要把某几个维度线性缩放一下，然后再加上一个常数维度，具体来说，上面这个式子的计算结果实际上和映射
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364953714_4455.jpg)
     之后的内积![](https://img-my.csdn.net/uploads/201304/03/1364953751_4112.jpg)的结果是相等的，那么区别在于什么地方呢？
- 一个是映射到高维空间中，然后再根据内积的公式进行计算；
- 而另一个则直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果。
    （公式说明：上面之中，最后的两个式子，第一个算式，是带内积的完全平方式，可以拆开，然后，通过凑一个得到，第二个算式，也是根据第一个算式凑出来的）
    回忆刚才提到的映射的维度爆炸，在前一种方法已经无法计算的情况下，后一种方法却依旧能从容处理，甚至是无穷维度的情况也没有问题。
    我们把这里的计算两个向量在隐式映射过后的空间中的内积的函数叫做核函数 (Kernel Function) ，例如，在刚才的例子中，我们的核函数为：
> 
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364956440_7770.jpg)
核函数能简化映射空间中的内积运算——刚好“碰巧”的是，在我们的 SVM 里需要计算的地方数据向量总是以内积的形式出现的。对比刚才我们上面写出来的式子，现在我们的分类函数为：
> 
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364956916_5948.jpg)
    其中  由如下 dual 问题计算而得：
> 
> 
> 
![](https://img-my.csdn.net/uploads/201304/03/1364957480_2629.jpg)
    这样一来计算的问题就算解决了，避开了直接在高维空间中进行计算，而结果却是等价的！当然，因为我们这里的例子非常简单，所以我可以手工构造出对应于![](https://img-my.csdn.net/uploads/201304/03/1364953575_7320.jpg)的核函数出来，如果对于任意一个映射，想要构造出对应的核函数就很困难了。
#### 几个核函数
    通常人们会从一些常用的核函数中选择（根据问题和数据的不同，选择不同的参数，实际上就是得到了不同的核函数），例如：
- 多项式核![](http://blog.csdn.net/leonis_v/article/details/50529825)，显然刚才我们举的例子是这里多项式核的一个特例（R = 1，d = 2）。虽然比较麻烦，而且没有必要，不过这个核所对应的映射实际上是可以写出来的，该空间的维度是![](https://img-my.csdn.net/uploads/201304/03/1364958204_2877.jpg)，其中 是原始空间的维度。
- 高斯核![](https://img-my.csdn.net/uploads/201304/03/1364958259_8460.jpg)，这个核就是最开始提到过的会将原始空间映射为无穷维空间的那个家伙。不过，如果![](https://img-my.csdn.net/uploads/201304/03/1364958296_7554.jpg)选得很大的话，高次特征上的权重实际上衰减得非常快，所以实际上（数值上近似一下）相当于一个低维的子空间；反过来，如果![](https://img-my.csdn.net/uploads/201304/03/1364958296_7554.jpg)选得很小，则可以将任意的数据映射为线性可分——当然，这并不一定是好事，因为随之而来的可能是非常严重的过拟合问题。不过，总的来说，通过调控参数![](https://img-my.csdn.net/uploads/201304/03/1364958296_7554.jpg)，高斯核实际上具有相当高的灵活性，也是使用最广泛的核函数之一。下图所示的例子便是把低维线性不可分的数据通过高斯核函数映射到了高维空间：![](https://img-blog.csdn.net/20130919095640250)
- 线性核![](https://img-my.csdn.net/uploads/201304/03/1364958354_7262.jpg)，这实际上就是原始空间中的内积。这个核存在的主要目的是使得“映射后空间中的问题”和“映射前空间中的问题”两者在形式上统一起来了(意思是说，咱们有的时候，写代码，或写公式的时候，只要写个模板或通用表达式，然后再代入不同的核，便可以了，于此，便在形式上统一了起来，不用再分别写一个线性的，和一个非线性的)。
#### 核函数的本质
上面说了这么一大堆，读者可能还是没明白核函数到底是个什么东西？我再简要概括下，即以下三点：
- 实际中，我们会经常遇到线性不可分的样例，此时，我们的常用做法是把样例特征映射到高维空间中去(如上文2.2节最开始的那幅图所示，映射到高维空间后，相关特征便被分开了，也就达到了分类的目的)；
- 但进一步，如果凡是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到可怕的(如上文中19维乃至无穷维的例子)。那咋办呢？
- 此时，核函数就隆重登场了，核函数的价值在于它虽然也是讲特征进行从低维到高维的转换，但核函数绝就绝在它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就如上文所说的避免了直接在高维空间中的复杂计算。
    最后引用[这里](http://www.yaksis.com/posts/why-use-svm.html)的一个例子举例说明下核函数解决非线性问题的直观效果。
    假设现在你是一个农场主，圈养了一批羊群，但为预防狼群袭击羊群，你需要搭建一个篱笆来把羊群围起来。但是篱笆应该建在哪里呢？你很可能需要依据牛群和狼群的位置建立一个“分类器”，比较下图这几种不同的分类器，我们可以看到SVM完成了一个很完美的解决方案。
![](https://img-blog.csdn.net/20131121105410546)
    这个例子从侧面简单说明了SVM使用非线性分类器的优势，而逻辑模式以及决策树模式都是使用了直线方法。
