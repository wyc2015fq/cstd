# 旋转数组的二分查找 - 数据之美的博客 - CSDN博客
2017年09月10日 05:16:12[看穿数据之美](https://me.csdn.net/oppo62258801)阅读数：169
个人分类：[数据结构																[算法](https://blog.csdn.net/oppo62258801/article/category/6551325)](https://blog.csdn.net/oppo62258801/article/category/6551324)
来源： [http://www.jobcoding.com/array/one-sorted-array/rotate_array/](http://www.jobcoding.com/array/one-sorted-array/rotate_array/)
1. 问题描述
已知有序数组a[N]， 从中间某个位置k（k未知，k=-1表示整个数组有序）分开，然后将前后两部分互换，
得到新的数组，在该新数组的查找元素x。如：a[]={1,2,5,7,9,10,15}，从k=4分开，得到新数
组a={9,10,15, 1,2,5,7}。
<一次二分查找>：二分查找算法有两个关键点：1）数组有序；2）根据当前区间的中间元素与x的大小关系，
确定下次二分查找在前半段区间还是后半段区间进行。
仔细分析该问题，可以发现，每次根据low和high求出mid后，mid左边（[low, mid]）和右边（[mid, high]）
至少一个是有序的。
a[mid]分别与a[left]和a[right]比较，确定哪一段是有序的。
如果左边是有序的，若x<a[mid]且x>a[left], 则right=mid-1；其他情况，left =mid+1；
如果右边是有序的，若x> a[mid] 且x<a[right] 则left=mid+1；其他情况，right =mid-1；
**[cpp]**[view
 plain](http://blog.csdn.net/zzj1881/article/details/7346751#)[copy](http://blog.csdn.net/zzj1881/article/details/7346751#)
- int binary_search_rotate_arry(int *a, int n, int x)  
- {  
- int low = 0, high = n - 1, mid;  
- while(low <= high)  
-     {  
-         mid = low + ((high - low) >> 1);  
- if(a[mid] == x)  
- return mid;  
- if(a[mid] >= a[low])  
-         {//左边有序
- if(x < a[mid] && x >= a[low])  
-                 high = mid - 1;  
- else
-                 low = mid + 1;  
-         }  
- else//右边有序
-         {  
- if(x > a[mid] && x <= a[high])  
-                 low = mid + 1;  
- else
-                 high = mid - 1;  
-         }  
- //cout << low << " " << mid << " " << high << endl;
-     }  
- return -1;  
- }  
