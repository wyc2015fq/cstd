# 全排列 递归方法与非递归方法实现 - 数据之美的博客 - CSDN博客
2017年09月06日 20:56:55[看穿数据之美](https://me.csdn.net/oppo62258801)阅读数：140

版权声明：本文为博主原创文章，未经博主允许不得转载。
目录[(?)](http://blog.csdn.net/morewindows/article/details/7370155/#)[[-]](http://blog.csdn.net/morewindows/article/details/7370155/#)
- [一全排列的递归实现](http://blog.csdn.net/morewindows/article/details/7370155/#t0)
- [二去掉重复的全排列的递归实现](http://blog.csdn.net/morewindows/article/details/7370155/#t1)
- [三全排列的非递归实现](http://blog.csdn.net/morewindows/article/details/7370155/#t2)
全排列在笔试面试中很热门，因为它难度适中，既可以考察递归实现，又能进一步考察非递归的实现，便于区分出考生的水平。所以在百度和迅雷的校园招聘以及程序员和软件设计师的考试中都考到了，因此本文对全排列作下总结帮助大家更好的学习和理解。对本文有任何补充之处，欢迎大家指出。
首先来看看题目是如何要求的（百度迅雷校招笔试题）。
用C++写一个函数, 如 Foo(const char *str), 打印出 str 的全排列, 
如 abc 的全排列: abc, acb, bca, dac, cab, cba
# 一．全排列的递归实现
为方便起见，用123来示例下。123的全排列有123、132、213、231、312、321这六种。首先考虑213和321这二个数是如何得出的。显然这二个都是123中的1与后面两数交换得到的。然后可以将123的第二个数和每三个数交换得到132。同理可以根据213和321来得231和312。因此可以知道——**全排列就是从第一个数字起每个数分别与它后面的数字交换。**找到这个规律后，递归的代码就很容易写出来了：
**[cpp]**[view
 plain](http://blog.csdn.net/morewindows/article/details/7370155/#)[copy](http://blog.csdn.net/morewindows/article/details/7370155/#)
- //全排列的递归实现
- #include <stdio.h>
- #include <string.h>
- void Swap(char *a, char *b)  
- {  
- char t = *a;  
-     *a = *b;  
-     *b = t;  
- }  
- //k表示当前选取到第几个数,m表示共有多少数.
- void AllRange(char *pszStr, int k, int m)  
- {  
- if (k == m)  
-     {  
- staticint s_i = 1;  
-         printf("  第%3d个排列\t%s\n", s_i++, pszStr);  
-     }  
- else
-     {  
- for (int i = k; i <= m; i++) //第i个数分别与它后面的数字交换就能得到新的排列
-         {  
-             Swap(pszStr + k, pszStr + i);  
-             AllRange(pszStr, k + 1, m);  
-             Swap(pszStr + k, pszStr + i);  
-         }  
-     }  
- }  
- void Foo(char *pszStr)  
- {  
-     AllRange(pszStr, 0, strlen(pszStr) - 1);  
- }  
- int main()  
- {  
-     printf("         全排列的递归实现\n");  
-     printf("  --by MoreWindows( http://blog.csdn.net/MoreWindows )--\n\n");  
- char szTextStr[] = "123";  
-     printf("%s的全排列如下:\n", szTextStr);  
-     Foo(szTextStr);  
- return 0;  
- }  
运行结果如下：
![](http://hi.csdn.net/attachment/201203/19/0_1332153878mG2D.gif)
注意这样的方法没有考虑到重复数字，如122将会输出：
![](http://hi.csdn.net/attachment/201203/19/0_1332153901A6da.gif)
这种输出绝对不符合要求，因此现在要想办法来去掉重复的数列。
# 二．去掉重复的全排列的递归实现
由于**全排列就是从第一个数字起每个数分别与它后面的数字交换。**我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。
*换种思维*，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。
这样我们也得到了在全排列中去掉重复的规则——**去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。**用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。下面给出完整代码：
**[cpp]**[view
 plain](http://blog.csdn.net/morewindows/article/details/7370155/#)[copy](http://blog.csdn.net/morewindows/article/details/7370155/#)
- //去重全排列的递归实现
- #include <stdio.h>
- #include <string.h>
- void Swap(char *a, char *b)  
- {  
- char t = *a;  
-     *a = *b;  
-     *b = t;  
- }  
- //在pszStr数组中，[nBegin,nEnd)中是否有数字与下标为nEnd的数字相等
- bool IsSwap(char *pszStr, int nBegin, int nEnd)  
- {  
- for (int i = nBegin; i < nEnd; i++)  
- if (pszStr[i] == pszStr[nEnd])  
- returnfalse;  
- returntrue;  
- }  
- //k表示当前选取到第几个数,m表示共有多少数.
- void AllRange(char *pszStr, int k, int m)  
- {  
- if (k == m)  
-     {  
- staticint s_i = 1;  
-         printf("  第%3d个排列\t%s\n", s_i++, pszStr);  
-     }  
- else
-     {  
- for (int i = k; i <= m; i++) //第i个数分别与它后面的数字交换就能得到新的排列
-         {  
- if (IsSwap(pszStr, k, i))  
-             {  
-                 Swap(pszStr + k, pszStr + i);  
-                 AllRange(pszStr, k + 1, m);  
-                 Swap(pszStr + k, pszStr + i);  
-             }  
-         }  
-     }  
- }  
- void Foo(char *pszStr)  
- {  
-     AllRange(pszStr, 0, strlen(pszStr) - 1);  
- }  
- int main()  
- {  
-     printf("         去重全排列的递归实现\n");  
-     printf("  --by MoreWindows( http://blog.csdn.net/MoreWindows )--\n\n");  
- char szTextStr[] = "122";  
-     printf("%s的全排列如下:\n", szTextStr);  
-     Foo(szTextStr);  
- return 0;  
- }  
运行结果如下：
![](http://hi.csdn.net/attachment/201203/19/0_13321539194BOq.gif)
OK，到现在我们已经能熟练写出递归的方法了，并且考虑了字符串中的重复数据可能引发的重复数列问题。那么如何使用非递归的方法来得到全排列了？
# 三．全排列的非递归实现
要考虑全排列的非递归实现，先来考虑如何计算字符串的下一个排列。如"1234"的下一个排列就是"1243"。只要对字符串反复求出下一个排列，全排列的也就迎刃而解了。
如何计算字符串的下一个排列了？来考虑"926520"这个字符串，我们从后向前找第一双相邻的递增数字，"20"、"52"都是非递增的，"26 "即满足要求，称前一个数字2为替换数，替换数的下标称为替换点，再从后面找一个比替换数大的最小数（这个数必然存在），0、2都不行，5可以，将5和2交换得到"956220"，然后再将替换点后的字符串"6220"颠倒即得到"950226"。
对于像"4321"这种已经是最“大”的排列，采用STL中的处理方法，将字符串整个颠倒得到最“小”的排列"1234"并返回false。
这样，只要一个循环再加上计算字符串下一个排列的函数就可以轻松的实现非递归的全排列[算法](http://lib.csdn.net/base/datastructure)。按上面思路并参考STL中的实现源码，不难写成一份质量较高的代码。值得注意的是在循环前要对字符串排序下，可以自己写快速排序的代码（请参阅《[白话经典算法之六
 快速排序 快速搞定](http://blog.csdn.net/morewindows/article/details/6684558)》），也可以直接使用VC库中的快速排序函数（请参阅《[使用VC库函数中的快速排序函数](http://blog.csdn.net/morewindows/article/details/6684561)》）。下面列出完整代码：
**[cpp]**[view
 plain](http://blog.csdn.net/morewindows/article/details/7370155/#)[copy](http://blog.csdn.net/morewindows/article/details/7370155/#)
- //全排列的非递归实现
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
- void Swap(char *a, char *b)  
- {  
- char t = *a;  
-     *a = *b;  
-     *b = t;  
- }  
- //反转区间
- void Reverse(char *a, char *b)  
- {  
- while (a < b)  
-         Swap(a++, b--);  
- }  
- //下一个排列
- bool Next_permutation(char a[])  
- {  
- char *pEnd = a + strlen(a);  
- if (a == pEnd)  
- returnfalse;  
- char *p, *q, *pFind;  
-     pEnd--;  
-     p = pEnd;  
- while (p != a)  
-     {  
-         q = p;  
-         --p;  
- if (*p < *q) //找降序的相邻2数,前一个数即替换数
-         {  
- //从后向前找比替换点大的第一个数
-             pFind = pEnd;  
- while (*pFind <= *p)  
-                 --pFind;  
- //替换
-             Swap(pFind, p);  
- //替换点后的数全部反转
-             Reverse(q, pEnd);  
- returntrue;  
-         }  
-     }  
-     Reverse(p, pEnd);//如果没有下一个排列,全部反转后返回true
- returnfalse;  
- }  
- int QsortCmp(constvoid *pa, constvoid *pb)  
- {  
- return *(char*)pa - *(char*)pb;  
- }  
- int main()  
- {  
-     printf("         全排列的非递归实现\n");  
-     printf("  --by MoreWindows( http://blog.csdn.net/MoreWindows )--\n\n");  
- char szTextStr[] = "abc";  
-     printf("%s的全排列如下:\n", szTextStr);  
- //加上排序
-     qsort(szTextStr, strlen(szTextStr), sizeof(szTextStr[0]), QsortCmp);  
- int i = 1;  
- do{  
-         printf("第%3d个排列\t%s\n", i++, szTextStr);  
-     }while (Next_permutation(szTextStr));  
- return 0;  
- }  
[测试](http://lib.csdn.net/base/softwaretest)一下，结果如下所示：
![](http://hi.csdn.net/attachment/201203/19/0_1332153935m1l5.gif)
将字符串改成"cba"会输出：
![](http://hi.csdn.net/attachment/201203/21/0_1332314873UCct.gif)
至此我们已经运用了递归与非递归的方法解决了全排列问题，总结一下就是：
1．**全排列就是从第一个数字起每个数分别与它后面的数字交换。**
2．**去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。**
3．**全排列的非递归就是由后向前找替换数和替换点，然后由后向前找第一个比替换数大的数与替换数交换，最后颠倒替换点后的所有数据。**
转载请标明出处，原文地址：[http://blog.csdn.net/morewindows/article/details/7370155](http://blog.csdn.net/morewindows/article/details/7370155)
如果觉得本文对您有帮助，请点击‘顶’支持一下，您的支持是我写作最大的动力，谢谢。
