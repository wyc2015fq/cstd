# 深入理解Java虚拟机学习笔记——一、JVM结构 - 隔壁老王的专栏 - CSDN博客





2017年03月16日 22:56:29[隔壁老王来也](https://me.csdn.net/haoyuyang)阅读数：720








# **运行时数据区**



JVM在执行Java程序时会将它所管理的内存划分成若干个不同的数据区域，每个区域都有各自的用途以及创建、销毁的时间。有些区域随着JVM虚拟机进程的启动而存在，有些区域则依赖于用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，JVM所管理的内存会被划分成一下几个运行时数据区：

![](https://img-blog.csdn.net/20170316225517618)

## 
- **程序计数器**

        可以把程序计数器看作是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器在工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

        由于Java虚拟机的多线程是通过轮流切换线程并分配处理器执行时间的方式实现的，因此为了使线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，这类内存区域被称为“线程私有”的内存。

## 
- **虚拟机栈**

        Java虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java线程执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

        我们经常把Java内存分为“栈内存”和“堆内存”，这里的“栈内存”就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分。

        局部变量表存放了编译器各种已知的基本数据类型（byte,char,short,int,long,float,double,boolean）、对象引用类型（reference）和returnAddress类型（指向了一条字节码指令的地址）。

        64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

        在这个区域中规定了两种异常：①当线程所请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常。②如果虚拟机栈可以动态扩展，但申请不到足够内存时，将会抛出OutOfMemoryError异常。

## 
- **本地方法栈**

        本地方法栈发挥的作用与虚拟机栈相同，不同点在于虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈是为虚拟机执行Native方法服务。

## 
- **Java堆**

        Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。该内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在该区域分配内存。Java虚拟机规范中对Java堆的描述：所有的对象实例及数组都要在堆上分配。

        Java堆是垃圾收集器管理的主要区域，因此也将Java堆称为“GC堆”。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代。从内存分配角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。如果在堆中没有足够的内存来分配给实例，并且堆也无法再扩展，将会抛出OutOfMemoryError异常。

## 
- **方法区**

        方法区与Java堆一样，也被所有线程共享。方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在HotSpot虚拟机中，方法区也被称为“永久代”，本质上两者并不等价，仅仅是因为HotSpot虚拟机把GC分代收集扩展至方法区，或者使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存。但是使用永久代来实现方法区更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限），而且极少数方法，如String.itern()会因为这个原因导致在不同的虚拟机下有不同的表现。因此，现在HotSopt的规划路线中也有放弃永久的并逐步采用Native Memory来实现方法区的规划了。在JDK 1.7的HotSpot中，已经将原本存放于永久代中的字符串常量池移出。

        根据虚拟机规范的规定，当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。

JDK 1.8已经将常量池从方法区中移除，并将其放入了堆内存中。

### 
- **运行时常量池**

        运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面常量和符号引用，这部分内容会在类加载后进入方法区的运行时常量池。

        既然运行时常量池作为方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时就会抛出OutOfMemoryError异常。

## 
- **直接内存**

        直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK 1.4中新加入了NIO类，引入了一种基于通道、缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

        显然本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存肯定会受到本机中内存大小以及处理器寻址空间的限制。在配置-Xmx等参数信息时，通常会忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。





















