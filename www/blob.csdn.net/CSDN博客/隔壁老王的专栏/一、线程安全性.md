# 一、线程安全性 - 隔壁老王的专栏 - CSDN博客





2016年11月10日 21:26:41[隔壁老王来也](https://me.csdn.net/haoyuyang)阅读数：1002








**1.什么是线程安全性**

**正确性：**某个类的行为与其规范完全一致。

**线程安全性：**当多个线程访问某个类时，该类始终都能表现出正确性的行为。

*当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么久称这个类是线程安全的。*

**2.原子性**

**竞态条件：**由于不恰当的执行时序而出现不正确结果的现象。

*当计算机的正确性取决于多个线程的执行时序时，那么就会发生竞态条件。*

**原子性：**一组语句作为一个不可分割的单元被执行。

**3.加锁机制**

*要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。*

（1）内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两个部分：一个作为锁的对象引用，一个做为这个锁保护的代码块。静态synchronized方法以Class对象作为锁。每个Java对象都可以做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能够持有这种锁。任何一个执行同步代码块的线程，都不可能看到其他线程正在执行由同一个锁保护的同步代码块。

（2）重入

由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁时，那么这个请求就会成功。“重入”意味着获取锁的操作是线程，而不是调用。

如果内置锁不是可重入的，那么下面这段代码将发生死锁：



```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}

public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString + ": calling doSomething");
        super.doSometing();
    }
}
```
**4.用锁来保护状态**


*对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，我们就称状态变量是由这个锁保护的。对于每个包含多个变量的不变性条件，其中涉及的素有*

*变量都需要由同一个锁来保护。*

**



