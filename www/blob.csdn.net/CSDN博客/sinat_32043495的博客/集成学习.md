# 集成学习 - sinat_32043495的博客 - CSDN博客





2017年12月08日 20:56:50[LZXandTM](https://me.csdn.net/sinat_32043495)阅读数：705








## **一.集成学习的概念**

   通过构建并结合多个学习器来完成学习任务，先产生一组"个体学习器",再用某种策略将它们结合起来,个体学习器通常由一个现有的算法从训练数据中产生,例如C4.5决策树算法、BP神经网络算法等,此时集成中只包含同种类型的个体学习器,例如"决策树集成"中全是决策树,“神经网络集成”中全是神经网络,这样的集成是同质的,其中的个体学习器亦称基学习器;集成也可以包含不同类型的个体学习器,例如同时包含决策树和神经网络,这样的集成是异质的。

## **二.集成学习为什么有效**

** a) **统计上的原因
  对于一般的学习任务，往往要搜索的假设空间十分巨大，但是能够用于训练分类器的训练集中实例个数不足够用来精确地学习到目标假设，这个时候学习的结果便可能是一系列满足训练集的假设，而学习算法只能够选择这些假设的其中之一作为学习到的分类器进行输出。然而通过机器学习的过拟合问题我们看到，能够满足训练集的假设不一定在实际应用中有同样好的表现，这样学习算法选择哪个假设进行输出的时候就面临着一定的风险，把多个假设集成起来能够降低这种风险（这可以理解为通过集成使得各个假设和目标假设之间的误差得到一定程度的抵消）

** b)**计算上的原因
  已经证明了在人工神经网络学习和决策树学习中，学习到最好的人工神经网络或者是决策树是一个NP-hard 问题，其他的分类器模型也面临着类似的计算复杂度的问题。这使得我们只能用某些启发式的方法来降低寻找目标假设的复杂度，但这样的结果是找到的假设不一定是最优的。通过把多个假设集成起来能够使得最终的结果更加接近实际的目标函数值
** c) **表示上的原因
  由于假设空间是人为规定的，在大多数机器学习的应用场合中实际目标假设并不在假设空间之中，如果假设空间在某种集成运算下不封闭，那么我们通过把假设空间中的一系列假设集成起来就有可能表示出不在假设空间中的目标假设。

## **三.集成学习有效的条件**

   虽然以上几方面的原因使得集成学习可能取得更好的学习效果，但是并不是所有的集成方式都有效的，集成学习有效的条件是每个单一的学习器错误率都应当低于 0.5，否则集成的结果反而会提高错误率。此外，进行集成学习的每个分类器还应当各不相同，这个要求可以这样理解：如果每个基本分类器分类结果差不多，则集成后的分类器整体和单个分类器做出的决策实际上没有什么差异，这样集成后的分类器就难以保证比单个分类器有更好的性能了。

   所以，要获得好的集成，个体学习器应好而不同，即个体学习器要有一定的准确性，即学习器不能太坏，并且要有多样性，即学习器间具有差异

## **四.集成学习方法介绍**

一种是个体学习器间存在强依赖关系、可同时生成的并行化方法，代表是Boosting；

 另一种是个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是Bagging和随机森林。

插入方差和偏差的概念:



**偏差：**描述的是预测值（估计值）的期望与真实值之间的差距。偏差越大，越偏离真实数据。

**方差：**描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散。


![](https://img-blog.csdn.net/20171207100605111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20180314195850369)

A complex model will have large variance. 


We can average complex models to reduce variance. 
If we average all the f*,is it close to f^. 
所以，如果想让一个variance很大的model的error变小，可以训练好多个variance很大的model，然后把它们平均起来，这个方法就叫做Bagging。

### 1.Boosting
先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前的基学习器做错的训练样本在后续受到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最终将这T个基学习器进行加权结合--Adaboost--"Adaptive Boosting"（自适应增强）


它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。

具体说来，整个Adaboost 迭代算法就3步：

 初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N;

 训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去;

 将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。

![](https://img-blog.csdn.net/20171207103815542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


** 例子：**

![](https://img-blog.csdn.net/20171207105152098?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20171207105200992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


Adaboost最终分类器的误差上界:

![](https://img-blog.csdn.net/20171207111724415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20171207112656935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/2018031421061866)


### 2.Bagging与随机森林

![](https://img-blog.csdn.net/20171207114443914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


 随机森林是bagging的一个特化进阶版，所谓的特化是因为随机森林的弱学习器都是决策树。所谓的进阶是随机森林在bagging的样本随机采样基础上，又加上了特征的随机选择，其基本思想没有脱离bagging的范畴。


#### 决策树的类型：

**number of branches, Branching criteria, termination criteria, base hypothesis**

决策树（DecisionTree）又称为判定树，是运用于分类的一种树结构。其中的每个内部结点（internalnode）代表对某个属性的一次测试，每条边代表一个测试结果，叶结点（leaf）代表某个类（class）或者类的分布（classdistribution），最上面的结点是根结点

##### **a)ID3决策树**

![](https://img-blog.csdn.net/20171207214239352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)




![](https://img-blog.csdn.net/20171207214245891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20171207214254572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


##### b)**C4.5算法**



改进1：用信息增益率代替信息增益来选择属性

改进2：能够完成对连续值属性的离散化处理

改进3：能处理属性值缺失的情况

改进4：在决策树构造完成之后进行剪枝

###### **改进1：**



**![](https://img-blog.csdn.net/20171207220330970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**

**![](https://img-blog.csdn.net/20171207220342610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**

**![](https://img-blog.csdn.net/20171207220353659?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**

###### 改进2：

![](https://img-blog.csdn.net/20171208161244358?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


###### 改进3：

![](https://img-blog.csdn.net/20171208163304144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20171208163332026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


###### **改进4：**

解决过拟合的问题,具体见上一条博客

c) CART决策树



分类回归树（CART:Classificationand Regression Tree）其特点是在计算过程中充分利用二分支树的结构（BianryTree-structured），即根节点包含所有样本，在一定的分裂规则下根节点被分裂为两个子节点，这个过程又在子节点上重复进行，直至不可再分，成为叶节点为止。

**使用GINI指标来选择分裂属性**


![](https://img-blog.csdn.net/20171208212442984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![](https://img-blog.csdn.net/20171208212459406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


### 结合策略:

a) 平均法

![](https://img-blog.csdn.net/20171208200949967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


b)投票法

![](https://img-blog.csdn.net/20171208201543316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


c)学习法

当训练数据很多时，一种更为强大的结合策略是使用"学习法"，即通过另一个学习器来进行结合,Stacking是学习法的典型代表。个体学习器称为初级学习器,用于结合的学习器称为次级学习器或元学习器

Stacking先从初始数据集训练出初级学习器，然后生成一个新数据集用于训练次级学习器.在这个新数据集中，初级学习器的输出被当作样例输入特征，而初始样本的标记仍被当作样例标记

![](https://img-blog.csdn.net/20171208203436980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


![](https://img-blog.csdn.net/20171208203500283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzIwNDM0OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


**论文实例：**

**Fast Image Interpolation via Random Forests**

**![](https://img-blog.csdn.net/20180314204759989)![](https://img-blog.csdn.net/20180314204810606)![](https://img-blog.csdn.net/20180314204819299)**

**附录：**

**![](https://img-blog.csdn.net/20180314205617593)![](https://img-blog.csdn.net/20180314205622298)![](https://img-blog.csdn.net/20180314205627164)![](https://img-blog.csdn.net/20180314205631917)![](https://img-blog.csdn.net/2018031420563693)**



**SRopts.pRegrForest.M = 10;SRopts.pRegrForest.maxDepth = 15;SRopts.pRegrForest.nodesubsample = 512;SRopts.pRegrForest.verbose = 1;**

**SRopts.pRegrForest.N1 = size(patchesSrcPca,2);**

Reference:

1.https://pan.baidu.com/s/1hqePkdY

2.http://scott.fortmann-roe.com/docs/BiasVariance.html

3.http://blog.51cto.com/baidutech/743809

4.https://wenku.baidu.com/view/6894c8fd05a1b0717fd5360cba1aa81144318f2d.html

5.https://rasbt.github.io/mlxtend/user_guide/classifier/StackingClassifier/



