# C++基础问题 - sinat_32043495的博客 - CSDN博客





2018年03月15日 16:37:06[LZXandTM](https://me.csdn.net/sinat_32043495)阅读数：41








**C++内存管理机制:**



· 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等,其操作方式类似于数据结构中的栈。

· 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式类似于链表。

· 全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放

· 文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放

程序代码区—存放函数体的二进制代码

//main.cpp 程序代码区

int a = 0; //全局初始化区 

char *p1; //全局未初始化区 

main() 

{ 

int b; //栈 

char s[] = "abc"; //栈 

char *p2; //栈 

char *p3 = "123456"; //123456\0在常量区，p3在栈上。 

static int c =0； //全局（静态）初始化区 

p1 = (char *)malloc(10); 

p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 malloc必须进行强制类型转换。

strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 

}



**常见的内存错误及其对策**

发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。常见的内存错误及其对策如下：

* 内存分配未成功，却使用了它。

　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行

　　检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。

* 内存分配虽然成功，但是尚未初始化就引用它。

　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

* 内存分配成功并且已经初始化，但操作越过了内存的边界。

　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。

* 忘记了释放内存，造成内存泄露。

　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。

　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。

* 释放了内存却继续使用它。

    有三种情况：

　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。

　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。

　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。

　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。

1. 变量声明和定义区别？

    - 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。

    - 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

    int a;//属于声明并定义了a，申请了内存空间，但没有初始化

extern int a;//声明了a为int类型，但没有定义，没有申请存储空间
- void main()  
- {  
- externint a;//定义和声明不能放在同一个函数里
- int a=10;   //再定义a=10错误
-     cout<<hex<<&a<<endl;  
- }  
- externint a;//这是声明
- void main()  
- {  
- int a=10;   //（这是定义）并且这样定义是对的
-     cout<<hex<<&a<<endl;  
- }  
- void main()  
- {  
- externint a;//声明
-     cout<<hex<<&a<<endl;//这说明声明是不占内存空间的，所以这个取地址是错误的
- }  
- externint a;//说明声明可以声明多次，而定义却只能定义一次
- externint a;  
- externint a;  
- void main()  
- {  
- int a=10;  
-     cout<<a<<endl;  
- }     

2. "零值比较"？
    - bool类型：if(flag)

    - int类型：if(flag == 0)

    - 指针类型：if(flag == null)

    - float类型：if((flag >= -0.000001) && (flag <= 0. 000001))


3. strlen和sizeof区别？
    - sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。

    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。


    - **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**


4. 同一不同对象可以互相赋值吗？
    - 可以，但含有指针成员时需要注意。

    - 对比类的对象赋值时深拷贝和浅拷贝。


5. 结构体内存对齐问题？
    - 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

    - 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。


6. static作用是什么？在C和C++中有何区别？
    - static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。

    - C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。

    - static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。

    - 未初始化时，static变量默认值为0。


7. 结构体和类的区别？
    - 结构体的默认限定符是public；类是private。

    - ~~结构体不可以继承，类可以。~~ C++中结构体也可以继承。


8. malloc和new的区别？
    - malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。

    - malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。

    - malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。


9. 指针和引用区别？
    - 引用只是别名，不占用具体存储空间，只有声明没有定义；指针时具体变量，需要占用存储空间。

    - 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

    - 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

    - 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。


10. 宏定义和函数有何区别？
    - 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。

    - 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。

    - 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。

    - 宏函数不要在最后加分号。


11. 宏定义和const区别？
    - 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。

    - 宏不检查类型；const会检查数据类型。

    - 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。


12. 宏定义和typedef区别？
    - 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

    - 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。

    - 宏不检查类型；typedef会检查数据类型。

    - 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

    - 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。


13. 宏定义和内联函数(inline)区别？
    - 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

    - 内联函数本身是函数，强调函数特性，具有重载等功能。

    - 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。


14. 条件编译#ifdef, #else, #endif作用？
    - 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。

    - 用于子程序前加#define DEBUG用于程序调试。

    - 应对硬件的设置（机器类型等）。

    - 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。


15. 区别以下几种变量？


        const int a;
        int const a;
        const int *a; *a**指向的内容不可以修改*
        int *const a; //*a**指针不能指向其他地方，比如**a ++*
    - int const a和const int a均表示定义常量类型a。

    - const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)

    - int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)


16. volatile有什么作用？
    - volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

    - 多线程中被几个任务共享的变量需要定义为volatile类型。


17. 什么是常引用？
    - 常引用可以理解为常量指针，形式为const typename & refname = varname。

    - 常引用下，原变量值不会被别名所修改。

    - 原变量的值可以通过原名修改。

    - 常引用通常用作只读变量别名或是形参传递。


18. 区别以下指针类型？


        int *p[10]
        int (*p)[10]
        int *p(int)
        int (*p)(int)


    - int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。

    - int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

    - int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。

    - int (*p)()是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。


19. 常量指针和指针常量区别？
    - 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。

    - 指针常量是一个不能给改变指向的指针。如int *const p。


20. a和&a有什么区别？


        假设数组int a[10];
        int (*p)[10] = &a;


    - a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。

    - &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。

    - 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。


21. 数组名和指针（这里为指向数组首元素的指针）区别？
    - 二者均可通过增减偏移量来访问数组中的元素。

    - 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。

    - 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。


22. 野指针是什么？

    - 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。



野指针：指向不确定地址的指针变量。（即没有初始化）使用野指针易因内存泄露出现段错误。而造成内存泄露的原因有两个：

1.访问了没有权限的内存（平时我们正确使用指针的时候，系统应经将相应的内存分配给用户，但是如果指向没有分配的内存，系统会判定我们没有权限）

2.访问了已经释放了的内存
    - 产生原因及解决办法：
         - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

         - 指针free或delete之后没有及时置空 => 释放操作后立即置空。


23. 堆和栈的区别？

    - 申请方式不同。

        - 栈由系统自动分配。

        - 堆由程序员手动分配。

    - 申请大小限制不同。

        - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。

        - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

    - 申请效率不同。

        - 栈由系统分配，速度快，不会有碎片。

        - 堆由程序员分配，速度慢，且会有碎片。






**stack: **

由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 

分配方式：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出

大小限制：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小

分配效率：栈由系统自动分配，速度较快。但程序员是无法控制的

调用过程：在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

**heap: **

需要程序员自己申请，并指明大小，在c中malloc函数 

如p1 = (char *)malloc(10); 

在C++中用new运算符 

如p2 = (char *)malloc(10); 

但是注意p1、p2本身是在栈中的。

分配方式：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

大小限制：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

分配效率：堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便

调用过程：一般是在堆的头部用一个字节存放堆的大小,堆中的具体内容由程序员安排

24. delete和delete[]区别
    - delete只会调用一次析构函数。

    - delete[]会调用数组中每个元素的析构函数。

C++告诉我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。 


关于 new[] 和 delete[]，其中又分为两种情况：(1) 为基本数据类型分配和回收空间；(2) 为自定义类型分配和回收空间。




|```cpp#include <iostream>;``````cppusing``````cppnamespace``````cppstd;``````cppclass``````cppT {``````cpppublic``````cpp:``````cpp``````cppT() { cout <<``````cpp"constructor"``````cpp<< endl; }``````cpp``````cpp~T() { cout <<``````cpp"destructor"``````cpp<< endl; }``````cpp};``````cppint``````cppmain()``````cpp{``````cpp``````cppconst``````cppint``````cppNUM = 3;``````cpp``````cppT* p1 =``````cppnew``````cppT[NUM];``````cpp``````cppcout << hex << p1 << endl;``````cpp``````cpp//  delete[] p1;``````cpp``````cppdelete``````cppp1;``````cpp``````cppT* p2 =``````cppnew``````cppT[NUM];``````cpp``````cppcout << p2 << endl;``````cpp``````cppdelete``````cpp[] p2;``````cpp}```|
|----|

大家可以自己运行这个程序，看一看 delete p1 和 delete[] p1 的不同结果，我就不在这里贴运行结果了。

    从运行结果中我们可以看出，delete p1 在回收空间的过程中，只有 p1[0] 这个对象调用了析构函数，其它对象如 p1[1]、p1[2] 等都没有调用自身的析构函数，这就是问题的症结所在。如果用 delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。 
    基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。 
    所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。




