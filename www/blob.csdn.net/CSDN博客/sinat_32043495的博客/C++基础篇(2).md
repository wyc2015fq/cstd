# C++基础篇(2) - sinat_32043495的博客 - CSDN博客





2018年03月26日 10:08:37[LZXandTM](https://me.csdn.net/sinat_32043495)阅读数：64








![](https://img-blog.csdn.net/20180326100650170)




![](https://img-blog.csdn.net/20180326100955796)


![](https://img-blog.csdn.net/2018032610092097)

![](https://img-blog.csdn.net/20180326100930503)![](https://img-blog.csdn.net/20180326100748447)


![](https://img-blog.csdn.net/20180326100950897)





![](https://img-blog.csdn.net/20180326100721395)


![](https://img-blog.csdn.net/20180326100732942)


![](https://img-blog.csdn.net/2018032610074043)


![](https://img-blog.csdn.net/20180326100914989)



a从栈中实例化 TV tv; TV tv[20]; b从堆中实例化 TV *p = new TV(); TV *q = new TV[]; delete p; delete []q; c对象成员的访问 tv.type = 0; tv.changeVol(); || p->type = 0; p->changeVol();从栈实例化对象：自动分配释放内存。从堆实例化对象：手动分配释放内存.
![](https://img-blog.csdn.net/20180326100924961)
![](https://img-blog.csdn.net/20180326101007669)![](https://img-blog.csdn.net/20180326100936889)



**析构函数用于删除数据，不允许传入参数，也不允许重载**
![](https://img-blog.csdn.net/20180326100942215)
![](https://img-blog.csdn.net/20180326101027902)![](https://img-blog.csdn.net/20180326100946721)

![](https://img-blog.csdn.net/20180326101049764)![](https://img-blog.csdn.net/20180326101000890)



**初始化列表中初始化只能用括号，不能用等号**

![](https://img-blog.csdn.net/2018032610102431)![](https://img-blog.csdn.net/2018032610103689)



**初始化列表和构造函数，构造函数不能完全代替初始化列表的作用，比如 const pi**

![](https://img-blog.csdn.net/20180326101039980)

**错误的**

![](https://img-blog.csdn.net/20180326101045597)

![](https://img-blog.csdn.net/20180326104530115)![](https://img-blog.csdn.net/20180326104541963)![](https://img-blog.csdn.net/20180326104549563)![](https://img-blog.csdn.net/20180326104554652)



this就是所在对象的地址

this指针一般都是系统默认调用，以防止在实例化对象调用成员函数的时候出现错误，保证一一对应，当数据成员和构造函数中的形参名字相同是，计算机会分不清楚谁给谁赋值，这是需要人工加上this指针，用来区别。系统自动为每一个成员函数的参数列表加了一个this指针，它是指向本类对象的指针，它的值是当前被调用的成员函数所在对象的起始地址

![](https://img-blog.csdn.net/20180326104601212)![](https://img-blog.csdn.net/20180326104607288)



**如果对象成员为指针，则在sizeof（line）计算对象内存时，只计算对象成员指针的占用的空间大小，其指出去的那块内存（这里是m_iX等）不被算入。**

![](https://img-blog.csdn.net/2018032610461273)



**深拷贝（如果存在指针，则在拷贝构造函数中new一块内存，存要被拷贝的对象的值）**

**浅拷贝(只是简单的值传递） 注意：在浅拷贝中，arr1的m_pArr指针 和 arr2的m_pArr指针会指向同一块内存地址。这样在对象析构函数会对同一块内存地址释放两次，结果就是计算机奔溃了，发生运行时错误。**
![](https://img-blog.csdn.net/20180326104616799)![](https://img-blog.csdn.net/20180326104621822)![](https://img-blog.csdn.net/20180326104625961)


