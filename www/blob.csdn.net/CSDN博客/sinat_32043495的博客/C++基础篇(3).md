# C++基础篇(3) - sinat_32043495的博客 - CSDN博客





2018年03月26日 11:35:37[LZXandTM](https://me.csdn.net/sinat_32043495)阅读数：69








![](https://img-blog.csdn.net/20180326112736178)![](https://img-blog.csdn.net/20180326112746267)

![](https://img-blog.csdn.net/20180326112959865)![](https://img-blog.csdn.net/2018032611311956)![](https://img-blog.csdn.net/20180326112755254)![](https://img-blog.csdn.net/2018032611314848)

派生类可以赋值给基类，反之不可

![](https://img-blog.csdn.net/20180326112805951)![](https://img-blog.csdn.net/2018032611282474)



重载函数的特性：

    （1）相同的范围（在同一个类中）；
    （2）函数名字相同；
    （3）参数不同；
    （4）virtual关键字可有可无。

     因为函数参数不同，可以简单的理解为：两个重载函数是不同的函数，调用者能够明确

的根据不同的参数来调用不同的函数。那么如果存在这样两个函数，编译器怎么处理呢？

class A
{
public:
    void Func(int a, int b=0) {printf("This is Func1/n");}
    void Func(int a) {printf("This is Func2/n");}
};

 int main()

{
    A a;
    a.Func(5);
    return 0;
}

 当然，对于这样两个函数，调用者不知道应该调用哪个函数，故编译器直接报错。

我们在看看，覆盖和隐藏分别是什么特性呢？从字面意思来讲，覆盖和隐藏都具有一个把另

一个给遮住了，那只不过是谁遮谁的问题。


    覆盖，是指派生类函数覆盖基类函数，只作用于派生类函数，其特性为：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual关键字。

我们发现，这里用到了虚函数，实际上虚函数的作用，就是实现覆盖。




#include<iostream>

usingnamespacestd;

class Base

{

public:    

virtualvoid fun(int i)

{ 

cout << "Base::fun(int) : " << i << endl;

}

};

class Derived : public Base

{public:    

virtualvoid fun(int i)

{ 

cout << "Derived::fun(int) : " << i << endl;

}

};

int main()

{    

Base b;   

Base * pb = new Derived();    

pb->fun(3);//Derived::fun(int)

system("pause");    

return0;}


隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。


#include <iostream>

usingnamespacestd;

class Base{

public:    void fun(double ,int )

{ cout << "Base::fun(double ,int )" << endl; }

};

class Derive : public Base{

public:    void fun(int )

{ 

cout << "Derive::fun(int )" << endl; 

}

};

int main()

{    

Derive pd;    

pd.fun(1);//Derive::fun(int )

pb.fun(0.01, 1);//error C2660: “Derive::fun”: 函数不接受 2 个参数

system("pause");    

return0;

}

![](https://img-blog.csdn.net/20180326112952155)
父类的指针无法调用其子类的数据成员和成员函数

![](https://img-blog.csdn.net/2018032611305018)



菱形继承，这时D类会有两份继承来的A的数据，用虚继承可以避免这种情况

虚继承，保证Farmer和Worker被MigrantWorker继承时，只有一份Person的数据成员m_strColor

![](https://img-blog.csdn.net/20180326113026539)

![](https://img-blog.csdn.net/20180326113058611)![](https://img-blog.csdn.net/20180326113111986)


