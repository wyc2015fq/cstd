# 去中心化的网络设计 — P2P的实现 - qq_42302962的博客 - CSDN博客
2018年05月31日 11:02:10[Linux高级开发](https://me.csdn.net/qq_42302962)阅读数：1136
随着区块链的越来越火，去中心化的网络设计再次被拿到技术人员面前。在这里我使用非常通俗的语言，帮大家来理解去中心化的网络设计的基础—网络穿透。再使用代码来实现穿透。如果阐述不到位的地方，欢迎大家抛砖。
在有中心化服务器的网络中，客户端，服务器，网关构成网络拓扑图。如下图1所示：由于后续出现的名词概念很多，先约法三章，在这里统一一下称呼：所有的终端机器成为客户端，不同客户端使用大写字母区分（A,B,C,…）；客户端上面运行的应用程序统一称为客户程序，不同的应用程序使用不数字区分（1,2,3,…）。作为服务器的物理机称为服务器，而服务器上运行的程序称为服务程序，后文中每一个拓扑组件都只有一个IP地址。为客户端提供公网IP服务的组件称为网关。
![wKioL1nGkdbRpj8jAAB4putmiMQ017.png-wh_50](https://s1.51cto.com/wyfs02/M00/A5/FA/wKioL1nGkdbRpj8jAAB4putmiMQ017.png-wh_500x0-wm_3-wmp_4-s_1853812742.png)
图1 中心化服务器的网络拓扑图
从网关映射到客户端中的网络结构，这里需要引入一个NAT的概念。什么NAT呢？中文名叫网络地址转换，习惯称为网络地址映射。为什么需要网络地址映射呢？：需要说到IPV4网络地址已经用完，全部使用IPV6又会造成很多只支持IPV4的终端设备无法正常使用，所以网络地址映射应运而生，忍辱负重。才会有我们现在所谓的网络穿透的出现。到底怎么映射的？如图2网络地址映射所示。客户程序使用192.168.0.234:7890发送数据，通过网关的网络地址映射在公网被转换为112.93.116.102:6834，被互联网上的大家所认知。此时在公网上使用客户程序的ip与端口被112.93.116.102:6834代替。在这里大家应该明白了NAT是何许物种了。
![wKiom1nGkg_Q03LBAABXmGw3UOQ516.png-wh_50](https://s1.51cto.com/wyfs02/M02/07/49/wKiom1nGkg_Q03LBAABXmGw3UOQ516.png-wh_500x0-wm_3-wmp_4-s_890112037.png)
图2 网络地址映射
为了保持新手福音，业界良心的态度。什么是穿透？因为NAT是客户程序发起的，网络为了保持通讯新建的一个临时牌照，随时可能被收回，而且重新发起后的牌照不一样。从而外界及时知道了这个临时牌照也没有用。所以需要通过穿透在网关上面打个洞，来为外界进行服务。那NAT与穿透有什么关系呢？正因为有了NAT才需要穿透，如果是IPV6每个客户端一个IP地址，那就不需要直接可以找到客户端了。
网络地址映射
由于网关的安全性要求不一致，就出现四种不同的NAT方式。分别进行阐述：
第一种完全锥形NAT，英文名叫Full Cone NAT。如图3完全锥形NAT所示，客户程序(192.168.0.234:7890)与服务器A(13.44.178.98:9800)通信，通过网关的地址转换产生的临时牌照的公网地址（112.93.116.102:6834），服务器B（157.78.13.156:23456）发送数据到公网地址（112.93.116.102:6834），如果客户程序(192.168.0.234:7890)能够收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为完全锥形NAT；
![wKiom1nGkhGRaHQkAABqja7Jt88832.png-wh_50](https://s4.51cto.com/wyfs02/M02/07/49/wKiom1nGkhGRaHQkAABqja7Jt88832.png-wh_500x0-wm_3-wmp_4-s_3071185391.png)
[](https://s4.51cto.com/wyfs02/M01/07/49/wKiom1nGkhCjX6CuAABYmhK5jE4855.png-wh_500x0-wm_3-wmp_4-s_2160276653.png)
图3 完全锥形NAT
第二种限制锥形NAT，英文名叫RestrictedCone NAT。在图3 完全锥形NAT中，如果客户程序(192.168.0.234:7890)不能收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为限制型锥形NAT。
第三种端口限制锥形NAT，英文名叫Port RestrictedCone NAT。客户程序(192.168.0.234:7890)发送数据给服务程序（13.44.178.98:9800）,网关通过网络地址转换产生的地址（112.93.116.102:6834）,同样的服务器内的另一个服务程序（13.44.178.178:9801）发送数据给网关（112.93.116.102:6834）地址，如果客户程序(192.168.0.234:7890)能够收到，则为限制锥形NAT，如果客户程序(192.168.0.234:7890)不能收到，则为端口限制锥形NAT。
对于所有的锥型NAT，客户程序（192.168.0.234:7890）对外发送的数据时，网关地址转换的地址都是一样的为（112.93.116.102:6834）,那为什么在图4 限制型锥形NAT中，客户程序不能收到服务程序B（13.44.178.98:9801）的数据呢？因为在网关中没有发生过客户程序（192.168.0.234:7890）给服务程序B（13.44.178.98:9801），故服务程序（13.44.178.98:9801）直接发送给网关（112.93.116.102:6834），则被网关所丢弃。
![wKiom1nGkhCjX6CuAABYmhK5jE4855.png-wh_50](https://s4.51cto.com/wyfs02/M01/07/49/wKiom1nGkhCjX6CuAABYmhK5jE4855.png-wh_500x0-wm_3-wmp_4-s_2160276653.png)
图4 限制型锥形NAT
第四种对称NAT，英文，名叫Symmetric NAT。如图5对称NAT所示，客户程序（192.168.0.234:7890）发送数据给两个不同服务器（13.44.178.98:9800）和（157.78.13.156:23456）时，网关会进行不同的网络地址映射产生（112.93.116.102:6834）和（112.93.116.102:6835）。这是对于整个NAT网络发送数据出去的过程，而接收数据与端口限制锥形NAT一致。
![wKiom1nGkhCzHbmVAABstzph6sM258.png-wh_50](https://s4.51cto.com/wyfs02/M01/07/49/wKiom1nGkhCzHbmVAABstzph6sM258.png-wh_500x0-wm_3-wmp_4-s_3393758864.png)
图5 对称NAT
本节介绍三种锥形NAT和对称NAT的概念，相信到此你还是不知道NAT类型与怎么穿透网关友什么关系。
穿透剖析
怎么穿透网关来实现去中心化，如图6穿透网络NAT拓扑图所示
![wKiom1nGkhDyDwdxAAB4Jpb2pAA676.png-wh_50](https://s1.51cto.com/wyfs02/M00/07/49/wKiom1nGkhDyDwdxAAB4Jpb2pAA676.png-wh_500x0-wm_3-wmp_4-s_482127532.png)
在理想的情况下，在NAT 1中客户程序（192.168.0.234:7890）知道NAT 2中客户程序（192.168.2.168:2786）的网络映射地址（157.123.80.165:6954），并给网络映射地址（157.123.80.165:6954）发送数据，并且客户程序（192.168.2.168:2786）能够收到数据；而NAT 2中客户程序（192.168.2.168:2786）也知道NAT 1中客户程序的网络映射地址，并给其网络映射地址（112.93.116.102:6834）发送数据，并且也能收到数据。此时对于服务器而言，就已经没有起到数据中转的作用，此时客户程序（192.168.0.234:7890）与客户程序（192.168.2.168:2786）能够互相收发数据，服务程序（13.44.178.98:9800）已经没有作用，对于客户端程序来说，已经实现了去中心化。
这只是在理论情况，现在具体实现步骤以及结合四种NAT类型来分析一下。
第一种：NAT 1为完全锥形NAT，NAT 2为任何一种NAT模式，如图7 完全锥形NAT的穿透，绿色字体的顺序。
- 
客户程序（192.168.0.234:7890）先发送一个连接请求给服务程序，通知服务程序，需要连接客户程序（192.168.2.168:2786）。
- 
服务程序收到连接请求后，发送给notify消息给客户程序（192.168.2.168:2786）,通知客户程序（192.168.2.168:2786），发送p2p连接请求给网关（112.93.116.102:6834）。
- 
客户程序（192.168.2.168:2786）发送p2p连接请求给网关（112.93.116.102:6834），由于NAT1为完全锥形NAT，所以客户程序（192.168.0.234:7890）能够收到客户程序（192.168.2.168:2786）的请求。
- 
客户程序（192.168.0.234:7890）收到p2p连接请求后，从请求数据中解析出请求发送者客户程序（192.168.2.168:2786）的IP地址与端口，并立即返回确认消息。此时双方进入P2P的穿透模式。
然而在这里有一点需要注意：NAT2为对称NAT的时候，在3步骤的时候，网关会新生成另一个端口，IP地址不变，用来与NAT1中的网络进行通信；在4步骤的时候，客户程序（192.168.0.234:7890）返回数据的地址，就是新生成的端口。
![wKioL1nGkdejVvCGAACSBtVxl_E171.png-wh_50](https://s4.51cto.com/wyfs02/M01/A5/FA/wKioL1nGkdejVvCGAACSBtVxl_E171.png-wh_500x0-wm_3-wmp_4-s_1164084917.png)
图7 完全锥形NAT的穿透
第二种：NAT 1为限制锥形NAT或者端口限制锥形NAT（两个锥形NAT模式是一样的，就不分开解释了），NAT 2为锥形NAT。如图8 限制锥形NAT的穿透所示
- 
客户程序（192.168.0.234:7890）发送连接请求给服务程序，通知服务程序，需要连接客户程序（192.168.2.168:2786）。
- 
服务程序收到连接请求后，发送给notify消息给客户程序（192.168.2.168:2786）,通知客户程序（192.168.2.168:2786），发送p2p连接请求给网关（112.93.116.102:6834）。
- 
客户程序（192.168.2.168:2786）发送p2p连接请求给网关（112.93.116.102:6834），由于NAT1为限制锥形NAT，所以客户程序（192.168.0.234:7890）收不到发送的p2p连接请求，此步骤最终的是在NAT2的网关（157.123.80.165:6954）新生成一条NAT目的地址的记录。与后续6步骤作为配合。
- 
客户程序（192.168.2.168:2786）提醒服务程序通知客户程序（192.168.0.234:7890），
- 
服务程序马上通知客户程序（192.168.0.234:7890）发送请求给NAT2的网关（157.123.80.165:6954）。
- 
客户程序（192.168.0.234:7890）发送p2p连接请求给网关（157.123.80.165:6954），由于刚刚3步骤发出了请求，此时网关会认为是3步骤返回的响应，所以能够p2p连接请求发送给客户程序（192.168.2.168:2786）
- 
客户程序（192.168.2.168:2786）收到p2p连接请求后，立即返回确认消息给p2p连接请求包解析出来的IP地址与端口，此确认消息能够顺利到底客户程序（192.168.0.234:7890），到此网关已经穿透，P2P已经建立。
![wKioL1nGkdiAKZ-cAAChO9RNALs726.png-wh_50](https://s4.51cto.com/wyfs02/M02/A5/FA/wKioL1nGkdiAKZ-cAAChO9RNALs726.png-wh_500x0-wm_3-wmp_4-s_3439009477.png)
图8 限制锥形NAT的穿透
第三种：NAT1为限制锥形NAT，NAT2为对称NAT。如图8限制锥形NAT的穿透所示。
在步骤3和步骤6与NAT2为限制锥形NAT有些差异，其余步骤流程一致。
步骤3：客户程序（192.168.2.168:2786）发送p2p连接请求给网关（112.93.116.102:6834），由于NAT2为对称网络，此时会重新生成一个端口用于对网关（112.93.116.102:6834）通信。新生成的端口没有办法能够准确的知道。只能进行猜测。
步骤6：发送数据给网关（157.123.80.165:猜测端口）。
在这里提供一种思路来提高测猜的准确度，把服务程序使用两个端口（之前9800，新加一个9801），由于网关NAT分配端口是顺序的，在步骤4发送请求给服务程序（9801端口），因为步骤3与步骤4相隔时间短，步骤3在网关（157.123.80.165）所生成的新端口比步骤4的端口小。从而来提高猜测的准确度。
相信已经对穿透的具体步骤有明确的概念，怎么准确的判断当前NAT的类型？
NAT分类
其实在网络地址映射概念已经有介绍分类，在这里使用更加计算机化语言描述。
第一种，检测当前客户程序的网关是否为完全锥形NAT，如图9检测完全锥形NAT所示
![wKioL1nGkdeyikmBAABxHWZavbg981.png-wh_50](https://s4.51cto.com/wyfs02/M00/A5/FA/wKioL1nGkdeyikmBAABxHWZavbg981.png-wh_500x0-wm_3-wmp_4-s_461412689.png)
图9 检测完全锥形NAT
首先检测Udp的可用性，客户程序（192.168.0.234:7890）使用一个300ms定时器发送Udp请求数据包给服务器A。等待服务器A返回确认数据。如果多次发送请求并未得到服务器的确认数据，则认为Udp不能信息，则推出整个检测过程。如果收到确认数据，同样使用定时器再发送另一种请求数据要求服务器B发送数据给网关（112.93.116.102:6834），如果收到服务器B的数据，则认为是完全锥形网络。如果没有收到则进行限制锥形NAT。
第二种，检测限制锥形网络，如图10所示。
![wKioL1nGkdeQXaSUAABtIOVt-Ik423.png-wh_50](https://s4.51cto.com/wyfs02/M02/A5/FA/wKioL1nGkdeQXaSUAABtIOVt-Ik423.png-wh_500x0-wm_3-wmp_4-s_2165647245.png)
图10 检测限制锥形NAT
客户程序（192.168.0.234:7890）定时发送数据包给服务程序A，并要求服务程序从另一个端口发送数据包给网关（112.93.116.102:6834）。若客户程序（192.168.0.234:7890）收到回应，则该NAT为限制锥形NAT。若多次操作没有回应，则进行对称NAT检测。
第三种，检测当前客户程序的网关是否为对称NAT，如图9所示
客户程序（192.168.0.234:7890）给服务器A（13.44.178.98:9800）与服务器B（157.78.13.156:23456）发送数据包，对比两个服务器收到客户程序的（）IP地址与端口是否一致。如果不一致则是对称网络。如果一致则该网络为端口限制锥形NAT。

以下为实现了完全锥形网络的穿透代码
udp.h
```
```cpp
/*
```
```cpp
```
```cpp
* Author: WangBoJing
```
```cpp
```
```cpp
* email: 1989wangbojing@gmail.com
```
```cpp
```
```cpp
* github: https://github.com/wangbojing
```
```cpp
```
```cpp
*/
```
```cpp
#ifndef __UDP_H__
```
```cpp
#define __UDP_H__
```
```cpp
#include <stdio.h>
```
```cpp
#include <stdlib.h>
```
```cpp
#include <string.h>
```
```cpp
#include <sys/socket.h>
```
```cpp
#include <netinet/in.h>
```
```cpp
#include <unistd.h>
```
```cpp
#include <time.h>
```
```cpp
typedef
```
```cpp
unsigned
```
```cpp
int
```
```cpp
U32;
```
```cpp
typedef
```
```cpp
unsigned
```
```cpp
short
```
```cpp
U16;
```
```cpp
typedef
```
```cpp
unsigned
```
```cpp
char
```
```cpp
U8;
```
```cpp
typedef
```
```cpp
volatile
```
```cpp
long
```
```cpp
UATOMIC;
```
```cpp
typedef
```
```cpp
void
```
```cpp
* (*KING_CALLBACK)(
```
```cpp
void
```
```cpp
*arg);
```
```cpp
typedef
```
```cpp
enum
```
```cpp
{
```
```cpp
```
```cpp
KING_RESULT_FAILED = -1,
```
```cpp
```
```cpp
KING_RESULT_SUCCESS = 0,
```
```cpp
} KING_RESULT;
```
```cpp
typedef
```
```cpp
enum
```
```cpp
{
```
```cpp
```
```cpp
KING_STATUS_NULL,
```
```cpp
```
```cpp
KING_STATUS_LOGIN,
```
```cpp
```
```cpp
KING_STATUS_HEARTBEAT,
```
```cpp
```
```cpp
KING_STATUS_CONNECT,
```
```cpp
```
```cpp
KING_STATUS_MESSAGE,
```
```cpp
```
```cpp
KING_STATUS_NOTIFY,
```
```cpp
```
```cpp
KING_STATUS_P2P_CONNECT,
```
```cpp
```
```cpp
KING_STATUS_P2P_MESSAGE,
```
```cpp
} KING_STATUS_SET;
```
```cpp
#define KING_CLIENT_MAX    1024
```
```cpp
#define KING_CLIENT_ADDR_LENGTH  6
```
```cpp
#define KING_BUFFER_LENGTH  512
```
```cpp
#define KING_NUMBER_ID_LENGTH   4
```
```cpp
typedef
```
```cpp
struct
```
```cpp
_CLIENT_TABLE {
```
```cpp
```
```cpp
U8 addr[KING_CLIENT_ADDR_LENGTH];
```
```cpp
```
```cpp
U32 client_id;
```
```cpp
```
```cpp
long
```
```cpp
stamp;
```
```cpp
} client_table;
```
```cpp
/**************************** status define ****************************/
```
```cpp
#define KING_PROTO_LOGIN_REQ    0x01
```
```cpp
#define KING_PROTO_LOGIN_ACK    0x81
```
```cpp
#define KING_PROTO_HEARTBEAT_REQ   0x02
```
```cpp
#define KING_PROTO_HEARTBEAT_ACK   0x82
```
```cpp
#define KING_PROTO_CONNECT_REQ    0x11
```
```cpp
#define KING_PROTO_CONNECT_ACK    0x91
```
```cpp
#define NTY_PROTO_NOTIFY_REQ    0x12
```
```cpp
#define NTY_PROTO_NOTIFY_ACK    0x92
```
```cpp
#define NTY_PROTO_P2P_CONNECT_REQ   0x13
```
```cpp
#define NTY_PROTO_P2P_CONNECT_ACK   0x93
```
```cpp
#define NTY_RPORO_MESSAGE_REQ    0x21
```
```cpp
#define NTY_RPORO_MESSAGE_ACK    0xA1
```
```cpp
/**************************** context define ****************************/
```
```cpp
#define KING_PROTO_BUFFER_VERSION_IDX  0
```
```cpp
#define KING_PROTO_BUFFER_STATUS_IDX  1
```
```cpp
#define KING_PROTO_BUFFER_LENGTH_IDX  (KING_PROTO_BUFFER_STATUS_IDX+1)
```
```cpp
#define KING_PROTO_BUFFER_SELFID_IDX  (KING_PROTO_BUFFER_LENGTH_IDX+2)
```
```cpp
//login
```
```cpp
#define KING_PROTO_LOGIN_SELFID_IDX   KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
//heartbeat
```
```cpp
#define KING_PROTO_HEARTBEAT_SELFID_IDX  KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
//connect
```
```cpp
#define KING_PROTO_CONNECT_SELFID_IDX  KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
#define KING_PROTO_CONNECT_OTHERID_IDX  (KING_PROTO_BUFFER_SELFID_IDX+KING_NUMBER_ID_LENGTH)
```
```cpp
//notify
```
```cpp
#define KING_PROTO_NOTIFY_SELFID_IDX   KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
#define KING_PROTO_NOTIFY_ADDR_IDX   (KING_PROTO_BUFFER_SELFID_IDX+KING_NUMBER_ID_LENGTH)
```
```cpp
//p2p connect
```
```cpp
#define KING_PROTO_P2P_CONNECT_SELFID_IDX KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
//p2p connect ack
```
```cpp
#define KING_PROTO_P2P_CONNECT_ACK_SELFID_IDX KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
//message
```
```cpp
#define KING_RPORO_MESSAGE_SELFID_IDX  KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
#define KING_PROTO_MESSAGE_OTHERID_IDX  (KING_RPORO_MESSAGE_SELFID_IDX+KING_NUMBER_ID_LENGTH)
```
```cpp
#define KING_RPORO_MESSAGE_CONTENT_IDX  (KING_PROTO_MESSAGE_OTHERID_IDX+KING_NUMBER_ID_LENGTH)
```
```cpp
//message ack
```
```cpp
#define KING_RPORO_MESSAGE_ACK_SELFID_IDX KING_PROTO_BUFFER_SELFID_IDX
```
```cpp
static
```
```cpp
unsigned
```
```cpp
long
```
```cpp
cmpxchg(UATOMIC *addr, unsigned
```
```cpp
long
```
```cpp
_old, unsigned
```
```cpp
long
```
```cpp
_new) {
```
```cpp
```
```cpp
U8 res;
```
```cpp
```
```cpp
__asm__
```
```cpp
volatile
```
```cpp
(
```
```cpp
```
```cpp
"lock; cmpxchg %3, %1;sete %0;"
```
```cpp
```
```cpp
:
```
```cpp
"=a"
```
```cpp
(res)
```
```cpp
```
```cpp
:
```
```cpp
"m"
```
```cpp
(*addr),
```
```cpp
"a"
```
```cpp
(_old),
```
```cpp
"r"
```
```cpp
(_new)
```
```cpp
```
```cpp
:
```
```cpp
"cc"
```
```cpp
,
```
```cpp
"memory"
```
```cpp
);
```
```cpp
```
```cpp
return
```
```cpp
res;
```
```cpp
}
```
```cpp
static
```
```cpp
long
```
```cpp
time_genrator(
```
```cpp
void
```
```cpp
) {
```
```cpp
```
```cpp
static
```
```cpp
long
```
```cpp
lTimeStamp = 0;
```
```cpp
```
```cpp
static
```
```cpp
long
```
```cpp
timeStampMutex = 0;
```
```cpp
```
```cpp
if
```
```cpp
(cmpxchg(&timeStampMutex, 0, 1)) {
```
```cpp
```
```cpp
lTimeStamp =
```
```cpp
time
```
```cpp
(NULL);
```
```cpp
```
```cpp
timeStampMutex = 0;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
lTimeStamp;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
addr_to_array(U8 *array,
```
```cpp
struct
```
```cpp
sockaddr_in *p_addr) {
```
```cpp
```
```cpp
int
```
```cpp
i = 0;
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 4;i ++) {
```
```cpp
```
```cpp
array[i] = *((unsigned
```
```cpp
char
```
```cpp
*)(&p_addr->sin_addr.s_addr) + i);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 2;i ++) {
```
```cpp
```
```cpp
array[4+i] = *((unsigned
```
```cpp
char
```
```cpp
*)(&p_addr->sin_port)+i);
```
```cpp
```
```cpp
}
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
array_to_addr(U8 *array,
```
```cpp
struct
```
```cpp
sockaddr_in *p_addr) {
```
```cpp
```
```cpp
int
```
```cpp
i = 0;
```
```cpp
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 4;i ++) {
```
```cpp
```
```cpp
*((unsigned
```
```cpp
char
```
```cpp
*)(&p_addr->sin_addr.s_addr) + i) = array[i];
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 2;i ++) {
```
```cpp
```
```cpp
*((unsigned
```
```cpp
char
```
```cpp
*)(&p_addr->sin_port)+i) = array[4+i];
```
```cpp
```
```cpp
}
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_login(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = KING_PROTO_LOGIN_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_LOGIN_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_LOGIN_SELFID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_heartbeat(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = KING_PROTO_HEARTBEAT_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_HEARTBEAT_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_HEARTBEAT_SELFID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_connect(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
int
```
```cpp
other_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = KING_PROTO_CONNECT_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_CONNECT_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_CONNECT_OTHERID_IDX) = other_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_CONNECT_OTHERID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_p2pconnect(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = NTY_PROTO_P2P_CONNECT_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_P2P_CONNECT_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_P2P_CONNECT_SELFID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_p2pconnectack(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = NTY_PROTO_P2P_CONNECT_ACK;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_P2P_CONNECT_ACK_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_P2P_CONNECT_ACK_SELFID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_client_send_message(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
int
```
```cpp
other_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr, U8 *msg,
```
```cpp
int
```
```cpp
length) {
```
```cpp
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = NTY_RPORO_MESSAGE_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_RPORO_MESSAGE_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_MESSAGE_OTHERID_IDX) = other_id;
```
```cpp
```
```cpp
```
```cpp
memcpy
```
```cpp
(buffer+KING_RPORO_MESSAGE_CONTENT_IDX, msg, length);
```
```cpp
```
```cpp
int
```
```cpp
n = KING_RPORO_MESSAGE_CONTENT_IDX + length;
```
```cpp
```
```cpp
*(U16*)(buffer+KING_PROTO_BUFFER_LENGTH_IDX) = (U16) n;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_messageack(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
self_id,
```
```cpp
struct
```
```cpp
sockaddr_in *paddr) {
```
```cpp
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = NTY_RPORO_MESSAGE_ACK;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_RPORO_MESSAGE_ACK_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
int
```
```cpp
n = KING_RPORO_MESSAGE_ACK_SELFID_IDX + KING_NUMBER_ID_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)paddr,
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
client_table table[KING_CLIENT_MAX] = {0};
```
```cpp
int
```
```cpp
client_count = 0;
```
```cpp
static
```
```cpp
int
```
```cpp
get_index_by_clientid(
```
```cpp
int
```
```cpp
client_id) {
```
```cpp
```
```cpp
int
```
```cpp
i = 0;
```
```cpp
```
```cpp
int
```
```cpp
now_count = client_count;
```
```cpp
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < now_count;i ++) {
```
```cpp
```
```cpp
if
```
```cpp
(table[i].client_id == client_id)
```
```cpp
return
```
```cpp
i;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_message(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
client_id, U8 *buffer,
```
```cpp
int
```
```cpp
length) {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
index = get_index_by_clientid(client_id);
```
```cpp
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in c_addr;
```
```cpp
```
```cpp
c_addr.sin_family = AF_INET;
```
```cpp
```
```cpp
array_to_addr(table[index].addr, &c_addr);
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
n = sendto(sockfd, buffer, length, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)&c_addr,
```
```cpp
sizeof
```
```cpp
(c_addr));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
static
```
```cpp
int
```
```cpp
king_send_notify(
```
```cpp
int
```
```cpp
sockfd,
```
```cpp
int
```
```cpp
client_id,
```
```cpp
int
```
```cpp
self_id) {
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
int
```
```cpp
index = get_index_by_clientid(self_id);
```
```cpp
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] = NTY_PROTO_NOTIFY_REQ;
```
```cpp
```
```cpp
*(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_NOTIFY_SELFID_IDX) = self_id;
```
```cpp
```
```cpp
memcpy
```
```cpp
(buffer+KING_PROTO_NOTIFY_ADDR_IDX, table[index].addr, KING_CLIENT_ADDR_LENGTH);
```
```cpp
```
```cpp
```
```cpp
index = get_index_by_clientid(client_id);
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in c_addr;
```
```cpp
```
```cpp
c_addr.sin_family = AF_INET;
```
```cpp
```
```cpp
array_to_addr(table[index].addr, &c_addr);
```
```cpp
```
```cpp
int
```
```cpp
n = KING_PROTO_NOTIFY_ADDR_IDX + KING_CLIENT_ADDR_LENGTH;
```
```cpp
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)&c_addr,
```
```cpp
sizeof
```
```cpp
(c_addr));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
n;
```
```cpp
}
```
```cpp
#endif
```
```
udp_client.c
```
```cpp
/*
```
```cpp
```
```cpp
* Author: WangBoJing
```
```cpp
```
```cpp
* email: 1989wangbojing@gmail.com
```
```cpp
```
```cpp
* github: https://github.com/wangbojing
```
```cpp
```
```cpp
*/
```
```cpp
#include "udp.h"
```
```cpp
#include <pthread.h>
```
```cpp
static
```
```cpp
int
```
```cpp
status_machine = KING_STATUS_LOGIN;
```
```cpp
static
```
```cpp
int
```
```cpp
client_selfid = 0x0;
```
```cpp
struct
```
```cpp
sockaddr_in server_addr;
```
```cpp
client_table p2p_clients[KING_CLIENT_MAX] = {0};
```
```cpp
static
```
```cpp
int
```
```cpp
p2p_count = 0;
```
```cpp
static
```
```cpp
int
```
```cpp
king_client_buffer_parser(
```
```cpp
int
```
```cpp
sockfd, U8 *buffer, U32 length,
```
```cpp
struct
```
```cpp
sockaddr_in *addr) {
```
```cpp
```
```cpp
```
```cpp
U8 status = buffer[KING_PROTO_BUFFER_STATUS_IDX];
```
```cpp
```
```cpp
```
```cpp
switch
```
```cpp
(status) {
```
```cpp
```
```cpp
case
```
```cpp
NTY_PROTO_NOTIFY_REQ: {
```
```cpp
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in other_addr;
```
```cpp
```
```cpp
other_addr.sin_family = AF_INET;
```
```cpp
```
```cpp
```
```cpp
array_to_addr(buffer+KING_PROTO_NOTIFY_ADDR_IDX, &other_addr);
```
```cpp
```
```cpp
king_send_p2pconnect(sockfd, client_selfid, &other_addr);
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
NTY_PROTO_P2P_CONNECT_REQ: {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
now_count = p2p_count++;
```
```cpp
```
```cpp
p2p_clients[now_count].stamp = time_genrator();
```
```cpp
```
```cpp
```
```cpp
p2p_clients[now_count].client_id = *(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_P2P_CONNECT_SELFID_IDX);
```
```cpp
```
```cpp
addr_to_array(p2p_clients[now_count].addr, addr);
```
```cpp
```
```cpp
```
```cpp
king_send_p2pconnectack(sockfd, client_selfid, addr);
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Enter P2P Model\n"
```
```cpp
);
```
```cpp
```
```cpp
status_machine = KING_STATUS_P2P_MESSAGE;
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
NTY_PROTO_P2P_CONNECT_ACK: {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
now_count = p2p_count++;
```
```cpp
```
```cpp
```
```cpp
p2p_clients[now_count].stamp = time_genrator();
```
```cpp
```
```cpp
p2p_clients[now_count].client_id = *(
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_P2P_CONNECT_SELFID_IDX);
```
```cpp
```
```cpp
addr_to_array(p2p_clients[now_count].addr, addr);
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Enter P2P Model\n"
```
```cpp
);
```
```cpp
```
```cpp
status_machine = KING_STATUS_P2P_MESSAGE;
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
NTY_RPORO_MESSAGE_REQ: {
```
```cpp
```
```cpp
```
```cpp
U8 *msg = buffer+KING_RPORO_MESSAGE_CONTENT_IDX;
```
```cpp
```
```cpp
U32 other_id = *(U32*)(buffer+KING_RPORO_MESSAGE_SELFID_IDX);
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" from client:%d --> %s\n"
```
```cpp
, other_id, msg);
```
```cpp
```
```cpp
king_send_messageack(sockfd, client_selfid, addr);
```
```cpp
```
```cpp
//status_machine = KING_STATUS_P2P_MESSAGE;
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_LOGIN_ACK: {
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" Connect Server Success\nPlease Enter Message : "
```
```cpp
);
```
```cpp
```
```cpp
status_machine = KING_STATUS_MESSAGE;
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_HEARTBEAT_ACK:
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_CONNECT_ACK:
```
```cpp
```
```cpp
case
```
```cpp
NTY_PROTO_NOTIFY_ACK:
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
case
```
```cpp
NTY_RPORO_MESSAGE_ACK:
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
void
```
```cpp
* king_recv_callback(
```
```cpp
void
```
```cpp
*arg) {
```
```cpp
```
```cpp
int
```
```cpp
sockfd = *(
```
```cpp
int
```
```cpp
*)arg;
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in addr;
```
```cpp
```
```cpp
int
```
```cpp
length =
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in);
```
```cpp
```
```cpp
U8 buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
//printf("king_recv_callback --> enter\n");
```
```cpp
```
```cpp
```
```cpp
while
```
```cpp
(1) {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
n = recvfrom(sockfd, buffer, KING_BUFFER_LENGTH, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)&addr, &length);
```
```cpp
```
```cpp
if
```
```cpp
(n > 0) {
```
```cpp
```
```cpp
```
```cpp
buffer[n] = 0;
```
```cpp
```
```cpp
king_client_buffer_parser(sockfd, buffer, n, &addr);
```
```cpp
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
if
```
```cpp
(n == 0) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"server closed\n"
```
```cpp
);
```
```cpp
```
```cpp
close(sockfd);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
if
```
```cpp
(n == -1) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"recvfrom"
```
```cpp
);
```
```cpp
```
```cpp
close(sockfd);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
}
```
```cpp
void
```
```cpp
*king_send_callback(
```
```cpp
void
```
```cpp
*arg) {
```
```cpp
```
```cpp
int
```
```cpp
sockfd = *(
```
```cpp
int
```
```cpp
*)arg;
```
```cpp
```
```cpp
char
```
```cpp
buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
//printf("king_send_callback --> enter\n");
```
```cpp
```
```cpp
```
```cpp
while
```
```cpp
(1) {
```
```cpp
```
```cpp
bzero(buffer, KING_BUFFER_LENGTH);
```
```cpp
```
```cpp
```
```cpp
scanf
```
```cpp
(
```
```cpp
"%s"
```
```cpp
, buffer);
```
```cpp
```
```cpp
//getchar();
```
```cpp
```
```cpp
if
```
```cpp
(status_machine == KING_STATUS_MESSAGE) {
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" --> please enter bt : "
```
```cpp
);
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
other_id = buffer[1]-0x30;
```
```cpp
```
```cpp
if
```
```cpp
(buffer[0] ==
```
```cpp
'C'
```
```cpp
) {
```
```cpp
```
```cpp
```
```cpp
king_send_connect(sockfd, client_selfid, other_id, &server_addr);
```
```cpp
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
{
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
length =
```
```cpp
strlen
```
```cpp
(buffer);
```
```cpp
```
```cpp
king_client_send_message(sockfd, client_selfid, other_id, &server_addr, buffer, length);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
if
```
```cpp
(status_machine == KING_STATUS_P2P_MESSAGE) {
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" --> please enter message to send : "
```
```cpp
);
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
now_count = p2p_count;
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in c_addr;
```
```cpp
```
```cpp
c_addr.sin_family = AF_INET;
```
```cpp
```
```cpp
array_to_addr(p2p_clients[now_count-1].addr, &c_addr);
```
```cpp
```
```cpp
int
```
```cpp
length =
```
```cpp
strlen
```
```cpp
(buffer);
```
```cpp
```
```cpp
king_client_send_message(sockfd, client_selfid, 0, &c_addr, buffer, length);
```
```cpp
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
}
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[]) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" This is a UDP Client\n"
```
```cpp
);
```
```cpp
```
```cpp
if
```
```cpp
(argc != 4) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"Usage: %s ip port\n"
```
```cpp
, argv[0]);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
```
```cpp
```
```cpp
if
```
```cpp
(sockfd < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"socket"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
pthread_t thread_id[2] = {0};
```
```cpp
```
```cpp
KING_CALLBACK cb[2] = {king_send_callback, king_recv_callback};
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
i = 0;
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 2;i ++) {
```
```cpp
```
```cpp
int
```
```cpp
ret = pthread_create(&thread_id[i], NULL, cb[i], &sockfd);
```
```cpp
```
```cpp
if
```
```cpp
(ret) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"pthread_create"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
sleep(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
server_addr.sin_family = AF_INET;
```
```cpp
```
```cpp
server_addr.sin_port = htons(
```
```cpp
atoi
```
```cpp
(argv[2]));
```
```cpp
```
```cpp
server_addr.sin_addr.s_addr = inet_addr(argv[1]);
```
```cpp
```
```cpp
```
```cpp
client_selfid =
```
```cpp
atoi
```
```cpp
(argv[3]);
```
```cpp
```
```cpp
king_send_login(sockfd, client_selfid, &server_addr);
```
```cpp
```
```cpp
for
```
```cpp
(i = 0;i < 2;i ++) {
```
```cpp
```
```cpp
pthread_join(thread_id[i], NULL);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
udp_server.c
```
```cpp
/*
```
```cpp
```
```cpp
* Author: WangBoJing
```
```cpp
```
```cpp
* email: 1989wangbojing@gmail.com
```
```cpp
```
```cpp
* github: https://github.com/wangbojing
```
```cpp
```
```cpp
*/
```
```cpp
#include "udp.h"
```
```cpp
int
```
```cpp
king_buffer_parser(
```
```cpp
int
```
```cpp
sockfd, U8 *buffer, U32 length,
```
```cpp
struct
```
```cpp
sockaddr_in *addr) {
```
```cpp
```
```cpp
```
```cpp
U8 status = buffer[KING_PROTO_BUFFER_STATUS_IDX];
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"king_buffer_parser --> %x\n"
```
```cpp
, status);
```
```cpp
```
```cpp
```
```cpp
switch
```
```cpp
(status) {
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_LOGIN_REQ: {
```
```cpp
#if 1
```
```cpp
```
```cpp
int
```
```cpp
old = client_count;
```
```cpp
```
```cpp
int
```
```cpp
now = old+1;
```
```cpp
```
```cpp
if
```
```cpp
(0 == cmpxchg((UATOMIC*)&client_count, old, now)) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"client_count --> %d, old:%d, now:%d\n"
```
```cpp
, client_count, old, now);
```
```cpp
```
```cpp
return
```
```cpp
KING_RESULT_FAILED;
```
```cpp
```
```cpp
}
```
```cpp
#else
```
```cpp
```
```cpp
client_count = client_count+1;
```
```cpp
```
```cpp
int
```
```cpp
now = client_count;
```
```cpp
#endif
```
```cpp
```
```cpp
U8 array[KING_CLIENT_ADDR_LENGTH] = {0};
```
```cpp
```
```cpp
addr_to_array(array, addr);
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"login --> %d.%d.%d.%d:%d\n"
```
```cpp
, *(unsigned
```
```cpp
char
```
```cpp
*)(&addr->sin_addr.s_addr), *((unsigned
```
```cpp
char
```
```cpp
*)(&addr->sin_addr.s_addr)+1),
```
```cpp
```
```cpp
*((unsigned
```
```cpp
char
```
```cpp
*)(&addr->sin_addr.s_addr)+2), *((unsigned
```
```cpp
char
```
```cpp
*)(&addr->sin_addr.s_addr)+3),
```
```cpp
```
```cpp
addr->sin_port);
```
```cpp
```
```cpp
```
```cpp
table[now].client_id =  *(U32*)(buffer+KING_PROTO_LOGIN_SELFID_IDX);
```
```cpp
```
```cpp
memcpy
```
```cpp
(table[now].addr, array, KING_CLIENT_ADDR_LENGTH);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_HEARTBEAT_REQ: {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
client_id = *(unsigned
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_HEARTBEAT_SELFID_IDX);
```
```cpp
```
```cpp
int
```
```cpp
index = get_index_by_clientid(client_id);
```
```cpp
```
```cpp
table[index].stamp = time_genrator();
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
KING_PROTO_CONNECT_REQ: {
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
client_id = *(unsigned
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_CONNECT_SELFID_IDX);
```
```cpp
```
```cpp
int
```
```cpp
other_id = *(unsigned
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_CONNECT_OTHERID_IDX);
```
```cpp
```
```cpp
king_send_notify(sockfd, other_id, client_id);
```
```cpp
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
case
```
```cpp
NTY_RPORO_MESSAGE_REQ: {
```
```cpp
```
```cpp
```
```cpp
U8 *msg = buffer+KING_RPORO_MESSAGE_CONTENT_IDX;
```
```cpp
```
```cpp
int
```
```cpp
client_id = *(unsigned
```
```cpp
int
```
```cpp
*)(buffer+KING_RPORO_MESSAGE_SELFID_IDX);
```
```cpp
```
```cpp
int
```
```cpp
other_id = *(unsigned
```
```cpp
int
```
```cpp
*)(buffer+KING_PROTO_MESSAGE_OTHERID_IDX);
```
```cpp
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" from client:%d --> %s\n"
```
```cpp
, client_id, msg);
```
```cpp
#if 0
```
```cpp
```
```cpp
king_send_message(sockfd, other_id, buffer, length);
```
```cpp
#endif
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
return
```
```cpp
KING_RESULT_SUCCESS;
```
```cpp
```
```cpp
}
```
```cpp
int
```
```cpp
main(
```
```cpp
int
```
```cpp
argc,
```
```cpp
char
```
```cpp
*argv[]) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
" This is a UDP Server\n"
```
```cpp
);
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
```
```cpp
```
```cpp
if
```
```cpp
(sockfd < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"socket"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(0);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in addr;
```
```cpp
```
```cpp
addr.sin_family = AF_INET;
```
```cpp
```
```cpp
addr.sin_port = htons(
```
```cpp
atoi
```
```cpp
(argv[1]));
```
```cpp
```
```cpp
addr.sin_addr.s_addr = htonl(INADDR_ANY);
```
```cpp
```
```cpp
```
```cpp
if
```
```cpp
(bind(sockfd, (
```
```cpp
struct
```
```cpp
sockaddr*)&addr,
```
```cpp
sizeof
```
```cpp
(addr)) < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"bind"
```
```cpp
);
```
```cpp
```
```cpp
exit
```
```cpp
(1);
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
char
```
```cpp
buffer[KING_BUFFER_LENGTH] = {0};
```
```cpp
```
```cpp
struct
```
```cpp
sockaddr_in c_addr;
```
```cpp
```
```cpp
```
```cpp
int
```
```cpp
n;
```
```cpp
```
```cpp
int
```
```cpp
length =
```
```cpp
sizeof
```
```cpp
(
```
```cpp
struct
```
```cpp
sockaddr_in);
```
```cpp
```
```cpp
```
```cpp
while
```
```cpp
(1) {
```
```cpp
```
```cpp
```
```cpp
n = recvfrom(sockfd, buffer, KING_BUFFER_LENGTH, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)&c_addr, &length);
```
```cpp
```
```cpp
if
```
```cpp
(n > 0) {
```
```cpp
```
```cpp
```
```cpp
buffer[n] = 0x0;
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"%d.%d.%d.%d:%d say: %s\n"
```
```cpp
, *(unsigned
```
```cpp
char
```
```cpp
*)(&c_addr.sin_addr.s_addr), *((unsigned
```
```cpp
char
```
```cpp
*)(&c_addr.sin_addr.s_addr)+1),
```
```cpp
```
```cpp
*((unsigned
```
```cpp
char
```
```cpp
*)(&c_addr.sin_addr.s_addr)+2), *((unsigned
```
```cpp
char
```
```cpp
*)(&c_addr.sin_addr.s_addr)+3),
```
```cpp
```
```cpp
c_addr.sin_port, buffer);
```
```cpp
```
```cpp
int
```
```cpp
ret = king_buffer_parser(sockfd, buffer, n, &c_addr);
```
```cpp
```
```cpp
if
```
```cpp
(ret == KING_RESULT_FAILED)
```
```cpp
continue
```
```cpp
;
```
```cpp
```
```cpp
buffer[KING_PROTO_BUFFER_STATUS_IDX] += 0x80;
```
```cpp
```
```cpp
n = sendto(sockfd, buffer, n, 0, (
```
```cpp
struct
```
```cpp
sockaddr*)&c_addr,
```
```cpp
sizeof
```
```cpp
(c_addr));
```
```cpp
```
```cpp
if
```
```cpp
(n < 0) {
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"sendto"
```
```cpp
);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
if
```
```cpp
(n == 0) {
```
```cpp
```
```cpp
printf
```
```cpp
(
```
```cpp
"server closed\n"
```
```cpp
);
```
```cpp
```
```cpp
}
```
```cpp
else
```
```cpp
{
```
```cpp
```
```cpp
perror
```
```cpp
(
```
```cpp
"recv"
```
```cpp
);
```
```cpp
```
```cpp
break
```
```cpp
;
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
}
```
```cpp
```
```cpp
```
```cpp
return
```
```cpp
0;
```
```cpp
}
```
```
