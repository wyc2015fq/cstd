# 菜鸟升级记——工厂方法模式 - Jun5203 - CSDN博客
2019年01月18日 09:26:44[贾俊浩_Ellen](https://me.csdn.net/Ellen5203)阅读数：59
所属专栏：[C#](https://blog.csdn.net/column/details/29824.html)
### 概述
工厂方法模式是一种类创建型模式，此模式的核心精神是封装类中不变的部分，将易改动的部分设为独立类，通过依赖注入以达到解耦、复用和方便后期维护扩展的目的。
### 实践
**模式中的角色**
- 抽象工厂（Creator）
任何在模式中创建对象的工厂类必须实现这个接口。
- 具体工厂（ConcreteCreator）
- 抽象产品（Product）
- 具体产品（ConcreteProduct）
**工厂方法模式和简单工厂模式的区别**
- 简单工厂模式
- 优点
工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
- 缺点
若要增加新的功能，需更改工厂类中的方法，违背开放-封闭原则。
- 工厂方法模式
- 优点
在不修改具体工厂角色的情况下引进新的产品，既克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。
- 缺点
工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行，若要增加新的功能，需要修改客户端。
**模式应用**
- 对于某个产品，调用者清楚的知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品。
- 只是需要生产一种产品，而且不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程这对于使用者来说是透明的。
### 代码
**工厂方法**
```
class Operation（ 抽象产品）
    {
        /// <summary>
        /// 运算类
        /// </summary>
        private double _numberA = 0;
        private double _numberB = 0;
        public double NumberA
        {
            get { return _numberA; }
            set { _numberA = value; }
        }
        public double NumberB
        {
            get { return _numberB; }
            set { _numberB = value; }
        }
        /// <summary>
        /// 得到运算结果
        /// </summary>
        /// <returns></returns>
        public virtual double GetResult()
        {
            double result = 0;
            return result;
        }
    }
    /// <summary>
    /// 加法类（具体产品）
    /// </summary>
    class OperationAdd : Operation
    {
        public override double GetResult()
        {
            double result = 0;
            result = NumberA + NumberB;
            return result;
        }
    }
    /// <summary>
    /// 减法类（具体产品）
    /// </summary>
    class OperationSub : Operation
    {
        public override double GetResult()
        {
            double result = 0;
            result = NumberA - NumberB;
            return result;
        }
    }
    /// <summary>
    /// 乘法类（具体产品）
    /// </summary>
    class OperationMul : Operation
    {
        public override double GetResult()
        {
            double result = 0;
            result = NumberA * NumberB;
            return result;
        }
    }
    /// <summary>
    /// 除法类（具体产品）
    /// </summary>
    class OperationDiv : Operation
    {
        public override double GetResult()
        {
            double result = 0;
            if (NumberB == 0)
                throw new Exception("除数不能为0");
            result = NumberA / NumberB;
            return result;
        }
    }
    /// <summary>
    /// 工厂方法（抽象工厂）
    /// </summary>
    interface IFactory
    {
        Operation CreateOperation();
    }
    /// <summary>
    /// 负责专门生产“+”的工厂（具体工厂）
    /// </summary>
    class AddFactory : IFactory
    {
        public Operation CreateOperation()
        {
            return new OperationAdd();
        }
    }
    /// <summary>
    /// 专门负责生产“-”的工厂（具体工厂）
    /// </summary>
    class SubFactory : IFactory
    {
        public Operation CreateOperation()
        {
            return new OperationDiv();
        }
    }
    /// <summary>
    /// 专门负责生产“*”的工厂（具体工厂）
    /// </summary>
    class MulFactory : IFactory
    {
        public Operation CreateOperation()
        {
            return new OperationMul();
        }
    }
    /// <summary>
    /// 专门负责生产“/”的工厂（具体工厂）
    /// </summary>
    class DivFactory : IFactory
    {
        public Operation CreateOperation()
        {
            return new OperationDiv();
        }
    }
```
**客户端**
```
class Progran
    {
        static void Main(string[] args)
        {
            IFactory operFactory=new AddFactory();
            Operation oper = operFactory.CreateOperation();
            oper.NumberA = 1;
            oper.NumberB = 2;
            double result = oper.GetResult();
            Console.WriteLine(result);
            Console.Read();
        }
    }
```
