# 菜鸟升级记——装饰模式 - Jun5203 - CSDN博客
2019年02月13日 17:18:43[贾俊浩_Ellen](https://me.csdn.net/Ellen5203)阅读数：34
所属专栏：[C#](https://blog.csdn.net/column/details/29824.html)
装饰模式
动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190213171309150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsbGVuNTIwMw==,size_16,color_FFFFFF,t_70)
```
class Program
    {
        static void Main(string[] args)
        {
            ConcreteComponent c=new ConcreteComponent();
            ConcreteDecoratorA d1=new ConcreteDecoratorA();
            ConcreteDecoratorB d2=new ConcreteDecoratorB();
            d1.SetComponent(c);//用ConcreteDecoratorA的实例化对象d1来包装c，调用Decorator的方法，传参到component
            d2.SetComponent(d1);//用ConcreteDecoratorB的实例化对象d2来包装d1，调用Decorator的方法，传参到component
            d2.Operation();//调用ConcreteDecoratorB的方法
            Console.Read();
        }
    }
    abstract class Component
    {
        public abstract void Operation();
    }
    class ConcreteComponent : Component
    {
        public override void Operation()
        {
            Console.WriteLine("具体对象的操作");
        }
    }
    abstract class Decorator : Component
    {
        protected Component component;
        public void SetComponent(Component component)//传参
        {
            this.component = component;
        }
        public override void Operation()
        {
            if (component != null)//首先运行的是ConcreteDecoratorA//其次是ConcreteComponent
            {
                component.Operation();//首先调用ConcreteDecoratorA的方法//其次调用ConcreteComponent的方法
            }
        }
    }
    class ConcreteDecoratorA : Decorator
    {
        public override void Operation()
        {
            base.Operation();//调用父类中的方法
            Console.WriteLine("具体装饰对象A的操作");
        }
    }
    class ConcreteDecoratorB: Decorator
    {
        public override void Operation()
        {
            base.Operation();//子类中调用父类的方法
            Console.WriteLine("具体装饰对象B的操作");
        }
    }
```
装饰模式是利用SetComponent来对对象进行包装的。每个装饰对象的实现就和如何使用这个对象分离开，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。
