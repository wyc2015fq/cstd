# 菜鸟升级记——建造者模式 - Jun5203 - CSDN博客
2019年02月16日 21:51:29[贾俊浩_Ellen](https://me.csdn.net/Ellen5203)阅读数：40
所属专栏：[C#](https://blog.csdn.net/column/details/29824.html)
**建造者模式**
建造者模式又叫“生成器模式”，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
**<代码解读>**
```
class Program
    {
        static void Main(string[] args)
        {
            Director director=new Director();//实例化指挥者→指挥者类（若无构造函数则调试不显示）
            Builder b1=new ConcreteBuilder1();//里氏转换→ConcreteBuilder1类(1)
            Builder b2=new ConcreteBuilder2();//同上
            director.Construct(b1);//调用director的Construct方法，传b1(ConcreteBuilder1)(2)
            Product p1 = b1.GetResult();//指挥者用ConcreteBuilder1的方法来建造产品
            p1.Show();//p1=product
            director.Construct(b2);
            Product p2 = b2.GetResult();
            p2.Show();
            Console.Read();
        }
    }
    //Product类-产品类，由多个部件组成
    class Product
    {
        IList<string >parts=new List<string>();
        public void Add(string part)//添加产品部件//part=部件A
        {
            parts.Add(part);
        }
        public void Show()
        {
            Console.WriteLine("\n产品 创建 ----");
            foreach (string part in parts)//列举所有的产品部件,遍历
            {
                Console.WriteLine(part);
            }
        }
    }
    //Builder类——抽象建造者类
    abstract class Builder
    {
        public abstract void BuildPartA();
        public abstract void BuildPartB();
        public abstract Product GetResult();
    }
    //ConcreteBuilder1类——具体建造者类
    class ConcreteBuilder1 : Builder 
    {
        private Product product=new Product();//1.1ConcreteBuilder1依赖于Product
        public override void BuildPartA()
        {
            product.Add("部件A");//2.2调用product的Add方法，传“部件A”
        }
        public override void BuildPartB()
        {
            product.Add("部件B");
        }
        public override Product GetResult()
        {
            return product;//相当于new product
        }
    }
    //ConcreteBuilder2类——具体建造者类
    class ConcreteBuilder2 : Builder
    {
        private Product product = new Product();
        public override void BuildPartA()
        {
            product.Add("部件X");
        }
        public override void BuildPartB()
        {
            product.Add("部件Y");
        }
        public override Product GetResult()
        {
            return product;
        }
    }
    //Director类——指挥者类
    class Director
    {
        public void Construct(Builder builder)//Director与Builder是聚合关系2.1Builder=ConcreteBuilder1
        {
            builder.BuildPartA();//调用ConcreteBuilder1的BuildPartA方法
        }
    }
```
什么时候使用建造者模式？
主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。
