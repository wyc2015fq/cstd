# 粒子群算法详解 二 - qq_32515081的博客 - CSDN博客
2018年04月02日 21:07:30[TengAdventure](https://me.csdn.net/qq_32515081)阅读数：57
#### 几个适应度评价函数
     头几天机子种了病毒，重新安装了系统，不小心把程序全部格式化了，痛哭！！！没办法，好多程序不见了，现在把这几个典型的函数重新编写了，把他们给出来，就算粒子群算法的一个结束吧！痛恨病毒！！！！
第一个函数：Griewank函数，图形如下所示：
![](https://p-blog.csdn.net/images/p_blog_csdn_net/niuyongjie/295595/o_Griewank.jpg)
适应度函数如下：（为了求最大值，我去了所有函数值的相反数）
function y=Griewank(x)
%Griewan函数
%输入x,给出相应的y值,在x=(0,0,…,0)处有全局极小点0.
%编制人：
%编制日期：
[row,col]=size(x);
if row>1
     error('输入的参数错误');
end
 y1=1/4000*sum(x.^2);
 y2=1;
for h=1:col
     y2=y2*cos(x(h)/sqrt(h));
 end
 y=y1-y2+1;
 y=-y;
绘制函数图像的代码如下：
function DrawGriewank()
%绘制Griewank函数图形
x=[-8:0.1:8];
 y=x;
 [X,Y]=meshgrid(x,y);
 [row,col]=size(X);
for l=1:col
for h=1:row
         z(h,l)=Griewank([X(h,l),Y(h,l)]);
     end
 end
 surf(X,Y,z);
 shading interp
第二个函数：Rastrigin函数，图形如下所示：
![](https://p-blog.csdn.net/images/p_blog_csdn_net/niuyongjie/295595/o_Rastrigin.jpg)
适应度函数如下：（为了求最大值，我去了所有函数值的相反数）
function y=Rastrigin(x)
%Rastrigin函数
%输入x,给出相应的y值,在x=(0,0,…,0)处有全局极小点0.
%编制人：
%编制日期：
[row,col]=size(x);
if row>1
     error('输入的参数错误');
end
 y=sum(x.^2-10*cos(2*pi*x)+10);
 y=-y;
绘制函数图像的代码如下：
function DrawRastrigin()
%绘制Rastrigin函数图形
x=[-5:0.05:5];
 y=x;
 [X,Y]=meshgrid(x,y);
 [row,col]=size(X);
for l=1:col
for h=1:row
         z(h,l)=Rastrigin([X(h,l),Y(h,l)]);
     end
 end
 surf(X,Y,z);
 shading interp
第三个函数Schaffer函数，图形如下所示：
![](http://hi.csdn.net/attachment/201005/7/0_1273212391CzZQ.gif)
函数的代码如下，因为该函数在（0,...,0）处有最大值1，因此不需要取相反数。
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function result=Schaffer(x1)  
- %Schaffer 函数  
- %输入x,给出相应的y值,在x=(0,0,…,0) 处有全局极大点1.  
- %编制人：  
- %编制日期：  
- [row,col]=size(x1);  
- if row>1  
-     error('输入的参数错误');  
- end  
- x=x1(1,1);  
- y=x1(1,2);  
- temp=x^2+y^2;  
- result=0.5-(sin(sqrt(temp))^2-0.5)/(1+0.001*temp)^2;  
function result=Schaffer(x1)
%Schaffer 函数
%输入x,给出相应的y值,在x=(0,0,…,0) 处有全局极大点1.
%编制人：
%编制日期：
[row,col]=size(x1);
if row>1
    error('输入的参数错误');
end
x=x1(1,1);
y=x1(1,2);
temp=x^2+y^2;
result=0.5-(sin(sqrt(temp))^2-0.5)/(1+0.001*temp)^2;
绘制函数代码图形的代码如下：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function DrawSchaffer()  
- x=[-5:0.05:5];  
- y=x;  
- [X,Y]=meshgrid(x,y);  
- [row,col]=size(X);  
- for l=1:col  
- for h=1:row  
- z(h,l)=Schaffer([X(h,l),Y(h,l)]);  
- end  
- end  
- surf(X,Y,z);  
- shading interp  
function DrawSchaffer()
x=[-5:0.05:5];
y=x;
[X,Y]=meshgrid(x,y);
[row,col]=size(X);
for l=1:col
for h=1:row
z(h,l)=Schaffer([X(h,l),Y(h,l)]);
end
end
surf(X,Y,z);
shading interp
第四个函数：Ackley函数，函数图形如下：
![](http://hi.csdn.net/attachment/201005/7/0_1273214232AIdI.gif)
函数的代码如下，因为 该函数在（0,...,0）处有最小值0，因此需要取相反数
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function result=Ackley(x)  
- %Ackley 函数  
- %输入x,给出相应的y值,在x=(0,0,…,0) 处有全局极小点0,为得到最大值，返回值取相反数  
- %编制人：  
- %编制日期：  
- [row,col]=size(x);  
- if row>1  
-     error('输入的参数错误');  
- end  
- result=-20*exp(-0.2*sqrt((1/col)*(sum(x.^2))))-exp((1/col)*sum(cos(2*pi.*x)))+exp(1)+20;  
- result=-result;  
function result=Ackley(x)
%Ackley 函数
%输入x,给出相应的y值,在x=(0,0,…,0) 处有全局极小点0,为得到最大值，返回值取相反数
%编制人：
%编制日期：
[row,col]=size(x);
if row>1
    error('输入的参数错误');
end
result=-20*exp(-0.2*sqrt((1/col)*(sum(x.^2))))-exp((1/col)*sum(cos(2*pi.*x)))+exp(1)+20;
result=-result;
绘制函数代码图形的代 码如下：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function DrawAckley()  
- %绘制Ackley函数图形  
- x=[-8:0.1:8];  
- y=x;  
- [X,Y]=meshgrid(x,y);  
- [row,col]=size(X);  
- for l=1:col  
- for h=1:row  
-         z(h,l)=Ackley([X(h,l),Y(h,l)]);  
-     end  
- end  
- surf(X,Y,z);  
- shading interp  
function DrawAckley()
%绘制Ackley函数图形
x=[-8:0.1:8];
y=x;
[X,Y]=meshgrid(x,y);
[row,col]=size(X);
for l=1:col
    for h=1:row
        z(h,l)=Ackley([X(h,l),Y(h,l)]);
    end
end
surf(X,Y,z);
shading interp
第五个函数是：Rosenbrock函数，该函数在（1,...,1）处有最小值0，为了得到最大值，取函数值的相反数。
函数图形如下所示
![](http://hi.csdn.net/attachment/201005/7/0_1273215531j7Fw.gif)
函数的代码：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function result=Rosenbrock(x)  
- %Rosenbrock 函数  
- %输入x,给出相应的y值,在x=(1,1,…,1) 处有全局极小点0,为得到最大值，返回值取相反数  
- %编制人：  
- %编制日期：  
- [row,col]=size(x);  
- if row>1  
-     error('输入的参数错误');  
- end  
- result=100*(x(1,2)-x(1,1)^2)^2+(x(1,1)-1)^2;  
- result=-result;  
function result=Rosenbrock(x)
%Rosenbrock 函数
%输入x,给出相应的y值,在x=(1,1,…,1) 处有全局极小点0,为得到最大值，返回值取相反数
%编制人：
%编制日期：
[row,col]=size(x);
if row>1
    error('输入的参数错误');
end
result=100*(x(1,2)-x(1,1)^2)^2+(x(1,1)-1)^2;
result=-result;
绘制函数图形的代码如下：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/1619496#)[copy](https://blog.csdn.net/niuyongjie/article/details/1619496#)[print](https://blog.csdn.net/niuyongjie/article/details/1619496#)[?](https://blog.csdn.net/niuyongjie/article/details/1619496#)
- function DrawRosenbrock()  
- %绘制Rosenbrock函数图形,大铁锅函数，哈哈  
- x=[-8:0.1:8];  
- y=x;  
- [X,Y]=meshgrid(x,y);  
- [row,col]=size(X);  
- for l=1:col  
- for h=1:row  
-         z(h,l)=Rosenbrock([X(h,l),Y(h,l)]);  
-     end  
- end  
- surf(X,Y,z);  
- shading interp  
function DrawRosenbrock()
%绘制Rosenbrock函数图形,大铁锅函数，哈哈
x=[-8:0.1:8];
y=x;
[X,Y]=meshgrid(x,y);
[row,col]=size(X);
for l=1:col
    for h=1:row
        z(h,l)=Rosenbrock([X(h,l),Y(h,l)]);
    end
end
surf(X,Y,z);
shading interp
这样粒子群算法不得不草草收场。
我们选择的测试函数是：Griewank。其基本形式如下：
![](http://latex.codecogs.com/gif.latex?min&space;f%5Cleft&space;(&space;x_i&space;%5Cright&space;)=%5Csum_%7Bi&space;=&space;1%7D%5E%7BN%7D%5Cfrac%7Bx_i%5E2%7D%7B4000%7D-%5Cprod_%7Bi=1%7D%5E%7BN%7Dcos%5Cleft&space;(&space;%5Cfrac%7Bx_i%7D%7B%5Csqrt%7Bi%7D%7D&space;%5Cright&space;)+1)
图像为：
![](https://img-blog.csdn.net/20140611134514843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ29vZ2xlMTk4OTAxMDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
（Griewank函数图像）
在实验中我们选择的维数是20；MATLAB程序代码如下：
主程序：
**[plain]**[view plain](https://blog.csdn.net/google19890102/article/details/30044945#)[copy](https://blog.csdn.net/google19890102/article/details/30044945#)[print](https://blog.csdn.net/google19890102/article/details/30044945#)[?](https://blog.csdn.net/google19890102/article/details/30044945#)
- c1=2;%学习因子  
- c2=2;%学习因子  
- Dimension=20;  
- Size=30;  
- Tmax=500;  
- Velocity_max=1200;%粒子最大速度  
- 
- F_n=2;%测试函数名  
- 
- Fun_Ub=600;%函数上下界  
- Fun_Lb=-600;  
- Position=zeros(Dimension,Size);%粒子位置  
- Velocity=zeros(Dimension,Size);%粒子速度  
- Vmax(1:Dimension)=Velocity_max;%粒子速度上下界  
- Vmin(1:Dimension)=-Velocity_max;  
- Xmax(1:Dimension)=Fun_Ub;%粒子位置上下界，即函数自变量的上下界  
- Xmin(1:Dimension)=Fun_Lb;  
- [Position,Velocity]=Initial_position_velocity(Dimension,Size,Xmax,Xmin,Vmax,Vmin);  
- 
- Pbest_position=Position;%粒子的历史最优位置，初始值为粒子的起始位置，存储每个粒子的历史最优位置  
- Gbest_position=zeros(Dimension,1);%全局最优的那个粒子所在位置，初始值认为是第1个粒子  
- 
- for j=1:Size  
-     Pos=Position(:,j);%取第j列，即第j个粒子的位置  
-     fz(j)=Fitness_Function(Pos,F_n,Dimension);%计算第j个粒子的适应值  
- end  
- [Gbest_Fitness,I]=min(fz);%求出所有适应值中最小的那个适应值，并获得该粒子的位置  
- Gbest_position=Position(:,I);%取最小适应值的那个粒子的位置，即I列  
- 
- for itrtn=1:Tmax  
- time(itrtn)=itrtn;  
- 
- Weight=1;  
- r1=rand(1);  
- r2=rand(1);  
- for i=1:Size  
-    Velocity(:,i)=Weight*Velocity(:,i)+c1*r1*(Pbest_position(:,i)-Position(:,i))+c2*r2*(Gbest_position-Position(:,i));  
- end  
- %限制速度边界  
- for i=1:Size  
-     for row=1:Dimension  
-         if Velocity(row,i)>Vmax(row)  
-             Veloctity(row,i)=Vmax(row);  
-         elseif Velocity(row,i)<Vmin(row)  
-             Veloctity(row,i)=Vmin(row);  
-         else  
-         end  
-     end  
- end  
- 
- Position=Position+Velocity;  
- 
- %限制位置边界  
- for i=1:Size  
-     for row=1:Dimension  
-         if Position(row,i)>Xmax(row)  
-             Position(row,i)=Xmax(row);  
-         elseif Position(row,i)<Xmin(row)  
-             Position(row,i)=Xmin(row);  
-         else  
-         end  
-     end  
- end  
- 
-   for j=1:Size  
-      P_position=Position(:,j)';%取一个粒子的位置  
-      fitness_p(j)=Fitness_Function(P_position,F_n,Dimension);  
-      if fitness_p(j)< fz(j) %粒子的适应值比运动之前的适应值要好，更新原来的适应值  
-          Pbest_position(:,j)=Position(:,j);  
-          fz(j)=fitness_p(j);  
-      end  
-      if fitness_p(j)<Gbest_Fitness  
-          Gbest_Fitness=fitness_p(j);  
-      end  
-   end  
-   [Gbest_Fitness_new,I]=min(fz);%更新后的所有粒子的适应值，取最小的那个，并求出其编号  
-    Best_fitness(itrtn)=Gbest_Fitness_new; %记录每一代的最好适应值  
-    Gbest_position=Pbest_position(:,I);%最好适应值对应的个体所在位置  
- end  
- plot(time,Best_fitness);  
- xlabel('迭代的次数');ylabel('适应度值P_g');  
```
c1=2;%学习因子
c2=2;%学习因子
Dimension=20;
Size=30;
Tmax=500;
Velocity_max=1200;%粒子最大速度
F_n=2;%测试函数名
Fun_Ub=600;%函数上下界
Fun_Lb=-600;
Position=zeros(Dimension,Size);%粒子位置
Velocity=zeros(Dimension,Size);%粒子速度
Vmax(1:Dimension)=Velocity_max;%粒子速度上下界
Vmin(1:Dimension)=-Velocity_max;
Xmax(1:Dimension)=Fun_Ub;%粒子位置上下界，即函数自变量的上下界
Xmin(1:Dimension)=Fun_Lb;
[Position,Velocity]=Initial_position_velocity(Dimension,Size,Xmax,Xmin,Vmax,Vmin);
Pbest_position=Position;%粒子的历史最优位置，初始值为粒子的起始位置，存储每个粒子的历史最优位置
Gbest_position=zeros(Dimension,1);%全局最优的那个粒子所在位置，初始值认为是第1个粒子
for j=1:Size
    Pos=Position(:,j);%取第j列，即第j个粒子的位置
    fz(j)=Fitness_Function(Pos,F_n,Dimension);%计算第j个粒子的适应值
end
[Gbest_Fitness,I]=min(fz);%求出所有适应值中最小的那个适应值，并获得该粒子的位置
Gbest_position=Position(:,I);%取最小适应值的那个粒子的位置，即I列
for itrtn=1:Tmax
time(itrtn)=itrtn;
Weight=1;
r1=rand(1);
r2=rand(1);
for i=1:Size
   Velocity(:,i)=Weight*Velocity(:,i)+c1*r1*(Pbest_position(:,i)-Position(:,i))+c2*r2*(Gbest_position-Position(:,i));
end
%限制速度边界
for i=1:Size
    for row=1:Dimension
        if Velocity(row,i)>Vmax(row)
            Veloctity(row,i)=Vmax(row);
        elseif Velocity(row,i)<Vmin(row)
            Veloctity(row,i)=Vmin(row);
        else
        end
    end
end
Position=Position+Velocity;
%限制位置边界
for i=1:Size
    for row=1:Dimension
        if Position(row,i)>Xmax(row)
            Position(row,i)=Xmax(row);
        elseif Position(row,i)<Xmin(row)
            Position(row,i)=Xmin(row);
        else
        end
    end
end
  for j=1:Size
     P_position=Position(:,j)';%取一个粒子的位置
     fitness_p(j)=Fitness_Function(P_position,F_n,Dimension);
     if fitness_p(j)< fz(j) %粒子的适应值比运动之前的适应值要好，更新原来的适应值
         Pbest_position(:,j)=Position(:,j);
         fz(j)=fitness_p(j);
     end
     if fitness_p(j)<Gbest_Fitness
         Gbest_Fitness=fitness_p(j);
     end
  end
  [Gbest_Fitness_new,I]=min(fz);%更新后的所有粒子的适应值，取最小的那个，并求出其编号
   Best_fitness(itrtn)=Gbest_Fitness_new; %记录每一代的最好适应值
   Gbest_position=Pbest_position(:,I);%最好适应值对应的个体所在位置
end
plot(time,Best_fitness);
xlabel('迭代的次数');ylabel('适应度值P_g');
```
初始化：
**[plain]**[view plain](https://blog.csdn.net/google19890102/article/details/30044945#)[copy](https://blog.csdn.net/google19890102/article/details/30044945#)[print](https://blog.csdn.net/google19890102/article/details/30044945#)[?](https://blog.csdn.net/google19890102/article/details/30044945#)
- function [Position,Velocity] = Initial_position_velocity(Dimension,Size,Xmax,Xmin,Vmax,Vmin)  
-   for i=1:Dimension  
-       Position(i,:)=Xmin(i)+(Xmax(i)-Xmin(i))*rand(1,Size); % 产生合理范围内的随机位置，rand(1,Size)用于产生一行Size个随机数  
-       Velocity(i,:)=Vmin(i)+(Vmax(i)-Vmin(i))*rand(1,Size);  
-   end  
- end  
```
function [Position,Velocity] = Initial_position_velocity(Dimension,Size,Xmax,Xmin,Vmax,Vmin)
  for i=1:Dimension
      Position(i,:)=Xmin(i)+(Xmax(i)-Xmin(i))*rand(1,Size); % 产生合理范围内的随机位置，rand(1,Size)用于产生一行Size个随机数
      Velocity(i,:)=Vmin(i)+(Vmax(i)-Vmin(i))*rand(1,Size);
  end
end
```
适应值计算：
**[plain]**[view plain](https://blog.csdn.net/google19890102/article/details/30044945#)[copy](https://blog.csdn.net/google19890102/article/details/30044945#)[print](https://blog.csdn.net/google19890102/article/details/30044945#)[?](https://blog.csdn.net/google19890102/article/details/30044945#)
- function Fitness=Fitness_Function(Pos,F_n,Dimension)  
-  switch F_n  
-     case 1  
-         Func_Sphere=Pos(:)'*Pos(:);  
-         Fitness=Func_Sphere;  
-     case 2  
-         res1=Pos(:)'*Pos(:)/4000;  
-         res2=1;  
-         for row=1:Dimension  
-             res2=res2*cos(Pos(row)/sqrt(row));  
-         end  
-         Func_Griewank=res1-res2+1;  
-         Fitness=Func_Griewank;  
- end  
```
function Fitness=Fitness_Function(Pos,F_n,Dimension)
 switch F_n
    case 1
        Func_Sphere=Pos(:)'*Pos(:);
        Fitness=Func_Sphere;
    case 2
        res1=Pos(:)'*Pos(:)/4000;
        res2=1;
        for row=1:Dimension
            res2=res2*cos(Pos(row)/sqrt(row));
        end
        Func_Griewank=res1-res2+1;
        Fitness=Func_Griewank;
end
```
最终的收敛曲线：
![](https://img-blog.csdn.net/20140611134709343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ29vZ2xlMTk4OTAxMDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
（收敛曲线）
#### 粒子群算法局部版本的实现
最近要写篇与粒子群算法有关的文章，因此不得不实现粒子群算法的局部版本。粒子群算法局部版本的实现思想已经在粒子群算法(3)----标准的粒子群算法(局部版本)中已经讲述。主要分为3个函数。第一个函数为粒子群初始化函数LocalInitSwarm(SwarmSize......AdaptFunc)其主要作用是初始化粒子群的粒子，并设定粒子的速度、位置在一定的范围内。本函数所采用的数据结构如下所示：
表ParSwarm记录的是粒子的位置、速度与当前的适应度值，我们用W来表示位置，用V来代表速度，用F来代表当前的适应度值。在这里我们假设粒子个数为N，每个粒子的维数为D。
|W1,1|W1,2|...|W1,D|V1,1|V1,2|...|V1,D-1|V1,D|F1|第1个粒子|
|----|----|----|----|----|----|----|----|----|----|----|
|W2,1|W2,2|...|W2,D|V2,1|V2,2|...|V2,D-1|V2,D|F2|第2个粒子|
|...|...|...|...|...|...|...|...|...|...|.......|
|WN-1,1|WN-1,2|...|WN-1,D-1|VN-1,1|VN-1,2|...|VN-1,D-1|VN-1,D|FN-1|第N-1个粒子|
|WN,1|WN,2|...|WN,D|VN,1|VN,2|...|VN,D-1|VN,D|FN|第N个粒子|
表OptSwarm不但要记录自身历史最优解，还需要记录每个粒子邻域（采用环形邻域）的最优解，以及全部粒子搜索到的全局最优解。因此应该有2*N+1行，前SwarmSize行记录粒子自己历史最优解，后SwarmSize行记录邻域最优解。用Wg代表全局最优解，W.,1代表每个粒子的历史最优解。粒子群初始化阶段表OptSwarm的前N行与表ParSwarm中
的相同，而Wg的值为表ParSwarm中适应度值的最大值对应的行。
|W1,1|Wj,2|...|Wj,D-1|Wj,D|第1个粒子的历史最优解|
|----|----|----|----|----|----|
|W2,1|Wk,2|...|Wk,D-1|Wk,D|第2个粒子的历史最优解|
|...|...|...|...|...|...|
|W(N-1),1|Wl,2|...|Wl,D-1|Wl,D|第N-1个粒子的历史最优解|
|W(N),1|Wm,2|...|Wm,D-1|Wm,D|第N个粒子的历史最优解|
|Wl,1|...|...|...|Wl,D|第一个粒子的邻域最优解|
|Wl,2|...|...|...|Wl,D|第二个粒子的邻域最优解|
|...|...|...|...|.....|....|
|Wl,N|...|...|...|...|第N个粒子的邻域最优解|
|Wg,1|Wg,2|...|Wg,D-1|Wg,D|全局粒子的历史最优解|
根据这样的思想MATLAB代码如下：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5601882#)[copy](https://blog.csdn.net/niuyongjie/article/details/5601882#)[print](https://blog.csdn.net/niuyongjie/article/details/5601882#)[?](https://blog.csdn.net/niuyongjie/article/details/5601882#)
- function [ParSwarm,OptSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc)  
- %功能描述：局部版本的粒子群算法，初始化粒子群，限定粒子群的位置以及速度在指定的范围内  
- %[ParSwarm,OptSwarm,BadSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc)  
- %  
- %输入参数：SwarmSize:种群大小的个数  
- %输入参数：ParticleSize：一个粒子的维数  
- %输入参数：ParticleScope:一个粒子在运算中各维的范围；  
- %         ParticleScope格式:  
- %           3维粒子的ParticleScope格式:  
- %                                   [x1Min,x1Max  
- %                                    x2Min,x2Max  
- %                                    x3Min,x3Max]  
- %  
- %输入参数：AdaptFunc：适应度函数  
- %  
- %输出：ParSwarm初始化的粒子群  
- %输出：OptSwarm粒子群当前最优解与每个粒子邻域的最优解，第一次初始化，邻域的区域为0，即为粒子本身  
- %  
- %用法 [ParSwarm,OptSwarm,BadSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc);  
- %  
- %异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。  
- %  
- %编制人：XXX  
- %编制时间：2010.5.6  
- %参考文献：无  
- %  
- 
- %容错控制  
- if nargin~=4  
-     error('输入的参数个数错误。')  
- end  
- if nargout<2  
-     error('输出的参数的个数太少，不能保证以后的运行。');  
- end  
- 
- [row,colum]=size(ParticleSize);  
- if row>1||colum>1  
-     error('输入的粒子的维数错误，是一个1行1列的数据。');  
- end  
- [row,colum]=size(ParticleScope);  
- if row~=ParticleSize||colum~=2  
-     error('输入的粒子的维数范围错误。');  
- end  
- 
- %初始化粒子群矩阵  
- 
- %初始化粒子群矩阵，全部设为[0-1]随机数  
- %rand('state',0);  
- ParSwarm=rand(SwarmSize,2*ParticleSize+1);  
- 
- %对粒子群中位置,速度的范围进行调节  
- for k=1:ParticleSize  
-     ParSwarm(:,k)=ParSwarm(:,k)*(ParticleScope(k,2)-ParticleScope(k,1))+ParticleScope(k,1);  
-     %调节速度，使速度与位置的范围一致  
-     ParSwarm(:,ParticleSize+k)=ParSwarm(:,ParticleSize+k)*(ParticleScope(k,2)-ParticleScope(k,1))+ParticleScope(k,1);  
- end  
- 
- %对每一个粒子计算其适应度函数的值  
- 
- for k=1:SwarmSize  
-     ParSwarm(k,2*ParticleSize+1)=AdaptFunc(ParSwarm(k,1:ParticleSize));  
- end  
- 
- %初始化粒子群最优解矩阵,共SwarmSize*2行，其中前SwarmSize行记录粒子自己历史最优解，后SwarmSize行记录邻域最优解  
- OptSwarm=zeros(SwarmSize*2+1,ParticleSize);  
- %粒子群最优解矩阵全部设为零  
- OptSwarm(1:SwarmSize,:)=ParSwarm(1:SwarmSize,1:ParticleSize);  
- %计算粒子邻域为1的最优解  
- linyu=1;  
- for row=1:SwarmSize  
- if row-linyu>0&&row+linyu<=SwarmSize  
-             tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];              
-             [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));             
-             OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);             
- else
- if row-linyu<=0  
-                 %该行上面的部分突出了边界，下面绝对不会突破边界  
- if row==1  
-                     tempM=[ParSwarm(SwarmSize+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                       
-                     OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                     
- else
-                     tempM=[ParSwarm(1:row-1,:);ParSwarm(SwarmSize+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                      
-                     OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                    
-                 end  
- else
-                 %该行下面的部分突出了边界，上面绝对不会突破边界  
- if row==SwarmSize  
-                     tempM=[ParSwarm(SwarmSize-linyu:row-1,:);ParSwarm(1:linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                       
-                     OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);  
- else
-                     tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(SwarmSize-row),:)];    
-                     [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                      
-                     OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                      
-                 end  
-             end  
-         end  
-     end%for
- [maxValue,row]=max(ParSwarm(:,2*ParticleSize+1));  
- %寻找适应度函数值最大的解在矩阵中的位置(行数)  
- OptSwarm(SwarmSize*2+1,:)=ParSwarm(row,1:ParticleSize);  
function [ParSwarm,OptSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc)
%功能描述：局部版本的粒子群算法，初始化粒子群，限定粒子群的位置以及速度在指定的范围内
%[ParSwarm,OptSwarm,BadSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc)
%
%输入参数：SwarmSize:种群大小的个数
%输入参数：ParticleSize：一个粒子的维数
%输入参数：ParticleScope:一个粒子在运算中各维的范围；
%         ParticleScope格式:
%           3维粒子的ParticleScope格式:
%                                   [x1Min,x1Max
%                                    x2Min,x2Max
%                                    x3Min,x3Max]
%
%输入参数：AdaptFunc：适应度函数
%
%输出：ParSwarm初始化的粒子群
%输出：OptSwarm粒子群当前最优解与每个粒子邻域的最优解，第一次初始化，邻域的区域为0，即为粒子本身
%
%用法 [ParSwarm,OptSwarm,BadSwarm]=LocalInitSwarm(SwarmSize,ParticleSize,ParticleScope,AdaptFunc);
%
%异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。
%
%编制人：XXX
%编制时间：2010.5.6
%参考文献：无
%
%容错控制
if nargin~=4
    error('输入的参数个数错误。')
end
if nargout<2
    error('输出的参数的个数太少，不能保证以后的运行。');
end
[row,colum]=size(ParticleSize);
if row>1||colum>1
    error('输入的粒子的维数错误，是一个1行1列的数据。');
end
[row,colum]=size(ParticleScope);
if row~=ParticleSize||colum~=2
    error('输入的粒子的维数范围错误。');
end
%初始化粒子群矩阵
%初始化粒子群矩阵，全部设为[0-1]随机数
%rand('state',0);
ParSwarm=rand(SwarmSize,2*ParticleSize+1);
%对粒子群中位置,速度的范围进行调节
for k=1:ParticleSize
    ParSwarm(:,k)=ParSwarm(:,k)*(ParticleScope(k,2)-ParticleScope(k,1))+ParticleScope(k,1);
    %调节速度，使速度与位置的范围一致
    ParSwarm(:,ParticleSize+k)=ParSwarm(:,ParticleSize+k)*(ParticleScope(k,2)-ParticleScope(k,1))+ParticleScope(k,1);
end
    
%对每一个粒子计算其适应度函数的值
for k=1:SwarmSize
    ParSwarm(k,2*ParticleSize+1)=AdaptFunc(ParSwarm(k,1:ParticleSize));
end
%初始化粒子群最优解矩阵,共SwarmSize*2行，其中前SwarmSize行记录粒子自己历史最优解，后SwarmSize行记录邻域最优解
OptSwarm=zeros(SwarmSize*2+1,ParticleSize);
%粒子群最优解矩阵全部设为零
OptSwarm(1:SwarmSize,:)=ParSwarm(1:SwarmSize,1:ParticleSize);
%计算粒子邻域为1的最优解
linyu=1;
    for row=1:SwarmSize
        if row-linyu>0&&row+linyu<=SwarmSize
            tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];            
            [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));           
            OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);           
        else
            if row-linyu<=0
                %该行上面的部分突出了边界，下面绝对不会突破边界
                if row==1
                    tempM=[ParSwarm(SwarmSize+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                     
                    OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                   
                else
                    tempM=[ParSwarm(1:row-1,:);ParSwarm(SwarmSize+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                    
                    OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                  
                end
            else
                %该行下面的部分突出了边界，上面绝对不会突破边界
                if row==SwarmSize
                    tempM=[ParSwarm(SwarmSize-linyu:row-1,:);ParSwarm(1:linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                     
                    OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);
                else
                    tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(SwarmSize-row),:)];  
                    [maxValue,linyurow]=max(tempM(:,2*ParticleSize+1));                    
                    OptSwarm(SwarmSize+row,:)=tempM(linyurow,1:ParticleSize);                    
                end
            end
        end
    end%for
[maxValue,row]=max(ParSwarm(:,2*ParticleSize+1));
%寻找适应度函数值最大的解在矩阵中的位置(行数)
OptSwarm(SwarmSize*2+1,:)=ParSwarm(row,1:ParticleSize);
下面的函数LocalPsoProcessByCircle实现了局部版粒子群算法的单步更新位置速度的功能，其中把速度的范围限制在每维范围的0.5倍。这个跟以前的版本有些区别，经过试验效果还可以。
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5601882#)[copy](https://blog.csdn.net/niuyongjie/article/details/5601882#)[print](https://blog.csdn.net/niuyongjie/article/details/5601882#)[?](https://blog.csdn.net/niuyongjie/article/details/5601882#)
- function [ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- % 功能描述：局部版本：采用环形邻域的方法。基本的粒子群算法的单步更新位置,速度的算法  
- %  
- %[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- %  
- % 输入参数：ParSwarm:粒子群矩阵，包含粒子的位置，速度与当前的目标函数值  
- %输入参数：OptSwarm：包含粒子群个体最优解与全局最优解的矩阵  
- %输入参数：ParticleScope:一个粒子在运算中各维的范围；  
- % 输入参数：AdaptFunc：适应度函数  
- %输入参数：LoopCount：迭代的总次数  
- %输入参数：CurCount：当前迭代的次数  
- %  
- % 返回值：含意同输入的同名参数  
- %  
- %用法：[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- %  
- % 异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。  
- %  
- %编制人：XXX  
- %编制时间：2010.5.6  
- %参考文献：XXX  
- %参考文献：XXX  
- %  
- %修改记录  
- %----------------------------------------------------------------  
- %2010.5.6  
- %修改人：XXX  
- % 添加2*unifrnd(0,1).*SubTract1(row,:)中的unifrnd(0,1)随机数，使性能大为提高  
- %参照基于MATLAB的粒子群优化算法程序设计  
- %  
- % 总体评价：使用这个版本的调节系数，效果比较好  
- %  
- 
- %容错控制  
- if nargin~=8  
-     error('输入的参数个数错误。')  
- end  
- if nargout~=2  
-     error('输出的个数太少，不能保证循环迭代。')  
- end  
- 
- %开始单步更新的操作  
- 
- %*********************************************  
- %***** 更改下面的代码，可以更改惯性因子的变化*****  
- %---------------------------------------------------------------------  
- % 线形递减策略  
- w=MaxW-CurCount*((MaxW-MinW)/LoopCount);  
- %---------------------------------------------------------------------  
- %w 固定不变策略  
- %w=0.7;  
- %---------------------------------------------------------------------  
- % 参考文献：陈贵敏，贾建援，韩琪，粒子群优化算法的惯性权值递减策略研究，西安交通大学学报，2006，1  
- %w 非线形递减，以凹函数递减  
- %w=(MaxW-MinW)*(CurCount/LoopCount)^2+(MinW-MaxW)*(2*CurCount/LoopCount)+MaxW;  
- %---------------------------------------------------------------------  
- %w 非线形递减，以凹函数递减  
- %w=MinW*(MaxW/MinW)^(1/(1+10*CurCount/LoopCount));  
- %*****更改上面的代码，可以更改惯性因子的变化*****  
- %*********************************************  
- 
- % 得到粒子群群体大小以及一个粒子维数的信息  
- [ParRow,ParCol]=size(ParSwarm);  
- 
- %得到粒子的维数  
- ParCol=(ParCol-1)/2;  
- SubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置  
- SubTract2=OptSwarm(ParRow+1:end-1,:)-ParSwarm(:,1:ParCol);  
- %*********************************************  
- %***** 更改下面的代码，可以更改c1,c2的变化*****  
- c1=2.05;  
- c2=2.05;  
- %---------------------------------------------------------------------  
- %con=1;  
- %c1=4-exp(-con*abs(mean(ParSwarm(:,2*ParCol+1))-AdaptFunc(OptSwarm(ParRow+1,:))));  
- %c2=4-c1;  
- %----------------------------------------------------------------------  
- %***** 更改上面的代码，可以更改c1,c2的变化*****  
- %*********************************************  
- for row=1:ParRow     
-    TempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*SubTract1(row,:)+c2*unifrnd(0,1).*SubTract2(row,:);  
-    %限制速度的代码  
- for h=1:ParCol  
- if TempV(:,h)>ParticleScope(h,2)/2.0  
-            TempV(:,h)=ParticleScope(h,2)/2.0;  
-        end  
- if TempV(:,h)<-ParticleScope(h,2)/2.0  
-            TempV(:,h)=(-ParticleScope(h,2)+1e-10)/2.0;  
-            %加1e-10防止适应度函数被零除  
-        end  
-    end    
- 
-    % 更新速度  
-    ParSwarm(row,ParCol+1:2*ParCol)=TempV;  
- 
-    %*********************************************  
-    %***** 更改下面的代码，可以更改约束因子的变化*****  
-    %---------------------------------------------------------------------  
-    %a=1;  
-    %---------------------------------------------------------------------  
-    a=0.729;  
-    %***** 更改上面的代码，可以更改约束因子的变化*****  
-    %*********************************************  
- 
-    % 限制位置的范围  
-    TempPos=ParSwarm(row,1:ParCol)+a*TempV;  
- for h=1:ParCol  
- if TempPos(:,h)>ParticleScope(h,2)  
-            TempPos(:,h)=ParticleScope(h,2);  
-        end  
- if TempPos(:,h)<=ParticleScope(h,1)  
-            TempPos(:,h)=ParticleScope(h,1)+1e-10;             
-        end  
-    end  
- 
-    %更新位置   
-    ParSwarm(row,1:ParCol)=TempPos;  
- 
-    % 计算每个粒子的新的适应度值  
-    ParSwarm(row,2*ParCol+1)=AdaptFunc(ParSwarm(row,1:ParCol));  
- if ParSwarm(row,2*ParCol+1)>AdaptFunc(OptSwarm(row,1:ParCol))  
-        OptSwarm(row,1:ParCol)=ParSwarm(row,1:ParCol);  
-    end  
- end  
- %for循环结束  
- %确定邻域的范围  
- linyurange=fix(ParRow/2);  
- %确定当前迭代的邻域范围  
- jiange=ceil(LoopCount/linyurange);  
- linyu=ceil(CurCount/jiange);  
- for row=1:ParRow  
- if row-linyu>0&&row+linyu<=ParRow  
-             tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];  
- 
-             [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                 OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-             end  
- else
- if row-linyu<=0  
-                 %该行上面的部分突出了边界，下面绝对不会突破边界  
- if row==1  
-                     tempM=[ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
- else
-                     tempM=[ParSwarm(1:row-1,:);ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
-                 end  
- else
-                 %该行下面的部分突出了边界，上面绝对不会突破边界  
- if row==ParRow  
-                     tempM=[ParSwarm(ParRow-linyu:row-1,:);ParSwarm(1:linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
- else
-                     tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(ParRow-row),:)];    
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
-                 end  
-             end  
-         end  
-     end%for
-     %寻找适应度函数值最大的解在矩阵中的位置(行数)，进行全局最优的改变   
- [maxValue,row]=max(ParSwarm(:,2*ParCol+1));  
- if AdaptFunc(ParSwarm(row,1:ParCol))>AdaptFunc(OptSwarm(ParRow*2+1,:))  
-     OptSwarm(ParRow*2+1,:)=ParSwarm(row,1:ParCol);  
- end  
- 
function [ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
% 功能描述：局部版本：采用环形邻域的方法。基本的粒子群算法的单步更新位置,速度的算法
%
%[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
%
% 输入参数：ParSwarm:粒子群矩阵，包含粒子的位置，速度与当前的目标函数值
%输入参数：OptSwarm：包含粒子群个体最优解与全局最优解的矩阵
%输入参数：ParticleScope:一个粒子在运算中各维的范围；
% 输入参数：AdaptFunc：适应度函数
%输入参数：LoopCount：迭代的总次数
%输入参数：CurCount：当前迭代的次数
%
% 返回值：含意同输入的同名参数
%
%用法：[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
%
% 异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。
%
%编制人：XXX
%编制时间：2010.5.6
%参考文献：XXX
%参考文献：XXX
%
%修改记录
%----------------------------------------------------------------
%2010.5.6
%修改人：XXX
% 添加2*unifrnd(0,1).*SubTract1(row,:)中的unifrnd(0,1)随机数，使性能大为提高
%参照基于MATLAB的粒子群优化算法程序设计
%
% 总体评价：使用这个版本的调节系数，效果比较好
%
%容错控制
if nargin~=8
    error('输入的参数个数错误。')
end
if nargout~=2
    error('输出的个数太少，不能保证循环迭代。')
end
%开始单步更新的操作
%*********************************************
%***** 更改下面的代码，可以更改惯性因子的变化*****
%---------------------------------------------------------------------
% 线形递减策略
w=MaxW-CurCount*((MaxW-MinW)/LoopCount);
%---------------------------------------------------------------------
%w 固定不变策略
%w=0.7;
%---------------------------------------------------------------------
% 参考文献：陈贵敏，贾建援，韩琪，粒子群优化算法的惯性权值递减策略研究，西安交通大学学报，2006，1
%w 非线形递减，以凹函数递减
%w=(MaxW-MinW)*(CurCount/LoopCount)^2+(MinW-MaxW)*(2*CurCount/LoopCount)+MaxW;
%---------------------------------------------------------------------
%w 非线形递减，以凹函数递减
%w=MinW*(MaxW/MinW)^(1/(1+10*CurCount/LoopCount));
%*****更改上面的代码，可以更改惯性因子的变化*****
%*********************************************
% 得到粒子群群体大小以及一个粒子维数的信息
[ParRow,ParCol]=size(ParSwarm);
%得到粒子的维数
ParCol=(ParCol-1)/2;
SubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置
SubTract2=OptSwarm(ParRow+1:end-1,:)-ParSwarm(:,1:ParCol);
%*********************************************
%***** 更改下面的代码，可以更改c1,c2的变化*****
c1=2.05;
c2=2.05;
%---------------------------------------------------------------------
%con=1;
%c1=4-exp(-con*abs(mean(ParSwarm(:,2*ParCol+1))-AdaptFunc(OptSwarm(ParRow+1,:))));
%c2=4-c1;
%----------------------------------------------------------------------
%***** 更改上面的代码，可以更改c1,c2的变化*****
%*********************************************
for row=1:ParRow   
   TempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*SubTract1(row,:)+c2*unifrnd(0,1).*SubTract2(row,:);
   %限制速度的代码
   for h=1:ParCol
       if TempV(:,h)>ParticleScope(h,2)/2.0
           TempV(:,h)=ParticleScope(h,2)/2.0;
       end
       if TempV(:,h)<-ParticleScope(h,2)/2.0
           TempV(:,h)=(-ParticleScope(h,2)+1e-10)/2.0;
           %加1e-10防止适应度函数被零除
       end
   end  
   
   % 更新速度
   ParSwarm(row,ParCol+1:2*ParCol)=TempV;
   
   %*********************************************
   %***** 更改下面的代码，可以更改约束因子的变化*****
   %---------------------------------------------------------------------
   %a=1;
   %---------------------------------------------------------------------
   a=0.729;
   %***** 更改上面的代码，可以更改约束因子的变化*****
   %*********************************************
   
   % 限制位置的范围
   TempPos=ParSwarm(row,1:ParCol)+a*TempV;
   for h=1:ParCol
       if TempPos(:,h)>ParticleScope(h,2)
           TempPos(:,h)=ParticleScope(h,2);
       end
       if TempPos(:,h)<=ParticleScope(h,1)
           TempPos(:,h)=ParticleScope(h,1)+1e-10;           
       end
   end
   %更新位置 
   ParSwarm(row,1:ParCol)=TempPos;
   
   % 计算每个粒子的新的适应度值
   ParSwarm(row,2*ParCol+1)=AdaptFunc(ParSwarm(row,1:ParCol));
   if ParSwarm(row,2*ParCol+1)>AdaptFunc(OptSwarm(row,1:ParCol))
       OptSwarm(row,1:ParCol)=ParSwarm(row,1:ParCol);
   end
end
%for循环结束
%确定邻域的范围
linyurange=fix(ParRow/2);
%确定当前迭代的邻域范围
jiange=ceil(LoopCount/linyurange);
linyu=ceil(CurCount/jiange);
    for row=1:ParRow
        if row-linyu>0&&row+linyu<=ParRow
            tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];
            
            [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
            if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
            end
        else
            if row-linyu<=0
                %该行上面的部分突出了边界，下面绝对不会突破边界
                if row==1
                    tempM=[ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                else
                    tempM=[ParSwarm(1:row-1,:);ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                end
            else
                %该行下面的部分突出了边界，上面绝对不会突破边界
                if row==ParRow
                    tempM=[ParSwarm(ParRow-linyu:row-1,:);ParSwarm(1:linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                else
                    tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(ParRow-row),:)];  
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                end
            end
        end
    end%for
    %寻找适应度函数值最大的解在矩阵中的位置(行数)，进行全局最优的改变 
[maxValue,row]=max(ParSwarm(:,2*ParCol+1));
if AdaptFunc(ParSwarm(row,1:ParCol))>AdaptFunc(OptSwarm(ParRow*2+1,:))
    OptSwarm(ParRow*2+1,:)=ParSwarm(row,1:ParCol);
end
  
这两个函数给出以后，需要一个函数来把这两个函数组装起来，以此实现一个完整的粒子群算法，这个函数就是LocalPsoProcessByCircle
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5601882#)[copy](https://blog.csdn.net/niuyongjie/article/details/5601882#)[print](https://blog.csdn.net/niuyongjie/article/details/5601882#)[?](https://blog.csdn.net/niuyongjie/article/details/5601882#)
- function [Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot)  
- % 功能描述：一个循环n次的局部PSO算法完整过程，返回这次运行的最小与最大的平均适应度,以及在线性能与离线性能  
- %[Result,OnLine,OffLine,MinMaxMeanAdapt]=PsoProcess(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot)  
- % 输入参数：SwarmSize:种群大小的个数  
- %输入参数：ParticleSize：一个粒子的维数  
- %输入参数：ParticleScope:一个粒子在运算中各维的范围；  
- %         ParticleScope格式:  
- %           3维粒子的ParticleScope格式:  
- %                                   [x1Min,x1Max  
- %                                    x2Min,x2Max  
- %                                    x3Min,x3Max]  
- %  
- % 输入参数:InitFunc:初始化粒子群函数  
- %输入参数:StepFindFunc:单步更新速度，位置函数  
- %输入参数：AdaptFunc：适应度函数  
- %输入参数：IsStep：是否每次迭代暂停；IsStep＝0，不暂停，否则暂停。缺省不暂停  
- %输入参数：IsDraw：是否图形化迭代过程；IsDraw＝0，不图形化迭代过程，否则，图形化表示。缺省不图形化表示  
- %输入参数：LoopCount：迭代的次数；缺省迭代100次  
- %输入参数：IsPlot：控制是否绘制在线性能与离线性能的图形表示；IsPlot=0,不显示；  
- %                 IsPlot=1；显示图形结果。缺省IsPlot=1  
- %  
- %返回值：BestofStep:每次迭代，全局最优值.  
- % 返回值：Result为经过迭代后得到的最优解  
- %返回值：OnLine为在线性能的数据  
- %返回值：OffLine为离线性能的数据  
- % 返回值：MinMaxMeanAdapt为本次完整迭代得到的最小与最大的平均适应度  
- %  
- %用法[Result,OnLine,OffLine,MinMaxMeanAdapt]=PsoProcess(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot);  
- %  
- %异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。  
- %  
- %编制人：XXX  
- % 编制时间：2007.3.26  
- %参考文献：XXXXX%  
- 
- %修改记录：  
- %添加MinMaxMeanAdapt，以得到性能评估数据  
- %修改人：XXX  
- %修改时间：2007.3.27  
- %参考文献：XXX.  
- 
- %容错控制  
- if nargin<4  
-     error(' 输入的参数个数错误。')  
- end  
- 
- [row,colum]=size(ParticleSize);  
- if row>1||colum>1  
-     error('输入的粒子的维数错误，是一个1行1列的数据。');  
- end  
- [row,colum]=size(ParticleScope);  
- if row~=ParticleSize||colum~=2  
-     error('输入的粒子的维数范围错误。 ');  
- end  
- 
- %设置缺省值  
- if nargin<7  
-     IsPlot=1;  
-     LoopCount=100;  
-     IsStep=0;  
-     IsDraw=0;  
- end  
- if nargin<8  
-     IsPlot=1;  
-     IsDraw=0;  
-     LoopCount=100;  
- end  
- if nargin<9  
-     LoopCount=100;  
-     IsPlot=1;  
- end  
- if nargin<10  
-     IsPlot=1;  
- end  
- 
- %控制是否显示2维以下粒子维数的寻找最优的过程  
- if IsDraw~=0   
-     figure  
-     clf  
-     DrawObjGraphic(ParticleSize,ParticleScope,AdaptFunc);  
-     view(0,90);  
- end  
- 
- %初始化种群         
- [ParSwarm,OptSwarm]=InitFunc(SwarmSize,ParticleSize,ParticleScope,AdaptFunc);  
- 
- % 在测试函数图形上绘制初始化群的位置  
- if IsDraw~=0  
- if 1==ParticleSize  
- for ParSwarmRow=1:SwarmSize  
-             plot([ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,1)],[ParSwarm(ParSwarmRow,3),0],'r*-','markersize',8);  
-             text(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,3),num2str(ParSwarmRow));  
-         end  
-     end  
- 
- if 2==ParticleSize  
- for ParSwarmRow=1:SwarmSize  
-             hold on  
-             stem3(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,2),ParSwarm(ParSwarmRow,5),'white*','markersize',8);  
-         end           
-     end  
- end  
- 
- %暂停让抓图  
- if IsStep~=0  
-     disp(' 开始迭代，按任意键：')  
-     pause  
- end  
- 
- %开始更新算法的调用  
- for k=1:LoopCount  
-     %显示迭代的次数：  
-     disp('----------------------------------------------------------')  
-     TempStr=sprintf(' 第 %g 次迭代',k);  
-     disp(TempStr);  
-     disp('----------------------------------------------------------')  
- 
-     % 调用一步迭代的算法  
-     [ParSwarm,OptSwarm]=StepFindFunc(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,0.95,0.4,LoopCount,k);  
- 
-     % 在目标函数的图形上绘制2维以下的粒子的新位置  
- if IsDraw~=0  
- if 1==ParticleSize  
- for ParSwarmRow=1:SwarmSize  
-                 plot([ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,1)],[ParSwarm(ParSwarmRow,3),0],'r*-','markersize',8);  
-                 text(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,3),num2str(ParSwarmRow));  
-             end  
-         end  
- 
- if 2==ParticleSize  
- for ParSwarmRow=1:SwarmSize  
-                 stem3(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,2),ParSwarm(ParSwarmRow,5),'white.','markersize',8);  
-             end  
-         end  
-     end  
- 
-     XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);  
-     YResult=AdaptFunc(XResult);      
- if IsStep~=0  
-         XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);  
-         YResult=AdaptFunc(XResult);      
-         str=sprintf('%g步迭代的最优目标函数值%g',k,YResult);  
-         disp(str);  
-         disp(' 下次迭代，按任意键继续');  
-         pause  
-     end  
- 
-     %记录每一步的平均适应度  
-     MeanAdapt(1,k)=mean(ParSwarm(:,2*ParticleSize+1));  
-     BestofStep(1,k)=YResult;  
- end  
- %for循环结束标志  
- 
- %记录最小与最大的平均适应度  
- MinMaxMeanAdapt=[min(MeanAdapt),max(MeanAdapt)];  
- % 计算离线与在线性能  
- for k=1:LoopCount  
-     OnLine(1,k)=sum(MeanAdapt(1,1:k))/k;  
-     OffLine(1,k)=max(MeanAdapt(1,1:k));  
- end  
- 
- for k=1:LoopCount  
-     OffLine(1,k)=sum(OffLine(1,1:k))/k;  
- end  
- 
- %绘制离线性能与在线性能曲线  
- if 1==IsPlot  
-     figure  
-     hold on  
-     title('离线性能曲线图')  
-     xlabel(' 迭代次数');  
-     ylabel('离线性能');  
-     grid on  
-     plot(OffLine);  
- 
-     figure  
-     hold on  
-     title(' 在线性能曲线图')  
-     xlabel('迭代次数');  
-     ylabel('在线性能');  
-     grid on  
-     plot(OnLine);  
- end  
- 
- %记录本次迭代得到的最优结果  
- XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);  
- YResult=AdaptFunc(XResult);  
- Result=[XResult,YResult];  
function [Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot)
% 功能描述：一个循环n次的局部PSO算法完整过程，返回这次运行的最小与最大的平均适应度,以及在线性能与离线性能
%[Result,OnLine,OffLine,MinMaxMeanAdapt]=PsoProcess(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot)
% 输入参数：SwarmSize:种群大小的个数
%输入参数：ParticleSize：一个粒子的维数
%输入参数：ParticleScope:一个粒子在运算中各维的范围；
%         ParticleScope格式:
%           3维粒子的ParticleScope格式:
%                                   [x1Min,x1Max
%                                    x2Min,x2Max
%                                    x3Min,x3Max]
%
% 输入参数:InitFunc:初始化粒子群函数
%输入参数:StepFindFunc:单步更新速度，位置函数
%输入参数：AdaptFunc：适应度函数
%输入参数：IsStep：是否每次迭代暂停；IsStep＝0，不暂停，否则暂停。缺省不暂停
%输入参数：IsDraw：是否图形化迭代过程；IsDraw＝0，不图形化迭代过程，否则，图形化表示。缺省不图形化表示
%输入参数：LoopCount：迭代的次数；缺省迭代100次
%输入参数：IsPlot：控制是否绘制在线性能与离线性能的图形表示；IsPlot=0,不显示；
%                 IsPlot=1；显示图形结果。缺省IsPlot=1
%
%返回值：BestofStep:每次迭代，全局最优值.
% 返回值：Result为经过迭代后得到的最优解
%返回值：OnLine为在线性能的数据
%返回值：OffLine为离线性能的数据
% 返回值：MinMaxMeanAdapt为本次完整迭代得到的最小与最大的平均适应度
%
%用法[Result,OnLine,OffLine,MinMaxMeanAdapt]=PsoProcess(SwarmSize,ParticleSize,ParticleScope,InitFunc,StepFindFunc,AdaptFunc,IsStep,IsDraw,LoopCount,IsPlot);
%
%异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。
%
%编制人：XXX
% 编制时间：2007.3.26
%参考文献：XXXXX%
%修改记录：
%添加MinMaxMeanAdapt，以得到性能评估数据
%修改人：XXX
%修改时间：2007.3.27
%参考文献：XXX.
%容错控制
if nargin<4
    error(' 输入的参数个数错误。')
end
[row,colum]=size(ParticleSize);
if row>1||colum>1
    error('输入的粒子的维数错误，是一个1行1列的数据。');
end
[row,colum]=size(ParticleScope);
if row~=ParticleSize||colum~=2
    error('输入的粒子的维数范围错误。 ');
end
%设置缺省值
if nargin<7
    IsPlot=1;
    LoopCount=100;
    IsStep=0;
    IsDraw=0;
end
if nargin<8
    IsPlot=1;
    IsDraw=0;
    LoopCount=100;
end
if nargin<9
    LoopCount=100;
    IsPlot=1;
end
if nargin<10
    IsPlot=1;
end
%控制是否显示2维以下粒子维数的寻找最优的过程
if IsDraw~=0 
    figure
    clf
    DrawObjGraphic(ParticleSize,ParticleScope,AdaptFunc);
    view(0,90);
end
%初始化种群       
[ParSwarm,OptSwarm]=InitFunc(SwarmSize,ParticleSize,ParticleScope,AdaptFunc);
% 在测试函数图形上绘制初始化群的位置
if IsDraw~=0
    if 1==ParticleSize
        for ParSwarmRow=1:SwarmSize
            plot([ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,1)],[ParSwarm(ParSwarmRow,3),0],'r*-','markersize',8);
            text(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,3),num2str(ParSwarmRow));
        end
    end
    if 2==ParticleSize
        for ParSwarmRow=1:SwarmSize
            hold on
            stem3(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,2),ParSwarm(ParSwarmRow,5),'white*','markersize',8);
        end         
    end
end
    
%暂停让抓图
if IsStep~=0
    disp(' 开始迭代，按任意键：')
    pause
end
%开始更新算法的调用
for k=1:LoopCount
    %显示迭代的次数：
    disp('----------------------------------------------------------')
    TempStr=sprintf(' 第 %g 次迭代',k);
    disp(TempStr);
    disp('----------------------------------------------------------')
    
    % 调用一步迭代的算法
    [ParSwarm,OptSwarm]=StepFindFunc(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,0.95,0.4,LoopCount,k);
    
    % 在目标函数的图形上绘制2维以下的粒子的新位置
    if IsDraw~=0
        if 1==ParticleSize
            for ParSwarmRow=1:SwarmSize
                plot([ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,1)],[ParSwarm(ParSwarmRow,3),0],'r*-','markersize',8);
                text(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,3),num2str(ParSwarmRow));
            end
        end
        if 2==ParticleSize
            for ParSwarmRow=1:SwarmSize
                stem3(ParSwarm(ParSwarmRow,1),ParSwarm(ParSwarmRow,2),ParSwarm(ParSwarmRow,5),'white.','markersize',8);
            end
        end
    end
    
    XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);
    YResult=AdaptFunc(XResult);    
    if IsStep~=0
        XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);
        YResult=AdaptFunc(XResult);    
        str=sprintf('%g步迭代的最优目标函数值%g',k,YResult);
        disp(str);
        disp(' 下次迭代，按任意键继续');
        pause
    end
    
    %记录每一步的平均适应度
    MeanAdapt(1,k)=mean(ParSwarm(:,2*ParticleSize+1));
    BestofStep(1,k)=YResult;
end
%for循环结束标志
%记录最小与最大的平均适应度
MinMaxMeanAdapt=[min(MeanAdapt),max(MeanAdapt)];
% 计算离线与在线性能
for k=1:LoopCount
    OnLine(1,k)=sum(MeanAdapt(1,1:k))/k;
    OffLine(1,k)=max(MeanAdapt(1,1:k));
end
for k=1:LoopCount
    OffLine(1,k)=sum(OffLine(1,1:k))/k;
end
%绘制离线性能与在线性能曲线
if 1==IsPlot
    figure
    hold on
    title('离线性能曲线图')
    xlabel(' 迭代次数');
    ylabel('离线性能');
    grid on
    plot(OffLine);
    figure
    hold on
    title(' 在线性能曲线图')
    xlabel('迭代次数');
    ylabel('在线性能');
    grid on
    plot(OnLine);
end
%记录本次迭代得到的最优结果
XResult=OptSwarm(SwarmSize*2+1,1:ParticleSize);
YResult=AdaptFunc(XResult);
Result=[XResult,YResult];
这里给出一个使用的例子代码，并分别解释各参数的含义：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5601882#)[copy](https://blog.csdn.net/niuyongjie/article/details/5601882#)[print](https://blog.csdn.net/niuyongjie/article/details/5601882#)[?](https://blog.csdn.net/niuyongjie/article/details/5601882#)
- Scope=[-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10];//粒子的维数限制范围
- qun=20;//粒子群种群规模
- lizi=10;//粒子的维数
- [Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(qun,lizi,Scope,@localinitswarm,@localsteppsobycircle,@Rastrigin,0,0,1000,0);  
Scope=[-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10];//粒子的维数限制范围
qun=20;//粒子群种群规模
lizi=10;//粒子的维数
[Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(qun,lizi,Scope,@localinitswarm,@localsteppsobycircle,@Rastrigin,0,0,1000,0);
在上面的代码中函数LocalPsoProcessByCircle中的qun代表粒子群的规模为20个，lizi代表每个粒子的维数为10，Scope是粒子的每一维的范围，同时也是速度的范围的二倍，@localinitswarm是初始化函数的句柄，@localsteppsobycircle是单步更新的函数句柄，@Rastrigin是适应度评价函数的句柄，1000代表真个算法循环1000次终止，其他参数参见说明文档。
### 混合粒子群算法
混合粒子群算法将全局粒子群算法与局部粒子群算法结合，其速度更新采用公式
![](http://hi.csdn.net/attachment/201005/17/0_1274106466sS27.gif)
其中G（k+1）是全局版本的速度更新公式，而L（k+1）是局部版本的速度更新公式，混合粒子群算法采用H（k+1）的公式。
位置更新公式
![](http://hi.csdn.net/attachment/201005/17/0_1274106596NbRb.gif)
因为是局部版本与全局版本相结合，所以，粒子群的初始化函数应该与局部版本的相同，这里就不列出了，参看粒子群算法(7）中的LocalInitSwarm函数。
关键还是混合粒子群算法的单步更新函数，函数名为HybridStepPso
代码如下：
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5602104#)[copy](https://blog.csdn.net/niuyongjie/article/details/5602104#)[print](https://blog.csdn.net/niuyongjie/article/details/5602104#)[?](https://blog.csdn.net/niuyongjie/article/details/5602104#)
- function [ParSwarm,OptSwarm]=HybridStepPso(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- % 功能描述：混合粒子群算法。将全局版本与局部版本相混合。基本的粒子群算法的单步更新位置,速度的算法  
- %  
- %[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- %  
- %算法思想：全局版本的速度更新公式：vq(k+1)=w*v(k)+c1*r1*(pg-w)+c2*r2*(pq-w)  
- %pg为个体历史最优，pq为全局最优  
- %局部版本的速度更新公式：vl(k+1)=w*v(k)+c1*r1*(pg-w)+c2*r2*(pl-w) pl为邻域最优  
- %现在速度更新公式vh=n*vq+(1-n)*vl;n属于0到1的一个数  
- % 输入参数：ParSwarm:粒子群矩阵，包含粒子的位置，速度与当前的目标函数值  
- %输入参数：OptSwarm：包含粒子群个体最优解与全局最优解的矩阵  
- %输入参数：ParticleScope:一个粒子在运算中各维的范围；  
- % 输入参数：AdaptFunc：适应度函数  
- %输入参数：LoopCount：迭代的总次数  
- %输入参数：CurCount：当前迭代的次数  
- %  
- % 返回值：含意同输入的同名参数  
- %  
- %用法：[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)  
- %  
- % 异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。  
- %  
- %编制人：XXX  
- %编制时间：2010.5.6  
- %参考文献：XXX  
- %参考文献：XXX  
- %  
- %修改记录  
- %----------------------------------------------------------------  
- %2010.5.6  
- %修改人：XXX  
- % 添加2*unifrnd(0,1).*SubTract1(row,:)中的unifrnd(0,1)随机数，使性能大为提高  
- %修改混合因子，从小到大，开始从CurCount/LoopCount开始  
- %修改C1=2.05,C2=2.05  
- %修改速度的范围时区间每维范围的0.5(一半)  
- %参照基于MATLAB的粒子群优化算法程序设计  
- %  
- % 总体评价：使用这个版本的调节系数，效果比较好  
- %  
- 
- %容错控制  
- if nargin~=8  
-     error('输入的参数个数错误。')  
- end  
- if nargout~=2  
-     error('输出的个数太少，不能保证循环迭代。')  
- end  
- 
- %开始单步更新的操作  
- 
- %*********************************************  
- %***** 更改下面的代码，可以更改惯性因子的变化*****  
- %---------------------------------------------------------------------  
- % 线形递减策略  
- w=MaxW-CurCount*((MaxW-MinW)/LoopCount);  
- %---------------------------------------------------------------------  
- %w 固定不变策略  
- %w=0.7;  
- %---------------------------------------------------------------------  
- % 参考文献：陈贵敏，贾建援，韩琪，粒子群优化算法的惯性权值递减策略研究，西安交通大学学报，2006，1  
- %w 非线形递减，以凹函数递减  
- %w=(MaxW-MinW)*(CurCount/LoopCount)^2+(MinW-MaxW)*(2*CurCount/LoopCount)+MaxW;  
- %---------------------------------------------------------------------  
- %w 非线形递减，以凹函数递减  
- %w=MinW*(MaxW/MinW)^(1/(1+10*CurCount/LoopCount));  
- %*****更改上面的代码，可以更改惯性因子的变化*****  
- %*********************************************  
- %更改下面代码可以改变混合因子的取值  
- %-----------------------------------------------  
- Hybrid=CurCount/LoopCount;  
- %-----------------------------------------------  
- 
- % 得到粒子群群体大小以及一个粒子维数的信息  
- [ParRow,ParCol]=size(ParSwarm);  
- 
- %得到粒子的维数  
- ParCol=(ParCol-1)/2;  
- GlobleSubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置  
- LocalSubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置  
- LocalSubTract2=OptSwarm(ParRow+1:end-1,:)-ParSwarm(:,1:ParCol);%粒子邻域最优解位置减去粒子当前位置  
- %*********************************************  
- %***** 更改下面的代码，可以更改c1,c2的变化*****  
- c1=2.05;  
- c2=2.05;  
- %---------------------------------------------------------------------  
- %con=1;  
- %c1=4-exp(-con*abs(mean(ParSwarm(:,2*ParCol+1))-AdaptFunc(OptSwarm(ParRow+1,:))));  
- %c2=4-c1;  
- %----------------------------------------------------------------------  
- %***** 更改上面的代码，可以更改c1,c2的变化*****  
- %*********************************************  
- for row=1:ParRow   
-        GlobleSubTract2=OptSwarm(ParRow*2+1,:)-ParSwarm(row,1:ParCol);%全局最优的位置减去每个粒子当前的位置     
-        LocalTempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*LocalSubTract1(row,:)+c2*unifrnd(0,1).*LocalSubTract2(row,:);  
-        GlobleTempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*GlobleSubTract1(row,:)+c2*unifrnd(0,1).*GlobleSubTract2;  
-        TempV=Hybrid.*GlobleTempV+(1-Hybrid).*LocalTempV;  
-    %限制速度的代码  
- for h=1:ParCol  
- if TempV(:,h)>ParticleScope(h,2)/2.0  
-            TempV(:,h)=ParticleScope(h,2)/2.0;  
-        end  
- if TempV(:,h)<-ParticleScope(h,2)/2.0  
-            TempV(:,h)=(-ParticleScope(h,2)+1e-10)/2.0;  
-            %加1e-10防止适应度函数被零除  
-        end  
-    end    
- 
-    % 更新速度  
-    ParSwarm(row,ParCol+1:2*ParCol)=TempV;  
- 
-    %*********************************************  
-    %***** 更改下面的代码，可以更改约束因子的变化*****  
-    %---------------------------------------------------------------------  
-    %a=1;  
-    %---------------------------------------------------------------------  
-    a=0.729;  
-    %***** 更改上面的代码，可以更改约束因子的变化*****  
-    %*********************************************  
- 
-    % 限制位置的范围  
-    TempPos=ParSwarm(row,1:ParCol)+a*TempV;  
- for h=1:ParCol  
- if TempPos(:,h)>ParticleScope(h,2)  
-            TempPos(:,h)=ParticleScope(h,2);  
-        end  
- if TempPos(:,h)<=ParticleScope(h,1)  
-            TempPos(:,h)=ParticleScope(h,1)+1e-10;             
-        end  
-    end  
- 
-    %更新位置   
-    ParSwarm(row,1:ParCol)=TempPos;  
- 
-    % 计算每个粒子的新的适应度值  
-    ParSwarm(row,2*ParCol+1)=AdaptFunc(ParSwarm(row,1:ParCol));  
- if ParSwarm(row,2*ParCol+1)>AdaptFunc(OptSwarm(row,1:ParCol))  
-        OptSwarm(row,1:ParCol)=ParSwarm(row,1:ParCol);  
-    end  
- end  
- %for循环结束  
- %确定邻域的范围  
- linyurange=fix(ParRow/2);  
- %确定当前迭代的邻域范围  
- jiange=ceil(LoopCount/linyurange);  
- linyu=ceil(CurCount/jiange);  
- for row=1:ParRow  
- if row-linyu>0&&row+linyu<=ParRow  
-             tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];  
- 
-             [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                 OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-             end  
- else
- if row-linyu<=0  
-                 %该行上面的部分突出了边界，下面绝对不会突破边界  
- if row==1  
-                     tempM=[ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
- else
-                     tempM=[ParSwarm(1:row-1,:);ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
-                 end  
- else
-                 %该行下面的部分突出了边界，上面绝对不会突破边界  
- if row==ParRow  
-                     tempM=[ParSwarm(ParRow-linyu:row-1,:);ParSwarm(1:linyu,:)];  
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
- else
-                     tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(ParRow-row),:)];    
-                     [maxValue,linyurow]=max(tempM(:,2*ParCol+1));  
- if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))  
-                         OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);  
-                      end  
-                 end  
-             end  
-         end  
-     end%for
-     %寻找适应度函数值最大的解在矩阵中的位置(行数)，进行全局最优的改变   
- [maxValue,row]=max(ParSwarm(:,2*ParCol+1));  
- if AdaptFunc(ParSwarm(row,1:ParCol))>AdaptFunc(OptSwarm(ParRow*2+1,:))  
-     OptSwarm(ParRow*2+1,:)=ParSwarm(row,1:ParCol);  
- end  
- 
function [ParSwarm,OptSwarm]=HybridStepPso(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
% 功能描述：混合粒子群算法。将全局版本与局部版本相混合。基本的粒子群算法的单步更新位置,速度的算法
%
%[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
%
%算法思想：全局版本的速度更新公式：vq(k+1)=w*v(k)+c1*r1*(pg-w)+c2*r2*(pq-w)
%pg为个体历史最优，pq为全局最优
%局部版本的速度更新公式：vl(k+1)=w*v(k)+c1*r1*(pg-w)+c2*r2*(pl-w) pl为邻域最优
%现在速度更新公式vh=n*vq+(1-n)*vl;n属于0到1的一个数
% 输入参数：ParSwarm:粒子群矩阵，包含粒子的位置，速度与当前的目标函数值
%输入参数：OptSwarm：包含粒子群个体最优解与全局最优解的矩阵
%输入参数：ParticleScope:一个粒子在运算中各维的范围；
% 输入参数：AdaptFunc：适应度函数
%输入参数：LoopCount：迭代的总次数
%输入参数：CurCount：当前迭代的次数
%
% 返回值：含意同输入的同名参数
%
%用法：[ParSwarm,OptSwarm]=LocalStepPsoByCircle(ParSwarm,OptSwarm,AdaptFunc,ParticleScope,MaxW,MinW,LoopCount,CurCount)
%
% 异常：首先保证该文件在Matlab的搜索路径中，然后查看相关的提示信息。
%
%编制人：XXX
%编制时间：2010.5.6
%参考文献：XXX
%参考文献：XXX
%
%修改记录
%----------------------------------------------------------------
%2010.5.6
%修改人：XXX
% 添加2*unifrnd(0,1).*SubTract1(row,:)中的unifrnd(0,1)随机数，使性能大为提高
%修改混合因子，从小到大，开始从CurCount/LoopCount开始
%修改C1=2.05,C2=2.05
%修改速度的范围时区间每维范围的0.5(一半)
%参照基于MATLAB的粒子群优化算法程序设计
%
% 总体评价：使用这个版本的调节系数，效果比较好
%
%容错控制
if nargin~=8
    error('输入的参数个数错误。')
end
if nargout~=2
    error('输出的个数太少，不能保证循环迭代。')
end
%开始单步更新的操作
%*********************************************
%***** 更改下面的代码，可以更改惯性因子的变化*****
%---------------------------------------------------------------------
% 线形递减策略
w=MaxW-CurCount*((MaxW-MinW)/LoopCount);
%---------------------------------------------------------------------
%w 固定不变策略
%w=0.7;
%---------------------------------------------------------------------
% 参考文献：陈贵敏，贾建援，韩琪，粒子群优化算法的惯性权值递减策略研究，西安交通大学学报，2006，1
%w 非线形递减，以凹函数递减
%w=(MaxW-MinW)*(CurCount/LoopCount)^2+(MinW-MaxW)*(2*CurCount/LoopCount)+MaxW;
%---------------------------------------------------------------------
%w 非线形递减，以凹函数递减
%w=MinW*(MaxW/MinW)^(1/(1+10*CurCount/LoopCount));
%*****更改上面的代码，可以更改惯性因子的变化*****
%*********************************************
%更改下面代码可以改变混合因子的取值
%-----------------------------------------------
Hybrid=CurCount/LoopCount;
%-----------------------------------------------
% 得到粒子群群体大小以及一个粒子维数的信息
[ParRow,ParCol]=size(ParSwarm);
%得到粒子的维数
ParCol=(ParCol-1)/2;
GlobleSubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置
LocalSubTract1=OptSwarm(1:ParRow,:)-ParSwarm(:,1:ParCol);%粒子自身历史最优解位置减去粒子当前位置
LocalSubTract2=OptSwarm(ParRow+1:end-1,:)-ParSwarm(:,1:ParCol);%粒子邻域最优解位置减去粒子当前位置
%*********************************************
%***** 更改下面的代码，可以更改c1,c2的变化*****
c1=2.05;
c2=2.05;
%---------------------------------------------------------------------
%con=1;
%c1=4-exp(-con*abs(mean(ParSwarm(:,2*ParCol+1))-AdaptFunc(OptSwarm(ParRow+1,:))));
%c2=4-c1;
%----------------------------------------------------------------------
%***** 更改上面的代码，可以更改c1,c2的变化*****
%*********************************************
for row=1:ParRow 
       GlobleSubTract2=OptSwarm(ParRow*2+1,:)-ParSwarm(row,1:ParCol);%全局最优的位置减去每个粒子当前的位置   
       LocalTempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*LocalSubTract1(row,:)+c2*unifrnd(0,1).*LocalSubTract2(row,:);
       GlobleTempV=w.*ParSwarm(row,ParCol+1:2*ParCol)+c1*unifrnd(0,1).*GlobleSubTract1(row,:)+c2*unifrnd(0,1).*GlobleSubTract2;
       TempV=Hybrid.*GlobleTempV+(1-Hybrid).*LocalTempV;
   %限制速度的代码
   for h=1:ParCol
       if TempV(:,h)>ParticleScope(h,2)/2.0
           TempV(:,h)=ParticleScope(h,2)/2.0;
       end
       if TempV(:,h)<-ParticleScope(h,2)/2.0
           TempV(:,h)=(-ParticleScope(h,2)+1e-10)/2.0;
           %加1e-10防止适应度函数被零除
       end
   end  
   
   % 更新速度
   ParSwarm(row,ParCol+1:2*ParCol)=TempV;
   
   %*********************************************
   %***** 更改下面的代码，可以更改约束因子的变化*****
   %---------------------------------------------------------------------
   %a=1;
   %---------------------------------------------------------------------
   a=0.729;
   %***** 更改上面的代码，可以更改约束因子的变化*****
   %*********************************************
   
   % 限制位置的范围
   TempPos=ParSwarm(row,1:ParCol)+a*TempV;
   for h=1:ParCol
       if TempPos(:,h)>ParticleScope(h,2)
           TempPos(:,h)=ParticleScope(h,2);
       end
       if TempPos(:,h)<=ParticleScope(h,1)
           TempPos(:,h)=ParticleScope(h,1)+1e-10;           
       end
   end
   %更新位置 
   ParSwarm(row,1:ParCol)=TempPos;
   
   % 计算每个粒子的新的适应度值
   ParSwarm(row,2*ParCol+1)=AdaptFunc(ParSwarm(row,1:ParCol));
   if ParSwarm(row,2*ParCol+1)>AdaptFunc(OptSwarm(row,1:ParCol))
       OptSwarm(row,1:ParCol)=ParSwarm(row,1:ParCol);
   end
end
%for循环结束
%确定邻域的范围
linyurange=fix(ParRow/2);
%确定当前迭代的邻域范围
jiange=ceil(LoopCount/linyurange);
linyu=ceil(CurCount/jiange);
    for row=1:ParRow
        if row-linyu>0&&row+linyu<=ParRow
            tempM =[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:row+linyu,:)];
            
            [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
            if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
            end
        else
            if row-linyu<=0
                %该行上面的部分突出了边界，下面绝对不会突破边界
                if row==1
                    tempM=[ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                else
                    tempM=[ParSwarm(1:row-1,:);ParSwarm(ParRow+row-linyu:end,:);ParSwarm(row+1:row+linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                end
            else
                %该行下面的部分突出了边界，上面绝对不会突破边界
                if row==ParRow
                    tempM=[ParSwarm(ParRow-linyu:row-1,:);ParSwarm(1:linyu,:)];
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                else
                    tempM=[ParSwarm(row-linyu:row-1,:);ParSwarm(row+1:end,:);ParSwarm(1:linyu-(ParRow-row),:)];  
                    [maxValue,linyurow]=max(tempM(:,2*ParCol+1));
                     if maxValue>AdaptFunc(OptSwarm(ParRow+row,:))
                        OptSwarm(ParRow+row,:)=tempM(linyurow,1:ParCol);
                     end
                end
            end
        end
    end%for
    %寻找适应度函数值最大的解在矩阵中的位置(行数)，进行全局最优的改变 
[maxValue,row]=max(ParSwarm(:,2*ParCol+1));
if AdaptFunc(ParSwarm(row,1:ParCol))>AdaptFunc(OptSwarm(ParRow*2+1,:))
    OptSwarm(ParRow*2+1,:)=ParSwarm(row,1:ParCol);
end
  
注意代码的91行到96行，这几行就是混合粒子群速度更新公式，其他部分基本与前面的实现一样。
最后还是一个把这两个函数组装在一起的函数，同样采用LocalPsoProcessByCircle函数，详细见粒子群算法(7）的内容，最后还是给出一个应用实例。
**[c-sharp]**[view plain](https://blog.csdn.net/niuyongjie/article/details/5602104#)[copy](https://blog.csdn.net/niuyongjie/article/details/5602104#)[print](https://blog.csdn.net/niuyongjie/article/details/5602104#)[?](https://blog.csdn.net/niuyongjie/article/details/5602104#)
- Scope=[-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10];//粒子每维的限制范围
- qun=20;//粒子群的规模
- lizi=10;//每个粒子的维数
- [Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(qun,lizi,Scope,@localinitswarm,@Hybridsteppso,@Rastrigin,0,0,1000,0);  
Scope=[-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10;-10 10];//粒子每维的限制范围
qun=20;//粒子群的规模
lizi=10;//每个粒子的维数
[Result,OnLine,OffLine,MinMaxMeanAdapt,BestofStep]=LocalPsoProcessByCircle(qun,lizi,Scope,@localinitswarm,@Hybridsteppso,@Rastrigin,0,0,1000,0);
注意：在这个LocalPsoProcessByCircle函数中，使用HybridStepPso作为单步更新的函数，其余基本与局部粒子群算法相同。
经过本人的实际测试，运行条件相同，最好的是局部版本的PSO，混合的PSO并不像有些文献上说的那么好，也许是我实现的不对，如果有那个大侠实现的效果更好，可以给我联系，我们可以共享代码。
同时也希望那些砖家、叫兽们共享你们的效果非常好的代码。
本人已经实现了一个PSO的工具箱，不过效果不好，本人水平低劣，又需要的可以联系我。
![](http://hi.csdn.net/attachment/201005/17/0_1274107955AAa8.gif)
不知道CSDN能不能做链接下载，如果可以，请告诉我，我做个链接，大家可以随便下载，共同交流。
自从上次博客密码泄露以后，很久没有上这个博客了，看到很多人留言索要粒子群算法工具箱的代码，我都没有回复，十分对不起，
http://download.csdn.net/download/niuyongjie/9442791
我把工具箱的代码上传到资源里面了，有需要的自己下载吧！
http://download.csdn.net/download/niuyongjie/9442791

