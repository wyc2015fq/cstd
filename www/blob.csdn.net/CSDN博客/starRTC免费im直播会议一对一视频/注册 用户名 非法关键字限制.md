# 注册  用户名 非法关键字限制 - starRTC免费im直播会议一对一视频 - CSDN博客
2017年05月11日 13:10:31[starRTC免费IM直播会议一对一视频](https://me.csdn.net/elesos)阅读数：3202
@#%）等等这类符号不行
**为什么用户注册时要屏蔽“用户信息保留关键字”？**
1、保护会员安全，防止有用户使用管理员的名义来骗取其他会员的钱财
2、仿制部分网友采用域名注册，恶意来宣传
discuz有这个功能，可以研究一下：
后台 → 全局 → 注册与访问控  → 注册 → 用户信息保留关键字
UCenter → 注册设置  → 禁止的用户名

wordpress
wp-includes/user.php
sanitize_user
屏蔽非法关键词用户名
教大家如何禁止wordpress网站用户在注册时使用敏感关键。
首先在functions.php文件中加入以下两段代码：
**function****ruikeedu_blacklist_check**($str){ $moderation_keys
 = trim(get_option('moderation_keys')); $blacklist_keys = trim(get_option('blacklist_keys'));
 $keys = $moderation_keys ."\n".$blacklist_keys; $words = explode("\n",
 $keys ); **foreach** ( (**array**)
 $words **as** $word) { $word = trim($word);
**if** (
**empty**($word) )
**continue**; $word = preg_quote($word,
'#'); $pattern =
"#$word#i";
**if** ( preg_match($pattern, $str) )
**return****true**; }
**return****false**;}add_filter(
'sanitize_user',
'ruikeedu_sanitize_user',3,3);**function****ruikeedu_sanitize_user**($username, $raw_username,
 $strict){ **if**(ruikeedu_blacklist_check($username)){
 $username = ''; }
**return** $username;}
然后在 WordPress 后台 > 设置 > 讨论，我们输入“评论审核”和“评论黑名单”关键字，就可以来屏蔽用户使用敏感关键词来注册了。
**用户注册时候不能含有非法关键字，同上**
WordPress 后台 > 设置 > 讨论，可以让我们输入“评论审核”和“评论黑名单”关键字，这些关键字在用户留言的时候将用于非法关键字的检测。那么我们是否可以将这些关键字用于其他方面呢？比如用户注册的时候，用户名不能包含这些非法关键字。答案肯定是可以：
首先创建非法关键字检测函数：
function
 wpjam_blacklist_check($str){$moderation_keys= trim(get_option('moderation_keys'));$blacklist_keys= trim(get_option('blacklist_keys'));$keys=$moderation_keys."\n".$blacklist_keys;$words=explode("\n",$keys);foreach((array)$wordsas$word){$word= trim($word);// Skip empty linesif(empty($word))continue;// Do some escaping magic so that '#' chars in the// spam words don't break things:$word= preg_quote($word,'#');$pattern= "#$word#i";if( preg_match($pattern,$str))returntrue;}returnfalse;}
设置用户名不能含有待审关键字和黑名单关键字。
add_filter('sanitize_user','wpjam_sanitize_user',3,3);function
 wpjam_sanitize_user($username,$raw_username,$strict){if(wpjam_blacklist_check($username)){$username='';}return$username;}
将上面这两段函数复制到当前主题的 functions.php 文件即可。
*版主*
*管理*
*站长*
*admin*
*超版*
*众乐网*
*众乐*
*社区*
*元老*
Administrator
*管理*
*@*
*网*
*com*
*cn*
*net*
*org*
*cc*
*tk*
*公司*
*gov.cn*
*name*
*info*
*biz*
*官方*
*tm *
*mn*
*in*
*pro*
*net.cn *
*travel *
*ag*
*cm *
*com.hk *
*org.cn*
*sh *
*ws*
*vc*
*co*
*com.tw*
*版主* 
*斑竹* 
*吧主* 
*霸主* 
*Manager*
*<* 
*>*
*文学*
*作家*
*文章*
*作品*
*昵称*
*名字*
*名称* 
*人名*
*name*
*网站* 
*baidu*
百度
*sina*
新浪
*163*
网易 
*sohu*
搜狐
*xunlei* 
讯雷 
*gougou*
狗狗
*iask*
爱问 
*youku*
优酷
*56*
我乐 
*hao123*
好123
*头衔* 
*关键字* 
*关键词* 
*统配符*
*网页*
*电脑* 
*文档* 
*浏览器* 
*保留*
*主席* 
*公司* 
*总经理* 
*投资商*
*股东*
*Marshal*
*fuck*
*操* 
*靠*
*日* 
*kao*
*cao* 
*黑社会*
*流氓* 
*se*
*色*
*性爱*
*肏*
*尼玛*
*你妈*
*傻*
*www*
*qq*
*QQ*
*yy*
*YY*
*战队*
*火线*
*游戏*
*刷机*
*刷级*
*网*
*攻击*
*黑*
*黄*
*迷药*
*匿名*
*倪明*
*佚名*
*未知*
- admin
- administrator
- 管理员
- 版主
- 超级版主
- 超级管理员
- 本站管理员
- 本版版主
- 会员
- 超级会员
- vip
- *.com*
- *.cn*
- 用户管理
- *管理员*
- 
- *官方
- *京东*
- *淘宝*
PHP屏蔽过滤指定关键字的方法
**实现思路：**
一、把关键字专门写在一个文本文件里，每行一个，数量不限，有多少写多少。
二、PHP读取关键字文本，存入一个数组
三、遍历关键字数组，挨个用strpos函数去看看内容有没有关键字，如果有，返回true,没有则返回false
**PHP代码如下:**
**[php]**[view
 plaincopy](http://www.lai18.com/content/369559.html#)
- /* PHP中用strpos函数过滤关键字 */
- 
- // 关键字过滤函数
- 
- **function** keyWordCheck($content){  
- 
- // 去除空白
- 
- $content = trim($content);  
- 
- // 读取关键字文本
- 
- $content = @file_get_contents('keyWords.txt');  
- 
- // 转换成数组
- 
- $arr = explode("n", $content);  
- 
- // 遍历检测
- 
- **for**($i=0,$k=count($arr);$i<$k;$i++){  
- 
- // 如果此数组元素为空则跳过此次循环
- 
- **if**($arr[$i]==''){  
- 
- **continue**;   
- 
- }   
- 
- // 如果检测到关键字，则返回匹配的关键字,并终止运行
- 
- **if**(@strpos($str,trim($arr[$i]))!==false){  
- 
- //$i=$k; 
- 
- **return**$arr[$i];  
- 
- }   
- 
- }  
- 
- // 如果没有检测到关键字则返回false 
- 
- **return** false;  
- 
- }   
- 
- $content = '这里是要发布的文本内容。。。';   
- 
- // 过滤关键字
- 
- $keyWord = keyWordCheck($content);  
- 
- // 判断是否存在关键字
- 
- **if**($keyWord){  
- 
- echo '你发布的内容存在关键字'.$keyWord;  
- 
- }**else**{  
- 
- echo '恭喜！通过关键字检测';  
- 
- // 往下可以进行写库操作完成发布动作。
- 
- }
例子2 （注：中文关键字过滤时使用的关键字文件为utf-8编码）
**[php]**[view
 plaincopy](http://www.lai18.com/content/369559.html#)
- /**
- 
-  * 被禁止的关键字检测
- 
-  *
- 
-  * @param string $string  要检测的字符串
- 
-  * @param string $fileName 屏蔽关键字文件
- 
-  * @return bool
- 
-  */
- 
- **function** banwordCheck( $string, $fileName )  
- 
- {  
- 
- **if** ( !($words = file_get_contents( $fileName )) ){  
- 
- **die**('file read error!');  
- 
-  }  
- 
- $string = strtolower($string);  
- 
- $matched = preg_match('/'.$words.'/i', $string, $result);  
- 
- **if** ( $matched && isset($result[0]) && strlen($result[0]) > 0 )  
- 
-  {  
- 
- **if** ( strlen($result[0]) == 2 ){  
- 
- $matched = preg_match('/'.$words.'/iu', $string, $result);  
- 
-   }   
- 
- **if** ( $matched && isset($result[0]) && strlen($result[0]) > 0 ) {  
- 
- **return** true;  
- 
-   }**else**{  
- 
- **return** false;  
- 
-   }    
- 
-  }**else**{  
- 
- **return** false;  
- 
-  }  
- 
- }  
- 
- $content = '测试关键字';  
- 
- **if** ( banwordCheck($content, './banwords.txt') ){  
- 
-  echo "matched! ";  
- 
- }**else**{  
- 
-  echo "no match! ";  
- 
- }  
用正则去匹配关键字，把关键字用别的字符替换
**[php]**[view
 plaincopy](http://www.lai18.com/content/24631065.html#)
- $str = "/你大爷|你麻痹|什么玩意|SB|你他妈/";  // 关键字正则字符串  
- $string = "你他妈干什么玩意了 SB";    // 文本字符串 
-  echo preg_replace($str, "*", $string);    //preg_replace() 执行一个正则表达式的匹配和替换
思路
1.把关键字放到一个txt文档中 要用一定的符合分隔开 ，用file_get_contents() 函数将关键字文档读入
2.用函数explode() 把字符串分割成数组 循环数组 strpos() 查找匹配关键字
代码
**[php]**[view
 plaincopy](http://www.lai18.com/content/24631065.html#)
- header('content-type:textml; charset=utf-8;');   
- **function** strPosFuck($content)   
- {     
- $fuck = file_get_contents('keyWords.txt');  // 读取关键字文本信息  
- $content = trim($content);    $fuckArr = explode("\n",$fuck);  // 把关键字转换为数组  
- **for** ($i=0; $i < count($fuckArr) ; $i++)     
- {    
- // $fuckArr[$i] = trim($fuckArr[$i]);  
- **if** ($fuckArr[$i] == "") {       
- **continue**;  //如果关键字为空就跳过本次循环   
- # code...     
- }      
- **if** (strpos($content,trim($fuckArr[$i])) != false)      
-   {      
- **return**$fuckArr[$i];  //如果匹配到关键字就返回关键字     
-   # code...       
-   }     
-   }    **return** false;  // 如果没有匹配到关键字就返回 false 
-   }   
- $content = "我今天你大爷碰到一个SB";    
- $key = strPosFuck($content);   
- **if** ($key)   
-   {    
-   echo "存在关键字".$key;    
-   # code...    
-   }   
- **else**
-   {     
-   echo "OK";   
-   }  
**注意点** 一定要去空 一定要去空 ，
strops() 函数返回值 要么是false 要么就是关键字的位置 判断的时候注意
成功后大家可以想想怎么把匹配到的关键字全部返回组成一个字符串或者数组

关键词少的时候，用简单的遍历就可以，没必要复杂化
如果类似贴吧这种大型社区，敏感词库庞大的，可以使用DFA算法来进行判断和过滤
Python和JAVA有很多现成的过滤方法，如
[http://blog.csdn.net/woshiaotian/article/details/10047675](http://blog.csdn.net/woshiaotian/article/details/10047675)
[http://blog.zhaojie.me/2008/12/filter-forbidden-word-solution.html](http://blog.zhaojie.me/2008/12/filter-forbidden-word-solution.html)[关键字过滤解决方案（上）](http://blog.zhaojie.me/2008/12/filter-forbidden-word-solution.html)

在Discuz!论坛后台，站长可以在后台-帖子-词语过滤里设置需要屏蔽或替换的关键词。一般这些需要屏蔽和替换的关键字包括一些和政治、色情相关的违法国家法律法规的词语。
**在这里，我们点“批量添加”，然后将压缩包中的“屏蔽关键词.txt”文件导入，进行批量屏蔽非法关键词。**
    其中，在Discuz!论坛后台设置屏蔽的关键字只能保证帖子内容正当不违规，站长可以在UCenter后台-词语过滤里面进一步设置一些屏蔽的关键字，这里就不具体举例了，以保障用户的短消息也能安全。
    屏蔽关键词表下载

[http://www.cnblogs.com/AndersLiu/archive/2007/03/25/687069.html](http://www.cnblogs.com/AndersLiu/archive/2007/03/25/687069.html)

在线测试/学习正则表达式的网址，
[http://www.gskinner.com/RegExr/](http://www.gskinner.com/RegExr/)

**只含有汉字、数字、字母、下划线，下划线位置不限：**
  ^[a-zA-Z0-9_\u4e00-\u9fa5]+$
如一个用户叫Bill Gates，另一个人起名叫Bill Gates，区别只是两个单词见多了一个空格，当然也可能是换行符这种不可见字符，它们在浏览器里面看上去就象同一个人）

**1. 字母数字字符（英文字母和数字）**
**2. 下划线(_) **
与此同时，我们还强制用户名最短3个字符最长不超过16个字符。下面就是符合上述描述条件的正则表达式： 
/[a-zA-Z0-9_]{3,16}/ 
这个有问题，需要用到行定位点， ^ (caret) 和 $ (dollar)
 字符将把我们的表达式限制在一个字符串的起点和终点位置，这样可以确保整个用户名符合我们的设定，而不是一部分。
修订版的正则表达式象这样： 
/^[a-zA-Z0-9_]{3,16}$/
function
 validate_username( $username ) {
if(preg_match('/^[a-zA-Z0-9_]{3,16}$/',
 $_GET['username'])) {
returntrue;
}
returnfalse;
}
Warning: preg_match() [function.preg-match]:
 Compilation failed: PCRE does not support \L, \l, \N, \U, or \u at offset 3 intest.php
 on line 3
if(preg_match("/^[\x{4e00}-\x{9fa5}]+$/u",$str))
 {
print("该字符串全部是中文");
} else{
print("该字符串不全部是中文");
}
在php中，是用\x表示十六进制数据的。
[http://www.cnblogs.com/seanxyh/archive/2013/04/03/2998596.html](http://www.cnblogs.com/seanxyh/archive/2013/04/03/2998596.html)

说明：正则表达式通常用于两种任务：1.验证，2.搜索/替换。用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$。此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。
正则表达式（英文：Regular Expression）在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。
|说明|正则表达式|
|----|----|
|网址（URL）|[a-zA-z]+://[^\s]*|
|IP地址(IP Address)|((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)|
|电子邮件(Email)|\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*|
|QQ号码|[1-9]\d{4,}|
|HTML标记(包含内容或自闭合)|<(.*)(.*)>.*<\/\1>|<(.*) \/>|
|密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)|(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$|
|日期(年-月-日)|(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))|
|日期(月/日/年)|((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})|
|时间(小时:分钟, 24小时制)|((1|0?)[0-9]|2[0-3]):([0-5][0-9])|
|汉字(字符)|[\u4e00-\u9fa5]|
|中文及全角标点符号(字符)|[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]|
|中国大陆固定电话号码|(\d{4}-|\d{3}-)?(\d{8}|\d{7})|
|中国大陆手机号码|1\d{10}|
|中国大陆邮政编码|[1-9]\d{5}|
|中国大陆身份证号(15位或18位)|\d{15}(\d\d[0-9xX])?|
|非负整数(正整数或零)|\d+|
|正整数|[0-9]*[1-9][0-9]*|
|负整数|-[0-9]*[1-9][0-9]*|
|整数|-?\d+|
|小数|(-?\d+)(\.\d+)?|
|不包含abc的单词|\b((?!abc)\w)+\b|
以上正则表达式均经过多次测试，并不断增加,因为不同程序或工具的正则表达式略有区别，大家可以根据需要进行简单修改
**常用正则表达式**
正则表达式用于字符串处理、表单验证等场合，实用高效。现将一些常用的表达式收集于此，以备不时之需。
|说明|正则表达式|
|----|----|
|用户名|/^[a-z0-9_-]{3,16}$/|
|密码|/^[a-z0-9_-]{6,18}$/|
|十六进制值|/^#?([a-f0-9]{6}|[a-f0-9]{3})$/|
|电子邮箱|/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/|
|URL|/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/|
|IP 地址|/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/|
|HTML 标签|/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/|
|Unicode编码中的汉字范围|/^[u4e00-u9fa5],{0,}$/|
|匹配中文字符的正则表达式|[\u4e00-\u9fa5]|
|评注：匹配中文还真是个头疼的事，有了这个表达式就好办了| |
|匹配双字节字符(包括汉字在内)|[^\x00-\xff]|
|评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）| |
|匹配空白行的正则表达式|\n\s*\r|
|评注：可以用来删除空白行| |
|匹配HTML标记的正则表达式|<(\S*?)[^>]*>.*?</\1>|<.*? />|
|评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力| |
|匹配首尾空白字符的正则表达式|^\s*|\s*$|
|评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式| |
|匹配Email地址的正则表达式|\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*|
|评注：表单验证时很实用| |
|匹配网址URL的正则表达式|[a-zA-z]+://[^\s]*|
|评注：网上流传的版本功能很有限，上面这个基本可以满足需求| |
|匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)|^[a-zA-Z][a-zA-Z0-9_]{4,15}$|
|评注：表单验证时很实用| |
|匹配国内电话号码|\d{3}-\d{8}|\d{4}-\d{7}|
|评注：匹配形式如 0511-4405222 或 021-87888822| |
|匹配腾讯QQ号|[1-9][0-9]{4,}|
|评注：腾讯QQ号从10000开始| |
|匹配中国大陆邮政编码|[1-9]\d{5}(?!\d)|
|评注：中国大陆邮政编码为6位数字| |
|匹配身份证|\d{15}|\d{18}|
|评注：中国大陆的身份证为15位或18位| |
|匹配ip地址|\d+\.\d+\.\d+\.\d+|
|评注：提取ip地址时有用| |
|匹配特定数字：| |
|^[1-9]\d*$|//匹配正整数|
|^-[1-9]\d*$|//匹配负整数|
|^-?[1-9]\d*$|//匹配整数|
|^[1-9]\d*|0$|//匹配非负整数（正整数 + 0）|
|^-[1-9]\d*|0$|//匹配非正整数（负整数 + 0）|
|^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$|//匹配正浮点数|
|^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$|//匹配负浮点数|
|^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$|//匹配浮点数|
|^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$|//匹配非负浮点数（正浮点数 + 0）|
|^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$|//匹配非正浮点数（负浮点数 + 0）|
|评注：处理大量数据时有用，具体应用时注意修正| |
|匹配特定字符串| |
|^[A-Za-z]+$|//匹配由26个英文字母组成的字符串|
|^[A-Z]+$|//匹配由26个英文字母的大写组成的字符串|
|^[a-z]+$|//匹配由26个英文字母的小写组成的字符串|
|^[A-Za-z0-9]+$|//匹配由数字和26个英文字母组成的字符串|
|^\w+$|//匹配由数字、26个英文字母或者下划线组成的字符串|
**表达式全集**
正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表：
|字符|描述|
|----|----|
|\|将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。|
|^|匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。|
|$|匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。|
|*|匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。|
|+|匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。|
|?|匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。|
|{n}|n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。|
|{n,}|n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。|
|{n,m}|m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。|
|?|当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。|
|.|匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“[.\n]”的模式。|
|(pattern)|匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。|
|(?:pattern)|匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。|
|(?=pattern)|正向预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|
|(?!pattern)|负向预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始|
|x|y|匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。|
|[xyz]|字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。|
|[^xyz]|负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。|
|[a-z]|字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。|
|[^a-z]|负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。|
|\b|匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。|
|\B|匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。|
|\cx|匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。|
|\d|匹配一个数字字符。等价于[0-9]。|
|\D|匹配一个非数字字符。等价于[^0-9]。|
|\f|匹配一个换页符。等价于\x0c和\cL。|
|\n|匹配一个换行符。等价于\x0a和\cJ。|
|\r|匹配一个回车符。等价于\x0d和\cM。|
|\s|匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。|
|\S|匹配任何非空白字符。等价于[^\f\n\r\t\v]。|
|\t|匹配一个制表符。等价于\x09和\cI。|
|\v|匹配一个垂直制表符。等价于\x0b和\cK。|
|\w|匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。|
|\W|匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。|
|\xn|匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。.|
|\num|匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。|
|\n|标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。|
|\nm|标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。|
|\nml|如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。|
|\un|匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（?）。|
以下是以PHP的语法所写的示例
验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间 
<?php
$str = 'a1234';
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) {
echo "验证成功";
} else {
echo "验证失敗";
}
?>
简易的台湾身份证字号验证
<?php
$str = 'a1234';
if (preg_match("/^\w[12]\d{8}$/", $str)) {
echo "验证成功";
} else {
echo "验证失敗";
}
?>
以下示例是用 Perl 语言写的，与上面的示例功能相同 
print $str = "a1234" =~ m:^[a-zA-Z0-9]{4,16}$: ? "COMFIRM" : "FAILED";
print $str = "a1234" =~ m"^\w[12]\d{8}$" ? "COMFIRM" : "INVAILD";
[Validated XHTML 1.0 Strict](http://validator.w3.org/check?uri=referer)[Validated
 CSS 2.1](http://jigsaw.w3.org/css-validator/check/referer)
如何写出高效率的正则表达式
如果纯粹是为了挑战自己的正则水平，用来实现一些特效（例如使用正则表达式计算质数、解线性方程），效率不是问题；如果所写的正则表达式只是为了满足一两次、几十次的运行，优化与否区别也不太大。但是，如果所写的正则表达式会百万次、千万次地运行，效率就是很大的问题了。我这里总结了几条提升正则表达式运行效率的经验（工作中学到的，看书学来的，自己的体会），贴在这里。如果您有其它的经验而这里没有提及，欢迎赐教。
为行文方便，先定义两个概念。
**误匹配**：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。
**漏匹配**：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。
写出一条正则表达式，既可能**只出现**误匹配（条件写得极宽松，其范围大于目标文本），也可能**只出现**漏匹配（只描述了目标文本中多种情况种的一种），还可能**既有误匹配又有漏匹配**。例如，使用\w+\.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。
精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。
**掌握语法细节**。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable
 repetition inside lookbehind，例如(?<=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?<=ab)c）都不支持，而perl和python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。
**先粗后精，先加后减**。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。
**留有余地**。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发*票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式
 发[*#](?:票|漂)，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。
**明确**。具体说来，就是**谨慎**用点号这样的元字符，**尽可能**不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是<span
 class=”msg”>…</span>且正文中无尖括号，那么<span class=”msg”>[^<]{1,480}</span>这种写法**的思路**要好于<span class=”msg”>.*</span>，原因有二：一是使用[^<]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。
**不要让稻草压死骆驼**。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。
**宁简勿繁**。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g;
 s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。
**巧妙定位**。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。


