# 决策树 - 浅梦的博客 - CSDN博客





2017年08月26日 23:25:35[浅梦s](https://me.csdn.net/u012151283)阅读数：366
个人分类：[机器学习																[决策树](https://blog.csdn.net/u012151283/article/category/7194664)](https://blog.csdn.net/u012151283/article/category/6653295)








在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。 

其主要优点是模型具有可读性，分类速度快。 

学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型。 

预测时，对新的数据，利用决策树模型进行分类。 

决策树学习通常包括3个步骤：特征选择，决策树生成和决策树的修剪。
# 决策树模型与学习

## 决策树与if-else规则

由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。

## 决策树与条件概率分布

决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。假设X为表示特征的随机变量，Y为表示类的随机变量，那么这个条件概率分布可以表示为$P(Y|X)$。X取值于给定划分下单元的集合，Y取值于类的集合。

## 决策树学习

决策树学习的损失函数通常是正则化的的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。 

因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树学习算法通常采用启发式算法，近似求解这一最优化问题。这样得到的决策树是次最优的。 

决策树对的生成对应于模型的局部选择，决策树的剪枝对应于模型的的全局选择。决策树的生成只考虑局部最优，相对地，决策树的剪枝则考虑全局最优。 

决策树学习常用算法包括ID3,C4.5,CART。
# 特征选择

## 信息增益

在信息论与概率统计中，**熵(entropy)**表示随机变量不确定性的度量。设X是一个取有限个值得离散随机变量，其概率分布 
$P(X=x_i)=p_i,i=1,...,n$

则随机变量X的熵定义为 
$H(X)=-\sum\limits_{i=1}^np_i\log p_i\text{(5.1)}$

在式(5.1)中，若$p_i=0$则定义$0\log 0=0$。通常，式(5.1)中的对数以2或e为底，这时熵的单位分别为比特(bit)或纳特(nat)。 

由定义可知，熵只依赖于X的分布，与X的取值无关，所以可将X的熵记作$H(p)$，即 
$H(p)=-\sum\limits_{i=1}^np_i\log p_i$

熵越大，随机变量的不确定性越大。从定义可验证 
$0\le H(p)\le \log n$
**条件熵$H(Y|X)$**表示在已知随机变量X的条件下随机变量Y的不确定性。随机变量X给定条件下随机变量Y的条件熵，定义为**X给定条件下Y的条件概率分布的熵对X的数学期望**
$H(Y|X)=\sum\limits_{i=1}^np_iH(Y|X=x_i)$

这里，$p_i=P(X=x_i),i=1,2,...,n$

信息增益表示得知特征X的信息而使得类Y的信息的不确定性减少的程度。 

特征A对训练数据集D的信息增益$g(D,A)$，定义为集合D的经验熵$H(D)$与特征A给定条件下D的经验条件熵$H(D|A)$之差，即 
$g(D,A)=H(D)-H(D|A)$

一般，熵H(Y)与条件熵H(Y|X)之差称为互信息。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。
## 信息增益比

以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比可以对这一问题进行校正。 

特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集D关于特征A的值的熵$H_A(D)$之比，即 
$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$

其中 
$H_A(D)=-\sum\limits_{i=1}^n\frac{|D_i|}{|D|}\log_2\frac{D_i}{D}$

n是特征A取值的个数。
# 决策树生成

## ID3算法

ID3（Iterative Dichotomiser 3）创建多叉树，在决策树各个结点上应用**信息增益**准则选择特征，递归地构建决策树。 

ID3不能处理连续特征。

## C4.5生成算法

与ID3相似，在生成的过程中，用**信息增益比**来选择特征。

### C4.5可以处理连续特征

处理过程如下： 

1. 对属性的取值进行排序 

2. 两个属性取值之间的中点作为可能的分裂点，将数据集分成两部分，计算每个可能的分裂点的信息增益（InforGain） 

3. 对每个分裂点的信息增益(InforGain)并修正：减去$\log_2\frac{N-1}{|D|}$

4. 选择修正后信息增益(InforGain)最大的，分裂点作为该属性的最佳分裂点 

5. 计算最佳分裂点的信息增益率（Gain Ratio）作为属性的Gain Ratio 

6. 选择Gain Ratio最大的属性作为分裂属性 

其中，3，4两点在93年Quinlan的C4.5算法中并没有体现，后来Quinlan在96年发表文章，对C4.5进行了改进，这两点是主要的修改。 

Quinlan的主要理由是数据集中同时出现连续属性和离散属性时，原始的C4.5算法倾向于选择连续的属性作为分裂属性，因此连续属性的信息增益需要减去$\log_2\frac{N-1}{|D|}$作为修正，其中N为可能的分裂点个数，|D|是数据集大小。 

第二个修改是，选择最佳分裂点不用信息增益率(Gain Ratio)，而用信息增益（Information Gain），然后用最大的信息增益对应的Gain Ratio作为属性的Gain Ratio. 

若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性。
### C4.5对缺失值的处理
- 如何在属性缺失的情况下进行划分属性选择？
- 给定划分属性，若样本在该属性上缺失，如何对样本进行划分

决策树学习开始阶段，根结点中各样本的权重初始化为1。 
![这里写图片描述](https://img-blog.csdn.net/20170926104422965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](https://img-blog.csdn.net/20170926104455649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
# 决策树的剪枝

在决策树学习中将已生成的树进行简化的过程称为剪枝。剪枝从已生成的树上裁掉一些子树或叶结点，并将其根据结点或父结点作为新的叶结点，从而简化分类树模型。

## 预剪枝

在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。 

预剪枝是的决策树的很多分支没有“展开”，不仅降低了过拟合风险，还显著减少了决策树的训练时间开销和测试时间开销。 

另一方面，有些分支的当前划分虽然不能提升泛化性能，但在其基础上进行的后续划分却有可能导致性能显著提高；预剪枝基于”贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。
## 后剪枝

先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将子树替换为叶结点。 
![这里写图片描述](https://img-blog.csdn.net/20170926105254776?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](https://img-blog.csdn.net/20170926105325914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

后剪枝通常比预剪枝保留了更多的分支。 

后剪枝欠拟合风险小，泛化性能往往优于预剪枝决策树。 

训练时间开销比未剪枝和预剪枝大得多。
# CART算法

分类与回归树(classification and regresiion tree,CART)。 

CART是在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。CART假设决策树是**二叉树**，内部结点特征的取值为”是”或“否”。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。 

CART算法由以下两步组成： 

1. 决策树生成：基于训练集生成决策树，生成的决策树要尽量大； 

2. 决策树剪枝：用验证集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。 

sklearn中使用优化的CART实现决策树。
## CART回归树生成

回归树：平方误差最小化 

分类树：基尼指数最小化 
$f(x)=\sum\limits_{m=1}^Mc_mI(x\in R_m)$

当输入空间的划分确定时，用平方误差$\sum\limits_{x_i\in R_m}(y_i-f(x_i))^2$表示回归树对训练集的预测误差，用平方误差最小准则求解每个单元的最优输出值。 

易知，单元$R_m$上的$c_m$的最优值$\hat c_m$是$R_m$上的所有输入实例$x_i$的对应输出$y_i$的均值，即 
$\hat c_m = ave(y_i|x_i \in R_m)$
![这里写图片描述](https://img-blog.csdn.net/20170826231950823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
## 分类树的生成

分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。 

基尼指数

> 
分类问题中，假设由K个类，样本点属于第k类的概率为$p_K$，则概率分布的基尼指数定义为 
$Gini(p)=\sum\limits_{k=1}^Kp_k(1-p_k)=1-\sum\limits_{k=1}^Kp_k^2$

  在特征A的条件下，集合D的基尼指数定义为 
$Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)$

  基尼指数Gini(D)表示集合D不确定性，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数越大，不确定性越大。
![这里写图片描述](https://img-blog.csdn.net/20170826232359682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## CART剪枝

![这里写图片描述](https://img-blog.csdn.net/20170926150233622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](https://img-blog.csdn.net/20170926150730232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$这个表示剪枝后损失函数减小的程度。一般地，若剪枝后损失函数下降，则该值为负数。 

但通常，该该值为正，表明剪枝后误差上升了，而我们要选择使得误差上升最少的子树进行剪枝（该子树拟合能力较差，可以舍弃）。 
![这里写图片描述](https://img-blog.csdn.net/20170926150759545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MTI4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

参考资料
> 
《统计学习方法》第5章 

  《机器学习》西瓜书 第4章 
[sklearn trees](http://scikit-learn.org/stable/modules/tree.html#tree)
[cooky_lin_607的博客](http://blog.sina.com.cn/s/blog_9ba91aae0100zaxt.html)


















