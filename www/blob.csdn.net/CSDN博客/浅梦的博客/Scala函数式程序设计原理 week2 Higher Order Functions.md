# Scala函数式程序设计原理 week2 Higher Order Functions - 浅梦的博客 - CSDN博客





2017年09月18日 14:04:21[浅梦s](https://me.csdn.net/u012151283)阅读数：289
个人分类：[Scala](https://blog.csdn.net/u012151283/article/category/7178055)









# 高阶函数

函数式语言中，函数是“头等公民”，就和数字一样。 

可以在变量中存放函数，也可以将函数作为参数或作为返回值。 

以其他函数作为参数并返回函数的函数称为高阶函数。
## 函数类型

类型`A=>B`是一个以类型A作为参数返回类型B的函数的类型。

## 匿名函数
`(x:Int) => 3*x`
`(x:Int)`是函数的参数，`3*x`是函数体。 

参数的类型可以被省略，如果可以被编译器从上下文中推断出来。

## 匿名函数是一种语法糖

匿名函数`(x1:T1,...,xn:Tn) => E`总可以使用含`def`的表达式 改写：

```
{
def f(x1:T1,...xn:Tn)=E;
f
}
```

# 柯里化Currying

柯里化是将原来接受两个参数的函数变成新的接受一个参数得函数得过程。新的函数返回一个以原有第二个参数作为参数的函数。

# 函数和数据

## 类

```
class Rational(x:Int,y:Int){
  def numer = x
  def denom = y
}
```

上述定义引入两个实体：
- 一个新的类型，叫做`Rational`
- 一个构造器`Rational`创建这个类型的元素

Scala将类型和值的名称保存在不同的命名空间中。 

所以两种`Rational`的定义是不会冲突的。

## 主构造器
- 
主构造器的参数直接放置在类名之后 

参数被编译成字段，其值被初始化成构造时传入的参数。

- 
主构造器会执行类定义中的所有语句。


## 辅助构造器

除了主构造器之外，类可以拥有任意多的辅助构造器(auxiliary constructor)。
- 辅助构造器的名称为this
- 每一个辅助构造器都必须以一个对先前定义的其他构造器的调用开始。

## 对象

通过在类的构造器前面使用`new`操作符构造对象

```
val x = new Rational(1,2)
x.numer
x.denom
```

对象的成员，通过中缀运算符`.`访问。

## 自引用

在类的内部，`this`代表当前正在执行的方法的所属对象。

## 对象私有字段

Scala中，方法可以访问该类的所有对象的私有字段。 

Scala允许定义更严格的访问限制，通过`private[this]`修饰符实现。
`private[this] var value = 0//类似某个对象.value这样的访问将不被允许`
这样，类的方法只能访问道当前对象的value字段，而不能访问同样类的其他对象的该字段。这样的访问被称为**对象私有的**。 
`private[类名]`可以定义仅有指定类的方法可以访问给定的字段。这里的类名必须是当前定义的类，或者是包含该类的外部类。

## 先决条件和断言

```
class Rational(x:Int,y:Int){
require(y>0,"denominator must be positive")
}
```

`require`是一个先决条件函数，接受一个条件和可选的字符串。若条件的值未`false`，会抛出一个`IllegalArgumentException`的异常。 

断言assert，失败的话也会抛出异常，但是是`AssertError`
- `require`是用来强制调用一个函数的先决条件
- `assert`用来检查函数代码本身

# 取值和操作符

L2.7




