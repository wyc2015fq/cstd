# 关于自动拆箱的危害--慎重自动拆箱 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2016年12月05日 10:05:46[QuJack](https://me.csdn.net/A784586)阅读数：374标签：[Java基础](https://so.csdn.net/so/search/s.do?q=Java基础&t=blog)
个人分类：[Java](https://blog.csdn.net/A784586/article/category/6556682)









               先看图再解释！





![](http://s16.sinaimg.cn/large/002cdaLCzy717iMMCcL2f&690)
是不是惊呆了，改了下数据，结果却不同了？！

Java是面向对象的语言，一般操作的都是对象，为了使操作基本类型方便，所以Java引入了包装类，基本类型到包装类的转换叫做装箱，反之为拆箱。操作又分为自动和手动，自动有危害，请看上图截图！

原因：Java整型，内存缓存-128---127的数据，当都为80时候，num2比较的时候是用的缓存中的数据80.因此运行结果相等。当都改为150的时候，所以不相等，要想150时候运行正确，改为num1.equals(num2)即可。有兴趣的可以测试150时候，当改为 num1！=num2条件依然也不成立！




再看如下代码，执行test()函数后，屏幕打印结果为（）


|12345678910111213141516|`public``class``Test2``{``    ``public``void````add(Byte b)````    ``{````````b = b++;``    ``}``    ``public``void``test()``    ``{````````Byte a = ``127``;````````Byte b = ``127``;````````add(++a);````````System.out.print(a + ````" "````);````````add(b);````````System.out.print(b + ``""``);``    ``}``}`|
|----|----|







答案：-128 127

Byte b是封装类型，`add(b);`引用传递，执行了没有任何影响，`add(++a);`会拆箱，溢出变为-128。







个人总结学习，欢迎批评指正，改进进步！









