# 数据库的隔离级别 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月30日 20:23:06[QuJack](https://me.csdn.net/A784586)阅读数：338标签：[数据库的隔离级别](https://so.csdn.net/so/search/s.do?q=数据库的隔离级别&t=blog)
个人分类：[数据库](https://blog.csdn.net/A784586/article/category/6777843)










**超级总结：**





**数据库的隔离级别分为四种，由强到弱分别为：****串行化，可重复读（幻读），不可重复读（读已提交），脏读（读未提交）****。**

**串行化****就是事务一个接一个执行，基于锁实现并发的数据库，****执行范围查询****的时候需要获得****范围锁****；不是基于锁实现并发数据库发现违反串型操作的，需要进行回滚。**

**可重复读（幻读）：****避免一个事务前后读的不一致，****被Select获取的数据都不能被修改。其他事务不能更改所选的数据，但是可以增加数据，可以出现幻读。****【MySQL默认级别】。**

**不可重复读（读已提交）****：读取的数据可以被其他事务修改。读之前上锁，读后可以在事务结束前释放锁，写需要在事务提交后释放。【sql server默认级别】。**

**脏读（读未提交）****：允许事务读取未提交的数据。**


#######################################################################################

**看懂了就没必要看下面的仔细解析了，没看懂可以先看了下面的，再看超级总结！ ^_^**

---------------------------------------------------------------------------------------------------------------------------------------------

1.数据库的隔离级别：

数据库的ACID属性：原子性，一致性，隔离性，持久性；

为了控制并发执行的效果就有了不同的隔离级别：

**1.1 串行化**（serializable）：所有**事务****都一个接一个**地串行执行，这样可以避免**幻读**（phantom
 reads）。对于**基于锁**来实现并发控制的数据库来说，串行化要求在**执行范围查询**（如选取年龄在10到30之间的用户）的时候，需要获取**范围锁**（range
 lock）。如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需要**滚回**该事务。

1.2**可重复读**（repeatable
 read，幻读）：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。MySQL默认级别。

1.3**读已提交**（read
 commited，不可重复读）：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。该等级也是SQL
 Server等大多数数据库默认的隔离等级。




1.4** 读未提交**（read
 uncommimited，脏读）：这是最低的隔离等级，允许其他事务看到没有提交的数据。这种等级会导致脏读（Dirty
 Read）。




备注：

**幻读**：第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。

**脏读**：事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。




一般在编程的时候只需要设置**隔离等级**，至于具体采用什么**锁**实现则由数据库来设置。







例子：下面考察后面**三种隔离等级对应的并发问题**。

假设有两个事务。事务1执行查询1，然后事务2执行查询2，然后提交，接下来事务1中的查询1再执行一次。查询基于以下表进行：

|users| | |
|----|----|----|
|id|name|age|
|1|Joe|20|
|2|Jill|25|


**###**

**可重复读(幻读**，phantom
 reads)

一个事务中先后各执行一次同一个查询，但是返回的结果集却不一样。发生这种情况是因为在执行Select操作的时候没有获取范围锁（Range
 Lock），导致其他事务仍然可以插入新的数据。

|Transaction 1|Transaction 2|
|----|----|
|SELECT * FROM usersWHERE age BETWEEN 10 AND 30;||
||INSERT INTO users VALUES ( 3, 'Bob', 27 );COMMIT;|
|SELECT * FROM usersWHERE age BETWEEN 10 AND 30;||


注意transaction 1对同一个查询语句（Query 1）执行了两次。 如果采用更高级别的隔离等级（即串行化）的话，那么前后两次查询应该返回同样的结果集。但是在可重复读隔离等级中却前后两次结果集不一样。但是为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题。

**###**

**读已提交（不可重复读**，Non-repeatable
 reads）

SELECT * FROM users WHERE id = 1;【Transaction 1】




UPDATE users SET age = 21 WHERE id = 1;【Transaction 2】

COMMIT;




SELECT * FROM users WHERE id = 1;【Transaction 1】




在采用锁来实现并发控制的数据库系统中，不可重复读是因为在执行Select操作的时候没有加读锁（read
 lock）。

**###**

**读未提交 (脏读**，dirty
 reads)

所谓的脏读就是允许事务读取未提交的更新。

|Transaction 1|Transaction 2|
|----|----|
|SELECT * FROM users WHERE id = 1;||
||UPDATE users SET age = 21 WHERE id = 1;|
|SELECT * FROM users WHERE id = 1;||
||RollBack|








串行化不会出现幻读-----》幻读（可重复读）---》 不可重复读 ----》脏读




**总结：**



**数据库的隔离级别分为四种，由强到弱分别为：****串行化，可重复读（幻读），不可重复读（读已提交），脏读（读未提交）****。**

**串行化****就是事务一个接一个执行，基于锁实现并发的数据库，****执行范围查询****的时候需要获得****范围锁****；不是基于锁实现并发数据库发现违反串型操作的，需要进行回滚。**

**可重复读（幻读）：****避免一个事务前后读的不一致，****被Select获取的数据都不能被修改。其他事务不能更改所选的数据，但是可以增加数据，可以出现幻读。****【MySQL默认级别】。**

**不可重复读（读已提交）****：读取的数据可以被其他事务修改。读之前上锁，读后可以在事务结束前释放锁，写需要在事务提交后释放。【sql server默认级别】。**

**脏读（读未提交）****：允许事务读取未提交的数据。**





