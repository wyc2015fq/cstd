# 设计模式总结：  5种创建型，7种结构型，11种行为型 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





置顶2017年03月09日 19:39:07[QuJack](https://me.csdn.net/A784586)阅读数：1247








设计模式总结：  5种创建型，7种结构型，11种行为型




1.1 工厂方法模式

    工厂方法模式（根据参数不同，工厂方法返回不同的产品对象），

    多个工厂方法模式（创建不同产品不需要参数），

    静态工厂方法模式（将工厂方法改为静态的，不需要实例化类）

1.2 抽象工厂：适合产品多变的情况，要生产新的产品就必须在工厂类里面加生产的方法，违背开闭原则。抽象工厂，




       增加一个工厂类接口，一个接口方法；各种产品实现这个工厂接口，生产自己对应的产品。

1.3单例模式：Singleton （懒汉式&饿汉式）

特殊的工厂方法模式，一个类只有一个实例：

                           1.拥有一个私有的静态实例；

                           2. 拥有私有的默认构造函数；

                           3.静态工厂方法，如果是懒汉式的必须同步的，防止多线程同时操作；

                           4.重写clone()函数，

返回当前实例对象，默认clone()创建新实例；

public class SingletonFactory{

           //1.私有的防止外部变量引用；

private static SingletonFactory _instance=null;

            //2.私有的默认构造函数，防止使用构造函数实例化；

private SingletonFactory(){ 

                     }

            //3.单例静态工厂方法，同步方式多线程同时执行；

synchronized public static SingletonFactory getInstance(){

            if(_instance==null){

                    _instance=new SingletonFactory();

                        }

                        retrun _instance;

            }

        //4.重写克隆函数

public SingletonFactory clone(){

        return getInstance();

                        }

}





1.4 建造者模式    StringBuilder


public class Client {

    public static void main(String[]args){

        Builder builder = new ConcreteBuilder();//接口buider,实现接口的具体建造者ConcreteBuilder,导演者Director，

        Director director = new Director(builder);

        director.construct();

        Product product = builder.retrieveResult();

        System.out.println(product.getPart1());

        System.out.println(product.getPart2());

    }

}








1.5原型模式：复制一个已经存在的实例来返回一个新的实例，而不是新建




------------------------------------------------------------------------------------------------------------

2.1  适配器模式：




类的适配器：对类进行适配。A继承B，实现接口C。

对象的适配器：对对象进行包装；A实现接口C，不继承B，包含一个B的对象；

接口的适配器：对接口抽象化。A实现所有接口，为每个接口提供一个默认实现；


缺省适配器模式：
      （A extends AbstractB implements interfaceC，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现(@Override)抽象类AbstractB中的方法，也可以选择不实现）





2.2 装饰器模式：（io流）

一个接口A，一个接口A的实现类B，一个装饰器C。C实现了A，并且有一个私有的类型为A的成员，构造函数初始化它。





适配器模式是将一个类A转换为另一个类B；


装饰器模式是为一个类A增强新的功能，从而变成Ｂ；

代理模式是为一个类Ａ转换为操作类B；






2.3 代理模式


Proxy实现接口Sourcable,含有一个Source对象


2.4 外观模式 jdbc


代理模式（一对一）发展而来的外观模式（一对多）

客户端访问子系统中的各个类，高度耦合。中间加一个统一接口，降低耦合度，客户端访问该类，该类调用子系统中的各个类。






2.5 桥接模式
  jdbc
客户端通过访问桥访问目标实现类，桥抽象化类包含目标接口类对象，可以赋值
 目标接口类的实现类的实例化给他，通过桥调用不同的目标实现类对象。




2.6 组合

2.7 享元

-----------------------------------------




父类与子类之间：


1.策略模式：【实现C中函数指针的功能，不同的比较策略】  （comparable & Comparator）；




2.模板方法模式




两个类之间：


3.观察者模式




4.迭代子模式（容器与容器遍历）




5.责任链模式（责任链模式）（串的替换---可以使用链式操作）




6.命令模式






类的状态：



7.备忘录模式






8.状态模式





通过中间类：



9.访问者模式




10.中介模式




11.解释器模式




























######################################################################





1.责任链模式（过滤器模式）：
2.OO思想
3.Iterator模式：（容器与容器遍历）


4.策略模式Strategy（comparable & Comparator）；

5.动态代理模式

6.工厂模式

7.其他模式




缺省适配模式（接口和抽象类）；




*************************************************************************************************************************************************************************************




面向接口的编程，面向抽象的编程





1. Java设计模式--责任链

先写测试，测试驱动开发；---------极限编程

串的替换---可以使用链式操作

过滤器链--过滤器模式；




################################################

0826

2.Java设计模式--oo面向对象

策略模式--------comparable & Comparator

封装，继承，多态；

面向对象思维：

            考虑类：名词，例子：美国人继承人---》人这个类包含国籍这个属性更合理

            属性：不可脱离具体的属性；

            考虑方法；

            类之间的关系；

             隐藏（封装），降低耦合度；

            继承； is  a    继承的耦合度很强，谨慎使用；

            多态：可扩展 Extensibility




可扩展原则： 修改不如添加（重载加方法，接口和抽象类 加类）；

##################################################################################################################################

面对对象的设计，复用的重点其实应该是抽象层的复用，而不是具体某一个代码块的复用！


Java接口(interface)和Java抽象类(abstract class)代表的就是抽象类型，就是我们需要提出的抽象层的具体表现。OOP面向对象的编程，如果要提高程序的复用率，增加程序 的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，正确地使用接口、抽象类这些有用的抽象类型作为你结构层次上的顶层。







抽象类和接口的区别：
- Java接口和Java抽象类最大的一个区别，就在于Java抽象类可以提供某些方法的部分实现，而Java接口不可以（就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法），这大概就是Java抽象类唯一的优点吧，但这个优点非常有用。如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而Java接口做不到这一点，如果向一个Java接口里加入一个
 新方法，所有实现这个接口的类就无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点。这个在我的另外一篇博客[mapreduce
 新旧API 区别](http://blog.csdn.net/xw13106209/article/details/6924458)中有提到类似的问题，在新的mapreduce api中更倾向于使用抽象类，而不是接口，因为这更容易扩展。原因就是上面划线部分所说的。
- 一个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，所以抽象类作为类型定义工具的效能大打折扣。在这一点上，Java接口的优势就出来了，任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就有了多种类型。（使用抽象类，那么继承这个抽象类的子类类型就比较单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，因为类型就比较多。接口和抽象类都可以定义对象，但是只能用他们的具体实现类来进行实例化。）
- 从第2点不难看出，Java接口是定义混合类型的理想工具，混合类表明一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。
- 结合1、2点中抽象类和Java接口的各自优势，具精典的设计模式就出来了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，也就是说在层次结构中，Java
 接口在最上面，然后紧跟着抽象类，这下两个的最大优点都能发挥到极至了。这个模式就是“缺省适配模式”。在Java语言API中用了这种模式，而且全都遵循一定的命名规范：Abstract ＋接口名。（A
 extends AbstractB implements interfaceC，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现(@Override)抽象类AbstractB中的方法，也可以选择不实现）


Java接口和Java抽象类的存在就是为了用于具体类的实现和继承的，如果你准备写一个具体类去继承另一个具体类的话，那你的设计就有很大问题了。Java抽象类就是为了继承而存在的，它的抽象方法就是为了强制子类必须去实现的。


需要注意的是在抽象类中，如果方法没有具体实现（就是方法后面没有{}），那么必须加上abstract来声明这个方法，而接口中不需要使用abstract来声明（抽象类之所以被称为抽象类，就是因为它包含有抽象方法。含有抽象方法的类叫做抽象类）








先学会用，在研究源码内部原理；

Over Design 也是一种罪过

接口与抽象类：需要继承，设计一个基类；    ------交通工具()

                       共同的规范，共性的动作之类，设计一个接口；--------go()




#################################################################

3. 设计模式Iterator

interface里面的方法都是public，可以不写；

面向接口编程；

不关心ArrayList或者LinkedList具体实现也能遍历，写Iterator接口，Collection中有返回Iterator的方法，具体不同实现类中实现这个方法，实现方法中写一个内部类实现Iterator的两个函数的具体不同实现：hasNext(),Next();

#################################################################

4. 设计模式：策略模式----------comparable & Comparator：


comparable:

写一个可复用的sort()对猫狗都可以排序；

先写一个接口Comparable，并包含方法ComparaTo()，猫狗都实现这个接口;

********************************

Comparator：

写一个接口Comparator，并包含方法compara(),猫狗中包含一个接口的属性，值为实例化一个Comparator的子类；写一个猫的比较器实现接口Comparator；

********************************

接口中的方法默认都是public的，因此可以省略不写；




################################################################

5. 设计模式：动态代理模式

类tank实现了接口moveable,

tank2 继承tank,可以重写里面的方法，调用父类方法，前后加内容--前后加当前时间，计算方法耗时；

tank3聚合实现：实现moveable接口，里面有成员 moveable t  ，t.move()前后加内容;




继承和聚合都可以实现代理，但是继承实现代理不够灵活；

聚合灵活：不会导致类爆炸，容易交换包裹顺序；

Tank t=new Tank();

TankLogProxy tlp=new TankLogProxy (t);

TankTimeProxy  ttp=new TankTimeProxy(tlp); 


Moveable m=ttp;

m.move();

#################################################################

6.设计模式：工厂模式

#################################################################


7.其他模式：

#################################################################








设计模式：

一．5种创建型的模式

１.工厂方法模式【工厂方法模式，多个工厂方法模式，静态工厂模式】：





负责实例化同一接口的多个类；定义一个创建产品对象的工厂类，由该工厂统一创建继承了同一接口的多个产品的对象；有大量产品需要创建适用；

工厂方法模式：

public class Farm1（）{                                          //工厂类

                public Animal produce(String type){    //Animal
 接口；工厂方法函数

                    if (type=="pig"){    

                            return new Pig();

                    }else if(type=="sheep"){

                              return new Sheep();

                        }

                            }

}

多个工厂方法模式：创建不同产品不需要参数。


public class Farm1（）{                                          //工厂类  核心

                publicvoid producePig(){
    //Pig工厂方法函数





                            return new Pig();

                            }


                      publicvoid produceSheep(){
    //Sheep 工厂方法函数







                            return new Sheep();

                            }



}
静态工厂方法模式：（简单工厂模式）


将多个工厂方法模式中，工厂方法改为静态，就不需要创建工厂对象了







2.抽象工厂模式：

问题：工厂方法一个工厂类承担了所有产品的的创建，如果产品的树形结构需要扩展，必须在工厂类中增加创建的功能；违背开闭原则；

抽象工厂模式：建立与产品类等级相似的工厂等级结构；为每一个产品提供一个具体的工厂类；扩展一个新产品的时候，只需要增加一个新的工厂类，甚至类似的对应产品多层继承工厂类；

增加一个工厂类接口，一个接口方法；

各种产品实现这个工厂接口，生产自己对应的产品。

适用：产品结构多变或有可能扩展的产品创建中




3.单例模式：Singleton

特殊的工厂方法模式，一个类只有一个实例：

                           1.拥有一个私有的静态实例；

                           2. 拥有私有的默认构造函数；

                           3.静态工厂方法，同步的，防止多线程同时操作；

                           4.重写cone()函数，返回当前实例对象，默认clone()创建新实例；

public class SingletonFactory{

           //1.私有的防止外部变量引用；

            private static SingletonFactory _instance=null;

            //2.私有的默认构造函数，防止使用构造函数实例化；

            private SingletonFactory(){ 

                     }

            //3.单例静态工厂方法，同步方式多线程同时执行；

synchronized public static SingletonFactory getInstance(){

            if(_instance==null){

                    _instance=new SiongletonFactory();

                        }

                        retrun _instance;

            }

        //4.重写克隆函数

public SingletonFactory clone(){

        return getInstance();

                        }

}




4.建造者模式：StringBuilder
 类，增加删除修改各种数据。构造数据集。

创建符合对象；将各种产品集中了起来；不关注各部分怎么创建用工厂模式，关注各部分用建造者模式；




各种产品都放List 中。

Farm5 farm=new Farm5();

farm.producePig();

farm.produceSheep();





farm.sum();




5.原型模式：prototype  创建复杂耗时的实例。

        复制一个已经存在的实例来返回一个新的实例，而不是新建。

public class Prototype implements Cloneable{

        public Object clone() throws ConeNotSupporteException{

                Prototype prototype=(Prototype) super.clone();

                return prototype;

                    }

}

以上是浅复制.




浅复制和深复制，基本类型值都一样被复制，引用类型的，只有是深复制的时候才会被复制。浅复制，引用的对象不被复制，引用同一个引用对象。










二．7种结构型的模式








1.适配器模式
源角色：Adaptee

目标角色：Target

适配器角色：Adapter





    Adaptee只有方法operation(),没有newoperation（），但是客户端同时要求又这两种方法，这时候新建一个接口Target，提供一个中间环节Adapter类，适配器类Adapter继承源角色Adaptee,实现目标角色Target接口。 





类的适配器：对类进行适配

对象的适配器：对对象进行包装；

接口的适配器：对接口抽象化。




类的适配器模式：

        Source类：operation1（）

        Targetable类：接口类，operation1（）,  operation2（）

        Adapter类: extends  Source，implements  Targetable




适配后的类，可以通过调用Targetable接口来实现对Source的操作；




对象的适配器模式：



        Source类：operation1（）

        Targetable类：接口类，operation1（）,  operation2（）

        Wrapper类:implements  Targetable; 不继承Source，包含一个Source对象，构造函数初始化，operation1（）{source.operation1();} 



接口的适配器模式：

Sourcable:定义多个接口函数的接口类；

DefaultWrapper：抽象类，实现了接口Sourcable，为每个接口函数提供一个默认实现；

      解决问题：实现一个接口编写一个类，不必实现所有接口函数；











2.装饰模式：

接口类：Sourable 

源类：Source，实现接口类

装饰类：Decorator1，实现接口类，含有一个私有接口类型的成员，构造函数初始化；





Sourable source=new Source();

        Sourable obj=new Decorator1(new Decorator2(new Decorator3(source)));

        obj.operator();




Decorator1：


    private Sourable source;

    public Decorator1(Sourable source)

    {

        super();

        this.source = source;

    }






适配器模式是将一个类A转换为另一个类B；


装饰器模式是为一个类A增强新的功能，从而变成Ｂ；

代理模式是为一个类Ａ转换为操作类B；




3.代理模式

被代理对象接口Sourcable

被代理对象Source

代理者Proxy




Proxy实现接口Sourcable,含有一个Source对象，跟对象适配器类似，不同的是在初始化的时候不能由外部传入，在构造函数中new Source();在operation1（）中调用source.operation1(),前后可以加入新增内容，跟装饰模式很像，不同的是关注点不同，代理模式关注如何调用，装饰模式关注扩展功能。Proxy实现对Source的调用。还实现了自己的功能。














4.外观模式：JDBC屏蔽了于数据库进行连接，查询，更新，删除等一系列的操作；

代理模式（一对一）发展而来的外观模式（一对多）

客户端访问子系统中的各个类，高度耦合。中间加一个统一接口，降低耦合度，客户端访问该类，该类调用子系统中的各个类。

目标类-----外观类-----客户端类。外观类中有各个子系统类的对象。




5.桥接模式：JDBC桥 DriverManager

抽象化角色：桥接类

修正抽象化：桥接具体类




实现化角色：目标接口

具体实现化：目标实现类




客户端通过访问桥访问目标实现类，桥抽象化类包含目标接口类对象，可以赋值 目标接口类的实现类的实例化给他，通过桥调用不同的目标实现类对象。










6.组合模式

将对象组合成树形结构以表示部分-整体的层次结构。




组合模式类：节点名称，父节点，孩子节点

private String  name;

private TreeNode parent;

private Vector <TreeNode> v=new Vector<TreeNode>();
















7.享元模式 FlyWeight            java中的数据库连接池

使用共享的方式，达到高效地支持大量的细粒度对象，他的目的就是节省占用的空间资源，从而实现系统性能的改善。










三．11种行为型的模式


父类与子类之间：




1.策略模式：【实现C中函数指针的功能，不同的比较策略】




2.模板方法模式






两个类之间：




3.观察者模式




4.迭代子模式




5.责任链模式




6.命令模式








类的状态：





7.备忘录模式









8.状态模式








通过中间类：





9.访问者模式




10.中介模式




11.解释器模式































