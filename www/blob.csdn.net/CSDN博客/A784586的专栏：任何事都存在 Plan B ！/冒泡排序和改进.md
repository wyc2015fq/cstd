# 冒泡排序和改进 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月17日 18:13:51[QuJack](https://me.csdn.net/A784586)阅读数：466








> 
> 
> 
> 
> 
> 
> 
冒泡排序和改进








冒泡排序思想：

将相邻的两个数做比较，如果不满足排序要求，则交换位置。具体有两种，一种就是从前往后相邻的比较，假设按照增序排，第一个跟第二个比，如果第一个大，则交换。然后将第二个和第三个位置的比。以此类推，一直比下去，这样一个轮回，可以将最大的那个数字送到最后一个位置。然后比较余下的。因此也称这种为“沉底法”。还有一种类似，就是从后往前比较，就是所谓的“冒泡法”，每一个轮回，将最小的那个数字送到了第一个元素的位置。

冒泡算法的改进：

记录每次交换的位置，当一次冒泡中无两个元素交换，则后面的部分已经有序，以后每轮比较不需要再次比较已经有序的部分。







java实现代码：下面代码以【沉底法】为例的代码。






```java
package com.mytest.hw;

public class BubbleSort {

	/**
	 * 冒泡排序和冒泡排序的改进
	 */
	public static void main(String[] args) {
		int[] a={5,4,3,2,7,8,9,10};
		for (int i : a) {
			System.out.print(i+" ");
		}
		System.out.println("\n排序后：");
		
		//sortbubble1(a);
		sortbubble2(a);
		for (int i : a) {
			System.out.print(i+" ");
		}
	}

	

	//时间复杂度 O(n^2)  沉底
	private static void sortbubble1(int[] a) {
		for(int i=1;i<a.length;i++)
			for(int j=0;j<a.length-i;j++){
				if(a[j]>a[j+1]){
					a[j]=a[j]^a[j+1];
					a[j+1]=a[j]^a[j+1];
					a[j]=a[j]^a[j+1];
				}
			}
		
	}
	//冒泡的改进算法  
	private static void sortbubble2(int[] a) {
		int lastexchange=a.length-1;//记录最后一次交换的位置，第一次必须比较到最后
		int exchange=0;//记录每次交换的位置
		
		while(lastexchange>0){
			for(int j=0;j<lastexchange;j++){
				if(a[j]>a[j+1]){
					a[j]=a[j]^a[j+1];
					a[j+1]=a[j]^a[j+1];
					a[j]=a[j]^a[j+1];
					exchange=j;
				}
			}
			lastexchange=exchange;
		}
		
	}
	

}
```




备注：



```java
a[j]=a[j]^a[j+1];
a[j+1]=a[j]^a[j+1];
a[j]=a[j]^a[j+1];
```

如上代码为不引入第三个变量交换两个元素位置的方法；





          冒泡法之沉底法实现如上代码，冒泡法之冒泡法原理类似，不再啰嗦了。






