# 按层打印二叉树的节点【层次遍历变形】 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月14日 14:56:07[QuJack](https://me.csdn.net/A784586)阅读数：431








# 按层打印二叉树的节点

思想：在层次遍历的基础上，添加两个变量，一个toprint用于统计当层需要打印多少个，另外个nextprint用于计数下一层需要打印多少个。

java实现代码：



```java
package com.mytest.mymain;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class BTree{
	public int value;  //public static int value;  那么最终输出都为8个8
	public BTree left;  
	public BTree right;  
	BTree(int x) { value = x; }  
}
public class TraversalTree {
	public static void main(String[] args) {
		BTree root=new BTree(1);
		BTree Node2=new BTree(2);
		BTree Node3=new BTree(3);
		BTree Node4=new BTree(4);
		BTree Node5=new BTree(5);
		BTree Node6=new BTree(6);
		BTree Node7=new BTree(7);
		BTree Node8=new BTree(8);
	
		root.left=Node2;
		root.right=Node3;
		
		Node2.left=Node4;
		Node2.right=Node5;
		
		Node3.left=Node6;
		Node3.right=Node7;
		
		Node4.left=Node8;
		
		
		
		System.out.println("层次遍历带换行:");
		levelorder2(root);
	}
	
	
	//层次遍历,带换行
	public static void levelorder2(BTree root){
		Queue<BTree> queue=new LinkedList<BTree>();
		BTree bTree=null;
		
		if(root != null){
			queue.add(root);
		}
		int toprint=1;
		int nextprint=0;
		
		while(!queue.isEmpty()){
			bTree=queue.poll();
			System.out.print(bTree.value+"  ");
			toprint--;
			
			if(bTree.left != null){
				queue.add(bTree.left);
				nextprint++;
			}
			
			if(bTree.right !=null ){
				queue.add(bTree.right);
				nextprint++;
			}
			if(toprint==0){
				System.out.println();
				toprint=nextprint;
				nextprint=0;
			}
			
		}
		
	}
}
```




由于牛客网在线编程给的接口不同，下面结合这个思想+牛客网给的函数接口，完成牛客网上的编码：



```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
		ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> al_row = new ArrayList<Integer>();
		if (pRoot == null)    return al;
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		queue.add(pRoot);
		int count=1;      //记录本层需要打印多少个，当树不为空的时候，第一层要打印1个；
		int countnext = 0;//记录下一层要打印多少个元素
		while (!queue.isEmpty()) {
			TreeNode treeNode=queue.poll();
			al_row.add(treeNode.val);
			count--;
			
			if (treeNode.left != null) {  //左子树不为空的时候入队列，记录下层要打印的个数加1
				queue.add(treeNode.left);
				countnext++;
			}
			if (treeNode.right != null) {//右子树不为空的时候入队列，记录下层要打印的个数加1
				queue.add(treeNode.right);
				countnext++;
			}
			
			if(count==0){
				//al.add(al_row);这个添加有问题 new ArrayList<Integer>(al_row)
                al.add(new ArrayList<Integer>(al_row));
				al_row.clear();
			
				count=countnext;
				countnext=0;
				
			}
			
		}

		return al;
    }
    
}
```


[更多树相关的算法：按之字形打印，层次遍历不换行等，点我查看相关博客。](http://blog.csdn.net/a784586/article/details/61629926)





