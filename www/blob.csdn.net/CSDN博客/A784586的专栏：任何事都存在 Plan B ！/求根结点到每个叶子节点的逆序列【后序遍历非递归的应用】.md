# 求根结点到每个叶子节点的逆序列【后序遍历非递归的应用】 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月13日 21:03:00[QuJack](https://me.csdn.net/A784586)阅读数：508








> 
> 
**求根结点到每个叶子节点的逆序列【后序遍历非递归的应用】**



思想：后序遍历非递归算法，栈中存储的，从栈顶到栈底，正好是叶子节点双亲到根节点的序列，将后序遍历非递归算法中访问节点改为判断是否是叶子节点，若是输出栈中所有节点的值。




备注：如果栈不是自己用数组实现，无法通过下标遍历，遍历栈中元素，却不移除，需要另外个栈辅助。如果是自己用数组模拟栈，则可以通过控制下标，取得所求路径上的节点值，遍历栈却不移除栈中的元素；代码红色部分。




[树的后序遍历（递归和非递归java实现）](http://blog.csdn.net/a784586/article/details/61924895)




利用后序遍历的非递归实现求解代码：






```java
package com.mytest.mymain;


import java.util.Stack;

 

class BTree{
	public int value;  //public static int value;  那么最终输出都为8个8
	public BTree left;  
	public BTree right;  
	BTree(int x) { value = x; }  
}
public class PreOrderwithStack {
	public static void main(String[] args) {
		BTree root=new BTree(1);
		BTree Node2=new BTree(2);
		BTree Node3=new BTree(3);
		BTree Node4=new BTree(4);
		BTree Node5=new BTree(5);
		BTree Node6=new BTree(6);
		BTree Node7=new BTree(7);
		BTree Node8=new BTree(8);
	
		root.left=Node2;
		root.right=Node3;
		
		Node2.left=Node4;
		Node2.right=Node5;
		
		Node3.left=Node6;
		Node3.right=Node7;
		
		Node4.left=Node8;
		
		preorderfun(root);
		System.out.println();
		inorderfun(root);
		System.out.println();
		postorderfun(root);
		System.out.println();
		allpath(root);
	}
	
	public static void allpath(BTree root){
		Stack<BTree> stack =new Stack<BTree>();
		Stack<BTree> stack2=new Stack<BTree>();
		
		BTree proot;//标记栈顶元素前一个被访问的元素
		int flag;//root的左孩子未被访问；
		if(root!=null){
			do{
				while(root!=null){//将root所有左孩子全部入栈
					stack.push(root);
					root=root.left;
				  }
				
				//执行到此处，栈顶元素没有左孩子或者左子树已经被访问过；
				proot=null;//标记栈顶元素前一个被访问的元素，或者此时为最左下边，该元素前一个被访问的元素肯定为空。
				flag=1;//root的左孩子已经被访问；或者root为null
				
				while(!stack.isEmpty() && flag==1){
					root=stack.peek();       //取到栈顶元素，但是不出栈；
					if(root.right==proot){
						//System.out.print(root.value+"  ");
						if(root.left==null && root.right==null){  //是叶子节点
							/*1  Iterator<BTree> it=stack.iterator();   // 打印的是从根到叶子的路径；
							while(it.hasNext())
								System.out.print(it.next().value+" ");
							System.out.println();*/
							
							/*2 Stack stack2=(Stack) stack.clone();  //后面栈空
						
							while(!stack.isEmpty()){	
								System.out.print(stack.pop().value+" ");
								}
							System.out.println();*/
							
							//3.遍历栈中的元素，却不移除；
							while(!stack.isEmpty()){
								root=stack.pop();
								System.out.print(root.value+"  ");
								stack2.push(root);
							}
							System.out.println();
							
							while(!stack2.isEmpty()){
								stack.push(stack2.pop());
							}	
							
						}
						root=stack.pop();
						proot=root;
					}else{
						root=root.right;
						flag=0;//root左边孩子未被访问；
					}
				}
			}while(!stack.isEmpty());
		}	
	}
```


其他思路：也可以用层次遍历的变形解决本题，修改数据结构，为每个节点添加个字段保存双亲。根节点双亲置空，在层次遍历判断的时候，判断是叶子节点，则寻找队列中的双亲节点。











