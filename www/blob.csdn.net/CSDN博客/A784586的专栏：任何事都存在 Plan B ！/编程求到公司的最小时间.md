# 编程求到公司的最小时间 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月29日 16:54:15[QuJack](https://me.csdn.net/A784586)阅读数：447标签：[求到公司的最小时间](https://so.csdn.net/so/search/s.do?q=求到公司的最小时间&t=blog)
个人分类：[Java](https://blog.csdn.net/A784586/article/category/6556682)









题目：人从原点，去公司，也可以忍走到出租车位置，打车去公司。求人到公司的最小时间。

人的位置坐标为原点。

int n = Integer.parseInt(in.nextLine()); //n表示有n量出租车

String[] ax = null;  //出租车的横坐标

String[] ay = null;   //出租车的纵坐标

String[] company = null; //公司的横坐标和纵坐标

String[] time = null;//每不行一个单位（横坐标或者纵坐标移动一个单位）的时间消耗，出租车每行驶一个单位（横坐标或者纵坐标移动一个单位）的时间消耗





思想：设置时间总消耗为sum=从原点不行去公司的时间。然后迭代人去每个出租车站点的步行时间+出租车到公司的时间。比之前的小则替换。







java实现代码：



```java
package com.mytest.test0322;

import java.util.Scanner;

public class wangyi001 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			int n = Integer.parseInt(in.nextLine());
			String[] ax = null;
			String[] ay = null;
			String[] company = null;
			String[] time = null;
			if (in.hasNext())
				ax = in.nextLine().split(" ");
			if (in.hasNext())
				ay = in.nextLine().split(" ");
			if (in.hasNext())
				company = in.nextLine().split(" ");
			if (in.hasNext())
				time = in.nextLine().split(" ");
			if (ax != null && ay != null && company != null && time != null &&time.length == 2
					&& company.length == 2 && ax.length == n
					&& ax.length == ay.length
					&& Integer.parseInt(company[0]) >= -10000
					&& Integer.parseInt(company[1]) <= 10000
					&& Integer.parseInt(time[0]) >= 1
					&& Integer.parseInt(time[0]) <= 10000 && n >= 1 && n <= 50) {
				int sum = (Math.abs(Integer.parseInt(company[0])) + Math.abs(Integer
						.parseInt(company[1])))
						* Integer.parseInt(time[0]);

				for (int point = 0; point < n; point++) {
					if (Integer.parseInt(ax[point]) >= -10000
							&& Integer.parseInt(ax[point]) <= 10000
							&& Integer.parseInt(ay[point]) >= -10000
							&& Integer.parseInt(ay[point]) <= 10000) {
						int temp = (Math.abs(Integer.parseInt(ax[point])) + Math
								.abs(Integer.parseInt(ay[point])))
								* Integer.parseInt(time[0])
								+ Integer.parseInt(time[1])
								* (Math.abs(Integer.parseInt(ax[point])
										- Integer.parseInt(company[0])) + Math
										.abs(Integer.parseInt(ay[point])
												- Integer.parseInt(company[1])));
						if (temp < sum)
							sum = temp;
					}
				}
				System.out.println(sum);
			}
		}
	}
}
```







