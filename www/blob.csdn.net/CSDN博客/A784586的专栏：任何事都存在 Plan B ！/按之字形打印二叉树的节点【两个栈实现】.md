# 按之字形打印二叉树的节点【两个栈实现】 - A784586的专栏：任何事都存在 Plan B ！ - CSDN博客





2017年03月14日 19:48:54[QuJack](https://me.csdn.net/A784586)阅读数：460








> 
> 
**按之字形打印二叉树的节点**



思路：用两个栈，先把根节点放入其中一个栈中，然后判断两个栈只要有一个不为空，访问打印根节点，将根节点的左右子树分别入另外个栈，当访问遍历另外个栈偶数层的时候，这时候分别将下一层的节点按照右左的顺序入栈，交替的时候打印换行，交换两个栈操作即可。具体可以画图，把两个栈对应的进栈出栈对照一个具体例子模拟可以加深理解算法过程。







java实现代码：



```java
package com.mytest.mymain;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

import javax.management.IntrospectionException;
class BTree{
	public int value;  //public static int value;  那么最终输出都为8个8
	public BTree left;  
	public BTree right;  
	BTree(int x) { value = x; }  
}
public class TraversalTree {
	public static void main(String[] args) {
		BTree root=new BTree(1);
		BTree Node2=new BTree(2);
		BTree Node3=new BTree(3);
		BTree Node4=new BTree(4);
		BTree Node5=new BTree(5);
		BTree Node6=new BTree(6);
		BTree Node7=new BTree(7);
		BTree Node8=new BTree(8);
	
		root.left=Node2;
		root.right=Node3;
		
		Node2.left=Node4;
		Node2.right=Node5;
		
		Node3.left=Node6;
		Node3.right=Node7;
		
		Node4.left=Node8;
		
		System.out.println("\n之字形层次遍历带换行:");
		levelorder3(root);
		
	}
	//按之字形层次遍历二叉树
	public static void levelorder3(BTree root){
		if(root==null) return;
		Stack<BTree> stack1=new Stack<BTree>();
		Stack<BTree> stack2=new Stack<BTree>();
		Stack[] stack={stack1,stack2};
		int current=0;
		int next=1;
		stack[current].push(root);
		//System.out.println("A:"+((BTree)stack[current].pop()).value);
		BTree bTree=null;
		while(!stack[0].isEmpty() || !stack[1].isEmpty()){
			
			bTree= (BTree) stack[current].pop();
			System.out.print(bTree.value+"  ");
			
			if(current==0){//左孩子进去，右孩子进去
				if(bTree.left!=null){stack[next].push(bTree.left);}
				if(bTree.right!=null){stack[next].push(bTree.right);}
			}else{//右孩子进去，左孩子进去
				if(bTree.right!=null){stack[next].push(bTree.right);}
				if(bTree.left!=null){stack[next].push(bTree.left);}
			}
			
			if(stack[current].isEmpty()){
				System.out.println();//一层遍历完，换行
				current=1-current;
				next=1-next;
			}
			
		}
		
	}
}
```


由于牛客网给的函数接口不同，完成牛客网的在线编程：



```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
			ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> al_row = new ArrayList<Integer>();
		if (pRoot == null)    return al;
		
		Stack<TreeNode> stack1=new Stack<TreeNode>();
		Stack<TreeNode> stack2=new Stack<TreeNode>();
		Stack[] stacks={stack1,stack2};
		int current=0;
		int next=1;
		stacks[current].add(pRoot);
		while(!stack1.isEmpty()|| !stack2.isEmpty()){
			TreeNode treeNode=(TreeNode) stacks[current].pop();
			al_row.add(treeNode.val);
			
			if(current==0){//左右孩子进入
				if(treeNode.left !=null){stacks[next].push(treeNode.left);}
				if(treeNode.right !=null){stacks[next].push(treeNode.right);}
			}
			if(current==1){//右左孩子进入
				if(treeNode.right !=null){stacks[next].push(treeNode.right);}
				if(treeNode.left !=null){stacks[next].push(treeNode.left);}
			}
			if(stacks[current].isEmpty()){
				al.add(new ArrayList<Integer>(al_row));
				al_row.clear();
				current=1-current;
				next=1-next;
			}
			
		}
		return al;
    }

}
```







