# TCP的状态（SYN，FIN，RST，ACK，PSH，URG） - 星爷2401 - CSDN博客
2016年12月12日 21:03:52[星爷2401](https://me.csdn.net/leifukes)阅读数：4631
TCP的标志位有SYN，FIN，RST，ACK，PSH，URG
SYN：建立连接。
FIN：关闭连接。
RST：连接重置。
ACK：相应。
PSH：有数据传输。
URG：urgent紧急。
ACK可以和其他的命令同时使用：比如SYN和ACK同时为1，代表建立连接之后立即相应，如果只有SYN为1，则代表只是建立了链接。
TCP的三次握手是通过ACK来体现的：
第一次：A主机发送位码为SYN=1，产生一个随机数seq number = 1234567的数据包到达主机B，主机B通过SYN=1就会知道，A要建立一个链接。
第二次：B主机收到连接请求后要确认联机信息，向A发送ack number = （seq+1），SYN=1，ACK=1，随机产生seq=7654321的包。
第三次：A主机收到后检查ack number是否正确，number=1234567+1，以及ACK=1，若正确，A发送ACK number=B的sql+1，主机B收到以检查正确number=7654321+1，切ACK=1则成功建立连接。
RST一般是在FIN之后才会有1的情况。出现RST的原因大概有以下几点：
1、服务器端口未打开。
去请求一个端口未打开的机器，会返回RST连接重置，这个取决于操作系统对于这种情况的处理，有点操作系统会返回，而有的操作系统，在这种情况下，不会返回任何数据。
2、异常终止一个连接。
终止一个连接的正确方式是发送FIN，这叫有序释放。只有在所有的排队的数据发送完成之后才会发送FIN，这样能保证没有任何数据丢失，但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。这叫异常释放。
异常终止的好处：
1、丢弃任何待发数据，并立即发送复位报文段。
2、RST的接收方，会区分另一端是正常释放还是异常释放，应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。
RST报文不会导致另一端产生任何相应，另一端根本不进行确认。收到RST的一方将终止该连接，并通知应用层连接复位。
TCP协议要建立连接要经过3次“握手”，截取的数据包也是从3次握手开始，可以看到前三个包的状态（Flags）分别是：
 [S]、[S.]、[.]
首先是客户端向服务端发送一个10位的序号给服务端；服务端收到后把它+1再返回回去；客户端检查返回来的序号是对的，就返回给服务端一个1。根据上面的描述，知道这三个包满足：第一个包的seq+1=第二个包的ack；第三个包的ack=1
连接建立了之后就是具体的数据交互了，tcpdump脚本加-X参数可以通过十六进制和ASCII方式显示出具体的数据内容，这里略过。
TCP协议要断开连接要经过4次“挥手”，上面数据包的最后3条就是挥手的过程。细心的朋友会发现前面说的4次挥手，却只有3个包，这不是笔误。
最后三个包的状态分别是：
[F.]、[F.]、[.]
首先是客户端发一个序号告诉服务器我要断开，服务器说行，服务器发回一个序号，说断开吧，客户端说：“断！”
四次挥手之所以只能看到3个数据包是因为：ACK延迟发送机制。为了提高性能，TCP在收到ACK之后会攒起来而不是立即发送的，在几种情况下才会发送：
1 超过MSS（可以理解为攒得太多了，放不下了）
2 有FIN
3 系统设置为禁用延迟（TCP_NODELAY）
倒数第二条的前面应该还有一个ACK，因为不符合上述3条，所以被延迟（一般是40ms或者200ms）了，等到倒数第二条发出时符合条件了（有FIN）就一块发出来了，所以4次挥手只能看到3个包。如果系统禁用了延迟发送，就会看到4个包了。
以上均为我自己的理解，如果理解的不对，请指正。

