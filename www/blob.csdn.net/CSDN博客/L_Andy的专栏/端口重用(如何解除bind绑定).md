# 端口重用(如何解除bind绑定) - L_Andy的专栏 - CSDN博客

2015年01月27日 10:11:32[卡哥](https://me.csdn.net/L_Andy)阅读数：4549


## [socket]如何解除绑定bind()?

|我找的关于setsockopt的资料：1. 如果在已经处于 ESTABLISHED状态下的socket(一般由端口号和标志符区分）调用closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：BOOL bReuseaddr=TRUE;setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof(BOOL));2. 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：BOOL  bDontLinger = FALSE; setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&bDontLinger,sizeof(BOOL));3.在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：int nNetTimeout=1000;//1秒//发送时限setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char *)&nNetTimeout,sizeof(int));//接收时限setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char *)&nNetTimeout,sizeof(int));4.在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：// 接收缓冲区int nRecvBuf=32*1024;//设置为32Ksetsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));//发送缓冲区int nSendBuf=32*1024;//设置为32Ksetsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));5. 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能：int nZero=0;setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char *)&nZero,sizeof(nZero));6.同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：int nZero=0;setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char *)&nZero,sizeof(int));7.一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：BOOL  bBroadcast=TRUE; setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&bBroadcast,sizeof(BOOL));8.在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可以设置connect()延时,直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的作用，在阻塞的函数调用中作用不大)BOOL bConditionalAccept=TRUE;setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)&bConditionalAccept,sizeof(BOOL));9.如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采取的措施是"从容关闭"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体应用的要求(即让没发完的数据发送出去后在关闭socket)？struct linger {  u_short    l_onoff;  u_short    l_linger;};linger m_sLinger;m_sLinger.l_onoff=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)// 如果m_sLinger.l_onoff=0;则功能和2.)作用相同;m_sLinger.l_linger=5;//(容许逗留的时间为5秒)setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&m_sLinger,sizeof(linger));Note:1.在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用;     2.如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0；10.还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息：(前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数,采用的具体协议，以及出错的代码都可以记录下来）BOOL bDebug=TRUE;setsockopt(s,SOL_SOCKET,SO_DEBUG,(const char*)&bDebug,sizeof(BOOL));## [socket]如何解除绑定bind()?int enable = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR,  &enable, sizeof(int);|int enable = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR,  &enable, sizeof(int);|
|----|----|
|int enable = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR,  &enable, sizeof(int);| |

