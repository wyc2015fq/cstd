# 什么是图形加速 - L_Andy的专栏 - CSDN博客

2018年04月24日 15:58:41[卡哥](https://me.csdn.net/L_Andy)阅读数：696


入门篇 ---- 图形加速 之 图形

首先，我们先来咬文嚼字：图形加速卡。就是用来加速图形处理的一张扩展卡。所谓的图形处理是什么呢？纯文本时代的电脑，那一行一行的命令和文字，不叫图形处理。:-P 图形和文本是电脑输出给人们“看”的两样东西。

一、文本，被遗忘的时代

真正的文本处理呢，很不幸在 DOS 之后已经被完全淘汰了。所以没有什么“文本加速卡”之流的东西，是因为现在的显卡，即使完全没有文本处理的功能，也能在 Windows 下正常的工作。到这里，也许有人要问了：Windows 里的文字，不是“文本”吗？答案是：对你来说，它是。可是对电脑来说，它就不是文本了。Windows 里的文本，也是图形。那些文字是被 Windows “画”出来的。打开控制面板里的“字体”，你看到了什么？种类繁多的字体是吧。这些都不是存放在显卡里的，而是在硬盘上。当 Windows 接收到在窗口上打印一行字的命令的时候，它会调度“画”字程序，从硬盘里读出字体，然后画到屏幕上来。现在就明了了：Windows 的界面是完全基于图形的。所以图形加速卡对于 Windows 来说是十分重要的。好了，现在，让我们忘掉“文本”吧！ -_- 

二、图形的定义，像素及其他

再来看图形的定义。图形在 电脑里有两种截然不同的定义。第一种叫 光栅图形(Raster Graphics)，第二种叫 矢量图形(Vector Graphics)。所谓的“光栅图形”，每个电脑玩家都有广泛的接触。你现在打开 Windows 的“画笔”程序，随便画几个圆，几条线，图几块色，然后把你得图放大 8 倍(这个不用我指导你做吧？！) 你看到了什么？是不是由一个一个的小方块组成了你的图形？每一个小方块，被称作一个像素“Pixel”。也就是说，你的图形是有小小的像素们组成的。

盯着一个像素，你发现了什么？对了！一个像素只有一种颜色！( #%@#%^@)。而懂一点色彩学的人，都应该知道，光是由 红(Red) 绿(Green) 和 蓝(Blue) 三种基色以任意比例组合而成的。这图形里的一个像素，也是由 红，绿 和 蓝 组成的。在最为广泛的电脑图形之中，每一个原色，由 八个 0 或 1 的二进制数，也就是 8 位组成，也就是每种颜色的表现能力为 2^8 = 256 种，称之为“色阶”。学过统计吗？每个原色 256 种色阶，那么 R/G/B 三种原色的表现能力为多少种颜色？……… :blink: 你在翻高中数学书？咳，算了，还是我告诉你吧。要把它们乘起来。结果是 256 x 256 x 256 = …. 16777216 种。哇？！这么多？好，让我们用电脑习惯的千进制来吧它分开：16,777,216 = 16M。这就是人们常说的什么 16兆色啦，真彩色啦等等。

这里来一点插曲。如果一种染色占 8 位的话，那么 R/G/B 总共占 8 + 8 + 8 = 24 位。可是 24 位对现在的 32 位的电脑系统来说，是一个很不舒服的长度。应为 24 位对于电脑一次处理的 32 位来说，太小，可是一次处理两个 24 位，又超出了 32 位的处理能力。怎么办？只能在 24 位的颜色后面，再补上 8 位的空数据。这样一来，一个像素的颜色将占用 32 位，正好和 32 位系统的处理能力相应。这样处理起来就舒服多了。“空数据？你的意思是说每一个像素要浪费 8 位数据？”答案并不是肯定的。最后的 8 位虽然在图形的显示上没有作用，可是由于这里多了 8 位，人们总要想办法充分利用现有的资源的。所以另一个概念被加入到了像素里：透明度。也就是大家耳渲目染的像素Alpha 值。用原本没用的 8 位来保存 Alpha，不错的创意吧。这样，我们就可以根据像素的透明度，来把一个像素和另一个像素混合，做出重叠的效果。这就人传说中的 Alpha 混合 特效 呵呵。挺简单的吧。到这里，我们用比较专业的格式来表达一下最常用的像素：R8G8B8A8。 哇，什么？好，拆开看：R8, G8, B8, A8 也就是 红 8 位，绿 8 位，蓝 8 位，透明度 8 位。用来唬人蛮不错的啊~ :P 

光栅图形就介绍到这里的。接下来该另一个英雄登场：矢量图形。别小看了它，现在的 3D 图像基础可是有很大一部分是基于它的。

光栅图形是一个一个的点，而矢量图形是什么呢？其实也是一个一个的点，不过还有数学公式。这样讲：如果说光栅图形是告诉电脑在每个点画什么颜色的话，那么矢量图形就是教给电脑该怎么样画一个图形。比如一个圆。如果用光栅图形来表示，那么就要有一大堆的像素，来描速在圆所在的区域里，每个点的颜色。而用矢量图形来表示：它是一个圆，圆的圆心，圆的半径(可能还有圆的颜色)。就这么简单。在电脑画这两张图的时候，做的就是截然不同的工作了。画光栅图的时候，电脑把所有的像素数据读出来，然后原模原样的 Copy 到显示缓存，这样我们就在屏幕上看到这个圆了。而画矢量的圆，完全不同了：首先，电脑要确定圆的圆心，半径，然后找到这个圆将落在屏幕的哪一片区域。这个很重要的一步，叫做 设定(Setup)。找到了圆所在的屏幕区域之后，就可以用指定的颜色来填充这个区域了。这一步叫 光栅化(Rasterize)。圆所在的区域被填充了出来，我们就自然而然的看到这个圆了。 B) 

这个呢，就是电脑图形的初步基础。要牢记 光栅图形，矢量图形的定义，以及矢量图形的画法。笼统地说有两步，就是 设定 和 光栅化。这在以后的 3D 图形知识部分很重要。

原理篇 ---- 图形加速 之 加速

很久以前，绘图工作全部是由我们伟大而神圣的 CPU 来完成的，那时候的显卡，就是真正意义上用来“显示东西的卡”。它的工作就是把 CPU 处理好的数据“搬”到显示器上来。那时候 CPU 的工作可真是辛苦。现在好了，CPU 越来越快，可是做的工作却越来越少了。我先来说说图形加速的几个阶段。2D 图像加速，Windows 加速 和 3D 图像加速。 :rolleyes: 

一、简单死板的 2D 加速

2D 加速，是早就有的产物了。它的作用是用 显示芯片 来代替 CPU，整块整块的移动显存里的数据。比如，你要移动一个窗口，在没有 2D 加速的时代，CPU 所作的工作：1、找到窗口在显存中的地址，2、把一行数据拷贝到目的地址，3、重复 2 直到拷贝完所有的行。完成。这样一来，当窗口很大的时候，CPU 要处理的数据量就会成倍的增长，导致窗口的移动比蜗牛爬还慢…. 想体验一下吗？好，进入设备管理器，把你的显卡驱动删掉，然后重起…. 好好享受啊！呵呵

有了 2D 加速呢，CPU 所做的事，减轻了很多，不过还是要指导 显示芯片 来干这搬运工的活。CPU 的工作：1、找到窗口在显存中的地址，2、给 显卡发送 “拷贝这一行到目的地”的命令。3、重复 2 直到拷贝完所有的行。初看起来好像和没有加速以前差不多，可是第 2 步就是关键所在哦。

现在让我们把第二步分解来看：没有 2D 加速：1、读 32 Bit 数据(入门篇里的哦！)，把这 32 Bit 数据写入目的地。2、重复 1 直到一行所有的像素被处理完。而有了 2D 加速后的工作只有：1、发送命令让显卡去拷贝这一行。这样看来，2D 加速确实能很大程度的释放 CPU 的负担。所以大家现在随便提起一个窗口移动一下，很平滑不是吗？显卡负责了窗口的移动。

二、诡异的 Windows 加速

Windows 对于每位 PC 程序员来说，都可以用“诡异”二字来形容。Windows 有太多专有的东西，以至于显卡也要为 Windows 本身制定一套加速计划。拥有全部的 Windows 加速功能的显卡几乎没有，而且现在的 CPU 的速度足以弥补 Windows 没有全部硬件加速的缺陷。总的来说，包括 鼠标光标的加速，图标的加速 和 特别的窗口加速等等。

鼠标加速就是用显卡的硬件来处理 Windows 的鼠标光标。大家现在看到的鼠标光标 和桌面上的其他内容其实不属于同一个层。是画在显卡单独划分出来的“顶层”里的。具体的内容也就不用太详细的介绍的，总之我告诉大家一个辨别的方法。打开一个动画窗口，也就是内容一直在变动的窗口，然后把鼠标光标移动上去。如果光标不断的闪动，那么显卡没有给鼠标光标加速。反之如果鼠标光标纹丝不动，那么显卡给鼠标光标加速了。

图标的加速，就是显卡来画 Windows 图标的功能。这个功能真是少只又少，不过对于目前 Windows xp 惯用的 32Bit 透明图表，现代的图形加速卡能起到一定程度的加速功能。

特别的窗口加速：窗口加速不是用 2D 加速功能来处理吗？有什么特别的？当然有。移动一个窗口，嘿嘿，现在你知道电脑在做什么。可是，当一个顶端窗口挡在你移动的窗口上面的时候，也就是一个“总在最前面”的窗口(Windows 定的称呼) 挡在桌面，而你在它的下面移动一个窗口….. 怎么样，解释不了了吧！？ 这个时候，Windows 要做的事就稍有不同了。它首先找到窗口露在外面的部分，然后这样把整个窗口分割成一个一个的小块，再一个一个移动它们到目标位置。是不是比较麻烦？而如果用有 Windows 加速功能的显卡来做，显卡自己就可以处理这一切了。Windows加速就讲这么一点吧，因为它太庞大了，我都没有全部弄清楚。那么接下来，该我们的主角出场了。

三、复杂庞大的 3D 加速

人人都喜欢渲染 3D 动画(一看就头晕的除外)。看到虚拟的主角在屏幕上跳来跳去，杀来杀去，拯救世界，谁不激动啊！说起 3D 加速，由于它太复杂了，我准备分 5 个部分来讲，涵盖从简到繁，从过去到未来的 3D 加速基础知识，好让大家能多了解一点我们默默无闻的 3D 加速卡们的工作。

3.1: 彩色三角形

世界就是这样开始的。人们想到了用三角形来表示 3D 的物体。其实很简单，学过高中几何的同学都知道，三点确定一个平面。所以三角形永远都是平面的。这样一来，复杂的曲面物体被近似的用小的平面来表示，在绘画上面会方便很多。来看画一个三角形的过程：前面的文章我已经讲了绘制矢量图的过程。其实一个三角形也相当于一个矢量图。它由三个顶点组成。而绘制的过程一样有两步：1、找到三角形将会坐落在屏幕的哪个地方。2、用颜色填充这个地方。也就是我提到的 设定(Setup) 和 光栅化(Rasterize) 的过程。而由于对象是三角形，我们给这两个过程另起名字叫做：三角形设定(Triangle Setup) 和 三角形光栅化(Triangle Rasterize) 过程。呵呵，有点儿现代图形学的意思了吧！一开始的 3D 图形，只有颜色，没有现在人们所说的贴图啦，纹理啦等等，所以生成的图像都是光突突的感觉。那个时候根本还没有出现 3D 游戏的概念，而专业人士是不会在乎这些的。

3.2: 贴图？皮肤 + 颜色混合

人们显然不会满足永远看着光秃秃的三角形组成的东西在屏幕上乱跳。于是慢慢的有人想到：我们给三角形贴上纹理贴纸怎么样？说起纹理，看看你家里的家具，它们表面的木纹啦什么的，还真的和三角形用的纹理贴图有点相似之处呢！纹理贴图在 3D 图形领域所扮演的角色，和现实家居里的墙纸，贴纸确实功能差不多。而当时在纹理贴图发明的初始时间，还有人强烈的反对它呢！有人认为纹理贴图是没有用的东西，以至于那段时间有公司竟然出品过不支持纹理贴图的显卡(没有 TMU 的显卡，你能想象的出来吗？公司的名字我忘了)！不过纹理贴图还是显示出了它强大的魅力。现在的 3D 图形技术里，纹理贴图也算是单独的一门学问了。

有人会问，纹理贴图怎么贴到三角形上去的？这个过程的解释比较复杂，你可以试着想象：纹理贴图需要坐标来指定，就像你在刚刚做好的桌子上画上定点，让贴纸对齐定点贴上去一样。也就是说，每个三角形的顶点都包含有贴图坐标，这样处理的时候就能按照贴图坐标把纹理贴图贴在对应的位置。怎么贴？！我还没有讲？哦，对啊，呵呵，怎么贴呢？是这样的：在三角形设定的阶段，贴图坐标也被应用到了每一个像素上。具体的说，知道了顶点的贴图坐标，那么三角形内任一一个点的贴图坐标也应该能计算出来吧？！对了，是插值。利用插值，我们可以得出要画的三角形所在像素的每一个点所对应的贴图坐标，不是吗？有了这个贴图坐标，就简单多了。我们利用坐标，到贴图里去取对应坐标颜色来，不就把图贴上来了吗？呵呵，这段有点绕，也怪我的文字表达能力欠佳，大家仔细多看几遍吧，不好意思啊！

还有，伴随着纹理贴图而来的颜色混合，也应该归到这一节。颜色混合…. 我知道！不就是用像素的 Alpha 值来把两个像素运算混合成为一个像素吗？对了！不过颜色的混合不是仅限于 Alpha 混合。还有很多种混合方式。比如把三角形像素的颜色 和 屏幕上原有像素的颜色 加起来，这样看起来，三角形所在的地方像是被“加亮”了一样。游戏中的火焰啦，光环啦，等等，就是用了加法来完成的。同样，把两个像素的颜色相减、相乘 或 相除 也未尝不可，这一切就是 – 颜色混合。正因为有了颜色混合，各种酷炫的游戏特效才能实现。

3.3: 显卡的革命

上面所说的功能，人们早就把它们做到一些显卡芯片里了。这样一来，这些所有的工作，都被从 CPU 里解放了出来。好啊！可是 CPU 还是不知足：I want more freedom! 人们想尽方法把 CPU 的负担减轻。所以，最后，就连 三角形设定，三角形光栅化 过程之前的 潘多拉盒，也被解放了出来。这就是：几何变换 和 光照运算(Transform & Lighting, T&L)。

说到这里，就不得不讲一下这两个纯数学的过程。几何变换：大家都知道，我们在屏幕上看到的 3D 图形，是以某一个视点为观察点绘制的。这是怎么完成的？还有，3D 物体如何在整个场景里移动？这就牵扯到了图形处理之前的话题：3D 空间几何。每一个 3D 物体都有一个说明其位置，方向的数据阵列，我们把它叫做 矩阵(Matrix)。这个矩阵储存了物体在场景里的位置，旋转方向，缩放大小等等的信息。所以在物体移动的时候，我们不细要更改所有三角形的位置，仅仅修改 矩阵 里的信息，整个物体就一动了。而 矩阵的应用不仅如此。最后要把整个场景变换成一摄像机为中心的 3D 空间，这个过程也和 矩阵有关。

光照，另一个数学过程，就是用来通过三角形的顶点相对于场景中光源的位置，距离，夹角等等来计算这个三角形接受到光照的强度的过程。

以前，这两个纯数学的过程，需要 CPU 来完成。CPU 计算完所有的三角形数据后，把这些数据发送给显卡进行 设定 和 光栅化的过程。可是后来，人们发现，这些运算是如此的死板，以至于可以把它也集成到 显示芯片里来做！这就是硬件几何变换的由来。

所以，到此，CPU 需要做的已经没有什么了。修改一下物体的 矩阵，设置好需要的参数，然后给 显示芯片 发送命令：画吧！剩下的全不用操心……

3.4: 新 CPU 的诞生：GPU

那么到此显示芯片就可以称作 Graphics Processing Unit 了吗？nVidia 是这么说的，可是作为一个真正的处理器，没有可编程性的话，也是残缺的。在用腻了显卡设好的层层套套之后，程序员们大声疾呼：还我自由！他们迫切需要一种打破现在硬件死板功能的设计。因为一切都由硬件完成了，所以灵活性完全丧失了。显示芯片只能按照电路设计来处理三角形，成了一个呆板的“三角形处理机”。这个时候人们开始反省了，人们觉得给程序员最大的自由度让他们发挥才是写好的 3D 程序的关键。所以 – 可编程图形芯片 被设计了出来。这种芯片和以前的 T&L 芯片的最大不同之处在于：它的所有行为都是可以被编成的。使得它的功能被提升到了无限的高度。

反过来想想，当时没有硬件 3D 加速的时候，一切都是 CPU 完成的，虽然慢，但是很灵活。然后，全部硬件化了，灵活性也一降再降。到最后，可编程图形芯片 把速度和灵活性一起实现了。这时程序员所做的事，似乎回到了原始时代：自己写程序对三角形做 光照，办换，和光栅化。不过这又怎样呢？他们喜欢自由！

一切都很好，我们很高兴的说：这才是我想要的。很满足不是吗？可是事实并不像你想象的那样完美，上帝爱捉弄人……..

3.5: 真理？谬论？

发展了这么多年，光栅化的 3D 图形可以说是技术很成熟了。不过它所生成的图形，好像永远都不那么真实。即使人们尽再大的努力，它的画面始终还是动画，和人们心目中的“电影级别的画质”总是差那么一点……

究竟哪里错了？与此同时，3D 图形学的另一门分支：光线追踪图形学(Ray-Tracing) 也在快速的发展着。光线追踪图形学 与 光栅化图形学 是建立在完全不同的理论基础上的，它们的研究成果也是格格不入。而 光线追踪图形学 的理论基础是以眼睛为出发点，追踪每一条光线，精确的计算这些光线经过反射、折射和散射等等随后的颜色。这门学问由于原理及其复杂，所以研究的人力物力都比光栅化图形学要少，以至于到现在它的优势刚刚慢慢显现出来。而它真正的投入到民用、实时处理的阶段，恐怕还要十年左右的发展。而如果它成功了，现在一切的 光栅化图形学 理论，就会被全部推翻。

