# VC++笔记十 - L_Andy的专栏 - CSDN博客

2014年07月24日 09:38:07[卡哥](https://me.csdn.net/L_Andy)阅读数：1815


                
VC2008 无法调试,无法断点,断点无效的最终解决方法

今天VC2008忽然又出现断点无效了,按上次博客说的格式化了源文件,也删了编译工程数据库文件,问题依就.经过测试找到了终解决方法

方法一：

其实出现这个问题常常出现在工程中某一个源文件中,多是文件内的一些不可视符出了问题,比较多的是由于制表符Tab(0x09)引起的

在无法点的源文件打开再把内容全选(Ctrl+A),然后在菜单 “编辑”－“高级”－“设置选定内容的格式”。要是还是无效可以用

UltraEdit解决,用UltraEdit打开源文件,然后在UltraEdit-菜单-视图-显示空格/制表符打上构,这时再看看源文件找到不正常的地方删除就解决问题了

如下图:

那个分号后面的">"符删了,就恢复正常了

方法二

此问题在当源文件大时容易发生（猜测原因：vc编译器在源文件比较大时删掉了一些空白tab字符，然后再生成调试符号表，导致总认为执行二进制文件和源文件不一致）。

建议

Tools --> Options -->Debugging

去掉“Require source files to exactly match the original versoin”项的勾选

自己保证源码和编译的dll、exe一致即可

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

MFC编译运行错误之程序运行出现-1.#IND,1.#INF  C/C++程序运行有时候会出现-1.#IND,1.#INF，

在调试的时候输出除数为0得出的结果， INF就是infinite，就是无穷大的意思 IND可能表示很小，

不确定  

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

使用类似于pow, exp等等函数时常会产生一个无效数字1.#IND00，在VC下可以通过与一个确定数字比较大小来判断是否产生了无效数字，

但这个方法在DEV-CPP下却是行不通的。 其实解决办法很简单，使用   float.h中一个函数_isnan即可：   int _isnan(double x);       

当x是一个无效值(NaN, Not a Number) 时，返回非零值 否则返回0

#ifndef Nan_h__

#define Nan_h__

#define NAN log(-1.0) //无效值NaN

#define isNAN(x) ((x)!=(x))

#define NINF log(0.0) //负无穷大

#define INF -NINF //无穷大

#define PINF -NINF //正无穷大

#define isINF(x) (((x)==PINF)||((x)==NINF))

#define isPINF(x) ((x)==PINF)

#define isNINF(x) ((x)==NINF)

#endif // Nan_h__

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

请教C++深拷贝与浅拷贝区别并详细说一下如何应用

拷贝有两种：深拷贝，浅拷贝

当出现类的等号赋值时，会调用拷贝函数

在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。

但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。

所以，这时，必须采用深拷贝。

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。

简而言之，当数据成员中有指针时，必须要用深拷贝。

///////////////////////////////////////////////////////////////
            

