
# 深入理解Python中的-重复运算符 - jiahaowanhao的博客 - CSDN博客


2018年07月03日 13:57:21[数据分析技术](https://me.csdn.net/jiahaowanhao)阅读数：228


[深入理解Python中的*重复运算符](http://cda.pinggu.org/view/25990.html)
在python中有个特殊的符号“*”，可以用做数值运算的乘法算子，也是用作对象的重复算子，但在作为重复算子使用时一定要注意
注意的是：*重复出来的各对象具有同一个id，也就是指向在内存中同一块地址，在对各个对象进行操作是一定要注意。
举例来说：
>>> alist = [range(3)]*4
>>> alist
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
上面初始化一个二层列表用来模拟矩阵，该矩阵式4X3的，为描述方便，这里记矩阵为A。
现在我想给A11赋值为1，用下面的代码：
alist[0][0]=1
那我们想要的结果应该是：
[[1, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
可是很不幸，我们得到的是：
[[1, 1, 2], [1, 1, 2], [1, 1, 2], [1, 1, 2]]
这是怎么回事呢，为什么给A21赋值，其他的Ai1为什么都跟着变了呢？
原因是这样的：
文章开始的时候我们已经说过了，*重复出来的各对象具有同一个id，也就是指向在内存中同一块地址，在对各个对象进行操作是一定要注意。
我们再初始化的时候用了重复算子"*"，这个操作符在对对象进行重复操作时，会将重复的所有对象都指向同一块内存地址，所有当你改变其中的一个值时，其他的值自然也会更新，用python的话进行解释就是下面的命令及输出：
>>> id(alist[0])
18858192
>>> id(alist[1])
18858192
>>> id(alist[2])
18858192
>>> id(alist[3])
18858192
>>>
看到了吧，id都是一样滴，也就是说这4个list是同一个“list”。
既然这样那我们想要模拟一个矩阵怎么办呢，除了有专门的numpy包之外，你当然可以给上层list逐个的append新的list，例如：
>>> blist=[]
>>> for i in range(4):
blist.append([j for j in range(3)])
>>> blist
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
这样，我们再试试上面的赋值操作：
>>> blist[0][0]=1
>>> blist
[[1, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
>>>
总结
以上就是本文关于深入理解Python中的*重复运算符的全部内容，希望对大家有所帮助。

