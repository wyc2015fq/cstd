# 图的存储 邻接矩阵+邻接表+链式前向星 - 紫芝的博客 - CSDN博客





2018年08月22日 23:52:55[紫芝](https://me.csdn.net/qq_40507857)阅读数：66








### 图的存储 — 邻接矩阵 

**在树的问题中，邻接矩阵是空间、时间的极大浪费。 假设树的结点个数为 N = 100000。**

**建立邻接矩阵需要空间为 1e5*1e5 但是由于只有 N - 1 条边，所以在邻接矩阵中只有 100000 - 1 个有效 信息。 **

**即只利用了邻接矩阵的 0.00001%，剩余空间全部被浪费。**

### 图的存储 — 邻接表 

**邻接表是最常用存储结构之一。 但是 vector(动态数组) 的时间效率较低 (较普通数组而言)。**

**那有没有一种用普通数组可以存储， 时间和空间都极佳的存储结构？**

### 链式前向星 

链式前向星是介于 **邻接矩阵** 和 **邻接表** 之间比较均衡的一种数据结构

```cpp
struct edge{
  int to;//存储该边指向的顶点
  int next;//存储下一条边的编号
}edge[maxn];
int head[maxn];
int cnt=0;
void add_edge(int u,int v)//建边，u->v
{
  edge[++cnt].next=head[u];//令next指向前一条边
  edge[cnt].to=v;//这条边的终点为v
  head[u]=cnt;//更新head
}
//建边
for(int i=0;i<n-1;i++)
{
  scanf("%d%d",&a,&b);
  add_edge(a,b);
  add_edge(b,a);
}
//DFS
for(int i=head[x];i!=0;i=edge[i].next){
  int son=edge[i].to;
  dfs(son);
}
```

```cpp
const int maxn=1e6+10;
struct edge
{
    int to;//这条边指向的顶点
    int next;
    int val;
}edge[maxn];
int cnt=0;
int head[maxn];
void addEdge(int from,int to,int val)
{
    edge[cnt].to=to;
    edge[cnt].val=val;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}
void init()
{
    memset(head,-1,sizeof head);
    cnt=0;
}
```





