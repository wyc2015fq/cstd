# 洛谷P3919可持久化线段树 - 紫芝的博客 - CSDN博客





2018年08月22日 22:35:31[紫芝](https://me.csdn.net/qq_40507857)阅读数：61








# P3919 【模板】可持久化数组（可持久化线段树/平衡树）
- **题目提供者**[HansBug](https://www.luogu.org/space/show?uid=1492) 站长团
- **评测方式****云端评测**
- **标签**O2优化高性能
- **难度**提高+/省选-
- **时空限制**3000ms / 512MB

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）

## 题目描述

如题，你需要维护这样的一个长度为 N 的数组，支持如下几种操作
- 
在某个历史版本上修改某一个位置上的值

- 
访问某个历史版本上的某一位置的值


此外，每进行一次操作（**对于操作2，即为生成一个完全一样的版本，不作任何改动**），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）

**输入格式：**

输入的第一行包含两个正整数 N M， 分别表示数组的长度和操作的个数。


第二行包含 N 个整数，依次为初始状态下数组各位的值（依次为 ai ，1 ≤ i ≤ N）。


接下来 M行每行包含 3 或 4 个整数，代表两种操作之一（ i 为基于的历史版本号）：


        1.对于操作1，格式为 vi 1 loci valuei，即为在版本 vi 的基础上，将 aloci 修改为 valuei。


        2.对于操作2，格式为 vi 2 loci，即访问版本 vi 中的 aloci 的值。

(1 <= N，M <= 105，1 <= loci <= N，1 <= vi <= i，- 109 <= ai，valuei <= 109)

**输出格式：**

输出包含若干行，依次为每个操作2的结果。

## 输入

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91
```

## 输出

```
59
87
41
87
88
46
```

**说明**

样例说明：

一共11个版本，编号从0-10，依次为：

* **0** : 59 46 14 87 41

* **1** : 59 46 14 87 41

* **2** : 14 46 14 87 41

* **3** : 57 46 14 87 41

* **4** : 88 46 14 87 41

* **5** : 88 46 14 87 41

* **6** : 59 46 14 87 41

* **7** : 59 46 14 87 41

* **8** : 88 46 14 87 41

* **9** : 14 46 14 87 41

* **10** : 59 46 14 87 91

### 可持久化线段树

给出 N 个数字的序列，M 次操作。

有两个操作： 1. 更新 i 点元素为 k，并保存版本 +1。

                       2. 查询 x 版本下点 i 的值。 起初为版本号为 0。

**可持久化线段树最大的特点是：**

可以访问历史版本。 简而言之，可持久化线段树，是在线段树上不断更新，但却 不删除原有信息的线段树。 每次更新都赋予一个新的根节点编号，用以区分不同的版本。

![](https://img-blog.csdn.net/20180822211849388?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180822212034982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/2018082221222758?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

由于可持续化线段树的结点的序号不确定。 因此需要采取动态开点的方法构建线段树

![](https://img-blog.csdn.net/20180822212429176?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
struct node{
  int lc,rc;
  long long int v;
}segtree[maxn << 8];//可持久化线段树
int root[maxn << 5];//root[i]表示版本号为i的线段树的根节点编号
long long int a[maxn];//长度为 N 的数组
int n,m;//n个点，m种操作
int tot;
 
int build_tree(int l, int r) {
  int pos = ++tot;
  if (l == r) {
    segtree[pos].v = a[l];
    return pos;
  }
  int mid = l + (r - l)/2;
  segtree[pos].lc = build_tree(l, mid);
  segtree[pos].rc = build_tree(mid + 1, r);
  return pos;
}
//即访问版本 pos 中的 a[p] 的值
long long int query(int pos, int p, int l, int r) {
  if (l == r) {
    return segtree[pos].v;
  }
  int mid = l + (r - l)/2;
  if(p <= mid) return query(segtree[pos].lc, p, l, mid);
  else return query(segtree[pos].rc, p, mid + 1, r);
}
//在版本 old 的基础上，将 a[tar] 修改为 c
int update(int old, int tar, int c, int l, int r) {
  int pos = ++tot;//新开节点时，需要依靠前面构建的节点编号+1
  if (l == r) {
    segtree[pos].v = c;
    return pos;
  }
  segtree[pos].lc = segtree[old].lc;
  segtree[pos].rc = segtree[old].rc;
  int mid = l + (r - l)/2;
  if(tar <= mid) segtree[pos].lc = update(segtree[old].lc, tar, c, l, mid);
  else segtree[pos].rc = update(segtree[old].rc, tar, c, mid + 1, r);
  return pos;
}
 
int main()
{
  //freopen("test.in", "r", stdin);
  //freopen("test.out", "w", stdout);
  while (scanf("%d %d", &n, &m) != EOF) {
    tot = 0;
    for (int i = 1;i <= n; i++){
      scanf("%lld", &a[i]);
    }
 
    root[0] = build_tree(1,n);
    int v,x,l,w;
 
    for (int i = 1;i <= m; i++){
      scanf("%d %d %d", &v, &x, &l);
      if (x == 1) {
        scanf("%d", &w);
        root[i] = update(root[v], l, w, 1, n);
      } else {
        root[i] = root[v];
        printf("%lld\n",query(root[v], l, 1, n));
      }
    }
  }
  return 0;
}
```





