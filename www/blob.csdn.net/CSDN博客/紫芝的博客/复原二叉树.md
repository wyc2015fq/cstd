# 复原二叉树 - 紫芝的博客 - CSDN博客





2018年07月19日 17:04:47[紫芝](https://me.csdn.net/qq_40507857)阅读数：94








## 复原二叉树

时间限制: 1 Sec  内存限制: 128 MB

## 题目描述

小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。

## 输入

输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。

## 输出

对于每组输入，输出对应的二叉树的后序遍历结果。

## 样例输入

```
DBACEGF ABCDEFG
BCAD CBAD
```

## 样例输出

```
ACBFGED
CDAB
```

### 已知二叉树的先序与中序，输出后序

前序最先出现总是根结点，root为前序中当前的根结点下标，并且同时在中序把二叉树分为左子树和右子树

start为当前需要打印的子树在中序中的最左边的下标，end 为当前需要打印的子树在中序中最右边的下标

```cpp
//已知二叉树的先序与中序，输出后序
/*
前序最先出现总是根结点，root为前序中当前的根结点下标
并且同时在中序把二叉树分为左子树和右子树
start为当前需要打印的子树在中序中的最左边的下标，
end 为当前需要打印的子树在中序中最右边的下标，
*/
#include<bits/stdc++.h>
using namespace std;
string pre;//前序
string in; //中序
void post(int root,int start,int end)
{
	//递归打印这棵树的后序，递归出口为 start > end
 	if(start>end)
 	return;
 	int i=start;//i为 root所代表的值在中序中的下标
 	while(i<end&&in[i]!=pre[root])
 	i++;
 	int cnt=i-start;//左子树结点个数
 	post(root+1,start,i-1);
	post(root+1+cnt,i+1,end);
	printf("%c",pre[root]);
 }
 int main()
 {
    while(cin>>pre>>in){
        int len=pre.length();
        post(0,0,len-1);
        printf("\n");
    }
 	return 0;
}
```





