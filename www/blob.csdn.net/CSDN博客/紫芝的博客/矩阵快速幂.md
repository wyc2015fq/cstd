# 矩阵快速幂 - 紫芝的博客 - CSDN博客





2018年05月09日 21:34:17[紫芝](https://me.csdn.net/qq_40507857)阅读数：40










先介绍一下矩阵乘法

![](https://img-blog.csdn.net/20180509212809999)

矩阵快速幂说是用来计算矩阵的高次幂的算法
将朴素的O(n)时间复杂度降到O(logn)




例如：计算矩阵A的6次方A*A*A*A*A*A
把6个矩阵两两分组(A*A)*(A*A)*(A*A)
这样的好处是只需要计算一次A*A，
然后将A*A的结果连乘自己两次，就得到A^6
一共计算三次，少于原来的5次，减少重复计算




离散化处理：
1.A^19=A^16*A^2*A^1
2.A^156=A^4*A^8*A^16*A^128
156=10011100(2)




```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long  ll;
const int maxn=110;
const int MOD=1e9+7;
#define mod(x) ((x)%MOD)
int n;
struct mat{
int m[maxn][maxn];
}unit;
mat operator *(mat a,mat b)
{
    mat ret;
    ll x;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
    {
        x=0;
        for(int k=0;k<n;k++)
            x+=mod( (ll) (a.m[i][k]*b.m[k][j]) );
            ret.m[i][j]=mod(x);
    }
    return ret;
}
void init_unit()
{
    for(int i=0;i<maxn;i++)
        unit.m[i][i]=1;//单位矩阵，主对角线上元素为1，其余元素为0
    return;
}
mat pow_mat(mat a,ll n)
{
    mat ret=unit;
    while(n){
        if(n&1) ret=ret*a;
        a=a*a;
        n>>=1;
    }
    return ret;
}
int main()
{
	ios::sync_with_stdio(false);
    ll x;
    init_unit();
    while(cin>>n>>x){
        mat a;
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
            cin>>a.m[i][j];
        a=pow_mat(a,x);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++)
            {
                if(j+1==n)  cout<<a.m[i][j]<<endl;
                else cout<<a.m[i][j]<<" ";
            }
        }
    }
	return 0;
}
```




