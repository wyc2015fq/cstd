# bzoj 1225 暴搜&动态规划 - 紫芝的博客 - CSDN博客





2018年04月14日 20:59:27[紫芝](https://me.csdn.net/qq_40507857)阅读数：34








[点击打开链接](https://www.lydsy.com/JudgeOnline/problem.php?id=1225)



## 1225: [HNOI2001] 求正整数
Time Limit: 10 Sec  Memory Limit: 162 MB
Submit: 835  Solved: 349
[[Submit](https://www.lydsy.com/JudgeOnline/submitpage.php?id=1225)][[Status](https://www.lydsy.com/JudgeOnline/problemstatus.php?id=1225)][[Discuss](https://www.lydsy.com/JudgeOnline/bbs.php?id=1225)]
## Description


对于任意输入的正整数n，请编程求出具有n个不同因子的最小正整数m。例如：n=4，则m=6，因为6有4个不同整数因子1，2，3，6；而且是最小的有4个因子的整数。


## Input


n（1≤n≤50000）


## Output


m


## Sample Input

4

## Sample Output

6
1.数据范围只有50000，计算可得约数的个数最多16个，先打出一张素数表


以后的素数对答案没有贡献 


2.dfs(x,y,z);
x表示搜索到的正整数，y表示x的因子个数，z表示已经搜索到了第z个质数


3.这样会超时，考虑剪枝
1.枚举当前质数的指数i时，y%(i+1)==0,那么就是求 y的因子数，
时间复杂度为sqrt(y);
2.当前质数的指数不可以为0，因为是从小到大搜索，还是比较有用
4.x是会爆long long的（比赛时用double卡的精度）如果搜索时加高精度就太麻烦了，
考虑用对数。log(n)=Σa[i]*log(pri[i]) 
5.在<float.h>中定义了浮点类型的范围：
#define DBL_MAX         1.7976931348623158e+308 
// max value 
#define DBL_MIN         2.2250738585072014e-308
//min positive value






![](https://img-blog.csdn.net/20180414205758607)





```cpp
#include<iostream>
#include<cstring>
#include<cfloat>
#include<cstdio>
#include<cmath>
using namespace std;
int n,ans[100005],res[21],tmp[21],pri[]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
double mn=DBL_MAX,lg[21];
void print()
{
	ans[0]=ans[1]=1;
	for(int i=1;i<=16;i++)
	{
		for(;res[i]>0;res[i]--)
		{
			for(int j=1;j<=ans[0];j++)
				ans[j]*=pri[i];
			for(int j=1;j<=ans[0];j++)
				ans[j+1]+=ans[j]/10,ans[j]%=10;
			if(ans[ans[0]+1]!=0)
				ans[0]++;
			while(ans[ans[0]]/10!=0)
				ans[ans[0]+1]+=ans[ans[0]]/10,ans[ans[0]]%=10,++ans[0];
		}
	}
	for(int i=ans[0];i>=1;i--)
		printf("%d",ans[i]);
	printf("\n");
}
void dfs(double x,int y,int z)//现在的数是e^x，还剩y个因子，选到第z个质数 
{
	if(x>=mn)
		return ;
	if(y==1)
	{
		mn=x;
		memset(res,0,sizeof(res));
		for(int i=1;i<=z-1;i++)
			res[i]=tmp[i];
		return ;
	}
	if(z>16)
		return ;
	for(int i=0;(i+1)*(i+1)<=y;i++)//找y的因子 
		if(y%(i+1)==0)
		{
			if(i!=0)
			{
				tmp[z]=i;
				dfs(x+lg[z]*i,y/(i+1),z+1);
			}
			if((i+1)*(i+1)!=y)
			{
				tmp[z]=y/(i+1)-1;
				dfs(x+lg[z]*(y/(i+1)-1),i+1,z+1);
			}
		}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=16;i++)
		lg[i]=log(pri[i]);
	dfs(0,n,1);
	print();
	return 0;
}
```



