# POJ1163数字三角形【简单动态规划】 - 紫芝的博客 - CSDN博客





2018年11月06日 18:39:56[紫芝](https://me.csdn.net/qq_40507857)阅读数：343








## The Triangle

[POJ - 1163](https://cn.vjudge.net/problem/10754/origin)

7
3   8
8   1   0
2   7   4   4
4   5   2   6   5

(Figure 1)
Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right. 

Input

Your program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of the triangle. The number of rows in the triangle is > 1 but <= 100. The numbers in the triangle, all integers, are between 0 and 99.

Output

Your program is to write to standard output. The highest sum is written as an integer.

Sample Input

5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
Sample Output

30
### 题意：

一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。

每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。

   5

  8 4

 3 6 9

7 2 9 5

例子中的最优方案是：5 + 8 + 6 + 9 = 28

### 分析：

这样就是向下走和向右下走！

f[i,j]表示从顶层到达第i层第j个位置的最大的得分 ，第i层第j个位置可以由**第i-1层的第j个位置**或者**第i-1层的第 j-1个位置**走过来

### 状态转移方程：f[i,j]=max(f[i-1,j],f[i-1,j-1])+a[i,j];

![](https://img-blog.csdnimg.cn/20181106183515934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20181106183541985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3,size_16,color_FFFFFF,t_70)

**对最后一行的f值进行扫描，最大的那一个即是结果**

```java
import java.util.*;
import java.math.*;
 
public class Main{
	static int MAXN=(int)(500+10);
	static int[][] a=new int[MAXN][MAXN];
	static int n;
	static long[][] dp=new long[MAXN][MAXN];
	static void init() {
		for(int i=0;i<MAXN;i++)
			for(int j=0;j<MAXN;j++)
			dp[i][j]=0;
	}
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		while(cin.hasNext()) {
			n=cin.nextInt();
			if(n==0)	break;
			for(int i=1;i<=n;i++) {
				for(int j=1;j<=i;j++)
					a[i][j]=cin.nextInt();
			}
			init();
			for(int i=1;i<=n;i++) {
				for(int j=1;j<=i;j++) {
					dp[i][j]=Math.max(dp[i-1][j-1], dp[i-1][j])+a[i][j];
				}
			}
			long ans=-1;
			for(int i=1;i<=n;i++)
				ans=Math.max(ans, dp[n][i]);
			System.out.println(ans);
		}
		cin.close();
	}
}
```





