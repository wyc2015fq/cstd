# HDU1257 最少拦截系统  贪心或动态规划 - 紫芝的博客 - CSDN博客





2018年07月24日 21:39:50[紫芝](https://me.csdn.net/qq_40507857)阅读数：55








# 最少拦截系统

****Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 55679    Accepted Submission(s): 21814****

**Problem Description**

某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.

怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.

**Input**

输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度

(雷达给出的高度数据是不大于30000的正整数,用空格分隔)

**Output**

对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.

**Sample Input**

8 

389 207 155 300 299 170 158 65

8

7  6  5  6  3  2  4  1

**Sample Output**

2

2

**Source**

[浙江工业大学第四届大学生程序设计竞赛](http://acm.hdu.edu.cn/search.php?field=problem&key=%D5%E3%BD%AD%B9%A4%D2%B5%B4%F3%D1%A7%B5%DA%CB%C4%BD%EC%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%BE%BA%C8%FC&source=1&searchmode=source)

**Recommend**

JGShining   |   We have carefully selected several similar problems for you:  [1176](http://acm.hdu.edu.cn/showproblem.php?pid=1176)[1159](http://acm.hdu.edu.cn/showproblem.php?pid=1159)[1087](http://acm.hdu.edu.cn/showproblem.php?pid=1087)[1203](http://acm.hdu.edu.cn/showproblem.php?pid=1203)[1069](http://acm.hdu.edu.cn/showproblem.php?pid=1069)

### 解法一：

贪心策略：首先至少需要一套系统，第一套系统的最大发射高度为第一个飞机的高度，

对于后面的飞机，若当前有一套系统发射高度大于等于飞机高度，则这套系统的发射高度更新为飞机高度

若没有一套系统发射高度大于等于飞机的高度，则需要新的系统，且新系统的发射高度为飞机高度。

```cpp
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int a[110];//保存每套系统的发射高度
int main()
{
    int n;
    while(cin>>n){
        int x;
        int cnt=1;//至少需要一套设备
        bool flag=false;
        cin>>a[0];
        for(int i=1;i<n;i++)
        {
            flag=false;
            cin>>x;
            for(int j=0;j<cnt;j++)
            {
                if(a[j]>x){
                    a[j]=x;//a[j]以后能发射的最大高度
                    flag=true;//不需要新的设备
                    break;
                }
            }
            //没有找到，选新的系统
            if(!flag)   a[cnt++]=x;
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```

### 解法二：

动态规划，LIS（Longest increasing subsequence）[最长上升子序列](https://blog.csdn.net/qq_40507857/article/details/81198662)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXX=100000+5;
const int INF=INT_MAX;

int a[MAXX],dp[MAXX];
// a数组为数据，dp[i]表示以a[i]结尾的最长递增子序列长度

int main()
{
    int n;
    while(cin>>n)
    {
        for(int i=0; i<n; i++)
        {
            cin>>a[i];
            dp[i]=1; // 初始化为1，长度最短为自身
        }
        int ans=1;
        for(int i=1; i<n; i++)//枚举子序列的终点
        {
            for(int j=0; j<i; j++)//从头向终点检查每一个元素
            {
                if(a[i]>a[j])
                {
                    dp[i]=max(dp[i],dp[j]+1);  // 状态转移
                }
            }
            ans=max(ans,dp[i]);  // 比较每一个dp[i],最大值为答案
        }
        cout<<ans<<endl;
    }
    return 0;
}
```





