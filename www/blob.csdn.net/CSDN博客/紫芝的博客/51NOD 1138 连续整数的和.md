# 51NOD 1138 连续整数的和 - 紫芝的博客 - CSDN博客





2018年05月12日 16:53:39[紫芝](https://me.csdn.net/qq_40507857)阅读数：26








[点击打开链接](https://cn.vjudge.net/contest/228540#problem/I)


给出一个正整数N，将N写为若干个连续数字和的形式(长度 >= 2)。

例如N = 15，可以写为1 + 2 + 3 + 4 + 5，也可以写为4 + 5 + 6，或7 + 8。

如果不能写为若干个连续整数的和，则输出No Solution。




Input 

输入1个数N(3 <= N <= 10^9)。

            Output 

输出连续整数中的第1个数，如果有多个按照递增序排列，如果不能分解为若干个连续整数的和，则输出No Solution。

            Sample Input        15            Sample Output        1
4
7

## 解题思路: 


因为它是连续的序列所以他一定是一个公差为 1 的等差数列，那么输入的 x 就满足 




x=a1*n+n*(n-1)/2;


所以 我们要求的就是a1,所以 a1可以解得： 


a1=( 2*x-n*(n-1) ) / 2*n




首项为1，公差为1的等差数列求和公式为：x=(n+1)*n/2

那么我们只需要从 2*sqrt(n)开始判断就行了    for(int i=sqrt(n)*2; i>=2; i–) 



又因为不能是单独的一个数，所以是>=2。




```cpp
#include<bits/stdc++.h>
#include<bitset>
#include<cmath>
using namespace std;
const int maxn=1e5+5;

int main()
{
	ios::sync_with_stdio(0);
	int x;
	while(cin>>x){
        bool flag=0;
        int m=2*(int)sqrt(x);
	for(int n=m;n>=2;n--)
    {
        if((2*x-n*(n-1))%(2*n)==0&&(2*x-n*(n-1))>0)
            cout<<(2*x-n*(n-1))/(2*n)<<endl,flag=1;
    }
    if(!flag)   cout<<"No Solution\n";
	}
	return 0;
}
```






