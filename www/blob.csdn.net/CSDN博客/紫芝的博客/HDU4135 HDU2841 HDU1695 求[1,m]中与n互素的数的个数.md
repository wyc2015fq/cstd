# HDU4135 HDU2841 HDU1695 求[1,m]中与n互素的数的个数 - 紫芝的博客 - CSDN博客





2018年09月20日 16:05:50[紫芝](https://me.csdn.net/qq_40507857)阅读数：39








### [求n的质因子](https://blog.csdn.net/qq_40507857/article/details/82859117)

### 模板：求1-m之间与n互素的数的个数

```cpp
vector<ll>p;
//返回1-m中与n互素的数的个数
ll cal(ll n,ll m)
{
    p.clear();
    for(int i=2;i*i<=n;i++){
        if(n%i==0)
        {
            p.push_back(i);
            while(n%i==0)   n/=i;
        }
    }
    if(n>1) p.push_back(n);//求n的素因子

    int num=p.size();//素因子的个数
    int maxs=1<<num;//从中选出一些质因子，就是生成子集，子集最多的个数
    ll s=0;//1到m中与n不互素的数的个数
    
    //枚举子集，不能有空集，所以从1开始
    for(ll i=1;i<maxs;i++){//从1枚举到(2^素因子个数)
        ll cnt=0;
        ll mul=1;
       for(ll j=0;j<num;j++){//枚举每个素因子
           if(i&(1<<j)){//有第i个因子
            cnt++;//计数
            mul*=p[j];//乘上这个质因子
           }
       }
       
       //容斥原理
       if(cnt&1) //选取个数为奇数，加
        s+=m/mul;
       else     //选取个数为偶数，减
        s-=m/mul;
    }
    return m-s;//返回1-m中与n互素的数的个数
}
```

### **HDU4135**

**Given a number N, you are asked to count the number of integers between A and B inclusive which are relatively prime to N. Two integers are said to be co-prime or relatively prime if they have no common positive divisors other than 1 or, equivalently, if their greatest common divisor is 1. The number 1 is relatively prime to every integer.**

**Input**

**The first line on input contains T (0 < T <= 100) the number of test cases, each of the next T lines contains three integers A, B, N where (1 <= A <= B <= 10 15) and (1 <=N <= 10 9).**

**Output**

**For each test case, print the number of integers between A and B inclusive which are relatively prime to N. Follow the output format below.**

**Sample Input**

```
2
1 10 2
3 15 5
```

**Sample Output**

```
Case #1: 5
Case #2: 10
```

**Hint**

```
In the first test case, the five integers in range [1,10] which are relatively prime to 2 are {1,3,5,7,9}.
```



 题意：

求区间[a,b]中与n互素的数字个数

分析：

考虑一下逆向问题：求1-m之间与n不互素的个数，不互素则一定至少有一个素因子。这样就可以枚举n的素因子，然后计算[a,b]区间有多少个n的素因子，其实这并不好算。

考虑[1,a-1]和[1,b]两个区间与n互素的个数，答案就是二者之差。互素的个数等于总数减去不互素的个数，然后问题转换为**容斥原理**经典问题：**求1-m中与n互素的数的个数**

如果1-m中某个数与n不互素，那么一定可以被n的某个因子整除，所以先枚举n的所有素因子。

举个例子，n=12,m=8，12的素因子是2，3，1-8中有几个是2的倍数呢？num2=8/2=4;  1-8中有几个是3的倍数呢？num3=8/3=2，那么1-8之间与12互素的个数是2+4=6个数字吗？1-8之间与12不互素的是2，3，4，6，8，共5个数字，这是因为同为2和3的倍数的6被计算了两次，所以要再减去一次num6=8/6,结果是 8/2+8/3-8/(2*3).

结论：**如果是奇数个组合，那么符号是加；如果是偶数个组合，那么符号是减；**

AC　ｃｏｄｅ

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

vector<ll>p;
//返回1-m中与n互素的数的个数
ll fun(ll n,ll m)
{
    p.clear();
    for(int i=2;i*i<=n;i++){
        if(n%i==0)
        {
            p.push_back(i);
            while(n%i==0)   n/=i;
        }
    }
    if(n>1) p.push_back(n);//求n的素因子

    int num=p.size();//素因子的个数
    ll s=0;//1到m中与n不互素的数的个数
    for(ll i=1;i<(1<<num);i++){//从1枚举到(2^素因子个数)
        ll cnt=0;
        ll mul=1;
       for(ll j=0;j<num;j++){//枚举每个素因子
           if(i&(1<<j)){//若对应位置为1，那么计入
            cnt++;
            mul*=p[j];
           }
       }
       //容斥原理
       if(cnt&1) //选取个数为奇数，加
        s+=m/mul;
       else     //选取个数为偶数，减
        s-=m/mul;
    }
    return m-s;//返回1-m中与n互素的数的个数
}

int main()
{
    int T,ca=0;
    scanf("%d",&T);
    while(T--){
        ll n,a,b;
        scanf("%lld%lld%lld",&a,&b,&n);
        ll ans=fun(n,b)-fun(n,a-1);
        printf("Case #%d: %lld\n",++ca,ans);
    }
    return 0;
}
```

### ＨＤＵ２８４１

There are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see. 


If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him.

Input

The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000)

Output

For each test case output one line represents the number of trees Farmer Sherlock can see.

Sample Input

```
2
1 1
2 3
```

Sample Output

```
1
5
```

 题意：

给一个ｎ＊ｍ的矩阵，左下角为（１，１），右上角为（ｎ，ｍ），问从（０，０）点可以看到多少个点。

分析：

如果ｇｃｄ（ｘ，ｙ）＝ｇ，ｇ！＝１，那么一定被（ｘ／ｇ，ｙ／ｇ）的点挡住

两个数字(x,y)如果两数互质，则可以被看到；如果不互质，则看不到，所以我们就是要找出所有的互质二元组(x,y)

我们可以固定一个数字，用一个数来循环。例如矩阵为n*m，我们固定m，用n来循环，即1与[1,m]里面多少个数互质，2与[1,m]里面多少个数互质，3与[1,m]里面多少个数互质……n与[1,m]里面多少个数互质，把这些结果全部累加起来即可

所以问题的最后变为了，给定一个数字x，找出它和1到y里面有多少个数互质

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

vector<ll>p;
//返回1-m中与n互素的数的个数
ll fun(ll n,ll m)
{
    p.clear();
    for(int i=2;i*i<=n;i++){
        if(n%i==0)
        {
            p.push_back(i);
            while(n%i==0)   n/=i;
        }
    }
    if(n>1) p.push_back(n);//求n的素因子

    int num=p.size();//素因子的个数
    ll s=0;//1到m中与n不互素的数的个数
    for(ll i=1;i<(1<<num);i++){//从1枚举到(2^素因子个数)
        ll cnt=0;
        ll mul=1;
       for(ll j=0;j<num;j++){//枚举每个素因子
           if(i&(1<<j)){//若对应位置为1，那么计入
            cnt++;
            mul*=p[j];
           }
       }
       //容斥原理
       if(cnt&1) //选取个数为奇数，加
        s+=m/mul;
       else     //选取个数为偶数，减
        s-=m/mul;
    }
    return m-s;//返回1-m中与n互素的数的个数
}
int main()
{
    int T,ca=0;
    scanf("%d",&T);
    while(T--){
        ll a,b;
        scanf("%lld%lld",&a,&b);

        ll ans=0;
        for(int i=1;i<=a;i++)
        {
            ans+=fun(i,b);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

### HDU1695 

Given 5 integers: a, b, c, d, k, you're to find x in a...b, y in c...d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you're only required to output the total number of different number pairs. 

Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same. 

**Yoiu can assume that a = c = 1 in all test cases.**

Input

The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases. 

Each case contains five integers: a, b, c, d, k, 0 < a <= b <= 100,000, 0 < c <= d <= 100,000, 0 <= k <= 100,000, as described above. 

Output

For each test case, print the number of choices. Use the format in the example. 

Sample Input

2
1 3 1 5 1
1 11014 1 14409 9
Sample Output

Case 1: 9
Case 2: 736427

Hint

For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5).

题意：![x\sqsubseteq [1,b],y\sqsubseteq [1,d]](https://private.codecogs.com/gif.latex?x%5Csqsubseteq%20%5B1%2Cb%5D%2Cy%5Csqsubseteq%20%5B1%2Cd%5D)  ,求gcd(x,y)=k的(x,y)的个数

分析：显然，等价于求b，d同时除以k，求gcd(x,y)=1的个数，因为(1,3)和(3,1)是一种情况，所以要限制(x<y)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<ll>p;
ll cal(ll n,ll m)
{
    p.clear();
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0){
            p.push_back(i);
            while(n%i==0) n/=i;
        }
    }
    if(n>1) p.push_back(n);

    int num=p.size();
    ll maxs=1<<num;
    ll s=0;
    for(ll i=1;i<maxs;i++){
        ll cnt=0;
        ll mul=1;
        for(ll j=0;j<num;j++){
            if(i&(1<<j)){
                cnt++;
                mul*=p[j];
            }
        }
        if(cnt&1)   s+=m/mul;
        else    s-=m/mul;
    }
    return m-s;
}
int main()
{
    int T,ca=0;
    scanf("%d",&T);
    while(T--){
        ll a,b,c,d,k;
        scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&k);
        if(!k)
        {
            printf("Case %d: 0\n",++ca);
            continue;
        }
        b/=k;d/=k;
        if(b>d) swap(d,b);
        ll ans=0;

        for(ll i=1;i<=d;i++)
        {
            ll k=min(i,b);//求区间[1,k]内与i互质的个数
           ans+=cal(i,k);
        }
        printf("Case %d: %lld\n",++ca,ans);
    }
    return 0;
}
```





