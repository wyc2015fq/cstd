# 树链剖分 - 紫芝的博客 - CSDN博客





2018年08月22日 23:20:33[紫芝](https://me.csdn.net/qq_40507857)阅读数：23
个人分类：[数据结构																[线段树](https://blog.csdn.net/qq_40507857/article/category/7569707)](https://blog.csdn.net/qq_40507857/article/category/7837948)








### **树链剖分**

**实质上就是将一棵树分割成多条链，然后再利用数据 结构维护这些链(线段树，树状数组等)。**

一些名词：

**重结点：**子树结点数目最多的结点；

**轻结点：**父亲节点中除了重结点以外的结点；

**重边：**父亲结点和重结点连成的边；

**轻边：**父亲节点和轻节点连成的边；

**重链：**由多条重边连接而成的路径；

**轻链：**由多条轻边连接而成的路径；

![](https://img-blog.csdn.net/20180822231219721?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

粗线相连的为重结点。其余都 是轻结点；每段粗线都是重边， 每条粗线都是重链。

红点标记的是每条重链的起点， 也就是下面我们要讲到的 top。

**名称 解释 **

![](https://img-blog.csdn.net/20180822231720695?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 题目描述

已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

操作1： 格式： 1 x y z 表示将树从 x 到 y 结点最短路径上所有节点的值都加上 z

操作2： 格式： 2 x y 表示求树从 x 到 y 结点最短路径上所有节点的值之和

操作3： 格式： 3 x z 表示将以 x 为根节点的子树内所有节点值都加上 z

操作4： 格式： 4 x 表示求以 x 为根节点的子树内所有节点值之和

## 输入

第一行包含 4 个正整数 N、M、R、P，分别表示树的结点个数、操作个数、根节点序号和取模数（即所有的输出结果均对此取模）。

接下来一行包含 N 个非负整数，分别依次表示各个节点上初始的数值 Ai。

接下来 N - 1 行每行包含两个整数 x、y，表示点 x 和点 y 之间连有一条边（保证无环且连通）

接下来 M 行每行包含若干个正整数，每行表示一个操作，格式如下：

操作1： 1 x y z

操作2： 2 x y

操作3： 3 x z

操作4： 4 x

( 1 ≤ N，M ≤ 105，1 ≤ R ≤ N，1 ≤ P ≤ 109，0 ≤ Ai ≤ 109)

## 输出

输出包含若干行，分别依次表示每个操作 2 或操作 4 所得的结果（对 P 取模）

## 样例输入

5 5 2 24
7 3 7 8 0 
1 2
1 5
3 1
4 1
3 4 2
3 2 2
4 5
1 5 1 3
2 1 3
## 样例输出

2
21

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
typedef long long ll;
struct edge
{
int to,next;
}edge[maxn<<2];
struct node
{
    ll sum,lazy;
}segtree[maxn<<2];
int head[maxn];//头节点
int tot;

int fa[maxn];//fa[u]保存节点u的父亲节点
int zson[maxn];//保存重儿子
int dep[maxn];//dep[u]保存节点u的深度值
int rnk[maxn];//保存当前节点在树中的位置
int size[maxn];//size[u]保存以u为根的子树节点的个数
int dfsid[maxn];//保存树中每个节点剖分以后的新编号（DFS序）
int top[maxn];//top[u]保存当前节点所在链的顶端节点
int a[maxn];
int n,m,r,p,x,y,z,op,dfsnum;
void add_edge(int a, int b) {
  edge[++tot].next = head[a];
  edge[tot].to = b;
  head[a] = tot;
}

void init() {
  memset(head, 0, sizeof head);
  memset(segtree, 0, sizeof segtree);
  memset(edge, 0, sizeof edge);
  memset(fa, 0, sizeof fa);
  memset(zson, 0, sizeof zson);
  memset(dep, 0, sizeof dep);
  memset(rnk, 0, sizeof rnk);
  memset(size, 0, sizeof size);
  memset(dfsid, 0, sizeof dfsid);
  memset(top, 0, sizeof top);
  memset(a, 0, sizeof a);
}

int dfs1(int x = r, int f = -1, int deep = 0) {
  fa[x] = f;
  dep[x] = deep;
  size[x] = 1;

  for (int i = head[x]; i; i = edge[i].next) {
    int son = edge[i].to;
    if (son == f) continue;
    size[x] += dfs1(son, x, deep + 1);
    if(size[son] > size[zson[x]]) {
      zson[x] = son;
    }
  }

  return size[x];
}

void dfs2(int x = r, int t = r) {
  top[x] = t;
  dfsid[x] = ++dfsnum;
  rnk[dfsnum] = x;

  if(zson[x] == 0) return;//size == 1?
  dfs2(zson[x], t);

  for (int i = head[x]; i; i = edge[i].next) {
    int son = edge[i].to;
    if (son == fa[x] || son == zson[x]) continue;
    dfs2(son, son);
  }
}

void pushup(int now) {
  segtree[now].sum = segtree[now << 1].sum + segtree[(now << 1)|1].sum;
}

void pushdown(int now, int l, int r) {
  if (segtree[now].lazy == 0) return;
  segtree[now << 1].lazy += segtree[now].lazy;
  segtree[(now << 1)|1].lazy += segtree[now].lazy;
  int mid = l + (r - l)/2;
  segtree[now << 1].sum += segtree[now].lazy*(mid - l + 1);
  segtree[(now << 1)|1].sum += segtree[now].lazy*(r - mid);
  segtree[now].lazy = 0;
}

void build_tree(int l, int r, int now) {
  segtree[now].sum = segtree[now].lazy = 0;
  if (l == r) {
    segtree[now].sum = a[rnk[l]];
    return;
  }
  int mid = l + (r - l)/2;
  build_tree(l, mid, now << 1);
  build_tree(mid + 1, r, (now << 1)|1);
  pushup(now);
}

long long int query(int L, int R, int now = 1, int l = 1, int r = n) {
  if (L <= l && R >= r) {
    return segtree[now].sum;
  }
  pushdown(now, l, r);
  int mid = l + (r - l)/2;
  long long int ans = 0;
  if (L <= mid) ans += query(L, R, now << 1, l, mid);
  if (R > mid) ans += query(L, R, (now << 1)|1, mid + 1, r);
  return ans%p;
}

void update(int L, int R, int c, int l = 1, int r = n, int now = 1) {
  if (L <= l && R >= r) {
    segtree[now].sum += c*(r - l + 1);
    segtree[now].lazy += c;
    return;
  }
  pushdown(now, l, r);
  int mid = l + (r - l)/2;
  if (L <= mid) update(L, R, c, l, mid, now << 1);
  if (R > mid) update(L, R, c, mid + 1, r, (now << 1)|1);
  pushup(now);
  return;
}

long long int sum(int x, int y) {
  long long int ans = 0;
  int tx = top[x], ty = top[y];
  while (tx != ty) {
    if (dep[tx] >= dep[ty]) {
      ans += query(dfsid[tx], dfsid[x]);
      x = fa[tx];
    } else {
      ans += query(dfsid[ty], dfsid[y]);
      y = fa[ty];
    }
    ans %= p;
    tx = top[x], ty = top[y];
  }

  if (dep[x] <= dep[y]) {
    ans += query(dfsid[x], dfsid[y]);
  } else {
    ans += query(dfsid[y], dfsid[x]);
  }
  return ans%p;
}

void updates(int x, int y, int c) {
  int tx = top[x], ty = top[y];
  while (tx != ty) {
    if (dep[tx] >= dep[ty]) {
      update(dfsid[tx], dfsid[x], c);
      x = fa[tx];
    } else {
      update(dfsid[ty], dfsid[y], c);
      y = fa[ty];
    }
    tx = top[x], ty = top[y];
  }

  if (dep[x] <= dep[y]) {
    update(dfsid[x], dfsid[y], c);
  } else {
    update(dfsid[y], dfsid[x], c);
  }
}

void print(char s[10], int *size) {
  printf("%s : ",s);
  for (int i = 1; i <= n; i++) {
    printf("%d ",size[i]);
  }
  printf("\n");
}

int main()
{
  //freopen("test.in", "r", stdin);
  //freopen("test.out", "w", stdout);

  while (scanf("%d %d %d %d", &n, &m, &r, &p) != EOF) {
    init();
    tot = dfsnum = 0;
    for (int i = 1; i <= n; i++) {
      scanf("%d", &a[i]);
    }
    for (int i = 0; i < n - 1; i++) {
      scanf("%d %d", &x, &y);
      add_edge(x, y);
      add_edge(y, x);
    }

    dfs1();
    dfs2();
    build_tree(1, n, 1);


    for (int i = 0; i < m; i++) {
      scanf("%d", &op);
      if (op == 1) {
        scanf("%d %d %d", &x, &y, &z);
        updates(x, y, z);
      } else if (op == 2) {
        scanf("%d %d", &x, &y);
        printf("%lld\n",sum(x, y)%p);
      } else if (op == 3) {
        scanf("%d %d", &x, &z);
        update(dfsid[x], dfsid[x] + size[x] - 1, z);
      } else {
        scanf("%d", &x);
        printf("%lld\n", query(dfsid[x], dfsid[x] + size[x] - 1)%p);
      }
    }
  }

  return 0;
}
```






