# 入侵和反击 动态规划 - 紫芝的博客 - CSDN博客





2018年07月24日 23:27:34[紫芝](https://me.csdn.net/qq_40507857)阅读数：21
个人分类：[动态规划																[解题模板](https://blog.csdn.net/qq_40507857/article/category/7565904)](https://blog.csdn.net/qq_40507857/article/category/7565832)








## 入侵和反击

时间限制: 1 Sec  内存限制: 128 MB

## 题目描述

A国部署的反导系统遇到了一个致命BUG，那就是每一次发射的拦截导弹的飞行高度都将只能小于等于上一枚导弹的飞行高度，第一次发射的拦截导弹的飞行高度可以看作是足够大。对于A国，这是一件很严重的问题，这意味着A国的防空系统面临空前危机。

通过对A国的军事部门计算机的入侵，A国还不知道敌对国B国刚才已经发现了这项BUG。更不知道，在这项BUG的报告书上交到B国空军司令部那一刻，三分钟后B国的全体高级空军军官已经在作战室讨论作战方案。

如果战争真的开始，B国将依次派出n架战斗机A国将依次发射拦截导弹，这n架飞机的飞行高度分别是h1h2h3.....hn。B国将要充分利用这项漏洞，考虑到这么一种情况，假设只要A国的导弹的飞行高度大于等于B国飞机就能百分之百地锁定并击落，那么B国，最少将会有几架不被击落飞机？

## 输入

第一行为T，表示有T组输入数据(T<200)。

每组数据第一行是n代表有n架飞机（1=<n<=20 000）。

接下来一行有n个数，分别代表n架飞机的飞行高度，飞机飞行高度maxh为(1<=maxh<=50 000)。

## 输出

对于每组测试数据，在每行中输出一个数。表示B国最少将会有几架未被击落飞机。

## 样例输入

```
2
1
1000
6
340 260 101 405 278 89
```

## 样例输出

0

2

分析：

动态规划基础题目，求一个最长上升子序列，总序列长度减去上升子序列长度，即为答案

解法1：时间复杂度：O（n^2）

```cpp
#include<stdio.h>
#define MAXN 20010
int dp[MAXN], a[MAXN];
int main()
{
    int n, i, j, t, temp;
    int max, min;
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        for (i = 1; i <= n; i++)
            scanf("%d", &a[i]);
        dp[1] = 1;
    //  max=5000;
        for (i = 2; i <= n; i++)
        {
            temp = 0;
            for (j = 1; j < i; j++)
                if (a[i] <= a[j])
                    if (temp < dp[j])
                        temp = dp[j];
            dp[i] = temp + 1;
        }
        max = 0;
        for (i = 1; i <= n; i++)
            if (max < dp[i])
                max = dp[i];
        min = n - max;
        printf("%d\n", min);
    }
    return 0;
}
```

解法2：时间复杂度O（n^2）

```cpp
//lower_bound返回区间[first, last)内第一个不小于（即大于或等于）给定值的元素指针
//upper_bound返回区间[first, last)内第一个大于给定值的元素指针
#include<stdio.h>
#include<algorithm>
#include<cstring>
using namespace std;
int num[20100],lis[20100];
int main()
{
    int n,len,T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        len = 0;
        memset(lis,0,sizeof(lis));
        for(int i=n-1;i>=0;i--)
//如果i是从1开始，在lower_bound中的到的位置会返回到0，
//这样就不可以把lis[1]的位置替换掉，从而WA。
            scanf("%d",&num[i]);
        lis[0] = num[0];
        for(int i=1;i<n;i++)
        {
            if(num[i] >= lis[len])
//如果num比lis[len]选择的终点大，则可以放入lis，即新的终点。
                lis[++len] = num[i];
            else
            {
                int pos = upper_bound(lis,lis+len,num[i]) - lis;
//注意lower_bound 的用法，lower_bound返回的是一个地址
                lis[pos] = num[i];
            }
        }

        printf("%d\n",n-len-1);//len是从0开始的，所以要加上1。
    }
}
```






