# HDU 3435 无向环最小权值覆盖 - 紫芝的博客 - CSDN博客





2018年10月07日 21:03:32[紫芝](https://me.csdn.net/qq_40507857)阅读数：40
个人分类：[最小费用最大流](https://blog.csdn.net/qq_40507857/article/category/8104975)









An undirected graph is a graph in which the nodes are connected by undirected arcs. An undirected arc is an edge that has no arrow. Both ends of an undirected arc are equivalent--there is no head or tail. Therefore, we represent an edge in an undirected graph as a set rather than an ordered pair. 

Now given an undirected graph, you could delete any number of edges as you wish. Then you will get one or more connected sub graph from the original one (Any of them should have more than one vertex). 

You goal is to make all the connected sub graphs exist the Hamiltonian circuit after the delete operation. What’s more, you want to know the minimum sum of all the weight of the edges on the “Hamiltonian circuit” of all the connected sub graphs (Only one “Hamiltonian circuit” will be calculated in one connected sub graph! That is to say if there exist more than one “Hamiltonian circuit” in one connected sub graph, you could only choose the one in which the sum of weight of these edges is minimum). 

  For example, we may get two possible sums: 

![](https://odzkskevi.qnssl.com/8b03332ed6041dddbe68b6b7d7e99827?v=1538752021)



(1)  7 + 10 + 5 = 22 

(2)  7 + 10 + 2 = 19 

(There are two “Hamiltonian circuit” in this graph!)

Input

In the first line there is an integer T, indicates the number of test cases. (T <= 20) 

In each case, the first line contains two integers n and m, indicates the number of vertices and the number of edges. (1 <= n <=1000, 0 <= m <= 10000) 

Then m lines, each line contains three integers a,b,c ,indicates that there is one edge between a and b, and the weight of it is c . (1 <= a,b <= n, a is not equal to b in any way, 1 <= c <= 10000) 

Output

Output “Case %d: “first where d is the case number counted from one. Then output “NO” if there is no way to get some connected sub graphs that any of them exists the Hamiltonian circuit after the delete operation. Otherwise, output the minimum sum of weight you may get if you delete the edges in the optimal strategy. 


Sample Input

3

3 4
1 2 5
2 1 2
2 3 10
3 1 7 

3 2
1 2 3
1 2 4

2 2
1 2 3
1 2 4
Sample Output

Case 1: 19
Case 2: NO
Case 3: 6

        
 
Hint

In Case 1:
You could delete edge between 1 and 2 whose weight is 5. 

In Case 2:
It’s impossible to get some connected sub graphs that any of them exists the Hamiltonian circuit after the delete operation.

最小费用最大流

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
typedef long long LL;

const int maxn=2000+5;
const int INF=0x3f3f3f3f;

int map[maxn][maxn];

struct Edge
{
    int from, to, cap, flow, cost;
    Edge(int u, int v, int c, int f, int w) :from(u), to(v), cap(c), flow(f), cost(w) {}
};

struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];
    int d[maxn];
    int p[maxn];
    int a[maxn];

    void init(int n)
    {
        this->n = n;
        for (int i = 0; i<n; i++) G[i].clear();
        edges.clear();
    }

    void AddEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge(from, to, cap, 0, cost));
        edges.push_back(Edge(to, from, 0, 0, -cost));
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool BellmanFord(int s, int t, int &flow, LL & cost)
    {
        for (int i = 0; i<n; i++) d[i] = INF;
        memset(inq, 0, sizeof(inq));
        d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;

        queue<int> Q;
        Q.push(s);
        while (!Q.empty()){
            int u = Q.front(); Q.pop();
            inq[u] = 0;
            for (int i = 0; i<G[u].size(); i++){
                Edge& e = edges[G[u][i]];
                if (e.cap>e.flow && d[e.to]>d[u] + e.cost){
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if (!inq[e.to]) { Q.push(e.to); inq[e.to] = 1; }
                }
            }
        }
        if (d[t] == INF) return false;
        flow += a[t];
        cost += (LL)d[t] * (LL)a[t];
        for (int u = t; u != s; u = edges[p[u]].from){
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];

        }
        return true;
    }

    int MincostMaxdflow(int s, int t, LL & cost)
    {
        int flow = 0; cost = 0;
        while (BellmanFord(s, t, flow, cost) );
        return flow;
    }
}t;

int n,m;

int main()
{
    //freopen("D:\\input.txt", "r", stdin);
    int T;
    int kase=0;
    scanf("%d",&T);
    int u,v,d;
    while(T--)
    {
        memset(map,0,sizeof(map));
        scanf("%d%d",&n,&m);
        int src=0,dst=2*n+1;
        t.init(dst+1);
        for(int i=1;i<=n;i++)
        {
            t.AddEdge(src,i,1,0);
            t.AddEdge(i+n,dst,1,0);
        }
        for(int i=0;i<m;i++)
        {
            scanf("%d%d%d",&u,&v,&d);
            if(map[u][v]==0 || map[u][v]>d)
            {
                t.AddEdge(u,v+n,1,d);
                t.AddEdge(v,u+n,1,d);
                map[u][v]=map[v][u]=d;
            }
        }
        long long cost;
        int flow=t.MincostMaxdflow(src,dst,cost);
        printf("Case %d: ",++kase);
        if(flow==n)  printf("%d\n",cost);
        else printf("NO\n");
    }
    return 0;
}
```

KM算法

```cpp
#include<cstdio>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
const int maxn=1e4+10;
int n,m;
int w[maxn][maxn];
int lx[maxn],ly[maxn];
int link[maxn];
int slack[maxn];
int visx[maxn],visy[maxn];
bool dfs(int x)
{
    visx[x]=1;
    for(int y=1;y<=n;y++){
        if(visy[y]) continue;
        int t=lx[x]+ly[y]-w[x][y];
        if(t==0){
            visy[y]=1;
            if(link[y]==0||dfs(link[y])){
                link[y]=x;
                return 1;
            }
        }
        else if(slack[y]>t) slack[y]=t;
    }
    return 0;
}
int km()
{
    memset(lx,0,sizeof lx);
    memset(ly,0,sizeof ly);
    memset(link,0,sizeof link);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        if(lx[i]<w[i][j])
        lx[i]=w[i][j];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            slack[j]=INF;
        while(1){
            memset(visx,0,sizeof visx);
            memset(visy,0,sizeof visy);
            if(dfs(i))  break;
            int d=INF;
            for(int k=1;k<=n;k++)
                if(!visy[k]&&d>slack[k])
                d=slack[k];
            for(int k=1;k<=n;k++){
                if(visx[k]) lx[k]-=d;
                if(visy[k]) ly[k]+=d;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(w[link[i]][i]==-INF) return -1;
        ans+=w[link[i]][i];
    }
    return -ans;
}
int main()
{
    int T;
    scanf("%d",&T);
    int ca=1;
    while(T--){
          scanf("%d%d",&n,&m);
        int u,v,cost;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            w[i][j]=-INF;

        for(int i=1;i<=m;i++){
            scanf("%d%d%d",&u,&v,&cost);
            cost=-cost;
            if(w[u][v]!=-INF)
                cost=max(cost,w[u][v]);
            w[u][v]=cost;
            w[v][u]=cost;
        }
        
        printf("Case %d: ",ca++);
        int ans=km();
        if(ans!=-1)
            printf("%d\n",ans);
        else
            printf("NO\n");
    }
}
```





