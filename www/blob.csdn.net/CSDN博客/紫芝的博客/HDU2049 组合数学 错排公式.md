# HDU2049  组合数学  错排公式 - 紫芝的博客 - CSDN博客





2018年09月23日 13:13:56[紫芝](https://me.csdn.net/qq_40507857)阅读数：259








国庆期间,省城HZ刚刚举行了一场盛大的集体婚礼,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做"考新郎",具体的操作是这样的: 
![](https://odzkskevi.qnssl.com/6ab742488bcb408dc9a61fa508326aea?v=1537523342)


首先,给每位新娘打扮得几乎一模一样,并盖上大大的红盖头随机坐成一排; 然后,让各位新郎寻找自己的新娘.每人只准找一个,并且不允许多人找一个. 最后,揭开盖头,如果找错了对象就要当众跪搓衣板... 

看来做新郎也不是容易的事情... 


假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能. 

Input

输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1<M<=N<=20)。 

Output

对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。 

Sample Input

2
2 2
3 2
Sample Output

1
3
分析：

求n个人中，有多少种M个人的错排

先从N个中选M个，有C（N，M）种，这M个人错排的个数为F[M]，ans=C（N，M）* F[M]

**错排公式：F[n]=(n-1)*(F[n-1]+F[n-2]), F[1]=0,F[2]=1;(n>=3)**

错排的情况：

首先考虑，如果开始有n-1个新郎，并且这n-1个人都已经完成了错排（有f(n-1)种可能），现在又来了一个人，那么后来的第n个人可以通过用自己的新娘去和那n-1个人中的任意一个交换，来实现n个人都错排。这种情况有**(n-1)*f[n-1]**种可能;

另外，如果开始的n-1个人不是都错排，那么要想使第n个人过来与其中一个交换后实现错排的话就必须满足两个条件：

1.那n-1个人中只有一个人选到了自己的新娘，也就是说有n-2个人都已经错排了。

2.第n个人必须和那个选到自己新娘的人去交换，但那个选到自己新娘的人可以是n-1个人中的任意一个。这种情况有**(n-1)*f[n-2]**种可能。

其他情况都不能满足n个人错排。 因此递推关系：f[n]=(n-1)*(f[n-1]+f[n-2])。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=30;
ll c[maxn][maxn];
ll f[maxn];
void init()
{
    c[0][0]=1;
    for(int i=1;i<maxn;i++)
        for(int j=0;j<=i;j++)
        c[i][j]=c[i-1][j-1]+c[i-1][j];
     f[1]=0;
     f[2]=1;
     for(int i=3;i<=20;i++)
        f[i]=(i-1)*(f[i-1]+f[i-2]);
}
int main()
{
    init();
    int T;
    scanf("%d",&T);
    while(T--){
        int n,m;
    scanf("%d%d",&n,&m);
        printf("%lld\n",c[n][m]*f[m]);
    }
    return 0;
}
```





