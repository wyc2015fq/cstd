# HDU 2063 过山车 二分图匹配 匈牙利算法 - 紫芝的博客 - CSDN博客





2018年08月24日 09:10:27[紫芝](https://me.csdn.net/qq_40507857)阅读数：41








# 过山车

****Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 29925    Accepted Submission(s): 12911****

**Problem Description**

RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？

**Input**

输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0<K<=1000

1<=N 和M<=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。

**Output**

对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。

**Sample Input**

```
6 3 3 
1 1 
1 2 
1 3 
2 1 
2 3 
3 1 
0
```

**Sample Output**
3
**Author**

PrincessSnow

**Source**

[RPG专场练习赛](http://acm.hdu.edu.cn/search.php?field=problem&key=RPG%D7%A8%B3%A1%C1%B7%CF%B0%C8%FC&source=1&searchmode=source)

**Recommend**

lcy   |   We have carefully selected several similar problems for you:  [1068](http://acm.hdu.edu.cn/showproblem.php?pid=1068)[1083](http://acm.hdu.edu.cn/showproblem.php?pid=1083)[2444](http://acm.hdu.edu.cn/showproblem.php?pid=2444)[1281](http://acm.hdu.edu.cn/showproblem.php?pid=1281)[1150](http://acm.hdu.edu.cn/showproblem.php?pid=1150)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1e3+10;
int n1,n2,k;
//n1,n2为二分图的顶点集，其中x属于n1，y属于n2
int map[maxn][maxn],vis[maxn],link[maxn];
//link记录n2中的点y在n1中所匹配的x点的编号
void init()
{
    memset(map,0,sizeof map);
    memset(link,0,sizeof link);
}
int find(int x)
{
    for(int i=1;i<=n2;i++)
    {
        if(map[x][i]&&!vis[i])//x->i有边，且节点i未被搜索
        {
            vis[i]=1;//标记节点已经被搜索
            //如果i不属于前一个匹配M，或被i匹配到的节点可以寻找到增广路
            if(link[i]==0||find(link[i]))
            {
                link[i]=x;//更新
                return 1;//匹配成功
            }
        }
    }
    return 0;
}
int main()
{
    while(~scanf("%d",&k)&&k){
        scanf("%d%d",&n1,&n2);
        init();
        for(int i=0;i<k;i++)
        {
             int x,y;
            scanf("%d%d",&x,&y);
            map[x][y]=1;
        }
        int ans=0;
        for(int i=1;i<=n1;i++)
        {
            memset(vis,0,sizeof vis);
            if(find(i)) ans++;
        }
        printf("%d\n",ans);
    }
   return 0;
}
```





