# 并查集模板 - 紫芝的博客 - CSDN博客





2018年04月07日 14:07:17[紫芝](https://me.csdn.net/qq_40507857)阅读数：72
个人分类：[解题模板																[并查集](https://blog.csdn.net/qq_40507857/article/category/7569705)](https://blog.csdn.net/qq_40507857/article/category/7565904)








### 并查集（Union-Find-Set）简洁而高效地处理连通分量的查询与合并

并查集由一个整型数组和两个函数构成

**1.数组pre[]：记录每个结点的前导结点（父节点），初始化为：pre[i]=i**

**2.函数unionset：合并两个连通分量**

**3.函数findset：查找任意两个点是否在同一个连通分量**

**可以把每个连通分量看成一个集合，该集合中包含了连通分量中的所有点。**

**这些点两两连通，而具体的连通方式无关紧要，就好比集合中的元素没有先后顺序之分，只有属于和不属于的区别**

**在图中，每个点恰好属于一个连通分量，对应到集合表示中，每个元素恰好属于一个集合。**

**换句话说，图的所有连通分量可以用若干个不相交集合来表示**

**并查集的精妙之处在于用树来表示集合。例如，若包含点1，2，3，4，5，6的图有3个连通分量{1，3}，{2，5，6}，{4}，**

**则需要用3棵树来表示。这三棵树的具体形态无关紧要，只要有一棵树包含1，3两个点，一棵树包含2，5，6三个点，**

**还有一棵树包含4这个点即可。规定每棵树的根节点是这棵树所对应的集合的代表元。**

**并查集中的路径压缩，在特殊情况下，这棵树可能是一条长链。设链的最后一个节点是x，则每次执行find（x)都会遍历整条链，**

**效率十分低下，改进方法其实很简单。既然每棵树表示的只是一个集合，因此树的形态是无关精要的，并不需要在查找操作之后保持树的形态不变，只要顺便把遍历过的节点都改成树根的子节点，下次查找就会快很多**

```cpp
int pre[maxn];//pre[i]记录i的前驱节点
int findset(int x)//查找x的根节点
{
    if(pre[x]==x)    return x;
    return pre[x]=findset(pre[x]);
}
//合并x和y所在的连通分量
void unionset(int x,int y)
{
    int fx=findset(x),fy=findset(y);
    pre[fy]=fx;
}
```




