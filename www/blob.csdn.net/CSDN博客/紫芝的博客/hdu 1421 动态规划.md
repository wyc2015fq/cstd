# hdu 1421 动态规划 - 紫芝的博客 - CSDN博客





2018年04月23日 18:57:27[紫芝](https://me.csdn.net/qq_40507857)阅读数：29








## 题意：

有n件物品，从中选出2*k件,使得这k组物品，每组中两件物品重量之差的平方的和最小

## 题解：



先对n个物品排序，尽量选择与之相邻的一个物品使其配对， 

dp[i][j]表示在前j个物品里选i对出来
那么对于第j个物品，有两种选择：选或不选 ，即dp[i][j-1]或dp[i-1][j-2]+(a[j]-a[j-1])^2

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#include<sstream>
#include<algorithm>
#include<utility>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<cmath>
#include<iterator>
#include<stack>
using namespace std;
const int INF=0x3f3f3f3f;
const double eps=1e-7;
const int mod=1000007;
const int maxn=2005;
int dp[maxn][maxn];
int a[maxn];
int main()
{
        int n,k;
      while(cin>>n>>k)
      {
              for(int i=1;i<=n;i++)
                cin>>a[i];
              sort(a+1,a+1+n);
              memset(dp,INF,sizeof dp);//表示无法到达 
              for(int i=0;i<=n;i++)
                dp[0][i]=0;//不需要选任何物品 
              for(int i=1;i<=k;i++)
              {
                for(int j=2;j<=n;j++)
                dp[i][j]=min(dp[i][j-1],dp[i-1][j-2]+(a[j]-a[j-1])*(a[j]-a[j-1]));
              }
              cout<<dp[k][n]<<endl;
      }
}
```







