# 算法竞赛入门与进阶 （四）二分 - 紫芝的博客 - CSDN博客





2018年04月27日 11:14:26[紫芝](https://me.csdn.net/qq_40507857)阅读数：135








# 1.单调函数求零点

![](https://img-blog.csdn.net/20180427094209845)

# 2.二分查找

在一个单调有序的集合中查找元素，每次将集合分为左右两部分，
判断解在哪个部分中并调整集合上下界，重复直到找到目标元素。


例如：在以下序列中查找55

![](https://img-blog.csdn.net/20180427094248976)

# 3.C++ STL的二分查找函数

binary_search 返回bool值 判断查找元素是否存在

lower_bound 返回可插入的最小位置的迭代器
即返回第一个符合条件的元素位置

upper_bound返回可插入的最大位置的迭代器


即返回最后一个符合条件的元素位置




##  例一：

给一串n个单调递增的数，有q次询问>=x且<=y的数有多少个


数据规模：1 ≤ n ≤ 10^5  1 ≤ q ≤ 50000

C++版


```cpp
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e5+5;
int a[MAX],n,q;
int main()
{
	cin>>n>>q;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	//sort(a,a+n);
	while(q--)
	{
		int x,y;
		cin>>x>>y;
		int left=lower_bound(a,a+n,x)-a;
		int right=upper_bound(a,a+n,y)-a;
		cout<<right-left<<endl;
	}
	return 0;
}
```

C语言实现

```cpp
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
const int MAX = 1e5 + 5;
int a[MAX], n, q;
int find_low(int x)
{
	int mid, l = 1, r = n;
	while (l <= r) {
		//mid=(l+r)>>1;//l+r可能会溢出 
		mid = l + ((r - l) >> 1);//严谨的写法
								 //mid=l+(r-l)/2;
		if (a[mid]<x)
			l = mid + 1;//向右区间搜索 
		else r = mid - 1; //向左区间搜索 
	}
	return l;
}
int find_up(int x)
{
	int mid, l = 1, r = n;
	while (l <= r) {
		//mid=(l+r)>>1;//l+r可能会溢出 
		mid = l + ((r - l) >> 1);//严谨的写法
								 //mid=l+(r-l)/2;
		if (a[mid] <= x)
			l = mid + 1;//向右区间搜索 
		else r = mid - 1; //向左区间搜索 
	}
	return l;
}
int main()
{
	cin >> n >> q;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}

	while (q--)
	{
		int x, y;
		cin >> x >> y;
		int left = find_low(x);
		int right = find_up(y);
		cout << right - left << endl;
	}
	return 0;
}
```

## 例二：

//uva1152  poj2785
题意：
给你N行4列的数，从每一列选一个数，
问使他们的和为0的情况有多少种（N<=4000）


思路：
既然有四列，那么我们可以分别计算前两列和后两列的和（只需要n*n*2次运算），
然后对后两列的和排序，那么我们对于每一个前两列的和都可以二分找到后两列的和中与之相加为0的个数，

这样的复杂度就是O(n*n*log(n))是可以接受的

C++


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	int t;
	cin>>t;
	while(t--){
		
		int n;
		cin>>n;
		vector<int> a(n);
		vector<int> b(n);
		vector<int> c(n);
		vector<int> d(n);
		for(int i=0;i<n;i++)
		{
			/*
			int A,B,C,D;
			cin>>A>>B>>C>>D;
			a.push_back(A);
			b.push_back(B);
			c.push_back(C);
			d.push_back(D);
			*/
			cin>>a[i]>>b[i]>>c[i]>>d[i];
		}
		vector<int> ab;
		for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		ab.push_back(a[i]+b[j]);
		
		vector<int> cd;
		for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		cd.push_back(c[i]+d[j]);
		
		sort(cd.begin(),cd.end());
		int ans=0;
		for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			int temp=(-1)*(a[i]+b[j]);
			int l=lower_bound(cd.begin(),cd.end(),temp)-cd.begin();
			int r=upper_bound(cd.begin(),cd.end(),temp)-cd.begin();
			/*
			if(cd[p]==temp)
			ans++;
			*/
			ans+=r-l;
		}
		cout<<ans<<endl;
		if(t>0)	cout<<endl;
	} 
	return 0;
}
```

C语言

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define N 4010
int a[N],b[N],c[N],d[N];
int ab[N*N],cd[N*N];
int main(){
	int t,i,j,k,n=0;
	cin>>t;
	for(i=1;i<=t;i++)
		cin>>a[i]>>b[i]>>c[i]>>d[i];
		k=0;
		for(i=1;i<=t;i++){
			for(j=1;j<=t;j++){
			ab[k]=a[i]+b[j];
			cd[k++]=c[i]+d[j];	
			}
		}
		//sort(ab,ab+t*t);
		sort(ab,ab+k);
	
		for(i=0;i<=t*t-1;i++){
			int left=0,right=t*t-1,flag=0,mid;
			while(right-left>=2){
				mid=(left+right)/2;
				if(ab[mid]+cd[i]==0){
					//向右搜索 
					for(j=mid+1;ab[j]==ab[mid]&&j<=t*t-1;j++)
					n++;
					//向左搜索
					for(k=mid-1;ab[k]==ab[mid]&&k>=0;k--)
					n++;
					
					n++;
					flag=1;
					break; 
				}
				else if(ab[mid]+cd[i]>0)
				right=mid;
				else if(ab[mid]+cd[i]<0)
				left=mid;
			}
			if(ab[right]+cd[i]==0&&flag==0)
			n++;
			if(ab[left]+cd[i]==0&&flag==0)
			n++;
		}	 
		printf("%d\n",n);		
		return 0;
		}
```







