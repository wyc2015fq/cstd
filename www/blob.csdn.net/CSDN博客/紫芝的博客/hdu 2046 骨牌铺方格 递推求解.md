# hdu 2046 骨牌铺方格  递推求解 - 紫芝的博客 - CSDN博客





2018年04月28日 18:49:59[紫芝](https://me.csdn.net/qq_40507857)阅读数：18










# 骨牌铺方格
**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 61686    Accepted Submission(s): 29848**


Problem Description

在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.
例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：
![](http://acm.hdu.edu.cn/data/images/C40-1003-1.jpg)




Input

输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0<n<=50)。





Output

对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。





Sample Input


1
3
2





Sample Output


1
3
2





Author

lcy




Source

[递推求解专题练习（For Beginner）](http://acm.hdu.edu.cn/search.php?field=problem&key=%B5%DD%CD%C6%C7%F3%BD%E2%D7%A8%CC%E2%C1%B7%CF%B0%A3%A8For+Beginner%A3%A9&source=1&searchmode=source)


## 思路：
用a[i]表示2*i长方形的个数，已知a[1]=1;a[2]=2;
假设已经知道a[i-1],a[i-2]，求a[i],要在（i-1）个骨牌后再放一个
骨牌在这一格上横着放和竖着放： 
①如果前面i-1块已经铺好，则第i块只有一种铺法，就是竖着放；
②如果要横着放，也只有一种铺法，不过要求前面i-2块已经铺好！

 因此    arr[i]=arr[i-1]+arr[i-2];

![](https://img-blog.csdn.net/2018042818475452)

1.递归代码：超时

```cpp
#include<bits/stdc++.h>
using namespace std;
__int64 fun(int n)
{
	if(n==1)
	return 1;
	if(n==2)
	return 2;
	return fun(n-1)+fun(n-2);
}
int main()
{
	ios::sync_with_stdio(0);
	int n;
	while(cin>>n){
		cout<<fun(n)<<endl;
	}
	return 0;
}
```

2.递推代码：AC

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=55;
__int64 a[MAX];
void fun()
{
	a[1]=1;
	a[2]=2;
	for(int i=3;i<MAX;i++)
	a[i]=a[i-1]+a[i-2];
}
int main()
{
	ios::sync_with_stdio(0);
	int n;
	fun();
	while(cin>>n){
		cout<<a[n]<<endl;
	}
	return 0;
}
```




