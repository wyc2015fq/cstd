# 最小生成树 - 紫芝的博客 - CSDN博客





2018年07月15日 17:38:27[紫芝](https://me.csdn.net/qq_40507857)阅读数：62
个人分类：[最小生成树](https://blog.csdn.net/qq_40507857/article/category/7646993)









在无向图中，连通且不含环的图称为树**（Tree）**。

给定无向图G=(V,E)，连接G中所有的点，且边集是E的子集的树称为G的生成树**（spanning Tree）**

而权值最小的生成树称为最小生成树**（Minimal Spanning Tree，MST）**

构造MST的算法有很多，最常见的有两个：Kruskal算法和Prim算法，kruskal算法简单高效。

**Kruskal算法的第一步是给所有的边按照从小到大的顺序排序，接下来从小到大依次考查每条边（u，v)**

**情况1：**u和v在同一个连通分量中，那么加入（u，v）后会形成环，因此不能选择

**情况2：**如果u，v在不同的连通分量，那么加入（u，v）一定是最优的

```cpp
struct edge
{
    int u,v,w;//起点，终点，权值
    bool friend operator <(edge a,edge b)//重载小于运算符
    {
        return a.w>b.w;//每次让权值最小的边出队
    }
};
priority_queue<edge> q;
int pre[maxn];//每个点的前驱节点,初始化为-1
int cnt;//最小生成树所需边的个数
int get_parent(int x)//查找x的前驱节点
{
    if(pre[x]==-1)  return x;
    return pre[x]=get_parent(pre[x]);//递归查询
}
bool mix(int x,int y)//判断x，y是否在同一个集合
{
    int fx=get_parent(x),fy=get_parent(y);
    if(fx==fy)//x，y在同一个集合
        return 1;
    pre[fx]=fy;//x,y不在同一个集合
 return 0;
}
ll kruskal()
{
    ll cost=0;//建树的花费
    while(!q.empty()){//队列非空
        edge x=q.top();
        q.pop();
        if(!mix(x.u,x.v))//若两点不在同一个集合
            cost+=x.w,cnt++;//建边
    }
    return cost;
}
```





