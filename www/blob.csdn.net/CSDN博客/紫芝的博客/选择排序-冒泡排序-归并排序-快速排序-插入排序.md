# 选择排序-冒泡排序-归并排序-快速排序-插入排序 - 紫芝的博客 - CSDN博客





2019年01月16日 18:24:42[紫芝](https://me.csdn.net/qq_40507857)阅读数：1239








# 选择排序
- 基本思想:

设所排序序列个数为N，i取1，2，3…n-1,从N-i+1个记录（Ri,Ri+1….Rn）中找出排序码最小的记录，与第i个记录交换，执行N-1次后完成序列的排序。

```java
//选择排序
private static void selectSort(int[] arr, int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (arr[i] > arr[j]) {
                int t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
            }
        }
    }
}
```

# 冒泡排序
- 基本思想：

相邻的元素进行两两比较，顺序相反则进行交换，每一次都会将最大或最小的元素"浮上来"，最终达到有序

```java
//冒泡排序
private static void bubbleSort(in[] arr, into n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                int t = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = t;
            }
        }
    }
}
```

# 归并排序
- 将若干有序序列进行两两合并，直到待排序记录都在一个有序序列中为止

```java
//归并排序
private static void mergeSort(int[] arr, int n) {
    mergeSort(arr, 0, n - 1);
}

private static void mergeSort(int[] arr, int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        // 左边
        mergeSort(arr, low, mid);
        // 右边
        mergeSort(arr, mid + 1, high);
        // 左右归并
        merge(arr, low, mid, high);
    }
}

private static void merge(int[] arr, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;// 左指针
    int j = mid + 1;// 右指针
    int k = 0;
    // 把较小的数先移到新数组中
    while (i <= mid && j <= high) {
        if (arr[i] < arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    // 把右边边剩余的数移入数组
    while (j <= high) {
        temp[k++] = arr[j++];
    }
    // 把新数组中的数覆盖arr数组
    for (int k2 = 0; k2 < temp.length; k2++) {
        arr[k2 + low] = temp[k2];
    }
}
```

# 快速排序
- 基本思想：

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。

```java
//快速排序
private static void quickSoft(int arr[], int length) {
    quickSoft(arr, 0, length - 1);
}

private static void quickSoft(int arr[], int low, int high) {
    int pos;
    if (low < high) {
        pos = partition(arr, low, high);
        quickSoft(arr, low, pos - 1);
        quickSoft(arr, pos + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int val = arr[low];
    while (low < high) {
        while (low < high && arr[high] >= val) {
            --high;
        }
        arr[low] = arr[high];
        while (low < high && arr[low] <= val) {
            ++low;
        }
        arr[high] = arr[low];
    }
    arr[low] = val;
    return low;
}
```

# 插入排序
- 基本思想：

每次将一个待排序的记录按其关键码的大小插入到一个已经排好序的有序序列中，直到全部记录排好序。

```java
//插入排序
private static void insertSoft(int[] arr, int n) {
    for (int i = 1; i < n; i++) {
        int t = arr[i];
        int k = i;
        for (int j = i - 1; j >= 0 && arr[j] > t; --j) {
            arr[j + 1] = arr[j];
            k = j;
        }
        arr[k] = t;
    }
}
```



