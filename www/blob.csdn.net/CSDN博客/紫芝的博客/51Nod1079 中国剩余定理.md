# 51Nod1079 中国剩余定理 - 紫芝的博客 - CSDN博客





2018年09月14日 16:23:09[紫芝](https://me.csdn.net/qq_40507857)阅读数：188








# [中国剩余定理](https://www.51nod.com/Challenge/Problem.html#!%23problemId=1079)

## Chinese remainder theorem

一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。例如，K % 2 = 1, K % 3 = 2, K % 5 = 3。符合条件的最小的K = 23。

Input

第1行：1个数N表示后面输入的质数及模的数量。（2 <= N <= 10)

第2 - N + 1行，每行2个数P和M，中间用空格分隔，P是质数，M是K % P的结果。（2 <= P <= 100, 0 <= K < P)

Output

输出符合条件的最小的K。数据中所有K均小于10^9。

Sample Input

```
3
2 1
3 2
5 3
```

Sample Output
`23`
```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
const int maxn=1e9+7;
//扩展欧几里得定理
ll ex_gcd(ll a,ll b,ll &x,ll &y)
{
    ll d=a;
    if(!b)    x=1,y=0;
    else{
        d=ex_gcd(b,a%b,y,x);
        y-=a/b*x;
    }
    return d;
}

//中国剩余定理
//x%m[i]=a[i]
ll china(int n,int *a,int *m)
{
    ll M=1,x=0,y,z;
    for(int i=0;i<n;i++)
        M*=m[i];
    for(int i=0;i<n;i++)
    {
        ll M_i=M/m[i];
        ex_gcd(M_i,m[i],y,z);//M_i*y = 1(mod m[i])
        x = (x+M_i*a[i]*y)%M;
    }
    return (x+M)%M;
}
int main()
{
    int n;//输入的质数及模的数量
    while(scanf("%d",&n)!=EOF){
        int *m=new int[15];//质数
        int *a=new int[15];//K%m[i]=a[i]
       
        for(int i=0;i<n;i++)
        {
            scanf("%d%d",&m[i],&a[i]);
        }
        printf("%lld\n",china(n,a,m));
    }
    return 0;
}
```





