# 汉诺塔问题 - 紫芝的博客 - CSDN博客





2018年05月11日 20:41:59[紫芝](https://me.csdn.net/qq_40507857)阅读数：315








# **汉诺塔问题**

相传在[古印度](https://baike.baidu.com/item/%E5%8F%A4%E5%8D%B0%E5%BA%A6)圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，

在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。

游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。

操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。



![](https://img-blog.csdn.net/20180511203531894)



分析：

对于这样一个问题，任何人都不可能直接写出移动盘子的每一步，但我们可以利用下面的方法来解决。

设移动盘子数为n，为了将这n个盘子从A杆移动到C杆，可以做以下三步：

(1)以C盘为中介，从A杆将1至n-1号盘移至B杆；

(2)将A杆中剩下的第n号盘移至C杆；

(3)以A杆为中介；从B杆将1至n-1号盘移至C杆。



```cpp
#include<bits/stdc++.h>
using namespace std;
void hanoi(int n,char A,char B,char C)
{
    if(n==1)//只有一个盘子，就把它直接搬到C
        printf("Move sheet %d from %c to %c\n",n,A,C);
    else{//盘子数超过2个，每次处理两个盘子，A->B,A->C,B->C
        hanoi(n-1,A,C,B);
        printf("Move sheet %d from %c to %c\n",n,A,C);
        hanoi(n-1,B,A,C);
    }
}
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	hanoi(n,'A','B','C');
	return 0;
 }
```
|||||||
|----|----|----|----|----|----|

## 问题 D: 汉诺塔问题

## 题目描述



汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三个金刚石柱子，在一根柱子上从上往下，按从小到大顺序摞着64片黄金圆盘，上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间每次只能移动一个圆盘，只能移动在最顶端的圆盘。

现在有 n 个圆盘从上往下，从小到大叠在第一根柱子上，要把这些圆盘全部移动到第三根柱子，我们都知道，最少的移动数目为 2^n - 1 次。但是现在我们要求的并不是这个。

我们用 1，2，...，n 表示 n个盘子的编号，编号越大盘子就越大。在移动过程中，有的圆盘移动次数多，有的少。告知盘子总数和盘号，计算该盘子的移动次数。



## 输入



输入包含多组数据，首先输入 T ，表示有 T 组数据。每个数据一行，是盘子的数目(1 <= N <= 60)和盘号 k (1 <= k <= N)。



## 输出

对于每组数据，输出一个数，即到达目标时 k 号盘需要的最少移动数。



## 样例输入

```
2

60 1

3 1
```

## 样例输出

```
576460752303423488

4
```

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll hanoi(int n,int k)
{
    if(n==k)//最大的盘子只移动一次
    return 1;
    if(n==1)//只有一个盘子，不需要移动
        return 0;
    return 2*hanoi(n-1,k);//上面n-1层移动两次
    }
int main()
{
    ios::sync_with_stdio(false);
    int n,k,t;
    cin>>t;
    while(t--){
        cin>>n>>k;
    cout<<hanoi(n,k)<<endl;
    }
    return 0;
    }
```





