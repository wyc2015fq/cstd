# 算法竞赛入门与进阶 （三）贪心 - 紫芝的博客 - CSDN博客





2018年04月25日 18:22:48[紫芝](https://me.csdn.net/qq_40507857)阅读数：104








# 贪心算法：

### 在对问题求解的时候，总是做出在当前看来最好的选择，

### 也就是说不从整体上进行考虑，它所做出的仅仅是在某种意义上的局部最优解是否是全优解，需要证明。若用贪心算法求解某问题的整体最优解，必须证明贪心思想在该问题的应用结果就是最优解

# 贪心：每次都选看起来最好的！

## 例一：

有n个人在一个水龙头前排队接水，假如每个人接水的时间为Ti，


请编程找出这n个人排队的一种顺序，使得n个人的平均等待时间最小。

贪心策略：

第1个人的等待时间为0，第二个人的等待的时间为t[1],第三个人的等待时间为t[1]+t[2]

第n个人的等待时间为前n-1个人接水的时间之和，所以将n个人的接水时间从小到大排序

这就是n个人排队的顺序，使得n个人的平均等待时间最小


```cpp
#include<bits/stdc++.h>
using namespace std; 
const int MAX=1e5+5;
int t[MAX],n;
int main()
{
	while(cin>>n){
		for(int i=0;i<n;i++)
		cin>>t[i];
		sort(t,t+n);
		int sum=0;
		for(int i=1;i<n;i++)
		t[i]+=t[i-1];
		for(int i=0;i<n;i++)
		sum+=t[i];
		cout<<sum<<endl;
	}
	return 0;
}
```

# 例二：

## 银行排队
时间限制: 1 Sec  内存限制: 128 MB
提交: 299  解决: 115
[[提交](http://sustoj.com/submitpage.php?cid=1015&pid=0&langmask=0)][[状态](http://sustoj.com/problemstatus.php?id=1634)][[讨论版](http://sustoj.com/bbs.php?pid=1634&cid=1015)]
## 题目描述


有n个人将要排队在银行办理业务，已知每个人办理业务所花费的时间，分别是t1,t2,t3...tn。现在，你可以重新安排他们的排队顺序，目的是为了使所有人从排队开始到业务办理完成花费的时间总和最少。现在你只需要告诉我，安排好后所有人花费的时间总和最少是多少？


## 输入


本题有多组测试数据。每组数据第一行给出一个正整数n，代表有n个人排队，其中n<=100。接下来一行有n个正整数，分别代表这每个人办理业务所需要花费的时间。


## 输出


对每个测试用例，在每一行里输出所有人花费时间的总和最少的值。


## 样例输入
5
3 1 2 2 1
10
2 1 3 1 3 4 5 8 7 4
## 样例输出
22
147

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;

int tim[101];
int main()
{
	int N;
	
	while(scanf("%d",&N)!=EOF)
	{
		for(int i=0;i<N;i++)
		scanf("%d",&tim[i]);
		
		sort(tim,tim+N);
		int ans=0,sum;
		for(int i=0;i<N;i++)
		{
			sum=0;
			for(int j=0;j<=i;j++)
			{
				sum +=tim[j];
			}
			ans+=sum;
		 } 		
		 printf("%d\n",ans);
	}
	return 0;
}
```

# 例三：
|水题| | | | | | |
|----|----|----|----|----|----|----|
||Time Limit: 500 MS|Memory Limit: 32768 K||----|----|Total Submit: 428(149 users)Total Accepted: 164(109 users)Rating: ![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-half2.png)Special Judge: No|Time Limit: 500 MS|Memory Limit: 32768 K|Total Submit: 428(149 users)|Total Accepted: 164(109 users)|Rating: ![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-half2.png)|Special Judge: No|
|Time Limit: 500 MS|Memory Limit: 32768 K| | | | | |
|Total Submit: 428(149 users)|Total Accepted: 164(109 users)|Rating: ![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-solid.png)![](http://acm.hrbust.edu.cn/Public/images/star-half2.png)|Special Judge: No| | | |
|Description| | | | | | |
|因为是有关于接水的问题，便简称为水题了（。N个人排队在M个出水口前接水，第i个人接水需时为t[i]，请问接水的最短用时是多少？| | | | | | |
|Input| | | | | | |
|第一行一个整数 T ，代表有 T 组数据。每组数据第一行两个整数 N(<=100000) , M(<=10000) 代表有 N 个人 M 个出水口。第二行N个整数，第i个数字t[i](<=10000)代表第i个人接水用时t[i]。| | | | | | |
|Output| | | | | | |
|对于每组数据输出一个整数，代表所需的最少接水时间。| | | | | | |
|Sample Input| | | | | | |
|25 31 2 3 4 56 31 2 3 3 4 5| | | | | | |
|Sample Output| | | | | | |
|56| | | | | | |
|Hint| | | | | | |
|小桥流水哗啦啦，我和小岛去偷瓜~。| | | | | | |
|Source| | | | | | |
|"诚德软件杯"哈尔滨理工大学第四届ACM程序设计团队赛| | | | | | |
[点击打开链](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&a=showProblem&problem_id=2223)[接](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&a=showProblem&problem_id=2223)
## 贪心 + 二叉推

将所有人从大到小排序，依次插入 M 个出水口， 每次要插入到用时最少的出水口，最后输出 M个出水口中用时最多的

```cpp
#include<stdio.h>
#include<vector>
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;

int cmp(int a,int b)
{
	return a>b;
}
int tim[101000];
int main()
{
	int T,N,M;
	cin>>T;
	while(T--)
	{
		cin>>N>>M;
		priority_queue<int,vector<int>,greater<int> >pq;
		//优先队列，从小到大入队列
		
		//将 M 个出水口用时初始化为 0
		for(int i=0;i<M;i++)
		pq.push(0);
		
		for(int i=0;i<N;i++)
		cin>>tim[i];
		
		sort(tim,tim+N,cmp);//从大到小排序
		
		for(int i=0;i<N;i++)
		{
			int temp=pq.top();//每次取出时间最小的出水口
			pq.pop();//出队列
			temp+=tim[i];
			//将第 i 个人插入到目前时间最小的出水口 
			pq.push(temp);
			 
		 } 
		 int ans=-1;
		 //遍历循环，找出最大值 
		 while(!pq.empty()){
		 	if(ans<pq.top())
			 ans=pq.top();
			 pq.pop(); 
		 }
		 printf("%d\n",ans);
	}
	return 0;
}
```

# 例四：[点击打开链接](https://cn.vjudge.net/problem/CSU-1588)

合并果子



现在有n堆果子，第i堆有ai个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。


Input
第一行包含一个整数T（T<=50），表示数据组数。
每组数据第一行包含一个整数n（2<=n<=1000），表示果子的堆数。
第二行包含n个正整数ai（ai<=100），表示每堆果子的果子数。


Output
每组数据仅一行，表示最小合并代价。


Sample Input2
4
1 2 3 4
5
3 5 2 1 4Sample Output19
33



## 优先队列

```cpp
#include<iostream>
#include<queue>
//#include<bits/stdc++.h>
using namespace std;
const int MAX=1e4+5;
int n; 
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--){
		int n,x;
	cin>>n;
	priority_queue<int,vector<int>,greater<int> >q;
	for(int i=0;i<n;i++)
	{
		cin>>x;
	q.push(x);
	}
	long long sum=0;
	while(q.size()>1)
	{
		int min1=q.top();
		q.pop();
		int min2=q.top();
		q.pop();
		sum+=(min1+min2);
		q.push(min1+min2);
	}
	cout<<sum<<endl;
	} 
	return 0;
 }
```

## STL堆算法


```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std; 
int main()
{
	int t;
	cin>>t;
	
	while(t--){
		int n;
		cin>>n;
		vector<int> v;
		while(n--){
			int x;
			cin>>x;
			v.push_back(x);
		}
		long long sum=0;
		make_heap(v.begin(),v.end(),greater<int>());
		while(v.size()>1)
		{
			int min1=v.front();
			pop_heap(v.begin(),v.end(),greater<int>());
			v.pop_back();
			
			int min2=v.front();
			pop_heap(v.begin(),v.end(),greater<int>());
			v.pop_back();
			
			//cout<<min1<<" "<<min2<<endl;
			sum+=(min1+min2);
			v.push_back(min1+min2);
			push_heap(v.begin(),v.end(),greater<int>());
		}
		cout<<sum<<endl;
	}
	return 0;
}
```


# 例５：

# n个正整数，联接成一排，组成一个最小（最大）的多位整数



描述：设有n个正整数，将它们联接成一排，组成一个最小（最大）的多位整数。

程序输入：n个数程序输出：联接成的多位数例如：n=2时，2个整数32、321连接成的最小整数为：32132

n=3时，3个整数13,312,343,连成的最大整数为34331213。
n=4时,4个整数7,13,4,246连接成的最大整数为7424613。


n=4时，4个整数55、31、312、33 联接成的最小整数为：312313355

思路：两个方向:a.先组合，后排序，b.先排序，后组合，但是要注意：A=’321’，B=’32’，

按照标准的字符串比较规则因为A>B，所以A+B > B+A ，而实际上’32132’ < ’32321’。 

所以，自定义一种字符串的比较规则：**即如果A+B>B+A,则我们认为A>B。**

```cpp
#include<bits/stdc++.h>
using namespace std;
bool cmp(string a,string b)
{
	return a+b>b+a;
}
int main()
{
	ios::sync_with_stdio(false);
	string s;
	vector<string> v;
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>s;
		v.push_back(s);
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i<v.size();i++)
	cout<<v[i];
	cout<<endl;
	return 0;
 }
```




# 例６

## 事件序列问题 

## 已知N个事件的发生时刻和结束时刻（见下表，表中事件已按结束时刻升序排序）。

一些在时间上没有重叠的事件，可以构成一个事件序列，如事件{2，8，10}。

事件序列包含的事件数目，称为该事件序列的长度。请编程找出一个最长的事件序列。
![](https://img-blog.csdn.net/20180426001652610)

## 算法分析：
用begin[i],end[i]表示事件i的开始时刻和结束时刻，
则问题转化为求 a1<a2<a3<...<an 满足：
begin[a1]<end[a1] <= begin[a2]<end[a2] <= begin[an]<end[an]

## hdu 2037


```cpp
#include <stdio.h>  
#include <algorithm>  
using namespace std;  
  
struct node   
{  
    int t1;//电视开始时间   
    int t2;//电视的结束时间   
}a[105];   
  
int cmp(node u,node v)
//对节目按照结束时间从小到大排序，
//如果结束的时间相同，则按照开始的   
{//时间从大到小的排序！   
    if(u.t2==v.t2)
	//为什么要将开始的时间从大到小排序呢？
	//是因为如果结束时间相同的话，开始的   
  	//越迟，看节目的时间越短，你就能尽可能的多看电视！ 
		   return u.t1>v.t1;
    return u.t2<v.t2;
	//例如：2-3,3-4,2-4，你肯定会看2-3,3-4的两个电视，而不看2-4这个电视   
}  
  
int main()  
{  
    int n,i,j,k,t;  
    while(scanf("%d",&n)&&n)  
    {  
        for(i=0;i<n;i++)//有n个开始和结束时间，将时间输入   
            scanf("%d%d",&a[i].t1,&a[i].t2);  
        sort(a,a+n,cmp);//对时间进行排序   
        for(i=1,t=a[0].t2,k=1;i<n;i++)
		//如果开始 的时间比他这个结束的时间迟，则就k++   
        {  
            if(a[i].t1>=t)//说明这个电视你能够看   
            {  
                t=a[i].t2;  
                k++;  
            }  
        }  
        printf("%d\n",k);//k代表能看的电视的个数！   
    }  
    return 0;  
}
```

# 例7：
HDU 4221 贪心 


## 题意：
给n个活动，每个活动需要一段时间C来完成，并且有一个截止时间D，
当完成时间t大于截止时间完成时，会扣除t-D分，
让你找出如何使自己所扣分的最大值最小。



## 注意：求得是没有按时完成的任务罚金最多的那个!



## 思路：按照截止时间从小到大来排序，从第一天开始做任务，每个任务的完成时间减去截止时间相对来说最少



```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int MAX=1e6+5;
struct node{
	int c,d;
}a[MAX];
bool cmp(node a,node b)
{
	return a.d<b.d;
}
int main()
{
	ios::sync_with_stdio(0);
	int t,T=1;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=0;i<n;i++)
		cin>>a[i].c>>a[i].d;
		sort(a,a+n,cmp);
		long long ans=0,time=0;
		for(int i=0;i<n;i++)
		{
			time+=a[i].c;
			if(ans<time-a[i].d){			
			ans=time-a[i].d;
			}
		}
		printf("Case %d: %I64d\n",T++,ans);
	}
	return 0;
}
```

# 例8：

## NOIP2012 国王游戏 题解




## 描述


恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 
国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。




## 格式


### 输入格式


第一行包含一个整数n，表示大臣的人数。 
第二行包含两个整数a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来n行，每行包含两个整数a和b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。


### 输出格式


输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。





## 样例1


### 样例输入1[复制]



> 3 
1 1 
2 3 
7 4 
4 6 

### 样例输出1[复制]



> 2




## 限制


每个测试点1s




## 提示


对于20%的数据，有1≤ n≤ 10，0 < a、b < 8； 
对于40%的数据，有1≤ n≤20，0 < a、b < 8； 
对于60%的数据，有1≤ n≤100； 
对于60%的数据，保证答案不超过10^9； 
对于100%的数据，有1 ≤ n ≤1,000，0 < a、b < 10000。



## 【题解】

  一开始看着题觉得是二分答案（最大值的最小值），后来发现不满足单调性

  再后来发现可以用贪心做：只需把大臣按照左手*右手升序排序即可

  证明：

   很显然前面的大臣位置随便调换对后面的大臣并没有影响

  那么假设现在已经排了i-1个大臣,p=a[1]*a[2]*a[3]*……*a[i-1];

  第i个大臣的钱w[i]=p/b[i],第i+1个大臣的钱w[i+1]=p*a[i]/b[i+1]

  若i+1大臣在i大臣前面

  第i个大臣的钱w[i]=p*a[i+1]/b[i],第i+1个大臣的钱w[i+1]=p/b[i+1]

  显然p*a[i+1]/b[i]>p/b[i]  &&  p*a[i]/b[i+1]>p/b[i+1]

  所以两个里面的最大值在p*a[i+1]/b[i] 和 p*a[i]/b[i+1] 之间  

  若p*a[i+1]/b[i] > p*a[i]/b[i+1]（这样就是i+1大臣排在i后面最大值会更小） 则 a[i+1]*b[i+1]>a[i]*b[i]

  所以如果要让大臣得到的钱的最大值最小就要保证两个相邻的大臣，前面的左手*右手<后面的左手*右手




```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e4+5;
struct node{
	int right,left,m;
}a[MAX]; 
bool cmp(node a,node b){
	if(a.m==b.m)
	return a.right<b.right;
	return a.m<b.m;
}
long long num=1,ans=0; 
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=0;i<=n;i++)
	{
		cin>>a[i].left>>a[i].right;
		a[i].m=a[i].left*a[i].right;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=0;i<=n;i++)
	{
		ans=max(ans,num/a[i].right);
		num*=a[i].left;
	}
	printf("%I64d\n",ans);
	return 0;
 }
```










