# 纸牌 最小生成树 - 紫芝的博客 - CSDN博客





2018年07月27日 09:00:59[紫芝](https://me.csdn.net/qq_40507857)阅读数：64
个人分类：[最小生成树](https://blog.csdn.net/qq_40507857/article/category/7646993)









## 纸牌

时间限制: 1 Sec  内存限制: 128 MB

## 题目描述

有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai * bj + bi * aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。

## 输入

首行输入n，代表n个点

接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。

## 输出

输出最大分数

## 样例输入

```
5
2 4
3 3
1 7
2 5
4 4
```

## 样例输出
`108`
## 题解

艾神讲过的最小生成树经典题目，主要是删除牌的问题。但是假如我们将每张牌看成1个结点，两个点的属性的乘积得到的分数为1条路径长度，那么n个结点构成了n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1007;
int a[maxn],b[maxn];
int n;
struct edge
{
    int u,v,w;
    bool friend operator <(edge a,edge b)
    {
        return a.w<b.w;
    }
};
priority_queue<edge> q;
int pre[maxn];
int get_parent(int x)
{
    if(pre[x]==-1)  return x;
    return pre[x]=get_parent(pre[x]);
}
bool mix(int x,int y)
{
    int fx=get_parent(x),fy=get_parent(y);
    if(fx==fy)  return 1;
    pre[fx]=fy;
    return 0;
}
int kruskal()
{
    int cost=0;
    while(!q.empty()){
        edge x=q.top();
        q.pop();
        if(!mix(x.u,x.v))
            cost+=x.w;
    }
    return cost;
}
int main()
{
    memset(pre,-1,sizeof(pre));
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d%d",&a[i],&b[i]);
    for(int i=0;i<n;i++)
        for(int j=0;j<i;j++)
    {
        edge t;
        t.u=i;t.v=j;
        t.w=a[i]*b[j]+a[j]*b[i];
        q.push(t);
    }
    cout<<kruskal()<<endl;
}
```





