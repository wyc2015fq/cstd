# HDU 1754 线段树模板  更新点-查询区间 - 紫芝的博客 - CSDN博客





2018年04月09日 21:12:00[紫芝](https://me.csdn.net/qq_40507857)阅读数：81
个人分类：[线段树](https://blog.csdn.net/qq_40507857/article/category/7569707)









线段树三类问题：

①更新点，查询区间

②更新区间，查询点

③更新区间，查询区间 

1.线段树是一种二叉搜索树，与区间树相似，它将一个区间划分为一些

单元区间，每个单元区间对应线段树的一个叶子节点

线段树区间查询：    询问某段区间某些性质，如极值、求和 


2.对于线段树中每一个非叶子节点[a,b],

它的左儿子表示的区间为[a,(a+b)/2]

右儿子表示的区间为[(a+b)/2+1,b]



3.线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间长度
![](https://img-blog.csdn.net/20180409210651865)


4.使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，

时间复杂度为O(logN),未优化的空间复杂度为2N，需要离散化让空间压缩



5.线段树如何处理？

若节点x（x为奇数）记录的是第一个点的数据，节点x+1记录的是第二个点

的数据，那么节点 x/2记录的就是[1,2]上的有效数据，以此类推，最顶端

的父节点记录的就是区间[1,n]上的有效数据，那么对于每个节点的数据 

有且仅有 logn个节点的数据会被它影响到，因此每次跟新logn个点，

查询也一样，有效节约了时间



6.对于每个节点，其代表的区间[x,y]之间的值，

左儿子节点代表的就是[x,(x+y)/2]区间的值， 

右儿子节点代表的是区间[(x+y)/2+1,y]上的值，

既保证了无重复，由保证了树的层数最短，查询效率最高

7.单点更新线段树

由于事先用 father[]数组保存过每个节点对应的下标，因此只需要

知道第几个点，就能知道这个点在结构体中的位置（即下标），

根据之前已知的基本关系，就只需要直接一路更新上去即可 

HDU1754

模板题目：

更新点，查询区间最大值

```cpp
#include<bits/stdc++.h>
using namespace std;

//const int MAXNODE=2097152;
const int MAX=2e6+3;
const int MAXNODE=1<<19;

struct NODE{
	int value;//节点对应区间的权值
	int left,right;//区间[left,right] 
}node[MAXNODE];
//当区间长度为 0时，对应一个点 
int father[MAX];//每个点对应的结构体数组下标 


//为区间[left,right]建立一个一个以 i 为祖先的线段树
//i为数组下标，即结点序号
void BuildTree(int i,int left,int right)
{
	//写入第 i 个结点中的左区间
	node[i].left=left;
	
	//写入第 i 个结点中的右区间
	node[i].right=right;
	
	//每个区间初始化为 0
	node[i].value=0 ;
	
	//当区间长度为 0 时，结束递归 
	if(left==right)
	{
		father[left]=i;
		//能知道某个点对应的序号
		//为了更新时，从下往上一直到顶
		return; 
	 } 
	 //该结点往左孩子的方向继续建立线段树，
	 //线段树的划分是二分思想
	 //这里将区间 (left,right)一分为二

	 BuildTree(i<<1,left,(right+left)/2);
	 
	 //该结点往右孩子的方向，继续建立线段树
	 BuildTree(i<<1|1,(right+left)/2+1,right); 
} 

//从下往上更新，这个点本身已经在函数外更新过 
void UpdateTree(int ri)
{

	//整个线段树的祖先结点对应的下标为 1 
	if(ri==1)	return;	//向上已经找到了祖先
	
	int fi=ri/2;//ri的父结点
	
	int a=node[fi<<1].value;//该父结点的两个孩子结点 （左） 
	int b=node[fi<<1|1].value;//右
	
	//更新这个父结点，从两个孩子结点中挑个大的 
	node[fi].value=(a>b)?a:b; 
	
	//递归更新，由父结点往上找
	UpdateTree(ri>>1);
}

int Max; 
// i 为区间序号 
//对应的区间是最大范围的那个区间，一般初始为 1 
void query(int i,int l,int r)
{ 
	//找到了一个完全重合的区间 
	if (node[i].left==l&&node[i].right==r)
	{
		Max=max(Max,node[i].value);
		return;
	 } 
	 
	 //get the left child of the tree node 
	 i=i<<1;
	 
	 if(l<=node[i].right) //左区间有涉及
	 {
	  
	 	if(r<=node[i].right)//全包含于左区间，则查询区间形态不变
	 	query(i,l,r);
	 	
		else//半包含于左区间，则查询区间拆分,左端点不变，右端点变为左孩子的右区间端点
		
		query(i,l,node[i].right);
	 }
	 
	 //right child of the tree
	 i++;
	 	 
	 if(r>=node[i].left){//右区间有涉及 
	 	if(l>=node[i].left)//全包含于右区间，则查询区间形态不变 
		  query(i,l,r);	 
	 else//半包含于左区间，则查询区间拆分 
	 query(i,node[i].left,r); } 	
}
int main()
{
	int n,m,g;
	ios::sync_with_stdio(false);//关闭流同步 
	while(cin>>n>>m){
		BuildTree(1,1,n);
		for(int i=1;i<=n;i++)
		{
			cin>>g;
			node[father[i]].value=g;
			UpdateTree(father[i]);
		}
		string op;
		int a,b;
		while(m--){
			cin>>op>>a>>b;
			if(op[0]=='Q'){
				Max=0;
				query(1,a,b);
				cout<<Max<<endl;
			}else{
				node[father[a]].value=b;
				UpdateTree(father[a]);
			}
		}
	}
	return 0;
}
```

# Java版

```cpp
import java.util.*;
import java.math.*;
class node{
	int l,r,max;
	node(int l,int r,int max){
		this.l=l;
		this.r=r;
		this.max=max;
	}
}
public class Main{
	static int maxn=200008;
	static int N;
	static node[] tree=new node[maxn<<2];
	static int[] a=new int[maxn];
	
	static void init() {
		for(int i=0;i<(maxn<<2);i++) {
			tree[i]=new node(0,0,0);
		}
	}
	
	static void pushup(int rt) {
		tree[rt].max=Math.max(tree[rt<<1].max, tree[rt<<1|1].max);
	}
	static void build(int rt,int l,int r) {
		tree[rt].l=l;
		tree[rt].r=r;
		if(l==r) {
			tree[rt].max=a[l];
			return;
		}
		int mid=(l+r)>>1;
		build(rt<<1,l,mid);
		build(rt<<1|1,mid+1,r);
		pushup(rt);
	}
	static void update(int rt,int pos,int val) {
		if(tree[rt].l==pos&&tree[rt].r==pos) {
			tree[rt].max=val;
			return;
		}
		int mid=(tree[rt].l+tree[rt].r)>>1;
		if(pos<=mid)
			update(rt<<1,pos,val);
		else 
			update(rt<<1|1,pos,val);
		pushup(rt);
	}
	static int query(int rt,int l,int r) {
		if(tree[rt].l==l&&tree[rt].r==r)
			return tree[rt].max;
		int mid=(tree[rt].l+tree[rt].r)>>1;
		if(r<=mid)
			return query(rt<<1,l,r);
		else if(l>mid)
			return query(rt<<1|1,l,r);
		else
			return Math.max(query(rt<<1,l,mid), query(rt<<1|1,mid+1,r));
	}
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		init();
		//int T=cin.nextInt();
		int ca=1;
		while(cin.hasNext()) {
			N=cin.nextInt();
			int M=cin.nextInt();
			for(int i=1;i<=N;i++) {
				a[i]=cin.nextInt();
			}
			
			build(1,1,N);
			//System.out.println("Case " + ca++ +":");
			while((M--)!=0) {
				String str=cin.next();
				
				int a=cin.nextInt();
				int b=cin.nextInt();
				if(str.charAt(0)=='U')
					update(1,a,b);
				
				if(str.charAt(0)=='Q')
					System.out.println(query(1,a,b));
			}
		}
		cin.close();
	}
}
```

# NYOJ-【士兵杀敌（二）】

## 士兵杀敌（二）

时间限制：1000 ms  |  内存限制：65535 KB

难度：5

描述

南将军手下有N个士兵，分别编号1到N，这些士兵的杀敌数都是已知的。

小工是南将军手下的军师，南将军经常想知道第m号到第n号士兵的总杀敌数，请你帮助小工来回答南将军吧。

南将军的某次询问之后士兵i可能又杀敌q人，之后南将军再询问的时候，需要考虑到新增的杀敌数。



输入

只有一组测试数据

第一行是两个整数N,M，其中N表示士兵的个数(1<N<1000000)，M表示指令的条数。(1<M<100000)

随后的一行是N个整数，ai表示第i号士兵杀敌数目。(0<=ai<=100)

随后的M行每行是一条指令，这条指令包含了一个字符串和两个整数，首先是一个字符串，如果是字符串QUERY则表示南将军进行了查询操作，后面的两个整数m,n，表示查询的起始与终止士兵编号；如果是字符串ADD则后面跟的两个整数I,A(1<=I<=N,1<=A<=100),表示第I个士兵新增杀敌数为A.

输出

对于每次查询，输出一个整数R表示第m号士兵到第n号士兵的总杀敌数，每组输出占一行

样例输入

```
5 6
1 2 3 4 5
QUERY 1 3
ADD 1 2
QUERY 1 3
ADD 2 3
QUERY 1 2
QUERY 1 5
```

样例输出

```
6
8
8
20
```



题解：

线段树，更新点，查询区间求和

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXNODE =1e5+3;
const int MAX=MAXNODE<<2;
struct NODE{
	int value;//区间和
	int left,right; 
}node[MAXNODE];

int father[MAX];
void BuildTree(int i,int left,int right)
{
	node[i].left=left;
	node[i].right=right;
	node[i].value=0;
	if(left==right){
		father[left]=i;
		return ;
	}
	BuildTree(i<<1,left,(left+right)/2);
	BuildTree(i<<1|1,(left+left)/2+1,right);
}
void UpdateTree(int ri)
{
	if(ri==1)	return;
	int fi=ri/2;
	int a=node[fi<<1].value;
	int b=node[fi<<1|1].value;
	node[fi].value=a+b;
	UpdateTree(ri>>1);
}

int Sum;
void query(int i,int l,int r)
{
	if(node[i].left==l&&node[i].right==r){
		Sum+=node[i].value;
		return;
	}	
	i=i<<1;
	if(l<=node[i].right)
	{
		if(r<=node[i].right)
		query(i,l,r);
		else
		query(i,l,node[i].right);
	}
	i++;
	if(r>=node[i].left){
		if(l>=node[i].left)
		query(i,l,r);
		else query(i,node[i].left,r);
	}
}
int main(){
	int n,m,g;
	ios::sync_with_stdio(false);
	while(cin>>n>>m){
		BuildTree(1,1,n);
		for(int i=1;i<=n;i++)
		{
			cin>>g;
			node[father[i]].value=g;
			UpdateTree(father[i]);
		}
		while(m--)
		{
			int a,b;
			string op;
			//getchar();
			cin>>op>>a>>b;
			if(op[0]=='Q')
			{
				Sum=0;
				query(1,a,b);
				cout<<Sum<<endl;
			}else{
				node[father[a]].value+=b;
				UpdateTree(father[a]);
			}
		}
	}
	return 0;
}
```









