# 算法竞赛入门与进阶   （一）枚举 - 紫芝的博客 - CSDN博客





2018年04月16日 18:09:06[紫芝](https://me.csdn.net/qq_40507857)阅读数：77








#   枚举

1.关键点：不重复不遗漏

2.优化：把多余的操作去掉

例一：

在一个N*N(N<=100)矩阵中求一个最大的正方形使得该正方形的四个顶点都是有字符“#”构成。 

#*#***

******

#*#*#*

******

#*****


***#**

hint：

1.两个点确定一个正方形，然后判断其余两个点是否为“#”

2.三个点确定一个矩形，若矩形边平行于坐标轴，则只需要两个点

![](https://img-blog.csdn.net/20180416163608186)


![](https://img-blog.csdn.net/20180416163623398)


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=102;
char s[N][N]; 
int n;
/*
struct node{
	int x,y;
}dot[N*N];
*/
int x[N*N],y[N*N];
typedef pair<int,int> Point;
set<Point> pset;
int main()
{
	ios::sync_with_stdio(false);
	while(cin>>n){
		int k=0;
		pset.clear();
		for(int i=0;i<n;i++)
		{	
		scanf("%s",s[i]);
			for(int j=0;j<n;j++)
			{
				if(s[i][j]=='#'){
					x[k]=i+1;
					y[k]=j+1;
					//cout<<i<<" "<<j<<endl; 
					pset.insert(make_pair(x[k],y[k]));
					k++;
				}
			}
		}
		int cnt=0;//边长的平方 
		for(int i=0;i<k;i++)
		{
			for(int j=i+1;j<k;j++)
			{
				int mx=x[i]+x[j],dx=max(x[i],x[j])-min(x[i],x[j]);
				int my=y[i]+y[j],dy=max(y[i],y[j])-min(y[i],y[j]);
				if((mx+dy)&1||(my+dx)&1)	continue;
				int sg=((x[i]-x[j])*(y[i]-y[j])<0)?1:-1;
				if(pset.count(make_pair((mx+dy)/2,(my+sg*dx)/2))&&
				pset.count(make_pair((mx-dy)/2,(my-sg*dx)/2)))
				{
					int dis=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
					dis=dis/2;
					cnt=max(cnt,dis);
				}
			}
		}
		cout<<sqrt(cnt)<<endl; 
	}
	return 0;
 }
```

例二：

给定长度为n的整数数列{Ai}，找出两个整数ai和aj（i<j），使得ai-aj尽量大


```cpp
//uva 11078
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int a[N];
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=0;i<n;i++)
		cin>>a[i];
		
		int ans=a[0]-a[1];
		int maxn=a[0];//maxn动态维护数组中的最大值
		for(int i=1;i<n;i++)
		{
			ans=max(ans,maxn-a[i]);
			maxn=max(maxn,a[i]);//因为i<j，所以maxn比ans更新的晚 
		 } 
		 cout<<ans<<endl; 
	}
	return 0;
}
```

例三：

给定长度为n的整数数列以及整数S，求出总和不小于S的连续子串的长度的最小值，如果解不存在，输出0.

poj3061 尺取法（追逐法）

```cpp
#include<iostream>
using namespace std;
int a[100005];
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t; 
	while(t--)
	{
		int n,s;
		cin>>n>>s;
		for(int i=0;i<n;i++){
			cin>>a[i];			
		}
		int sum=0,l=0,re=0x7f7f7f7f;
		for(int i=0;i<n;i++)
		{
			sum+=a[i];
			if(sum>=s)
			{
				while(sum>=s)
				{
					sum-=a[l];
					l++;
				}
				re=min(re,i-l+2);
			}			
		}
		if(l==0)
		cout<<0<<endl;
		else
		cout<<re<<endl;
	}
	return 0;
}
```

变型1：



# 圆圈舞蹈



【问题描述】

     熊大妈的奶牛在时针的带领下，围成了一个圆圈跳舞。由于没有严格的教育，奶牛们之间的间隔不一致。

      奶牛想知道两只最远的奶牛到底隔了多远。奶牛A到B的距离为A顺时针走和逆时针走，到达B的较短路程。告诉你相邻两个奶牛间的距离，请你告诉奶牛两只最远的奶牛

到底隔了多远。

【输入】

     第一行一个整数N，表示有N只奶牛。(2≤N≤100000)

     接下来2～N+1行，第I行有一个数，表示第I-1头奶牛顺时针到第I头奶牛的距离。(1≤距离≤maxlongint，距离和≤maxlongint)

      第N+l行的数表示第N头奶牛顺时针到第1头奶牛的距离。

【输出】

     一行，表示最大距离。

【样例】

Circle.in

5

1

2

3

4

5

Circle.out

7

【样例解析】

      Circle.out所有奶牛I到J之间的距离和到达方式（顺为顺时针，逆为逆时针）如下：
|I\J|1|2|3|4|5|
|----|----|----|----|----|----|
|1|O|1 (顺)|3(顺)|6（顺）|5（逆）|
|2|1（逆）|O|2（顺）|5（顺）|6（逆）|
|3|3（逆）|2（逆）|0|3（顺）|7（顺）|
|4|6（逆）|5（逆）|3（逆）|0|4(顺)|
|5|5（顺）|6（顺）|7（逆）|4（逆）|0|

所以，最远的两头奶牛为3到5，距离是7。



解法：

1.枚举每一个点，直到找到一个大于园的一半周长的点

2.总长度减去刚找到的长度，进行比较，然后选小的

3.求出每头奶牛与他相离最远奶牛的距离：

求两头：1头顺时针最大的

1头逆时针最大的

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[100005];
int c=0;//记录园的周长
int ans=0;//记录答案 
void work()
{
	int sum=0,k=0;//sum记录长度 
	for(int i=1;i<=n;i++)
	{
		sum+=a[i-1];
		if(sum>c/2)
		{
			k=i;break;
		}
	 } 
	 int q=min(sum,abs(c-sum));//该点选择的最短路
	 int q1=min(sum-a[k-1],abs(c-(sum-a[k-1])));
	 ans=max(q,q1);
	 //以上为二分 
	 for(int i=1;i<=n;i++)
	 {
	 	sum-=a[i-1];
		 while(sum<=c/2){
		 	sum+=a[k+1];
		 	k++;
		 } 
		 ans=max(ans,abs(c-sum));
		 ans=max(ans,min(sum-a[k-1],abs(c-(sum-a[k-1]))));
	 }
	 cout<<ans<<endl;
}
int main()
{
	ios::sync_with_stdio(false);
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			c+=a[i];
		}
		work();
	return 0;
}
```

# 变型2：

小明喜欢收集卡片，他要去商店购买新到的卡片。

商店出售的卡片有N张，是连续的，小明只能购买连续的一段，

这一串卡片共有M种，每种卡片都有一个价格，小明拿的钱数为 V，

他想知道如何用花最少的钱来集齐所有种类的卡片。

N<=1000000 ，M<=2000 ，Ti<=2000 ,  V<=10^9



输入第1行 三个正整数 N，M，V，

第2行共M个正整数，第i个数Ti表示第i种卡片的价格，

第3行 N个正整数，表示第i个卡片是哪一类。

输出小明还剩多少钱



样例输入

5 2 20

10 5

1 1 2 2 1



样例输出


5 



```cpp
#include<bits/stdc++.h>
using namespace std;
int M[2005],N[1000005];
	int  n,m;
	long long v;
int kind[2005];

int main()
{
	ios::sync_with_stdio(false);

	while(cin>>n>>m>>v){
		for(int i=1;i<=m;i++)
		cin>>M[i];
		
		for(int j=0;j<n;j++)
		cin>>N[j];
		
		fill(kind,kind+2005,0);
		long long sum= 0;
		int r,l=0;
		for(r=0;r<n;r++)
		{
			sum+=M[N[r]];
			kind[N[r]]++;
			if(kind[N[l]]>1){
				//cout<<"yes"<<endl;
				while(kind[N[l]]>1)
			{
				sum-=M[N[l]];
				kind[N[l]]--;
				l++;
			}
			}						
		}
		//cout<<l<<"      "<<r<<endl;
		if(l==0)
		cout<<v<<endl;
		else{
			cout<<v-sum<<endl;
		}
	}
	return 0;
 }
```


# 变型3：


```cpp
/*
有N个数的数列，M次操作，每次对一个区间[Li,Ri]加上一个值Xi
问M次操作之后，每个数的值。
*/
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[100005];
int main()
{
	ios::sync_with_stdio(false);
	while(cin>>n&&n)
	{
		fill(a,a+100005,0);
		for(int i=1;i<=n;i++)
		cin>>a[i];
		cin>>m;
		for(int i=0;i<m;i++)
		{
			int l,r,x;
			cin>>l>>r>>x;
			a[l]+=x;
			a[r+1]-=x;
		}
		for(int i=1;i<n;i++)
		cout<<a[i-1]+a[i]<<" ";
		cout<<a[n-1]+a[n]<<endl;
	}
	return 0;
}
```





# 变型4：UVA 11020

有n个人，每个人有两个属性x，y，如果对于一个人P（x，y），不存在另外一个人(a，b)，使得a<x, b <= y 或者 a < = x, b < y, 则这个人是有优势的。动态插入每个人， 要求统计当前已经插入的人中，有优势的人的个数。





```cpp
#include<bits/stdc++.h>
using namespace std;
struct ty{
    int x,y;
    bool operator < (const ty & a)  const {
        return x<a.x||(x==a.x&&y<a.y);
    }
};
multiset <ty> st;
int n;
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t; 
	for(int ka=1;ka<=t;ka++){
	cin>>n;
        st.clear();
        for(int i=1;i<=n;i++)
        {
            int x,y;
            cin>>x>>y;
            ty p;
            p.x=x;
            p.y=y;
            multiset <ty>::iterator it=st.lower_bound(p);
            if(it==st.begin()||(--it)->y>y)
                st.insert(p);
            it=st.upper_bound(p);
            while(it!=st.end()&&it->y>=y)
                st.erase(it++);
        }
        cout<<st.size()<<endl;
	}
	return 0;
}
```









