# HDU1028 POJ 1664 整数划分问题 - 紫芝的博客 - CSDN博客





2018年09月23日 10:26:56[紫芝](https://me.csdn.net/qq_40507857)阅读数：37








Well, it seems the first problem is too easy. I will let you know how foolish you are later." feng5166 says. 

"The second problem is, given an positive integer N, we define an equation like this: 

  N=a[1]+a[2]+a[3]+...+a[m]; 

  a[i]>0,1<=m<=N; 

My question is how many different equations you can find for a given N. 

For example, assume N is 4, we can find: 

  4 = 4; 

  4 = 3 + 1; 

  4 = 2 + 2; 

  4 = 2 + 1 + 1; 

  4 = 1 + 1 + 1 + 1; 

so the result is 5 when N is 4. Note that "4 = 3 + 1" and "4 = 1 + 3" is the same in this problem. Now, you do it!" 

Input

The input contains several test cases. Each test case contains a positive integer N(1<=N<=120) which is mentioned above. The input is terminated by the end of file. 

Output

For each test case, you have to output a line contains an integer P which indicate the different equations you have found. 

Sample Input

```
4
10
20
```

Sample Output

```
5
42
627
```

放苹果
|**Time Limit:** 1000MS||**Memory Limit:** 10000K|
|----|----|----|
|**Total Submissions:** 37597||**Accepted:** 23147|

Description

把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

Input

第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。

Output

对输入的每组数据M和N，用一行输出相应的K。

Sample Input

1
7 3

Sample Output

8
整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。

    如6的整数划分为，共11种。

```
6
    5 + 1
    4 + 2, 4 + 1 + 1
    3 + 3, 3 + 2 + 1, 3 + 1 + 1 + 1
    2 + 2 + 2, 2 + 2 + 1 + 1, 2 + 1 + 1 + 1 + 1
    1 + 1 + 1 + 1 + 1 + 1
```

**下面介绍一种通过递归方法得到一个正整数的划分数。**


    递归函数的声明为 int split(int n, int m);其中n为要划分的正整数，m是划分中的最大加数(当m > n时，最大加数为n)，
1 当n = 1或m = 1时，split的值为1，可根据上例看出，只有一个划分1 或 1 + 1 + 1 + 1 + 1 + 1

    可用程序表示为 * if(n == 1 || m == 1) return 1;*

    2 下面看一看m 和 n的关系。它们有三种关系
  (1) m > n

    在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为split(n, n);

    可用程序表示为  **if(m > n) return split(n, n);  **
  (2) m = n

    这种情况可用递归表示为split(n, m - 1) + 1，从以上例子中可以看出，就是最大加

    数为6和小于6的划分之和

    用程序表示为  **if(m == n) return (split(n, m - 1) + 1);**
  (3) m < n

    这是最一般的情况，在划分的大多数时都是这种情况。

    从上例可以看出，设m = 4，那split(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。

    因此，split(n, m)可表示为  **split(n, m - 1) + split(n - m, m)**


```cpp
#include <stdio.h>

   int split(int n, int m)
   {
      if(n < 1 || m < 1) return 0;
      if(n == 1 || m == 1) return 1;
      if(n < m) return split(n, n);
      if(n == m) return (split(n, m - 1) + 1);
      if(n > m) return (split(n, m - 1) + split((n - m), m));
  }

int main()
{
     printf("12的划分数: %d", split(12, 12));
    return 0;
}
```

直接递归计算可能会超时，所以考虑记忆化搜索

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e3+7;
#define mod 1000000007
ll dp[130][130];
//n为要划分的正整数，m是划分中最大加数
void init()
{
    memset(dp,-1,sizeof dp);
    for(int i=1;i<130;i++)
        dp[i][1]=dp[1][i]=1;
}
ll split(int n,int m)
{
    if(dp[n][m]!=-1)
        return dp[n][m];
    if(n<1||m<1)
        return dp[n][m]=0;
    if(n==1||m==1)
        return dp[n][1]=dp[1][m]=1;
    if(m>n)//m>n,最大加数为n
        return dp[n][n]=split(n,n);
    if(m==n)
        return dp[n][m]=split(n,m-1)+1;
    if(m<n)
        return dp[n][m]=split(n,m-1)+split(n-m,m);
}

int main()
{
    init();
    int n;
    while(scanf("%d",&n)!=EOF){
        printf("%lld\n",split(n,n));
    }
    return 0;
}
```

POJ 1664 放苹果

```cpp
//#include<bits/stdc++.h>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long ll;
const int maxn=1e3+7;
#define mod 1000000007
ll dp[130][130];
//n为要划分的正整数，m是划分中最大加数
void init()
{
    memset(dp,-1,sizeof dp);
    for(int i=1;i<130;i++)
        dp[i][1]=dp[1][i]=1;
}
ll split(int n,int m)
{
    if(dp[n][m]!=-1)
        return dp[n][m];
    if(n<1||m<1)
        return dp[n][m]=0;
    if(n==1||m==1)
        return dp[n][1]=dp[1][m]=1;
    if(m>n)//m>n,最大加数为n
        return dp[n][n]=split(n,n);
    if(m==n)
        return dp[n][m]=split(n,m-1)+1;
    if(m<n)
        return dp[n][m]=split(n,m-1)+split(n-m,m);
}

int main()
{
    init();
    int n,m;
    int T;
    scanf("%d",&T);
    while(T--){
            scanf("%d%d",&m,&n);
        printf("%lld\n",split(m,n));
    }
    return 0;
}
```





