# 巴什博弈例题：NYOJ23；HDU：2149，1847，2897，2188 - 紫芝的博客 - CSDN博客





2018年05月01日 12:24:53[紫芝](https://me.csdn.net/qq_40507857)阅读数：35








## 巴什博弈：

只有一堆n个物品，两个人轮流从这堆物品中取除，每次取的个数为[1,m](至少去一个，最多取m个)，最后取完者获胜

### 特征：

物品只有一堆，简单变形：

要么在范围内不规定个数，要么规定只能取几个 

### 分析：

1.如果n<=m,那么先者一定赢 

2.如果n=m+1,那么由于一次最多取m个，无论先取者拿走多少个，后者一定能够一次拿走所有物品，后者取胜 

3.因此，我们发现了如何取胜的方法：

如果n=(m+1)*r+s;(r为任意自然数，s<=m),那么先取者拿走s个物品，后取者拿走k(k<=m)个物品，先取者再拿走（m+1-k）个物品，结果剩下（m+1）*（r-1）个物品，那么先取者一定获胜


4.要保持给对手留下（m+1）的倍数个物品，只要n%(m+1)!=0,先取者一定获胜

###  例题：

NYOJ２３取石子（一）

```cpp
//hdu2149 巴什博弈 
#include<bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	int n,m,t;
	cin>>t;
	while(t--){
			cin>>n>>m;
			if(n%(m+1)!=0)
			printf("Win\n");
			else
			printf("Lose\n");
		}
	return 0;
 }
```

HDU２１４９    **Public Sale**

```cpp
//hdu2149 巴什博弈 
#include<bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	int n,m;
	while(cin>>n>>m){
		if(n<=m){
			for(int i=n;i<m;i++)
			printf("%d ",i);
			printf("%d\n",m);
		}else{
			if(n%(m+1)==0)
			printf("none\n");
			else{
				bool first=1;//控制输出格式 
				for(int s=1;s<=m;s++)
				{
					if((n-s)%(m+1)==0)
					{
						if(first){//如果是第一个元素 
						printf("%d",s);
						first=0;//已输出第一个元素 
						}	
						else
						printf(" %d");//非第一个元素，前面右一个空格						
					}
				}
				printf("\n");
			}
		}
	}
	return 0;
 }
```

优化之后的代码：

**1.若n>m,先取者必胜2.若n%(m+1)!=0，那么第一个取的数就是n%(m+1);**

**留给对手的就是m+1的倍数 **

```cpp
#include<iostream>
using namespace std;
int main()
{   int n;//成本 
	int m;//最大加价 
    while(scanf("%d%d",&n,&m)!=EOF)
    {  
        if(n%(m+1)==0) cout<<"none";
        else
        {   if(n%(m+1))  cout<<n%(m+1); //直接取余数 
            if(m>=n)
            {   for(int i=n+1;i<=m;i++)
                    cout<<" "<<i;
            } 
        }
        cout<<endl;
    }
    return 0;
}
```

Java 

```java
import java.util.*;
import java.math.*;

public class Main{
	static int MAXN=(int)(2e5+10);
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		while(cin.hasNext()) {
			int m=cin.nextInt();
			int n=cin.nextInt();
			if(m<=n) {
				for(int i=m;i<=n;i++) {
					System.out.print(i);
					if(i==n)
						System.out.println();
					else
						System.out.print(" ");
				}
				continue;
			}
			if(m%(n+1)==0)
				System.out.println("none");
			else {
				int x=m%(n+1);
				System.out.println(x);
			}
		}
		cin.close();
	}
}
```

HDU1847 巴什博弈

寻找必败状态，若n%3=0，则cici赢，否则kiki赢

枚举前面几个数，找规律

分析：

1.若留给cici的是3，那么cici只能取1个或者2个

所以下一次Kiki取后必赢

2.若是给Cici留下的是3的倍数，假设为3n(n=1,2,3,..)，

那么无论Cici取什么数，剩余的数一定可以写成3m+1或者3m+2(m<n)的形式，

那么只要Kiki再取的时候留给Cici的仍然是3的倍数的话，就必胜了 

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	int n;
	while(cin>>n){
		if(n%3==0)
		cout<<"Cici\n";
		else cout<<"Kiki\n";
	} 
	return 0;
 }
```

HDU2188 

```java
import java.util.*;
import java.math.*;

public class Main{
	static int MAXN=(int)(2e5+10);
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		int T=cin.nextInt();
		while((T--)!=0) {
			int n=cin.nextInt();
			int m=cin.nextInt();
			if(n<=m) {
				System.out.println("Grass");
				continue;
			}
			if(n%(m+1)==0) {
				System.out.println("Rabbit");
			}else {
				System.out.println("Grass");
			}
		}
		cin.close();
	}
}
```

### HDU 2897 巴什博弈变形

每行有三个数字n，p，q，表示一堆硬币一共有n枚，从这个硬币堆里取硬币，一次最少取p枚，最多q枚，如果剩下少于p枚就要一次取完。两人轮流取，直到堆里的硬币取完，最后一次取硬币的算输。对于每一行的三个数字，给出先取的人是否有必胜策略，如果有回答WIN，否则回答LOST。

**Input**

不超过100000行，每行三个正整数n，p，q。

**Output**

对应每行输入，按前面介绍的游戏规则，判断先取者是否有必胜策略。输出WIN或者LOST。

**Sample Input**

7 2 4

6 2 4

**Sample Output**

LOST

WIN

### 分析：

假设先取者为A，后取者为B，初始状态下有石子n个，除最后一次外，其他每次取得石子个数必须在[p，q]之间。 

**1）：若当前石子共有n = （p+q） * r个，则A必胜；**

必胜策略为：A第一次取q个，以后每次若B取K个，A取（p+q-k）个，如此下去；最后必剩下p个给B，所以A必胜。 

**2）若n = （p+q）* r + left个（1 <= left <= p）B必胜；**

必胜策略为：每次取石子活动中，若A取k个，则B去（p+q-k）个，那么最后剩下left个给A，此时left <= p，所以A只能一次去完，B胜。 

**3）若n = （p+q） * r + left个（p < left <= q），则A必胜；**

必胜策略为：A第一次取t（1 <= left – t < = p）个，以后每次B取k个，则A取（p+q-k）个，那么最后留下1 <= left – t <= p给B，则A胜。

（也就相当于当A取得时候，他可以把当前局势变为第2种的，即让B面对必败态，这时候的原理和第2种就一样了）

```java
import java.util.*;
import java.math.*;

public class Main{
	static int MAXN=(int)(2e5+10);
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		while(cin.hasNext()) {
			int n=cin.nextInt();
			int p=cin.nextInt();
			int q=cin.nextInt();
			int left=n%(p+q);
			if(left==0)
				System.out.println("WIN");
			else if(left<=p)
				System.out.println("LOST");
			else 
				System.out.println("WIN");
		}
		cin.close();
	}
}
```

打表代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include<iostream>
using namespace std;
const int maxn=2e5+10;
int sg[maxn];
int vis[maxn];
void SG(int n,int p,int q)
{
    int i,j;
    memset(sg,0,sizeof(sg));
    for(i=p+1; i<=n; ++i)
    {
        memset(vis,0,sizeof(vis));
        for(j=p; j<=q; ++j)
            vis[sg[i-j]]=1;//标记最小的不属于这个集合的非负整数
        for(j=0; j<n; ++j)
            if(!vis[j])
            {
                sg[i]=j;
                break;
            }
    }
    for(i=0; i<n; i++)
        cout<<sg[i]<<endl;
}
int main(){
    int n,p,q;
    while(scanf("%d%d%d",&n,&p,&q)!=EOF){
        SG(n,p,q);
    }
}
```





