# HDU 1853 & HDU 3488【有向环最小权值覆盖问题 】最小费用最大流 - 紫芝的博客 - CSDN博客





2018年10月07日 20:29:30[紫芝](https://me.csdn.net/qq_40507857)阅读数：53








## [HDU 1853 & HDU 3488【有向环最小权值覆盖问题 】带权二分图匹配 KM算法](https://blog.csdn.net/qq_40507857/article/details/82960984)

In the kingdom of Henryy, there are N (2 <= N <= 200) cities, with M (M <= 30000) one-way roads connecting them. You are lucky enough to have a chance to have a tour in the kingdom. The route should be designed as: The route should contain one or more loops. (A loop is a route like: A->B->……->P->A.) 

Every city should be just in one route. 

A loop should have at least two cities. In one route, each city should be visited just once. (The only exception is that the first and the last city should be the same and this city is visited twice.) 

The total distance the N roads you have chosen should be minimized. 

Input

An integer T in the first line indicates the number of the test cases. 

In each test case, the first line contains two integers N and M, indicating the number of the cities and the one-way roads. Then M lines followed, each line has three integers U, V and W (0 < W <= 10000), indicating that there is a road from U to V, with the distance of W. 

It is guaranteed that at least one valid arrangement of the tour is existed. 

A blank line is followed after each test case.

Output

For each test case, output a line with exactly one integer, which is the minimum total distance.

Sample Input

1
6 9
1 2 5
2 3 5
3 1 10
3 4 12
4 1 8
4 6 11
5 4 7
5 6 9
6 5 4
Sample Output

42
### 题意：

**给出n个点m条单向边边以及经过每条边的费用，让你求出走过一个哈密顿环（除起点外，每个点只能走一次）的最小费用。**

### 解析：

任意类似的**【有向环最小权值覆盖】**问题，都可以用最小费用流来写。

由于题目中要求每个点最多走一次，为了防止走多次的发生，我们要**把每个点 i 拆成左点i 和 右点i + n两个点**。

具体建图如下:



源点outset编号0, 所有左点编号 1~n ，右点编号 n+1 ~ 2*n, 汇点inset 编号 2*n+1.
**（1）源点outset到第i个点有边 ( outset, i, 1, 0)，即源点和左点建边。**
**（2）如果从 i 点到 j 点有权值为 c 的边,那么有边  (i,  j+n,  1,  c)，即左点和右点建边， 确保了每个点只走一次。**
**（3）每个节点到汇点有边 (i+n,  inset,  1,  0)， 即右点和汇点建边。**


最终如果最大流 == n 的话（即满流），那么最小费用就是我们所求；若最大流量小于n，则不存在满足条件的环

为什么这样的构图方法就可以求得我们所要的解， 具体解析请点这里：[解析](http://blog.csdn.net/u013480600/article/details/39159407)

而且本题时间要求比较严格，而且**点少边多**；各种超时，需要加个去重边处理才行。**即先用邻接矩阵存储最小边权，然后再建图**

```cpp
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<queue>
#include<cstdio>
#include<string>
#include<math.h>
#include<algorithm>
#include<map>
#include<set>
#include<stack>
#define mod 998244353
#define INF 0x3f3f3f3f
#define eps 1e-6
using namespace std;
typedef long long ll;
#define MAXN 1003
#define MAXM 40004
//最小费用最大流
struct Edge{
    int to,next;
    int flow,cost,cap;
}edge[MAXM];
int tol,head[MAXN];
void init()
{
    tol=0;
    memset(head,-1,sizeof head);
}
void addEdge(int u,int v,int cap,int cost){
    edge[tol].to=v;
    edge[tol].cap=cap;
    edge[tol].cost=cost;
    edge[tol].flow=0;
    edge[tol].next=head[u];
    head[u]=tol++;

    edge[tol].to=u;
    edge[tol].cap=0;
    edge[tol].cost=-cost;
    edge[tol].flow=0;
    edge[tol].next=head[v];
    head[v]=tol++;
}

bool inq[MAXN];//标记是否点是否在队列
int dis[MAXN];//最短距离
int pre[MAXN];//记录路径
int q[MAXN*10];//队列
//单位费用可能是负值，所以用SPFA
bool spfa(int st,int en)
{
    memset(inq,0,sizeof inq);
    memset(dis,INF,sizeof dis);
    memset(pre,-1,sizeof pre);

    int rear=0,front=0;
    dis[st]=0;
    inq[st]=true;
    q[front++]=st;
    while(rear<front){
        int u=q[rear++];
        inq[u]=false;

        for(int e=head[u];e!=-1;e=edge[e].next){
            int v=edge[e].to;
            if(edge[e].cap>edge[e].flow&&dis[v]>dis[u]+edge[e].cost){
                dis[v]=dis[u]+edge[e].cost;
                pre[v]=e;//表示边e-->v,e就是v的前驱
                if(!inq[v])
                    inq[v]=true,q[front++]=v;
            }
        }
    }
    return pre[en]!=-1;
}
int MCMF(int st,int en,int &cost,int &flow)
{
    //如果能找到从源点到汇点的最短路，说明还没有达到最小费用最大流
    while(spfa(st,en)){
        int Min=INF;//最小残余流量
        //沿着当前路径返回
        for(int i=pre[en];i!=-1;i=pre[edge[i^1].to]){
            int rem=edge[i].cap-edge[i].flow;
            Min=Min>rem?rem:Min;
        }
        for(int i=pre[en];i!=-1;i=pre[edge[i^1].to]){
            edge[i].flow+=Min;//正向边添加残余流量
            edge[i^1].flow-=Min;//反向边减少残余流量
            cost+=Min*edge[i].cost;
        }
        flow+=Min;
    }
}
//以上为最小费用最大流模板
int mp[210][210];
int main()
{
    int n,m;
    int T;
    scanf("%d",&T);
    while(T--){
      scanf("%d%d",&n,&m);
        memset(mp,INF,sizeof mp);
        init();
        int st=0,en=2*n+1;
        for(int i=1;i<=n;i++){
            addEdge(st,i,1,0);
            addEdge(n+i,en,1,0);
        }
        //去重边操作
        for(int i=1;i<=m;i++)
        {
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            mp[u][v]=min(mp[u][v],w);
            //addEdge(u,n+v,1,w);
        }
        //建图
        for(int i=1;i<=n;i++){
          for(int j=1;j<=n;j++){
            if(mp[i][j]!=INF)
            addEdge(i,j+n,1,mp[i][j]);
          }
        }
        int cost=0,flow=0;
        MCMF(st,en,cost,flow);
        //printf("%d  %d\n",flow,cost);

        if(flow==n)
            printf("%d\n",cost);
        else
            printf("-1\n");
    }
}
```



