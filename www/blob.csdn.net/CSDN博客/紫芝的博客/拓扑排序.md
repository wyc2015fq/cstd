# 拓扑排序 - 紫芝的博客 - CSDN博客





2018年07月30日 11:02:31[紫芝](https://me.csdn.net/qq_40507857)阅读数：440
个人分类：[图论](https://blog.csdn.net/qq_40507857/article/category/7659793)









**拓扑排序**

    一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在有向图中若以顶点表示活动，有向边表示活动之间的先后关系，这样的图简称为AOV网。在AOV网中为了更好地完成工程，必须满足活动之间先后关系，需要将各活动排一个先后次序即为拓扑排序

**• 1.从有向图中选取一个没有前驱的顶点，并输出之；**

**•2.从有向图中删去此顶点以及所有以它为尾的弧；**

**•重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。**

**没有前驱 <--> 入度为零，删除顶点及以它为尾的弧-- 弧头顶点的入度减1。**

### 拓扑排序方法

对象：有向无环图（DAG）

![](https://img-blog.csdn.net/20180730114323233?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA3ODU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**1.BFS**

•**每次可以拿出的顶点一定是入度为 0 的点，即没有被指向的点，因为这样的点表示的事件没有依赖，在一个入度为 0 的点表示的事件执行完之后，它所指向的顶点所依赖的点就少了一个，所以我们可以先将所有入度为 0 的点加入一个队列中，然后依次将它们所指向的点的入度减 1，再将入度变为 0 的点也依次加入队列，这样最后就可以得到一个拓扑有序的序列。**

**根据BFS算法思想：**

**1.找到所有入度为 0 的点，并加入队列，此时 3、5 被加入队列**

**2.取队首，即 3 顶点，将 2、6 的入度减 1**

**3.再取队首 5 顶点，将 1、2、6 的入度再减 1，此时 1 的入度为 0，加入队列**

**4.取队首 1 顶点，将 2、4 顶点的入度减 1，此时 2、4 的入度均为 0.加入队列**

**5.取队首 2 顶点，将 6 顶点的入度减 1，此时 6 的入度为 0，也加入队列**

**6.取队首 4 顶点，4 顶点没有指向任何顶点**

**7.取队首 6 顶点，6 顶点也没有指向任何顶点**

**8.此时队列为空，且所有顶点均参与了排序，此时得到一个拓扑序 3、5、1、2、4、6. **

**2.DFS**

**•对于图上的一条边 u,v，一定有v 比 u 更早退出 DFS 过程，而拓扑排序的顺序正好相反，对于一条边 u,v，需要 u 排在 v前面，所以可以利用 DFS，将所有的点按照退出 DFS 的过程倒序排列，即得到一个图的拓扑序。**

**根据DFS思想：**

**1.假设从 1 开始进行深度优先搜索，搜索顺序依次为：1、2、6、4，或 1、4、2、6**

**2.此时并没有搜索到全部顶点，从下一个没有搜索过的顶点再执行深度优先搜索，剩下的点的搜索顺序可以是 3、5 或者 5、3**

**3.这样根据搜索结束的顺序，即可以得到一个该图的拓扑序：3、5、1、2、6、4。**

**拓扑排序的应用：**

•判断一个有向图中是否有环。无环的图所有点都能进行拓扑排序。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=510;
int graph[maxn][maxn];//保存图
int degree[maxn];//保存入度
int TOP[maxn];//保存已删除点
int main()
{
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
    	int now = 0；//指针作用记录TOP中可插入的位置
        memset(graph,0,sizeof(graph));
        memset(degree,0,sizeof(degree));
        for(int i=0;i<m;i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            if(!graph[u][v])
            {
                graph[u][v]=1;
                degree[v]++;//v的入度++
            }
        }
        queue<int>q;
        for(int i=1;i<=n;i++)
            if(degree[i]==0)
            q.push(i);
        while(!q.empty())
        {
            int cur=q.front();
            q.pop();
            TOP[now++]=cur;
            for(int i=1;i<=n;i++)
            {
                if(graph[cur][i]==1)
                {
                    degree[i]--;//相连的点的入度减1
                    if(degree[i]==0)//假设入度为0，增加队列
                        q.push(i);
                }
            }
        }
        //这里可以添加输出，排序已保存在TOP数组中
    }
    return 0;
}
```





