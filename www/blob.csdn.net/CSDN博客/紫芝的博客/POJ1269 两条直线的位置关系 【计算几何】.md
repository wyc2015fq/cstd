# POJ1269 两条直线的位置关系 【计算几何】 - 紫芝的博客 - CSDN博客





2018年10月25日 15:29:50[紫芝](https://me.csdn.net/qq_40507857)阅读数：35








# Intersecting Lines

We all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways: 1) no intersection because they are parallel, 2) intersect in a line because they are on top of one another (i.e. they are the same line), 3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. 

Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. 

Input

The first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4).

Output

There should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read "END OF OUTPUT".

Sample Input

```
5
0 0 4 4 0 4 4 0
5 0 7 6 1 0 2 3
5 0 7 6 3 -6 4 -3
2 0 2 27 1 5 18 5
0 3 4 0 1 2 2 5
```

Sample Output

```
INTERSECTING LINES OUTPUT
POINT 2.00 2.00
NONE
LINE
POINT 2.00 5.00
POINT 1.07 2.20
END OF OUTPUT
```

### 题意：

**两点确定一条直线，给出两条直线：**

**1.若两直线平行，输出NONE**

**2.若两直线重合，输出LINE**

**3.若两直线相交，求出交点**

## 关键：叉积的运用

直线的一般方程为：F(x)=a*x+b*y+c=0,假设已经知道直线过两个点(x0,y0),(x1,y1)

**a=y0-y1;   b=x1-x0;   c=x0*y1-x1*y0;**

将两条直线表示为:

**F0(x)=a0*x+b0*y+c0=0;    F1(x)=a1*x+b1*y+c1=0;**

两条直线的交点满足：a0*x+b0*y+c0=a1*x+b1*y+c1;

**x=(b0*c1-b1*c0)/D;   y=(a1*c0-a0*c1)/D;    D=a0*b1-a1*b0;**

D等于0时，两直线平行；

**若两条直线平行，且直线上一点在另一条直线上，则两直线重合**

```cpp
import java.util.*;
import java.math.*;
class point{
	double x,y;
	public void point(double x,double y) {
		this.x=x;
		this.y=y;
	}
}
class segment{
	point a,b;
	public void segment(point a,point b) {
		this.a=a;
		this.b=b;
	}
}
public class Main{
	static int maxn=110;
	static double EPS=1e-2;
	static int n;

	static double dist(point a,point b) {
		double dis=Math.sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
		return dis;
	}
	
	//判断点是否在过a，b两点的直线上
	//若两条直线斜率相等，则点在直线上
	static double cross(point a,point b,point p) {
		return (a.x-p.x)*(b.y-p.y)-(b.x-p.x)*(a.y-p.y);//叉积
	}
	
	
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		int T=cin.nextInt();
		System.out.println("INTERSECTING LINES OUTPUT");
		while((T--)!=0) {
				segment[] seg=new segment[3];
				for(int i=1;i<=2;i++) {	
				point a=new point();
				point b=new point();
				a.x=cin.nextDouble();
				a.y=cin.nextDouble();
				b.x=cin.nextDouble();
				b.y=cin.nextDouble();
				segment tmp=new segment();
				tmp.segment(a, b);
				seg[i]=tmp;
			}
				double a1=seg[1].a.y-seg[1].b.y;
				double b1=seg[1].b.x-seg[1].a.x;
				double c1=seg[1].a.x*seg[1].b.y-seg[1].b.x*seg[1].a.y;
				
				double a2=seg[2].a.y-seg[2].b.y;
				double b2=seg[2].b.x-seg[2].a.x;
				double c2=seg[2].a.x*seg[2].b.y-seg[2].b.x*seg[2].a.y;
				
				double D=a1*b2-a2*b1;
				if(Math.abs(D)==0) {//两直线平行
					if(cross(seg[1].a, seg[1].b, seg[2].a)==0)//两直线重合
						System.out.println("LINE");
					else
						System.out.println("NONE");
					continue;
				}
				double x=(b1*c2-b2*c1)/D,y=(a2*c1-a1*c2)/D;
				System.out.println("POINT " + String.format("%.2f", x) + " "+String.format("%.2f", y));
			}
		
		System.out.println("END OF OUTPUT");
		cin.close();
	}
}
```

[kuangbin的模板](https://www.cnblogs.com/kuangbin/p/3189088.html)

POJ有毒：

**C++使用%.2f或者%.2lf输出double，G++使用%.2f输出double**

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
#include <map>
#include <vector>
#include <set>
#include <string>
#include <math.h>

using namespace std;
const double eps = 1e-8;
int sng(double x)
{
    if(fabs(x)<eps)
        return 0;
    if(x<0) return -1;
    else return 1;
}
struct point{
    double x,y;
    point(){}
    point(double _x,double _y)
    {
        x=_x;   y=_y;
    }
    point operator -(const point &b)const{
        return point(x-b.x,y-b.y);
    }
    //叉积
    double operator ^(const point &b)const{
        return x*b.y-y*b.x;
    }
    //点积
    double operator *(const point &b)const{
        return x*b.x+y*b.y;
    }
    //绕原点旋转角度（弧度制B）之后，x，y的变化
    void transXY(double B){
        double tx=x,ty=y;
        x=tx*cos(B)-ty*sin(B);
        y=tx*sin(B)+ty*cos(B);
    }
};

struct line{
    point s,e;
    double k;
    line(){}
    line(point _s,point _e){
        s=_s;   e=_e;
        k=atan2(e.y-s.y,e.x-s.x);
    }
    //两条直线求交点
    //第一个值为0表示直线重合，为1表示平行，为2表示相交
    //第二个值为交点，只有第一个值为2时，交点才有意义
    pair<int,point> operator &(const line &b)const{
        point res=s;
        if(sng((s-e)^(b.s-b.e))==0){
            if(sng((s-b.e)^(b.s-b.e))==0)
                return make_pair(0,res);//重合
            return make_pair(1,res);//平行
        }
        double t=((s-b.s)^(b.s-b.e))/((s-e)^(b.s-b.e));
        res.x+=(e.x-s.x)*t;
        res.y+=(e.y-s.y)*t;
        return make_pair(2,res);
    }
};
//两点距离
double dist(point a,point b)
{
    return sqrt((a-b)*(a-b));
}
bool inter(line l1,line l2)
{
    return
        max(l1.s.x,l1.e.x)>=min(l2.s.x,l2.e.x)&&
        max(l2.s.x,l2.e.x)>=min(l1.s.x,l1.e.x)&&
        max(l1.s.y,l1.e.y)>=min(l2.s.y,l2.e.y)&&
        max(l2.s.y,l2.e.y)>=min(l1.s.y,l1.e.y)&&
        sng((l2.s-l1.s)^(l1.e-l1.s))*sng((l2.e-l1.s)^(l1.e-l1.s))<=0&&
        sng((l1.s-l2.s)^(l2.e-l1.s))*sng((l1.e-l2.s)^(l2.e-l2.s))<=0;
}
int main()
{
    int T;
    scanf("%d",&T);
    printf("INTERSECTING LINES OUTPUT\n");
    while(T--){

        line L1,L2;
        scanf("%lf%lf%lf%lf",&L1.s.x,&L1.s.y,&L1.e.x,&L1.e.y);
        scanf("%lf%lf%lf%lf",&L2.s.x,&L2.s.y,&L2.e.x,&L2.e.y);
        pair<int,point> res=L1&L2;
        if(res.first==0)
            printf("LINE\n");
        else if(res.first==1)
            printf("NONE\n");
        else
            printf("POINT %.2lf %.2lf\n",(res.second).x,(res.second).y);
    }
    printf("END OF OUTPUT\n");
}
```





