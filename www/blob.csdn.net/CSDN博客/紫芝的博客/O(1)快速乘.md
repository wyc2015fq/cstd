# O(1)快速乘 - 紫芝的博客 - CSDN博客





2018年08月27日 12:31:59[紫芝](https://me.csdn.net/qq_40507857)阅读数：676








*引用自2009年国家集训队论文，骆可强：《论程序底层优化的一些方法与技巧》*

如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。

```cpp
typedef long long ll;
#define MOL 123456789012345LL
inline ll mul_mod_ll(ll a,ll b)
{
    ll d=(ll)floor(a*(long double)b/MOL+0.5);
    ll ret=a*b-d*MOL;
    if(ret<0)   ret+=MOL;
    return   ret;
}
```

首先，使用浮点数计算 a*b/MOL 的值，关键在于第二句，显然  a*b -  d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。

考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。

### 模板

```cpp
inline ll ksc(ll x,ll y,ll mod)
{
    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     
}
```

因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。



