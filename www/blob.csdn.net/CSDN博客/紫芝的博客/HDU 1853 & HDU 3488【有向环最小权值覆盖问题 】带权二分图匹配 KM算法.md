# HDU 1853 & HDU 3488【有向环最小权值覆盖问题 】带权二分图匹配  KM算法 - 紫芝的博客 - CSDN博客





2018年10月07日 20:33:33[紫芝](https://me.csdn.net/qq_40507857)阅读数：31
个人分类：[二分图](https://blog.csdn.net/qq_40507857/article/category/7982736)









### [HDU 1853 & HDU 3488【有向环最小权值覆盖问题 】最小费用最大流](https://blog.csdn.net/qq_40507857/article/details/82960767)

In the kingdom of Henryy, there are N (2 <= N <= 200) cities, with M (M <= 30000) one-way roads connecting them. You are lucky enough to have a chance to have a tour in the kingdom. The route should be designed as: The route should contain one or more loops. (A loop is a route like: A->B->……->P->A.) 

Every city should be just in one route. 

A loop should have at least two cities. In one route, each city should be visited just once. (The only exception is that the first and the last city should be the same and this city is visited twice.) 

The total distance the N roads you have chosen should be minimized. 

Input

An integer T in the first line indicates the number of the test cases. 

In each test case, the first line contains two integers N and M, indicating the number of the cities and the one-way roads. Then M lines followed, each line has three integers U, V and W (0 < W <= 10000), indicating that there is a road from U to V, with the distance of W. 

It is guaranteed that at least one valid arrangement of the tour is existed. 

A blank line is followed after each test case.

Output

For each test case, output a line with exactly one integer, which is the minimum total distance.

Sample Input

1
6 9
1 2 5
2 3 5
3 1 10
3 4 12
4 1 8
4 6 11
5 4 7
5 6 9
6 5 4
Sample Output

42
### 题意：

**给出n个点m条单向边边以及经过每条边的费用，让你求出走过一个哈密顿环（除起点外，每个点只能走一次）的最小费用。**

### **[二分图最大权匹配 KM算法](https://blog.csdn.net/qq_40507857/article/details/82182463)**

**有向环最小权值覆盖问题可以使用KM算法（带权二分图匹配算法）**

我们把任意一个顶点i都分成两个,即i和i’. 如果原图存在i->j的边,那么二分图有i->j’的边.

       下面我们要引出几条结论:

**  1. **如果原图能由**多个不相交的有向环覆盖,那么二分图必然存在完备匹配.**

(**假设原图的有向环为(1->2->3->1) and(6->5->4->6),那么二分图的完备匹配就是1->2’ 2->3’ 3->1’6->5’ 5->4’ 4->6’**)

** 2.如果二分图存在完备匹配,那么原图必定能由几个不相交的有向环覆盖.**

(**假设二分图的完备匹配是1->2’ 2->3’ 3->1’ 6->5’ 5->4’ 4->6’那么原图的有向环为(1->2->3->1) and (6->5->4->6)**)

** 3.如果原图存在权值最大的有向环覆盖,那么二分图的最优匹配一定就是这个值.**

(**因为该有向环覆盖对应了一个二分图的完备匹配,而该完备匹配的权值就等于该有向环覆盖的权值,所以最优匹配不可能丢失该最大权值的匹配**)

**有解：**

** 现在原题要求的是最小长度匹配,我们把所有已知边的权值都取负数,且那些不存在的边我们取-INF(负无穷). 如果完备匹配存在,那么我们求出的最优匹配权值的绝对值 肯定<INF. 且该绝对值就是最小权值匹配.**

**无解：**

**   如果完备匹配不存在,那么最优匹配权值的绝对值 肯定>INF， 或者这么说,如果最终求得的匹配中,有任何一个匹配边用了权值为负无穷的边,那么最优匹配不存在(即完备匹配不存在)**

**注意:此题输入可能存在重边.**

```cpp
#include<cstdio>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
const int maxn=1e4+10;
int n,m;
int w[maxn][maxn];
int lx[maxn],ly[maxn];
int link[maxn];
int slack[maxn];
int visx[maxn],visy[maxn];
bool dfs(int x)
{
    visx[x]=1;
    for(int y=1;y<=n;y++){
        if(visy[y]) continue;
        int t=lx[x]+ly[y]-w[x][y];
        if(t==0){
            visy[y]=1;
            if(link[y]==0||dfs(link[y])){
                link[y]=x;
                return 1;
            }
        }
        else if(slack[y]>t) slack[y]=t;
    }
    return 0;
}
int km()
{
    memset(lx,0,sizeof lx);
    memset(ly,0,sizeof ly);
    memset(link,0,sizeof link);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        if(lx[i]<w[i][j])
        lx[i]=w[i][j];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            slack[j]=INF;
        while(1){
            memset(visx,0,sizeof visx);
            memset(visy,0,sizeof visy);
            if(dfs(i))  break;
            int d=INF;
            for(int k=1;k<=n;k++)
                if(!visy[k]&&d>slack[k])
                d=slack[k];
            for(int k=1;k<=n;k++){
                if(visx[k]) lx[k]-=d;
                if(visy[k]) ly[k]+=d;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        //if(w[link[i]][i]==-INF) return -1;
        ans+=w[link[i]][i];
    }

    return -ans;
}
int main()
{
        int T;
    scanf("%d",&T);
    while(T--){
          scanf("%d%d",&n,&m);
        int u,v,cost;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            w[i][j]=-INF;

        for(int i=1;i<=m;i++){
            scanf("%d%d%d",&u,&v,&cost);
            cost=-cost;
            if(w[u][v]!=-INF)//去重边，取权值最小的边建图
                cost=max(cost,w[u][v]);
            w[u][v]=cost;
            //w[v][u]=cost;
        }
            printf("%d\n",km());
    }
}
```



