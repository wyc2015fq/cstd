# 最长回文子串 - 紫芝的博客 - CSDN博客





2018年04月04日 22:23:59[紫芝](https://me.csdn.net/qq_40507857)阅读数：888
个人分类：[解题模板																[动态规划](https://blog.csdn.net/qq_40507857/article/category/7565832)](https://blog.csdn.net/qq_40507857/article/category/7565904)








最长回文子串的概念：

一个字符串中连续的一段就是这个字符串的子串，而回文串指的是12421这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串啦



**一、分析：有两种可能，一种是回文字符串的长度为奇数，一种是偶数的情况。**

**i为字符串当前字符的下标。**

**当回文字串为奇数的时候，j表示i-j与i+j构成的回文字串长度；**

**当回文字串长度为偶数的时候，j表示i+1左边j个字符一直到i右边j个字符的回文字串长度**



**用maxvalue保存遍历结果得到的最大值并且输出**



```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	cin>>n;
	getchar();
	string s;
    while(n--){
    	//getline(cin,s);
    	cin>>s;
    	int len=s.length();
    	
		int temp,ans=-1;
		//i为字符串当前字符的下标 
    	for(int i=0;i<len;i++)
    	{
    		temp=1;//字符串的长度为奇数 
    		for(int j=1;j<len;j++)
    		{
    			if(i-j<0||i+j>=len||s[i-j]!=s[i+j])
    			break;
    			temp+=2;
			}
			ans=max(ans,temp);
			
			temp=0;//字符串的长度为偶数 
			for(int j=1;j<len;j++)
			{
				if(i-j+1<0||i+j>=len||s[i-j+1]!=s[i+j])
				break;
				temp+=2;
			}
			ans=max(ans,temp);
		}
		cout<<ans<<endl;
    }
   return 0;
}
```



**二、用动态规划算法来查找最长回文子串，算法时间复杂度为O（n²）。设状态dp[j][i]表示索引j到索引i的子串是否是回文串。则易得转移方程如下：**

**![](https://img-blog.csdn.net/20180405181217444)**

**则dp[j][i]为true时表示索引j到索引i形成的子串为回文子串，且子串起点索引为i,长度为j+i-1。**

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{	
	int n;
	string s;
	scanf("%d",&n);
	while(n--){	
	cin>>s;
	int len=s.length();
	bool dp[len][len];
	fill_n(&dp[0][0],len*len,false);
	
		int max_len=1; //保存最长回文子串长度
		int start=0;//保存最长回文子串起点
		for(int i=0;i<s.size();++i)
		{
			for(int j=0;j<=i;++j)
			{
				if(i-j<2)
					dp[j][i]=(s[i]==s[j]);
				else
					dp[j][i]=(s[i]==s[j] && dp[j+1][i-1]);
				if(dp[j][i] && max_len<(i-j+1))
				{
					max_len=i-j+1;
					start=j;
				}
			}
		}	
		string ret=s.substr(start,max_len);
		cout<<ret.length()<<endl;	
	}	
	return 0;
}
```










