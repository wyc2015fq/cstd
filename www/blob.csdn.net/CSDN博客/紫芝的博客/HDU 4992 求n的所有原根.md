# HDU 4992 求n的所有原根 - 紫芝的博客 - CSDN博客





2018年09月18日 10:31:31[紫芝](https://me.csdn.net/qq_40507857)阅读数：81








# Primitive Roots

****Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 1441    Accepted Submission(s): 367****

**Problem Description**

We say that integer x, 0 < x < n, is a primitive root modulo n if and only if the minimum positive integer y which makes x^y = 1 (mod n) true is φ(n) .Here φ(n) is an arithmetic function that counts the totatives of n, that is, the positive integers less than or equal to n that are relatively prime to n. Write a program which given any positive integer n( 2 <= n < 1000000) outputs all primitive roots of n in ascending order.

**Input**

Multi test cases.

Each line of the input contains a positive integer n. Input is terminated by the end-of-file seperator.

**Output**

For each n, outputs all primitive roots of n in ascending order in a single line, if there is no primitive root for n just print -1 in a single line.

**Sample Input**

4 25

**Sample Output**

3 2 3 8 12 13 17 22 23

**Source**

[BestCoder Round #8](http://acm.hdu.edu.cn/search.php?field=problem&key=BestCoder+Round+%238&source=1&searchmode=source)

**Recommend**

heyang   |   We have carefully selected several similar problems for you:  [6447](http://acm.hdu.edu.cn/showproblem.php?pid=6447)[6446](http://acm.hdu.edu.cn/showproblem.php?pid=6446)[6445](http://acm.hdu.edu.cn/showproblem.php?pid=6445)[6444](http://acm.hdu.edu.cn/showproblem.php?pid=6444)[6443](http://acm.hdu.edu.cn/showproblem.php?pid=6443)

# 题意

**求出n的所有原根，若不存在原根，输出-1**

# 分析

**原根的定义:对于n的原根x，则满足(x^y) mod  n=1的最小y=phi（n），phi（n）是n的欧拉函数值（小于等于n且与n互质的数的个数，包括1）。**

**如果g是模m的原根，整数d>=0，则g的d次幂是模m的原根的一个充要条件是d和phi(m)互质。**

**如果gcd（g，m）=1,g^d=1(mod m),则d为phi（m）的一个因子。换句话说如果g是m的原根，那么对于phi(m)的所有因子d（不包含phi(m)本身），g^d=1(mod m)是不成立的。我们可以通过枚举phi(m)的质因子，以及g^phi(m)=1(mod m)是否成立来判断g是否是模m的原根。**

有些不存在原根的数字用另一条性质判断：

模m有原根的充要条件是m=2,4,p^n,2×(p)^n,    (p为奇质数，n为任意数）

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N = 1000000;
bool f[N];//素数表
void getPrime()
{
    memset(f,0,sizeof f);
    int m=sqrt(N+0.5);
    for(int i=2;i<=m;i++)
        if(!f[i])
        for(int j=i*i;j<N;j+=i)
        f[j]=1;
}
//求欧拉函数
int phi(int x){
    if(!f[x])    return x-1;//x是素数
    int ans = x;
    for(int i=2; i*i<=x; i++){
        if(x%i==0){
            while(x%i==0)   x/=i;
            ans = ans - ans/i;
        }
    }
    if(x>1) ans = ans - ans/x;
    return ans;
}
//最大公约数
int gcd(int a, int b){
    return b==0?a:gcd(b,a%b);
}
//快速幂
ll quick_mod(ll a, ll b, ll mod){
    long long s = 1;
    while(b){
        if(b&1) s = (s*a)%mod;
        a = a*a%mod;
        b>>=1;
    }
    return s;
}
vector<int> V;
vector<int> G;

void cal(int x){
    G.clear();
    if(!f[x])    return;
    else{
        for(int i=2; i*i<=x; i++){
            if(x%i==0){
                G.push_back(i);
                if(i*i!=x)  G.push_back(x/i);
            }
        }
    }
}
//判断n是否存在原根
bool exist(int n){
    if(n%2==0)//偶数
        n/=2;
    if(!f[n])    return 1;//奇素数
    for(int i=3; i*i<=n; i+=2){
        if(n%i==0){
            while(n%i==0)   n/=i;
            return n==1;
        }
    }
    return 0;
}

void solve(int n){
    if(n==2){
        puts("1");
        return;
    }
    if(n==4){
        puts("3");
        return;
    }
    if(!exist(n)){
        puts("-1");
        return;
    }
    int p = phi(n);
    cal(p);
    int x = -1;
    for(int i=2; i<n; i++){
        bool flag = 1;
        if(quick_mod(i, p, n)!=1)   continue;
        for(int j=0; j<G.size(); j++){
            if(quick_mod(i, G[j], n)==1){
                flag = 0;
                break;
            }
        }
        if(flag){
            V.resize(1);
            V[0] = x = i;
            break;
        }
    }
    if(x==-1){
        puts("-1");
        return;
    }
    for(int i=2; i<p; i++){
        if(gcd(i, p)==1)
        V.push_back(quick_mod(x, i, n));
    }
    sort(V.begin(), V.end());
    vector<int>::iterator it=unique(V.begin(), V.end());
    V.erase(it, V.end());
    for(int i=0; i<V.size(); i++){
        if(i)   putchar(' ');
        printf("%d", V[i]);
    }
    puts("");
}
int main(){
    getPrime();
    int n;
    while(~scanf("%d", &n)) solve(n);
    return 0;
}
```





