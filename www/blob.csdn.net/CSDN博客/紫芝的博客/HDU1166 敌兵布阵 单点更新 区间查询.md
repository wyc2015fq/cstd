# HDU1166 敌兵布阵  单点更新  区间查询 - 紫芝的博客 - CSDN博客





2018年08月20日 23:15:05[紫芝](https://me.csdn.net/qq_40507857)阅读数：36








# 敌兵布阵

****Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 123221    Accepted Submission(s): 51619****

**Problem Description**

C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。

中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说："我知错了。。。"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.

**Input**

第一行一个整数T，表示有T组数据。

每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。

接下来每行有一条命令，命令有4种形式：

(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）

(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;

(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;

(4)End 表示结束，这条命令在每组数据最后出现;

每组数据最多有40000条命令

**Output**

对第i组数据,首先输出“Case i:”和回车,

对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。

**Sample Input**

```
1 
10 
1 2 3 4 5 6 7 8 9 10 
Query 1 3 
Add 3 6 
Query 2 7 
Sub 10 2 
Add 6 3 
Query 3 10 
End
```

**Sample Output**

```
Case 1: 
6 
33 
59
```

**Author**

Windbreaker

**Recommend**

Eddy   |   We have carefully selected several similar problems for you:  [1394](http://acm.hdu.edu.cn/showproblem.php?pid=1394)[1698](http://acm.hdu.edu.cn/showproblem.php?pid=1698)[1542](http://acm.hdu.edu.cn/showproblem.php?pid=1542)[1540](http://acm.hdu.edu.cn/showproblem.php?pid=1540)[1255](http://acm.hdu.edu.cn/showproblem.php?pid=1255)

```cpp
#include<cstdio>
using namespace std;
const int maxn=5e4+10;
struct node{
    int l,r,sum;
}tree[maxn<<2];
int a[maxn];
void build(int m,int l,int r)
{
    tree[m].l=l;
    tree[m].r=r;
    if(l==r){
        tree[m].sum=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(m<<1,l,mid);
    build(m<<1|1,mid+1,r);
    tree[m].sum=tree[m<<1].sum+tree[m<<1|1].sum;
}
//将a[pos]点的值更新为value
void update(int m,int pos,int val)
{
    if(tree[m].l==pos&&tree[m].r==pos){
        tree[m].sum+=val;
        return ;
    }
    int mid=(tree[m].l+tree[m].r)>>1;
    if(pos<=mid)
        update(m<<1,pos,val);
    else
        update(m<<1|1,pos,val);
    tree[m].sum=tree[m<<1].sum+tree[m<<1|1].sum;
}
int query(int m,int l,int r)
{
    if(l==tree[m].l&&r==tree[m].r)
        return tree[m].sum;
    int mid=(tree[m].l+tree[m].r)>>1;
    if(r<=mid)
        return query(m<<1,l,r);
    if(l>mid)
        return query(m<<1|1,l,r);
    return query(m<<1,l,mid)+query(m<<1|1,mid+1,r);
}
int main()
{
    int T,Case=1,n;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        printf("Case %d:\n",Case++);
        build(1,1,n);
        char str[20];
        int x,y;
        while(scanf("%s",str)){
            if(str[0]=='E') break;
            scanf("%d %d",&x,&y);
            if(str[0]=='A'){
                update(1,x,y);
            }
            if(str[0]=='S')
            {
                update(1,x,-y);
            }
            if(str[0]=='Q'){
                printf("%d\n",query(1,x,y));
            }
        }
    }
    return 0;
}
```

线段树简单写法： （不推荐）

```cpp
#include <cstdio>
const int maxn = 200000;
long long int segtree[maxn << 2], a[maxn];
//向上更新操作
void pushup(int now) {//这一点的值等于左儿子+右儿子
  segtree[now] = segtree[now << 1] + segtree[(now << 1)|1];
}
 
void build_tree(int l, int r, int now) {
  if (l == r) {
    segtree[now] = a[l];
    return;
  }
  int mid = l + (r - l)/2;
  build_tree(l, mid, now << 1);
  build_tree(mid + 1, r, (now << 1)|1);
  pushup(now);
}
 
void update(int l, int r, int now, int tar, int c) {
  if (l == r) {
    segtree[now] += c;
    return;
  }
  int mid = l + (r - l)/2;
  if (tar <= mid) update(l, mid, now << 1, tar, c);
  else update(mid + 1, r, (now << 1)|1, tar, c);
  pushup(now);
}
 
long long int query(int L, int R, int l, int r, int now) {
  if(L <= l && R >= r){
    return segtree[now];
  }
  long long int ans = 0;
  int mid = l + (r - l)/2;
  if (L <= mid) ans += query(L, R, l, mid, now << 1);
  if (R > mid) ans += query(L, R, mid + 1, r, (now << 1)|1);
  return ans;
}
 
int main()
{
  int T, n, x, y, ca = 0;
  scanf("%d", &T);
  while (T--) {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
      scanf("%lld", &a[i]);
    }
 
    build_tree(1, n, 1);
    printf("Case %d:\n", ++ca);
 
    char s[10];
    while(scanf("%s", s), s[0] != 'E') {
      scanf("%d %d", &x, &y);
      if (s[0] == 'Q') {
        printf("%lld\n", query(x, y, 1, n, 1));
      } else if (s[0] == 'S') {
        update(1, n, 1, x, -y);
      } else {
        update(1, n, 1, x, y);
      }
    }
 
  }
  return 0;
}
```

树状数组

```java
import java.util.*;
import java.math.*;
public class Main{
	static int maxn=50007;
	static int N;
	static int[] c=new int[maxn];
	static int lowbit(int i) {
		return i&(-i);
	}
	static void add(int i,int val) {
		while(i<=N) {
			c[i]+=val;
			i+=lowbit(i);
		}
	}
	static int sum(int i) {
		int sum=0;
		while(i>0) {
			sum+=c[i];
			i-=lowbit(i);
		}
		return sum;
	}
	static void init(int len) {
		for(int i=0;i<=len;i++) {
			c[i]=0;
		}
	}
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		int T=cin.nextInt();
		int ca=1;
		while((T--)!=0) {
			N=cin.nextInt();
			init(N);
			for(int i=1;i<=N;i++) {
				int x=cin.nextInt();
				add(i,x);
			}
			System.out.println("Case " + ca++ +":");
			while(cin.hasNext()) {
				String str=cin.next();
				if(str.charAt(0)=='E')
					break;
				int a=cin.nextInt();
				int b=cin.nextInt();
				if(str.charAt(0)=='A')
					add(a,b);
				if(str.charAt(0)=='S')
					add(a,-b);
				if(str.charAt(0)=='Q')
					System.out.println(sum(b)-sum(a-1));
			}
		}
		cin.close();
	}
}
```

线段树Java版

```cpp
import java.util.*;
import java.math.*;
class node{
	int sum,l,r;
	public void node(int l,int r,int sum){
		this.l=l;
		this.r=r;
		this.sum=sum;
	}
}
public class Main{
	static int maxn=50007;
	static int N;
	static int[] sum=new int[maxn<<2];
	static int[] left=new int[maxn<<2];
	static int[] right=new int[maxn<<2];
	static int[] a=new int[maxn];
	
	static void pushup(int rt) {
		sum[rt]=sum[rt<<1]+sum[rt<<1|1];
	}
	static void build(int rt,int l,int r) {
		left[rt]=l;
		right[rt]=r;
		if(l==r) {
			sum[rt]=a[l];
			return ;
		}
		int mid=((r+l)>>1);
		build(rt<<1,l,mid);
		build(rt<<1|1,mid+1,r);
		pushup(rt);
	}
	static void update(int rt,int pos,int val) {
		if(left[rt]==pos&&right[rt]==pos) {
			sum[rt]+=val;
			return;
		}
		int mid=(left[rt]+right[rt])>>1;
		if(pos<=mid)
			update(rt<<1,pos,val);
		else
			update(rt<<1|1,pos,val);
		pushup(rt);	
	}
	//区间[L,R]求和
	static int query(int rt,int l,int r) {
		if((left[rt]==l)&&(right[rt]==r))
			return sum[rt];
			int mid=(left[rt]+right[rt])>>1;
			if(r<=mid)
				return query(rt<<1,l,r);
			else if(l>mid)
				return query(rt<<1|1,l,r);
			else
				return query(rt<<1,l,mid)+query(rt<<1|1,mid+1,r);
	}
	
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		
		int T=cin.nextInt();
		int ca=1;
		while((T--)!=0) {
			N=cin.nextInt();
			
			for(int i=1;i<=N;i++) {
				a[i]=cin.nextInt();
			}
			
			build(1,1,N);
			System.out.println("Case " + ca++ +":");
			while(cin.hasNext()) {
				String str=cin.next();
				if(str.charAt(0)=='E')
					break;
				int a=cin.nextInt();
				int b=cin.nextInt();
				if(str.charAt(0)=='A')
					update(1,a,b);
				if(str.charAt(0)=='S')
					update(1,a,-b);
				if(str.charAt(0)=='Q') {
					int ans=query(1,a,b);
					System.out.println(ans);
				}
			}
		}
		cin.close();
	}
}
```





