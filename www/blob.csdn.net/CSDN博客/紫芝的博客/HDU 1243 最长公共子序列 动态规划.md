# HDU 1243 最长公共子序列  动态规划 - 紫芝的博客 - CSDN博客





2018年04月06日 13:09:27[紫芝](https://me.csdn.net/qq_40507857)阅读数：26








### HDU 1243

# 反恐训练营

**Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 5514    Accepted Submission(s): 1378**



当今国际反恐形势很严峻，特别是美国“9.11事件”以后，国际恐怖势力更是有恃无恐，制造了多起骇人听闻的恐怖事件。基于此，各国都十分担心恐怖势力会对本国社会造成的不稳定，于是纷纷在本国的军队、警察队伍中开展了反恐训练。作为反恐立场坚定的大国，中国也十分重视在人民解放军、武装警察部队、人民警察队伍中反恐训练，还专门成立了反恐特警队。 


炜炜是反恐特警队的一名新队员，现在正在接受培训。这几天刚好是射击训练第二阶段——实弹应变训练的日子，此前的第一阶段里，炜炜经过努力，已经将自己训练成为一个百发百中的神抢手了！这次，他将背着国产最新型12.7mm重型狙击枪进行训练比赛。 


这次训练比赛的规则是这样的： 


1、每个队员从出发点开始，沿着一条唯一的笔直道路跑直到终点，途中不允许往回跑，否则将被取消比赛资格。 

2、出发前，每个队员的枪膛内都被装了顺序一样的、用小写英文字母标明类型的子弹序列，每位队员被告知这一序列的信息；同时，每位队员也被告知恐怖分子即将出现的序列和类型（同样用小写英文字母标明类型）。 

3、在跑动的过程中，若发现“恐怖分子”，特警队员可以选择用枪击毙他，来得到写在“恐怖分子”胸前的得分，但是前提是他使用的子弹类型必须和“恐怖分子”类型相同，否则，即使击毙了“恐怖分子”，也得不到分数；当然选择不击毙他也是可以的，这样他不会从那个“恐怖分子”身上得到分数。 

4、允许特警队员放空枪，这样可以消耗掉型号不对的子弹而不至于杀死“恐怖分子”（当然每个特警队员都不会愚蠢到不装消音装置就放空枪，以至于吓跑“恐怖分子”），等待枪口出现正确型号的子弹击毙他得分。 


这里，我们假定： 

1、对于每个队员，途中出现恐怖分子的地点、时间、类型也是完全一样的。 

2、每颗子弹都是质量合格的，都可以发挥杀伤效力 

3、由于队员各个都是神枪手，一旦他选择了正确的子弹，向目标射击，目标100%被爆头 

4、每个队员的记忆力超强，能记住所有子弹序列信息和恐怖分子序列信息。 

5、每个队员体力足够好，能跑完全程，并做他想要做的 

6、“恐怖分子”是不动的，小范围内不存在多于一个的恐怖分子； 


炜炜需要你的帮助，告诉他如何做，才能得到最高的分数。现在如果告诉你出发时枪膛内子弹的序号和型号、恐怖分子出现的序号和类型，你能告诉炜炜他最多能得到多少分数吗？ 

Input

输入数据的第一行有一个整数N表示子弹和恐怖分子的类型数。随后的一行是各种恐怖分子类型的一行字母，两个字母之间没有任何字符。接下来的一行是击毙上一行对应位置恐怖分子类型的得分数，每个分数之间恰有一个空格。第三第四行分别表示开始时枪膛内子弹的序列（左边的先打出）和恐怖分子出现的序列（左边的先出现），字母之间都没有任何字符。 

每个测试数据之间没有空格和空行。你的程序必须通过全部测试数据，才能被判为AC。 

Output

对于每一个测试数据，输出炜炜最多能得到的分数。 

Sample Input

3
abc
1 1 1
abc
ccc
3
abc
1 1 1
ccc
aba
Sample Output

1
0
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int dp[2005][2005];
char s[30],m[2005],k[2005];
int b[30];
int main()
{
    int n;
    while(~scanf("%d",&n))
    {
        scanf("%s",s);
        for(int i=0;i<n;i++)
        {
            scanf("%d",&b[s[i]-'a']);
        }
        scanf("%s%s",m,k);
        int n1=strlen(m);
        int n2=strlen(k);
        memset(dp,0,sizeof(int)*(n1+1));
        for(int i=0;i<=n2;i++)
            dp[0][i]=0;
        for(int i=1;i<=n1;i++)
        {
            for(int j=1;j<=n2;j++)
            {
                if(m[i-1]==k[j-1])
                    dp[i][j]=dp[i-1][j-1]+b[m[i-1]-'a'];
                else 
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        printf("%d\n",dp[n1][n2]);
    }
}
```







