# 二分图的最大匹配  匈牙利算法 - 紫芝的博客 - CSDN博客





2018年08月28日 11:10:45[紫芝](https://me.csdn.net/qq_40507857)阅读数：46
个人分类：[图论](https://blog.csdn.net/qq_40507857/article/category/7659793)









# 基本概念

## 1.二分图：

二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 

无向图G为二分图的充分必要条件是，G至少有两个顶点，且其所有回路的长度均为偶数。 

## 2.最大匹配：

给定一个二分图G，在G的一个子图M中，M的边集中的任意两条边都不依附于同一个顶点，则称M是一个匹配.　　选择这样的边数最大的子集称为图的最大匹配问题，如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配.  

## 3.最小覆盖：

最小覆盖要求用最少的点（Ｘ集合或Ｙ集合的都行）让每条边都至少和其中一个点关联。可以证明：最少的点（即覆盖数）＝最大匹配数 

## 4.最小路径覆盖： 

用尽量少的不相交简单路径覆盖有向无环图Ｇ的所有结点。解决此类问题可以建立一个二分图模型。把所有顶点i拆成两个：Ｘ结点集中的i和Y结点集中的i',如果有边i->j，则在二分图中引入边i->j'，设二分图最大匹配为m,则结果就是n-m。 

## 5.增广路：

若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径（举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行）。 

### 增广路径的性质：

1 有奇数条边。

2 起点在二分图的左半边，终点在右半边。

3 路径上的点一定是一个在左半边，一个在右半边，交替出现。（其实二分图的性质就决定了这一点，因为二分图同一边的点之间没有边相连，不要忘记哦。）

4 整条路径上没有重复的点。

5 起点和终点都是目前还没有配对的点，而其它所有点都是已经配好对的。

6 路径上的所有第奇数条边都不在原匹配中，所有第偶数条边都出现在原匹配中。

7 最后，也是最重要的一条，把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原匹配中删除（这个操作称为增广路径的取反），则新的匹配数就比原匹配数增加了1个。

了解了增广路的定义以及性质之后，我们仔细理解第7条性质。因为增广路径的长度为奇数，我们不妨设为2*K+1，又因为第一条是非匹配边，且匹配边与非匹配边交替出现，所以非匹配边有K+1条，匹配边有K条。此时，我们做取反操作，则匹配边的个数会在原来的基础上+1。求最大匹配的“匈牙利算法”即是此思想：无论从哪个匹配开始，每一次操作都让匹配数+1，不断扩充，直到找不到增广路径，此时便得到最大匹配。

# 匈牙利算法：

算法的核心就是根据一个初始匹配不停的找增广路，直到没有增广路为止。

匈牙利算法的本质实际上和基于增广路特性的最大流算法还是相似的，只需要注意两点：

（一）每个X节点都最多做一次增广路的起点；

（二）如果一个Y节点已经匹配了，那么增广路到这儿的时候唯一的路径是走到Y节点的匹配点（可以回忆最大流算法中的后向边，这个时候后向边是可以增流的）。

找增广路的时候既可以采用dfs也可以采用bfs，两者都可以保证O(nm)的复杂度，因为每找一条增广路的复杂度是O(m)，而最多增广n次，dfs在实际实现中更加简短。

### **匈牙利算法的基本模式：**

1、 初始时最大匹配为空

2、 while （找得到增广路径）

3、 do  把增广路径加入到最大匹配中。

如果二分图的左半边一共有n个点，最多找n条增广路径，如果图中有m条边，每一条增广路径把所有边遍历一遍，所以时间复杂度为O（n*m）;

### 算法思想：

算法的思路是不停的找增广轨, 并增加匹配的个数,增广轨顾名思义是指一条可以使匹配数变多的路径,在匹配问题中,增广轨的表现形式是一条"交错轨",也就 是说这条由图的边组成的路径, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且始点和终点还没 有被选择过.这样交错进行,显然 他有奇数条边.那么对于这样一条路径,我们可以将第一条边改为已匹配,第二条边改为未匹配...以此类推.也就是将所有 的边进行"反色",容易发现这样修 改以后,匹配仍然是合法的,但是匹配数增加了一对.另外,单独的一条连接两个未匹配点的边显然也是交错轨.可以证明, 当不能再找到增广轨时,就得到了一个 最大匹配.这也就是匈牙利算法的思路.、

### 二分图匹配中较为重要的三个公式：

二分图最小顶点覆盖 = 二分图最大匹配；

DAG图的最小路径覆盖 = 节点数（n）- 最大匹配数；

二分图最大独立集 = 节点数（n）- 最大匹配数；

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1e3+10;
int n1,n2,k;
//n1,n2为二分图的顶点集，其中x属于n1，y属于n2
int map[maxn][maxn],vis[maxn],link[maxn];
//link记录n2中的点y在n1中所匹配的x点的编号
void init()
{
    memset(map,0,sizeof map);
    memset(link,0,sizeof link);
}
int find(int x)
{
    for(int i=1;i<=n2;i++)
    {
        if(map[x][i]&&!vis[i])//x->i有边，且节点i未被搜索
        {
            vis[i]=1;//标记节点已经被搜索
            //如果i不属于前一个匹配M，或被i匹配到的节点可以寻找到增广路
            if(link[i]==0||find(link[i]))
            {
                link[i]=x;//更新
                return 1;//匹配成功
            }
        }
    }
    return 0;
}
int main()
{
    while(~scanf("%d",&k)&&k){//k为边的个数
        scanf("%d%d",&n1,&n2);
        init();
        for(int i=0;i<k;i++)
        {
             int x,y;
            scanf("%d%d",&x,&y);
            map[x][y]=1;
        }
        int ans=0;
        for(int i=1;i<=n1;i++)
        {
            memset(vis,0,sizeof vis);
            if(find(i)) ans++;
        }
        printf("%d\n",ans);
    }
   return 0;
}
```

**[HDU 2063 二分图匹配](https://blog.csdn.net/qq_40507857/article/details/82011528)**

**[POJ3041 二分图最小顶点覆盖](https://blog.csdn.net/qq_40507857/article/details/82145005)**

**[POJ 1274 二分图的最大匹配](https://blog.csdn.net/qq_40507857/article/details/82145802)**

**[poj 1469 二分图的最大匹配](https://blog.csdn.net/qq_40507857/article/details/82146258)**

**[POJ325 最小点集覆盖](https://blog.csdn.net/qq_40507857/article/details/82147401)**



