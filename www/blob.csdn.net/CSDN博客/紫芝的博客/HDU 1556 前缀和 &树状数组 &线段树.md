# HDU 1556 前缀和 &树状数组 &线段树 - 紫芝的博客 - CSDN博客





2018年04月07日 21:53:42[紫芝](https://me.csdn.net/qq_40507857)阅读数：63








解法一：

a[i]表示以 i作为起点，对 i-n的气球全部上色的次数 

对(start,end)区间上色

++a[start]

--a[end+1]抵消掉 end+1-n的部分

问题转换为求 a的前缀和 



```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+6;
int n,a[maxn];
int main()
{
	while(scanf("%d",&n)&&n){
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		++a[l];--a[r+1];		
	}
	for(int i=1;i<=n+1;i++)
	printf("%d:%d\n",i,a[i]); 
	printf("%d",a[1]);
	for(int i=2;i<=n;i++)
	{
		a[i]+=a[i-1];
		printf(" %d",a[i]);
	}
	printf("\n");
	}	
	return 0;
}
```

解法二：

树状数组 

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,c[100005];
int lowbit(int i)
{
	return i&(-i);
 } 
void add(int i,int value)
{
	while(i<=N){
		c[i]+=value;
		i+=lowbit(i);
	}
}
int sum(int i){
	int sum=0;
	while(i>0){
		sum+=c[i];
		i-=lowbit(i);
	}
	return sum;
}
int main()
{
	while(scanf("%d",&N)!=EOF&&N)
	{
		int a,b;
		memset(c,0,sizeof(c));
		for(int i=1;i<=N;i++){
			scanf("%d%d",&a,&b);
			add(a,1);add(b+1,-1);
		}
		for(int i=1;i<N;i++)
		printf("%d ",sum(i));
		printf("%d\n",sum(N));
		}
				return 0;	
	}
```

解法三：

线段树 

更新区间，查询点

```cpp
#include<stdio.h>
#include<string.h>

#define lson l ,mid ,t << 1
#define rson mid + 1 ,r ,t << 1 | 1

__int64 sum[440000] ,mark[440000];

void Pushup(int t)
{
    sum[t] = sum[t<<1] + sum[t<<1|1];
}

void Pushdown(int t ,int ll)
{
     if(mark[t])
     {
         mark[t<<1] += mark[t];
         mark[t<<1|1] += mark[t];
         sum[t<<1] += (ll - (ll >> 1)) * mark[t];
         sum[t<<1|1] += (ll >> 1) * mark[t];
         mark[t] = 0;
     }
}

void BuidTree()
{
     memset(sum ,0 ,sizeof(sum));
     memset(mark ,0 ,sizeof(mark));
}

void Update(int l ,int r ,int t ,int a ,int b ,int c)
{
     if(a <= l && b >= r)
     {
          sum[t] += (r - l + 1) * c;
          mark[t] += c;
          return;
     }
     Pushdown(t ,r - l + 1);
     int mid = (l + r) >> 1;
     if(a <= mid) Update(lson ,a ,b ,c);
     if(b > mid)  Update(rson ,a ,b ,c);
     Pushup(t);
}

__int64 Query(int l ,int r ,int t ,int a ,int b)
{
    if(a <= l && b >= r)
    return sum[t];
    Pushdown(t ,r - l + 1);
    int mid = (l + r) >> 1;
    __int64 ans = 0;
    if(a <= mid) ans = Query(lson ,a ,b);
    if(b > mid) ans += Query(rson ,a ,b);
    return ans;
}

int main ()
{
    int n ,a ,b ,i;
    while(~scanf("%d" ,&n) && n)
    {
        BuidTree();
        for(i = 1 ;i <= n ;i ++)
        {
            scanf("%d %d" ,&a ,&b);
            Update(1 ,n ,1 ,a ,b ,1);
        }
        for(i = 1 ;i <= n ;i ++)
        if(i == n) printf("%I64d\n" ,Query(1 ,n ,1 ,i ,i));
        else printf("%I64d " ,Query(1 ,n ,1 ,i ,i));
    }
    return 0;
}
```




