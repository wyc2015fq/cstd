# 多因子模型之组合构建与优化器（上） - lyx的专栏 - CSDN博客





2017年10月21日 21:26:15[钱塘小甲子](https://me.csdn.net/qtlyx)阅读数：3582







        根据多因子模型，或者说alpha策略的开发顺序，我们应当是按照：因子--》alpha 模型--》风险模型--》组合构建 这样几个模块来的。今天来说说组合构建这个事。
        组合构建是在你有了alpha模型和风险模型之后，也就是说，你现在可以预测股票的收益和股票的风险了。那么我们怎么构建组合呢？ 大概有这么几种方法：
        a.根据alpha模型，选择前面N个预测收益高的股票，然后权重都是1/N；
        b.市值加权，当然也可以市值平方根或者市值对数加权，都属于这一类；
        c.使用现代portfolio理论，说白了，就是上优化器。

        当然啦，前面这两种，我们就不说了，实在是easy，但是缺点也很明显，就是你没有用完你对收益的预测信息和你对风险的预测。如果你觉得你的预测很烂，那么其实这样也无所谓。毕竟，很烂的话，还不如抛硬币选股配权重，是吧。原理上来讲，前两种其实就是投资者信息较少的一种做法。

# 1.二次规划（Quadratic Programming）

     一般的二次规划通用问题是这样的：  


![](https://img-blog.csdn.net/20171021212736332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


     没见过的同学得补一下了，大致就是说，我们要找到一个x向量，这个向量在上面这个表达式中，满足subject to的条件，我们叫做约束，同时，在约束的条件下，使上面这个目标函数尽可能小。说白了，就是求x这一个向量。  
那么，我们怎么把这个用到组合里面呢？先不急，我们注意上，上面的约束是一个不等式约束，而二次规划的等式约束，也就是条件是等式，那么其实这个优化问题是有解析解的。  
      先不管这个，我们来考虑一下投资的本质。说白了，投资就是风险和收益的权衡，我们希望在最大化收益的情况下，可以使得风险最小。说白了，就是你首先约定一个收益，然后我们要求风险最小。如果熟悉马科维兹的那套东西，就知道，就是我们的portfolio在有效前沿上。然后在看一下上面的公式，说白了，就是我们可以用等式约束，约束住一个收益，上面min的变成我们的risk。完美！  
      那么我们先用等式约束来感受一下吧。
      假设我们现在有三个股票，分别叫做s1，s2,s3，然后我们预测他的收益率为u1，u2，u3,分别为0.100162,0.164244,0.182082. 
      我们当然还预测了risk，但是risk必然是一个matrix，我们假设：  
![](https://img-blog.csdn.net/20171021212833548?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
        那么到现在，我们对风险的预测和对收益的预测都有了，我们就可以开始用优化器构建组合了。我们要清楚，既然是构建组合，那么我们的目标就是得到每一个股票的权重，所谓，一开始的x向量，其实就是我们要的答案，股票的权重。然后，既然是投资，要把钱投出去，投多少我们是知道的，我们一般构建的时候都认为是全额投资，也就是说，我们的每一个股票加起来的权重应该是1，没有钱是放着发霉用的。然后，我们就要选一个收益，然后用优化器构建一个这个收益下风险最小的组合了。我们假设我们的收益要求是0.15.  
        好了，数据都有了，我们可以把上面这一分析扔到一开始的二次规划的模型里面了。
        那么，首先，我们的约束有两个:
![](https://img-blog.csdn.net/20171021212926456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
然后我们的目标函数，也就是风险是：
![](https://img-blog.csdn.net/20171021212953689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
那么，写成优化的形式就是：
![](https://img-blog.csdn.net/20171021213025917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
其中，
![](https://img-blog.csdn.net/20171021213051349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
        这样我们就构建好了我们的优化目标和优化限制了。可以自行百度学习如何对等式约束的二次规划问题用拉格朗日乘子法求取解析解，这里笔者直接给出答案，组合权重w向量的解析解是：
![](https://img-blog.csdn.net/20171021213120488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


## 2. 第一个等式约束的例子

这个例子的数据来源于小黑书QEPM，做主动管理的人大概都是知道的。



```python
import numpy as np
cov_matrix = np.matrix([[0.100162,0.045864,0.005712],[0.045864,0.210773,0.028283],[0.005712,0.028283,0.066884]])
A_matrix = np.matrix([[1,1,1],[0.100162,0.164244,0.182082]])
b_matrix = np.matrix([[1],[0.15]])
w = cov_matrix.I * A_matrix.T * (A_matrix * cov_matrix.I * A_matrix.T).I * b_matrix
```
结果就是这样的：

![](https://img-blog.csdn.net/20171021213310288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

        上面这个w就是组合的权重向量了。上面这个向量告诉我们，当我们希望获得15%的收益率的时候，按照上面买入三只股票的权重，那么我们的risk是最小的，也就是说，我们在有效前沿上。上面的例子，收益是0.15，风险是0.0425既然，这样，我们把有效前沿画出来好了喽。

# 

## 3.等式约束的有效前沿






```python
import pandas as pd
%matplotlib inline
cov_matrix = np.matrix([[0.100162,0.045864,0.005712],[0.045864,0.210773,0.028283],[0.005712,0.028283,0.066884]])
A_matrix = np.matrix([[1,1,1],[0.100162,0.164244,0.182082]])
return_list = list()
risk_list = list()
for i in range(1, 300):
    up = i/1000.0
    b_matrix = np.matrix([[1],[up]])
    w = cov_matrix.I * A_matrix.T * (A_matrix * cov_matrix.I * A_matrix.T).I * b_matrix
    return_list.append((A_matrix * w)[1,0])
    risk_list.append((w.T * cov_matrix * w)[0,0])
plot_df = pd.DataFrame()
plot_df['return'] = return_list
plot_df['risk'] = risk_list
plot_df.plot.scatter(x='risk', y='return')
```

我们来看一下有效前沿：

![](https://img-blog.csdn.net/20171021213446486?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXRseXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


下一次，我们将讨论不等式约束和优化器的使用。


参考书目：Quantitative Equity Portfolio Managem， chp9




