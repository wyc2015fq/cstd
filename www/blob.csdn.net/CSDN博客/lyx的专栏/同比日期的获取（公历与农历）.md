# 同比日期的获取（公历与农历） - lyx的专栏 - CSDN博客





2019年03月13日 19:25:17[钱塘小甲子](https://me.csdn.net/qtlyx)阅读数：657








      在进行宏观数据和中观数据研究分析分的时候，经常会用到同比的概念。宏观数据一般都是月度的，所以一般一二月份由于春节效应，会合起来考虑；但是中观数据的频率有时候会比较高，比如周度或者旬度的数据。

      这些数据更多的时候，我们希望看到的是一个同比的情况，而且是农历同比，比如钢铁的库存、水泥的产量、建材的成交量等等，所以就涉及计算去年同比的一个问题了。下面的代码就是在当前的有数据的时间列表中，找到去年同比最近的一天，可以是农历也可以是公历。

```python
import sxtwl
def find_previous_day(current_date, date_list, lunna=True):
    # 用于寻找前一年与当前时间点最接近的日期，公历或者农历都可以
    cur_date = pd.to_datetime(current_date)
    if lunna:  # 农历同比
        lunar = sxtwl.Lunar()
        _lunnar_new_year = lunar.getDayByLunar(cur_date.year, 01, 01, False)
        lunnar_new_year = pd.to_datetime('%s-%s-%s' % (_lunnar_new_year.y, _lunnar_new_year.m, _lunnar_new_year.d))
        if lunnar_new_year > cur_date:
            # 当前不是农历新年后的时间
            _lunnar_new_year = lunar.getDayByLunar(cur_date.year - 1, 01, 01, False)
            lunnar_new_year = pd.to_datetime('%s-%s-%s' % (_lunnar_new_year.y, _lunnar_new_year.m, _lunnar_new_year.d))
        _lunnar_last_new_year = lunar.getDayByLunar(lunnar_new_year.year - 1, 01, 01, False)
        lunnar_last_new_year = pd.to_datetime('%s-%s-%s' % (_lunnar_last_new_year.y, _lunnar_last_new_year.m, _lunnar_last_new_year.d))
        most_recent_date = lunnar_last_new_year + (cur_date - lunnar_new_year)
        return date_list[np.array([abs((date - most_recent_date).days) for date in pd.to_datetime(date_list)]).argmin()]
    else:
        return date_list[np.array([abs((date - cur_date).days + 365) for date in pd.to_datetime(date_list)]).argmin()]
```

      current_date就是希望寻找去年同期的当前时间点，而date_list则是全历史的可选日期，也就是，我们会找一个最近的同比日期。lunna就是是否是农历的flag了。







