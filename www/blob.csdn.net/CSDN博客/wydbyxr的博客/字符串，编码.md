# 字符串，编码 - wydbyxr的博客 - CSDN博客
2017年02月26日 14:41:56[whitenightwu](https://me.csdn.net/wydbyxr)阅读数：131
## 前言
你可以把字符编码当做一种解码密钥。当有人给你一个字节序列 — 文件，网页，或者别的什么 — 并且告诉你它们是“文本”时，就需要知道他们使用了何种编码方式，然后才能将这些字节序列解码成字符。如果他们给的是错误的“密钥”或者根本没有给你“密钥”，那就得自己来破解这段编码，这可是一个艰难的任务。有可能你使用了错误的解码方式，然后出现一些莫名其妙的结果。 
你肯定见过这样的网页，在撇号(‘)该出现的地方被奇怪的像问号的字符替代了。这种情况通常意味着页面的作者没有正确的声明其使用的编码方式，浏览器只能自己来猜测，结果就是一些正确的和意料之外的字符的混合体。 
然而，像中文，日语和韩语等语言，他们的字符如此之多而不得不需要多字节编码的字符集。
现在，你就哭吧，因为以前所了解的关于字符串的知识都是错的，根本就没有所谓的“纯文本”。 
## nicode入门
Unicode编码系统为表达任意语言的任意字符而设计。 
例如：U+0041总是代表’A’，即使这种语言没有’A’这个字符。 
但是很快，一个明显的问题跳到我们面前。4个字节？只为了单独一个字符?这似乎太浪费了，特别是对像英语和西语这样的语言，他们只需要不到1个字节即可以表达所需的字符。 
- **UTF-32**：有一种Unicode编码方式每1个字符使用4个字节。它叫做UTF-32，因为32位 = 4字节。UTF-32是一种直观的编码方式。
- 
**UTF-16**：就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。UTF-16将0–65535范围内的字符编码成2个字节，如果真的需要表达那些很少使用的“星芒层(astral plane)”内超过这65535范围的Unicode字符，则需要使用一些诡异的技巧来实现。
- 
但是对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。会被使用的是大尾端(big-endian)还是小尾端(little-endian)而影响。为了解决这个问题，多字节的Unicode编码方式定义了一个“字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。
- 
**UTF-8**是一种为Unicode设计的变长(variable-length)编码系统。即，不同的字符可使用不同数量的字节编码。 
优点：在处理经常会用到的ASCII字符方面非常有效。在处理扩展的拉丁字符集方面也不比UTF-16差。对于中文字符来说，比UTF-32要好。同时，（在这一条上你得相信我，因为我不打算给你展示它的数学原理。）由位操作的天性使然，使用UTF-8不再存在字节顺序的问题了。一份以UTF-8编码的文档在不同的计算机之间是一样的比特流。
## python中的字符串
在Python 3，所有的字符串都是使用Unicode编码的字符序列。不再存在以UTF-8或者CP-1252编码的情况。
```python
>>> s = '深入 Python'    ①
>>> len(s)               ②
9
>>> s[0]                 ③
'深'
>>> s + ' 3'             ④
'深入 Python 3'
```
为了创建一个字符串，将其用引号包围。Python字符串可以通过单引号(‘)或者双引号(“)来定义。
### 格式化字符串，format()
Python 3支持把值格式化(format)成字符串。可以有非常复杂的表达式，最基本的用法是使用单个占位符(placeholder)将一个值插入字符串。  
例子如下。首先，这里使用了一个字符串字面值的方法调用。字符串也是对象，对象则有其方法。其次，整个表达式返回一个字符串。最后，{0}和{1} 叫做替换字段(replacement field)，他们会被传递给format()方法的参数替换。 
```python
>>> username = 'mark'
>>> password = 'PapayaWhip'                             ①
>>> "{0}'s password is {1}".format(username, password)  ②
"mark's password is PapayaWhip"
```
更复杂的例子： 
1. 不需要调用humansize模块定义的任何函数我们就可以抓取到其所定义的数据结构：国际单位制(SI, 来自法语Système International)的后缀列表（以1000为进制）。 
2. 这一句看上去有些复杂，其实不是这样的。{0}代表传递给format()方法的第一个参数，即si_suffixes。注意si_suffixes是一个列表。所以{0[0]}指代si_suffixes的第一个元素，即’KB’。同时，{0[1]}指代该列表的第二个元素，即：’MB’。大括号以外的内容 — 包括1000，等号，还有空格等 — 则按原样输出。语句最后返回字符串为’1000KB = 1MB’。 
```python
>>> import humansize
>>> si_suffixes = humansize.SUFFIXES[1000]      ①
>>> si_suffixes
['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
>>> '1000{0[0]} = 1{0[1]}'.format(si_suffixes)  ②
'1000KB = 1MB'
```
一个练习：
```
>>> import humansize
>>> import sys
>>> '1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}'.format(sys)
'1MB = 1000KB'
```
关于实例中的代码解释：
`return '{0:.1f} {1}'.format(size, suffix)     `
{0:.1f}是什么意思呢？它其实包含了两方面的内容：{0}你已经能理解，:.1f则不一定了。 
在替换域中，冒号(:)标示格式说明符的开始。“.1”的意思是四舍五入到保留一们小数点。“f”的意思是定点数（与指数标记法或者其他10进制数表示方法相对应）。因此，如果给定size为698.24，suffix为’GB’，那么格式化后的字符串将是’698.2 GB’，因为698.24被四舍五入到一位小数表示，然后后缀’GB’再被追加到这个串最后。
```
>>> '{0:.1f} {1}'.format(698.24, 'GB')
'698.2 GB'
```
### 其他实用技巧
#### 输入多行(multiline)字符串，splitlines()，lower()，count()
```python
>>> s = '''Finished files are the re-  ①
... sult of years of scientif-
... ic study combined with the
... experience of years.'''
>>> s.splitlines()                     ②
['Finished files are the re-',
 'sult of years of scientif-',
 'ic study combined with the',
 'experience of years.']
>>> print(s.lower())                   ③
finished files are the re-
sult of years of scientif-
ic study combined with the
experience of years.
>>> s.lower().count('f')               ④
6
```
- 我们可以在Python的交互式shell里输入多行(multiline)字符串。一旦我们以三个引号标记多行字符串的开始，按ENTER键，Python shell会提示你继续这个字符串的输入。连续输入三个结束引号以终止该字符串的输入，再敲ENTER键则会执行该条命令（在当前例子中，把这个字符串赋给变量s）。
- splitlines()方法以多行字符串作为输入，返回一个由字符串组成的列表，列表的元素即原来的单行字符串。请注意，每行行末的回车符没有被包括进去。
- lower()方法把整个字符串转换成小写的。（类似地，upper()方法执行大写化转换操作。）
- count()方法对串中的指定的子串进行计数。是的，在那一句中确实出现了6个字母“f”。 
#### 将字符串分离成字典
这跟解析URL的请求参数(query parameters)很相似，但是真实的URL解析实际上比这个复杂得多。
```python
>>> query = 'user=pilgrim&database=master&password=PapayaWhip'
>>> a_list = query.split('&')                            ①
>>> a_list
['user=pilgrim', 'database=master', 'password=PapayaWhip']
>>> a_list_of_lists = [v.split('=', 1) for v in a_list]  ②
>>> a_list_of_lists
[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]
>>> a_dict = dict(a_list_of_lists)                       ③
>>> a_dict
{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}
```
#### 分片
与之前的列表分片相似
```python
>>> a_string = 'My alphabet starts where your alphabet ends.'
>>> a_string[3:11]           ①
'alphabet'
>>> a_string[3:-3]           ②
'alphabet starts where your alphabet en'
>>> a_string[0:2]            ③
'My'
>>> a_string[:18]            ④
'My alphabet starts'
>>> a_string[18:]            ⑤
' where your alphabet ends.'
```
#### String vs. Bytes
字节即字节；字符是一种抽象。一个不可变(immutable)的Unicode编码的字符序列叫做string。一串由0到255之间的数字组成的序列叫做bytes对象。 
```
>>> by = b'abcd\x65'  ①
>>> by
b'abcde'
>>> type(by)          ②
<class 'bytes'>
>>> len(by)           ③
5
>>> by += b'\xff'     ④
>>> by
b'abcde\xff'
>>> len(by)           ⑤
6
>>> by[0]             ⑥
97
>>> by[0] = 102       ⑦
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'bytes' object does not support item assignment
```
- 使用“byte字面值”语法b”来定义bytes对象。byte字面值里的每个字节可以是ASCII字符或者是从\x00到\xff编码了的16进制数。 
- bytes对象是不可变的；我们不可以给单个字节赋上新值。如果需要改变某个字节，可以组合使用字符串的切片和连接操作(效果跟字符串是一样的)，或者我们也可以将bytes对象转换为bytearray对象。 
#### bytearray()
```python
>>> by = b'abcd\x65'
>>> barr = bytearray(by)  ①
>>> barr
bytearray(b'abcde')
>>> len(barr)             ②
5
>>> barr[0] = 102         ③
>>> barr
bytearray(b'fbcde')
```
- 使用内置函数bytearray()来完成从bytes对象到可变的bytearray对象的转换。
- 所有对bytes对象的操作也可以用在bytearray对象上。
- 有一点不同的就是，我们可以使用下标标记给bytearray对象的某个字节赋值。并且，这个值必须是0–255之间的一个整数。 
#### 不能混用bytes和strings。
```
>>> by = b'd'
>>> s = 'abcde'
>>> by + s                       ①
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't concat bytes to str
```
#### 字符串与字节数组转换–decode()和encode()
这就是字符串与字节数组之间的联系了：bytes对象有一个decode()方法，它使用某种字符编码作为参数，然后依照这种编码方式将bytes对象转换为字符串，对应地，字符串有一个encode()方法，它也使用某种字符编码作为参数，然后依照它将串转换为bytes对象。encode(‘big5’)、encode(‘gb18030’)、encode(‘utf-8’)都可以。
```python
>>> a_string = '深入 Python'         ①
>>> len(a_string)
9
>>> by = a_string.encode('utf-8')    ②
>>> by
b'\xe6\xb7\xb1\xe5\x85\xa5 Python'
>>> len(by)
13
```
### 补充
Python 2里，.py文件默认的编码方式为ASCII。Python 3的源码的默认编码方式为UTF-8 
如果想使用一种不同的编码方式来保存Python代码，我们可以在每个文件的第一行放置编码声明(encoding declaration)。
字符编码的重载声明也可以放在第二行，如果第一行被类UNIX系统中的hash-bang命令占用了。
```
#!/usr/bin/python3
# -*- coding: windows-1252 -*-
```
参考： 
[http://old.sebug.net/paper/books/dive-into-python3/strings.html](http://old.sebug.net/paper/books/dive-into-python3/strings.html)
