# 机器学习基础--碎片知识点（2） - wydbyxr的博客 - CSDN博客
2018年08月01日 15:38:15[whitenightwu](https://me.csdn.net/wydbyxr)阅读数：171
所属专栏：[经典机器学习算法](https://blog.csdn.net/column/details/28812.html)
# K-mean与高斯混合模型（K-means算法和EM算法）
　　两者的差别在哪里？ 
　　答：CSDN博主JpHu说，K-Means算法对数据点的聚类进行了“硬分配”，即每个数据点只属于唯一的聚类；而GMM的EM解法则基于后验概率分布，对数据点进行“软分配”，即每个单独的高斯模型对数据聚类都有贡献，不过贡献值有大有小。 
　　参考资料：[https://blog.csdn.net/tingyue_/article/details/70739671](https://blog.csdn.net/tingyue_/article/details/70739671)
# 分箱 (binning)或分桶 (bucketing)
　　连续值转换为离散值。将一个特征（通常是连续特征）转换成多个二元特征（称为桶或箱），通常是根据值区间进行转换。 
　　例如，您可以将温度区间分割为离散分箱，而不是将温度表示成单个连续的浮点特征。假设温度数据可精确到小数点后一位，则可以将介于 0.0 到 15.0 度之间的所有温度都归入一个分箱，将介于 15.1 到 30.0 度之间的所有温度归入第二个分箱，并将介于 30.1 到 50.0 度之间的所有温度归入第三个分箱。
# 论文的复现
　　一般来说，得比别人多用1-2项技术才能做到paper里宣称的识别率。经验吧，很多时候跑不到一个好结果，可能是没有充分下降，learning rate收缩得过快的话，可能还没到底就几乎不动了，收缩过慢的话，可能没有耐心等待学习率降到一个比较低的数就停止了。用最常用的指数下降法的话，很容易发生以上两种现象。 
　　我现在一般使用固定学习率，如果观察到loss已经下降不动，只在一个区间内抖动的话，就停止学习，将学习率除以10继续重复这个过程。从0.01开始，一般搞到1e-6就差不多啦。
# 流程（pipeline）
　　机器学习算法的基础架构。管道包括收集数据、将数据放入训练数据文件中、训练一或多个模型，以及最终输出模型。  
# 混淆矩阵 (confusion matrix)
　　一种 NxN 表格，用于总结分类模型的预测成效；即标签和模型预测的分类之间的关联。在混淆矩阵中，一个轴表示模型预测的标签，另一个轴表示实际标签。N 表示类别个数。在二元分类问题中，N=2。 
　　多类别分类问题的混淆矩阵有助于确定出错模式。例如，某个混淆矩阵可以揭示，某个经过训练以识别手写数字的模型往往会将 4 错误地预测为 9，将 7 错误地预测为 1。混淆矩阵包含计算各种效果指标（包括精确率和召回率）所需的充足信息。 
　　例如，下面显示了一个二元分类问题的混淆矩阵示例： 
肿瘤（预测的标签） 非肿瘤（预测的标签） 
肿瘤（实际标签） 18 1 
非肿瘤（实际标签） 6 452 
　　上面的混淆矩阵显示，在 19 个实际有肿瘤的样本中，该模型正确地将 18 个归类为有肿瘤（18 个真正例），错误地将 1 个归类为没有肿瘤（1 个假负例）。同样，在 458 个实际没有肿瘤的样本中，模型归类正确的有 452 个（452 个真负例），归类错误的有 6 个（6 个假正例）。
# 为什么不用逻辑回归，而要用GBM？
　　答：GB是Gradient Boosting。引用知乎答主Frankenstein的话，从决策边界上看，线性回归的决策边界是一条直线，逻辑回归的决策边界是一条曲线，GBM的决策边界可能是很多条线。 
　　逻辑回归只能处理回归问题，而GBM还可以用于解决分类或排序问题。
# benchmark和baseline的区别
　　Benchmark和baseline都有性能比较的意思。 
　　Benchmark一般是指评测指标或评测体系；而Baseline指你要对比的基础方法。简而言之，benchmark一般是和同行中比较牛的算法比较，比牛算法还好，那你可以考虑发好一点的会议/期刊；baseline一般是自己算法优化和调参过程中自己和自己比较，目标是越来越好，当性能超过benchmark时，可以发表了，当性能甚至超过SOTA时，恭喜你，考虑投顶会顶刊啦。 
　　1）Benchmark 
　　通俗的讲，一个算法之所以被称为benchmark，是因为它的性能已经被广泛研究，人们对它性能的表现形式、测量方法都非常熟悉，因此可以作为标准方法来衡量其他方法的好坏。这里需要区别state-of-the-art（SOTA），能够称为SOTA的算法表明其性能在当前属于最佳性能。如果一个新算法以SOTA作为benchmark，这当然是最好的了，但如果比不过SOTA，能比benchmark要好，且方法有一定创新，也是可以发表的。
　　2）baseline 
　　通俗的讲，一个算法被称为baseline，基本上表示比这个算法性能还差的基本上不能接受的，除非方法上有革命性的创新点，而且还有巨大的改进空间和超越benchmark的潜力，只是因为是发展初期而性能有限。所以baseline有一个自带的含义就是“性能起点”。这里还需要指出其另一个应用语境，就是在算法优化过程中，一般version1.0是作为baseline的，即这是你的算法能达到的一个基本性能，在算法继续优化和调参数的过程中，你的目标是比这个性能更好，因此需要在这个base line的基础上往上跳。
# The ground truth
　　就是参考标准，一般用来做error quantification。比方说要根据历史数据预测某一时间的温度，ground truth就是那个时间的真实温度。error就是(predicted temperature - real temprature)。 
　　例如：W_gt   。
# evaluation和prediction的区别
　　predict是指结果，不包含loss、acc，只包含softmax、logit等预测值；对单张图使用。 
　　eval包含了loss，acc等损失；对测试集使用。 
　　例如： 
　　predict_result    =>[{‘predictions’: array([-2.99999738], dtype=float32)}] 
　　eval_result    =>{‘average_loss’: 0.010000505, ‘loss’: 0.010000505, ‘global_step’: 3000}
# differential privacy 差分隐私
　　一项数据库隐私保护技术。 
　　从隐私保护的角度来说，隐私的主体是单个用户，只有牵涉到某个特定用户的才叫隐私泄露，发布群体用户的信息（一般叫聚集信息）不算泄露隐私。 
　　那么我们是不是可以任意发布聚集信息呢？倒是未必。我们设想这样一种情况：医院发布了一系列信息，说我们医院这个月有100个病人，其中有10个感染HIV。假如攻击者知道另外99个人是否有HIV的信息，那么他只需要把他知道的99个人的信息和医院发布的信息比对，就可以知道第100个人是否感染HIV。这种对隐私的攻击行为就是差分攻击。  
　　差分隐私于是定义：如果你能找出一种方法让攻击者用某种方式查询100个信息和查询那99个信息得到的结果是一致的，那攻击者就没办法找出那第100个人的信息了。但这个“一致” 怎么做到呢？那就加入随机性吧。如果查询100个记录和查询99个记录，输出同样值的概率是一样的，攻击者就无法进行差分攻击。这里我们就得到了差分隐私的核心思想：对于差别只有一条记录的两个数据集，查询它们获得相同值的概率非常非常的接近。
### 如何做到差分隐私
　　其实就是在查询结果里加入随机性。任何一种方法，只要用在数据集上能满足差分隐私的核心思想，那这个方法就是满足差分隐私的。所以最常用的方法是在结果上加满足某种分布的噪音，使查询结果随机化。
　　目前常用的有两种方法： 
　　1）一个是Laplace机制，在查询结果里加入Laplace分布的噪音，适用于数值型输出。例如：zhihu里有多少人是985大学毕业的？ 假如结果是2000人，那么每一次查询得到的结果都会稍稍有些区别，比如有很高的概率输出2001，也有较高概率输出2010， 较低概率输出1990，等等。 
　　2）另外一个是指数机制，在查询结果里用指数分布来调整概率，适用于非数值型输出。例如：中国top 3大学是哪一所。很高概率输出 浙江大学，较高概率输出上海交大，较低概率输出武汉大学，很低概率输出蓝翔技校，等等。
### 原则和实例
　　差分机密性是将随机性引入数据的过程。 
一个社会学简单的例子，根据以下流程要求被提问者回答“你拥有属性A？”的问题，对方的回复流程是： 
1. 扔一枚硬币。 
2. 如果正面朝上，然后诚实回答。 
3. 如果反面朝上，然后再扔硬币，如果正面回答“是”，如果反面回答“否”。 
保密性来源于个人答复的可纠正性。 
　　但总的来说，这些有很多答案的数据是非常重要的，因为没有属性A的人给予四分之一的肯定答案，实际拥有属性A的人给出四分之三的肯定答案。如果p是A的真实比例，那么我们期望得到（1/4）（1-p）+（3/4）p =（1/4）+ p / 2的肯定答案。因此可以估计p。
# 决策边界 (decision boundary)
　　在二元分类或多类别分类问题中，模型学到的类别之间的分界线。两种类别之间明确定义的边界。 
　　例如，在以下表示某个二元分类问题的图片中，决策边界是橙色类别和蓝色类别之间的分界线： 
![这里写图片描述](https://img-blog.csdn.net/20180801153718196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5ZGJ5eHI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
# 压缩感知CS与DL
　　压缩感知完全基于模型（model-based），有很好的结构，经过严谨的数学建模。深度学习则完全反过来，模型非常灵活，需要通过数据进行监督学习，是一种基于实证的方法。 
　　压缩感知（compressive sensing），高维空间的低维模型，利用其稀疏低秩的性质，带来一场图像处理的革命。 
　　深度学习。今天我以视觉为例，探讨低维模型和深度模型如何为了一个共同的目的从两个完全对立的方向走到了一起。自编码器（autoencoder）就是从压缩感知来的概念  
　　在高维的世界里，数据携带的信息是我们难以想象的鲁棒的。有多鲁棒呢？随着图像的分辨率越来越高，你可以损毁的像素的比例可以无限接近百分之百。这是数学的神奇之处：我们本来只想要损毁一小部分像素，但得到了远远超出想象的结论。  高维空间的统计和几何现象和低维空间中发展的几何和统计的直觉是完全相反的。你认为在低维空间一定会发生的事情在高维空间基本不发生，你认为在低维空间中绝对不会发生的事情往往在高维空间中以概率为 1 发生，即使世界一流的数学家在此也会犯错，这是我们学到的极其宝贵的经验。
