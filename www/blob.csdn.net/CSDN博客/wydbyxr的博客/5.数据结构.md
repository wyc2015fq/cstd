# 5.数据结构 - wydbyxr的博客 - CSDN博客
2018年08月01日 11:23:34[whitenightwu](https://me.csdn.net/wydbyxr)阅读数：39
个人分类：[Python](https://blog.csdn.net/wydbyxr/article/category/7151085)
# 关于list（列表）
## list的各种方法
下面这个示例演示了列表的大部分方法:
```python
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
>>> a.pop()
1234.5
>>> a
[-1, 1, 66.25, 333, 333]
```
- a.pop() ：从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop() 返回最后一个元素。
- a.append()：在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x)。
- 也许大家会发现像 insert， remove 或者 sort 这些修改列表的方法没有打印返回值–它们返回 None。 [1] 在 python 中对所有可变的数据类型这是统一的设计原则。
## 把列表当作堆栈使用
列表方法使得列表可以很方便的做为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（**后进先出**）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。
```python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
```
## 把列表当作队列使用
你也可以把列表当做队列使用，队列作为特定的数据结构，最先进入的元素最先释放（**先进先出**）。不过，列表这样用效率不高。相对来说从列表末尾添加和弹出很快；在头部插入和弹出很慢（因为，为了一个元素，要移动整个列表中的所有元素）。
要实现队列，使用 collections.deque，它为在首尾两端快速插入和删除而设计。 
要实现队列，使用 collections.deque，它为在首尾两端快速插入和删除而设计。例如:
```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")      # Terry arrives
>>> queue.append("Graham")     # Graham arrives
>>> queue.popleft()                 
# The first to arrive now leaves
'Eric'
>>> queue.popleft()                 
# The second to arrive now leaves
'John'
>>> queue                           
># Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
```
## 进阶：列表推导式
```
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
进一步：
squares = list(map(lambda x: x**2, range(10)))
再进一步：
squares = [x**2 for x in range(10)]
```
```
现在，如果你想交换行和列，可以用嵌套的列表推导式:
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
当然使用zip（）更简单
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```
# 循环技巧
在字典中循环时，关键字和对应的值可以使用 items() 方法同时解读出来:
```
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```
在序列中循环时，索引位置和对应值可以使用 enumerate() 函数同时得到:
```
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```
同时循环两个或更多的序列，可以使用 zip() 整体打包:
```
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```
需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数:
```
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```
# 深入条件控制
比较操作符 in 和 not in 审核值是否在一个区间之内。 
操作符 is 和 is not 比较两个对象是否相同；  
