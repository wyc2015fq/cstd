# 牛客选择题笔记 - Likes的博客 - CSDN博客
2019年03月17日 10:12:46[Lailikes](https://me.csdn.net/songchuwang1868)阅读数：14
- 阅读C++语言代码输出（）
```cpp
int main()
{
    int arr[]={1,2,3,4,5,6,7};
    int *p=arr;
    *(p++)+=89;
    printf("%d,%d\n",*p,*(++p));
    return 0;
}
```
第4行： *p=arr[0]
第5行：arr[0]=90;p自加1，此时*p=arr[1];
第6行：先计算*(++p),*p=arr[2],在计算*p=arr[2].**原因prinf从右到左编译，从左到右输出**
答案： 3 3 
- 阅读c++代码输出（）
```cpp
class base1{
    private: int a,b;
    public:
    base1 ( int i ) : b(i+1),a(b){}
    base1():b(0),a(b){}
    int get_a(){return a;}
    int get_b(){return b;}
};
int main()
{
    base1 obj1(11);
    cout<<obj1.get_a()<<endl<<obj1.get_b()<<endl;
    return 0;
}
```
类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数
答案：随机数  12
- 64位电脑 运行c++结果输出（） 
```cpp
class A
{
    char a[2];
    public:
        virtual void aa(){};
};
class B:public virtual A
{
    char b[2];
    char a[2];
    public:
        virtual void bb(){};
        virtual void aa(){};
};
class C:public virtual B
{
    char a[2];
    char b[2];
    char c[2];
    public:
        virtual void cc(){};
        virtual void aa(){};
        virtual void bb(){};
};
int main()
{
    cout<<sizeof(A)<<endl<<sizeof(B)<<endl<<sizeof(C);
    return 0;
}
```
**类空间大小是成员中内存最大值的最小整数倍。**
虚函数会占用内存空间，这边64位系统，则占用8Byte。
sizeof(A) = 2+8=10，最大成员内存8，则补齐至16.
sizeof(B) = 4+8=12，补齐至16，+sizeof(A)，total=32
sizeof(C) = 6+8=14，补齐至16，+sizeof(B)，total=48
答案：16 32 48
- 以下代码在64位的机子上输出是什么：
```cpp
#include <stdio.h>
int getSize(int data[]){
    return sizeof(data);
}
 
int main(){
    int data1[] = {1,2,3,4,5};
    int size1 = sizeof(data1);
     
    int* data2 = data1;
    int size2 = sizeof(data2);
     
    int size3 = getSize(data1);
     
    printf("%d, %d, %d", size1, size2, size3);
    return 0;
}
```
64位机下，指针占8个字节，所以sizeof(B)为8.getSize()是一个函数，**数组名作为函数的参数退化为指针**，所以size3也为8
答案：20,8,8
- 在Linux系统中，可以用来查找可执行文件的是？
(1)whereis
(2)locate
(3)which
(4)type
(5)find
[https://www.cnblogs.com/kex1n/p/5233821.html](https://www.cnblogs.com/kex1n/p/5233821.html)
答案：(1)(2)(3)(4)(5)
- 假设某分时系统采用时间片轮转法，进程A，B，C，D需要运行的时间分别为20ms，10ms，15ms，5ms，时间片选用5ms，则平均周转时间是：
系统按照时间片轮转，进程运行顺序为A B C D A B C A C A，A执行4次，B执行2次，C执行3次，D执行一次，按执行完的时间算：A在第10个时间片后，B在第6个时间片后，C在第9个时间片后，D在第4个时间片后，平均时间为（10+6+9+4）*5/4 = 36.25
答案：36.25ms
- 假设某系统为进程在内存中分配了3个物理块，进程访问顺序为0、2、1、3、0、2、4、0、2、1、3、4。已知系统未事先调入任何页面，那么当采用FIFO置换算法时，缺页率是：
访问失败叫做缺页，访问的内存不存在或者内存满都算访问失败。
（0）（2）（1）（3）（0）（2）（4）  0    2   （1）（3）  4
前三个括号中的算内存不存在  后6个括号中的算内存满
所以是9/12 = 0.75
答案：75%
- 已知中序遍历的序列为abcdef，高度最小的不可能的二叉树的前序遍历是
`（A）dbacfe （B）dbacef (C)cbaedf (D)cabefd`
要使二叉树的高度最小，则根节点两边子树的节点要尽可能均分。
所以高度最小的二叉树一共有四种情况
前两种是以c为根节点，后两种是以d为根节点
对应的前序遍历分别是
cabedf cbaedf dbacfe dbacef
![](https://uploadfiles.nowcoder.com/images/20180603/8975196_1528009191422_37E21584EB3F289BC55DB59FA5333B73)
答案：D
- 以下算法中未用到贪心算法思想的是？
(A)迪杰斯特拉(Dijkstra)  (B)库鲁斯卡尔(Kruskal)  (C)普里姆算法(Prim)  (D)KMP
```
迪杰斯特拉(Dijkstra)
贪心策略是每次选可达的点中距离源点最近的点进行扩展，即贪心选取最短距离的点
```
```
库鲁斯卡尔(Kruskal)
贪心策略是每次选最短的边（刨除成环的边）来作为最小生成树，即贪心最短边
```
```
普里姆算法(Prim)
贪心策略是每次选可达的点中距离曾经扩展过的点中任意点的最短距离，类似Dij，只是不是找距离源点的最短距离
```
```
KMP
不是贪心
是动态规划，动态规划的是当前状态失败之后上一次匹配的位置（求的是最长的与前缀子串匹配的左子串）
```
答案：D- 对于线性表（ 13,25,22,35,54,57,63）进行散列存储时，若选用 H （ K ） =K %7作为散列函数，则散列地址为 1 的元素有（ ）个？
对7取余=1的数是22,57
答案：2
- 下列选项中，不可能是快速排序第2趟排序结果的是 （）
`(A)4 14 10 12 8 6 18 (B)4 6 10 8 12 14 18 (C)6 4 10 8 14 12 18 (D)8 4 6 10 12 14 18`
快速排序的核心思想是基准数就位，每一趟至少有一个基准数就位，所以两趟下来至少就位两个基准数就位。**所以先自己排序，再找有几个数就位**，C选项只有18就位，所以错误
答案：C
- 如果C类子网的掩码为255.255.255.240，则包含的子网位数、子网数目、每个子网中的主机数目正确的是（ ）
首先C类地址掩码为255.255.255.000 。可知子网号为240（1111 0000） 。所以子网位数为4，对于分类的IPv4地址进行子网划分时，子网号不能使用全1和全0（CIDR却可以），所以子网数为16-2=14。又因为主机号全0表该网络地址，全1表广播地址，所以去掉这两种，子网中的主机数为16-2=14 。
答案：4  14  14
- 将当前命令sh test.sh任务在后台执行，下列最优雅的的做法是
nohup :表示不挂起，在你退出账户之后，进程继续在后台运行，一般形式为：   nohup command &
答案：nohup sh test.sh &
- 有时候因为磁盘空间快满了，我们需要删除一些log文件，但是忘记停止程序了，日志删除后，发现磁盘空间并没有释放，这时候我们通常使用以下哪种方式查找已删除文件的进程占用
lsof(list open files)是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。
答案：lsof
- 关于类成员函数的重载、覆盖和隐藏，下面说法错误的是（）
(A)重载函数必须要在同一个类中
(B)派生类函数覆盖基类函数，基类函数最好不要有virtual关键字
(C)如果派生类的函数与基类的函数名相同，通过派生类的实例也只能调用到派生类的函数。
(D)重载函数不能使用virtual关键字修饰
重载：在相同范围内（同一类）函数名字相同，参数不同，virtual可有可无，水平关系
覆盖/重写：不同范围（父类和子类）函数名字相同，参数相同，基类函数必须有virtual 垂直关系。
隐藏/重定义：是指派生类函数屏蔽了其同名的基类函数。如果派生类函数和基类函数同名，但是参数不同，不管有无virtual,基类函数都会被隐藏；如果如果派生类函数和基类函数同名，参数相同同，且无virtual,基类函数都会被隐藏。
答案：B
- 下列代码的时间复杂度是多少()(^符号是幂的意思)
```cpp
int func(int N)
{
    int cnt = 0;
    for(int i=1;i<=N;i++)
        for(int j=1;j<=N;j+=i)
            cnt+=(i+j);
    return cnt;
}
```
里面的for循环
N/1+N/2+N/3+...N/N
调和级数 1+1/2+1/3+1/4+...+1/n= ln(n+1)+r(r为常量)
所以为NlogN
答案O(NlogN)
- 假如N是由一棵有序树T转换而来的二叉树，那么T中的节点的后序遍历顺序是N节点的()
`(A)先序遍历  (B)中序遍历  (C)后序遍历  (D)层次遍历`
T转换：所有兄弟相连，除了左边第一个子节点，其余子节点与父节点断开
![](https://img-blog.csdnimg.cn/20190317155054968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbmdjaHV3YW5nMTg2OA==,size_16,color_FFFFFF,t_70)
答案：B

