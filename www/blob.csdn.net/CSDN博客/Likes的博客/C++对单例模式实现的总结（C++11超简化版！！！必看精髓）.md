# C++对单例模式实现的总结（C++11超简化版！！！必看精髓） - Likes的博客 - CSDN博客
2019年02月22日 17:57:06[Lailikes](https://me.csdn.net/songchuwang1868)阅读数：45
**目录**
[1、饿汉模式（一开始就初始化单例对象）](#1%E3%80%81%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%BC%80%E5%A7%8B%E5%B0%B1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%89)
[2、懒汉模式（需要的时候在实例化单例对象）](#2%E3%80%81%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%89)
[3、C++11简化版（必看精髓）](#3%E3%80%81C%2B%2B11%E7%AE%80%E5%8C%96%E7%89%88)
### 1、饿汉模式（一开始就初始化单例对象）
优点：不用担心多线程问题。
缺点：可能在整个程序中就没有用到这个单例对象，造成浪费。
实现：
```cpp
class Singleton
{
public:
	static Singleton* GetInstance()//公有static方法，用于获取单例句柄
	{
		return &singleton_;
	}
private:
	Singleton();//构造函数私有
	static Singleton singleton_ ;//私有static单例对象
};
Singleton Singleton::singleton_;
int main()
{
	auto p1 = Singleton::GetInstance();
	auto p2 = Singleton::GetInstance();
	bool result=( p1 == p2);//判断是否指向同一个单例对象
	std::cout <<  result << std::endl;
	return 0;
}
```
### 2、懒汉模式（需要的时候在实例化单例对象）
优点：不会像饿汉模式一样造成资源浪费。只是需要考虑多线程安全，实现上稍稍复杂一点。
```cpp
class Singleton
{
public:
	static Singleton* GetInstance()
	{
		if (p_singleton_ == nullptr)//第一次检查：实例化单例对象后，就不会再进入加锁逻辑
		{
			std::lock_guard<std::mutex> lock(mux_);
			if (p_singleton_ == nullptr)//第二次检查：可能两个线程同时通过第一次检查，一个线程获得锁时，可能另外一个线程已经实例化单体
			{
				p_singleton_ = new Singleton();
			}
		}
		return p_singleton_;
	}
private:
	Singleton();
	static Singleton * p_singleton_ ;
	static std::mutex mux_;
};
std::mutex Singleton::mux_;
Singleton * Singleton::p_singleton_ = nullptr;
int main()
{
	auto p1 = Singleton::GetInstance();
	auto p2 = Singleton::GetInstance();
	bool result=( p1 == p2);
	std::cout <<  result << std::endl;
	return 0;
}
```
其实记住懒汉模式就确保万无一失了，因为当在程序一开始时就调用懒汉模式的GetInstance，就实例化出单例，这等价于饿汉模式。
### 3、C++11简化版（必看精髓）
但是看起来懒汉模式比较复杂，我们还可以利用C++11对static的改进性质简化代码。
```cpp
class Singleton
{
public:
	static Singleton* GetInstance()
	{
		static Singleton  singleton;//此变量存在静态区，C++11自带两段检查锁机制来确保static变量实例化一次
		return &singleton;
	}
private:
	Singleton();
};
int main()
{
	auto p1 = Singleton::GetInstance();
	auto p2 = Singleton::GetInstance();
	bool result=( p1 == p2);
	std::cout <<  result << std::endl;
	return 0;
}
```
这种单例模式的写法可谓是简单地不能再简单了。为什么正确呢？
其实static变量本身全局就只有一份，与单例对象的性质极其相似。而C++11为了确保只初始化static变量一次，提供了两段检查锁机制（在上述代码的汇编代码中，可以清楚地看到两段检查锁的逻辑）。换言之，C++11对于static变量，自带使用了单例模式，自然不用我们再费事。
