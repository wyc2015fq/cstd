# C++引用总结 - Likes的博客 - CSDN博客
2019年02月21日 16:45:39[Lailikes](https://me.csdn.net/songchuwang1868)阅读数：24标签：[C++																[引用](https://so.csdn.net/so/search/s.do?q=引用&t=blog)](https://so.csdn.net/so/search/s.do?q=C++&t=blog)
个人分类：[C++](https://blog.csdn.net/songchuwang1868/article/category/7898933)
# [c++引用总结](https://www.cnblogs.com/jycboy/p/5184638.html)
一、变量的引用：
**引用：就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。**
**引用的声明方法：类型标识符 &引用名=目标变量名；**
** 例：char ch;**
**       char &rp=ch;**
** 1)引用仅是变量的别名，而不是实实在在地定义了一个变量，因此引用本身并不占用内存，而是和目标变量共同指向目标变量的内存地址.**
** 2）表达式中的取地址符&不再是取变量的地址，而是用来表示该变量是引用类型的变量。**
** 3)定义一个引用时，必须对其初始化。这其实是引用不占用内存所导致的必然结果，对于编译器而言引用就是目标变量的别名，目标变量都不在，别名是没有意义的，所以必须初始化。而指针本身是占用内存的，在定义时可以不对其进行初始化，这注定指针的使用更加广泛。**
** 示例代码：**
|12345678910111213141516171819202122232425262728293031|`#include <stdio.h>``#include <iostream>``using``namespace``std;``//c++中的引用实例``void``fun(``int``&x){``     ``printf``(``"形式参数的值为：%d\n"``,x);``     ``printf``(``"形式参数的地址为：%d\n"``,&x);``     ``x+=10;``}``void``fun2(``int``*num){``  ``printf``(``"形式参数的值为：%d\n"``,*num);``  ``printf``(``"形式参数的地址值为：%d\n"``,num); ``//2686724``  ``printf``(``"形式参数的地址为：%d\n"``,&num);  ``//2686704 这个和``  ``*num =(*num)+10;``}``int``main(``void``){``   ``int``num = 4,a=3;``    ``printf``(``"实参num的值为：%d\n"``,num);``    ``printf``(``"实参num的地址为：%d\n"``,&num);``//都是一样的``    ``fun(num);``   ``cout<<``"num的值为："``<<num<<endl; ``//14 num的值改啦``   ``fun2(&a);``   ``printf``(``"实参a的值为：%d\n"``,a);``   ``printf``(``"实参a的地址为：%d\n"``,&a);``//``   ``return``0;``}`|
![](https://images2015.cnblogs.com/blog/747969/201602/747969-20160207113329929-36595115.png)
     从图中可以看出1.引用和目标变量的地址是一样的，对引用的修改就是对目标变量的修改。
                         2. 而后边用指针作为函数参数，把地址传过去，指针变量的地址是2686608，而它的值是2686696（在指针的地址上存的值），2686696这个地址指向的值是3，也就是num的值。
                         3.指针变量是有自己的值的（2686608），和num的地址（2686696）不一样，而引用的地址是和变量的值一样的。
**二、引用的应用**
**1、引用作为参数**
　　引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。
**     （1）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。**
　　（2）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用\"*指针变量名\"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
**如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。**
**     就如同上边的例子一样。**
**2、常引用**
　　常引用声明方式：const  类型标识符  &引用名 = 目标变量名；
　　用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。
|12345678910111213141516171819202122|`#include <stdio.h>``#include <iostream>``using``namespace``std;``void``test_const();``int``main(``void``){``   ``test_const();``   ``return``0;``}``void``test_const(){``   ``int``a=1;``     ``int``&b=a;``     ``b=2;``    ``cout<<``"a="``<<a<<endl;``//2``    ``int``c=1;``    ``const``int``&d=c;``  ``//   d=2;//编译错误 error: assignment of read_only reference 'd'``    ``c=2;``//正确``    ``cout<<``"c="``<<c<<endl;``//``}`|
**     3、引用作为返回值**
　　要以引用返回函数值，则函数定义时要按以下格式：
**类型标识符  &函数名 （形参列表及类型说明）**
**　　　　｛  函数体  ｝**
　　说明：
　　（1）以引用返回函数值，定义函数时需要在函数名前加&
**（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。**
　以下程序中定义了一个普通的函数fn1（它用返回值的方法返回函数值），另外一个函数fn2，它以引用的方法返回函数值。
|12345678910111213141516171819202122232425262728293031|`#include <iostream>``using``namespace``std;`` ``float``temp;``//定义全局变量temp`` ``float``fn1(``float``r);``//声明函数fn1`` ``float``&fn2(``float``r);``//声明函数fn2 r`` ``float``fn1(``float``r){``//定义函数fn1，它以返回值的方法返回函数值``    ``temp=(``float``)(r*r*3.14);``    ``return``temp;``  ``}``  ``float``&fn2(``float``r){``//定义函数fn2，它以引用方式返回函数值``     ``temp=(``float``)(r*r*3.14);``     ``return``temp;`` ``}`` ``int``main(){``     ``float``e=10.0;``     ``float``a=fn1(10.0);``//第1种情况，系统生成要返回值的副本（即临时变量）``    ``// float &b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定）``   ``/*error: invalid initialization of non-const reference of type 'float&' from an rvalue of type 'float'``   ``*/``     ``//不能从被调函数中返回一个临时变量或局部变量的引用``     ``float``c=fn2(10.0);``//第3种情况，系统不生成返回值的副本``     ``//可以从被调函数中返回一个全局变量的引用``     ``float``&d=fn2(10.0); ``//第4种情况，系统不生成返回值的副本``     ``e=d;``     ``cout<<``"a="``<<a<<``",c="``<<c<<``",d="``<<d<<``",e="``<<e<<endl;``     ``//a=314,c=314,d=314``     ``return``0;``   ``}`|
　　引用作为返回值，必须遵守以下规则：
　　（1）**不能返回局部变量的引用。**这条可以参照Effective C++[1]的Item 31。**主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。**如【例5】中的第2种情况出现编译错误。
　　（2）**不能返回函数内部new分配的内存的引用。**这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
　　（3）**可以返回类成员的引用，但最好是const。**这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
　　（4）引用与一些操作符的重载：流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << \"hello\" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
**4、引用和多态**
**引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。**
　　【例7】：
**　　　　class  A;**
**　　　　class  B:public  A{ ... ... }**
**　　　　B  b;**
**　　　　A  &Ref = b;//用派生类对象初始化基类对象的引用**
　　Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。
**　　引用总结**
　　（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，**引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。**
**（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。**
**（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。**
**（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。**
**[](http://www.cnblogs.com/gw811/archive/2012/10/20/2732687.html) 写得真好：[http://www.cnblogs.com/gw811/archive/2012/10/20/2732687.html](http://www.cnblogs.com/gw811/archive/2012/10/20/2732687.html)**
**       保存，防止遗忘**
