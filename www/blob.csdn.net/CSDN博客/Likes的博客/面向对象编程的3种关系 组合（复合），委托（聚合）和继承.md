# 面向对象编程的3种关系:组合（复合），委托（聚合）和继承 - Likes的博客 - CSDN博客
2019年02月20日 17:49:09[Lailikes](https://me.csdn.net/songchuwang1868)阅读数：20标签：[组合																[聚合																[委托																[复合																[UML](https://so.csdn.net/so/search/s.do?q=UML&t=blog)](https://so.csdn.net/so/search/s.do?q=复合&t=blog)](https://so.csdn.net/so/search/s.do?q=委托&t=blog)](https://so.csdn.net/so/search/s.do?q=聚合&t=blog)](https://so.csdn.net/so/search/s.do?q=组合&t=blog)
个人分类：[C++](https://blog.csdn.net/songchuwang1868/article/category/7898933)
看了侯捷老师一节课的视频，做一个记录和小结，在OOP语言中，面向对象编程，类和类之间有3种关系：
1)Inheritance(继承)
2)Composition(复合、组合)
3)Delegation(委托、聚合)
先从Compositon开始讲起，其实在C语言中也见到过，一个结构体里面包含另外一个结构体，在C++中复合也是一样的，侯捷老师以标准库来形象的说明了这种情况，在queue类中包含了deque类
![](https://img-blog.csdn.net/20171203212142531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
2个类的关系如图表示
![](https://img-blog.csdn.net/20171203213403197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
菱形所在一端为A，箭头一端为B，A has B。
实心表示真的包含。那么复合关系下，这2个对象怎么产生，先后顺序是什么
![](https://img-blog.csdn.net/20171203213624694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
我们就像打地基一样，从底开始，我们需要component再去生成container，所以我们要在构造container之前先构造component，可以在container的初始化列表中构造，如果采用的是缺省的构造函数，编译器会自动填充（上述红色字体），但是如果不满意缺省构造函数，我们就得按自己想的写构造函数，在component()的位置上，同样的析构我们也是先从外一步一步拆到里面，所以在析构函数最后调用里面部分的析构函数。
接下来再谈谈委托关系，委托是利用指针包含另一个类，左边有一个右边，但是这个有只是一个指针，有点虚，所以是空心的
![](https://img-blog.csdn.net/20171203214323572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
在很多UML图中直接使用箭头，没有空心菱形，但也代表委托（聚合），这也是最常见的UML符号
有这么一个指针以后，在任何时间我想要你帮忙做事情，就可以委托给你，这也是为什么复合的生命周期是一致的，而委托的生命周期是不一样的（需要时才创建）。
![](https://img-blog.csdn.net/20171203214737923?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
string类只是对外的接口，真正的实现都在stringrep类里，当左边需要动作的时候，就去调用右边，被称为Pimpl（pointer to implementation）,有一个指针去指向为我实现所有功能的类，这种手法的好处在于，这个指针还可以去指向不同的实现类，去实现不同的功能，右边不管怎么变动都不影响string类也就不影响客户端,string类也永远不用再编译。
上述代码的实现如左下图所示，abc3个string指向一个指针，称为引用计数（共享特性）有多个字符串指向同一个hello，这时候abc互相不知道大家都在用同一个内存，如果改变a就会影响其他，怎么做到不影响呢，当a想改变时，整个系统就copy一份给a，让a改，然后降低count，称为copy and write。
下一个关系叫做Inheritance（继承）
![](https://img-blog.csdn.net/20171203220401247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2JmOTUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
public 继承表示is a，派生类是一种基类的东西，同样的继承了基类的数据。子类包含了父类，所以在构造子类之前要先构造父类，在子类的初始化列表上，同样的在析构子类的时候，也是先析构子类，再析构父类，和复合非常相似。
继承中非常重要的是虚函数，将在下一讲中讲到
