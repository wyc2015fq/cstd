# 模版的完全特化与偏特化 - Likes的博客 - CSDN博客
2019年03月30日 20:11:12[Lailikes](https://me.csdn.net/songchuwang1868)阅读数：24标签：[模板																[偏特化																[全特化](https://so.csdn.net/so/search/s.do?q=全特化&t=blog)](https://so.csdn.net/so/search/s.do?q=偏特化&t=blog)](https://so.csdn.net/so/search/s.do?q=模板&t=blog)
个人分类：[C++](https://blog.csdn.net/songchuwang1868/article/category/7898933)
[https://www.cnblogs.co](https://www.cnblogs.com/staring-hxs/p/3659479.html)
模版特化：任何针对模版参数进一步进行条件限制设计的特化版本。 <<泛型思维>>
完全特化：针对所有的模版参数进行特化。 <<c++ primer>>
举例如下：
template<class T,class N> 
class Template{}; 
**全特化:**
template<> 
class Template<int,char>{};
**偏特化：**
template<class T> 
class Template<T,int>{};
**注意：函数模版不存在偏特化，只有类模版才能偏特化**
```cpp
#include <iostream>
using namespace std;
template<typename T, typename N>
class Test
{
public:
    Test( T i, N j ) : a(i), b(j)
    {
        cout<<"普通模板类"<< a <<' ' << b << endl;
    }
private:
    T a;
    N b;
};
template<>
class Test<int , char>
{
public:
    Test( int i, char j ) : a( i ), b( j )
    {
        cout<<"模版类全特化"<< a  << ' ' << b << endl;
    }
private:
    int a;
    char b;
};
template <typename N>
class Test<char, N>
{
public:
    Test( char i, N j ):a( i ), b( j )
    {
        cout<<"模版类偏特化"<< a<< ' ' << b << endl;
    }
private:
    char a;
    N b;
};
//模板函数  
    template<typename T1, typename T2>  
void fun(T1 a , T2 b)  
{  
    cout<<"模板函数"<<endl;  
}  
//模版函数全特化  
template<>  
void fun<int ,char >(int a, char b)  
{  
    cout<<"模版函数全特化"<<endl;  
}  
//函数不存在偏特化：下面的代码是错误的  
// template<typename T2> 
// void fun<char,T2>(char a, T2 b) 
// { 
//     cout<<"模版函数偏特化"<<endl; 
// } 
int main()
{
    Test<double , double> t1( 0.1,0.2 );   //普通模版类
    Test<int , char> t2( 1, 'A' );   //模版类完全特化
    Test<char, bool> t3( 'A', true );  //模版类偏特化
    return 0;
}
```
