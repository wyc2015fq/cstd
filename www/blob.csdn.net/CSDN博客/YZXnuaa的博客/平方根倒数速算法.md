# 平方根倒数速算法 - YZXnuaa的博客 - CSDN博客
2018年03月20日 16:00:31[YZXnuaa](https://me.csdn.net/YZXnuaa)阅读数：366
![](https://img-blog.csdn.net/20160903122206740)
在电影《微微一笑很倾城》中，肖奈大神在玻璃上写了一堆公式，提到平方根倒数速算算法，这个到底是一个什么算法？笔者看电影的时候打开手机学了一下，发现该算法的作者真乃神人！今天有空，就把该算法写一写。
在3D图形编程中，经常要求平方根的倒数，即1/Sqrt(x)，如果用一般的代码(float)(1.0/sqrt(x)),,精度高，但是非常慢；我们需要一个快速，而又足够高精度的算法；著名游戏《雷神之锤III》的代码在2002年左右被披露，人们发现了一段用于快速计算平方根倒数的代码，下面是整理后的代码（去掉了一些宏定义）。
**[csharp]**[view plain](http://blog.csdn.net/xbinworld/article/details/52421847#)[copy](http://blog.csdn.net/xbinworld/article/details/52421847#)
- float InvSqrt (float x)  
- {  
- float xhalf = 0.5f*x;  
- int i = *(int*)&x; // get bits for floating value
- i = 0x5f3759df - (i >> 1);// L1：gives initial guess y0
- x = *(float*)&i; //l2：convert bits back to float
- x = x*(1.5f - xhalf*x*x);  //l3：Newton step, repeating increases accuracy
- return x;  
- }  
**[csharp]**[view plain](http://blog.csdn.net/xbinworld/article/details/52421847#)[copy](http://blog.csdn.net/xbinworld/article/details/52421847#)
- 
该程序运行效率极高，经测试，基本是使用直接开根号求倒数程序的4倍速度！一时间惊为天人。那么这段代码到底怎么理解？为什么中间出现了0x5f3759df这样一个完全无厘头的magic number？
--------------------------------------------------------------------------------------------------------------------------------------------------
该算法的本质其实就是牛顿迭代法（Newton-Raphson Method，简称NR）。NR是一种求方程的近似根的方法。首先要估计一个与方程的根比较靠近的数值，然后根据公式推算下一个更加近似的数值，不断重复直到可以获得满意的精度。其公式如下：
函数：y=f(x)
其一阶导数为：y'=f'(x)
则方程：f(x)=0 的第n+1个近似根为
x[n+1] = x[n] - f(x[n]) / f'(x[n])
--------------------------------------------------------------------------------------------------------------------------------------------------
求一个数a的平方根的倒数，实际就是求方程f(x)=1/(x^2)-a=0的解；将该方程按牛顿迭代法的公式展开为：
x[n+1]=x[n]*(3/2-a/2*x[n]*x[n])
也就是上面代码蓝色部分的第L3行；所以很明显，这段代码就是进行一次迭代的牛顿迭代法。只进行一次迭代就结束程序，又要保证精度，也就是说，牛顿迭代法的初始值要非常精准，才能在一次迭代后完成计算。整个代码最精彩的就是L1行了，i = 0x5f3759df - (i >> 1);到底是什么意思？为什么初始值可以这样算呢？了解该代码，需要先了解一些float point和fix point的表示方法[2]：
一个浮点数float是由32位二进制位表示的有理数，分为三部分。其中**符号**占1位，表示正负，记为**Si**；**指数**占接下来的8位，表示经过偏移处理后的指数，即实际表示E（如图中为124），需要偏移B（图中为2的8次方减1,127。B为一个固定值），最后得指数值为**E-B**；**有效数字（除最高位1以外，因为前面有指数，所以一个数肯定可以表示成1.xxxxx * 2^(kkk)，只保留xxxxx）**占剩下的23位，记为**m**（0<m<1）,图中的![\scriptstyle m=1\times 2^{-2}=0.250](http://upload.wikimedia.org/math/2/8/3/2838060cc9f7355d4066d76ebc42a02b.png)。
所以浮点数的结构公式为：![\scriptstyle x=(-1)^{\mathrm{Si}}\cdot(1+m)\cdot 2^{(E-B)}](http://upload.wikimedia.org/math/d/0/a/d0a5f600d212f7cedbad93beee3490e1.png)，  图中![\scriptstyle x=(1+0.250)\cdot 2^{-3}=0.15625](http://upload.wikimedia.org/math/c/2/0/c2080f02937e548d728abd18fbea6c35.png)
![](https://img-blog.csdn.net/20160903113206934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
整数fix point的表示相对简单，符号占1位，数值占剩下的31位。如果用上图的浮点数字节序列来表示整数，那么![\scriptstyle I=E\times 2^{23}+M](http://upload.wikimedia.org/math/7/8/c/78c7e4b5aef50f0ae128703640b0e501.png)，即![I=124\times 2^{23} + 2^{21}](http://upload.wikimedia.org/math/7/b/d/7bd3890823c9a9e5b55786b0901ae0b6.png)；平方根倒数函数仅能处理正数，所以符号位均为0。
对于同样的32位二进制数码，若为浮点数表示时实际数值为![\scriptstyle x=(1+m_x)2^{e_x}](http://upload.wikimedia.org/math/6/2/d/62da7c55b6e2192b3c7a82192bbdd230.png)，而若为整数表示时实际数值则为![\scriptstyle I_x=E_xL+M_x](http://upload.wikimedia.org/math/c/4/c/c4ce10a25dbe414b753cb26dae1a0f10.png)，其中![\scriptstyle L=2^{n-1-b}](http://upload.wikimedia.org/math/1/c/3/1c3e9805feab5c4e1ccb5608d6239b40.png)，这里n=32，b=8。式子中引入的新变量为：
> 
![m_x=\frac{M_x}{L}](http://upload.wikimedia.org/math/6/2/e/62e227c9e5f585b19083c233fc6fddcb.png)------------------------------------等式1
> 
![e_x=E_x-B](http://upload.wikimedia.org/math/6/f/5/6f57d2c1ea8e332a75ab47c47703a858.png)，其中![B=2^{b-1}-1](http://upload.wikimedia.org/math/4/1/e/41e28bc77be70c87e3756f2a05f90957.png)------------等式2
理解浮点数和整数的表示后，下面开始推导。
x的平方根倒数方程为：
> 
![y=\frac{1}{\sqrt{x}}](http://upload.wikimedia.org/math/b/b/5/bb56561eddeafb2a43230a9a91d10d5e.png)
两边取对数有：
> 
![\log_2{(y)}=-\frac{1}{2}\log_2{(x)}](http://upload.wikimedia.org/math/2/3/d/23d2ecae5c989dc0a6b08ba83eb2b1c3.png)
因为浮点数可表示为：![\scriptstyle x=(1+m_x)2^{e_x}](http://upload.wikimedia.org/math/6/2/d/62da7c55b6e2192b3c7a82192bbdd230.png)，所以也有![](https://img-blog.csdn.net/20140323200324921)，代入上式有：
> 
![\log_2(1+m_y)+e_y=-\frac{1}{2}\log_2{(1+m_x)}-\frac{1}{2}e_x](http://upload.wikimedia.org/math/0/2/6/026746c4ec62f62b37f1d152e0438af5.png)
由于![\scriptstyle 0 \le x < 1](http://upload.wikimedia.org/math/d/6/4/d649759923ec41fc854a0b7a393273e0.png)，有![\scriptstyle \log_2{(1+x)}\approx {x}](http://upload.wikimedia.org/math/5/7/c/57cda556fe7de598e7782a3a50bbc602.png)，则在此可定义![\sigma](http://upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png)与x的关系为![\scriptstyle \log_2{(1+x)}\cong x+\sigma](http://upload.wikimedia.org/math/d/8/9/d89b4e5e1a6943abcb3227d54bc76c06.png)，![\sigma](http://upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png)表示误差，所以将![\scriptstyle \log_2{(1+x)}= x+\sigma](http://upload.wikimedia.org/math/5/e/e/5eed21a00fd6e77f52c241e28f26af94.png)代入上式得：
> 
![m_y+\sigma+e_y=-\frac{1}{2}m_x-\frac{1}{2}\sigma-\frac{1}{2}e_x](http://upload.wikimedia.org/math/f/5/6/f56619e72a7939d8b15f4149fde7e8ec.png)
将等式1，等式2代入到上述方程中，有：
> 
![M_y+(E_y-B)L=-\frac{3}{2}\sigma{L}-\frac{1}{2}M_x-\frac{1}{2}(E_x-B)L](http://upload.wikimedia.org/math/b/6/a/b6ad534864e55c514b28eab99491fc3f.png)
移项整理得：
> 
![E_yL+M_y=\frac{3}{2}(B-\sigma)L-\frac{1}{2}(E_xL+M_x)](http://upload.wikimedia.org/math/6/c/e/6ce37033da0f457f176b88e250f47098.png)
又因为浮点规格存储的正浮点数x，若将其作为整数表示，则示值为：![\scriptstyle I_x=E_xL+M_x](http://upload.wikimedia.org/math/c/4/c/c4ce10a25dbe414b753cb26dae1a0f10.png)，所以**x的平方根倒数**的**首次近似值**的**整数表示值**为：
> 
![I_y=E_yL+M_y=R-\frac{1}{2}(E_xL+M_x)=R-\frac{1}{2}I_x](http://upload.wikimedia.org/math/a/8/3/a83f6fdf7d19a5d325d392c1cf492416.png)，
其中![R=\frac{3}{2}(B-\sigma)L](http://upload.wikimedia.org/math/f/1/3/f132458ac96d31a6fc42a77743f59de9.png)，![B=2^{b-1}-1](http://upload.wikimedia.org/math/4/1/e/41e28bc77be70c87e3756f2a05f90957.png)，![\scriptstyle L=2^{n-1-b}](http://upload.wikimedia.org/math/1/c/3/1c3e9805feab5c4e1ccb5608d6239b40.png)，n=32，b=8。
这个式子对应着源代码中的这一行：**i  = 0x5f3759df - ( i >> 1 );**，然后将整数表示值换回表示浮点数：**x  = * ( float * ) &i;**。这样就得到了浮点数的平方根倒数的近似值。
0x5f3759df 对应着R，即3/2(B-![\sigma](http://upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png))L.当R为0x5f3759df时，有![\scriptstyle \sigma=0.0450461875791687011756](http://upload.wikimedia.org/math/1/f/e/1feda3b05e687c2527dec6d7c6709ac0.png).
"现在不仅该算法的原作者不明，人们也仍无法明确当初选择这个“魔术数字”的方法。Chris Lomont在研究中曾做了个试验：他编写了一个函数，以在一个范围内遍历选取R值的方式将逼近误差降到最小，以此方法他计算出了线性近似的最优R值0x5f37642f（与代码中使用的0x5f3759df相当接近），但以之代入算法计算并进行一次牛顿迭代后，所得近似值与代入0x5f3759df的结果相比精度却仍略微更低。……在Charles McEniry的论文中，他使用了一种类似Lomont但更复杂的方法来优化R值：他最开始使用穷举搜索，所得结果与Lomont相同；而后他尝试用带权二分法寻找最优值，所得结果恰是代码中所使用的魔术数字0x5f3759df"---维基百科
