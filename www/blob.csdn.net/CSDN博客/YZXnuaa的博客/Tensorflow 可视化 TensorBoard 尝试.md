# Tensorflow 可视化 TensorBoard 尝试~ - YZXnuaa的博客 - CSDN博客
2018年01月10日 10:56:01[YZXnuaa](https://me.csdn.net/YZXnuaa)阅读数：346
原文地址：blog.csdn.net/silver_sail/article/details/51899659
安装Tensorflow的过程就不必说了，安装官网或者google一下，很多资源。
这次实验是在Iris数据集进行的，[下载链接](http://wenku.baidu.com/link?url=TyADN_eOzv8KsOtwOFZxqgatEoE_I8VE_8p7SRsXan_GflYQcneA1zW9SDQAbs0LqsvHvDjBYXHD1xCM1cakpzzNllkmWtCAAw5xz_mWre3)
代码如下：
**[python]**[view plain](http://blog.csdn.net/silver_sail/article/details/51899659#)[copy](http://blog.csdn.net/silver_sail/article/details/51899659#)
- import os  
- import cv2  
- import numpy as np  
- import sys  
- import tensorflow as tf  
- import random  
- import math  
- 
- def weight_variable(shape):  
-     initial = tf.truncated_normal(shape, stddev=0.1)  
- return tf.Variable(initial)  
- 
- def bias_variable(shape):  
-     initial = tf.constant(0.1, shape=shape)  
- return tf.Variable(initial)  
- 
- def load_iris(path):  
- #check file exist.
- ifnot os.path.exists(path):  
- print"path is not exist"
- return
- 
-     return_data = []  
-     return_label = []  
-     my_map = {}  
-     key = 0
-     iris_file = open(path);  
- for line in iris_file:  
- #cut the \n
-         line = line[:-1]  
-         elements = line.split(',')  
- 
- if len(elements) == 5:  
-             temp = elements[:-1]  
-             data = [float(x) for x in temp]  
-             category = elements[4]  
- 
-             label = key  
- if my_map.has_key(category):  
-                 label = my_map[category]  
- else:  
-                 my_map[category] = key  
-                 key = key + 1
-             label_vector = [0] * 3;  
-             label_vector[label] = 1;  
-             return_data.append(data)  
-             return_label.append(label_vector)  
-     iris_file.close()  
- return return_data,return_label  
- 
- def run(train_path):  
- #load data
-     img,label = load_iris(train_path)  
-     sess = tf.InteractiveSession()  
- 
- #first layer.
-     with tf.name_scope('input'):  
-         x = tf.placeholder("float", shape=[None, 4],name='x-input')  
-         y_ = tf.placeholder("float", shape=[None, 3],name='y-input')  
- 
- def next_batch(img,label,size):  
-         img_r =[]  
-         label_r = []  
- for num in range(size):  
-             index = random.randint(0,len(img)-1)  
-             img_r.append(np.array(img[index]))  
-             label_r.append(np.array(label[index]))  
-         img_r = np.array(img_r)  
-         label_r = np.array(label_r)  
- return {x:img_r,y_:label_r}  
- 
- def variable_summaries(var, name):  
-         with tf.name_scope('summaries'):  
-             mean = tf.reduce_mean(var)  
-             tf.scalar_summary('mean/' + name, mean)  
-             with tf.name_scope('stddev'):  
-                 stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))  
-             tf.scalar_summary('sttdev/' + name, stddev)  
-             tf.scalar_summary('max/' + name, tf.reduce_max(var))  
-             tf.scalar_summary('min/' + name, tf.reduce_min(var))  
-             tf.histogram_summary(name, var)  
- 
- #fully connection
- def nn_layer(input,input_dim,output_dim,layer_name,act=tf.nn.relu):  
-         with tf.name_scope(layer_name):  
-             with tf.name_scope('W'):  
-                 f_w_1 = weight_variable([input_dim,output_dim])  
-                 variable_summaries(f_w_1, layer_name + '/weights')  
-             with tf.name_scope('B'):  
-                 f_b_1 = bias_variable([output_dim])  
-                 variable_summaries(f_b_1, layer_name + '/bias')  
-             with tf.name_scope('Wx_plus_b'):  
-                 input_drop = tf.reshape(input,[-1,input_dim])  
-                 f_r_1 = tf.matmul(input_drop,f_w_1) + f_b_1  
-                 tf.histogram_summary(layer_name + '/pre_activations', f_r_1)  
-             activations = act(f_r_1, 'activation')  
-             tf.histogram_summary(layer_name + '/activations', activations)  
- return activations  
- 
-     l1_output = nn_layer(x,4,100,'layer1')  
-     l2_output = nn_layer(l1_output,100,3,'layer2',act=tf.nn.softmax)  
- 
- #
-     with tf.name_scope('cross_entropy'):  
-         cross_entropy = -tf.reduce_sum(y_*tf.log(l2_output))  
-         tf.scalar_summary('cross entropy', cross_entropy)  
- 
-     with tf.name_scope('train'):  
-         train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)  
-         correct_prediction = tf.equal(tf.argmax(l2_output,1), tf.argmax(y_,1))  
- 
-     with tf.name_scope('accuracy'):  
-         accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float"))  
-     tf.scalar_summary('accuracy',accuracy)  
- 
-     merged = tf.merge_all_summaries()  
-     train_writer = tf.train.SummaryWriter('/home/ubuntu/temp/log/train',sess.graph)  
-     test_writer = tf.train.SummaryWriter('/home/ubuntu/temp/log/test')  
-     tf.initialize_all_variables().run()  
- 
- for i in range(200000):  
- if i % 100 == 0:  # Record summaries and test-set accuracy
-             summary, acc = sess.run([merged, accuracy], feed_dict=next_batch(img,label,20))  
-             test_writer.add_summary(summary, i)  
- print('Accuracy at step %s: %s' % (i, acc))  
- else:  # Record train set summaries, and train
- if i % 100 == 99:  # Record execution stats
-                 run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)  
-                 run_metadata = tf.RunMetadata()  
-                 summary, _ = sess.run([merged, train_step],  
-                               feed_dict=next_batch(img,label,20),  
-                               options=run_options,  
-                               run_metadata=run_metadata)  
-                 train_writer.add_run_metadata(run_metadata, 'step%d' % i)  
-                 train_writer.add_summary(summary, i)  
- print('Adding run metadata for', i)  
- else:  # Record a summary
-                 summary, _ = sess.run([merged, train_step], feed_dict=next_batch(img,label,20))  
-                 train_writer.add_summary(summary, i)  
- 
- if __name__ == '__main__':  
-     run('iris.data.set.txt')  
代码是参考tensorflow官网的例子进行实验的，官网例子如下：
**[python]**[view plain](http://blog.csdn.net/silver_sail/article/details/51899659#)[copy](http://blog.csdn.net/silver_sail/article/details/51899659#)
- # Copyright 2015 The TensorFlow Authors. All Rights Reserved.
- #
- # Licensed under the Apache License, Version 2.0 (the 'License');
- # you may not use this file except in compliance with the License.
- # You may obtain a copy of the License at
- #
- #     http://www.apache.org/licenses/LICENSE-2.0
- #
- # Unless required by applicable law or agreed to in writing, software
- # distributed under the License is distributed on an 'AS IS' BASIS,
- # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- # See the License for the specific language governing permissions and
- # limitations under the License.
- # ==============================================================================
- """A simple MNIST classifier which displays summaries in TensorBoard.
-  This is an unimpressive MNIST model, but it is a good example of using
- tf.name_scope to make a graph legible in the TensorBoard graph explorer, and of
- naming summary tags so that they are grouped meaningfully in TensorBoard.
- It demonstrates the functionality of every TensorBoard dashboard.
- """
- from __future__ import absolute_import  
- from __future__ import division  
- from __future__ import print_function  
- 
- import tensorflow as tf  
- 
- from tensorflow.examples.tutorials.mnist import input_data  
- 
- flags = tf.app.flags  
- FLAGS = flags.FLAGS  
- flags.DEFINE_boolean('fake_data', False, 'If true, uses fake data '
- 'for unit testing.')  
- flags.DEFINE_integer('max_steps', 1000, 'Number of steps to run trainer.')  
- flags.DEFINE_float('learning_rate', 0.001, 'Initial learning rate.')  
- flags.DEFINE_float('dropout', 0.9, 'Keep probability for training dropout.')  
- flags.DEFINE_string('data_dir', '/tmp/data', 'Directory for storing data')  
- flags.DEFINE_string('summaries_dir', '/tmp/mnist_logs', 'Summaries directory')  
- 
- 
- def train():  
- # Import data
-   mnist = input_data.read_data_sets(FLAGS.data_dir,  
-                                     one_hot=True,  
-                                     fake_data=FLAGS.fake_data)  
- 
-   sess = tf.InteractiveSession()  
- 
- # Create a multilayer model.
- 
- # Input placehoolders
-   with tf.name_scope('input'):  
-     x = tf.placeholder(tf.float32, [None, 784], name='x-input')  
-     y_ = tf.placeholder(tf.float32, [None, 10], name='y-input')  
- 
-   with tf.name_scope('input_reshape'):  
-     image_shaped_input = tf.reshape(x, [-1, 28, 28, 1])  
-     tf.image_summary('input', image_shaped_input, 10)  
- 
- # We can't initialize these variables to 0 - the network will get stuck.
- def weight_variable(shape):  
- """Create a weight variable with appropriate initialization."""
-     initial = tf.truncated_normal(shape, stddev=0.1)  
- return tf.Variable(initial)  
- 
- def bias_variable(shape):  
- """Create a bias variable with appropriate initialization."""
-     initial = tf.constant(0.1, shape=shape)  
- return tf.Variable(initial)  
- 
- def variable_summaries(var, name):  
- """Attach a lot of summaries to a Tensor."""
-     with tf.name_scope('summaries'):  
-       mean = tf.reduce_mean(var)  
-       tf.scalar_summary('mean/' + name, mean)  
-       with tf.name_scope('stddev'):  
-         stddev = tf.sqrt(tf.reduce_sum(tf.square(var - mean)))  
-       tf.scalar_summary('sttdev/' + name, stddev)  
-       tf.scalar_summary('max/' + name, tf.reduce_max(var))  
-       tf.scalar_summary('min/' + name, tf.reduce_min(var))  
-       tf.histogram_summary(name, var)  
- 
- def nn_layer(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu):  
- """Reusable code for making a simple neural net layer.
-     It does a matrix multiply, bias add, and then uses relu to nonlinearize.
-     It also sets up name scoping so that the resultant graph is easy to read,
-     and adds a number of summary ops.
-     """
- # Adding a name scope ensures logical grouping of the layers in the graph.
-     with tf.name_scope(layer_name):  
- # This Variable will hold the state of the weights for the layer
-       with tf.name_scope('weights'):  
-         weights = weight_variable([input_dim, output_dim])  
-         variable_summaries(weights, layer_name + '/weights')  
-       with tf.name_scope('biases'):  
-         biases = bias_variable([output_dim])  
-         variable_summaries(biases, layer_name + '/biases')  
-       with tf.name_scope('Wx_plus_b'):  
-         preactivate = tf.matmul(input_tensor, weights) + biases  
-         tf.histogram_summary(layer_name + '/pre_activations', preactivate)  
-       activations = act(preactivate, 'activation')  
-       tf.histogram_summary(layer_name + '/activations', activations)  
- return activations  
- 
-   hidden1 = nn_layer(x, 784, 500, 'layer1')  
- 
-   with tf.name_scope('dropout'):  
-     keep_prob = tf.placeholder(tf.float32)  
-     tf.scalar_summary('dropout_keep_probability', keep_prob)  
-     dropped = tf.nn.dropout(hidden1, keep_prob)  
- 
-   y = nn_layer(dropped, 500, 10, 'layer2', act=tf.nn.softmax)  
- 
-   with tf.name_scope('cross_entropy'):  
-     diff = y_ * tf.log(y)  
-     with tf.name_scope('total'):  
-       cross_entropy = -tf.reduce_mean(diff)  
-     tf.scalar_summary('cross entropy', cross_entropy)  
- 
-   with tf.name_scope('train'):  
-     train_step = tf.train.AdamOptimizer(FLAGS.learning_rate).minimize(  
-         cross_entropy)  
- 
-   with tf.name_scope('accuracy'):  
-     with tf.name_scope('correct_prediction'):  
-       correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))  
-     with tf.name_scope('accuracy'):  
-       accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))  
-     tf.scalar_summary('accuracy', accuracy)  
- 
- # Merge all the summaries and write them out to /tmp/mnist_logs (by default)
-   merged = tf.merge_all_summaries()  
-   train_writer = tf.train.SummaryWriter(FLAGS.summaries_dir + '/train',  
-                                         sess.graph)  
-   test_writer = tf.train.SummaryWriter(FLAGS.summaries_dir + '/test')  
-   tf.initialize_all_variables().run()  
- 
- # Train the model, and also write summaries.
- # Every 10th step, measure test-set accuracy, and write test summaries
- # All other steps, run train_step on training data, & add training summaries
- 
- def feed_dict(train):  
- """Make a TensorFlow feed_dict: maps data onto Tensor placeholders."""
- if train or FLAGS.fake_data:  
-       xs, ys = mnist.train.next_batch(100, fake_data=FLAGS.fake_data)  
-       k = FLAGS.dropout  
- else:  
-       xs, ys = mnist.test.images, mnist.test.labels  
-       k = 1.0
- return {x: xs, y_: ys, keep_prob: k}  
- 
- for i in range(FLAGS.max_steps):  
- if i % 10 == 0:  # Record summaries and test-set accuracy
-       summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(False))  
-       test_writer.add_summary(summary, i)  
- print('Accuracy at step %s: %s' % (i, acc))  
- else:  # Record train set summaries, and train
- if i % 100 == 99:  # Record execution stats
-         run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)  
-         run_metadata = tf.RunMetadata()  
-         summary, _ = sess.run([merged, train_step],  
-                               feed_dict=feed_dict(True),  
-                               options=run_options,  
-                               run_metadata=run_metadata)  
-         train_writer.add_run_metadata(run_metadata, 'step%d' % i)  
-         train_writer.add_summary(summary, i)  
- print('Adding run metadata for', i)  
- else:  # Record a summary
-         summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True))  
-         train_writer.add_summary(summary, i)  
- 
- 
- def main(_):  
- if tf.gfile.Exists(FLAGS.summaries_dir):  
-     tf.gfile.DeleteRecursively(FLAGS.summaries_dir)  
-   tf.gfile.MakeDirs(FLAGS.summaries_dir)  
-   train()  
- 
- 
- if __name__ == '__main__':  
-   tf.app.run()  
有了这个代码，就可以运行了。因为自己设置的目录是/home/ubuntu/temp/log，所以在tensorboard运行的时候要指定这个目录。
命令如下：
**[plain]**[view plain](http://blog.csdn.net/silver_sail/article/details/51899659#)[copy](http://blog.csdn.net/silver_sail/article/details/51899659#)
- python tensorboard.py --logdir=/home/ubuntu/temp/log  
之后访问一下指定地址：
![](https://img-blog.csdn.net/20160713172125511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://blog.csdn.net/silver_sail/article/details/51899659)
如果访问没有数据，可以在命令后面加上--debug来查看详细信息，
![](http://blog.csdn.net/silver_sail/article/details/51899659)
红色标记的是tensorboard监视的目录，查看一下是否正确。
![](https://img-blog.csdn.net/20160713172259122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
如果还是不正确。。。就只能安装官网Readme来排查了：
![](http://blog.csdn.net/silver_sail/article/details/51899659)
[就是这里](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tensorboard/README.md)
