# 装箱问题 - YZXnuaa的博客 - CSDN博客
2018年04月11日 13:24:24[YZXnuaa](https://me.csdn.net/YZXnuaa)阅读数：104
个人分类：[基础算法](https://blog.csdn.net/YZXnuaa/article/category/7523136)
**[cpp]**[view plain](https://blog.csdn.net/a237653639/article/details/21212217#)[copy](https://blog.csdn.net/a237653639/article/details/21212217#)
- # include <stdio.h>
- int main()  
- {  
- int V, n;  
-     scanf("%d", &V);  
-     scanf("%d", &n);  
- int v[n+1];  
- int c[n+1][V+1];  
- int i,j;  
- for (i=1; i<=n; i++)  
-         scanf("%d", &v[i]);  
- for (i=0; i<=n; i++)  
-         c[i][0] = 0;  
- for (i=0; i<=V; i++)  
-         c[0][i] = 0;  
- for (i=1; i<=n; i++)  
- for (j=1; j<=V; j++)  
-         {  
- if (v[i] <= j)  
-             {  
- if (c[i-1][j-v[i]]+v[i] > c[i-1][j])  
-                     c[i][j] = c[i-1][j-v[i]]+v[i];  
- else
-                     c[i][j] = c[i-1][j];  
-             }  
- else
-                 c[i][j] = c[i-1][j];  
-         }  
-     printf("%d", V-c[n][V]);      
- 
- return 0;  
- }  
- #include <iostream>
- #include <cstring>
- usingnamespace std;  
- int max(int x, int y)  
- {  
- return x>y?x:y;  
- }  
- int main()  
- {  
- int v,n;  
-   cin >> v >> n;  
- int a[n];  
- int dp[v+1];  
-   memset(dp, 0, sizeof(dp));  
- /*
- 分析：背包型动态规划，相当于背包容量和背包中物品价值二者相等的一般背包问题。（貌似也称为伪背包问题）
- 对于每一个物品i，都存在放入箱子和不放入箱子两种情况。当前箱子容量剩余j时，若i放入，则为dp[j-a[i]]+a[i])；
- 若i不放入，则为dp[i]；因此，状态转移方程为：dp[j] = max(dp[j], dp[j-a[i]]+a[i])。*/
- for(int i=0; i<n; i++)//n个物品循环
-   {  
-     cin>>a[i];  
- for(int j=v; j>=a[i]; j--)//剩余容量
-     {  
-       dp[j] = max(dp[j], dp[j-a[i]]+a[i]);  
-     }  
-   }  
-   cout << v-dp[v];  
- }  

