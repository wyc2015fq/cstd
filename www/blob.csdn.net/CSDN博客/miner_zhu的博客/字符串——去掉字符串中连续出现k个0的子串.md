# 字符串——去掉字符串中连续出现k个0的子串 - miner_zhu的博客 - CSDN博客





2018年07月22日 10:10:30[miner_zhu](https://me.csdn.net/miner_zhu)阅读数：98








**【题目】**

　　给定一个字符串str和一个整数k，如果str中刚好有连续的k个‘0’字符出现时，把k个连续的‘0’字符删除，返回处理后的字符串。

**【举例】**

　　str = “A00B”，k = 2，返回 “AB”。 

　　str = “A0000B000”，k = 3，返回 “A0000B”。

**【基本思路】**
- 
使用两个变量count和start。count表示目前出现的连续‘0’的个数，start表示连续个‘0’出现的开始的位置。初始时，count = 0，start = -1。

- 
从左到右依次遍历str，假设遍历到i的位置的字符为char，情况分析如下：

1）如果char是字符‘0’，此时更新start的值，如果start = -1 ，说明之前没处在发现连续的 ‘0’的阶段，那么令start = i，否则start不变。同时令count加1。

2）如果char不是字符‘0’，此时为去掉连续 ‘0’的阶段。首先看此时count的值是否等于k，如果等于的话，说明之前出现的字符 ‘0’的个数正好为k，删除这些连续的 ‘0’；如果不等于的话，不必删除。最后令count = 0，start = -1。

3）既然把去掉 ‘0’的时机放在了char不是字符 ‘0’的时候，那么str如果以k个 ‘0’结尾的话，这个连续的 ‘0’就不会删除，所以在最后要再次判断一下count。




时间复杂度o（n），空间复杂度o（1）

```python
def removeKZeros(str1,k):
	if str1 == None or k <1 :
		return str1
	count = 0  #0的计数
	start = -1 #0出现的起始位置
    chas = list(str1) #列表化
    for i in range(len(chas)):
        if chas[i] == '0':
            count += 1
            start = i if start == -1 else start
        else:
            if count == k:
                while count > 0:  #重置
                    chas[start] = ""
                    start += 1
                    count -= 1
            count = 0  #重新赋值
            start = -1
    if count == k: #防止结尾出现k个0
        while count > 0:
            chas[start] = ""
            start += 1
            count -= 1
    return ''.join(chas) #转化为字符串方法：str.join(元组、列表、字典、字符串) 之后生成的只能是字符串
```





