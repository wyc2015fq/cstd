# c++基础笔记 - miner_zhu的博客 - CSDN博客





2018年11月07日 11:16:50[miner_zhu](https://me.csdn.net/miner_zhu)阅读数：93








# C++ 基本语法

C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。
- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

## 编译 & 执行 C++ 程序

接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：
- 打开一个文本编辑器，添加上述代码。
- 保存文件为 hello.cpp。
- 打开命令提示符，进入到保存文件所在的目录。
- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。
- 现在，键入 ' a.out' 来运行程序。
- 您可以看到屏幕上显示 ' Hello World '。

```
$ g++ hello.cpp
$ ./a.out
Hello World
```

请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。

您也可以使用 makefile 来编译 C/C++ 程序。

## C++ 中的分号 & 语句块

在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。

语句块是一组使用大括号{}括起来的按逻辑连接的语句。

## C++ 标识符

C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以**字母 A-Z 或 a-z 或下划线 _ **开始，后跟零个或多个**字母、下划线和数字**（0-9）

# C++ 注释

C++ 注释以 /* 开始，以 */ 终止。

以 // 开始，直到行末为止。

## 基本的内置类型

C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：
|类型|关键字|
|----|----|
|布尔型|bool|
|字符型|char|
|整型|int|
|浮点型|float|
|双浮点型|double|
|无类型|void|
|宽字符型|wchar_t|

一些基本类型可以使用一个或多个类型修饰符进行修饰：
- signed
- unsigned
- short
- long

## 局部变量

在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。

## 全局变量

在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。

## 定义常量

在 C++ 中，有两种简单的定义常量的方式：
- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

```
#define identifier value
const type variable = value
```

## 杂项运算符

下表列出了 C++ 支持的其他一些重要的运算符。
|运算符|描述|
|----|----|
|sizeof|[sizeof 运算符](http://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。|
|Condition ? X : Y|[条件运算符](http://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。|
|,|[逗号运算符](http://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。|
|.（点）和 ->（箭头）|[成员运算符](http://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。|
|Cast|[强制转换运算符](http://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|
|&|[指针运算符 &](http://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。|
|*|[指针运算符 *](http://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。|

# C++ 函数

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等。

## 定义函数

C++ 中的函数定义的一般形式如下：

return_type function_name( parameter list ) { body of the function }

在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

## 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：
`return_type function_name( parameter list );`
在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：
`int max(int, int);`
## 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有两种向函数传递参数的方式：
|调用类型|描述|
|----|----|
|[传值调用](http://www.runoob.com/cplusplus/cpp-function-call-by-value.html)|该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。|
|[指针调用](http://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html)|该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。|
|[引用调用](http://www.runoob.com/cplusplus/cpp-function-call-by-reference.html)|该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。|

默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。

## 参数的默认值

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。

# 字符串

C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:
|序号|函数 & 目的|
|----|----|
|1|**strcpy(s1, s2);**			复制字符串 s2 到字符串 s1。|
|2|**strcat(s1, s2);**			连接字符串 s2 到字符串 s1 的末尾。|
|3|**strlen(s1);**			返回字符串 s1 的长度。|
|4|**strcmp(s1, s2);**			如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。|
|5|**strchr(s1, ch);**			返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
|6|**strstr(s1, s2);**			返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

# 指针

学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 *****来返回位于操作数所指定地址的变量的值。

在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：
|概念|描述|
|----|----|
|[C++ Null 指针](http://www.runoob.com/cplusplus/cpp-null-pointers.html)|C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。|
|[C++ 指针的算术运算](http://www.runoob.com/cplusplus/cpp-pointer-arithmetic.html)|可以对指针进行四种算术运算：++、--、+、-|
|[C++ 指针 vs 数组](http://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html)|指针和数组之间有着密切的关系。|
|[C++ 指针数组](http://www.runoob.com/cplusplus/cpp-array-of-pointers.html)|可以定义用来存储指针的数组。|
|[C++ 指向指针的指针](http://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html)|C++ 允许指向指针的指针。|
|[C++ 传递指针给函数](http://www.runoob.com/cplusplus/cpp-passing-pointers-to-functions.html)|通过引用或地址传递参数，使传递的参数在调用函数中被改变。|
|[C++ 从函数返回指针](http://www.runoob.com/cplusplus/cpp-return-pointer-from-functions.html)|C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。|



# 引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

## C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：
- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

```
int&  r = i;
double& s = d;
```

引用通常用于函数参数列表和函数返回值。

# 日期 & 时间

C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。

有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。结构类型 **tm** 把日期和时间以 C 结构的形式保存。

# 基本的输入输出

## I/O 库头文件

下列的头文件在 C++ 编程中很重要。
|头文件|函数和描述|
|----|----|
|<iostream>|该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。|
|<iomanip>|该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。|
|<fstream>|该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。|

输出流**cout**，C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<< 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 << 在一个语句中可以多次使用，**endl** 用于在行末添加一个换行符。输入流**cin，**>>

 使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。

输入输出流中的函数（模板）：

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
    cout<<setiosflags(ios::left|ios::showpoint);  // 设左对齐，以一般实数方式显示
    cout.precision(5);       // 设置除小数点外有五位有效数字 
    cout<<123.456789<<endl;
    cout.width(10);          // 设置显示域宽10 
    cout.fill('*');          // 在显示区域空白处用*填充
    cout<<resetiosflags(ios::left);  // 清除状态左对齐
    cout<<setiosflags(ios::right);   // 设置右对齐
    cout<<123.456789<<endl;
    cout<<setiosflags(ios::left|ios::fixed);    // 设左对齐，以固定小数位显示
    cout.precision(3);    // 设置实数显示三位小数
    cout<<999.123456<<endl; 
    cout<<resetiosflags(ios::left|ios::fixed);  //清除状态左对齐和定点格式
    cout<<setiosflags(ios::left|ios::scientific);    //设置左对齐，以科学技术法显示 
    cout.precision(3);   //设置保留三位小数
    cout<<123.45678<<endl;
    return 0; 
}
```

测试输出结果：

```
123.46
****123.46
999.123
1.235e+02
```

其中 cout.setf 跟 setiosflags 一样，cout.precision 跟 setprecision 一样，cout.unsetf 跟 resetiosflags 一样。

```
setioflags(ios::fixed) 固定的浮点显示 
setioflags(ios::scientific) 指数表示 
setiosflags(ios::left) 左对齐 
setiosflags(ios::right) 右对齐 
setiosflags(ios::skipws 忽略前导空白 
setiosflags(ios::uppercase) 16进制数大写输出 
setiosflags(ios::lowercase) 16进制小写输出 
setiosflags(ios::showpoint) 强制显示小数点 
setiosflags(ios::showpos) 强制显示符号
```

cout.setf 常见的标志：
|标志|功能|
|----|----|
|boolalpha|可以使用单词”true”和”false”进行输入/输出的布尔值.|
|oct|用八进制格式显示数值.|
|dec|用十进制格式显示数值.|
|hex|用十六进制格式显示数值.|
|left|输出调整为左对齐.|
|right|输出调整为右对齐.|
|scientific|用科学记数法显示浮点数.|
|fixed|用正常的记数方法显示浮点数(与科学计数法相对应).|
|showbase|输出时显示所有数值的基数.|
|showpoint|显示小数点和额外的零，即使不需要.|
|showpos|在非负数值前面显示”＋（正号）”.|
|skipws|当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).|
|unitbuf|在每次插入以后，清空缓冲区.|
|internal|将填充字符回到符号和数值之间.|
|uppercase|以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.|

iostream 中定义的操作符：
|操作符|描述|输入|输出|
|----|----|----|----|
|boolalpha|启用boolalpha标志|√|√|
|dec|启用dec标志|√|√|
|endl|输出换行标示，并清空缓冲区||√|
|ends|输出空字符||√|
|fixed|启用fixed标志||√|
|flush|清空流||√|
|hex|启用 hex 标志|√|√|
|internal|启用 internal 标志||√|
|left|启用 left 标志||√|
|noboolalpha|关闭boolalpha 标志|√|√|
|noshowbase|关闭showbase 标志||√|
|noshowpoint|关闭showpoint 标志||√|
|noshowpos|关闭showpos 标志||√|
|noskipws|关闭skipws 标志|√||
|nounitbuf|关闭unitbuf 标志||√|
|nouppercase|关闭uppercase 标志||√|
|oct|启用 oct 标志|√|√|
|right|启用 right 标志||√|
|scientific|启用 scientific 标志||√|
|showbase|启用 showbase 标志||√|
|showpoint|启用 showpoint 标志||√|
|showpos|启用 showpos 标志||√|
|skipws|启用 skipws 标志|√||
|unitbuf|启用 unitbuf 标志||√|
|uppercase|启用 uppercase 标志||√|
|ws|跳过所有前导空白字符|√||

iomanip 中定义的操作符：
|操作符|描述|输入|输出|
|----|----|----|----|
|resetiosflags(long f)|关闭被指定为f的标志|√|√|
|setbase(int base)|设置数值的基本数为base||√|
|setfill(int ch)|设置填充字符为ch||√|
|setiosflags(long f)|启用指定为f的标志|√|√|
|setprecision(int p)|设置数值的精度(四舍五入)||√|
|setw(int w)|设置域宽度为w||√|

# 数据结构

C/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：

```cpp
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。

## 指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：
`struct Books *struct_pointer;`
现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：
`struct_pointer = &Book1;`
为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：
`struct_pointer->title;`
## typedef 关键字

下面是一种更简单的定义结构的方式，您可以为创建的类型取一个"别名"。例如：

```
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
```

现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：
`Books Book1, Book2;`
您可以使用 **typedef** 关键字来定义非结构类型，如下所示：

```
typedef long int *pint32;
 
pint32 x, y, z;
```

x, y 和 z 都是指向长整型 long int 的指针。

# 类 & 对象

C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。

类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。

## 类定义

定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。

类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：

```cpp
class Box
{
   public:
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
};
```

## 定义 C++ 对象

类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的一个对象：

Box Box1;        // 声明 Box1，类型为 Box

## 访问数据成员

类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。

需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。

# 类 & 对象详解

到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。
|概念|描述|
|----|----|
|[类成员函数](http://www.runoob.com/cplusplus/cpp-class-member-functions.html)|类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。|
|[类访问修饰符](http://www.runoob.com/cplusplus/cpp-class-access-modifiers.html)|类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。|
|[构造函数 & 析构函数](http://www.runoob.com/cplusplus/cpp-constructor-destructor.html)|类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。|
|[C++ 拷贝构造函数](http://www.runoob.com/cplusplus/cpp-copy-constructor.html)|拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。|
|[C++ 友元函数](http://www.runoob.com/cplusplus/cpp-friend-functions.html)|**友元函数**可以访问类的 private 和 protected 成员。|
|[C++ 内联函数](http://www.runoob.com/cplusplus/cpp-inline-functions.html)|通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。|
|[C++ 中的 this 指针](http://www.runoob.com/cplusplus/cpp-this-pointer.html)|每个对象都有一个特殊的指针 **this**，它指向对象本身。|
|[C++ 中指向类的指针](http://www.runoob.com/cplusplus/cpp-pointer-to-class.html)|指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。|
|[C++ 类的静态成员](http://www.runoob.com/cplusplus/cpp-static-members.html)|类的数据成员和函数成员都可以被声明为静态的。|

# 类成员函数

类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员

成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 ::** 来定义。在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。

```cpp
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度  
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
```

 也可以在类的外部使用**范围解析运算符 ::** 定义该函数

```cpp
double Box::getVolume(void)
{
    return length * breadth * height;
}
```

在这里，需要强调一点，在 :: 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（**.**），这样它就能操作与该对象相关的数据

**注：**

:: 叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。

:: 可以不跟类名，表示全局数据或全局函数（即非成员函数）。

# 类访问修饰符

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。关键字 public、private、protected 称为访问修饰符。

一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。

## 私有（private）成员

**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。

## 保护（protected）成员

**保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

# 类构造函数 & 析构函数

## 类的构造函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

**构造函数的名称与类的名称是完全相同的**，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

[http://www.runoob.com/cplusplus/cpp-constructor-destructor.html](http://www.runoob.com/cplusplus/cpp-constructor-destructor.html)

默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值

也可以使用初始化列表来初始化字段

## 类的析构函数

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

**析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀**，它不会返回任何值，也不能带有任何参数。

析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

#  拷贝构造函数

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：
- 
一个对象以值传递的方式传入函数体

- 
一个对象以值传递的方式从函数返回

- 
一个对象需要通过另外一个对象进行初始化


如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

# 友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。

尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**

比如声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：
`friend class ClassTwo;`
# 内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：
- 1.在内联函数内不允许使用循环语句和开关语句；
- 2.内联函数的定义必须出现在内联函数第一次调用之前；
- 3.类结构中所在的类说明内部定义的函数是内联函数。

# 指向类的指针

一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

# 类的静态成员

我们可以使用 **static** 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

> 
**静态成员函数与普通成员函数的区别：**
- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
- 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。


静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。

# 继承

面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

## 基类 & 派生类

一个类可以派生自多个类，这意味着，它可以从多个基类继承**数据和函数**。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名

一个派生类继承了所有的基类方法，但下列情况除外：
- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

## 继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：
- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

## 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：

```
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```



# 重载运算符和重载函数

C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。

## C++ 中的函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。

## C++ 中的运算符重载

您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

# 多态

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 **virtual。**

## 虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

## 纯虚函数

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

2、虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错，错误提示为：
`error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"`
3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。

8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

# 文件和流

到目前为止，我们已经使用了 **iostream** 标准库，它提供了 **cin** 和 **cout** 方法分别用于从标准输入读取流和向标准输出写入流。

本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：
|数据类型|描述|
|----|----|
|ofstream|该数据类型表示输出文件流，用于创建文件并向文件写入信息。|
|ifstream|该数据类型表示输入文件流，用于从文件读取信息。|
|fstream|该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。|

要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。



## 打开文件

在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。

下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
`void open(const char *filename, ios::openmode mode);`
在这里，**open()** 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。
|模式标志|描述|
|----|----|
|ios::app|追加模式。所有写入都追加到文件末尾。|
|ios::ate|文件打开后定位到文件末尾。|
|ios::in|打开文件用于读取。|
|ios::out|打开文件用于写入。|
|ios::trunc|如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。|

您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：

```
ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );
```

# 动态内存

了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：
- **栈：**在函数内部声明的所有变量都将占用栈内存。
- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。

很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。

如果您不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。

## new 和 delete 运算符

下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：
`new data-type;`
在这里，**data-type** 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 **new** 运算符来完成这点：

```cpp
double* pvalue  = NULL; // 初始化为 null 的指针
pvalue  = new double;   // 为变量请求内存
```

**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。

在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：
`delete pvalue;        // 释放 pvalue 所指向的内存`
# 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。

每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 **vector <int>** 或 **vector <string>**。

您可以使用模板来定义函数和类。

## 函数模板

模板函数定义的一般形式如下所示：

```cpp
template <class type> ret-type func-name(parameter list)
{
   // 函数的主体
}
```

在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。

## 类模板

正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：
`template <class type> class class-name {}`
在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。

# 预处理器

预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。

所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。

我们已经看到，之前所有的实例中都有 **#include** 指令。这个宏用于把头文件包含到源文件中。

C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。

## #define 预处理

#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**，指令的一般形式是：
`#define macro-name replacement-text `
当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。

## 参数宏

您可以使用 #define 来定义一个带有参数的宏

#define MIN(a,b) (a<b ? a : b)

## 条件编译

有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。

条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：

```
#ifndef NULL
   #define NULL 0
#endif
```

在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。

使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。

## # 和 ## 运算符

# 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。

## C++ 中的预定义宏

C++ 提供了下表所示的一些预定义宏：
|宏|描述|
|----|----|
|__LINE__|这会在程序编译时包含当前行号。|
|__FILE__|这会在程序编译时包含当前文件名。|
|__DATE__|这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。|
|__TIME__|这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。|







 标准库中的顺序容器包括：

         (1)、vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。

         (2)、deque：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。

         (3)、list：双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。

         (4)、forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。

         (5)、array：固定大小数组。支持快速随机访问。不能添加或删除元素。

         (6)、string：与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。




原文链接：[http://www.runoob.com/cplusplus/cpp-tutorial.html](http://www.runoob.com/cplusplus/cpp-tutorial.html)



