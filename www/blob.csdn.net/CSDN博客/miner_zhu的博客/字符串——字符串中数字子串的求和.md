# 字符串——字符串中数字子串的求和 - miner_zhu的博客 - CSDN博客





2018年07月22日 09:53:53[miner_zhu](https://me.csdn.net/miner_zhu)阅读数：129








**【题目】**

　　给定一个字符串str，求其中全部数字串所代表的数字之和。要求如下：
- 忽略小数点字符，例如“A1.3”，其中包含两个数字1和3.
- 如果紧贴数字子串的左侧出现字符“-”，当连续出现的数量为奇数时，则数字视为负，连续出现的数量为偶数时，则数字视为正。例如，“A-1BC- -12”，其中包含数字-1和12。

**【举例】**

　　str = “A1CD2E33”返回36. 

　　str = “A-1B- -2C- -D6E”，返回7。

**【基本思路】**
- 
使用三个变量。res，num和posi。res表示目前的累加和，num表示当前收集到的数字，posi表示数字num是正数还是负数，True表示正数，初始时res = 0, num = 0, posi = True。

- 
从左到右依次遍历字符串，假设遍历到的字符为char。情况分析如下：

1）如果char是 ‘0’ ~ ‘9’，假设之前收集的数字为num，则可以根据posi更新num的值，如果posi == True，则num = num×10 + (char - ‘0’)，否则num = num×10 - (char - ‘0’)。posi的更新方法之后解释。

2）如果char不是 ‘0’ ~ ‘9’，则说明num已经是一个完整的数字了，该累加到res了，所以res += num，然后令num = 0。累加完后观察此时char的值，如果此时的字符不是“-”，则令posi = True，如果此时的字符为“-”，判断前一个字符是否也是“-”，如果是的话，令 posi = ！posi，否则令posi = False。

- 
既然我们把累加的时机放在了char不是数字字符的时候，那么如果str是以数字字符结尾的，那么就会出现最后一个字符没有累加的情况。所以遍历完成后，还要再加一次num。


时间复杂度o（n），空间复杂度o（1）

```python
def numSum(str1):
	if str1 == None or len(str1) == 0:
		return Flase
	res = 0 #总和
	num = 0 #当前值
	cur = 0 #当前字符
	posi = Ture
	for i in range(len(str1)):
		cur = ord(str(i)) -  ord('0')
		if cur < '0' or cur > '9':
			res += num
			num = 0
			if str1[i] = '-':
				if i-1 >= 0 and str1[i-1] == '-':
					posi = not posi
				else:
					posi = Flase
			else:
				posi = Ture
		else:
			num = num *10 + cur if posi else -cur #posi为TUre时取cur，否则取-cur
	res += num
	return res
```





