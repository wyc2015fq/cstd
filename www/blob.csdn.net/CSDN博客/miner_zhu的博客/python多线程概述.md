# python多线程概述 - miner_zhu的博客 - CSDN博客





2018年07月22日 17:22:35[miner_zhu](https://me.csdn.net/miner_zhu)阅读数：23标签：[python																[多线程](https://so.csdn.net/so/search/s.do?q=多线程&t=blog)](https://so.csdn.net/so/search/s.do?q=python&t=blog)
个人分类：[python笔记](https://blog.csdn.net/miner_zhu/article/category/7809048)








### 一、进程与线程关系

•    进程：

•   正在运行的程序，是系统进行资源分配和调用的独立单位。

•   每一个进程都有它自己的内存空间和系统资源。

•    线程：

•   是进程中的单个顺序控制流，是一条执行路径

•   一个进程如果只有一条执行路径，则称为单线程程序。

•   一个进程如果有多条执行路径，则称为多线程程序。

### 二、线程基础

1、线程的状态

线程有5种状态，状态转换的过程如下图所示：

![线程状态](https://img-blog.csdn.net/20160811153901628)

2、线程同步（锁）

多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。

锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。

线程与锁的交互如下图所示：

![线程与锁](https://img-blog.csdn.net/20160811154043754)

3、线程通信（条件变量）

然而还有另外一种尴尬的情况：列表并不是一开始就有的；而是通过线程”create”创建的。如果”set”或者”print” 在”create”还没有运行的时候就访问列表，将会出现一个异常。使用锁可以解决这个问题，但是”set”和”print”将需要一个无限循环——他们不知道”create”什么时候会运行，让”create”在运行后通知”set”和”print”显然是一个更好的解决方案。于是，引入了条件变量。

条件变量允许线程比如”set”和”print”在条件不满足的时候（列表为None时）等待，等到条件满足的时候（列表已经创建）发出一个通知，告诉”set” 和”print”条件已经有了，你们该起床干活了；然后”set”和”print”才继续运行。

线程与条件变量的交互如下图所示：

![需要条件的线程](https://img-blog.csdn.net/20160811154152848)

![创造条件的线程](https://img-blog.csdn.net/20160811154224629)

4、线程运行和阻塞的状态转换

最后看看线程运行和阻塞状态的转换

![线程运行与阻塞状态转换](https://img-blog.csdn.net/20160811154412306)

**阻塞有三种情况：**

同步阻塞（锁定池）是指处于竞争锁定的状态，线程请求锁定时将进入这个状态，一旦成功获得锁定又恢复到运行状态； 

等待阻塞（等待池）是指等待其他线程通知的状态，线程获得条件锁定后，调用“等待”将进入这个状态，一旦其他线程发出通知，线程将进入同步阻塞状态，再次竞争条件锁定； 

而其他阻塞是指调用time.sleep()、anotherthread.join()或等待IO时的阻塞，这个状态下线程不会释放已获得的锁定。

tips: 如果能理解这些内容，接下来的主题将是非常轻松的；并且，这些内容在大部分流行的编程语言里都是一样的。（意思就是非看懂不可 >_< 嫌作者水平低找别人的教程也要看懂）




