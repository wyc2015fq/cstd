# 《Linux内核设计与实现》——块I/O层 - 一世豁然的专栏 - CSDN博客





2014年11月26日 11:15:53[一世豁然](https://me.csdn.net/Explorer_day)阅读数：805








一、概论

  1、系统中能够随机（不需要按顺序）访问固定大小数据片的硬件设备称作块设备，这些固定大小的数据片就称作快。




  2、如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；相反吗如果一个设备是随机访问，那么它就属于块设备。




  3、内存管理快设备要比管理字符设备细致得多，需要考虑的问题和完成的工作相对于字符设备来说要复杂得多。







二、剖析一个块设备

  1、块设备中最小的可寻址单元是扇区。扇区大小一般是2的整数倍，而最常见的是512字节。




  2、各种不同用途的软件都会用到自己的最小逻辑可寻址单元——块。块是文件系统的一种抽象——只能基于块来访问文件系统。




  3、扇区——设备最小寻址单元，有时会称作“硬扇区”或“设备块”。同样的，块——文件系统最小寻址单元，有时会被称作“文件快”或“I/O块”。




  4、扇区和缓冲区之间的关系。








三、缓冲区和缓冲区头

  1、当一个块被调入内存时，它要存储一个缓冲区职工。每个缓冲区与一个块对应，它相当于是磁盘在内存中的表示。




  2、缓冲区描述符用**buffer_head结构体**表示，称作缓冲区头，在文件<linux/buffer_head.h>中定义，它包含了内核操作缓冲区所需要的全部信息。




  3、缓冲区头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。此结构体在内核中只扮演了一个描述符的角色，说明从缓冲区到块的映射关系。




  4、将缓冲区头作为I/O操作单元有有两个弊端：

    1）、缓冲区头是一个很大且不易控制的数据结构体，而且缓冲区头对数据的操作即不方便也不清晰。

    2）、缓冲区头仅能描述整个缓冲区，当作为所有的I/O的容器使用时，缓冲区头会促使内核把对大块数据的I/O操作分解为对多个buffer_head结构体进行操作。这样做必定会

              造成不必要的负担和空间浪费。










四、bio结构体

 一）、相关简介

  1、内核中块I/O操作的基本容器由bio结构体表示，它定义在文件<linux/bio.h>中。该结构体代表了正在现场的以片段链表形式组织的块I/O操作。




  2、**bio结构体**定义于<linux/bio.h>中。




  3、bio结构体、bio_vec结构体和page结构体之间的关系。







 二）、I/O向量

  1、bi_io_vec域指向一个bio_vec结构体数组，该结构体表包含了一个特定的I/O操作所需要使用到的所有片段。每个bio_vec结构都是一个形式为<page,  offsef,  len>的向量，

         它描述的是一个特定的片段：片段所在的物理页、块在物理页中的偏移位置、从给定偏移量来时的块长度。




  2、**bio_vec结构**定义在<linux/bio.h>中。







 三）、新老方法的对比

  1、bio结构体代表的是I/O操作，它可以包括内存中的一个或多个页；而另一方面，buffer_head结构体代表的是一个缓冲区，它描述的仅仅是磁盘中的一个块。




  2、利用bio结构体代替buffer_head接哦古提的好处。








 五、请求队列

  1、块设备将它们挂起的块I/O请求保存在请求队列中，该队列由reques_queue结构体表示，定义在文件<linux/blkdev.h>中，包含一个双向请求链表以及相关控制信息。




  2、队列中的请求由结构体request表示，它定义在文件<linux/blkdev.h>中。因为一个请求可能要操作多个连续的磁盘，所以每个请求可以由多个bio结构体组成。







六、I/O调度程序

 一）、相关简介


  1、为了优化寻址操作，内核不会简单的按请求接受次序，也不会立即将其提交给磁盘。相反，它会在提交前，先执行名为合并与排序的预操作，这种预操作可以极大的提高系

        统的整体性能。




 二）、I/O调度程序的工作

  1、I/O调度程序的工作是管理块设备的请求队列。它决定队列中的请求排列顺序以及在什么时刻派发请求道块设备。




  2、I/O调度程序通过两个方法减少磁盘寻址的时间：合并和排序。合并是指将两个或多个结合成一个新请求。




 三）、Linus电梯

  1、I/O调度程序：Linus电梯。



  2、Linus电梯能执行合并与排序处理。




 四）、最终期限I/O调度程序

  1、最终期限I/O调度程序是为了解决Linus电梯所带来的饥饿问题而提出的。




  3、减少请求饥饿必须降低全局吞吐量为代价。




  3、最后I/O调度程序中，每个请求都有一个超时时间。默认情况下，读请求的超时时间是500ms，写请求的超时时间是5s。




 五）、预测I/O调度程序

  1、预测I/O调度程序的目标就饿时在保持良好的读相应的同时也能提供良好的全局变量。




  2、预测I/O调度的基础仍然是最后期限I/O调度程序。预测I/O调度程序也实现了三个队列，并为每个请求设置了超时时间。预测I/O调度程序最主要的改进是它添加了预测启发能

         力。




 六）、完全公正的排队I/O调度程序

  1、完全公正的排队I/O调度程序是为专有工作负荷设计的。




  2、完全公正的排队I/O调度程序以时间片轮转调度队列，从每个队列中选取请求数，然后进行下一轮调度。




七）、空操作的I/O调度程序

  1、空操作的I/O调度程序基本上是一个空操作且不进行排序，或者也不进行什么其他形式的预寻址操作。不过空操作的I/O调度程序执行合并。




 八）、I/O调度程序的选择（P245  表14-2）




