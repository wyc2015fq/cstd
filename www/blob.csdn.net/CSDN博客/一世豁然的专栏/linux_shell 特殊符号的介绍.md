# linux_shell 特殊符号的介绍 - 一世豁然的专栏 - CSDN博客





2015年04月01日 16:32:09[一世豁然](https://me.csdn.net/Explorer_day)阅读数：534










本博客转载于：[http://blog.chinaunix.net/uid-24485075-id-2981715.html](http://blog.chinaunix.net/uid-24485075-id-2981715.html)


linux_shell 特殊符号的介绍

＃：注释，行首以＃开头为注释

                    标准的引用和转义字符（" '/） 可以用来转义＃

;       命令分隔符,可以用来在一行中来写多个命令

eg：

  cd ~/backup ; mkdir startup ; cp ~/.* startup/.




;;      终止case选项

.       .命令等价于source命令

.       .作为文件名的一部分。如果作为文件名的前缀的话，那么这个文件将成为隐藏文件。将不为ls列出

.       .作为正则表达式的一部分，用来匹配任何的单个字符

"        部分引用."STRING"阻止了一部分特殊字符。

'        全引用.'STRING'阻止了全部特殊字符

,        逗号链接了一些列的算诉操作系列的算术操作，虽然里边所有的内容都被运行了，但只有最后一项被返回。

/       转义字符，如/X等价于"X"

/       文件名路径分

"        部分引用."STRING"阻止了一部分特殊字符。

'        全引用.'STRIN割符，或用来做除法操作.

`        

     ,   逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被

         返回.

         如:

         1 let "t2 = ((a = 9, 15 / 3))" # Set "a = 9" and "t2 = 15 / 3"

     /   转义字符,如/X 等价于"X"或'X',具体见第 5 章.

     /   文件名路径分隔符.或用来做除法操作.

     `   后置引用,命令替换,具体见第 14 章

     :   空命令,等价于"NOP"(no op,一个什么也不干的命令).也可以被认为与 shell 的内建命令

         (true)作用相同.":"命令是一个 bash 的内建命令,它的返回值为 0,就是 shell 返回的 true.



!     取反操作符,将反转"退出状态"结果,(见 Example 6-2).也会反转 test 操作符的意义.比

      如修改=为!=.!操作是 Bash 的一个关键字.

*     万能匹配字符,用于文件名匹配(这个东西有个专有名词叫 file globbing),或者是正则

      表达式中.注意:在正则表达式匹配中的作用和在文件名匹配中的作用是不同的.



*     数学乘法.

      **是幂运算.


    eg： 

    let "sus=2**3"

    echo "sus = $sus"

    $ sus = 8 -





?     测试操作.在一个确定的表达式中,用?来测试结果.

      (())结构可以用来做数学计算或者是写 c 代码,那?就是 c 语言的 3 元操作符的

      一个.

      在"参数替换"中,?测试一个变量是否被 set 了.

?     在 file globbing 中和在正则表达式中一样匹配任意的单个字符.

$     变量替换

$     在正则表达式中作为行结束符.

${}   参数替换

$*,$@ 位置参数


   $@ 列出所有的参数，各参数用空格隔开

   $*: 列出所有的参数，各参数用环境变量IFS的第一个字符隔开


$?    退出状态变量.$?保存一个命令/一个函数或者脚本本身的退出状态.

$$    进程 ID 变量.这个$$变量保存运行脚本进程 ID

()    命令组.如:

      1 (a=hello;echo $a)

      注意:在()中的命令列表,将作为一个子 shell 来运行.

      在()中的变量,由于是在子 shell 中,所以对于脚本剩下的部分是不可用的.

      如:

              1  a=123

              2  ( a=321; )

              3

              4  echo "a = $a"       # a = 123

              5  # 在圆括号中 a 变量,更像是一个局部变量.

              用在数组初始化, 如:

              1 Array=(element1,element2,element3)

     {xxx,yyy,zzz...}

              大括号扩展, 如:

              1 cat {file1,file2,file3} > combined_file

              2 # 把 file1,file2,file3 连接在一起,并且重定向到 combined_file 中.

              3

              4

              5 cp file22.{txt,backup}

              6 # 拷贝"file22.txt" 到"file22.backup" 中

              一个命令可能会对大括号中的以逗号分割的文件列表起作用[1]. file globbing 将对

              大括号中的文件名作扩展.

              注意: 在大括号中,不允许有空白,除非这个空白是有意义的.

              echo {file1,file2}/ :{/ A," B",' C'}

              file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

     {}       代码块.又被称为内部组.事实上,这个结构创建了一个匿名的函数.但是与函数不同的

              是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的. 如:

              bash$

              {

                    local a;

                    a= 123;

              }

              bash 中的 local 申请的变量只能够用在函数中.

              1 a=123

              2 { a=321; }

              3 echo "a = $a"        # a = 321      (说明在代码块中对变量 a 所作的修改,影响了外边的变

量 a)

              4

              5 # Thanks, S.C.



                注意: 与()中的命令不同的是,{}中的代码块将不能正常地开启一个新 shell.[2]

     {} /;      路径名.一般都在 find 命令中使用.这不是一个 shell 内建命令.

                注意: ";"用来结束 find 命令序列的-exec 选项.

     []          test.

                test 的表达式将在[] 中.

                值得注意的是[是 shell 内建 test 命令的一部分,并不是/usr/bin/test 中的扩展命令

                的一个连接.

     [[]] test.

                test 表达式放在[[]]中.(shell 关键字)

                具体查看[[]]结构的讨论.

     []          数组元素

                 Array[1]=slot_1

                 echo ${Array[1]}

     []          字符范围

                 在正则表达式中使用,作为字符匹配的一个范围

(()) 数学计算的扩展

       在(())结构中可以使用一些数字计算.

       具体参阅((...))结构.

>&>>&>><

       重定向.

       scriptname >filename 重定向脚本的输出到文件中.覆盖文件原有内容.

       command &>filename 重定向 stdout 和 stderr 到文件中

       command >&2 重定向 command 的 stdout 到 stderr

       scriptname >>filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件,

       则创建这个文件.

       进程替换,具体见"进程替换部分",跟命令替换极其类似.

       (command)>

       <(command)

       <和> 可用来做字符串比较

       <和> 可用在数学计算比较

<<     重定向,用在"here document"

<<<         重定向,用在"here string"

<,>    ASCII 比较

/<,/>  正则表达式中的单词边界. 如:

       bash$grep '/<the/>' textfile

|      管道.分析前边命令的输出,并将输出作为后边命令的输入.这是一种产生命令链的

       好方法.

       1 echo ls -l | sh

       2 # 传递"echo ls -l"的输出到 shell 中,

       3 #+ 与一个简单的"ls -l"结果相同.

                 4

                 5

                 6 cat *.lst | sort | uniq

                 7 # 合并和排序所有的".lst"文件,然后删除所有重复的行.

                管道是进程间通讯的一个典型办法,将一个进程的 stdout 放到另一个进程的 stdin 中.

                标准的方法是将一个一般命令的输出,比如 cat 或 echo,传递到一个过滤命令中(在这个

                过滤命令中将处理输入),得到结果, 如:

                cat $filename1 | $filename2 | grep $search_word

                当然输出的命令也可以传递到脚本中.如:

     >|         强制重定向(即使设置了 noclobber 选项--就是-C 选项).这将强制的覆盖一个现存文件.

     ||         或-逻辑操作.

     &       后台运行命令.一个命令后边跟一个&,将表示在后台运行.

     -          用于重定向 stdin 或 stdout.



               注意:以"-"开头的文件名在使用"-"作为重定向操作符的时候,可能会产生问题.

               应该写一个脚本来检查这个问题,并给这个文件加上合适的前缀. 如:

               ./-FILENAME, $PWD/-FILENAME,或$PATHNAME /-FILENAME.

               如果变量的值以"-"开头,可能也会引起问题.

               1 var="-n"

               2 echo $var

               3 #具有"echo -n"的效果了,这样什么都不会输出的.

     -         之前工作的目录."cd -"将回到之前的工作目录,具体请参考"$OLDPWD"环境变量.

               注意:一定要和之前讨论的重定向功能分开,但是只能依赖上下文区分.

     -         算术减号.

     =         算术等号,有时也用来比较字符串.

               1 a=28

               2 echo $a      # 28

     +         算术加号,也用在正则表达式中.

     +         选项,对于特定的命令来说使用"+"来打开特定的选项,用"-"来关闭特定的选项.

     %         算术取模运算.也用在正则表达式中.

  ~    home 目录.相当于$HOME 变量.

  ~+   当前工作目录,相当于$PWD 变量.

  ~-   之前的工作目录,相当于$OLDPWD 内部变量.

  =~  用于正则表达式,这个操作将在正则表达式匹配部分讲解,只有 version3 才支持.

  ^   行首,正则表达式中表示行首."^"定位到行首.





