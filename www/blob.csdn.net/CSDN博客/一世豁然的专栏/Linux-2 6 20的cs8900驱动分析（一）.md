# Linux-2.6.20的cs8900驱动分析（一） - 一世豁然的专栏 - CSDN博客





2015年07月15日 16:24:15[一世豁然](https://me.csdn.net/Explorer_day)阅读数：565








本博客转载于：[http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=22535114&id=1773574](http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=22535114&id=1773574)






**一、初始化阶段**

    网络初始化被调用的路径为：

init->do_basic_setup->do_initcalls->net_olddevs_init->ethif_probe2->probe_list2->cs89x0_probe->cs89x0_probe1

真是不容易啊，终于进到cs89x0_probe1了，在这里开始探测和初始化cs8900了。下面就按照这个顺序来说明网络驱动第一阶段的工作。注意：这里的调用顺序是将cs8900驱动编入内核所产生的，如果将cs8900驱动选为模块，这个路径：init->do_basic_setup->do_initcalls->net_olddevs_init->ethif_probe2->probe_list2也会执行。

**1.1 init函数**

我们知道当start_kernel函数完成后就会启动init进程执行，在真正的应用程序init进程（如busybox的/sbin/init）之前，Linux还需要执行一些初始化操作。init的代码可以在\init\main.c中找到，它的代码如下：

static int init(void * unused)

       {

               lock_kernel();

                ……                                                         //省略多cpu的初始化代码先

                do_basic_setup();                                   //我们所关注的初始化函数

                ……


        if (!ramdisk_execute_command)

                    ramdisk_execute_command = "/init";

      if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)    {

                     ramdisk_execute_command = NULL;

                     prepare_namespace();                                       //挂接根文件系统      

             }

             ……


free_initmem();                                                       //释放初始化代码的空间

       unlock_kernel();

……                                                                      //这几段没看懂



       if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0) //检查控制台console是否存在

              printk(KERN_WARNING "Warning: unable to open an initial console.\n");

……//这几段没看懂

       if (ramdisk_execute_command) {           //运行ramdisk_execute_command指定的init用户进程

              run_init_process(ramdisk_execute_command);

              printk(KERN_WARNING "Failed to execute %s\n",

                            ramdisk_execute_command);

       }

       ……

       if (execute_command) {       //判断在启动时是否指定了init参数，如果指定，此值将赋给execute_command

              run_init_process(execute_command);              //开始执行用户init进程，如果成功将不会返回。

              printk(KERN_WARNING "Failed to execute %s. Attempting "

                                   "defaults...\n", execute_command);

       }

//如果没有指定init启动参数，则查找下面的目录init进程，如果找到则不会返回

       run_init_process("/sbin/init");

       run_init_process("/etc/init");

       run_init_process("/bin/init");

       run_init_process("/bin/sh");

   //如果上面的程序都出错，则打印下面的信息，如果内核找到init进程，则程序不会指向到此处

       panic("No init found. Try passing init= option to kernel.");

}

**1.2 do_basic_setup函数**

在这里我们最关心的是do_basic_setup函数，顾名思义该函数的功能就是“做基本设置”，它的实现代码也在\init\main.c中。do_basic_setup()完成外设及其驱动程序的加载和初始化。该函数代码如下所示：

static void __init do_basic_setup(void)

{

       /* drivers will send hotplug events */

       init_workqueues();     //初始化工作队列

       usermodehelper_init(); //初始化khelper内核线程，还没弄清楚



       driver_init();           //初始化内核的设备管理架构需要的数据结构，很复杂，以后在谈这部分。



#ifdef CONFIG_SYSCTL

       sysctl_init();          //没搞懂

#endif

       do_initcalls();         //重点函数，初始化的主要工作就靠它了

}

**1.3 do_ initcalls函数**

       do_initcalls函数将会调用内核中所有的初始化函数，它的代码同样在\init\main.c中。do_initcalls函数调用其他初始化函数相当简洁，它的关键代码如下所示：

initcall_t *call;

for (call = __initcall_start; call < __initcall_end; call ) {

……

       result = (*call)();

……

｝

       简洁归简洁，但这段代码是什么意思呢？这说来就话长了，最重要的应该是先了解Linux处理初始化的大体思想，由于Linux有很多部分需要初始化，每个部分都有自己的初始化函数，如果按照常理一个一个的调用未免显得冗长，而且也不便于扩展。那么Linux是怎么处理的呢？首先，Linux将各个部分的初始化函数编译到一个块内存区中，当初始化完了以后释放这块内存区，这就是init函数中free_initmem所要做的事。然后，再在另外的内存区中存放一些函数指针，让每个指针指向一个初始化函数。然后在do_initcalls中依次根据这些指针调用初始化函数。

上面一段就是Linux实现初始化的大体思想，下面我们看看它最终是怎么实现的。首先要了解的是__define_initcall宏，该宏的定义在\ include\linux\init.h中，它的原型如下所示：

#define __define_initcall(level,fn,id) static initcall_t __initcall_##fn##id __attribute_used__ \

       __attribute__((__section__(".initcall" level ".init"))) = fn



__define_initcall宏有三个参数，level表示初始化函数的级别，level值的大小觉得了调用顺序，level越小越先被调用，fn就是具体的初始化函数，id简单标识初始化函数，现在还没找到有什么用^_^。__define_initcall的功能为，首先声明一个initcall_t类型的函数指针__initcall_##fn##id，initcall_t的原型为：

typedef int (*initcall_t)(void);

该类型可简单理解为函数指针类型^_^。然后，让该函数指针指向fn。最后，通过编译器的编译参数将此指针放到指定的空间".initcall" level ".init"中，__attribute_used向编译器说明这段代码有用，即使在没用到的时候，编译器也不会警告。__attribute__的__section__参数表示该段代码放入什么内存区域中，也即指定编译到什么地方，编译参数更详细的地方可以查阅GCC文档，在gcc官方网站[http://gcc.gnu.org/onlinedocs/](http://gcc.gnu.org/onlinedocs/)中能找到各个版本的手册。这样说来还是比较抽象，下面举个例子来说明：

       假如有初始化函数init_foolish函数，现在使用__define_initcall宏向内核加入该函数。假如调用方式如下：

__define_initcall("0",init_foolish,1)；

那么，__define_initcall宏首先申请一个initcall_t类型的函数指针__initcall_init_foolish1（注意替换关系），且使该指针指向了init_foolish，函数指针__initcall_init_foolish1被放到.initcall.0.init内存区域中，这个标志在连接时会用到。

       有了上面的基础知识，现在回到do_initcalls函数中，首先注意到是__initcall_start和__initcall_end，它们的作用就是界定了存放初始化函数指针区域的起始地址，也即从__initcall_start开始到__initcall_end结束的区域中存放了指向各个初始化函数的函数指针。换句话说，只要某段程序代码从__initcall_start开始依次调用函数指针，那么就可以完成各个部分的初始化工作，这显得十分优雅而且便于扩充，再看看do_initcalls，它何尝不是如此呢。这里还有一个有用的技巧就是__initcall_start和__initcall_end的原型是initcall_t型的数组，以后可以使用这种技巧^_^。

       现在我们知道了do_initcalls函数的实现原理，那么到底它调用了多少初始化函数呢？我们怎样才能知道呢？根据上面的分析，我们知道所有的初始化函数的指针都放在__initcall_start和__initcall_end区域期间，而函数指针与它指向的函数之间又有固定的关系，如上面的例子，初始化函数名为init_foolish，指向它的函数指针就是__initcall_init_foolish1，即在此函数加上前缀__initcall_和一个数字后缀，反之，从函数指针也可推出初始化函数名。有了这两个信息，我们就可以很方便的找个初始化函数。怎么找呢？？首先打开Linux完后产生的System.map文件，然后找到__initcall_start和__initcall_end字符串，你会发现它们之间有很多类似于__initcall_xxx1这样的符号，这些符号就是我们需要的函数指针了，这样就可推出初始化函数的名字。比如，我们这里需要的函数指针__initcall_net_olddevs_init6，按照上面的名字规则，很容易推出它所指向的初始化函数名字是net_olddevs_init。

       得到了初始化函数的名字又怎么样呢？又不知道它在哪个文件里，不要着急！请打开你的浏览器登陆[http://lxr.linux.no/ident](http://lxr.linux.no/ident)网站，然后选择Linux版本和架构，然后可以搜索我们想要的信息。比如我输入net_olddevs_init，然后我就会得到该函数所在文件的相关信息。






**1.4 net_olddevs_init函数**


       我们知道net_olddevs_init函数在do_initcalls函数中被调用并执行，那么它到底要做什么呢？看看实现代码就知道了，它的实现代码可以在\drivers\net\Space.c中找到。对于网络驱动部分的主要实现代码如下：


static int __init net_olddevs_init(void){  


……


       int num;


       for (num = 0; num < 8; num)


              ethif_probe2(num);


       ……


}


这段代码就不用讲解了吧，嘿嘿！就是调用了8次ethif_probe2，赶快去看看ethif_probe2长什么样子。

**1.5 ethif_probe2函数**


       先看看该函数的实现代码，该代码也在\drivers\net\Space.c文件中。


static void __init ethif_probe2(int unit)


{


       unsigned long base_addr = netdev_boot_base("eth", unit);   // 由于ethif_probe2被net_olddevs_init调用了8次，


                                          // 所以unit的值为0～7，也即在这里可以注册eth0～eth7八个网络设备


       if (base_addr == 1)


              return;



       (void)(    probe_list2(unit, m68k_probes, base_addr == 0) &&


              probe_list2(unit, eisa_probes, base_addr == 0) &&


              probe_list2(unit, mca_probes, base_addr == 0) &&


              probe_list2(unit, isa_probes, base_addr == 0) &&


              probe_list2(unit, parport_probes, base_addr == 0));


}


       该函数首先调用netdev_boot_base所给的设备是否已经向内核注册，如果已注册netdev_boot_base返回1，随后推出ethif_probe2。如果设备没注册，则又调用函数probe_list2四次，每次传递的传输不同，注意到每次传递的第二个参数不同，这个参数也是相当重要的，这里拿isa_probes参数为例说明，因为这个参数与cs89x0_probe有关，isa_probes的定义也在\drivers\net\Space.c中，它的样子形如：


static struct devprobe2 isa_probes[] __initdata = {


……


#ifdef CONFIG_SEEQ8005


       {seeq8005_probe, 0},


#endif


#ifdef CONFIG_CS89x0


     {cs89x0_probe, 0},


#endif


#ifdef CONFIG_AT1700


       {at1700_probe, 0},


#endif


       {NULL, 0},


……


};


如果把cs8900的驱动选为非编译进内核，那么它的探测函数cs89x0_probe就不会存在于isa_probes数组中，所以在初始阶段就不能被调用。从上面的代码可以知道devprobe2类型至少包括两个域，至少一个域为函数指针，看看它的原型如下：


struct devprobe2 {


       struct net_device *(*probe)(int unit);                         //函数指针，指向探测函数


       int status;       /* non-zero if autoprobe has failed */


};


下面看看probe_list2函数是怎么表演的。

**1.6 ethif_probe2函数**


       对于ethif_probe2函数也没有什么需要说明的，它的主要任务是依次调用devprobe2类型的probe域指向的函数。他的实现代码同样在\drivers\net\Space.c中，它的关键代码如下：


static int __init probe_list2(int unit, struct devprobe2 *p, int autoprobe)


{


       struct net_device *dev;


       for (; p->probe; p ) {


           ……


              dev = p->probe(unit);


              ……


       }


……


}

**1.7 cs89x0_probe函数**


       从该函数起，真正开始执行与cs8900驱动初始化程序，该函数在\drivers\net\cs89x0.c文件实现。下面依次解释该函数。




struct net_device * __init cs89x0_probe(int unit)


{


       struct net_device *dev = alloc_etherdev(sizeof(struct net_local)); //该函数申请一个net_device＋


//sizeof(struct net_local)的空间，net_local是cs8900驱动的私有数据空间。


       unsigned *port;


       int err = 0;


       int irq;


       int io;




       if (!dev)


              return ERR_PTR(-ENODEV);


       sprintf(dev->name, "eth%d", unit);                 //初始化dev->name域


       netdev_boot_setup_check(dev);                  //检查是否给定了启动参数，如果给定了启动参数，此函数将初始


//化dev的irq、base_addr、mem_start和mem_end域。


       io = dev->base_addr;                                 //io实际实质cs8900所占地址空间的起始地址，此地址为虚拟地址


       irq = dev->irq;




       if (net_debug)


              printk("cs89x0:cs89x0_probe(0x%x)\n", io);


//下面根据io的值调用cs89x0_probe1函数


       if (io > 0x1ff) {/* Check a single specified location. *///此段没搞懂，由于没给启动参数，这里也不会执行


       err = cs89x0_probe1(dev, io, 0);


       } else if (io != 0) { /* Don''''''''''''''''''''''''''''''''t probe at all. */


              err = -ENXIO;


       } else {


              for (port = netcard_portlist; *port; port ) {// netcard_portlist为unsigned int型数组，在cs89x0.c文件中定


//义，里面列出了cs8900可能占用空间的起始地址，这些地址


//将在cs89x0_probe1函数中用于向内核申请。


                     if (cs89x0_probe1(dev, *port, 0) == 0) // cs89x0_probe1探测成功就返回0


                            break;


                     dev->irq = irq;


              }


              if (!*port)


                     err = -ENODEV;


       }


       if (err)


              goto out;


       return dev;


out:


       free_netdev(dev);   //表示探测失败，这里就释放dev的空间，随后打印些消息


       printk(KERN_WARNING "cs89x0: no cs8900 or cs8920 detected. Be sure to disable PnP with SETUP\n");


       return ERR_PTR(err);


}
从上面的程序清单可以看到该函数还没有真正的开始探测cs8900，实质的探测工作是让cs89x0_probe1完成的。在解释cs89x0_probe1之前先提一下网络驱动程序中非常重要的一些函数。内核需要一个数据结构来管理或者描述每个网络驱动程序，这个数据类型就是struct
 net_device，该数据类型包括很多域，详细的解释可以参见《Linux 设备驱动程序》一书中的描述，也可以参见源代码（在\include\linux\netdevice.h中，源码中也有详细的注解）。内核为了编程方便特地实现了函数alloc_netdev来完成对net_device的空间分配。那么alloc_etherdev函数主要针对以太网在alloc_netdev基础上封装的一个函数，它除了申请net_device空间外，还会初始化net_device的相关域。




