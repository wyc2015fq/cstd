# 《Linux程序设计》——开发工具 - 一世豁然的专栏 - CSDN博客





2014年10月09日 15:49:13[一世豁然](https://me.csdn.net/Explorer_day)阅读数：757标签：[开发工具																[编程																[linux](https://so.csdn.net/so/search/s.do?q=linux&t=blog)
个人分类：[liunx应用编程](https://blog.csdn.net/Explorer_day/article/category/2276817)





一、多个源文件带来的问题

 1、对大型文件来说，编辑—编译—测试这一循环的周期将变长。如果仅改动了一个源文件，其他与之相关的都要从新编译。







二、make命令和makefile

 1、makefile的语法

   1）、makefile文件由一组依赖关系和规则组成。

   2）、make命令会会根据makefile文件来确定目标文件的创建顺序以及正确的规则调用顺序。




 2、make命令的选项和参数

   1）、make程序选项

     I、-k：让make命令在发现错误时任然继续执行，而不是在检测到第一个错误时就停下来。

     II、-n：让make命令输出将要执行的操作步骤，而不是真正执行这些操作。

    III、-f  <filename>：告诉make命令将那个文件作为makefile文件。

   2）、为了指示make命令创建一个特定的目标，可以把该目标的名字作为make命令额一个参数。如果不这么做，make命令将试图创建列在makefile文件中的第一个目标。

   3）、依赖关系

     I、依赖关系定义了最终应用程序里的每个文件与源文件之间的关系。

     II、makefile文件规则：先写目标的名称。然后紧跟着一个冒号，紧接着是空格或制表符tad，最后使用空格或制表符tab隔开的文件列表。

   4）、规则




 3、makefile文件中的注释（马克file文件的注释以#开头，一直延续到这一行结束）




 4、makefile文件中的宏


   1）、通过语句MACRONAME=value在makefile文件中定义宏，引用宏的方法是使用$（MACRONAME）或${MACRONAME}。

   2）、makefile文件中的宏常被用于设置编译器的选项。

   3）、常见的宏列（P323  表9-1）




 5、多个目标（P322-325代码）




 6、内置规则（P325-326代码）




 7、后缀和模式规则

   1）、增加后缀名规则：首先需要在makefile文件中增加一行语句，告诉make命令这个新的后缀名。然后既可以用这个新的后缀名来定义规则。

   2）、kmake使用特殊语法：.<old_suffix>.<new_suffix>:。




 8、用make管理函数库

   1）、函数库实际上就是文件，它们通常以.a为后缀名，在该文件中包含了一组目标文件。

   2）、用于管理函数库的语法是lib（file.o），它的含义是目标文件file.o是存储在函数库lib.a中的。make命令用一个内置规则来管理函数库，该规则的常见形式如下所示：

**.c.a：**

**                  &（cc） -c  $(CFLAGS)  $<**

**                  &（AR） -c  $(ARFLAGS)  $@  $*.o**

          I、第一条规则告诉它必须编译源文件以生成目标文件。

         II、第二条规则告诉它用ar命令将新的目标文件添加到函数库中。




 9、高级主题：makefile文件和子目录

   1）、把构成几个函数库的文件从主文件中分离出来，并将它们保存到一个子目录的方法

        I、在子目录中编写第二个makefile文件，它的作用是编译该子目录下的源文件，并将它们保存到一个函数中，然后将该库文件复制到上一级的主目录中。在主目录中的

            makefile文件包含一条用于制作函数库的规则，该规则会调用第二个makefile文件如下所示：

**  mylib.a：**

**                   （cd  mylibdirectory；$（MAKE））**


       II、在原来的马克file文件中添加一些宏。新添加的宏通过在我们已见过的宏的尾部追加一个字母得到，字母D代表目录，字母F代表文件名。然后你就可以用下面的规则来替

            换内置的.c.o后缀规则：


** .c.o：**

**                     $(CC)  $(CFLAGS)  -c  $(@D)/$(<F)  -o  $(@D)/$(@F)**

            这条规则的作用是：编译子目录中的源文件并将目标文件放置在该子目录中。然后用如下到的依赖关系和规则来更新当前目录下的函数库：

**  mylib.a：  mydir/2.o  mydir/3.o**

**                     ar  -rv  mylib.a  $?**




 10、GNU make和gcc







三、源代码控制

 1、RCS（版本控制系统）

   1）、RCS  能够跟踪并记录下源文件的每一次改动，并将这些改动都记录在一个文件中，该文件中记录的改动信息足够详细，你可以·通过这些信息重建出任何一个以前的版

             本。

   2）、RCS命令：

       I、rcs（初始化RCS控制文件）

       II、ci（将源文件的当前版本“签入”到RCS中）

      III、co（如果想修改文件，必须首先“签出”该文件：如果只是想阅读该文件，可以用co命令重建当前版本的该文件并将它的权限改为只读：如果想对其进行修改，必须用命令

             co  -l锁住该文件0。）

      IV、rlog（查看一个文件改动摘要）

       V、rcsdiff（了解两个版本之间的区别）

      VI、版本标识（RCS系统可以在源文件中使用一些特殊的字符串（宏）来帮助跟踪文件所做的改动。最常用的两个宏是**$RCSfile$**和**$Id$**。宏$RCSfile$将扩展为该文件的名

             字，而$Id$将扩展为一个标识版本号的字符串。）

      VII、ident（查找包含$Id$字符串的文件的版本）




 2、SCCS（源代码控制系统）




 3、RCS和SCCS的比较（P337  表9-2）




 4、CVS（并发版本控制系统）

   1）、CVS的本地使用（P337-P340例程）

   2）、跨网络访问CVS（P340）




 5、CVS的前端程序（WinCVS）




 6、Subversion







四、编写手册页（P342-P345）







五、发行软件（P345-P348）







六、RPM软件包（P349-P258）




七、开发环境

 1、KDevelop

 2、其他开发环境（P360  表9-6）](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=开发工具&t=blog)




