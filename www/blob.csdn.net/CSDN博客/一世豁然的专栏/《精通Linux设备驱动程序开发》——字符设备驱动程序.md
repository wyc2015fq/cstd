# 《精通Linux设备驱动程序开发》——字符设备驱动程序 - 一世豁然的专栏 - CSDN博客





2014年11月06日 14:57:20[一世豁然](https://me.csdn.net/Explorer_day)阅读数：784








一、字符设备驱动程序基础

 1、得到相应驱动程序的标识符（ls  -l  /dev）




 2、字符设备驱动程序内容

   1）、初始化例程例程()，负责初始化设备并将驱动程序和内核的其他部分通过注册函数实现无缝连接。

   2）、入口函数（或方法）集，如open()、read()、ioctl，这些函数直接对应相应的I/O系统调用，由用户应用程序通过对应的/dev节点调用。

   3）、中断例程，底半步例程，定时器处理例程，内核辅助线程以及其他的组成部分。




 3、从数据流角度看，字符设备驱动程序包含如下数据结构

   1）、与特定设备有关的数据结构。此结构保存着驱动程序使用的信息。

   2）、struct  file_operations，包括所有设备驱动程序入口函数的地址。

   3）、struct  cdev，针对字符设备驱动程序的内核抽象。此结构通常嵌入在前面讨论的特定设备结构中。

   4）、struct  file，包括关联/dev节点的信息。







二、设备实例：系统CMOS

 1、系统CMOS相关简介

   1）、在PC兼容的硬件上的BIOS使用CMOS存储系统信息。

   2）、借助CMOS驱动车程序，可以像访问普通文件一样访问两个两个PC  CMOS存储体。




 2、通过两个I/O地址（一个索引寄存器和一个数据寄存器）访问CMOS。（表5-1）

   1）、必须在索引寄存器中指定准备访问的CMOS存储器的偏移，并通过庶几乎寄存器来交换数据。




 3、驱动程序初始化

   1）、init()函数是注册机制的基础。他负责完成如下工作：

      I、申请分配主设备号。

      II、为特定设备相关的数据结构分配内存。

      III、将入口函数与字符驱动程序的cdev抽象相关联。

      IV、将主设备号与驱动程序的cdev相关联。

      V、在/dev和/sys下创建节点。

      VI、初始化硬件。

   2）CMOS驱动程序初始化（代码清单5-1）

      I、代码清单5-1解读（略）




 4、打开与释放

   1）、当应用程序打开设备节点时，内核调用相应函数驱动程序的open（）函数。当应用程序关闭一个已经打开的设备时，内核调用release()函数。

   2）、打开与释放（代码清单5-2）

      I、代码清单5-1解读（略）




 5、数据释放

   1）、read()和write()是负责在用户空间和设备之间交换数据的主要字符驱动函数。扩展的read()/write()函数系列包括其他几个函数：fsync()、aio_read、aio_write()和

             mmap()。

   2）、数据释放（代码清单5-3）

     I、代码清单5-3解读（略）




 6、查找

   1）、内核使用内部指针跟踪当前文件访问的位置。应用程序使用lseek()系统调用去申请内部文件指针的重定位。

   2）、使用lseek()服务，可以讲文件指针重设置文件内的任一偏移位置。

   3）、字符驱动程序相对应的lseek(0是llseek()函数。

   4）、查找（代码清单5-4）

     I、代码清单5-4解读（略）




 7、控制

   1）、字符设备驱动函数：I/O控制（ioctl）。

   2）、I/O控制（代码清单5-5）

      I、代码清单5-5解读。







三、检测数据是否可获得

 1、两个能够感知数据是否可获得的字符驱动程序方法：poll()和fasync()。前者是同步的，后者是异步的。




 2、轮询

   1）、X  Window服务器相关代码。

   2）、鼠标驱动程序的poll(0方法。





 3、Fasync

   1）、异步通知实例代码。

   2）、驱动程序通知链的实现机制实例代码。







四、和并行端口交互

 1、并行端口是在PC兼容系统上常见的25针接口。并行端口的能力（是单向还是双向、是否支持DMA等）取决于芯片组。




 2、打印机驱动程序实例

   1）、并行端口LED电路板驱动程序（led.c）

   2）、使用sysfs控制并行端口LED板






五、RTC子系统

 1、内核中队RTC的支持分两层：硬件无关的顶层字符驱动程序，用于实现内核的RTCAPI硬件相关的底层驱动程序，用于和底层的总线通信。




 2、内核中的RTC子系统

   1）、提供了顶层的字符驱动程序，并给出了用于顶层和底层RTC驱动程序进行捆绑的核心基础结构，核心基础结构的主要组成部分是rtc_class_ops结构和注册函数

             rtc_device_[register|unregister]()。

   2）、可以拥有不止一个一个RTC。他通过提供多个/dev/rtcN和/sys/class/rtc/rtcN接口实现此功能，其中N是RTC在系统上的序号。







六、伪字符驱动

 1、null设备、zero设备和内核随机数产生器没有和任何物理硬件相连接，它们被当作虚拟设备，并使用伪字符设备驱动程序来访问。




 2、dev/null字符设备接受你不想显示在屏幕上的数据。




 3、dev/zero用0来填充一个图像文件。




 4、内核有一个内部的随机数发生器：

   1）、但内核用户希望使用随机序列时，随机数发生器提供API。

   2）、对于用户模式程序，它提供两个字符接口：/dev/random和/dev/unrandom。

   3）、从/dev/random读取的随机数的随机性要高于dev/unrandom。




 5、/dev/mem和/dev/kmem是典型的伪字符设备，它提供了擦好看系统内存的工具。







七、混杂驱动程序

 1、混杂驱动程序是那些简单的字符驱动程序，它们拥有一些相同的特征：

   1）、内核将这些共同性抽象只至一个API中。，其简化了这些驱动程序初始化的方式。

   2）、所有的混杂设备都被分配一个主设备号10，但每个设备可选择一个单独的次设备号。




 2、设备实例：看门狗定时器

   1）、看门狗的功能是是将失去的系统重新设置成可操作状态。

   2）、Linux看门狗驱动程序使用混杂驱动程序来实现，位于目录drivers/char/watchdog/目录。

   3）、看门狗驱动程序示例（代码清单5-8）

   4）、看门狗用户（代码清单5-9）

   5）、对于不支持硬件看门狗模块的平台，内核实现了一个软件看门狗（softdog）。







八、字符设备驱动程序注意事项




