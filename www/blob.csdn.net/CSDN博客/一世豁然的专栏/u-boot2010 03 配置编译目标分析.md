# u-boot2010.03 配置编译目标分析 - 一世豁然的专栏 - CSDN博客





2015年06月24日 22:51:24[一世豁然](https://me.csdn.net/Explorer_day)阅读数：489








本博客转载于：[http://blog.csdn.net/yyttiao/article/details/7899008](http://blog.csdn.net/yyttiao/article/details/7899008)




该系列教程会根据uboot的编译过程进程分析，如何编译，那么将会如何分析这些流程
此处我还没有增加6410的支持，先看6400 的过程，因为还没有到增加的地方，分析完整个流程之后，会写如何移植uboot到s3c6410的。知道了工作的流程，再去移植会事半功倍的。



拿到uboot首先会修改编译的目标：
make smdk6400_config

对执行如下的目标



**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- #########################################################################
- ## ARM1176 Systems
- #########################################################################
- smdk6400_noUSB_config   \  
- smdk6400_config :   unconfig  
-     @mkdir -p $(obj)include $(obj)board/samsung/smdk6400  
-     @mkdir -p $(obj)nand_spl/board/samsung/smdk6400  
-     @echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h  
-     @if [ -z "$(findstring smdk6400_noUSB_config,$@)" ]; then    \  
-         echo "RAM_TEXT = 0x57e00000" >> $(obj)board/samsung/smdk6400/config.tmp;\  
-         $(MKCONFIG) $(@:_config=) arm arm1176 smdk6400 samsung s3c64xx;  \  
- else     \  
-         echo "RAM_TEXT = 0xc7e00000" >> $(obj)board/samsung/smdk6400/config.tmp;\  
-         $(MKCONFIG) $(@:_noUSB_config=) arm arm1176 smdk6400 samsung s3c64xx;   \  
-     fi  
-     @echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk  


这里主要看的是如下2句



**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- echo "RAM_TEXT = 0x57e00000" >> $(obj)board/samsung/smdk6400/config.tmp;\  
- $(MKCONFIG) $(@:_config=) arm arm1176 smdk6400 samsung s3c64xx;  \  

首先会将RAM_TEXT = 0x57e00000 写入到$(obj)board/samsung/smdk6400/config.tmp 这个文件内
**$(obj)** 是目标的编译生成的路劲或者是当前UBOOT的目录，这就要看你有没有指定编译目录了

重点分析$(MKCONFIG) $(@:_config=) arm arm1176 smdk6400 samsung s3c64xx; \
会调用$(MKCONFIG) 而 MKCONFIG := $(SRCTREE)/mkconfig
也就是说最终会变成如下形式
**mkconfig smdk6400 arm arm1176 smdk6400 samsung s3c64xx**

下面就得进入mkconfig的代码内进行分析。。记录上面的参数，请大家打开对应的文件，一步步的看着然后分析



**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- #!/bin/sh -e
- 
- # Script to create header files and links to configure
- # U-Boot for a specific board.
- #
- # Parameters: Target Architecture CPU Board [VENDOR] [SOC]
- #
- # (C) 2002-2006 DENX Software Engineering, Wolfgang Denk <wd@denx.de>
- #

这里有一句说明了参数的意思Parameters: Target Architecture CPU Board [VENDOR] [SOC]
对应我们传递进来的参数看到为：
Parameters: 
1:Target = smdk6400 
2:Architecture = arm 
3:CPU = arm1176 
4:Board = smdk6400 
5:[VENDOR] = samsung 
6:[SOC] = s3c64xx




**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- APPEND=no   # Default: Create new config file  
- BOARD_NAME=""   # Name to print in make output  
- TARGETS=""
- 
- while [ $# -gt 0 ] ; do
- case"$1" in  
-         --) shift ; break ;;  
-         -a) shift ; APPEND=yes ;;  
-         -n) shift ; BOARD_NAME="${1%%_config}" ; shift ;;  
-         -t) shift ; TARGETS="`echo $1 | sed 's:_: :g'` ${TARGETS}" ; shift ;;  
-         *) break ;;  
-     esac  
- done  

这里显示没有没有特殊的标志，所以就不需要了



**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- [ "${BOARD_NAME}" ] || BOARD_NAME="$1"
- 
- [ $# -lt 4 ] && exit 1  
- [ $# -gt 6 ] && exit 1  
- 
- if [ "${ARCH}" -a "${ARCH}" != "$2" ]; then  
-     echo "Failed: \$ARCH=${ARCH}, should be '$2' for ${BOARD_NAME}" 1>&2  
-     exit 1  
- fi  
- 
- echo "Configuring for ${BOARD_NAME} board..."
- /*这句就是我们看到的配置信息了*/


下面开始创建针对目标平台的连接目录了。uboot是这么编译的，将选中的平台相关的文件夹，通过软连接的方式，到一个指定的目录
那么编译的时候，就只要去这个统一的指定目录下找，就能针对不同的平台编译了。具体看下下面的建立过程



**[cpp]**[view
 plain](http://blog.csdn.net/yyttiao/article/details/7899008#)[copy](http://blog.csdn.net/yyttiao/article/details/7899008#)



- #
- # Create link to architecture specific headers
- #
- /* 这里表示目标目录跟源码目录不一致，建立相应的目录，由于我没有指定目标目录，所以执行else部分 */
- if [ "$SRCTREE" != "$OBJTREE" ] ; then  
-     mkdir -p ${OBJTREE}/include  
-     mkdir -p ${OBJTREE}/include2  
-     cd ${OBJTREE}/include2  
-     rm -f asm  
-     ln -s ${SRCTREE}/include/asm-$2 asm  
-     LNPREFIX="../../include2/asm/"
-     cd ../include  
-     rm -rf asm-$2  
-     rm -f asm  
-     mkdir asm-$2  
-     ln -s asm-$2 asm  
- else
-     cd ./include  
- /* 删除asm目录 */
-     rm -f asm  
- /* 
-      * 建立asm指向对应的目录，根据我上面标的，$2就是 2:Architecture = arm 
-      * 所以这里就是 ln -s asm-arm asm
-      */
-     ln -s asm-$2 asm  
- fi  
- 
- /*
- * 这里开始建立arch目录，有了上面的asm目录建立，这里就简单多了
- * 删除 rm -f asm-arm/arch
- */
- rm -f asm-$2/arch  
- 
- if [ -z "$6" -o "$6" = "NULL" ] ; then  
-     ln -s ${LNPREFIX}arch-$3 asm-$2/arch  
- else
- /*
-      * ln -s arch-s3c64xx asm-arm/arch
-      */
-     ln -s ${LNPREFIX}arch-$6 asm-$2/arch  
- fi  
- 
- /* 如果是arm平台，需要多建立一个proc目录 */
- if [ "$2" = "arm" ] ; then  
-     rm -f asm-$2/proc  
-     ln -s ${LNPREFIX}proc-armv asm-$2/proc  
- fi  
- 
- #
- # Create include file for Make
- #
- /*
- * 这里为make编译的时候创建一些环境变量，写入到config.mk文件
- */
- echo "ARCH = $2" > config.mk  
- echo "CPU = $3" >> config.mk  
- echo "BOARD = $4" >> config.mk  
- 
- [ "$5" ] && [ "$5" != "NULL" ] && echo "VENDOR = $5" >> config.mk  
- 
- [ "$6" ] && [ "$6" != "NULL" ] && echo "SOC = $6" >> config.mk  
- 
- # Assign board directory to BOARDIR variable
- if [ -z "$5" -o "$5" = "NULL" ] ; then  
-     BOARDDIR=$4  
- else
-     BOARDDIR=$5/$4  
- fi  
- 
- #
- # Create board specific header file
- #
- /*
- * 开始创建特殊的头文件，被好多文件加载的
- * APPEND = no,于是创建了新的config.h
- */
- if [ "$APPEND" = "yes" ]    # Append to existing config file  
- then  
-     echo >> config.h  
- else
-     > config.h    # Create new config file  
- fi  
- 
- /* 写入如下信息到该新建的头文件内 */
- echo "/* Automatically generated - do not edit */" >>config.h  
- 
- for i in ${TARGETS} ; do
-     echo "#define CONFIG_MK_${i} 1" >>config.h ;  
- done  
- 
- cat << EOF >> config.h  
- #define CONFIG_BOARDDIR board/$BOARDDIR
- #include <config_defaults.h>
- /* 这里需要注意的是，$1 对应的是smdk6400 正好指定了 include/config/smdk6400.h 配置头文件，也就是为什么移植需要该这个头文件，否则找不到的原因 */
- #include <configs/$1.h>
- #include <asm/config.h>
- EOF  
- 
- exit 0  


整个配置过程就结束了。下面进行总结下

1：在Makefile中将RAM_TEXT = 0x57e00000 写入board/samsung/smdk6400/config.tmp 中
   这个地址在最终会变成 TEXT_BASE 可以在board/samsung/smdk6400/config.mk 中看到
   echo "RAM_TEXT = 0x57e00000" >> $(obj)board/samsung/smdk6400/config.tmp;\

2：创建软连接到目标生成的工作目录下，不指定就是在uboot的源码目录下
   ln -s asm-$2 asm
   ln -s ${LNPREFIX}arch-$6 asm-$2/arch
   ln -s ${LNPREFIX}proc-armv asm-$2/proc

3：创建config.mk 为编译指定一些变量
   echo "ARCH = $2" > config.mk
   echo "CPU = $3" >> config.mk
   echo "BOARD = $4" >> config.mk
   [ "$5" ] && [ "$5" != "NULL" ] && echo "VENDOR = $5" >> config.mk
   [ "$6" ] && [ "$6" != "NULL" ] && echo "SOC = $6" >> config.mk

4：创建头文件，指向配置的头文件 include/config.h
   cat << EOF >> config.h
   #define CONFIG_BOARDDIR board/$BOARDDIR
   #include <config_defaults.h>
   #include <configs/$1.h>
   #include <asm/config.h>
   EOF

完成.接着就是编译了.下次见~~



