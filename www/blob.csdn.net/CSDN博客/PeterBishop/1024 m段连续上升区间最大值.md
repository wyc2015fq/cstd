# 1024 m段连续上升区间最大值 - PeterBishop - CSDN博客





2019年03月04日 19:48:21[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：1862








个人感觉dp的维度就是说的要去遍历的方向，动态打表毕竟，可以先通过最暴力的方法找到递推式子或者举例找出规律，自顶而下去思考才是正道

```cpp
/* ***********************************************
Author        :PeterBishop
Created Time  :Mon 04 Mar 2019 18:29:12 CST
File Name     :test.cpp
Origin        :H D O J  1024
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;
const int MAXN=1000010;
const int INF=0x7fffffff;
int dp[MAXN];
int max_prev[MAXN];
int a[MAXN];
//第i组第j个数
//dp[i][j]=max(dp[i][j-1]+a[j],max(dp[i-1][k],0<=k<j)+a[j])
int main()
{
	//freopen("out.txt","w",stdout);
	freopen("in.txt","r",stdin);
    int m,n;
	int ans_max;
	while(scanf("%d%d",&m,&n)!=EOF){
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			dp[i]=0;
			max_prev[i]=0;
		}
		dp[0]=0;
		max_prev[0]=0;
		for(int i=1;i<=m;i++){
			ans_max=-INF;
			for(int j=i;j<=n;j++){
				dp[j]=max(dp[j-1]+a[j],max_prev[j-1]+a[j]);
				max_prev[j-1]=ans_max;
				ans_max=max(dp[j],ans_max);
			}
		}
		cout<<ans_max<<endl;
	} 
    return 0;
}
```





