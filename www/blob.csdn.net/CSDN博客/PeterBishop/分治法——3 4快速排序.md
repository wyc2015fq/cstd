# 分治法——3.4快速排序 - PeterBishop - CSDN博客





2018年08月24日 23:25:31[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：61








![](https://img-blog.csdn.net/20180824210149453?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/2018082421020449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/2018082421024095?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824210302322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```cpp
#include<iostream>
using namespace std;
int Partition(int r[], int low, int high)
{
	int i = low, j = high, pivot = r[low];
	while (i<j)
	{
		while (i<j&&r[j]>pivot)
			j--;
		if (i < j)
			swap(r[i++], r[j]);
		while (i < j&&r[i] <= pivot)
			i++;
		if (i < j)
			swap(r[i], r[j--]);
	}
	return i;//返回基准元素的位置
}

void QuickSort(int R[], int low, int high)
{
	int mid;
	if (low < high)
	{
		mid = Partition(R, low, high);
		QuickSort(R, low, mid -1);
		QuickSort(R, mid, high);
	}
}
```



![](https://img-blog.csdn.net/20180824232513951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



