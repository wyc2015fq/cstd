# 缓冲流 - PeterBishop - CSDN博客





2018年11月04日 21:42:19[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：38








  这节课我们来讲缓冲流



![](https://img-blog.csdnimg.cn/20181104214056858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx,size_16,color_FFFFFF,t_70)



看上图，这节课我们讲四个类:

- BufferedInputStream,

- BufferedOutputStream,

- BufferedReader,

- BufferedWriter



首先说下缓冲流，缓冲流是一种处理流



处理流：是对流进行处理的流，作用是提高性能



缓冲流依然分为字符缓冲流和字节缓冲流，来看看例子



Demo1: 字节缓冲流
//这节课我们做一个文件复制，用java代码来做一个文件复制

//这样我们的文件复制就做完了

public static void main(String[] args) {

    String filepath = "F:\\code\\java\\123.txt";

    String copypath = "F:\\code\\java\\2.txt";

    *writeFile*(copypath,*readFile*(filepath));

}



*/** * **我们刚刚讲过，缓冲流是对流进行处理的，其实缓冲流的使用非常简单 */*public static String readFile(String filepath)

{

    InputStream is = null;

    try {

        File file = new File(filepath);

        is = new BufferedInputStream(new FileInputStream(file));    //在这里使用缓冲流提高效率

        //可以看到BufferedInputStream继承自FileInputStream

        //因此我们以后再使用文件读取的时候可以直接用BufferedInnputStream，这样读取文件效率更高

        //下面的BufferedOutputStream也是一样的

        //字节缓冲流就这么简单，就是在原来的字节流外面套层壳，由于是继承关系，方法调用都是一样的



        //获取文件内容长度

        long length = file.length();

        byte[] fileContent = new byte[(int)length];



        is.read(fileContent);



        String content = new String(fileContent);

        return content;



    } catch (FileNotFoundException e) { //由于FileNotFoundException是IOException的子类，所以先捕获FileNotFoundException

        e.printStackTrace();

        return null;

    } catch (IOException e) {

        e.printStackTrace();

        return null;

    } finally {

        //我们前面说过finally这部分用来存放释放资源的代码

        //现在我们就用来释放InputStream占用的资源

        try {

            if (is != null)

            {

                is.close();

            }

        } catch (IOException e) {   //可以看到抛出的是IOException，证明了Closeable确实重写了AutoCloseable的close方法

            e.printStackTrace();

        }

    }

}



public static boolean writeFile(String filepath,String content)

{

    File file = new File(filepath); //还没有这个文件

    OutputStream os = null;

    try {

        file.createNewFile();

    } catch (IOException e) {

        e.printStackTrace();

    }

    try {

        os = new BufferedOutputStream(new FileOutputStream(file));

        byte[] bytes = content.getBytes();

        os.write(bytes);

        return true;

    } catch (FileNotFoundException e) {

        e.printStackTrace();

        return false;

    } catch (IOException e) {

        e.printStackTrace();

        return false;

    }finally {

        try{

            if (os != null)

                os.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

}


Demo2: 字符缓冲流
//还是来写个文件复制

public static void main(String[] args) {

    String filepath = "F:\\code\\java\\2.txt";

    String copypath = "F:\\code\\java\\3.txt";

    *copyFile*(filepath,copypath);

}



*/** * **这个方法就直接copy文件了 * **@param ****filepath *** **@return ***/*public static void copyFile(String filepath, String copypath)

{

    BufferedReader reader = null;

    BufferedWriter writer = null;

    try {

        File file = new File(filepath);

        File copyFile = new File(copypath);

        reader = new BufferedReader(new FileReader(file));

        writer = new BufferedWriter(new FileWriter(copyFile));



        //这里如果不加判断的话就就无法往文件里写入内容

        if (!copyFile.exists())

        {

            copyFile.createNewFile();

        }





        String line = "";



        do {

            //BufferedReader多了一个新的方法 readline，一次可以读取一行字符串

            line = reader.readLine();

            System.*out*.println(line);

            if(line != null)    //如果这里不加这个判断，当line为null时会往文件里写入一个"null"，所以这里一定要加判断

            {

                writer.append(line);    //这个应该是往后新增

                //BufferedWriter也有一个新方法 newLine，就是写入换行

                writer.newLine();

                //其实这样的话到最后新文件会比原文件多一个换行

            }



        }while (line != null);



    } catch (FileNotFoundException e) {

        e.printStackTrace();

    } catch (IOException e) {

        e.printStackTrace();

    } finally {

        try {

            reader.close();

            writer.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

}






