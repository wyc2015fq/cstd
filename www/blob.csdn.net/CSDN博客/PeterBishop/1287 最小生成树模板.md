# 1287 最小生成树模板 - PeterBishop - CSDN博客





2019年02月28日 17:45:02[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：36








```cpp
/* ***********************************************
Author        :PeterBishop
Created Time  :Thu 28 Feb 2019 16:46:31 CST
File Name     :t.cpp
Origin        :P O J  1287
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;
const int MAXN=100;
const int INF=0x3f3f3f3f;
int p;
int r;
int ans=0;
bool vis[MAXN];
int lowc[MAXN];
int prim(int cost[][MAXN],int n){
	memset(vis,false,sizeof(vis));
	vis[0]=true;
	for(int i=1;i<n;i++)
		lowc[i]=cost[0][i];
	for(int i=1;i<n;i++){
		int minc=INF;
		int p=-1;
		for(int j=1;j<n;j++)
			if(!vis[j]&&minc>lowc[j]){
				p=j;
				minc=lowc[j];
			}
		ans+=minc;
		if(minc==INF)
			return -1;
		vis[p]=true;
		for(int j=0;j<n;j++)
			if(!vis[j]&&lowc[j]>cost[p][j])
				lowc[j]=cost[p][j];
	}
	return ans;
}
int main()
{
	//freopen("out.txt","w",stdout);
	freopen("in.txt","r",stdin);
	while(cin>>p>>r){
		if(p==0)
			break;
		ans=0;
		int cost[MAXN][MAXN];
		for(int i=0;i<MAXN;i++)
			for(int j=0;j<MAXN;j++)
				cost[i][j]=i==j?0:INF;
		for(int i=0;i<r;i++){
			int a,b,c;
			cin>>a>>b>>c;
			if(cost[a-1][b-1]>c)
				cost[a-1][b-1]=cost[b-1][a-1]=c;
		}
		cout<<prim(cost,p)<<endl;
	}
    
    
    return 0;
}
```





