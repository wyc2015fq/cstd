# 注解 - PeterBishop - CSDN博客





2018年11月29日 13:53:27[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：25
个人分类：[Java学习](https://blog.csdn.net/qq_40061421/article/category/8087498)









  注解，这玩意其实属于基本语法和常用类交叉的地方，是jdk1.5添加的新特性



  注解是什么？

  注解(Annotation)很重要，注解是JDK1.5之后才有的新特性.

  注解的作用就是简化开发或者作为一个标识用的，使用注解可以极大的简化我们的开发，这个你们以后会体会到，今天我们主要讲，怎么自己定义注解





JDK1.5之后内部提供的三个注解

       @Deprecated 意思是“废弃的，过时的”

       @Override 意思是“重写、覆盖”

       @SuppressWarnings 意思是“压缩警告”





注解定义方法:
public @interface 注解名 {

}


辅助我们自定义注解的几个注解:

@Target，表示我们自定义的注解可以标识在哪些地方:



ANNOTATION_TYPE:标在注解上，比如Target就可以标在我们自定义的注解上

CONSTRUCTOR: 标注在构造器上

FIELD: 标注在属性上

LOCAL_VARIABLE: 标注在局部变量上

METHOD: 标注在方法上

PACKAGE: 标注在包上,这个也基本用不到，不讲

PARAMETER: 标注在方法的参数上

TYPE: 标注在类上

TYPE_PARAMETER和TYPE_USE基本用不到，不讲



@Retentioan,表示我们这个注解在什么时候起作用，一般是RetentionPolicy.RUNTIME，表示运行时:

RetentionPolicy.SOURCE: 写代码的时候就会起作用

RetentionPolicy.CLASS: 编译的时候起作用

RetentionPolicy.RUNTIME: 运行的时候起作用(我们就用这个，其他两个是给写jvm的人用的)



Java1.8以后允许注解被继承，即如果你在父类或者父类的方法或属性等等地方标注了注解，子类可以直接继承这些注解，如果希望注解可继承，要加一个注解@Inherited



AnnotationUtil:
public class AnnotationUtil {



    */**     * **判断element上是否存在annotationClass对应的注解     * AnnotatedElement表示能标明注解的对象，比如Class,Field,Method,Constructor等都实现了这个接口     * 具体实现各位自己下去仔细琢磨，我就不细讲了，主要来演示下它的用途     * **@param ****element     *** **@param ****annotationClass     *** **@return     ***/    *public static boolean existAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationClass) {

        if (element == annotationClass)

        {

            return true;

        }

        else

        {

            Annotation annotation = element.getAnnotation(annotationClass);

            if (annotation != null)

            {

                return true;

            }

            else

            {

                Annotation[] declaredAnnotations = element.getDeclaredAnnotations();

                for (Annotation declaredAnnotation : declaredAnnotations)

                {

                    if (declaredAnnotation instanceof Documented || declaredAnnotation instanceof Retention || declaredAnnotation instanceof Target)

                    {

                        continue;

                    }

                    boolean flag = *existAnnotation*(declaredAnnotation.annotationType(),annotationClass);

                    if (flag)

                        return true;

                }

                return false;

            }

        }

    }



    public static <T extends Annotation> T getAnnotation(AnnotatedElement element,Class<T> annotationClass)

    {

        if (element == annotationClass)

        {

            return null;

        }

        else

        {

            Annotation annotation = element.getAnnotation(annotationClass);

            if (annotation != null)

            {

                return (T)annotation;

            }

            else

            {

                Annotation[] declaredAnnotations = element.getDeclaredAnnotations();

                for (Annotation declaredAnnotation : declaredAnnotations)

                {

                    boolean flag = *existAnnotation*(declaredAnnotation.annotationType(),annotationClass);

                    if (flag)

                        return (T)declaredAnnotation;

                }

                return null;

            }

        }

    }

}


MyAnnotation:
*/** * **接下来说下注解到底怎么写 * 首先，我们要定义注解可以表明在什么地方，这个时候需要在我们定义的注解上面加上@Target注解 */*@Target({ElementType.*FIELD*})

@Retention(RetentionPolicy.*RUNTIME*)

@Inherited

@Value

public @interface MyAnnotation {

    //注解里定义的方法在使用时其实就是属性，方法默认是public的

    //加了default就表示这个属性(方法)有默认值，不加的话使用注解的时候必须给值

    String value() /*default ""*/;

}


Value:
@Target({ElementType.*FIELD*,ElementType.*ANNOTATION_TYPE*})

@Retention(RetentionPolicy.*RUNTIME*)

@Inherited

public @interface Value {

}


AnnotationTest:
//可以看到@MyAnnotation注解不允许被加在类上，这是因为@Target里没有加ElementType.TYPE

//加了之后就不报错了

//我们还是去掉

//@MyAnnotation(value = "lalalala")

public class AnnotationTest {





    //这里的value其实就是刚刚在注解里定义的value方法

    @MyAnnotation(value = "xiaoye")

    String name;

    public static void main(String[] args) throws Exception {

        //接下来讲注解的解析

        //所谓注解的解析就是赋予注解一定的功能

        //解析注解必须通过反射

        AnnotationTest test = new AnnotationTest();

        Class clazz = test.getClass();

        Field nameField = clazz.getDeclaredField("name");



        //判断nameField上是否存在Value注解

        //这个方法可以追根溯源，如果nameField上有MyAnnotation注解，而MyAnnotation上又有Value注解，那么这个方法可以把Value注解给查出来

        boolean existAnnotation = AnnotationUtil.*existAnnotation*(nameField, Value.class);

        System.*out*.println(existAnnotation);

        //这个annotation.value()就是刚刚在注解里定义的value

        if (existAnnotation)

        {

            //这个方法则是可以获取到标注在注解上的注解，一句话，追根溯源

            Value annotation = AnnotationUtil.*getAnnotation*(nameField, Value.class);



        }





        //通过以上代码我们就实现了通过注解在运行时给属性赋值

        //当然注解可以实现很多很多功能，下面讲一个工具类



    }

}




