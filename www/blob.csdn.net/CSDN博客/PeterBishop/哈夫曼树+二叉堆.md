# 哈夫曼树+二叉堆 - PeterBishop - CSDN博客





2018年08月07日 11:17:50[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：217










### **哈夫曼树的介绍**

Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。

**定义**：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。

![](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/01.jpg?raw=true)

(01) 路径和路径长度

> 
**定义**：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 
**例子**：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。


(02) 结点的权及带权路径长度

> 
**定义**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 
**例子**：节点20的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 20 = 60。


(03) 树的带权路径长度

> 
**定义**：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 
**例子**：示例中，树的WPL= 1**100 + 2**80 + 3**20 + 3**10 = 100 + 160 + 60 + 30 = 350。




比较下面两棵树

![](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/02.jpg?raw=true)

上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。

> 
左边的树WPL=2*10 + 2*20 + 2*50 + 2*100 = 360 

右边的树WPL=350


左边的树WPL > 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。



### **哈夫曼树的图文解析**

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：

> 
**1**. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 
**2**. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 
**3**. 从森林中删除选取的两棵树，并将新树加入森林； 
**4**. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。




以{5,6,7,8,15}为例，来构造一棵哈夫曼树。

![](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true)

**第1步**：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。 
**第2步**：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将"树5"和"树6"从森林中删除，并将新的树(树11)添加到森林中。 
**第3步**：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将"树7"和"树8"从森林中删除，并将新的树(树15)添加到森林中。 
**第4步**：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将"树11"和"树15"从森林中删除，并将新的树(树26)添加到森林中。 
**第5步**：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将"树15"和"树26"从森林中删除，并将新的树(树41)添加到森林中。 

此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！











### **堆和二叉堆的介绍**

**堆的定义**

堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质：

[**性质一**] 堆中任意节点的值总是不大于(不小于)其子节点的值；

[**性质二**] 堆总是一棵完全树。

将任意节点不大于其子节点的堆叫做最小堆或小根堆，而将任意节点不小于其子节点的堆叫做最大堆或大根堆。常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。

**二叉堆的定义**

二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。

最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。示意图如下：

![](https://images0.cnblogs.com/i/497634/201403/182339209436216.jpg)





二叉堆一般都通过"数组"来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。有时候，我们将"二叉堆的第一个元素"放在数组索引0的位置，有时候放在1的位置。当然，它们的本质一样(都是二叉堆)，只是实现上稍微有一丁点区别。

假设"第一个元素"在数组中的索引为 0 的话，则父节点和子节点的位置关系如下：

(01) 索引为i的左孩子的索引是 (2*i+1);

(02) 索引为i的左孩子的索引是 (2*i+2);

(03) 索引为i的父结点的索引是 floor((i-1)/2);

![](https://images0.cnblogs.com/i/497634/201403/182342224903953.jpg)





### **二叉堆的图文解析**

在前面，我们已经了解到："最大堆"和"最小堆"是对称关系。这也意味着，了解其中之一即可。本节的图文解析是以"最大堆"来进行介绍的。

二叉堆的核心是"添加节点"和"删除节点"，理解这两个算法，二叉堆也就基本掌握了。下面对它们进行介绍。



**1. 添加**

假设在最大堆[90,80,70,60,40,30,20,10,50]种添加85，需要执行的步骤如下：

![](https://images0.cnblogs.com/i/497634/201403/182345301461858.jpg)

*如上图所示，当向最大堆中添加数据时：先将数据加入到最大堆的最后，然后尽可能把这个元素往上挪，直到挪不动为止！*

将85添加到[90,80,70,60,40,30,20,10,50]中后，最大堆变成了[90,85,70,60,80,30,20,10,50,40]。





**2. 删除**

假设从最大堆[90,85,70,60,80,30,20,10,50,40]中删除90，需要执行的步骤如下：

![](https://images0.cnblogs.com/i/497634/201403/182348387716132.jpg)

从[90,85,70,60,80,30,20,10,50,40]删除90之后，最大堆变成了[85,80,70,60,40,30,20,10,50]。
*如上图所示，当从最大堆中删除数据时：先删除该数据，然后用最大堆中最后一个的元素插入这个空位；接着，把这个“空位”尽量往上挪，直到剩余的数据变成一个最大堆。*

注意：考虑从最大堆[90,85,70,60,80,30,20,10,50,40]中删除60，执行的步骤不能单纯的用它的子节点来替换；而必须考虑到"替换后的树仍然要是最大堆"！

![](https://images0.cnblogs.com/i/497634/201403/182350015371912.jpg)





```cpp
#include <stdio.h>
#include <stdlib.h>


typedef int Type;

typedef struct _HuffmanNode {
	Type key;					// 权值
	struct _HuffmanNode *left;	// 左孩子
	struct _HuffmanNode *right;	// 右孩子
	struct _HuffmanNode *parent;	// 父节点
}HuffmanNode, *HuffmanTree;

void preorder_huffman(HuffmanTree tree)
{
	if (tree != NULL)
	{
		printf("%d ", tree->key);
		preorder_huffman(tree->left);
		preorder_huffman(tree->right);
	}
}


/*
* 中序遍历"Huffman树"
*/
void inorder_huffman(HuffmanTree tree)
{
	if (tree != NULL)
	{
		inorder_huffman(tree->left);
		printf("%d ", tree->key);
		inorder_huffman(tree->right);
	}
}

/*
* 后序遍历"Huffman树"
*/
void postorder_huffman(HuffmanTree tree)
{
	if (tree != NULL)
	{
		postorder_huffman(tree->left);
		postorder_huffman(tree->right);
		printf("%d ", tree->key);
	}
}

/*
* 创建Huffman树结点。
*
* 参数说明：
*     key 是键值。
*     left 是左孩子。
*     right 是右孩子。
*     parent 是父节点
*/
HuffmanNode* huffman_create_node(Type key, HuffmanNode *left, HuffmanNode* right, HuffmanNode* parent)
{
	HuffmanNode* p;

	if ((p = (HuffmanNode *)malloc(sizeof(HuffmanNode))) == NULL)
		return NULL;
	p->key = key;
	p->left = left;
	p->right = right;
	p->parent = parent;

	return p;
}

/*
* 创建Huffman树
*
* 参数说明：
*     a 权值数组
*     size 数组大小
*
* 返回值：
*     Huffman树的根
*/



static HuffmanNode *m_heap;	// 最小堆的数组
static int m_capacity;		// 总的容量
static int m_size;			// 当前有效数据的数量

							/*
							* 最小堆的向下调整算法
							*
							* 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
							*
							* 参数说明：
							*     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
							*     end   -- 截至范围(一般为数组中最后一个元素的索引)
							*/
static void minheap_filterdown(int start, int end)
{
	int c = start; 	 	// 当前(current)节点的位置
	int l = 2 * c + 1; 	// 左(left)孩子的位置
	HuffmanNode tmp = m_heap[c];	// 当前(current)节点

	while (l <= end)
	{
		// "l"是左孩子，"l+1"是右孩子
		if (l < end && m_heap[l].key > m_heap[l + 1].key)
			l++;		// 左右两孩子中选择较小者，即m_heap[l+1]
		if (tmp.key <= m_heap[l].key)
			break;		//调整结束
		else
		{
			m_heap[c] = m_heap[l];
			c = l;
			l = 2 * l + 1;
		}
	}
	m_heap[c] = tmp;
}

/*
* 最小堆的向上调整算法(从start开始向上直到0，调整堆)
*
* 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
*
* 参数说明：
*     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)
*/
static void filter_up(int start)
{
	int c = start;			// 当前节点(current)的位置
	int p = (c - 1) / 2;		// 父(parent)结点的位置 
	HuffmanNode tmp = m_heap[c];		// 当前节点(current)

	while (c > 0)
	{
		if (m_heap[p].key <= tmp.key)
			break;
		else
		{
			m_heap[c] = m_heap[p];
			c = p;
			p = (p - 1) / 2;
		}
	}
	m_heap[c] = tmp;
}

/*
* 将node插入到二叉堆中
*
* 返回值：
*     0，表示成功
*    -1，表示失败
*/
int dump_to_minheap(HuffmanNode *node)
{
	// 如果"堆"已满，则返回
	if (m_size == m_capacity)
		return -1;

	m_heap[m_size] = *node;     // 将"node的数据"全部复制到"数组末尾"
	filter_up(m_size);			// 向上调整堆
	m_size++;					// 堆的实际容量+1

	return 0;
}

/*
* 交换两个HuffmanNode节点的全部数据
*/
static void swap_node(int i, int j)
{
	HuffmanNode tmp = m_heap[i];
	m_heap[i] = m_heap[j];
	m_heap[j] = tmp;
}

/*
* 新建一个节点，并将最小堆中最小节点的数据复制给该节点。
* 然后除最小节点之外的数据重新构造成最小堆。
*
* 返回值：
*     失败返回NULL。
*/
HuffmanNode* dump_from_minheap()
{
	// 如果"堆"已空，则返回
	if (m_size == 0)
		return NULL;

	HuffmanNode *node;
	if ((node = (HuffmanNode *)malloc(sizeof(HuffmanNode))) == NULL)
		return NULL;

	// 将"最小节点的全部数据"复制给node
	*node = m_heap[0];

	swap_node(0, m_size - 1);				// 交换"最小节点"和"最后一个节点"
	minheap_filterdown(0, m_size - 2);	// 将m_heap[0...m_size-2]构造成一个最小堆
	m_size--;

	return node;
}

/*
* 打印二叉堆
*
* 返回值：
*     0，表示成功
*    -1，表示失败
*/
void minheap_print()
{
	int i;
	for (i = 0; i<m_size; i++)
		printf("%d ", m_heap[i].key);
}

/*
* 创建最小堆
*
* 参数说明：
*     a -- 数据所在的数组
*     size -- 数组大小
*/
void create_minheap(Type a[], int size)
{
	int i;

	// 创建最小堆所对应的数组
	m_size = size;
	m_capacity = size;
	m_heap = (HuffmanNode *)malloc(sizeof(HuffmanNode)*size);

	// 初始化数组
	for (i = 0; i<size; i++)
	{
		m_heap[i].key = a[i];
		m_heap[i].parent = m_heap[i].left = m_heap[i].right = NULL;
	}

	// 从(size/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个最小堆。
	for (i = size / 2 - 1; i >= 0; i--)
		minheap_filterdown(i, size - 1);
}

// 销毁最小堆
void destroy_minheap()
{
	m_size = 0;
	m_capacity = 0;
	free(m_heap);
}
HuffmanNode* create_huffman(Type a[], int size)
{
	int i;
	HuffmanNode *left, *right, *parent;

	// 建立数组a对应的最小堆
	create_minheap(a, size);

	for (i = 0; i<size - 1; i++)
	{
		left = dump_from_minheap();  // 最小节点是左孩子
		right = dump_from_minheap(); // 其次才是右孩子

									 // 新建parent节点，左右孩子分别是left/right；
									 // parent的大小是左右孩子之和
		parent = huffman_create_node(left->key + right->key, left, right, NULL);
		left->parent = parent;
		right->parent = parent;


		// 将parent节点数据拷贝到"最小堆"中
		if (dump_to_minheap(parent) != 0)
		{
			printf("插入失败!\n结束程序\n");
			destroy_huffman(parent);
			parent = NULL;
			break;
		}
	}

	// 销毁最小堆
	destroy_minheap();

	return parent;
}

/*
* 销毁Huffman树
*/
void destroy_huffman(HuffmanTree tree)
{
	if (tree == NULL)
		return;

	if (tree->left != NULL)
		destroy_huffman(tree->left);
	if (tree->right != NULL)
		destroy_huffman(tree->right);

	free(tree);
}

/*
* 打印"Huffman树"
*
* tree       -- Huffman树的节点
* key        -- 节点的键值
* direction  --  0，表示该节点是根节点;
*               -1，表示该节点是它的父结点的左孩子;
*                1，表示该节点是它的父结点的右孩子。
*/
void huffman_print(HuffmanTree tree, Type key, int direction)
{
	if (tree != NULL)
	{
		if (direction == 0)    // tree是根节点
			printf("%2d is root\n", tree->key, key);
		else                // tree是分支节点
			printf("%2d is %2d's %6s child\n", tree->key, key, direction == 1 ? "right" : "left");

		huffman_print(tree->left, tree->key, -1);
		huffman_print(tree->right, tree->key, 1);
	}
}

void print_huffman(HuffmanTree tree)
{
	if (tree != NULL)
		huffman_print(tree, tree->key, 0);
}
```



