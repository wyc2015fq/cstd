# 线程第三课——多线程初探与线程的生命周期 - PeterBishop - CSDN博客





2018年11月27日 21:34:53[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：24
个人分类：[Java学习](https://blog.csdn.net/qq_40061421/article/category/8087498)









  这节课我们来进入多线程，来初步感受下多线程，并了解下线程的声明周期



Demo 01：
public static void main(String[] args) {

    //直接点，懒得想新的线程名了



    Thread t1 = new Thread(new Runnable() {

        @Override

        public void run() {

            for (int i = 0; i < 10; i++) {

                System.*out*.println(Thread.*currentThread*().getName() + " " + i);

            }

        }

    });

    t1.setName("线程1");



    Thread t2 = new Thread(new Runnable() {

        @Override

        public void run() {

            for (int i = 0; i < 10; i++) {

                System.*out*.println(Thread.*currentThread*().getName() + " " + i);

            }

        }

    });

    t2.setName("线程2");



    t1.start();

    t2.start();

    //各位猜猜运行结果会是怎样

}


运行结果:

线程2 0

线程2 1

线程2 2

线程2 3

线程2 4

线程2 5

线程2 6

线程1 0

线程1 1

线程1 2

线程1 3

线程1 4

线程1 5

线程1 6

线程1 7

线程1 8

线程1 9

线程2 7

线程2 8

线程2 9



可以看到是交替输出的(线程2输出了一些，然后线程1又输出一些，然后线程2又输出一些，最重要的是，线程1是先启动的，可却先输出线程2的内容)



可以看到是完全无规律的交替输出


    为什么会这样呢？

    这就得说下线程的运行机制了。多个线程在启动之后就开始抢占CPU资源，哪个线程抢到了就执行那个线程里的东西

    说到抢占资源，接下来就要说说线程的生命周期(或者说是状态)，线程的状态分为以下几种:

    1. 新建状态: 线程对象被创建完成，但还没有执行start()方法启动

    2. 运行状态: 线程抢占到CPU资源，并正在运行

    3. 等待状态(阻塞状态): 线程在运行过程中需要某项资源但迟迟无法获得，就会进入等待状态(最常见的就是等待输入)

    4. 就绪状态: 线程在启动后会立刻进入就绪状态，此时的线程已经准备一切需要使用资   源，但由于其他线程占用着CPU故而只能在就绪队列等待

    5. 停止状态: 线程执行run()方法完毕或者程序直接结束或者调用stop()方法会导致线程进入停止状态,此状态下的线程释放了占有的资源






线程各状态转换图



![](https://img-blog.csdnimg.cn/20181127213327343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx,size_16,color_FFFFFF,t_70)

这样也就不难理解为什么线程和线程会交替输出了，因为这二者是在抢占CPU,线程1或线程2没办法保证自己能一直抢占着CPU，故而会交替输出，这就是初步探索多线程。



注意:

运行状态->等待状态->就绪状态的转换是单向的，不可逆转的

只有运行状态和就绪状态是可以相互转换的

所以，**等待状态要进入运行状态必须先进入就绪状态****(****重点)**





