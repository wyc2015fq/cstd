# 1015 好题挺难的（bin巨的思路） - PeterBishop - CSDN博客





2019年03月30日 10:16:04[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：9








为叙述问题方便，现将任一选择方案中，辩方总分和控方总分
之差简称为“辩控差”，辩方总分和控方总分之和称为“辩控和”。
第i 个候选人的辩方总分和控方总分之差记为V(i)，辩方总分和控
方总分之和记为S(i)。现用f(j, k)表示，取j 个候选人，使其辩
控差为k 的所有方案中，辩控和最大的那个方案（该方案称为“方
案f(j, k)”）的辩控和。并且，我们还规定，如果没法选j 个人，
使其辩控差为k，那么f(j, k)的值就为-1，也称方案f(j, k)不可行。
本题是要求选出m 个人，那么，如果对k 的所有可能的取值，求
出了所有的f(m, k) (-20×m≤ k ≤ 20×m)，那么陪审团方案
自然就很容易找到了。
    问题的关键是建立递推关系。需要从哪些已知条件出发，
才能求出f(j, k)呢？显然，方案f(j, k)是由某个可行的方案f(j-1, x)
( -20×m ≤ x ≤ 20×m)演化而来的。可行方案f(j-1, x)能演化成
方案f(j, k)的必要条件是：存在某个候选人i，i 在方案f(j-1, x)中
没有被选上，且x+V(i) = k。在所有满足该必要条件的f(j-1, x)中，
选出 f(j-1, x) + S(i) 的值最大的那个，那么方案f(j-1, x)再加上候选人i，
就演变成了方案 f(j, k)。这中间需要将一个方案都选了哪些人都记录下来。
不妨将方案f(j, k)中最后选的那个候选人的编号，记在二维数组的
元素path[j][k]中。那么方案f(j, k)的倒数第二个人选的编号，
就是path[j-1][k-V[path[j][k]]。假定最后算出了解方案的辩控差是k，
那么从path[m][k]出发，就能顺藤摸瓜一步步求出所有被选中的候选人。
初始条件，只能确定f(0, 0) = 0。由此出发，一步步自底向上递推，
就能求出所有的可行方案f(m, k)( -20×m ≤ k ≤ 20×m)。实际解题
的时候，会用一个二维数组f 来存放f(j, k)的值。而且，由于题目中辩
控差的值k 可以为负数，而程序中数租下标不能为负数，所以，在程序中
不妨将辩控差的值都加上400，以免下标为负数导致出错，即题目描述中，
如果辩控差为0，则在程序中辩控差为400。



```cpp
#include<iostream>
#include<cstring> 
#include<algorithm>
using namespace std;
int n,m;
int dp[21][801];
int path[21][801];
/*回溯，确认dp[j][k]方案是否曾选择过候选人i*/
bool select(int j,int k,int i,int* v)
{
	while(j>0 && path[j][k]!=i)
	{
		k-=v[ path[j][k] ];
		j--;
	}
	return j?false:true;
}
int main(void)
{
	int time=1;
	while(cin>>n>>m&&(n||m))
	{
		int i,j,k;
		int p[n+1],d[n+1],s[n+1],v[n+1];
		memset(dp,-1,sizeof(dp));
		memset(path,0,sizeof(path));
		for(i=1;i<=n;i++)
		{
			cin>>p[i]>>d[i];
			s[i]=p[i]+d[i];
			v[i]=p[i]-d[i];
		}
		int fix=m*20;  //总修正值，修正极限为从[-400,400]映射到[0,800]
		dp[0][fix]=0;   //由于修正了数值，因此dp[0][fix]才是真正的dp[0][0]
		for(j=1;j<=m;j++)
			for(k=0;k<=2*fix;k++)
			{
				if(dp[j-1][k]>=0)
				{
					for(i=1;i<=n;i++)
						if(dp[j][ k+v[i] ] < dp[j-1][k]+s[i])
						{
							if(select(j-1,k,i,v))
							{
								dp[j][ k+v[i] ] = dp[j-1][k]+s[i];
								path[j][ k+v[i] ] = i;
							}
						}
				}
			}
		for(k=0;k<=fix;k++)
			if(dp[m][fix-k]>=0 || dp[m][fix+k]>=0)    //从中间向两边搜索最小辨控差的位置k
				break;
		int div=dp[m][fix-k] > dp[m][fix+k] ? (fix-k):(fix+k);  //最小辨控差
		cout<<"Jury #"<<time++<<endl;
		cout<<"Best jury has value ";
		//辩方总值 = （辨控和+辨控差+修正值）/2
		cout<<(dp[m][div]+div-fix)/2<<" for prosecution and value ";
		//控方总值 = （辨控和-辨控差+修正值）/2
		cout<<(dp[m][div]-div+fix)/2<<" for defence:"<<endl;
		int* id=new int[m];
		for(i=0,j=m,k=div;i<m;i++)
		{
			id[i]=path[j][k];
			k-=v[id[i]];
			j--;
		}
		sort(id,id+m);   //升序输出候选人编号
		for(i=0;i<m;i++)
			cout<<' '<<id[i];
		cout<<endl<<endl;
	}
	return 0;
}
```





