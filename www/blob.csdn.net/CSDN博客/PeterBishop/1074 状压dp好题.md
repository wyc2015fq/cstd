# 1074 状压dp好题 - PeterBishop - CSDN博客





2019年03月13日 16:42:04[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：11








题解：

首先，dp思想：

假设dp[ _ , _ , _ , …… , _ , _ , _ ]记录了：n门课，在一些完成了，一些未完成的状态下，当前已经花去的时间（time），以及，当前已经被扣掉的最少分数（rs）；

例如：有3门课，那么dp[0,0,0]代表了三门课作业还未做完的状态，dp[0,1,1]代表第二门和第三门的作业已经做完，第一门课作业还没做完的状态；

那么，我们状态转移方程：

![](https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170925220111339-1549048578.png)

　　也就是说，dp[…1…]表示当前状态下第k门课已完成；

　　那么，在dp[…0…]状态下，“已花费的时间 + 完成第k门课所需的时间 - 这门课的deadline”表示当前状态下开始做第k门课的作业，会导致扣多少分（记为red_sco）。

　　如果red_sco + dp[…0…].rs 比 dp[…1…].rs 小，说明我们可以更新一下dp[…1…]，它的rs可以更小；



然后，由于一门课的作业，只有做完和还没做完两个状态，所以我们dp[ _ , _ , _ , …… , _ , _ , _ ]里的n个数字，合起来看就是一个二进制数；

那么我们把它转换成十进制，其实并不影响实际的状态转移操作，故我们可以对这个状态进行压缩（原本n位的二进制数字可以压缩的很小位数的十进制数），即状压DP；

```cpp
#include<cstdio>
#include<iostream>
#include<stack>
#define INF 0x3f3f3f3f
using namespace std;
int n;//n门课
struct Course{
    string name;
    int cost,deadline;
}course[16];

struct DP{
    int time,rs;
    int now,pre;//用以记录做作业的顺序
}dp[1<<15];

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(int i=0;i<n;i++) cin>>course[i].name>>course[i].deadline>>course[i].cost;

        int ed_state=(1<<n)-1;//所有作业都做完的状态

        dp[0].time=0, dp[0].rs=0;
        for(int state=1;state<=ed_state;state++)//遍历状态
        {
            dp[state].rs=INF;
            for(int co=n-1;co>=0;co--)//从后往前遍历课程，可以保证在相同扣分的情况下字典序完成课程作业
            {
                int k=1<<(n-1-co);
                if(state & k)//如果当前状态，这门课作业已完成
                {
                    int pre_state=state-k;

                    int tmp=dp[pre_state].time+course[co].cost-course[co].deadline;
                    if(tmp<0) tmp=0;
                        //算出要扣的分
                    if(tmp+dp[pre_state].rs < dp[state].rs)
                    {
                        dp[state].rs=tmp+dp[pre_state].rs;
                        dp[state].time=dp[pre_state].time+course[co].cost;

                        dp[state].now=co;
                        dp[state].pre=pre_state;
                    }
                }
            }
        }
        printf("%d\n",dp[ed_state].rs);
        stack<int> output;
        for(int i=ed_state;i!=0;i=dp[i].pre) output.push(dp[i].now);
        while(!output.empty())
        {
            cout<<course[output.top()].name<<endl;
            output.pop();
        }
    }
}
```





