# 包装类型 - PeterBishop - CSDN博客





2018年09月30日 16:23:10[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：103








### 这节课我们来讲讲包装类型

### 什么是包装类型？

### JDK为我们提供了一些与基本数据类型对应的类，这些类的对象可以和基本数据类型的变量直接互相赋值，并且这些类对比基本数据类型而言具有更为强大的功能。这些类就被称为包装类型。

### 基本数据类型与包装类型的对应关系:

### Integer === int

### Float === float

### Short === short

### Double === double

### Character === char

### Boolean === boolean

### Byte === byte

### Long === long

### Demo：

### public static void main(String[] args) {    //包装类型和基本数据类型可以互相直接赋值    Integer i1 = 12;    System.out.println(i1);    int i = i1;    System.out.println(i);    //包装类型能提供更为强大的功能    int max = Integer.max(2,1);    System.out.println(max);}

### Integer 源码分析:

### public final class Integer extends Number implements Comparable<Integer>

### 可以看到Integer类是继承了一个Number类然后实现了一个Comparable接口

### 首先来看Comparable接口

### public interface Comparable<T> {

### public int compareTo(T o);

### }

### 可以看到Comparable源码中只有一个方法叫compareTo，T是泛型，这个以后讲

### 然后来看看compareTo在Integer中的实现

### public int compareTo(Integer anotherInteger) {

### return *compare*(this.value, anotherInteger.value);

### }

### 可以看到是调用了自己类的compare方法并返回

### public static int compare(int x, int y) {

### return (x < y) ? -1 : ((x == y) ? 0 : 1);

### }

### 这里解释一下? :，这个叫三目运算符，语法是

### 表达式?语句1:语句2;

### 相当于:

### if(表达式)

### 语句1

### else

### 语句2

### 那么这就很简单了,

### 这个compare方法就相当于

### If(x < y)

### return -1;

### else if(x == y)

### return 0;

### else

### return 1;

### 这就是compareTo的功能，比较自己和另一个Integer的大小，如果自己更小，则返回-1，如果相等，返回0，如果自己更大，返回1

### 接下来看看API文档

### int Integer.compareTo(Integer anotherInteger)

### 如果该 `Integer`等于 `Integer`参数，则返回 `0`值；如果该 `Integer`在数字上小于 `Integer`参数，则返回小于 `0`的值；如果 `Integer`在数字上大于 `Integer`参数，则返回大于 `0`的值（有符号的比较）。

### Jdk1.6里好像没有compare方法，来看看1.8的

### 1.8的翻译不是很好，有机会带你们看英文版，总之compare的具体实现我们分析完成了。接下来看看Number类是个啥。

### public abstract class Number implements java.io.Serializable

### 可以看到Number是一个抽象类，这个类实现了Serializable接口，这个接口是实现序列化的，凡是实现Serializable接口的类都要实现序列化，序列化以后再讲，先看看Number有哪些方法。

### 可以看到Numebr里的方法就是xxxValue()，返回值类型就是xxx

### 最后我们来看看Integer类。

### @Native public static final int   *MIN_VALUE *= 0x80000000;

### */***

###  * A constant holding the maximum value an {**@code **int} can

###  * have, 2*<sup>**31**</sup>**-1.*

###  */

### @Native public static final int   *MAX_VALUE *= 0x7fffffff;

### 最大值最小值，用的16进制表示，我们可以来输出一下

### 接下来需要你们了解一个东西:

### System.*out*.println(Integer.*MAX_VALUE *+ 1);

### System.*out*.println(Integer.*MIN_VALUE *- 1);

### -2147483648

### 2147483647

### 可以看到Integer.MIN_VALUE就是Integer.MAX_VALUE + 1,这个了解一下就行，有机会会讲原理。

### public Integer(int value) {

### this.value = value;

### }

### 这个就是Integer的构造器。

### 搞错了，value还是在Integer里。

### 只不过声明的地方已经是840行了

### 可以看到value这个属性是一个int类型的常量，这说明什么？

### 这说明每当Integer的值改变的时候，其实是new出了一个新的Integer对象，然后原引用变量再指向这个新的new出来的对象。

### OK，Integer的源码就看到这里，以后有机会再深入研究。



