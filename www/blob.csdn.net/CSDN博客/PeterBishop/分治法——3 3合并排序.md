# 分治法——3.3合并排序 - PeterBishop - CSDN博客





2018年08月24日 21:00:06[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：19
个人分类：[趣学算法学习笔记](https://blog.csdn.net/qq_40061421/article/category/7930367)









![](https://img-blog.csdn.net/20180824203947282?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824204011669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180824204036825?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



```cpp
#include<iostream>
#include<cstdlib>
#incclude<cstdio>
using namespace std;
void Merge(int A[],int low,int mid,int high)
{
    int *B=new int[high-low+1];//申请一个辅助数组
    int i=low,j=mid+1,k=0;
    while(i<=mid&&j<=high)
    {
        if(A[i]<=A[j])
            B[k++]=A[i++];
        else
           B[k++]=A[j++];
    }
    while(i<=mid)
        B[k++]=A[i++];
    while(j<=high)
        B[k++]=A[j++];
    for(int i=low,k=0;i<=high;i++)
        A[i++]=B[k++];
}
void MergeSort(int A[],int low,int high)
{
    if(kow<high)
    {
        int mid=(low+high)/2;
        MergeSort(A,low,mid);
        MergeSort(A,mid+1,high);
        Merge(A,low,mid,high);
    }
}
```





