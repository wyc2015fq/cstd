# 2018 求至少k个连续数 使得平均值最大 - PeterBishop - CSDN博客





2018年10月20日 17:52:46[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：73








题意:找至少连续的k个数,使得这k个数的平均值最大.

思路:用两个数组 f[i] num[i],  f[i]表示以当前数arr[i]为结尾的最大平均数,num[i]表示个数

如何求f[i]呢?当然我们要知道以arr[i]为结尾,且个数>=k的所有情况,然后取其中的最优情况

① f[i]=f[i-1]+arr[i]/(num[i-1]+1)    num[i]=num[i-1]+1  以a[i]为结尾的数目>=k+1的最优情况就是f[i]=f[i-1]+arr[i]/(num[i-1]+1)

②  f[i]=(sum[i]-sum[i-k])/k  num[i]=k  以a[i]为结尾的数目==k的最优情况就是sum[i]-sum[i-k]/k

两者取较优者。通过 f[i]实现了当前这个点对于后面点的影响（由于比较的存在导致后面点的序列起始位置变的任意了，真的很机智的想法，理解了半天……）

![](https://img-blog.csdn.net/20181020111430104?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181020111442978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181020111455897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181020111509246?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181020111522711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181020111825346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181020111840982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)







![](https://img-blog.csdn.net/20181020111547965?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181020111601803?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181020111613270?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





```cpp
#include<cstdio>
typedef long long ll;
int main()
{
	int n,k;
	const int size=100001;
	while(~scanf("%d %d",&n,&k))
	{
		ll arr[size];
		ll sum[size]={0};
		for(int i=1;i<=k;i++)
		{
			scanf("%lld",&arr[i]);
			sum[i]=sum[i-1]+arr[i];
		}
		ll f[size]={0};
		f[k]=sum[k];
		ll m=f[k]*1000/k;
		ll num[size]={0};
		num[k]=k;
		for(int i=k+1;i<=n;i++)
		{
			scanf("%lld",&arr[i]);
			sum[i]=sum[i-1]+arr[i];
			ll tmp1=f[i-1]+arr[i];
			ll n1=num[i-1]+1;
			ll tmp2=sum[i]-sum[i-k];
			ll n2=k;
			if(tmp1*n2 > tmp2*n1)
			{
				f[i]=tmp1;
				num[i]=n1;
			}else{
				f[i]=tmp2;
				num[i]=n2;
			}
			if(f[i]*1000/num[i]>m)
			{
				m=f[i]*1000/num[i];
			}
		}
		printf("%lld\n",m);
	}
	return 0;
}
```

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;
const int maxn = 1e5 + 6;
int n, f;
int a[maxn];
int sum[maxn];
double dp[maxn];
int q[maxn];
double solve(int i, int j)
{
	return 1.0*(sum[i] - sum[j]) / (i - j);
}
int main()
{
	scanf("%d%d", &n, &f);
	sum[0] = 0;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	int head, tail;
	head = tail = 0;
	double ans = 0;
	for (int i = f; i <= n; i++)
	{
		while (head<tail&&solve(i, q[head])<solve(i, q[head + 1]))//如果头结点的斜率小于后一个则后一个变为头节点（我们需要下凸）
		{
			head++;
		}
		dp[i] = 1.0*(sum[i] - sum[q[head]]) / (i - q[head]);//记录i为结尾时的斜率
		ans = max(ans, dp[i]);
		int k = i - f + 1;//为了维护最多有f个，记录点的个数
		while (head<tail&&solve(q[tail], q[tail - 1])>solve(k, q[tail]))//如果新增结点与尾节点斜率小于原末尾两节点（下凸）
		{
			tail--;
		}
		q[++tail] = k;
	}
	printf("%d\n", int(ans * 1000));
	return 0;
}
```





