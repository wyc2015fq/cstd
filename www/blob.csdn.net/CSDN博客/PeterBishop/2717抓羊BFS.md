# 2717抓羊BFS - PeterBishop - CSDN博客





2018年04月14日 20:51:12[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：36
个人分类：[HDOJ](https://blog.csdn.net/qq_40061421/article/category/7502192)









```cpp
#include <stdio.h>//也是BFS的模板题，三个搜索方向，分别判断，挺好想到的
#include <string.h>
#include <queue>
using namespace std;

const int N = 1000000;
int map[N + 10];
int n, k;
struct node
{
	int x, step;
};

int check(int x)
{
	if (x<0 || x >= N || map[x])//这个判断的顺序很重要，先得判断有没有越界，不然runtime error
		return 0;
	return 1;
}

int bfs(int x)
{
	int i;
	queue<node> Q;
	node a, next;
	a.x = x;
	a.step = 0;
	map[x] = 1;
	Q.push(a);
	while (!Q.empty())
	{
		a = Q.front();
		Q.pop();
		if (a.x == k)
			return a.step;
		next = a;
		//每次都将三种状况加入队列之中
		next.x = a.x + 1;
		if (check(next.x))
		{
			next.step = a.step + 1;
			map[next.x] = 1;
			Q.push(next);
		}
		next.x = a.x - 1;
		if (check(next.x))
		{
			next.step = a.step + 1;
			map[next.x] = 1;
			Q.push(next);
		}
		next.x = a.x * 2;
		if (check(next.x))
		{
			next.step = a.step + 1;
			map[next.x] = 1;
			Q.push(next);
		}
	}
	return -1;
}

int main()
{
	int ans;
	while (~scanf("%d%d", &n, &k))
	{
		memset(map, 0, sizeof(map));
		ans = bfs(n);
		printf("%d\n", ans);
	}
	return 0;
}
```





