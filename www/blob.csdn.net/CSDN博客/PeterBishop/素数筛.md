# 素数筛 - PeterBishop - CSDN博客





2018年10月07日 20:33:16[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：12
个人分类：[数据结构与算法](https://blog.csdn.net/qq_40061421/article/category/7898328)









### 用筛法求[素数](https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0)的基本思想是：把从1开始的、某一范围内的[正整数](https://baike.baidu.com/item/%E6%AD%A3%E6%95%B4%E6%95%B0)从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的[倍数](https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981)。依次类推，直到筛子为空时结束。

### 第一种：普通筛法。

### 时间复杂度是O(nlogn)，不足之处在于一个合数可能被筛选多次。

```cpp
void Prime ()//n是个数，标记为1则不是素数
{
	memset(tag,0,sizeof(tag));//prime里面存储的是对应的数字，tag用来标记
	tag[0]=tag[1]=1;
	for(int i=2; i*i <= n; i++)
		if(tag[i]==0){
			prime[ct++]=i;
			for(int j=i+i;j<=n;j+=i)
				tag[j]=1;
		}
}
```



###  第二种：线性筛。

### 时间复杂度为O(n)，原因在于每个合数保证只被它最小的那个质因子筛选。关键代码在第10，11行，因为如果i能整除prime[ j ]，那么i肯定是个合数，且i中有质因子肯定小于等于prime[j]，所以到此就可以停止了，因为后面的prime[]会比i小的那个质因子要大。首先可以知道每个合数都无法避免被它最小的素因子筛一次——因为是从小到大枚举的素数，而break是为了保证每个数只被筛一次，比如i=4,prime[j]=2时如果不break，x=i*prime[j+1到cnt-1]都会在这里被筛一次，但是因为i是prime[j]的倍数，那么这些数也一定是prime[j]的倍数，因此一定会在后面被prime[j]筛一次，所以就没必要多筛了。

```cpp
void Prime(){
	memset(tag,0,sizeof(tag));
	int cnt=0;
	tag[0]=tag[1]=1;
	for(int i = 2; i<N; i++){
		if(!tag[i])
			prime[cnt++]=i;
		for(int j=0;j<cnt && prime[j]*i<N; j++){
			tag[i*prime[j]] = 1;
			if(i % prime[j]==0)
				break;
		}
	}
}
```





