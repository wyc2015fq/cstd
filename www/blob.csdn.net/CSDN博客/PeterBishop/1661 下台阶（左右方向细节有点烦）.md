# 1661 下台阶（左右方向细节有点烦） - PeterBishop - CSDN博客





2019年04月10日 23:20:04[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：8
个人分类：[POJ](https://blog.csdn.net/qq_40061421/article/category/7589386)









```cpp
/* ***********************************************
Author        :PeterBishop
Created Time  :2019年04月09日 星期二 19时13分09秒
File Name     :t.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <string>

using namespace std;
#define MAX 0x3f3f3f3f

struct Node{
    int x[2], h;
};

Node node[1100];
int N, X, Y, MAXh;
int dp[1100][2];

int cmp( const void *a, const void *b ){
    if( ((Node*)a)->h != ((Node*)b)->h ){
        return ((Node*)b)->h - ((Node*)a)->h;
    }else{
        return ((Node*)a)->x[0] - ((Node*)b)->x[0];
    }
}

int main(){
	int T;
	freopen("in.txt","r",stdin);

    scanf( "%d", &T );
    while( T-- ){
        scanf( "%d%d%d%d", &N, &X, &Y, &MAXh );
        for( int i = 1; i <= N; i++ ){
            scanf( "%d%d%d", &node[i].x[0], &node[i].x[1], &node[i].h );
        }
        node[0].x[0] = X;
        node[0].x[1] = X;
        node[0].h = Y;
        node[N+1].x[0] = -20000;
        node[N+1].x[1] = 20000;
        node[N+1].h = 0;
        qsort( &node[1], N, sizeof( Node ), cmp );
        memset( dp, 0x3f, sizeof( dp ) );
        dp[0][0] = 0;
        dp[0][1] = 0;
        for( int i = 0; i <= N; i++ ){
            for( int j = 0; j < 2; j++ ){
                if( dp[i][j] != MAX ){
                    int temp = -1;
                    for( int k = i + 1; k <= N + 1; k++ ){
                        if( abs( node[k].h - node[i].h ) > MAXh ){
                            temp = -1;
                            break;
                        }
                        if( node[k].x[0] <= node[i].x[j] && node[k].x[1] >= node[i].x[j] ){
                            temp = k;
                            break;
                        }
                    }
                    if( temp == -1 ){
                        continue;
                    }
                    if( temp != N + 1 ){
                        dp[temp][0] = min( dp[temp][0], dp[i][j] + abs( node[temp].x[0] - node[i].x[j] ) + abs( node[temp].h - node[i].h ) );
                        dp[temp][1] = min( dp[temp][1], dp[i][j] + abs( node[temp].x[1] - node[i].x[j] ) + abs( node[temp].h - node[i].h ) );
                    }else{
                        dp[temp][0] = min( dp[temp][0], dp[i][j] + abs( node[temp].h - node[i].h ) );
                    }
                }
            }
        }
        cout << dp[N+1][0] << endl;
    }
    return 0;
}
```





