# 1045堡垒冲突问题 - PeterBishop - CSDN博客





2018年03月12日 21:18:54[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：79








```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;
char map[5][5];
int res;
int n;
bool judge(int x, int y)
{
	if (map[x][y] != '.')
		return false;
	for (int i = x - 1; i >= 0; i--)
	{
		if (map[i][y] == 'X')
			break;
		if (map[i][y] == 'O')
			return false;
	}
	for (int i = y - 1; i >= 0; i--)
	{
		if (map[x][i] == 'X')
			break;
		if (map[x][i] == 'O')
			return false;
	}
	return true;
}
void dfs(int x, int y,int tot)
{
	if (x == n && y == 0)//判断是否搜索结束 
	{
		res = max(res, tot);
		return;
	}
	if (y == n)//这一行搜索完了进行下一行 
	{
		dfs(x + 1, 0, tot);
		return;
	}
	for (int i = y; i < n; i++)//对这一行每一列都搜索 
	{
		if (judge(x, i))//符合条件才有继续搜索的价值 
		{
			map[x][i] = 'O';
			dfs(x, i + 1, tot + 1);
			map[x][i] = '.';//路不通的时候回溯恢复map的内容 
		}
	}
	dfs(x + 1, 0, tot);//这一行没有符合的元素搜索下一行 
}
int main()
{
	while (cin>>n) 
	{
		if (n == 0)
			break;
		res = 0;
		for (int i = 0; i<n; i++)
			cin>>map[i];
		dfs(0, 0, 0);
		cout<<res<<endl;
	}
	return 0;
}
```




