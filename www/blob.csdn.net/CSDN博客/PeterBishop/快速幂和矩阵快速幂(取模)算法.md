# 快速幂和矩阵快速幂(取模)算法 - PeterBishop - CSDN博客





2018年09月11日 14:36:23[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：422








### 对于普通类型的求a^n，我们的求法是不是a*a*a*a....，这样乘以n次，时间复杂度为O(n)，对于普通n比较小的我们可以接受，然而当n比较大的时候，计算就慢了，所以我们就去寻找更快捷的计算方法！

### 例如：我们要求2^8，我们通过当为偶数的时候，a^n=(a*a)^(n/2)，当n为奇数时，a^n=a*(a*a)^(n/2)的形式，是不是可以转化为4^4->8^2->64^1，就可以了，2^5的话2*4^2->2*16^1。(把幂化为底数，减少乘法的次数）

```cpp
int power(int a, int n)//a^n
{
    int ans = 1;
    while(n > 0) 
    {
        if(n&1) //当n为奇数时，乘以余下的一个a
            ans *= a;
        a *= a;
        n /= 2;
    }
    return ans;
}
```

### 但是当n比较大时往往我们的结果都非常大，如果直接算的话就会溢出，所以我们在计算的过程中会对结果取模，然后我们就有了快速幂取模算法。控制数据的大小，对于取模我们有(a*b)%c = ((a%c)*(b%c))%c，给出代码。 

```cpp
int power(long long a, int n)
{
    long long ans = 1;
    while(n > 0) 
    {
        if(n&1) 
        {
            ans *= a;
            ans %= mod;
        }
        a *= a%mod;
        a %= mod;
        n /= 2;
    }
    return ans%mod;
}
```

### 下面是矩阵快速幂，区别只是底数换成了矩阵

```cpp
const int N=10;
int n,mod;
int temp[N][N];
int res[N][N],a[N][N];
void mul(int a[][N],int b[][N])//矩阵乘法
{
    memset(temp,0,sizeof(temp));
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            for(int k=0;k<N;k++)
                temp[i][j]=(temp[i][j]+a[i][k]*b[k][j]%mod)%mod;
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            a[i][j]=temp[i][j];
    return ;
}
void fun(int nn)//快速幂，只不过底数换成了矩阵
{
    memset(res,0,sizeof(res));
    for(int i=0;i<N;i++)
        res[i][i]=1;//单位阵
    while(nn){
        if(nn&1)//奇数的话res×a
            mul(res,a);
        mul(a,a);//a自己平方
        nn>>=1;//幂次/2
    }
    return ;
}
```

### 应用如下：

### 我们从最简单的斐波那契数列入手，求菲波那切数列的第n项，n很大，所以MOD1e9+7

### 斐波的为前两项之和，即发f[0]=1,f[1]=1,f[i] = f[i-1]+f[i-2](i>1)

### 比较简单的可以直接得到递推式

### ![](https://images2017.cnblogs.com/blog/1154439/201712/1154439-20171215082838623-2075351265.png)

### ，进一步递推

### ![](https://images2017.cnblogs.com/blog/1154439/201712/1154439-20171215082913935-1643428729.png)

### 由于**矩阵乘法满足结合律**，所它也可以用快速幂算法求解。

### 然后给一些简单的递推式:1.f(n)=a***f(n-1)+b***f(n-2)+c；（a,b,c是常数）****

### ****![](https://img-blog.csdn.net/20160728212613431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)****

### **2.f(n)=c^n-f(n-1) ；（c是常数）**

### ****![](https://img-blog.csdn.net/20160728213053418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)****

# 简单的例子

## Fibonacci数列

考虑![Fibonacci](https://private.codecogs.com/gif.latex?Fibonacci)数列，  ![F(n)=F(n-1)+F(n-2)](https://private.codecogs.com/gif.latex?F%28n%29%3DF%28n-1%29&plus;F%28n-2%29)



将右边两项看做是一个列向量的形式，令 

![X_{n-1}=\left\{\begin{matrix}F_{n-1}\\F_{n-2}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn-1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DF_%7Bn-1%7D%5C%5CF_%7Bn-2%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



很容易得到![Xn](https://private.codecogs.com/gif.latex?Xn)的形式，即 

![X_{n}=\left\{\begin{matrix}F_{n}\\F_{n-1}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DF_%7Bn%7D%5C%5CF_%7Bn-1%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)

现在的任务就是找到一个系数矩阵![A](https://private.codecogs.com/gif.latex?A)，使得![AX_{n-1}=X_n](https://private.codecogs.com/gif.latex?AX_%7Bn-1%7D%3DX_n)，且![A](https://private.codecogs.com/gif.latex?A)需与![n](https://private.codecogs.com/gif.latex?n)无关。 

如果能够找到这个![n](https://private.codecogs.com/gif.latex?n)，则易知![A^{n-1}X_1=X_n](https://private.codecogs.com/gif.latex?A%5E%7Bn-1%7DX_1%3DX_n)，于是可以利用矩阵快速幂计算出![Xn](https://private.codecogs.com/gif.latex?Xn)。这样就可以在![O(logn)](https://private.codecogs.com/gif.latex?O%28logn%29)的时间内计算出指定的![Fibonacci](https://private.codecogs.com/gif.latex?Fibonacci)数。 

这个矩阵很容易找，观察易得 

![A=\left\{\begin{matrix}1&1\\1& 0\end{matrix}\right\}\tag{1}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D1%261%5C%5C1%26%200%5Cend%7Bmatrix%7D%5Cright%5C%7D%5Ctag%7B1%7D)



## Fibonacci数列变种

推广一下，如果令![F_n=aF_{n-1}+bF_{n-2}](https://private.codecogs.com/gif.latex?F_n%3DaF_%7Bn-1%7D&plus;bF_%7Bn-2%7D)，则系数矩阵为 

![A=\left\{\begin{matrix}a&b\\1& 0\end{matrix}\right\}\tag{2}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Da%26b%5C%5C1%26%200%5Cend%7Bmatrix%7D%5Cright%5C%7D%5Ctag%7B2%7D)



# 利用二项式展开构造矩阵

## 计算k次方和

Fibonacci数列只是最简单的例子，对于稍微复杂一点的例子，二项式展开是常用的一项技术。 

考虑计算： 

![S_n=\sum_{i=1}^n{i^k}](https://private.codecogs.com/gif.latex?S_n%3D%5Csum_%7Bi%3D1%7D%5En%7Bi%5Ek%7D)



易得 

![Sn=n^k+Sn-1](https://private.codecogs.com/gif.latex?%5Cdpi%7B120%7D%20Sn%3Dn%5Ek&plus;Sn-1)



如果仿照![Fibonacci](https://private.codecogs.com/gif.latex?Fibonacci)数列，令 

![X_{n-1}=\left\{\begin{matrix}n^k\\S_{n-1}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn-1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dn%5Ek%5C%5CS_%7Bn-1%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



则 

![X_{n}=\left\{\begin{matrix}(n+1)^k\\S_{n}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%28n&plus;1%29%5Ek%5C%5CS_%7Bn%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



此时，可求出 

![A=\left\{\begin{matrix}\left({\frac{n+1}{n}}\right)^{k}&&0\\1&&1\end{matrix}\right\}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%5Cleft%28%7B%5Cfrac%7Bn&plus;1%7D%7Bn%7D%7D%5Cright%29%5E%7Bk%7D%26%260%5C%5C1%26%261%5Cend%7Bmatrix%7D%5Cright%5C%7D)



这个系数矩阵很明显是不能用的，因为它与n有关，无法将递推公式转化为矩阵的幂运算。 

这里需要使用二项式展开。 

![S_n=(n-1+1)^k+S_{n-1}\\=C_k^0(n-1)^k+C_k^1(n-1)^{k-1}+\cdots+C_k^k+S_{n-1}](https://private.codecogs.com/gif.latex?S_n%3D%28n-1&plus;1%29%5Ek&plus;S_%7Bn-1%7D%5C%5C%3DC_k%5E0%28n-1%29%5Ek&plus;C_k%5E1%28n-1%29%5E%7Bk-1%7D&plus;%5Ccdots&plus;C_k%5Ek&plus;S_%7Bn-1%7D)



此时，如果令 

![X_{n-1}=\left\{\begin{matrix}(n-1)^k\\(n-1)^{k-1}\\\vdots\\(n-1)^0\\S_{n-1}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn-1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%28n-1%29%5Ek%5C%5C%28n-1%29%5E%7Bk-1%7D%5C%5C%5Cvdots%5C%5C%28n-1%29%5E0%5C%5CS_%7Bn-1%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



则有 

![X_{n}=\left\{\begin{matrix}n^k\\n^{k-1}\\\vdots\\n^0\\S_{n}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dn%5Ek%5C%5Cn%5E%7Bk-1%7D%5C%5C%5Cvdots%5C%5Cn%5E0%5C%5CS_%7Bn%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



现在的任务与刚才一样，找到一个系数矩阵![A](https://private.codecogs.com/gif.latex?A)，使得![AXn-1=Xn](https://private.codecogs.com/gif.latex?AXn-1%3DXn)，且![A](https://private.codecogs.com/gif.latex?A)需与![n](https://private.codecogs.com/gif.latex?n)无关。 

有关SnSn的递推公式实际上就指明了AA的最后一行。而利用二项式展开很容易得到其他行。 

有 

![A=\left\{\begin{matrix}C_k^0&&C_k^1&&\cdots&&C_k^k&&0\\0&&C_{k-1}^0&&\cdots&&C_{k-1}^{k-1}&&0\\\vdots&&\vdots&&\ddots&&\vdots&&\vdots\\0&&\cdots&&\cdots&&C_0^0&&0\\C_k^0&&C_k^1&&\cdots&&C_k^k&&1\end{matrix}\right\}\tag{3}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DC_k%5E0%26%26C_k%5E1%26%26%5Ccdots%26%26C_k%5Ek%26%260%5C%5C0%26%26C_%7Bk-1%7D%5E0%26%26%5Ccdots%26%26C_%7Bk-1%7D%5E%7Bk-1%7D%26%260%5C%5C%5Cvdots%26%26%5Cvdots%26%26%5Cddots%26%26%5Cvdots%26%26%5Cvdots%5C%5C0%26%26%5Ccdots%26%26%5Ccdots%26%26C_0%5E0%26%260%5C%5CC_k%5E0%26%26C_k%5E1%26%26%5Ccdots%26%26C_k%5Ek%26%261%5Cend%7Bmatrix%7D%5Cright%5C%7D%5Ctag%7B3%7D)

最后有 

![A^{n-1}X_1=X_n](https://private.codecogs.com/gif.latex?A%5E%7Bn-1%7DX_1%3DX_n)



且 

![X_1=\left\{1\space1\space\cdots\space1\right\}^T](https://private.codecogs.com/gif.latex?X_1%3D%5Cleft%5C%7B1%5Cspace1%5Cspace%5Ccdots%5Cspace1%5Cright%5C%7D%5ET)



利用该系数矩阵可以在O(k3logn)O(k3log⁡n)时间内计算出kk次方的和。



## 更一般的例子

再考虑一个一般情况：

![S_n=\sum_{i=1}^n{(ai+b)^k}](https://private.codecogs.com/gif.latex?S_n%3D%5Csum_%7Bi%3D1%7D%5En%7B%28ai&plus;b%29%5Ek%7D)



与刚才几乎一模一样，有 

![S_n=[a(n-1)+(a+b)]^k+S_{n-1}\\=C_k^0a^k(n-1)^k+C_k^1a^{k-1}(a+b)(n-1)^{k-1}+\cdots+C_k^k(a+b)^k+S_{n-1}](https://private.codecogs.com/gif.latex?S_n%3D%5Ba%28n-1%29&plus;%28a&plus;b%29%5D%5Ek&plus;S_%7Bn-1%7D%5C%5C%3DC_k%5E0a%5Ek%28n-1%29%5Ek&plus;C_k%5E1a%5E%7Bk-1%7D%28a&plus;b%29%28n-1%29%5E%7Bk-1%7D&plus;%5Ccdots&plus;C_k%5Ek%28a&plus;b%29%5Ek&plus;S_%7Bn-1%7D)



剩下的步骤，也几乎完全与之前的一样，令 

![X_{n-1}=\left\{\begin{matrix}(n-1)^k\\(n-1)^{k-1}\\\vdots\\(n-1)^0\\S_{n-1}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn-1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%28n-1%29%5Ek%5C%5C%28n-1%29%5E%7Bk-1%7D%5C%5C%5Cvdots%5C%5C%28n-1%29%5E0%5C%5CS_%7Bn-1%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



则 

![X_{n}=\left\{\begin{matrix}n^k\\n^{k-1}\\\vdots\\n^0\\S_{n}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dn%5Ek%5C%5Cn%5E%7Bk-1%7D%5C%5C%5Cvdots%5C%5Cn%5E0%5C%5CS_%7Bn%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



同样，有关SnSn的递推公式实际上就指明了AA的最后一行，其他行则利用二项式展开得到。 

有 

![A=\left\{\begin{matrix}C_k^0&&C_k^1&&\cdots&&C_k^k&&0\\0&&C_{k-1}^0&&\cdots&&C_{k-1}^{k-1}&&0\\\vdots&&\vdots&&\ddots&&\vdots&&\vdots\\0&&\cdots&&\cdots&&C_0^0&&0\\C_k^0a^k&&C_k^1a^{k-1}(a+b)&&\cdots&&C_k^k(a+b)^k&&1\end{matrix}\right\}\tag{4}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DC_k%5E0%26%26C_k%5E1%26%26%5Ccdots%26%26C_k%5Ek%26%260%5C%5C0%26%26C_%7Bk-1%7D%5E0%26%26%5Ccdots%26%26C_%7Bk-1%7D%5E%7Bk-1%7D%26%260%5C%5C%5Cvdots%26%26%5Cvdots%26%26%5Cddots%26%26%5Cvdots%26%26%5Cvdots%5C%5C0%26%26%5Ccdots%26%26%5Ccdots%26%26C_0%5E0%26%260%5C%5CC_k%5E0a%5Ek%26%26C_k%5E1a%5E%7Bk-1%7D%28a&plus;b%29%26%26%5Ccdots%26%26C_k%5Ek%28a&plus;b%29%5Ek%26%261%5Cend%7Bmatrix%7D%5Cright%5C%7D%5Ctag%7B4%7D)



## 更复杂的例子

假设要计算如下和式： 

![S_n=\sum_{i=1}^ni^kk^i](https://private.codecogs.com/gif.latex?S_n%3D%5Csum_%7Bi%3D1%7D%5Eni%5Ekk%5Ei)



同样，将其写成递推公式，有 

![S_n=n^kk^n+S_{n-1}\\=(n-1+1)^kk^{(n-1)+1}+S_{n-1}\\=C_k^0(n-1)^kk^{(n-1)+1}+C_k^1(n-1)^{k-1}k^{(n-1)+1}+\cdots+C_k^kk^{(n-1)+1}+S_{n-1}](https://private.codecogs.com/gif.latex?S_n%3Dn%5Ekk%5En&plus;S_%7Bn-1%7D%5C%5C%3D%28n-1&plus;1%29%5Ekk%5E%7B%28n-1%29&plus;1%7D&plus;S_%7Bn-1%7D%5C%5C%3DC_k%5E0%28n-1%29%5Ekk%5E%7B%28n-1%29&plus;1%7D&plus;C_k%5E1%28n-1%29%5E%7Bk-1%7Dk%5E%7B%28n-1%29&plus;1%7D&plus;%5Ccdots&plus;C_k%5Ekk%5E%7B%28n-1%29&plus;1%7D&plus;S_%7Bn-1%7D)



将与![n](https://private.codecogs.com/gif.latex?n)有关的项抽出来作为列向量，令 

![X_{n-1}=\left\{\begin{matrix}(n-1)^kk^{(n-1)+1}\\(n-1)^{k-1}k^{(n-1)+1}\\\vdots\\(n-1)^0k^{(n-1)+1}\\S_{n-1}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn-1%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%28n-1%29%5Ekk%5E%7B%28n-1%29&plus;1%7D%5C%5C%28n-1%29%5E%7Bk-1%7Dk%5E%7B%28n-1%29&plus;1%7D%5C%5C%5Cvdots%5C%5C%28n-1%29%5E0k%5E%7B%28n-1%29&plus;1%7D%5C%5CS_%7Bn-1%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)



则 

![X_{n}=\left\{\begin{matrix}n^kk^{n+1}\\n^{k-1}k^{n+1}\\\vdots\\n^0k^{n+1}\\S_{n}\end{matrix}\right\}](https://private.codecogs.com/gif.latex?X_%7Bn%7D%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7Dn%5Ekk%5E%7Bn&plus;1%7D%5C%5Cn%5E%7Bk-1%7Dk%5E%7Bn&plus;1%7D%5C%5C%5Cvdots%5C%5Cn%5E0k%5E%7Bn&plus;1%7D%5C%5CS_%7Bn%7D%5Cend%7Bmatrix%7D%5Cright%5C%7D)

同样，有关Sn的递推公式说明了系数矩阵AA的最后一行。而其他行仍然可以由二项式展开得到，只是相差了一个系数k而已，这很容易解决。 

最后，有 

![A=\left\{\begin{matrix}kC_k^0&&kC_k^1&&\cdots&&kC_k^k&&0\\0&&kC_{k-1}^0&&\cdots&&kC_{k-1}^{k-1}&&0\\\vdots&&\vdots&&\ddots&&\vdots&&\vdots\\0&&\cdots&&\cdots&&kC_0^0&&0\\C_k^0&&C_k^1&&\cdots&&C_k^k&&1\end{matrix}\right\}\tag{5}](https://private.codecogs.com/gif.latex?A%3D%5Cleft%5C%7B%5Cbegin%7Bmatrix%7DkC_k%5E0%26%26kC_k%5E1%26%26%5Ccdots%26%26kC_k%5Ek%26%260%5C%5C0%26%26kC_%7Bk-1%7D%5E0%26%26%5Ccdots%26%26kC_%7Bk-1%7D%5E%7Bk-1%7D%26%260%5C%5C%5Cvdots%26%26%5Cvdots%26%26%5Cddots%26%26%5Cvdots%26%26%5Cvdots%5C%5C0%26%26%5Ccdots%26%26%5Ccdots%26%26kC_0%5E0%26%260%5C%5CC_k%5E0%26%26C_k%5E1%26%26%5Ccdots%26%26C_k%5Ek%26%261%5Cend%7Bmatrix%7D%5Cright%5C%7D%5Ctag%7B5%7D)





