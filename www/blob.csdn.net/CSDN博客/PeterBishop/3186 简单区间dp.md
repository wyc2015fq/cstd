# 3186 简单区间dp - PeterBishop - CSDN博客





2019年04月14日 10:39:12[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：7
个人分类：[POJ](https://blog.csdn.net/qq_40061421/article/category/7589386)









```cpp
/* ***********************************************
Author        :PeterBishop
Created Time  :2019年04月14日 星期日 10时02分46秒
File Name     :t.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <string>
/*
    dp[i][j]记录取i-j能获得的最大价值
    从取最后一个开始想，取最后一个i是a[i]*n, 上次取得就是dp[i-1][i]或dp[i][i+1]
    状态转移方程：dp[i][j] = max(dp[i+1][j]+(n-k)*a[i], dp[i][j-1]+(n-k)*a[j]),  (k是ij区间长度)
*/
using namespace std;
const int maxn = 2005;
int a[maxn], dp[maxn][maxn];
int main()
{
	freopen("in.txt","r",stdin);
	int n;
	while(cin>>n){
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=n;i++){
			cin>>a[i];
			dp[i][i]=n*a[i];
		}
		for(int l=1;l<n;l++){
			for(int i=1;i+l<=n;i++){
				int j=i+l;
				dp[i][j]=max(dp[i+1][j]+(n-l)*a[i],dp[i][j-1]+(n-l)*a[j]);


			}
		}

		cout<<dp[1][n]<<endl;
	}
    
    
    
    return 0;
}
```





