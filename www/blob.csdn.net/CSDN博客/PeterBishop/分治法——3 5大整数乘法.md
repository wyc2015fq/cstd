# 分治法——3.5大整数乘法 - PeterBishop - CSDN博客





2018年08月25日 11:41:34[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：63








![](https://img-blog.csdn.net/20180824232825293?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824232929631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180824233200111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824233404475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824233547943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824233812658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180824233911679?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180825113916889?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180825113951260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180825114103177?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180825114122796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```cpp
#include<stdlib.h>
#include<cstring>
#include<iostream>
#define M 100
using namespace std;

char sa[1000];
char sb[1000];
typedef struct Node {
	int s[M];
	int l;//字符串长度
	int c;
}*pNode;
void cp(pNode src, pNode des, int st, int l)//一个数分成两个数
{
	int i, j;//从st位置开始取l个数
	for (i = st, j = 0; i < st + l; i++, j++)
	{
		des->s[j] = src->s[i];
	}
	des->l = l;
	des->c = src->c + st;//次幂
}
void add(pNode pa, pNode pb, pNode ans)
{
	int i, cc, k, palen, pblen, len;
	int ta, tb;//ta、tb分别记录a、b相加时对应位上的数
	pNode temp;
	if (pa->c < pb->c)//保证a的次幂大
	{
		temp = pa;
		pa = pb;
		pb = temp;
	}
	ans->c = pb->c;//结果的次幂是较小的那个
	cc = 0;//初始化进位为0
	palen = pa->l + pa->c;
	pblen = pb->l + pb->c;
	if (palen > pblen)
		len = palen;
	else
		len = pblen;
	k = pa->c - pb->c;//a左侧需要补0的个数
	for (i = 0; i < len - ans->c; i++)
	{
		if (i < k)
			ta = 0;
		else
			ta = pa->s[i - k];
		if (i < pb->l)
			tb = pb->s[i];
		else
			tb = 0;//b的数字先取完右侧补0
		if (i >= pa->l + k)
			ta = 0;//a的数字先取完右侧补0
		ans->s[i] = (ta + tb + cc) % 10;
		cc = (ta + tb + cc) / 10;
	}//因为是倒序存储的所以这样去补0
	if (cc)
		ans->s[i++] = cc;
	ans->l = i;
}
void mul(pNode pa, pNode pb, pNode ans)
{
	int i, cc, w;
	int ma = pa->l >> 1, mb = pb->l >> 1;//a、b长度的一半
	Node ah, al, bh, bl;
	Node t1, t2, t3, t4, z;
	pNode temp;
	if (!ma || !mb)//如果其中一个为1
	{
		if (!ma)
		{
			temp = pa;
			pa = pb;
			pb = temp;
		}//保证b的长度是1
		ans->c = pa->c + pb->c;//结果的次幂是和
		w = pb->s[0];//b的值
		cc = 0;
		for (i = 0; i < pa->l; i++)//模拟乘法
		{
			ans->s[i] = (w*pa->s[i] + cc) % 10;
			cc = (w*pa->s[i] + cc) / 10;
		}
		if (cc)
			ans->s[i++] = cc;
		ans->l = i;
		return;
	}
		cp(pa, &ah, ma, pa->l - ma);
		cp(pa, &al, 0, ma);
		cp(pb, &bh, mb, pb->l - mb);
		cp(pb, &bl, 0, mb);

		mul(&ah, &bh, &t1);
		mul(&ah, &bl, &t2);
		mul(&al, &bh, &t3);
		mul(&al, &bl, &t4);

		add(&t3, &t4, ans);
		add(&t2, ans, &z);
		add(&t1, &z, ans);
}
```



![](https://img-blog.csdn.net/20180825113820612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



