# 过河问题 - PeterBishop - CSDN博客





2018年03月26日 21:03:45[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：201








```cpp

```

思路：

贪心思想（一般都是先排序）

关键步骤：每次从此岸到彼岸移动的两个人要么这两个人中有一个是最快的那个人，要么这两个人到达彼岸后再也不回来。即：要么最快+最慢，要么最慢+次慢。

1.对N个人过河时间从小到大排序。speed[i]



2.分情况讨论：

> 
⑴当n = 1，直接过河。sum = speed[0]

(2)当n = 2，直接过河。 sum = speed[1]

(3)当n = 3，无论怎么过河， sum = speed[0] + speed[1] + speed[2] 

(4)当n = 4，设从小到大排序后位a,b,c,d


> 
> 
用最小的来送：b + a + c + a + d = 2a + b + c + d（a,b过去，a回来，a,c过去，a回来，a,d过去）

（这种一开始想不到。。。）两小送两大：b + a + d + b + b = a + 3b + d(a,b过去，a回来，c,d过去，b回来，a,b过去）



> 
> 
sum = min(2a + b + c + d, a + 3b + d)



> 
(5)当n > 4，设从小到大排序后位a,b,……,c,d，大于4个人，目标就是把最大的两个人送过去。


> 
> 
用最小的来送：d + a + c + a = 2a + c + d(a,d过去，a回来，a,c过去，a回来）

两小送两大： b + a + d + b = a + 2b + d(a,b过去，a回来，c,d过去，b回来）



> 
> 
循环：sum = min(2a + b + c + d, a + 3b + d)，直到n <= 4时候结束。



```cpp

```

```cpp

```

```cpp
#include<iostream>//非常经典的过河问题，我考虑还是太少了，学到了经典题型，将多人问题化为4人问题，贪心
#include<cstdio>
#include<algorithm>
using namespace std;
int speed[1010];

int main()
{
	int Ncase;
	scanf("%d", &Ncase);
	while(Ncase--)
	{
		int n, sum = 0;
		scanf("%d", &n);
		for(int i = 0; i < n; i++)
			scanf("%d", &speed[i]);
		sort(speed, speed + n); //从小到大排序
		while(n)
		{
			if(n == 1)
			{
				sum += speed[0];
				break;
			}
			else if(n == 2)
			{
				sum += speed[1];
				break;
			}
			else if(n == 3)
			{
				sum += speed[0] + speed[1] + speed[2];
				break;
			}
			else if(n == 4)
			{
				if(speed[2] + speed[0] - 2 * speed[1] <= 0)
					sum += (2 * speed [0] + speed[1] + speed[2] + speed[3]);
				else
					sum += (speed[0] + 3 * speed[1] + speed[3]);
				break;
			}
			else
			{
				if(speed[n - 2] - 2 * speed[1] + speed[0] <= 0)
                    sum += (speed[n - 1] + speed[n - 2] + 2 * speed[0]);
                else
                    sum += (speed[n - 1] + 2 * speed[1] + speed[0]);
				n -= 2;
			}
		}
		printf("%d\n", sum);
	}
	return 0;
}
```




