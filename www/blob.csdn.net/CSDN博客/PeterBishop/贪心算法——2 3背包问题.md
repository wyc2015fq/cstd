# 贪心算法——2.3背包问题 - PeterBishop - CSDN博客





2018年08月17日 15:15:29[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：214








![](https://img-blog.csdn.net/20180817144638394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 问题描述如上，假设山洞有n种宝物，每一种有对应的种类w和价值v，毛驴的运载能力有限，只能运走m质量的宝物，一种宝物只能拿一样，但可以分割，如何使得总价值最大？

### 我们可以采用贪心策略，每次挑选单位质量价值最大的宝物，从而达到最优解 ，图解如下：

![](https://img-blog.csdn.net/20180817145226897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20180817145240561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



```cpp
#include<iostream>
#include<algorithm>
const int M=1000005;
using namespace std;
struct three{
    double weight;
    double value;
    double cost_performance;
}s[M];
bool cmp(three a,three b)
{
    return a.cost_performance>b.cost_performance;
}
int main(int argc, char const *argv[])
{
    int n;
    double m;
    cin>>n>>m;//输入宝物数量n和毛驴承载量m
    for(int i=0;i<n;i++)
    {
        cin>>s[i].weight>>s[i].value;
        s[i].cost_performance=s[i].value/s[i].weight;
    }
    sort(s,s+n,cmp);//按照性价比由大到小
    double sum=0;//记录结果
    for(int i=0;i<n;i++)
    {
        if(m>s[i].weight)//如果还能装得下
        {
            m-=s[i].weight;
            sum+=s[i].value;
        }
        else
        {
            sum+=m*s[i].cost_performance;
            break;//切割装入
        }
    }
    cout<<sum<<endl;
    return 0;
}
```







