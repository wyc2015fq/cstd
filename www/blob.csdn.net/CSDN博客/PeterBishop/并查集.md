# 并查集 - PeterBishop - CSDN博客





2018年10月03日 22:50:40[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：55
个人分类：[数据结构与算法](https://blog.csdn.net/qq_40061421/article/category/7898328)









![](https://img-blog.csdn.net/20181003221436663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221545216?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221612877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221629950?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221659577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221717572?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181003221728947?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181003221747507?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 代码实现如下：

```cpp
const int N=100;
int father[N];
void Init(int n){
    for(int i=1;i<=n;i++)//初始化
        father[i]=i;
}

int Find(int x){//找祖先
    if(x!=father[x])
        father[x]=Find(father[x]);//把当前结点的到其祖宗路径上的所有结点的值改为祖宗的值
    return father[x];//返回祖宗的值
}

int Merge(int a,int b){
    int p=Find(a);//找出对应的值
    int q=Find(b);
    if(p==q)
        return 0;//不需要合并，不必计算成本
    if(p>q)//将小的值赋值给大的
        father[p]=q;
    else
        father[q]=p;
    return 1;//合并计算总成本
}
```





