# 1495可乐分配问题也可以BFS - PeterBishop - CSDN博客





2018年04月15日 15:16:53[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：48
个人分类：[HDOJ](https://blog.csdn.net/qq_40061421/article/category/7502192)









```cpp
#include<cstdio>//一开始找规律，虽然总感觉能找到但是很浪费时间其实，然后看到了BFS简直豁然开朗
#include<cstring>
#include<algorithm>
#include<queue>
#define N 100+5
using namespace std;

struct node{
    int a,b,s,t;//a是大杯，b是小杯，s是可乐，t代表次数
}st;//深刻理解了BFS不止是迷宫图什么的，只要和最短最少有关就可以考虑，只要有起点和终点，有搜索“方向”就可以搜索
int a,b,s;
int vis[N][N]; 
int bfs()//这题的“方向”就是三个杯子互相倒水，一共六种可能，也就是六个方向
{
    queue<node> q;
    memset(vis,0,sizeof(vis));
    st.a=0; st.b=0; st.s=s; st.t=0;
    q.push(st);
    vis[a][b]=1;
    while(!q.empty())
    {
        node u=q.front(),v;//这个v一定要新建，不能六种方向都修改原值
        //能平分的条件是可乐瓶和容量大（a）的杯子都装着最开始一半的可乐。
        if(u.a==s/2 && u.s==s/2)
            return u.t;
        if(u.s && u.a!=a)   //s->a
        {
            int c=a-u.a;
            if(u.s>=c) v.a=a,v.s=u.s-c;
            else v.a=u.a+u.s,v.s=0;
            v.b=u.b; v.t=u.t+1;
            if(!vis[v.a][v.b])  //只从之前没有出现的状态往下推，下同。
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        if(u.s && u.b!=b)   //s->b
        {
            int c=b-u.b;
            if(u.s>=c) v.b=b,v.s=u.s-c;
            else v.b=u.b+u.s,v.s=0;
            v.a=u.a; v.t=u.t+1;
            if(!vis[v.a][v.b])
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        if(u.a && u.s!=s)   //a->s
        {
            int c=s-u.s;
            if(u.a>=c) v.s=s,v.a=u.a-c;
            else v.s=u.s+u.a,v.a=0;
            v.b=u.b; v.t=u.t+1;
            if(!vis[v.a][v.b])
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        if(u.a && u.b!=b)   //a->b
        {
            int c=b-u.b;
            if(u.a>=c) v.b=b,v.a=u.a-c;
            else v.b=u.b+u.a,v.a=0;
            v.s=u.s; v.t=u.t+1;
            if(!vis[v.a][v.b])
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        if(u.b && u.a!=a)   //b->s
        {
            int c=a-u.a;
            if(u.b>=c) v.a=a,v.b=u.b-c;
            else v.a=u.a+u.b,v.b=0;
            v.s=u.s; v.t=u.t+1;
            if(!vis[v.a][v.b])
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        if(u.b && u.s!=s)   //b->a
        {
            int c=s-u.s;
            if(u.b>=c) v.s=s,v.b=u.b-c;
            else v.s=u.s+u.b,v.b=0;
            v.a=u.a; v.t=u.t+1;
            if(!vis[v.a][v.b])
            {
                q.push(v);
                vis[v.a][v.b]=1;
            }
        }
        q.pop();
    }
    return 0;   //所有扩展的状态都不能使之平分。
}
int main()//这题其实很好的说明了，搜索的方向其实就是可能性，表示出来也就写出来了
{
    while(scanf("%d%d%d",&s,&a,&b),s||a||b)
    {
        if(s%2)//奇数肯定不可以的
        {
            puts("NO");
            continue;
        }
        if(a<b) swap(a,b); //这里使a作大号杯，方便bfs条件的判定。
        int ans=bfs();
        if(ans) printf("%d\n",ans);
        else puts("NO");
    }
    return 0;
}
```





