# 1321 棋盘问题 - PeterBishop - CSDN博客





2018年07月25日 12:58:04[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：28
个人分类：[POJ](https://blog.csdn.net/qq_40061421/article/category/7589386)









```cpp
#include<stdio.h>
int n, k;
char s[8][8];
int ans = 0;
int check(int x, int y)
{
	if (s[x][y] == '#')
	{
		for (int i = 0; i < n; i++)
		{
			if (s[i][y] == '*')
				return 0;
		}
		for (int i = 0; i < n; i++)
		{
			if (s[x][i] == '*')
				return 0;
		}
		return 1;
	}
	return 0;
}
void dfs(int x, int y,int t)
{
	if (t == k)
	{
		ans++;
		return;
	}
	if (x == n)
	{
		return;
	}
	if (y == n)
		dfs(x + 1, 0, t);
	for (int i = 0; i < n; i++)
	{
		if (check(x, i))
		{
			s[x][i] = '*';
			dfs(x+1 ,0, t + 1);//主要这里应该直接去下一行找，想清楚就好
			s[x][i] = '#';
		}
	}
	dfs(x + 1, 0, t);//这一行可能性都return回来了进入下一行
}
void main()
{
	while (scanf("%d %d", &n, &k)!=EOF)
	{
		ans = 0;
		if (n == -1 && k == -1)
			break;
		for (int i = 0; i < n; i++)
		{
			scanf("%s", s[i]);
		}
		dfs(0, 0, 0);
		printf("%d\n", ans);
	}
}
```





