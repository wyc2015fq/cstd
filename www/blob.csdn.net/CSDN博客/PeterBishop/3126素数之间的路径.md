# 3126素数之间的路径 - PeterBishop - CSDN博客





2018年04月16日 18:12:18[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：22








```cpp
#include <iostream>
#include <queue>
using namespace std;
#define MAXV 10000
bool prime[MAXV];

void init() //对素数打表，将素数的值设置为下标省去了查表
{	
	int i, j;
	for (i = 1000; i <= MAXV; i++) 
	{
		for (j = 2; j<i; j++)
			if (i%j == 0) 
			{
				prime[i] = false;
				break;
			}
		if (j == i) 
			prime[i] = true;
	}
}

int bfs(int first, int last) 
{
	bool dis[MAXV];
	queue <int>q;
	int v, i, j, temp, vtemp, count[MAXV], t[4];
	memset(dis, false, sizeof(dis));//两个数组其实也可以用结构体
	memset(count, 0, sizeof(count));

	q.push(first);
	dis[first] = true;//标记

	while (!q.empty()) 
	{
		v = q.front();
		q.pop();

		t[0] = v / 1000;
		t[1] = v % 1000 / 100;
		t[2] = v % 100 / 10;
		t[3] = v % 10;//位数

		for (j = 0; j<4; j++) //对四个位数一一尝试
		{
			temp = t[j];
			for (i = 0; i < 10; i++)//0-9一一尝试
			{
				if (i != temp)
				{
					t[j] = i;
					vtemp = t[0] * 1000 + t[1] * 100 + t[2] * 10 + t[3];
					if (!dis[vtemp] && prime[vtemp])
					{
						count[vtemp] = count[v] + 1;
						dis[vtemp] = true;
						q.push(vtemp);
					}
					if (vtemp == last) 
						return count[vtemp];
				}
			}
			t[j] = temp;//被修改后还原
		}
		if (v == last) 
			return count[v];
	}
	return -1;
}

int main() {
	int n, a, b, key;
	init();
	scanf("%d", &n);
	while (n--) 
	{
		scanf("%d%d", &a, &b);
		key = bfs(a, b);
		if (key != -1) 
			printf("%d\n", key);
		else 
			printf("Impossible\n");
	}
	return 0;
}
```




