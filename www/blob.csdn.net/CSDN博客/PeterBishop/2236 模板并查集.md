# 2236 模板并查集 - PeterBishop - CSDN博客





2019年02月14日 23:46:51[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：22
个人分类：[POJ](https://blog.csdn.net/qq_40061421/article/category/7589386)









### 题目很简单，但是弄这个输入有点麻烦，手生了

```cpp
/* ***********************************************
Author        :PeterBishop
Created Time  :Thu 14 Feb 2019 16:44:13 CST
File Name     :t.cpp
Origin        :P O J  2236
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;
int N,d;
struct Node
{
	int x,y;
	bool work;
	int next;
}Coms[1002];
int find(int x){
	return x==Coms[x].next?x:find(Coms[x].next);
}
void Union(Node a,Node b){
	int r1=find(a.next);
	int r2=find(b.next);
	if(r1!=r2){
		if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<=d*d)
			Coms[r2].next=r1;
	}
}
int main()
{
	freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	cin>>N>>d;
	for(int i=1;i<=N;i++){
		cin>>Coms[i].x>>Coms[i].y;
		Coms[i].work=false;
		Coms[i].next=i;
	}
	char s;
	while(scanf("\n%c", &s) != EOF){
		if(s=='O')
		{
			int x;
			scanf("%d",&x);
			Coms[x].work=true;
			for(int i=1;i<=N;i++){
				if(i!=x&&Coms[i].work){
					Union(Coms[x],Coms[i]);
				}
			}
		}
		else{
			int from,to;
			scanf("%d%d",&from,&to);
			if(find(from) == find(to))
				printf("SUCCESS\n");
			else
				printf("FAIL\n");

		}

	}




    return 0;
}
```





