# 面向对象(六)——继承 - PeterBishop - CSDN博客





2018年09月29日 14:44:40[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：61
个人分类：[Java学习](https://blog.csdn.net/qq_40061421/article/category/8087498)









### 这节课我们来学面向对象的第二个特征——继承

### 继承有什么用？

###        多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

### 被继承的类叫父类，继承的类叫子类，比如类A继承类B，则B为父类，A为子类

### 继承的关键字为extends

### 语法：

### class A extends B{

###               …

### }

### 子类可以继承父类的所有属性和方法，子类可以通过super关键字来调用父类的属性和方法

### Demo:

### class Person{    protected int id;    protected int age;    public Person(){}    public Person(int id, int age) {        this.id = id;        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}class Teacher extends Person{    public Teacher(){}    public Teacher(int id, int age)    {        super(id,age);  //调用父类构造器    }}public class Demo{    public static void main(String[] args) {        Teacher teacher = new Teacher(1,2);        //子类可以直接继承父类的方法        System.out.println(teacher.getId());        System.out.println(teacher.getAge());    }}

### 运行结果：

### 1

### 2

### 注意:

###        在java中一个父类可以有多个子类，但一个子类只可以有一个父类

###        父类类型的引用变量可以指向子类对象，即以下这条语句是合法的

###        Person person = new Teacher();

###        子类类型的引用变量不能执行父类对象，即以下这条语句是非法的:

###        Teacher teacher = new Person();       //本条语句是非法的

###        Jdk提供了一个类叫Object

###        Java里所有类默认继承Object类

### 方法重写:

###        子类可以重写(也叫覆盖)父类的方法，重写是指在子类中有一个和父类方法名相同且参数表也完全相同的方法，当子类重写父类方法后，子类对象调用方法时会调用自己类里重写的方法

### Demo:

### class Person{    protected int id;    protected int age;    public Person(){}    public Person(int id, int age) {        this.id = id;        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}class Teacher extends Person{    public Teacher(){}    public Teacher(int id, int age)    {        super(id,age);  //调用父类构造器    }    @Override    public int getAge() {        return 18;    }}public class Demo{    public static void main(String[] args) {        Person teacher = new Teacher(1,2);        //子类可以直接继承父类的方法        System.out.println(teacher.getId());        System.out.println(teacher.getAge());    }}

### 解释:

###        在上面的例子中，Teacher类重写了父类Person的getAge方法，导致Teacher的getAge方法永远返回18(永远18岁，yeah!)，然后在main方法中Perosn类型的引用变量teacher指向了Teacher类型的对象，而在调用teacher.getAge()时返回的是18，由此可见在调用方法时不是看引用变量是什么类型，而是看引用变量引用的对象是什么类型

![](https://img-blog.csdn.net/20181010211810764?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181010211817876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181010211826606?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181010211849972?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181010211943965?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20181010212418261?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181010212450587?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



![](https://img-blog.csdn.net/20181010212515732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDYxNDIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



