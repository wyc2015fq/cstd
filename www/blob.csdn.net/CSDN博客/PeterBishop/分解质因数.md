# 分解质因数 - PeterBishop - CSDN博客





2018年10月07日 21:00:30[PeterBishop0](https://me.csdn.net/qq_40061421)阅读数：256










质数（prime number）又称素数，有无限个。一个大于1的[自然数](http://baike.baidu.com/view/19911.htm)，除了1和它本身外，不能被其他自然数[整除](http://baike.baidu.com/view/135932.htm)（除0以外）的数称之为素数（质数）；否则称为[合数](http://baike.baidu.com/subview/1301/8862554.htm)。根据[算术基本定理](http://baike.baidu.com/view/651164.htm)，每一个比1大的整数，要么本身是一个质数，要么可以写成一系列质数的乘积；而且如果不考虑这些质数在乘积中的顺序，那么写出来的形式是唯一的。最小的质数是2。

          质因数（或质因子）在[数论](http://baike.baidu.com/view/17568.htm)里是指能整除给定正[整数](http://baike.baidu.com/view/71484.htm)的[质数](http://baike.baidu.com/view/10626.htm)。两个没有共同质因子的正整数称为[互质](http://baike.baidu.com/view/731400.htm)。因为1没有质因子，[1](http://baike.baidu.com/view/26506.htm)与任何正整数（包括1本身）都是互质。正整数的[因数分解](http://baike.baidu.com/view/321529.htm)可将正整数表示为一连串的质因子相乘，质因子如重复可以[指数](http://baike.baidu.com/view/194477.htm)表示。根据[算术基本定理](http://baike.baidu.com/view/651164.htm)，任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。综上所述质因数分解是唯一的。

质因数分解的经典算法是：



**Pollard Rho因数分解（Prime decomposition）**

1975年，John M. Pollard提出了第二种因数分解的方法，Pollard Rho快速因数分解。该算法时间复杂度为O（n^(1/4)）。



分解质因数代码：

将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。

程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成： 

(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。

(2)如果n<>k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,

　重复执行第一步。

(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。



另外在编写程序的时候还要用到的一个定理是：

**判断一个自然数是否是质数，只用看从2到根号N是否能整除N。也就是说，**

一个合数的最小正因子必小于根号N。
对于上面定理的简单思考证明：

首先，约数是成对出现的。比如24,你找到个约数3,那么一定有个约数8,因为24/3=8。

然后，这对约数必须一个在根号n之前，一个在根号n之后。因为都在根号n之前的话，

乘积一定小于n（根号nX根号n=n），同样，都在根号n之后的话，乘积一定大于n。

所以，如果你在根号n之前都找不到约数的话，那么根号n之后就不会有了。

如果N (N>=2)没有小于等于根号N，大于1的约数，那么N必然是质数。

假设N不是质数，并且不含有小于等于根号N的约数。

因为N是合数，那么N必然可以写成N=p*q，并且p和q大于1。根据假设，p和q都大于根号N。那么p*q>N，矛盾

具体程序：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a,n,i,k,num[100];
    while(cin>>n)
    {
        a=n;
        if(n==0)
            break;
        if(n==1)
            cout<<"1=1"<<endl;
        else
        {
            i=2;
            k=0;
            while(n!=1)
            {
                if(n%i==0)
                {
                    num[k]=i;
                    k++;
                    n=n/i;
                }
                else
                    i++;
            }
            cout<<a<<"=";
            for(i=0;i<k;i++)
            {
                cout<<num[i];
                if(i<k-1)
                    cout<<"*";
            }
            cout<<endl;
        }
    }
    return 0;
}
```





