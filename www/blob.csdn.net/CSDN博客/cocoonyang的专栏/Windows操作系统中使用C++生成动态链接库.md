# Windows操作系统中使用C++生成动态链接库 - cocoonyang的专栏 - CSDN博客





2019年01月09日 11:58:34[cocoonyang](https://me.csdn.net/cocoonyang)阅读数：139








重用是软件工程的重要方法。软件系统中可重用的部分包括：数据，文档，算法，代码，设计模式，软件架构以及环境等多方面内容。根据不同的抽象层次，软件代码重用大致可分为三类:  软件实现层重用，即软件源代码的重用；软件设计层重用，即重用软件系统的设计信息；软件架构层重用，即重用软件系统的架构。共享库是软件源代码重用的方法，动态链接库是保存软件外部共享库的文件格式。

通过外部共享库实现软件重用的流程有三步:

1) 生成外部共享库文件，

2) 编译整合外部共享库与宿主程序，

3) 启动宿主程序，宿主程序进程加载外部共享库。
# 外部共享库格式

动态链接指操作系统将外部共享库从持久性存储区（persistent storage）复制到内存，通过填写跳转表和重新定位指针等操作，把外部共享库注入当前进程[2]。不同操作系统中实现动态链接方法以及使用的文件格式各不相同。 动态链接库(Dynamic-link library, DLL) 是Windows操作系统在动态链接时使用的外部共享库的文件格式。

根据编译和使用方式的不同，Windows操作系统的外部共享库分为两种: 动态链接库和静态链接库，如下表所示。在使用外部共享库时，首先要将外部共享库代码编译成动态链接库文件或静态链接库文件。然后将链接库文件和宿主程序代码编译成宿主可执行文件。 Windows操作系统中外部共享库主要使用两类文件，文件名后缀分别是: .lib 和.dll。
||静态链接库|动态链接库|
|----|----|----|
|内存使用|每一个宿主软件运行时都有一份静态链接库|多个宿主软件运行时，内存只需要复制一个动态链接库|
|软件依赖|宿主程序运行时不依赖静态链接库文件|宿主程序运行时依赖动态链接库文件|
|文件|.lib文件|.lib文件, .dll文件|
|软件更新|整个软件都需要更新|宿主程序和库文件相互独立更新|
|版本冲突|无|非常严重|

VS(Visual Studio)构造静态链接库时，导出函数的声明和实现都放在lib文件中。 静态链接库中函数代码插入宿主程序中。宿主程序运行时不依赖lib文件。

VS构造动态链接库时，会同时生成lib文件和dll文件。动态链接库中lib文件的功能相当于头文件，只包含导出函数的声明，函数的实现放在dll文件中。主程序运行时依赖dll文件。

一个动态链接库实例可以被多个程序共同使用。这能实现代码共享并且可以隐藏实现软件代码细节，便于软件升级。 但是，这也带来一定的副作用。多个程序依赖于同一个动态链接库，当这些程序升级步调不一致，造成软件版本冲突，会引发一系列灾难性后果，也就是所谓的"DLL Hell".

# 动态链接库的调用方式

宿主程序加载动态链接库的方法有两种: 显式加载 和 隐式加载

## 显式加载

宿主程序代码中通过LoadLibrary()函数 和 FreeLibrary()函数指定动态链接库的加载和卸载的时机。

宿主程序启动后，宿主程序进程在遇到LoadLibrary()函数时才将动态链接库加载到进程的内存空间。

通过显式加载方法使用动态链接库，在编译整合动态链接库与宿主程序时只有需要使用dll文件。

## 隐式加载

隐式加载的宿主程序代码中没有直接使用LoadLibrary()函数 和 FreeLibrary()函数的代码，因此称为隐式加载。

隐式加载的宿主程序在启动时搜索到dll文件以后，将动态链接库加载到宿主程序进程的内存空间。 隐式加载实际上也是通过LoadLibrary()函数实现加载工作。

通过隐式加载方法使用动态链接库，在编译整合动态链接库与宿主程序时需要使用lib文件和dll文件。

# 函数调用协定

由于操作系统，编译器，硬件等环境因素的不同，程序使用的函数调用方法在寄存器使用，内存堆栈管理，函数参数传递，函数名修饰符等方面会有较大差异。每一种函数调用方式称为函数调用协定(Function Calling Convention)。

函数调用协定主要规定调用函数时下列几方面事项:
- 函数参数在内存中的顺序
- 传递参数的方式
- 函数调用方要保留CPU寄存器
- 内存堆栈的使用方式

下面是运行于x86架构微处理器的程序常用的函数调用协定 [3] [4]
|协议名称|函数参数在堆栈中的顺序|清理堆栈中的函数参数占用的内存空间|备注|
|----|----|----|----|
|cdecl|RTL(right-to-left)|函数调用方||
|sdtcall|RTL|函数被调用方||
|Pascal|LTR(left-to-right)|函数被调用方||
|fastcall|LTR|函数被调用方||
|thiscall|RTL|函数被调用方||
|vectorcall|RTL|||

在C语言源代码中，如果改变函数调用协定，需将协定的标识符放在函数名和函数返回值类型声明之间. 编译器根据调用协定生成相应的机器语言代码。汇编代码的助记符与机器语言指令一一对应。查看函数的汇编代码，能深入了解不同函数调用协定的实现细节。

下面通过几个样例展示不同函数调用协定之间的差异。 样例中使用的函数名为test, 它接受两个整数型参数，并返回这两个整数的和。在主函数main中，将整数1和3作为参数，调用函数test.  具体代码如下:

```
int test(int a, int b)
{
	return (a + b);
}

int main()  
{  
    test(1, 3);
    return 0;  
}
```

将上述源代码保存到名为foo.cc文件中.  生成汇编代码, 使用编译参数 /FA， 然后再控制台环境使用cl.exe编译:

```
cl /FA foo.cc
```

编译完成后，会生成可执行文件foo.exe. 编译过程中生成的汇编代码会保存在foo.asm中。

## cdecl Calling Convention

本样例中，test函数使用cdecl调用协定，具体C语言源代码如下:

```
int cdecl test(int a, int b)
{
	return (a + b);
}

int main()  
{  
    test(1, 3);
    return 0;  
}
```

汇编代码详解( 堆栈的工作原理, 请看参考文献[8,9,10])

```
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	 foo.cc
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?test@@YAHHH@Z					; test
PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_main	PROC
; File  \foo.cc
; Line 7   ;  假设EBP = 0,  现在堆栈为空，则 ESP = 0,
	push	ebp   ;  保存 main函数 堆栈基地址,   将EBP压入堆栈， ESP自动减4，则 现在 ESP = -4,
	mov	ebp, esp    ;  更新ebp，将当前堆栈顶的地址( 也就是下一个函数的堆栈的基地址) 放入ebp，
	                          ;  更新后， EBP = -4,  ESP = -4,
; Line 8
	push	3   ;  将第二个参数压入堆栈，ESP自动减4，则 现在 ESP = -8,
	push	1   ;  将第一个参数压入堆栈，ESP自动减4，则 现在 ESP = -12,
	call	?test@@YAHHH@Z				; test
	add	esp, 8   ;   强制将ESP指针上移8位地址，则 现在 ESP = -12+8 = -4,  
                      	;   函数调用方负责清理堆栈 
; Line 9
	xor	eax, eax  ;   让  EAX = 0,  也就是 return 0; 这句代码中的那个 0  
; Line 10
	pop	ebp  ;   从堆栈中推出EBP,  EBP 恢复为 0。 这时 ESP自动加4，现在 ESP = -4+4 = 0.  
	                ;  返回值保存在EAX中，EBP, ESP都恢复为初始值，现在可以安全退出了
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT  
_a$ = 8							; size = 4
    ;   为什么 这里_a$ 设为 8 ?  
    ;   在调用函数时，默认要将调用test函数后下一条机器语言指令的地址压入堆栈, ESP会自动减4.
    ;   （在函数调用结束后，默认将这个地址弹出堆栈, ESP会自动减4，这样一增一减，相互抵消. )     
    ;   习惯上在函数开始执行前要保存这个函数堆栈基地址EBP到堆栈中，即 push ebp，ESP也会减4，
    ;   这样  4 + 4 = 8      
    ;  运行到这里,调用test后的下一条机器语言指令的地址已经压入堆栈, 现在 ESP = -12 - 4 = -16 
_b$ = 12						; size = 4
?test@@YAHHH@Z PROC					; test
; File  foo.cc
; Line 2
	push	ebp   ; 保存test函数堆栈基地址, 将EBP压入堆栈中, ESP自动减4, 现在 ESP = -16 - 4 = -20  
	mov	ebp, esp  ;  现在  EBP = ESP = -20
; Line 3
	mov	eax, DWORD PTR _a$[ebp]  ;  堆栈中的地址: EBP + _a$ = -20 + 8 = -12,  参看指令 push 1   
	                                  ; 保存参数值为 1,  也就是第一个参数 
	add	eax, DWORD PTR _b$[ebp] ;   堆栈中的地址:EBP + _a$ = -20 + 12 = -8, 参看指令 push 3  
	                                ; 保存参数值为 3,  也就是第二个参数
; Line 4
	pop	ebp
	ret	0
?test@@YAHHH@Z ENDP					; test
_TEXT	ENDS
END
```

Caller 汇编代码

```
push	ebp
	mov	ebp, esp
; Line 10
	push	2
	push	1
	call	?test@@YAHHH@Z				; test
	add	esp, 8   ; 清理堆栈
```

使用内存传递参数.  在调用test(int a, int b)函数前，先将函数的两个参数自右向左压入栈，先压入b，后压入a

函数调用完毕后，由函数调用方 清理堆栈

## stdcall Calling Convention

C语言源代码

```
#include <stdio.h>  
  
int __stdcall test(int a, int b)
{
	return (a+b);
}

int main()  
{  
    test(1, 2);
    printf("Hello, world\n");  
    return 0;  
}
```

test函数汇编代码

```
; Function compile flags: /Odtp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?test@@YGHHH@Z PROC					; test
; File  foo.cc
; Line 4
	push	ebp
	mov	ebp, esp
; Line 5
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
; Line 6
	pop	ebp
	ret	8     ; 清理堆栈  
?test@@YGHHH@Z ENDP					; test
_TEXT	ENDS
```

函数被调用方清理堆栈

Caller 汇编代码

```
push	ebp
	mov	ebp, esp
; Line 10
	push	2
	push	1
	call	?test@@YGHHH@Z				; test
```

使用内存传递参数.  在调用test(int a, int b)函数前，先将函数的两个参数自右向左压入栈，先压入b，后压入a

## fastcall Calling Convention

C语言源代码

```
#include <stdio.h>  
  
int __fastcall test(int a, int b)
{
	return (a+b);
}

int main()  
{  
    test(1, 2);
    printf("Hello, world\n");  
    return 0;  
}
```

test函数汇编代码

```
; Function compile flags: /Odtp
_TEXT	SEGMENT
_b$ = -8						; size = 4
_a$ = -4						; size = 4
?test@@YIHHH@Z PROC					; test
; _a$ = ecx
; _b$ = edx
; File  foo.cc
; Line 4
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _b$[ebp], edx
	mov	DWORD PTR _a$[ebp], ecx
; Line 5
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
?test@@YIHHH@Z ENDP					; test
_TEXT	ENDS
```

Caller 汇编代码

```
; Line 10
	mov	edx, 2
	mov	ecx, 1
	call	?test@@YIHHH@Z				; test
```

使用寄存器传递参数，减少运行耗时。

## vectorcall  Calling Convention

C语言源代码

```
#include <stdio.h>  
  
int __vectorcall test(int a, int b)
{
	return (a+b);
}

int main()  
{  
    test(1, 2);
    printf("Hello, world\n");  
    return 0;  
}
```

test函数汇编代码

```
_TEXT	SEGMENT
_b$ = -8						; size = 4
_a$ = -4						; size = 4
?test@@YQHHH@Z PROC					; test
; _a$ = ecx
; _b$ = edx
; File \foo.cc
; Line 4
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _b$[ebp], edx
	mov	DWORD PTR _a$[ebp], ecx
; Line 5
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
?test@@YQHHH@Z ENDP					; test
_TEXT	ENDS
```

Caller 汇编代码

```
; Line 10
	mov	edx, 2
	mov	ecx, 1
	call	?test@@YQHHH@Z
```

使用寄存器传递参数，减少运行耗时。

## Pascal Calling Convention

Visual Studio 不再支持 __pascal、__fortran 和 __syscall 调用约定[7]

# DLL导出接口声明

声明DLL导出接口的方式有两种:   __declspec(dllexport) 关键字 和 def文件 。

## __declspec(dllexport) 关键字

Windows的32位编译器使用关键字 __declspec(dllexport) 从DLL中导出数据，函数，类，类成员函数(Windows的16位编译器使用 __export关键字).

例如：

```
__declspec(dllexport) void  Function1(void);
```

__declspec(dllexport) 关键字要位于在DLL导出函数名协定的左测，例如：

```
__declspec(dllexport) void __cdecl Function2(void);
```

如果要从DLL中导出类，__declspec(dllexport) 关键字要位于类名的左侧, 例如：

```
class __declspec(dllexport) CExampleExport : public CObject
{ 
     ... class definition ... 
};
```

有些DLL声明，例如 NONAME, and PRIVATE, 必须在 .def 文件中设置。

## def文件

def(module-definition)文件是一个包含模块声明的文本文件，这些声明描述DLL文件的属性。

在DLL源代码文件的函数如果不使用 __declspec(dllimport) or __declspec(dllexport) 关键字，

在生成链接编译DLL时，需要提供def文件。

例如:
```
LIBRARY   BTREE
EXPORTS
   Insert   @1
   Delete   @2
   Member   @3
   Min   @4
```

def文件的第一个声明必须是 LIBRARY 声明.

EXPORTS声明 列出DLL的导出函数的名字。在导出函数名后可以添加 @ 字符，然后是这个函数在DLL导出函数表的序号。(@ 字符和序列号并非必须项)

# 样例

## 文件架构

项目文件架构如下所示：

```
../  
  |_ inc
      |_ mylib.h
  |_ src
      |_ mylib.cc
      |_ main.cc
  |_ tmp 
      |_ lib.mak 
      |_ client.mak
```

主要包含5个文件. 分别保存在三个文件夹中：
- 
C++类头文件存放在 /inc文件夹中;

- 
C++类源文件存放在 /src文件夹中;

- 
项目编译过程中产生的临时文件放在 /tmp文件夹中;


mylib.h是动态链接库头文件

mylib.cc是动态链接库源文件

main.cc是宿主程序源文件

lib.mak编译动态链接库使用的makefile文件

client.mak编译宿主程序使用的makefile文件
## 生成动态链接库 – 导出接口函数

目标: 生成一个动态链接库

### 代码

动态链接库头文件

```
/*
 * mylib.h
 */

#ifndef DLL_INC_MYLIB_H_
#define DLL_INC_MYLIB_H_

// MathLibrary.h - Contains declarations of math functions
// #pragma once

#ifdef MATHLIBRARY_EXPORTS
#define MATHLIBRARY_API __declspec(dllexport)
#else
#define MATHLIBRARY_API __declspec(dllimport)
#endif

extern "C" MATHLIBRARY_API int add( const int, const int);
#endif /* DLL_INC_MYLIB_H_ */
```

动态链接库源文件

```
/*
 * mylib.cc
 *
 *  Created on: 2018年12月24日
 *      Author: ThinkPad
 */

// MathLibrary.cpp : Defines the exported functions for the DLL.
// #include "stdafx.h"
#include <utility>
#include <limits.h>
#include "math.h"
#include "mylib.h" 

int add( const int x1, const int x2)
{
	int tmp = x1 + x2;
	return tmp;
}
```

### makefile

编译动态链接库的makefile

```
# Target   
PROGRAM = test.dll  
  
inc = "../inc/"  
src = "../src/"    
INCLUDEDIRS =  /I $(inc)    
 
# Flags  
CPPOPT = $(INCLUDEDIRS) /w /EHsc /D_CRT_SECURE_NO_DEPRECATE  
  
# Compiler   
cc = cl   
CFLAGS =   
   
# The CPPSOURCES macro contains a list of source files.
CPPSOURCES =  mylib.cc      
  
# The CPPOBJECTS macro converts the CPPSOURCES macro into a list
# of object files.         
CPPOBJECTS = $(CPPSOURCES:.cc=.obj)   
    
all: $(PROGRAM)  
  
$(PROGRAM): $(CPPOBJECTS)  
    link.exe /out:$(PROGRAM)  /DLL  $(CPPOBJECTS)    
      
mylib.obj:   
    $(cc) $(CPPOPT) /c ../src/mylib.cc       
      
          
clean:    
    del $(CPPOBJECTS) $(PROGRAM)
```

### 编译
- 启动Developer Command Prompt for VS2015，进入VS控制台编译环境。
- 运行nmake /F lib.mak

编译运行后可得到 test.lib 和 test.dll文件

## 隐式加载动态链接库

使用隐式加载方法调用该链接库。

### 代码

隐式加载动态链接库宿主程序代码

```
// main.cc : Client app for  DLL.

#include <iostream>
#include "mylib.h"
int main()
{
	int x = 1;
	int y = 2;
	int sum = add( x, y);
	printf( "%d + %d = %d \n", x, y, sum);

       return 1;
}
```

### makefile

client.mak

```
# Target   
PROGRAM = test.exe  
  
inc = "../inc/"  
src = "../src/"    
INCLUDEDIRS =  /I $(inc)    
 
LIBDIRS =  
LIBS = test.lib 
 
# Flags  
CPPOPT = $(INCLUDEDIRS) /w /EHsc /D_CRT_SECURE_NO_DEPRECATE  
  
# Compiler   
cc = cl   
CFLAGS =   
LINKFLAGS = $(LIBDIRS) $(LIBS) 
   
# list of source files   
CPPSOURCES =  main.cc     
  
# expands to list of object files          
CPPOBJECTS = $(CPPSOURCES:.cc=.obj)   
    
all: $(PROGRAM)  
  
$(PROGRAM): $(CPPOBJECTS)  
    link.exe /out:$(PROGRAM)  $(CPPOBJECTS)  $(LINKFLAGS)  
      
main.obj:   
    $(cc) $(CPPOPT) /c ../src/main.cc       
      
          
clean:    
    del $(CPPOBJECTS) $(PROGRAM)
```

### 编译过程
- 启动Developer Command Prompt for VS2015，进入VS控制台编译环境。
- 运行nmake /F client.mak

编译运行后得到可执行文件 test.exe

## 显式加载动态链接库

使用显式加载方法调用该链接库。

### 代码

在tmp文件夹中创建宿主程序 [foo.cc](http://foo.cc)，代码如下:

```
#include <iostream>
#include <windows.h>      

typedef int (*DLLFunc)(int, int);

int main()
{
        DLLFunc dllFunc;
        HINSTANCE hInstLibrary = LoadLibrary("test.dll");

        if (hInstLibrary == NULL)
        {
          FreeLibrary(hInstLibrary);
        }
        dllFunc = (DLLFunc)GetProcAddress(hInstLibrary, "add");
        if (dllFunc == NULL)
        {
          FreeLibrary(hInstLibrary);
        }

        int x = 1;
        int y = 3;
        int tmp = dllFunc(x, y);
        std::cout << x << " + " << y << " = " << tmp << std::endl ;

        std::cin.get();
        FreeLibrary(hInstLibrary);
        return(1);
}
```

```
typedef int (*DLLFunc)(int, int);
```

是定义动态链接库中导出函数的函数指针类型。

LoadLibrary() 函数、FreeLibrary()函数，GetProcAddress() 函数都是Win32的API.  LoadLibrary() 函数的作用是将指定的可执行模块映射到调用进程的地址空间。如果调用成功， LoadLibrary() 函数将返回所加载的模块(既可以是dll文件，也可以是exe文件)的句柄。FreeLibrary()函数是释放加载模块的句柄。GetProcAddress() 函数的功能是从动态链接库中导出函数的地址。

### 编译过程
- 启动Developer Command Prompt for VS2015，进入VS控制台编译环境。
- 运行cl [foo.cc](http://foo.cc)

编译运行后得到可执行文件 foo.exe

### 宿主程序运行测试

```
>foo.exe
1 + 3 = 4
```

## 生成动态链接库 – 导出C++类

### 代码

C++类的头文件代码

```
#pragma once

#ifdef MATHLIBRARY_EXPORTS
#define MATHLIBRARY_API __declspec(dllexport)
#else
#define MATHLIBRARY_API __declspec(dllimport)
#endif

class  MATHLIBRARY_API  CDLLTest
{
public:
	CDLLTest();
	~CDLLTest();

public:
	int  add(int a, int b);
	int  sub(int a, int b);
};
```

C++类的源文件代码

```
#include "clas.h"

CDLLTest::CDLLTest()
{

}

CDLLTest::~CDLLTest()
{

}

int CDLLTest::add( int a, int b)
{
	return a + b;
}

int CDLLTest::sub( int a, int b)
{
	return a - b;
}
```

### makefile文件

```
# Target   
PROGRAM = foo.dll  
  
inc = "../inc/"  
src = "../src/"    
INCLUDEDIRS =  /I $(inc)    
 
# Flags  
CPPOPT = $(INCLUDEDIRS) /w /EHsc /D_CRT_SECURE_NO_DEPRECATE  
  
# Compiler   
cc = cl   
CFLAGS =   
   
# The CPPSOURCES macro contains a list of source files.
CPPSOURCES =  foo.cc      
  
# The CPPOBJECTS macro converts the CPPSOURCES macro into a list
# of object files.         
CPPOBJECTS = $(CPPSOURCES:.cc=.obj)   
    
all: $(PROGRAM)  
  
$(PROGRAM): $(CPPOBJECTS)  
    link.exe /out:$(PROGRAM)  /DLL  $(CPPOBJECTS)    
      
foo.obj:   
    $(cc) $(CPPOPT) /c ../src/foo.cc       
      
          
clean:    
    del $(CPPOBJECTS) $(PROGRAM)
```

## 隐式加载动态链接库 – 调用库中C++类

### 代码

宿主程序代码

```
#include <utility>
#include "foo.h"

void test()
{
	CDLLTest dllTest;

	int x = 1;
	int y = 2;
	int tmp = dllTest.add(1,2);

	printf("result = %d \n", tmp );

	tmp = dllTest.sub(1,2);

	printf("%d - %d = %d \n",x, y, tmp );
}


int main()
{

	test();

}
```

### makefile文件

```
# Target   
PROGRAM = foo_test.exe  
  
inc = "../inc/"  
src = "../src/"    
INCLUDEDIRS =  /I $(inc)    
 
LIBDIRS =  
LIBS = foo.lib 
 
# Flags  
CPPOPT = $(INCLUDEDIRS) /w /EHsc /D_CRT_SECURE_NO_DEPRECATE  
  
# Compiler   
cc = cl   
CFLAGS =   
LINKFLAGS = $(LIBDIRS) $(LIBS) 
   
# list of source files   
CPPSOURCES =  foo_test.cc     
  
# expands to list of object files          
CPPOBJECTS = $(CPPSOURCES:.cc=.obj)   
    
all: $(PROGRAM)  
  
$(PROGRAM): $(CPPOBJECTS)  
    link.exe /out:$(PROGRAM)  $(CPPOBJECTS)  $(LINKFLAGS)  
      
foo_test.obj:   
    $(cc) $(CPPOPT) /c ../src/foo_test.cc       
                
clean:    
    del $(CPPOBJECTS) $(PROGRAM)
```

### 测试结果

编译测试结果

```
>foo_test.exe
result = 3
1 - 2 = -1
```

> 
[1] [https://docs.microsoft.com/en-us/cpp/build/dlls-in-visual-cpp?view=vs-2017](https://docs.microsoft.com/en-us/cpp/build/dlls-in-visual-cpp?view=vs-2017)

[2] [https://en.wikipedia.org/wiki/Dynamic_linker](https://en.wikipedia.org/wiki/Dynamic_linker)

[3] [https://en.wikipedia.org/wiki/X86_calling_conventions](https://en.wikipedia.org/wiki/X86_calling_conventions)

[4] [https://www.agner.org/optimize/calling_conventions.pdf](https://www.agner.org/optimize/calling_conventions.pdf)

[5] [https://docs.microsoft.com/zh-cn/previous-versions/wda6h6df(v=vs.120)](https://docs.microsoft.com/zh-cn/previous-versions/wda6h6df(v=vs.120))

[6] [https://blog.csdn.net/ChristopherWu/article/details/23828837](https://blog.csdn.net/ChristopherWu/article/details/23828837)

[7] [https://blog.csdn.net/J_Jeff/article/details/41693737](https://blog.csdn.net/J_Jeff/article/details/41693737)

[8] [http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/](http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/)

[9] [http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)

[10] [https://en.wikipedia.org/wiki/Stack_(abstract_data_type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))







