# 多种方法产生波形，查表法，立即生成法 - V__KING__的专栏 - CSDN博客





2014年04月30日 09:28:52[v__king__](https://me.csdn.net/V__KING__)阅读数：3121








```cpp
//定义按键的值
#define RAW 11
#define SINE_FM 1
#define SINE_AM 2

#define PWM 3

#define SQUARE_WAVE_FM 4
#define SQUARE_WAVE_AM 5
int g_key_val=RAW;
int g_keyIndex=0;
int sin_table[512];int index_sinTable=0;
//int pwm_table[256],index_pwmTable=0;
int square_table[256],index_squareTable;
int numTimeFreq=1;
int samplePoint=512;
int g_value=0;
int g_analog=0;
unsigned lastTime=0;
int lastTime1=0;
int g_pwmValue=100;
int halfCycleTime=0;
int totalPoints=0;
int highPoints=0;
int g_index_points=0; 
int m1=0;
int m2=0;
int time2_count_my=0;
unsigned long  currentTime=0;
int key[]={RAW,SINE_FM,SINE_AM,
    PWM,SQUARE_WAVE_FM,SQUARE_WAVE_AM
};

/* 产生正弦波表 放入m_table,表中有n个元素*/
void createSinTable(int sin_table[],int samplePoint){
    for(int i=0; i<samplePoint; i+=1){//改变正弦波型频率的地方,采样点个数越大，频率越小
        //sin_table[i] =  map(cos(2*3.14/256 *i),-1,1,0,200);
        sin_table[i] =  (cos(2*PI/samplePoint*i)+1)*100;
    }
}

/* 产生pwm波表 放入pwm_table,表中有n个元素*/
void createPwmTable(int pwm_table[],int n){
    for(int i=0; i<n/2; i+=1){//改变正弦波型频率的地方,采样点个数越大，频率越小
        pwm_table[i] =  100;
    }
	for(int i=n/2+1; i<n; i+=1){
        pwm_table[i] =  0;
	}
}


void sendToSerial(int g_value){
	//Serial.write(g_value);
	Serial.write(g_value);
}

void setup(){
    Serial.begin(600);    
	createSinTable(sin_table,512);
}
void loop(){
    //按键消斗,按一次就key[i++]
 	if(digitalRead(2)){		
		//delay(10);
		if(digitalRead(2)){
			while(digitalRead(2));//按下去之后直到松手才往下走
			//我们遍历key[2]时,当里面遍历完了,我们就回到key[g_keyIndex],g_keyIndex=0;
			++g_keyIndex;
			if( g_keyIndex==sizeof(key)/sizeof(key[0]) ){		 								
				g_keyIndex=0;
			}
			g_key_val=key[g_keyIndex];				//获得键值
		}
	}
	g_analog=map(analogRead(A0),0,1023,0,200);
	//test
	g_key_val=SQUARE_WAVE_FM;
    switch(g_key_val){
        case RAW:
			g_value=g_analog;									//给要发送的数据赋值
			sendToSerial(g_value);								//发送数据到串口
            break;
        case SINE_FM:
			//改变等待时间,采样点数
			//发送全局table[]
			//用固定am
			samplePoint=g_analog;
			createSinTable(sin_table,samplePoint);				//每次发送都创建一个table，实际上这里其实是给改变重新给sin_table赋值，重新获得取样点
			g_value=sin_table[index_sinTable];					//给要发送的数据赋值
			//Serial.print("sin_table= ");	 
			//Serial.println(sin_table[index_sinTable]);		//用来调试用
			index_sinTable+=numTimeFreq; 						//numTimeFreq=1
			if(index_sinTable>=samplePoint){
				index_sinTable=0;
			}
			sendToSerial(g_value);								//发送数据到串口
            break;
        case SINE_AM:
			//table中的值（0,200）-->（0,200）内其它值
			//用固定freq,
			g_value=(cos(2*PI/512*index_sinTable)+1)*g_analog/2;
			index_sinTable+=numTimeFreq;						//numTimeFreq=1
			if(index_sinTable>=512){
				index_sinTable=0;
			}
			//Serial.println(g_value);							//调试之用
			sendToSerial(g_value);								//发送数据到串口
            break;
        case PWM:
			//固定g_value
			//固定freq
			//L+H=600;
			for(int i=0; i<g_analog*10; i++){	
				g_value=100;
				sendToSerial(g_value);								//发送数据到串口
			}
			for(int i=0; i<(200-g_analog)*10; i++){
				g_value=0;
				sendToSerial(g_value);								//发送数据到串口
			}
            break;
        case SQUARE_WAVE_FM:
			totalPoints=g_analog;
			highPoints=totalPoints/2;
			if(g_index_points < highPoints){		//发送高电平的点数总共highPoints个，没到highPoints个就继续发高电平
				g_index_points++;					//每发送一次，就加1
				Serial.write(100);					//发送高电平
			}else if(g_index_points < totalPoints){//g_index_points 在(highPoint,totalPoints)之间
				//这之间的点数就是lawPoints=totalPoints-highPoints;	//totalPoints=1000
				g_index_points++;					//每发送一次就加1
				Serial.write(0);
			}else{									//超过了tatalPoints就清零
				g_index_points=0;					
			}
			break;
        case SQUARE_WAVE_AM:
			//固定dutyCycle
			//固定freq
			//只改发送的值
			//为什么选300呢？是因为300的波形好看
			for(int i=0; i<300; i++){						
				sendToSerial(g_value);								//发送数据到串口
			}
			for(int i=0; i<300; i++){
				sendToSerial(g_value);								//发送数据到串口
			}
			break;
	}
}
```




