# 线程的同步与互斥（死锁的产生和避免） - V__KING__的专栏 - CSDN博客





2018年01月08日 13:34:19[v__king__](https://me.csdn.net/V__KING__)阅读数：193








*参考：[http://blog.51cto.com/2627lounuo/1765473](http://blog.51cto.com/2627lounuo/1765473)*

### 加锁

在公共的函数中加入了互斥锁

### 死锁
- 上面谈论到加锁和解锁，试想，如果一个线程连续两次申请锁，当其第一次申请的时候获得了这把锁，而第二次申请的时候因为锁被占用着会挂起等待，而占用这把锁的正是自身，那么该线程将永远不会释放锁而会一直处于挂起等待的状态。
- 如果线程A获得了一把锁，线程B获得了另一把锁，而线程A还需要再获得线程B所拥有的那把锁才能继续往下执行，同样，线程B也正需要线程A占用的那把锁，但这时两个线程都会挂起等待对方释放那把需要的锁，这样一来两个线程也就一直僵持着处于挂起状态了。

### 如何避免死锁
- 两个线程之间用了多把锁，获得锁的顺序需一致，可避免上面死锁2的情况。
- 避免同一线程内对同一把锁get两次。



