# opencv术语扫盲 - V__KING__的专栏 - CSDN博客





2015年12月08日 14:49:14[v__king__](https://me.csdn.net/V__KING__)阅读数：545标签：[opencv](https://so.csdn.net/so/search/s.do?q=opencv&t=blog)
个人分类：[opencv](https://blog.csdn.net/V__KING__/article/category/6010533)









# 1. 单通道,多通道

[参考文章1](http://m.blog.csdn.net/blog/cai_huan_123/44959103)

RGB，就代表了三个通道 

HSV，也是另一种色系表示方式，下面使HSV的示意图 
![这里写图片描述](https://img-blog.csdn.net/20151208133138082)
![这里写图片描述](https://img-blog.csdn.net/20151208133349187)
# 2. 颜色空间缩减

这里我们测试的，是一种简单的颜色缩减方法。如果矩阵元素存储的是单通道像素，使用C或C++的无符号字符类型，那么像素可有256个不同值。但若是三通道图像，这种存储格式的颜色数就太多了（确切地说，有一千六百多万种）。用如此之多的颜色可能会对我们的算法性能造成严重影响。其实有时候，仅用这些颜色的一小部分，就足以达到同样效果。

这种情况下，常用的一种方法是 颜色空间缩减 。其做法是：将现有颜色空间值除以某个输入值，以获得较少的颜色数。例如，颜色值0到9可取为新值0，10到19可取为10，以此类推。

uchar （无符号字符，即0到255之间取值的数）类型的值除以 int 值，结果仍是 char 。因为结果是char类型的，所以求出来小数也要向下取整。利用这一点，刚才提到在 uchar 定义域中进行的颜色缩减运算就可以表达为下列形式： 


$I_n=I_o/10 * 10$

这样的话，简单的颜色空间缩减算法就可由下面两步组成：一、遍历图像矩阵的每一个像素；二、对像素应用上述公式。值得注意的是，我们这里用到了除法和乘法运算，而这两种运算又特别费时，所以，我们应尽可能用代价较低的加、减、赋值等运算替换它们。此外，还应注意到，上述运算的输入仅能在某个有限范围内取值，如 uchar 类型可取256个值。




