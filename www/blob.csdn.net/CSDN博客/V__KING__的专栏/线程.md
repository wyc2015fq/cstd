# 线程 - V__KING__的专栏 - CSDN博客





2015年12月05日 11:01:11[v__king__](https://me.csdn.net/V__KING__)阅读数：363标签：[线程](https://so.csdn.net/so/search/s.do?q=线程&t=blog)
个人分类：[linux](https://blog.csdn.net/V__KING__/article/category/1733387)









# 线程

## 1. 线程创建、退出,返回0就是成功
- A. 线程的创建 

```
int pthread_create(
    pthread_t *restrict thread,
    const pthread_attr_t *restrict attr,
    void *(*start_routine)(void*),
    void *restrict arg);
pthread_create(线程ID，属性(默认为NULL)，线程执行的函数入口地址，给线程执行函数传递的参数);
```

返回值:成功返回0,失败返回错误码 

```
void *thread_function(void *arg)
{
 ....
}

int ret;
pthread_t tid;

ret = pthread_create(&tid,NULL,thread_function,NULL);
if(ret != 0){
 perror("Fail to pthread_create");
 exit(EXIT_FAILURE);
}
```
- B. 线程的退出 

```
void pthread_exit(void *value_ptr);
eg:
int value = 100;
pthread_exit(&value);
```
- C.等待线程 

```
int pthread_join(pthread_t thread, void **value_ptr);
eg:
int *pvalue;
pthread_join(tid,&pvalue);
```
- D.线程取消
`int pthread_cancel(pthread_t thread)`
## 2. 线程的互斥锁

<1> 引入互斥(mutual exclusion)锁的目的是用来保证共享数据操作的完整性。 

<2> 互斥锁主要用来保护临界资源。 

<3> 每个临界资源都由一个互斥锁来保护，任何时刻最多只能有一个线程能访问该资源。 

<4> 线程必须先获得互斥锁才能访问临界资源，访问完临界资源后释放该锁。如果无法获得锁，线程会阻塞直到获得锁为止。- 
A. 锁的初始化 

当我们定义一个锁时我们应当对它初始化。
- a.静态初始化可以通过PTHREAD_MUTEX_INITIALIZER宏
- b.动态初始化可以通过pthread_mutex_init函数进行，一般在通过pthread_mutex_init初始化的锁，在不需要时应调用pthread_mutex_destroy销毁。 

```
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(
    pthread_mutex *restrict mutex
    const pthread_mutexattr_t *restrict attr);
```

- 
B.获得互斥锁和释放互斥锁
- a.我们可以通过pthread_mutex_lock来获得锁 

注意: 如果想获得的锁已经被别的线程获取了，此时pthread_mutex_lock将引起调用者阻塞`pthread_mutex_trylock`我们称尝试获得锁，如果不能获得锁，它不会引起调用者阻塞而是立即放回。
- b.我们可以通过pthread_mutex_unlock来释放获得的锁


## 3. 线程的条件变量
- 
A.条件变量定义及初始化 

和线程的互斥锁一样，我们也有两种方式初始化条件变量;
- 
a.静态初始化:可以通过PTHREAD_COND_INITIALIZER初始化。
`pthread_mutex_t rwlock = PTHREAD_MUTEX_INITIALIZER;`
- 
b.动态初始化:可以通过pthread_cond_init进行，如果不需要在使用此条件变量，也应该调用pthread_cond_destroy销毁

```
int pthread_cond_init(
    pthread_cond_t *cond, 
    const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);
```


- 
B.等待条件变量 

参数说明: 

第一个参数是等待的条件变量，第二个参数在是线程互斥锁。 

pthread_cond_wait函数使用时一般都和互斥锁一起用,他们一起完成线程的同步。 

注意：pthread_cond_wait函数一上来会判断等待的条件是否满足，如果不满足将引起调用的线程阻塞，直到条件满足。需要注意的时，pthread_cond_wait函数在阻塞前会释放互斥锁，这就要求在调用它之前应先获取互斥锁 

(何时条件满足?当有线程调用pthread_cond_signal或pthread_cond_broadcase时，等待的条件满足，此时pthread_cond_wait函数将返回，返回时它将重新获取互斥锁)`int pthread_cond_wait(pthread_cond *restrict cond,pthread_mutex_t *restrict mutex) ;`- 
C.唤醒等待条件变量的线程

```
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

pthread_cond_broadcase函数唤醒所有等待条件变量的线程。 

pthread_cond_signal函数唤醒所有等待条件变量线程中的一个线程，一般唤醒的是第一个等待条件变量的线程。








