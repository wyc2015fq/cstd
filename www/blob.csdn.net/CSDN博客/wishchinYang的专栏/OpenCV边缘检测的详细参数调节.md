# OpenCV边缘检测的详细参数调节 - wishchinYang的专栏 - CSDN博客
2016年03月24日 13:46:22[wishchin](https://me.csdn.net/wishchin)阅读数：5659
1. findCountours
      转载于[http://blog.sina.com.cn/s/blog_7155fb1a0101a90h.html](http://blog.sina.com.cn/s/blog_7155fb1a0101a90h.html)
## findContours函数，这个函数的原型为：
```cpp
<span style="font-family:Times New Roman;">void findContours(
            InputOutputArray image, OutputArrayOfArrayscontours, OutputArray hierarchy, 
            int mode, int method, Point offset=Point())</span>
```
```
<span style="font-family:Times New Roman;">参数说明：
输入图像image必须为一个2值单通道图像
contours参数为检测的轮廓数组，每一个轮廓用一个point类型的vector表示
hiararchy参数和轮廓个数相同，每个轮廓contours[ i ]对应4个hierarchy元素hierarchy[ i ][0 ] ~hierarchy[ i ][ 3]，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，该值设置为负数。
mode表示轮廓的检索模式
    CV_RETR_EXTERNAL 表示只检测外轮廓
    CV_RETR_LIST     检测的轮廓不建立等级关系
    CV_RETR_CCOMP   建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。
    CV_RETR_TREE    建立一个等级树结构的轮廓。具体参考contours.c这个demo
method为轮廓的近似办法
    CV_CHAIN_APPROX_NONE存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1
    CV_CHAIN_APPROX_SIMPLE压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息
    CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain近似算法
offset表示代表轮廓点的偏移量，可以设置为任意值。对ROI图像中找出的轮廓，并要在整个图像中进行分析时，这个参数还是很有用的。
findContours后会对输入的2值图像改变，所以如果不想改变该2值图像，需创建新mat来存放，findContours后的轮廓信息contours可能过于复杂不平滑，可以用approxPolyDP函数对该多边形曲线做适当近似
contourArea函数可以得到当前轮廓包含区域的大小，方便轮廓的筛选。
    
</span>
```
```
<span style="font-family:Times New Roman;">     findContours经常与drawContours配合使用，用来将轮廓绘制出来。其中第一个参数image表示目标图像，第二个参数contours表示输入的轮廓组，每一组轮廓由点vector构成，第三个参数contourIdx指明画第几个轮廓，如果该参数为负值，则画全部轮廓，第四个参数color为轮廓的颜色，第五个参数thickness为轮廓的线宽，如果为负值或CV_FILLED表示填充轮廓内部，第六个参数lineType为线型，第七个参数为轮廓结构信息，第八个参数为maxLevel
得到了复杂轮廓往往不适合特征的检测，这里再介绍一个点集凸包络的提取函数<u>convexHull</u>，输入参数就可以是contours组中的一个轮廓，返回外凸包络的点集
还可以得到轮廓的外包络矩形，使用函数boundingRect，如果想得到旋转的外包络矩形，使用函数minAreaRect，返回值为RotatedRect；也可以得到轮廓的外包络圆，对应的函数为minEnclosingCircle；想得到轮廓的外包络椭圆，对应的函数为fitEllipse，返回值也是RotatedRect，可以用ellipse函数画出对应的椭圆
如果想根据多边形的轮廓信息得到多边形的多阶矩，可以使用类moments，这个类可以得到多边形和光栅形状的3阶以内的所有矩，类内有变量m00，m10，m01，m20，m11，m02，m30，m21，m12，m03，比如多边形的质心为x = m10 / m00，y = m01 / m00。
如果想获得一点与多边形封闭轮廓的信息，可以调用pointPolygonTest函数，这个函数返回值为该点距离轮廓最近边界的距离，为正值为在轮廓内部，负值为在轮廓外部，0表示在边界上。
</span>
```
2. canny
参考链接：[http://blog.chinaunix.net/uid-26020768-id-3187984.html](http://blog.chinaunix.net/uid-26020768-id-3187984.html)
```cpp
<span style="font-family:Times New Roman;">void cvCanny( const CvArr* image, CvArr* edges, double threshold1, double threshold2, int aperture_size=3 );
image单通道输入图像.
edges单通道存储边缘的输出图像
threshold1第一个阈值
threshold2第二个阈值
aperture_sizeSobel 算子内核大小 (见 cvSobel).</span>
```
函数 cvCanny 采用 CANNY 算法发现输入图像的边缘而且在输出图像中标识这些边缘。threshold1和threshold2 当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割。
- 注意事项：cvCanny只接受单通道图像作为输入。
- 外部链接：经典的canny自调整阈值算法的一个opencv的实现见[在OpenCV中自适应确定canny算法的分割门限](http://blog.chinaunix.net/u/30231/showart_233944.html)
- 参考OpenCV中文官网：[http://www.opencv.org.cn/index.php/Cv%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86#Canny](http://www.opencv.org.cn/index.php/Cv%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86#Canny)
原图像：                                                                                                                      结果：
![](https://img-blog.csdn.net/20160324163522279?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)![](https://img-blog.csdn.net/20160324163602995?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
重要：Canny原理：链接及内容：[http://blog.csdn.net/likezhaobin/article/details/6892176](http://blog.csdn.net/likezhaobin/article/details/6892176)
图象的边缘是指图象局部区域亮度变化显著的部分，该区域的灰度剖面一般可以看作是一个阶跃，既从一个灰度值在很小的缓冲区域内急剧变化到另一个灰度相差较大的灰度值。图象的边缘部分集中了图象的大部分信息，图象边缘的确定与提取对于整个图象场景的识别与理解是非常重要的，同时也是图象分割所依赖的重要特征，边缘检测主要是图象的灰度变化的度量、检测和定位，自从1959提出边缘检测以来，经过五十多年的发展，已有许多中不同的边缘检测方法。根据作者的理解和实践，本文对边缘检测的原理进行了描述，在此基础上着重对Canny检测算法的实现进行详述。
        本文所述内容均由编程验证而来，在实现过程中，有任何错误或者不足之处大家共同讨论（本文不讲述枯燥的理论证明和数学推导，仅仅从算法的实现以及改进上进行原理性和工程化的描述）。
**1、边缘检测原理及步骤**
        在之前的博文中，作者从一维函数的跃变检测开始，循序渐进的对二维图像边缘检测的基本原理进行了通俗化的描述。结论是：实现图像的边缘检测，就是要用离散化梯度逼近函数根据二维灰度矩阵梯度向量来寻找图像灰度矩阵的灰度跃变位置，然后在图像中将这些位置的点连起来就构成了所谓的图像边缘（图像边缘在这里是一个统称，包括了二维图像上的边缘、角点、纹理等基元图）。
        在实际情况中理想的灰度阶跃及其线条边缘图像是很少见到的，同时大多数的传感器件具有低频滤波特性，这样会使得阶跃边缘变为斜坡性边缘，看起来其中的强度变化不是瞬间的，而是跨越了一定的距离。这就使得在边缘检测中首先要进行的工作是滤波。
**        1）滤波**：边缘检测的算法主要是基于图像强度的一阶和二阶导数，但导数通常对噪声很敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。**常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核**（具体见“高斯滤波原理及其编程离散化实现方法”一文），然后基于高斯核函数对图像灰度矩阵的每一点进行加权求和（具体程序实现见下文）。
**        2）增强**：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将图像灰度点邻域强度值有显著变化的点凸显出来。**在具体编程实现时，可通过计算梯度幅值来确定。**
**        3）检测**：经过增强的图像，往往邻域中有很多点的梯度值比较大，而在特定的应用中，这些点并不是我们要找的边缘点，所以应该采用某种方法来对这些点进行取舍。**实际工程中，常用的方法是通过阈值化方法来检测。**
**2、Canny边缘检测算法原理**
        JohnCanny于1986年提出Canny算子，它与Marr（LoG）边缘检测方法类似，也属于是先平滑后求导数的方法。本节对根据上述的边缘检测过程对Canny检测算法的原理进行介绍。
**2.1 对原始图像进行灰度化**
        Canny算法通常处理的图像为灰度图，因此如果摄像机获取的是彩色图像，那首先就得进行灰度化。对一幅彩色图进行灰度化，就是根据图像各个通道的采样值进行加权平均。以RGB格式的彩图为例，通常灰度化采用的方法主要有：
        方法1：Gray=(R+G+B)/3;
        方法2：Gray=0.299R+0.587G+0.114B;（这种参数考虑到了人眼的生理特点）
        注意1：至于其他格式的彩色图像，可以根据相应的转换关系转为RGB然后再进行灰度化；
        注意2：在编程时要**注意图像格式中RGB的顺序通常为BGR**。
**2.2 对图像进行高斯滤波**
        图像高斯滤波的实现可以用两个一维高斯核分别两次加权实现，也可以通过一个二维高斯核一次卷积实现。
        1）高斯核实现
![](http://hi.csdn.net/attachment/201110/20/0_1319118393K2D6.gif)
上式为离散化的一维高斯函数，确定参数就可以得到一维核向量。
![](http://hi.csdn.net/attachment/201110/20/0_13191185277QAm.gif)
        上式为离散化的二维高斯函数，确定参数就可以得到二维核向量。
        注意1：关于参数Sigma的取值详见上篇博文。
        注意2：在求的高斯核后，要对整个核进行归一化处理。
2）图像高斯滤波
        对图像进行高斯滤波，听起来很玄乎，其实就是根据待滤波的像素点及其邻域点的灰度值按照一定的参数规则进行加权平均。这样可以有效滤去理想图像中叠加的高频噪声。
        通常滤波和边缘检测是矛盾的概念，抑制了噪声会使得图像边缘模糊，这回增加边缘定位的不确定性；而如果要提高边缘检测的灵敏度，同时对噪声也提高了灵敏度。实际工程经验表明，高斯函数确定的核可以在抗噪声干扰和边缘检测精确定位之间提供较好的折衷方案。这就是所谓的高斯图像滤波，具体实现代码见下文。
**2.3 用一阶偏导的有限差分来计算梯度的幅值和方向**
        关于图像灰度值得梯度可使用一阶有限差分来进行近似，这样就可以得图像在x和y方向上偏导数的两个矩阵。常用的梯度算子有如下几种：
        1）Roberts算子
![](http://hi.csdn.net/attachment/201110/20/0_1319118788tu9f.gif)
        上式为其x和y方向偏导数计算模板，可用数学公式表达其每个点的梯度幅值为：
![](http://hi.csdn.net/attachment/201110/20/0_1319118857NQ6k.gif)
        2）Sobel算子
![](http://hi.csdn.net/attachment/201110/20/0_1319118933e59W.gif)
  
      上式三个矩阵分别为该算子的x向卷积模板、y向卷积模板以及待处理点的邻域点标记矩阵，据此可用数学公式表达其每个点的梯度幅值为：
![](http://hi.csdn.net/attachment/201110/20/0_1319119015UX8D.gif)
        3）Prewitt算子
        和Sobel算子原理一样，在此仅给出其卷积模板。
![](http://hi.csdn.net/attachment/201110/20/0_1319119083ivVZ.gif)
        4）Canny算法所采用的方法
        在本文实现的Canny算法中所采用的卷积算子比较简单，表达如下：
![](http://hi.csdn.net/attachment/201110/20/0_13191191580BUw.gif)
        其x向、y向的一阶偏导数矩阵，梯度幅值以及梯度方向的数学表达式为：
![](http://hi.csdn.net/attachment/201110/20/0_131911920906FX.gif)
        求出这几个矩阵后，就可以进行下一步的检测过程。
**2.4 对梯度幅值进行非极大值抑制**        图像梯度幅值矩阵中的元素值越大，说明图像中该点的梯度值越大，但这不不能说明该点就是边缘（这仅仅是属于图像增强的过程）。在Canny算法中，非极大值抑制是进行边缘检测的重要步骤，**通俗意义上是指寻找像素点局部最大值，将非极大值点所对应的灰度值置为0**，这样可以剔除掉一大部分非边缘的点（这是本人的理解）。
![](http://hi.csdn.net/attachment/201110/20/0_1319119291xBLz.gif)
图1 非极大值抑制原理
        根据图1 可知，要进行非极大值抑制，就首先要确定像素点C的灰度值在其8值邻域内是否为最大。图1中蓝色的线条方向为C点的梯度方向，这样就可以确定其局部的最大值肯定分布在这条线上，也即出了C点外，梯度方向的交点dTmp1和dTmp2这两个点的值也可能会是局部最大值。因此，判断C点灰度与这两个点灰度大小即可判断C点是否为其邻域内的局部最大灰度点。如果经过判断，C点灰度值小于这两个点中的任一个，那就说明C点不是局部极大值，那么则可以排除C点为边缘。这就是非极大值抑制的工作原理。
        作者认为，在理解的过程中需要注意以下两点：
        1）中非最大抑制是回答这样一个问题：“当前的梯度值在梯度方向上是一个局部最大值吗？”
 所以,要把当前位置的梯度值与梯度方向上两侧的梯度值进行比较；
        2）梯度方向垂直于边缘方向。
        但实际上，我们只能得到C点邻域的8个点的值，而dTmp1和dTmp2并不在其中，要得到这两个值就需要对该两个点两端的已知灰度进行线性插值，也即根据图1中的g1和g2对dTmp1进行插值，根据g3和g4对dTmp2进行插值，这要用到其梯度方向，这是上文Canny算法中要求解梯度方向矩阵Thita的原因。
        完成非极大值抑制后，会得到一个二值图像，非边缘的点灰度值均为0，可能为边缘的局部灰度极大值点可设置其灰度为128。根据下文的具体测试图像可以看出，这样一个检测结果还是包含了很多由噪声及其他原因造成的假边缘。因此还需要进一步的处理。
**2.5 用双阈值算法检测和连接边缘**
        Canny算法中减少假边缘数量的方法是采用双阈值法。选择两个阈值（关于阈值的选取方法在扩展中进行讨论），根据高阈值得到一个边缘图像，这样一个图像含有很少的假边缘，但是由于阈值较高，产生的图像边缘可能不闭合，未解决这样一个问题采用了另外一个低阈值。
        在高阈值图像中把边缘链接成轮廓，当到达轮廓的端点时，该算法会在断点的8邻域点中寻找满足低阈值的点，再根据此点收集新的边缘，直到整个图像边缘闭合。
