# 详细分析图像形态学操作 - wishchinYang的专栏 - CSDN博客
2015年09月11日 09:18:25[wishchin](https://me.csdn.net/wishchin)阅读数：5022
        原文链接：[http://blog.csdn.net/poem_qianmo/article/details/23710721](http://blog.csdn.net/poem_qianmo/article/details/23710721)
        还是比教科书上的图文并茂的多。以防删除，如有疑问或者版权问题，请移步原博客或者告知本人。
本篇文章中，我们一起探究了图像处理中，最基本的形态学运算——膨胀与腐蚀。浅墨在文章开头友情提醒，用人物照片做腐蚀和膨胀的素材图片得到的效果会比较惊悚，毁三观的，不建议尝试。。。。。。。。。。
OK，开始吧，依然是先放一张截图：
![](https://img-blog.csdn.net/20140414224308828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
# 一、理论与概念讲解——从现象到本质
## 1.1 形态学概述
形态学（morphology）一词通常表示生物学的一个分支，该分支主要研究动植物的形态和结构。而我们图像处理中指的形态学，往往表示的是数学形态学。下面一起来了解数学形态学的概念。
数学形态学（Mathematical morphology） 是一门建立在格论和拓扑学基础之上的图像分析学科，是数学形态学图像处理的基本理论。其基本的运算包括：二值腐蚀和膨胀、二值开闭运算、骨架抽取、极限腐蚀、击中击不中变换、形态学梯度、Top-hat变换、颗粒分析、流域变换、灰值腐蚀和膨胀、灰值开闭运算、灰值形态学梯度等。
简单来讲，形态学操作就是基于形状的一系列图像处理操作。OpenCV为进行图像的形态学变换提供了快捷、方便的函数。最基本的形态学操作有二种，他们是：膨胀与腐蚀(Dilation与Erosion)。
膨胀与腐蚀能实现多种多样的功能，主要如下：
- 消除噪声
- 分割(isolate)出独立的图像元素，在图像中连接(join)相邻的元素。
- 寻找图像中的明显的极大值区域或极小值区域
- 求出图像的梯度
我们在这里给出下文会用到的，用于对比膨胀与腐蚀运算的“浅墨”字样毛笔字原图：
![](https://img-blog.csdn.net/20140414224457312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
在进行腐蚀和膨胀的讲解之前，首先需要注意，**腐蚀和膨胀是对白色部分（高亮部分）而言的，不是黑色部分。膨胀就是图像中的高亮部分进行膨胀，“领域扩张”，效果图拥有比原图更大的高亮区域。腐蚀就是原图中的高亮部分被腐蚀，“领域被蚕食”，效果图拥有比原图更小的高亮区域。**
## 1.2膨胀
其实，膨胀就是求局部最大值的操作。
按数学方面来说，膨胀或者腐蚀操作就是将图像（或图像的一部分区域，我们称之为A）与核（我们称之为B）进行卷积。
核可以是任何的形状和大小，它拥有一个单独定义出来的参考点，我们称其为锚点（anchorpoint）。多数情况下，核是一个小的中间带有参考点和实心正方形或者圆盘，其实，我们可以把核视为模板或者掩码。
而膨胀就是求局部最大值的操作，核B与图形卷积，即计算核B覆盖的区域的像素点的最大值，并把这个最大值赋值给参考点指定的像素。这样就会使图像中的高亮区域逐渐增长。如下图所示，这就是膨胀操作的初衷。
![](https://img-blog.csdn.net/20140414224715328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
膨胀的数学表达式：
![](https://img-blog.csdn.net/20140414224723843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
膨胀效果图（毛笔字）：
![](https://img-blog.csdn.net/20140414224735671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
照片膨胀效果图：
![](https://img-blog.csdn.net/20140414224750843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 1.3腐蚀
再来看一下腐蚀，大家应该知道，膨胀和腐蚀是一对好基友，是相反的一对操作，所以腐蚀就是求局部最小值的操作。
我们一般都会把腐蚀和膨胀对应起来理解和学习。下文就可以看到，两者的函数原型也是基本上一样的。
原理图：
![](https://img-blog.csdn.net/20140414224842203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
腐蚀的数学表达式：
![](https://img-blog.csdn.net/20140414224852968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
腐蚀效果图（毛笔字）：
![](https://img-blog.csdn.net/20140414224907109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
照片腐蚀效果图：
![](https://img-blog.csdn.net/20140414224923671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
 浅墨表示这张狗狗超可爱：D
## 二、深入——OpenCV源码分析溯源
直接上源码吧，在…\opencv\sources\modules\imgproc\src\ morph.cpp路径中 的第1353行开始就为erode（腐蚀）函数的源码，1361行为dilate（膨胀）函数的源码。
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
- //-----------------------------------【erode（）函数中文注释版源代码】---------------------------- 
- //    说明：以下代码为来自于计算机开源视觉库OpenCV的官方源代码 
- //    OpenCV源代码版本：2.4.8 
- //    源码路径：…\opencv\sources\modules\imgproc\src\ morph.cpp 
- //    源文件中如下代码的起始行数：1353行 
- //    中文注释by浅墨 
- //--------------------------------------------------------------------------------------------------------  
- void cv::erode( InputArray src, OutputArraydst, InputArray kernel,  
-                 Point anchor, int iterations,  
- int borderType, constScalar& borderValue )  
- {  
- //调用morphOp函数，并设定标识符为MORPH_ERODE
-    morphOp( MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType,borderValue );  
- }  
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
- //-----------------------------------【dilate（）函数中文注释版源代码】---------------------------- 
- //    说明：以下代码为来自于计算机开源视觉库OpenCV的官方源代码 
- //    OpenCV源代码版本：2.4.8 
- //    源码路径：…\opencv\sources\modules\imgproc\src\ morph.cpp 
- //    源文件中如下代码的起始行数：1361行 
- //    中文注释by浅墨 
- //-------------------------------------------------------------------------------------------------------- 
- void cv::dilate( InputArray src,OutputArray dst, InputArray kernel,  
-                  Point anchor, int iterations,  
- int borderType, constScalar& borderValue )  
- {  
- //调用morphOp函数，并设定标识符为MORPH_DILATE
-    morphOp( MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType,borderValue );  
- }  
可以发现erode和dilate这两个函数内部就是调用了一下morphOp，只是他们调用morphOp时，第一个参数标识符不同，一个为MORPH_ERODE（腐蚀），一个为MORPH_DILATE（膨胀）。
morphOp函数的源码在…\opencv\sources\modules\imgproc\src\morph.cpp中的第1286行，有兴趣的朋友们可以研究研究，这里就不费时费力花篇幅展开分析了。
## 三、浅出——API函数快速上手
## 3.1  形态学膨胀——dilate函数
erode函数，使用像素邻域内的局部极大运算符来膨胀一张图片，从src输入，由dst输出。支持就地（in-place）操作。
函数原型：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
> 
```cpp
C++: void dilate(  
        InputArray src,  
        OutputArray dst,  
        InputArray kernel,  
        Point anchor=Point(-1,-1),  
        int iterations=1,  
        int borderType=BORDER_CONSTANT,  
        const Scalar& borderValue=morphologyDefaultBorderValue()   
    );
```
参数详解：
- 第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。图像通道的数量可以是任意的，但图像深度应为CV_8U，CV_16U，CV_16S，CV_32F或 CV_64F其中之一。
- 第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。
- 第三个参数，InputArray类型的kernel，膨胀操作的核。若为NULL时，表示的是使用参考点位于中心3x3的核。
> 
> 
我们一般使用函数 getStructuringElement配合这个参数的使用。getStructuringElement函数会返回指定形状和尺寸的结构元素（内核矩阵）。
> 
其中，getStructuringElement函数的第一个参数表示内核的形状，我们可以选择如下三种形状之一:
> - - 矩形: MORPH_RECT
- 交叉形: MORPH_CROSS
- 椭圆形: MORPH_ELLIPSE
> 
> 
而getStructuringElement函数的第二和第三个参数分别是内核的尺寸以及锚点的位置。
> 
我们一般在调用erode以及dilate函数之前，先定义一个Mat类型的变量来获得getStructuringElement函数的返回值。对于锚点的位置，有默认值Point(-1,-1)，表示锚点位于中心。且需要注意，十字形的element形状唯一依赖于锚点的位置。而在其他情况下，锚点只是影响了形态学运算结果的偏移。
> 
getStructuringElement函数相关的调用示例代码如下：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)
```cpp
int g_nStructElementSize = 3; //结构元素(内核矩阵)的尺寸  
   
//获取自定义核  
Mat element = getStructuringElement(MORPH_RECT,  
    Size(2*g_nStructElementSize+1,2*g_nStructElementSize+1),  
    Point( g_nStructElementSize, g_nStructElementSize ));
```
> 
调用这样之后，我们便可以在接下来调用erode或dilate函数时，第三个参数填保存了getStructuringElement返回值的Mat类型变量。对应于我们上面的示例，就是填element变量。
> - 第四个参数，Point类型的anchor，锚的位置，其有默认值（-1，-1），表示锚位于中心。
- 第五个参数，int类型的iterations，迭代使用erode（）函数的次数，默认值为1。
- 第六个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_DEFAULT。
- 第七个参数，const Scalar&类型的borderValue，当边界为常数时的边界值，有默认值morphologyDefaultBorderValue()，一般我们不用去管他。需要用到它时，可以看官方文档中的createMorphologyFilter()函数得到更详细的解释。
- 
使用erode函数，一般我们只需要填前面的三个参数，后面的四个参数都有默认值。而且往往结合getStructuringElement一起使用。
调用范例：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
用上面核心代码架起来的完整程序代码：
```cpp
//载入原图   
            Mat image = imread("1.jpg");  
    //获取自定义核  
            Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));  
            Mat out;  
            //进行膨胀操作  
            dilate(image, out, element);
```
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
```cpp
//     描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/core/core.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  
#include <iostream>  
   
//-----------------------------------【命名空间声明部分】---------------------------------------  
//     描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------   
using namespace std;  
using namespace cv;  
   
//-----------------------------------【main( )函数】--------------------------------------------  
//     描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main(  )  
{  
   
       //载入原图   
       Mat image = imread("1.jpg");  
   
       //创建窗口   
       namedWindow("【原图】膨胀操作");  
       namedWindow("【效果图】膨胀操作");  
   
       //显示原图  
       imshow("【原图】膨胀操作", image);  
   
<span style="white-space:pre">  </span>//获取自定义核  
       Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));  
       Mat out;  
<span style="white-space:pre">  </span>//进行膨胀操作  
       dilate(image,out, element);  
   
       //显示效果图  
       imshow("【效果图】膨胀操作", out);  
   
       waitKey(0);  
   
       return 0;  
}
```
 运行截图：
![](https://img-blog.csdn.net/20140414230056968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
## 3.2 形态学腐蚀——erode函数
erode函数，使用像素邻域内的局部极小运算符来腐蚀一张图片，从src输入，由dst输出。支持就地（in-place）操作。
看一下函数原型：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
> 
```cpp
C++: void erode(  
        InputArray src,  
        OutputArray dst,  
        InputArray kernel,  
        Point anchor=Point(-1,-1),  
        int iterations=1,  
        int borderType=BORDER_CONSTANT,  
        const Scalar& borderValue=morphologyDefaultBorderValue()  
     );
```
参数详解：
- 第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。图像通道的数量可以是任意的，但图像深度应为CV_8U，CV_16U，CV_16S，CV_32F或 CV_64F其中之一。
- 第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。
- 第三个参数，InputArray类型的kernel，腐蚀操作的内核。若为NULL时，表示的是使用参考点位于中心3x3的核。我们一般使用函数 getStructuringElement配合这个参数的使用。getStructuringElement函数会返回指定形状和尺寸的结构元素（内核矩阵）。（具体看上文中浅出部分dilate函数的第三个参数讲解部分）
- 第四个参数，Point类型的anchor，锚的位置，其有默认值（-1，-1），表示锚位于单位（element）的中心，我们一般不用管它。
- 第五个参数，int类型的iterations，迭代使用erode（）函数的次数，默认值为1。
- 第六个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_DEFAULT。
- 第七个参数，const Scalar&类型的borderValue，当边界为常数时的边界值，有默认值morphologyDefaultBorderValue()，一般我们不用去管他。需要用到它时，可以看官方文档中的createMorphologyFilter()函数得到更详细的解释。
同样的，使用erode函数，一般我们只需要填前面的三个参数，后面的四个参数都有默认值。而且往往结合getStructuringElement一起使用。
调用范例：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
```cpp
//载入原图   
        Mat image = imread("1.jpg");  
//获取自定义核  
        Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));  
        Mat out;  
        //进行腐蚀操作  
        erode(image,out, element);
```
用上面核心代码架起来的完整程序代码：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
```cpp
//-----------------------------------【头文件包含部分】---------------------------------------  
    //     描述：包含程序所依赖的头文件  
    //----------------------------------------------------------------------------------------------  
    #include <opencv2/core/core.hpp>  
    #include<opencv2/highgui/highgui.hpp>  
    #include<opencv2/imgproc/imgproc.hpp>  
    #include <iostream>  
       
    //-----------------------------------【命名空间声明部分】---------------------------------------  
    //     描述：包含程序所使用的命名空间  
    //-----------------------------------------------------------------------------------------------   
    using namespace std;  
    using namespace cv;  
       
    //-----------------------------------【main( )函数】--------------------------------------------  
    //     描述：控制台应用程序的入口函数，我们的程序从这里开始  
    //-----------------------------------------------------------------------------------------------  
    int main(  )  
    {  
           //载入原图   
           Matimage = imread("1.jpg");  
       
            //创建窗口   
           namedWindow("【原图】腐蚀操作");  
           namedWindow("【效果图】腐蚀操作");  
       
           //显示原图  
           imshow("【原图】腐蚀操作", image);  
       
              
    //获取自定义核  
           Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));  
           Mat out;  
       
    //进行腐蚀操作  
           erode(image,out, element);  
       
           //显示效果图  
           imshow("【效果图】腐蚀操作", out);  
       
           waitKey(0);  
       
           return 0;  
    }
```
运行结果：
![](https://img-blog.csdn.net/20140414230334875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
## 四、综合示例——在实战中熟稔
依然是每篇文章都会配给大家的一个详细注释的博文配套示例程序，把这篇文章中介绍的知识点以代码为载体，展现给大家。
这个示例程序中的效果图窗口有两个滚动条，顾名思义，第一个滚动条“腐蚀/膨胀”用于在腐蚀/膨胀之间进行切换；第二个滚动条”内核尺寸”用于调节形态学操作时的内核尺寸，以得到效果不同的图像，有一定的可玩性。废话不多说，上代码吧：
**[cpp]**[view plain](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[copy](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[print](http://blog.csdn.net/poem_qianmo/article/details/23710721#)[?](http://blog.csdn.net/poem_qianmo/article/details/23710721#)![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)[](https://code.csdn.net/snippets/292553/fork)
```cpp
//-----------------------------------【程序说明】----------------------------------------------  
//            程序名称:：《【OpenCV入门教程之十】形态学图像处理（一）：膨胀与腐蚀  》 博文配套源码  
//            开发所用IDE版本：Visual Studio 2010  
//          开发所用OpenCV版本： 2.4.8  
//            2014年4月14日 Create by 浅墨  
//            浅墨的微博：@浅墨_毛星云  
//------------------------------------------------------------------------------------------------  
   
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include <opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  
#include <iostream>  
   
//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace std;  
using namespace cv;  
   
   
//-----------------------------------【全局变量声明部分】--------------------------------------  
//            描述：全局变量声明  
//-----------------------------------------------------------------------------------------------  
Mat g_srcImage, g_dstImage;//原始图和效果图  
int g_nTrackbarNumer = 0;//0表示腐蚀erode, 1表示膨胀dilate  
int g_nStructElementSize = 3; //结构元素(内核矩阵)的尺寸  
   
   
//-----------------------------------【全局函数声明部分】--------------------------------------  
//            描述：全局函数声明  
//-----------------------------------------------------------------------------------------------  
void Process();//膨胀和腐蚀的处理函数  
void on_TrackbarNumChange(int, void *);//回调函数  
void on_ElementSizeChange(int, void *);//回调函数  
   
   
//-----------------------------------【main( )函数】--------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main( )  
{  
       //改变console字体颜色  
       system("color5E");   
   
       //载入原图  
       g_srcImage= imread("1.jpg");  
       if(!g_srcImage.data ) { printf("Oh，no，读取srcImage错误~！\n"); return false; }  
        
       //显示原始图  
       namedWindow("【原始图】");  
       imshow("【原始图】", g_srcImage);  
        
       //进行初次腐蚀操作并显示效果图  
       namedWindow("【效果图】");  
       //获取自定义核  
       Mat element = getStructuringElement(MORPH_RECT, Size(2*g_nStructElementSize+1,2*g_nStructElementSize+1),Point( g_nStructElementSize, g_nStructElementSize ));  
       erode(g_srcImage,g_dstImage, element);  
       imshow("【效果图】", g_dstImage);  
   
       //创建轨迹条  
       createTrackbar("腐蚀/膨胀", "【效果图】", &g_nTrackbarNumer, 1, on_TrackbarNumChange);  
       createTrackbar("内核尺寸", "【效果图】",&g_nStructElementSize, 21, on_ElementSizeChange);  
   
       //输出一些帮助信息  
       cout<<endl<<"\t嗯。运行成功，请调整滚动条观察图像效果~\n\n"  
              <<"\t按下“q”键时，程序退出~!\n"  
              <<"\n\n\t\t\t\tby浅墨";  
   
       //轮询获取按键信息，若下q键，程序退出  
       while(char(waitKey(1))!= 'q') {}  
   
       return 0;  
}  
   
//-----------------------------【Process( )函数】------------------------------------  
//            描述：进行自定义的腐蚀和膨胀操作  
//-----------------------------------------------------------------------------------------  
void Process()  
{  
       //获取自定义核  
       Mat element = getStructuringElement(MORPH_RECT, Size(2*g_nStructElementSize+1,2*g_nStructElementSize+1),Point( g_nStructElementSize, g_nStructElementSize ));  
   
       //进行腐蚀或膨胀操作  
       if(g_nTrackbarNumer== 0) {     
              erode(g_srcImage,g_dstImage, element);  
       }  
       else{  
              dilate(g_srcImage,g_dstImage, element);  
       }  
   
       //显示效果图  
       imshow("【效果图】", g_dstImage);  
}  
   
   
//-----------------------------【on_TrackbarNumChange( )函数】------------------------------------  
//            描述：腐蚀和膨胀之间切换开关的回调函数  
//-----------------------------------------------------------------------------------------------------  
void on_TrackbarNumChange(int, void *)  
{  
       //腐蚀和膨胀之间效果已经切换，回调函数体内需调用一次Process函数，使改变后的效果立即生效并显示出来  
       Process();  
}  
   
   
//-----------------------------【on_ElementSizeChange( )函数】-------------------------------------  
//            描述：腐蚀和膨胀操作内核改变时的回调函数  
//-----------------------------------------------------------------------------------------------------  
void on_ElementSizeChange(int, void *)  
{  
       //内核尺寸已改变，回调函数体内需调用一次Process函数，使改变后的效果立即生效并显示出来  
       Process();  
}
```
放出一些效果图吧。原始图：
![](https://img-blog.csdn.net/20140414230512781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
膨胀效果图：
![](https://img-blog.csdn.net/20140414230547203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20140414230613703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20140414230639578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
腐蚀效果图：
![](https://img-blog.csdn.net/20140414233147421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20140414233158953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20140414230726734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
腐蚀和膨胀得到的图，都特有喜感，但千变万变，还是原图好看：
![](https://img-blog.csdn.net/20140414230919312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
OK，就放出这些吧，具体更多的运行效果大家就自己下载示例程序回去玩吧。
本篇文章到这里就基本结束了，最后放出文章配套示例程序的打包下载地址。
本篇文章的配套源代码请点击这里下载：
[【浅墨OpenCV入门教程之十】配套源代码下载](http://download.csdn.net/detail/zhmxy555/7193915)
OK，今天的内容大概就是这些，我们下篇文章见：）
![](https://img-blog.csdn.net/20140414231145031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
