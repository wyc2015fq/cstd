# -1.#IND000  &&图像类型转换 - wishchinYang的专栏 - CSDN博客
2013年12月23日 16:15:50[wishchin](https://me.csdn.net/wishchin)阅读数：773
（1）：float acos(float x) 参数x的范围为-1.0f到1.0f之间,返回值范围在0.0f到3.141592653f之间,值得注意的是:当x超出[-1.0f,1.0f]这个范围时此函数将返回一个-1.#IND000值,代表无穷小而编译器会不给出任何提示,通常此将会导致程序错误或崩溃,所以以后要注意数学函数的参数范围了.
可以通过以下代码进行调试:
 float test = acos(1.0001f)
 if (test != test) {
      cout << "错误出现" << endl;
 }
昨天遇到的-1.#IND000，无穷小。但是我想用if(a==-1.#IND000)去判断，编译不过，呵呵。
现在找到方法了  ，不过方法有点怪，astone指出，b!=b应该是恒为false，但在这个情况下竟然是true
 float a=10;
 float b=a/0;
 if( b > 0.0f ||b != b)
  printf("%f",b);
这个可以判断1.#INF000
 float a=-10;
 float b=a/0;
 if( b < 0.0f ||b != b)
  printf("%f",b);
这个可以判断-1.#IND000
加b!=b只用于.net 2003，在vC++6.0下不用。
      使用类似于pow,exp等等函数时常会产生一个无效数字1.#IND00，在VC下可以通过与一个确定数字比较大小来判断是否产生了无效数字，但这个方法在DEV-CPP下却是行不通的。
其实解决办法很简单，使用  float.h中一个函数_isnan即可：
int _isnan(double x);  
当x是一个无效值(NaN, Not a Number) 时，返回非零值；否则返回0.
一般可能是除数为零，使用数组时也经常出现这种情况
转自：http://blog.sina.com.cn/s/blog_3e6817300100a74d.html
（2）：图像类型转换：[http://blog.csdn.net/wuxiaoyao12/article/details/7305848](http://blog.csdn.net/wuxiaoyao12/article/details/7305848)
**一、Mat**类型：**矩阵类型**，Matrix。
 在openCV中，Mat是一个多维的密集数据数组。可以用来处理向量和矩阵、图像、直方图等等常见的多维数据。
    Mat有3个重要的方法：
         1、Mat mat = imread(const String* filename);            读取图像
         2、imshow(const string frameName, InputArray mat);      显示图像
         3、imwrite (const string& filename, InputArray img);    储存图像
Mat类型较CvMat与IplImage类型来说，有更强的矩阵运算能力，支持常见的矩阵运算。在计算密集型的应用当中，将CvMat与IplImage类型转化为Mat类型将大大减少计算时间花费。
A.Mat -> IplImage
同样只是创建图像头，而没有复制数据。
例： // 假设Mat类型的imgMat图像数据存在
IplImage pImg= IplImage(imgMat); 
B.Mat -> CvMat
与IplImage的转换类似，不复制数据，只创建矩阵头。
例： // 假设Mat类型的imgMat图像数据存在
     CvMat cvMat = imgMat;
**二、**CvMat类型与IplImage类型**：“图像”类型**
       在openCV中，Mat类型与CvMat和IplImage类型都可以代表和显示图像，但是，Mat类型侧重于计算，数学性较高，openCV对Mat类型的计算也进行了优化。而CvMat和IplImage类型更侧重于“图像”，openCV对其中的图像操作（缩放、单通道提取、图像阈值操作等）进行了优化。
*补充：*IplImage由CvMat派生，而CvMat由CvArr派生即CvArr -> CvMat -> IplImage
            CvArr用作函数的参数，无论传入的是CvMat或IplImage，内部都是按CvMat处理。
**1.CvMat**
A.CvMat-> IplImage
IplImage* img = cvCreateImage(cvGetSize(mat),8,1);
cvGetImage(matI,img);
cvSaveImage("rice1.bmp",img);
B.CvMat->Mat
与IplImage的转换类似，可以选择是否复制数据。
Mat::Mat(const CvMat* m, bool copyData=false);
在openCV中，没有向量（vector）的数据结构。任何时候，但我们要表示向量时，用矩阵数据表示即可。
但是，CvMat类型与我们在线性代数课程上学的向量概念相比，更抽象，比如CvMat的元素数据类型并不仅限于基础数据类型，比如，下面创建一个二维数据矩阵：
              CvMat* cvCreatMat(int rows ,int cols , int type);
这里的type可以是任意的预定义数据类型，比如RGB或者别的多通道数据。这样我们便可以在一个CvMat矩阵上表示丰富多彩的图像了。
**2.IplImage**
在类型关系上，我们可以说IplImage类型继承自CvMat类型，当然还包括其他的变量将之解析成图像数据。
IplImage类型较之CvMat多了很多参数，比如depth和nChannels。在普通的矩阵类型当中，通常深度和通道数被同时表示，如用32位表示RGB+Alpha.但是，在图像处理中，我们往往将深度与通道数分开处理，这样做是OpenCV对图像表示的一种优化方案。
IplImage的对图像的另一种优化是变量origin----原点。在计算机视觉处理上，一个重要的不便是对原点的定义不清楚，图像来源，编码格式，甚至操作系统都会对原地的选取产生影响。为了弥补这一点，openCV允许用户定义自己的原点设置。取值0表示原点位于图片左上角，1表示左下角。
dataOrder参数定义数据的格式。有IPL_DATA_ORDER_PIXEL和IPL_DATA_ORDER_PLANE两种取值，前者便是对于像素，不同的通道的数据交叉排列，后者表示所有通道按顺序平行排列。
IplImage类型的所有额外变量都是对“图像”的表示与计算能力的优化。
A.IplImage -> Mat
IplImage* pImg = cvLoadImage("lena.jpg");
Mat img(pImg,0); // 0是不複製影像，也就是pImg與img的data共用同個記憶體位置，header各自有
B.IplImage -> CvMat
法1：CvMat mathdr, *mat = cvGetMat( img, &mathdr );
法2：CvMat *mat = cvCreateMat( img->height, img->width, CV_64FC3 );
  cvConvert( img, mat );
C.IplImage*-> BYTE*
BYTE* data= img->imageData;
**CvMat和IplImage创建时的一个小区别：**
1、建立矩阵时，第一个参数为行数，第二个参数为列数。
CvMat* cvCreateMat( int rows, int cols, int type );
2、建立图像时，CvSize第一个参数为宽度，即列数；第二个参数为高度，即行数。这 个和CvMat矩阵正好相反。
IplImage* cvCreateImage(CvSize size, int depth, int channels );
CvSize cvSize( int width, int height );
IplImage内部buffer每行是按4字节对齐的，CvMat没有这个限制
*补充：*
A.BYTE*-> IplImage*
img= cvCreateImageHeader(cvSize(width,height),depth,channels);
cvSetData(img,data,step);
//首先由cvCreateImageHeader()创建IplImage图像头，制定图像的尺寸，深度和通道数；
//然后由cvSetData()根据BYTE*图像数据指针设置IplImage图像头的数据数据，
//其中step指定该IplImage图像每行占的字节数，对于1通道的IPL_DEPTH_8U图像，step可以等于width。
