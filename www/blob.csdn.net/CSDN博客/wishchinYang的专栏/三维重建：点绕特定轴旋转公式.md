# 三维重建：点绕特定轴旋转公式 - wishchinYang的专栏 - CSDN博客
2018年07月05日 14:22:09[wishchin](https://me.csdn.net/wishchin)阅读数：4593
     一些特定的三维平面运算可以直接在三维空间中进行，也可以在二维平面中运行，通过坐标变化转换到三维空间。旋转方式有中心旋转、轴旋转。
**1. 罗德里格旋转公式 **
   在三维旋转理论体系中，**罗德里格旋转公式**（根据[欧林·罗德里格](http://zh.wikipedia.org/w/index.php?title=%E6%AD%90%E6%9E%97%C2%B7%E7%BE%85%E5%BE%B7%E9%87%8C%E6%A0%BC&action=edit&redlink=1)命名）是在给定转轴和旋转角度后，旋转一个向量的有效算法。如果**v**是在![\mathbb{R}^3](http://upload.wikimedia.org/math/4/3/2/4323e25409ba6e2046668f8fc174381a.png)中的向量，**k**是转轴的[单位向量](http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BD%8D%E5%90%91%E9%87%8F)，θ是旋转角度（根据[叉乘](http://zh.wikipedia.org/wiki/%E5%8F%89%E4%B9%98)的[方向](http://zh.wikipedia.org/wiki/%E5%AE%9A%E5%90%91_%28%E6%95%B0%E5%AD%A6%29)确定正负号），那罗德里格旋转公式表达为：
![\mathbf{v}_\mathrm{rot} = \mathbf{v} \cos\theta + (\mathbf{k} \times \mathbf{v})\sin\theta  + \mathbf{k} (\mathbf{k} \cdot \mathbf{v}) (1 - \cos\theta).](http://upload.wikimedia.org/math/f/8/2/f82f4d4b04a0c680c32974ad29a1f8cb.png)
输入：
V = (vx, vy, vz) = (u, v, w)，这是待旋转的一个向量。
K = (kx, ky, kz) = (x, y, z)，这是单位化后的转轴。
输出：Vrot
计算过程及公式：
Vrot = V cosT + (K * V) sinT + K ( K . V) (1- cosT) 
        = (u, v, w) cosT + (yw - zv, zu - xw, xv - yu) sinT + (x, y, z)(xu + yv + zw)(1 - cosT)
计算公式：
 Vrot.x = u cosT + (yw - zv) sinT + x (xu + yv + zw) ( 1- cosT)
 Vrot.y = v cosT + (zu - xw) sinT + y (xu + yv + zw) ( 1- cosT)
 Vrot.z = w cosT + (xv - yu) sinT + z (xu + yv + zw) ( 1- cosT)
代码（java版本）：
```java
public static Point3d  rtRoundLine( Point3d line,  Point3d p, double Aplha ){
		
		double u = p.m_x;
		double v = p.m_y;
		double w = p.m_z;
		double T = Aplha;
		Point3d axisU = unit( line );
		double x= axisU.m_x;
		double y= axisU.m_y;
		double z= axisU.m_z;
		
		//长度
		double l= Math.sqrt(dot(line,line) );
		Point3d Vrot = new Point3d();
		Vrot.m_x = u *Math.cos(T) + (y * w - z * v) *Math.sin(T) + x *(x * u + y * v + z * w)*( 1- Math.cos(T));
		Vrot.m_y = v *Math.cos(T) + (z * u - x * w) *Math.sin(T) + y *(x * u + y * v + z * w)*( 1- Math.cos(T));
		Vrot.m_z = w *Math.cos(T) + (x * v - y * u) *Math.sin(T) + z *(x * u + y * v + z * w)*( 1- Math.cos(T));
		return Vrot;
	}
```
但是罗德里格旋转公式不适用于任意旋转轴旋转，得到的结果是错误的。
**二、任意点绕特定轴旋转**
   参考文章：[点绕任意轴旋转](https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html)....
   使用通用的把轴转换到Z轴上的方法，经过两次变换和两次逆变换得到旋转矩阵。
如下方法处理：
- 将旋转轴平移至原点
- 将旋转轴旋转至YOZ平面
- 将旋转轴旋转至于Z轴重合
- 绕Z轴旋转θ度
- 执行步骤3的逆过程
- 执行步骤2的逆过程
- 执行步骤1的逆过程
假设用v1(a1, b2, c2)和v2(a2, b2, c2)来表示旋转轴，θ表示旋转角度。为了方便推导，暂时使用右手系并使用列向量，待得出矩阵后转置一下即可，上面步骤对应的流程图如下。
![](https://img-blog.csdn.net/20180705155311930?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpc2hjaGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
.................................
得到下面的绕任意轴旋转的矩阵
![](https://img-blog.csdn.net/20180705155324422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpc2hjaGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
即
![](https://img-blog.csdn.net/20180705155418649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpc2hjaGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
对应的函数代码如下(Java版本):
```java
public static double[][] GetRotMatByLine( Point3d v1, Point3d v2, double theta )
	{
		int col = 4;
		int row = 4;
		double[][] pOut= new double[row][col];//一次性完成？？？
	    double a = v1.m_x;
	    double b = v1.m_y;
	    double c = v1.m_z;
	    //D3DXVECTOR3 p = *v2 - *v1;
	    Point3d p = new Point3d(v2.m_x-v1.m_x,v2.m_y-v1.m_y,v2.m_z-v1.m_z);
	    //D3DXVec3Normalize(&p, &p);
	    p = unit( p );
	    double u = p.m_x;
	    double v = p.m_y;
	    double w = p.m_z;
	    double uu = u * u;
	    double uv = u * v;
	    double uw = u * w;
	    double vv = v * v;
	    double vw = v * w;
	    double ww = w * w;
	    double au = a * u;
	    double av = a * v;
	    double aw = a * w;
	    double bu = b * u;
	    double bv = b * v;
	    double bw = b * w;
	    double cu = c * u;
	    double cv = c * v;
	    double cw = c * w;
	    double costheta = Math.cos(theta);
	    double sintheta = Math.sin(theta);
	    pOut[0][0] = uu + (vv + ww) * costheta;
	    pOut[0][1] = uv * (1 - costheta) + w * sintheta;
	    pOut[0][2] = uw * (1 - costheta) - v * sintheta;
	    pOut[0][3] = 0;
	    pOut[1][0] = uv * (1 - costheta) - w * sintheta;
	    pOut[1][1] = vv + (uu + ww) * costheta;
	    pOut[1][2] = vw * (1 - costheta) + u * sintheta;
	    pOut[1][3] = 0;
	    pOut[2][0] = uw * (1 - costheta) + v * sintheta;
	    pOut[2][1] = vw * (1 - costheta) - u * sintheta;
	    pOut[2][2] = ww + (uu + vv) * costheta;
	    pOut[2][3] = 0;
	    pOut[3][0] = (a * (vv + ww) - u * (bv + cw)) * (1 - costheta) + (bw - cv) * sintheta;
	    pOut[3][1] = (b * (uu + ww) - v * (au + cw)) * (1 - costheta) + (cu - aw) * sintheta;
	    pOut[3][2] = (c * (uu + vv) - w * (au + bv)) * (1 - costheta) + (av - bu) * sintheta;
	    pOut[3][3] = 1;
	    
	    return pOut;
	}//GetRotMatByLine
```
使用函数的代码：
```java
public static Point3d  rtRoundLine( Point3d ps, Point3d pe,  Point3d p, double Aplha,double[][] transM  ){
		//计算旋转点
		Point3d Vrot = new Point3d();
		//点乘矩阵
		if( true ){
			Vrot.m_x = p.m_x* transM[0][0] +p.m_y* transM[1][0] +p.m_z* transM[2][0]+ transM[3][0];
			Vrot.m_y = p.m_x* transM[0][1] +p.m_y* transM[1][1] +p.m_z* transM[2][1]+ transM[3][1];
			Vrot.m_z = p.m_x* transM[0][2] +p.m_y* transM[1][2] +p.m_z* transM[2][2]+ transM[3][2];
		}
		Vrot.m_z =-Vrot.m_z;
		return Vrot;
	}
```
示例结果：
![](https://img-blog.csdn.net/2018070514225668?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpc2hjaGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![](https://img-blog.csdn.net/20180705142304668?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpc2hjaGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
点云图与平面图对比
参考：[各种旋转方式总结](https://blog.csdn.net/u012750702/article/details/72229117).....
[罗德里格旋转公式](https://baike.baidu.com/item/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F/18878562?fr=aladdin)....
