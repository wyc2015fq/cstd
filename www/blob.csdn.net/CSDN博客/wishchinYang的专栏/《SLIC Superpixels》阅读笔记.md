# 《SLIC Superpixels》阅读笔记 - wishchinYang的专栏 - CSDN博客
2013年12月19日 14:49:38[wishchin](https://me.csdn.net/wishchin)阅读数：1666
个人分类：[图像特征																[OpenCV](https://blog.csdn.net/wishchin/article/category/5778933)](https://blog.csdn.net/wishchin/article/category/1860001)
原始链接：[http://blog.csdn.net/jkhere/article/details/16819285](http://blog.csdn.net/jkhere/article/details/16819285)
或许有改动，请参考原文！
SLIC 超像素（SLICSuperpixels）
Radhakrishna Achanta, Appu Shaji, KevinSmith, Aurelien Lucchi,
Pascal Fua, and Sabine Susstrunk
**摘要：**
超像素在计算机视觉领域越来越流行。但是，低计算量的算法却很少。我们发明了一种原创的算法，使像素聚类为五维颜色和图像层，用来生成简洁整齐的超像素。我们的研究结果非常简单易用，效率很高，具备很好的实用价值。实验证明我们的算法计算消耗低，但是却达到或者超过了其他4种最新的（state-of-art）方法。这种结论是通过比较boundary recall和under-segmentation error得出的。
**1.介绍：**
超像素提供了一种便捷的方式来计算local features。他们通过获得图像中的redundancy来大幅度地减轻后续图像处理的复杂度。已经证明在深度估算（depth estimation），图像分割（image segmentation），骨架提取（skeletonization），人体模型估计（body modelestimation），目标定位（object localization）等等领域十分有效。
超像素要想实际应用必须要运算速度快，简单易用，并且生成高质量的分割。不幸的是，现在最新的超像素生成方法都不能同时满足上述的要求。有的方法计算量大，有的算法分割质量差，有的算法包含多重难调的参数。
我们在本文中提出的方法，简单的同时达到了高质量整齐的超像素分割，并且比最新的方法都要效率高。我们提出的算法叫simple linear iterative clustering(SLIC)，采用的是当地像素聚类（local clustering），该像素是5维的（5-D space）， 是通过定义CIELAB颜色空间（就是Lab颜色空间）中的L,a,b数值以及x，y像素坐标。提出的一种全新的距离计算方法加强了超像素形状的整齐性，可以同时用于彩色图像和灰度图像。SLIC很简单就能实现---唯一需要的参数就是设定超像素的个数。在伯克利标准数据库（Berkeley
 benchmark dataset）中实验表明，SLIC在产生相似或更好的分割时，效率大幅度提高。该结论通过standard boundary recall和under-segmentationmeasures得到的。
对于很多视觉任务来说，紧凑整齐的超像素，就像SLIC生成的那样，是非常需要的。例如，基于图的模型条件随机场（ConditionalRandom Fields (CRF)），当从像素图到超像素图的时候，可以看到巨大的速度提升，但是松散的无关的超像素会使表现变差。如果超像素分割的松散的话，从超像素提取的本地特征SIFT会变得失去意义，没有区分度。这种现象可以通过比较两种视觉任务显现出来：物体分类识别和医学图像分割。两个例子中，我们的结果都比现有的方法表现要好并且计算量低。
**2.研究背景**
这个部分简要回顾现有的图像分割方法，重点放在生成超像素的适应性上。当然，并不是所有的算法都是用于这个目的，所以有的分割出来可能不够紧凑。但是我们依然讨论他们。
我们大体上将超像素算法分为两大类:基于图的和基于梯度上升的。我们的调查结果见Table 1，考虑的因素是分割质量，能不能控制分割数目和大小。
**2.1基于图的分割算法**
基于图的分割算法中，每个像素被认为是一个节点，两个节点间的边界权重取决于像素间的差值。超像素的分割是通过最小化一个定义在图上的cost funcation来得到的。Normalized cuts algorithm[9]是一个典型的算法，用的是形状（contour）和纹理（texture）。这是NC05的基本原理，NC05的算法复杂度为O(N3/2),N是像素的总个数。有方法可以提高运算效率，但是对大图像来说它仍然计算量大。NC05多用于骨架提取（skeletonization），人体模型估计（body
 modelestimation）。
Fezenszwalb和Huttenlocher[GS04]提出了一种采用最短生成树的算法，效率提高，但是不能控制超像素的数目和紧凑。算法的复杂度为O(NlogN)。
一种超像素网格的生成算法[SL08]，是通过寻找最佳垂直或水平路径来切分图像，采用基于图像条的图割方法（Asuperpixel lattice is generated by [14] (SL08) by finding optimalvertical(horizontal) seams/paths that cut the image, within vertical(horizontal) strips of pixels, using graph cuts on strips
 of the image.）。SL08算法允许设定超像素的大小、数量，但分割质量和分割速度严重依赖于pre-computedboundary maps。
基于梯度上升的分割算法：从一个初始的粗糙聚类开始，每次迭代得到一个更好的分割，直到收敛为止。接下来讲了Mean-shift，Quick-shift,以及Watersheds和Turbopixels的优缺点。
**2.2 基于梯度上升的算法**
从一个初始的粗糙聚类开始，每次迭代得到一个更好的分割，直到收敛为止。接下来，作者讨论了一下Mean-shift，Quick-shift,以及Watersheds和Watersheds。简单介绍了一下，然后分析了一下它的缺点。
Mean-shift不能控制超像素的大小和数目，因为Mean-shift依赖于输入的核参数。
Quick-shift要比Mean-shift快一点，跟Mean-shift一样也不能控制超像素的大小和数目。
接下来还讲了一下Watersheds和Watersheds，但没讲这两种方法的缺点，只是简单的介绍了一下这方面的工作。
**3.SLIC分割算法**
我们生成超像素是通过基于颜色相似度和临近度的像素聚类。这是在5维中进行的，[labxy]。[lab]是指CIELAB颜色空间中的像素颜色向量。CIELAB颜色空间就是指HSV空间，亮度空间，xy指像素的位置。两种颜色的最大的空间是有限的，空间距离依赖于图片大小。不可能简单地采用欧式距离在这5维空间中，如果不对空间距离归一化的话。为了使5维空间中的像素聚类，我们因此引入了一种新的距离测量方法。通过这种新的测量方法，我们把颜色相似度和像素位置融合了起来。
**3.1距离测量方法**
输入一个超像素数目的参数K。那么对于一张N个像素的图像来说，每个超像素大小约为N/K个像素。那么，每两个相邻的超像素块之间的距离为s=sqrt(N/K)。算法开始时，我们选择聚类的中心Ck =[lk,ak,bk,xk,yk],k属于[1,K]。每个超像素的面积大约为S的平方（近似于超像素的面积）。我们可以安全地假设：像素在聚类中心的2S*2S范围内。这个范围就是每个聚类中心的搜寻范围。
欧式距离在亮度空间内小距离是很有意义的。如果空间像素距离超过了颜色距离，那么图像上的边界不再有效（文章的意思是这样是不对的）。因此，在5D空间中取代简单的欧式距离，我们采用Ds如下：
其中Ds是lab距离和归一化后的xy距离之和。其中变量m用来控制超像素的紧密度。m的值在[1,20]之间。在接下来的文章中，我们统一选择m=10。这个数值既能在感官经验上满足颜色距离最大化，又能很好的在颜色相似度和空间相似度的平衡。
**3.2算法**
我们开始采样K个空间聚类中心，并且移动到3X3的最低梯度位置。这样做的好处是避免把他们放到边界，也避免选择了噪点像素。图像梯度的计算公式是:
其中I(x,y)是lab向量在位置(x,y)上的值。||.||是用的L2 norm。这同时考虑了颜色和强度信息。
每个像素与最近的聚类中心联系起来，并且被该聚类中心的search area覆盖。所有的像素与聚类中心联系起来后，一个新的中心被计算出来了。这个新中心是所有属于该聚类的labxy向量的平均值。我们重复该过程直到收敛为止。
最后，可能存在一些迷失的labels，那是因为附近一个大一些的分割有同样的label但并没有包含它。但是很少见，这种情况可能增加，因为我们的聚类没有明确地加强连通性。不管怎样，我们在最后一步加强连通性，重新标记不相交的分割块，通过最大附近聚类的标签。这一步是O(N)复杂度，时间消耗小于整体分割的10%。
**3.3 复杂度计算**
很容易就会注意到，在我们的算法中，本地聚类和聚类中心是k均值算法的特殊的例子，应用于生成超像素算法中。有趣的是，凭借距离公式1，我们能够定位图像plane上像素寻找区域，该区域与超像素的个数K成反比。实际上，一个像素落在当地不超过8个聚类中心的范围内。我们也注意到本算法的收敛误差在某几次迭代中急剧下降。我们实验表明运行本算法4到10次就足够了。本文章中，我们采用10次迭代的方法。
经典的k均值算法的时间复杂度是O(NKI)，N是数据量(像素点数)，K是聚类数(seeds),I是迭代次数。我们的方法达到了O(N)级别的复杂度，因为计算距离（不超过8个聚类中心）和迭代次数都是常量。因此SLIC是专门用来处理超像素分割的而不像k均值，并且避免了一些多余的距离计算。
有一些算法已经改进了k均值的收敛速度[18,19,20,21]。但是除了[21]以外，对于一个给定的K，都没有达到线性复杂度。但是SLIC是关于K线性的。注意，像[21]一样，对于距离计算，SLIC隐性地设置了边界，但是却不需要在接下来的迭代中重新计算边界。不类似大多数的分割算法，SLIC是专门用来超像素聚类的，并且更加简单。
**4.比较**
本章节，我们拿本算法和4种最先进的分割算法作比较，该四种方法为GS04，NC05，TP09，QS09,用的是公开的源代码。GS04和NC05是基于图分割的，TP09，QS09是基于梯度分割的。NC05和TP09被设计用来输出确定数量的超像素，而GS04和QS09需要参数调节才能得到指定的超像素数量。这4中算法应该很好地代表了当前最新的研究成果。总之一句话，作者的意思是：我采用的比较算法是很全面，很具有代表性的。
图2 视觉化地呈现了比较结果。为了提供有质量的比较，我们采用了under-segmentation error和boundary recall作为比较参数，计算用的是Berkeley segmentation ground truth。
**4.1 本算法的参数**
正如简介中提到的那样，超像素分割的易用性也是十分重要的。难以设置的参数会导致时间的浪费和表现的不佳。表1给出了每种算法需要设置的参数。SLIC，NC05和TP09都只需要一个参数。更应该注意到的是：CS04和QS09不允许用户控制超像素的数目。为了公平的比较，我们不得不手动得到。
**4.2 Under-segmentation error**
Under-segmentationerror该误差是用来测量算法在分割图像的时候产生的错误，与算法比较的是已知的准确分割出的结果（ground truth，是通过手工分割出来的）。这误差是用“bleeding”得出的。（这句不懂！）该方法惩罚超像素跟真实分割不重合的情况。如果真实分割是g1,g2,...,gM,超像素是s1,s2,...,sL,那么Under-segmentation error的计算公式就是：
**4.3 Boundary recall**
我们采用标准的Boundaryrecall方法来计算落入超像素边界的比例。我们用的是每个超像素的内部边界。
**4.4 计算和内存效率**
对于480X320的图像，SLIC的速度比TP09快10倍，比NC05快500倍。令人振奋的是，对于半个百万像素图片来说，比CS04还要快。这是因为我们的算法是O(N),而GS04是O(NlogN)。这很有意义，因为即使低像素的摄像机产生的图片也能超过3百万像素。另外，GS04需要5xN的内存来存储边界权值和阈值，SLIC只需要1xN的内存（来存储每个像素到最近聚类的距离）。
**4.5 讨论**
一个好的超像素分割应该具有低的under-segmentation error和高的Boundary recall。作为有用的预处理算法的一种，分割算法应该得到大小相同的超像素并且能控制超像素的数量。同样的原因，应该具备低计算量，少的输入参数。实验表明：最高的Boundary recall是GS04。这是因为它的分割靠近目标边界。但是，GS04的under-segmentation error比本算法高。我们的算法under-segmentation error最低，并且Boundary recall也很高。GS04不能指定超像素的数目，并且每个超像素的大小也不一样，所以很多基于超像素的算法不适用GS04[5,6,7]。另外，我们的算法最快，产生的超像素大小相同紧凑。
**5.超像素的应用**
操作超像素比直接操作像素可以大大提高计算速度，有时候甚至可以得到更好的结果[7]。例如，一些基于图的分割可以提高2-3倍。当然，超像素算法本身应该快到符合实际应用的需求。接下来，我们考虑两种典型的视觉应用:物体分类识别（object class recognition）和医学图像分割（medical image segmentation）。在这两个例子中，超像素可以大幅度地提升效果并能够减少计算量。我们得出SLIC比其他的算法优秀，计算量少。
**5.1 物体分类识别**
用的测试库是STAIRvision library。效果好！
**5.2医学图像分割**
分析了很多，这块不翻译了。文中给出了很多比较图。
**6. 结论**
对于视觉任务，如物体分类识别，医学图像分割，超像素分割作为预处理步骤是非常有用的。但是要想实际应用必须能够得到高质量的超像素，大小也相同，计算量也要小。现在极少算法能够符合所有条件。我们提出一种新的，复杂度为O(N)的超像素分割算法。该算法方便部署，得到高质量的分割结果，计算量很小。仅仅需要1个参数（就是超像素的个数）作为输入参数。它仅仅需要线性的计算量和内存量。我们还证明了在物体分割识别和医学图像处理上的优越性。与最新的算法对比，得到的结果质量更好，能耗更低。
**7.引用文献（reference）**
这块不翻译了，见原文。
本文由 JKhere 翻译于2013年11月19日，仅供学习研究。
