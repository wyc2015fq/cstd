# 12种排序算法 - cuihuan1702的博客 - CSDN博客












2017年10月18日 11:19:08[cuihuan1702](https://me.csdn.net/cuihuan1702)阅读数：553










# 作者：寒小阳时间：2013年9月。出处：[](http://blog.csdn.net/han_xiaoyang/article/details/12118943)[http://blog.csdn.net/han_xiaoyang/article/details/12163251](http://blog.csdn.net/han_xiaoyang/article/details/12163251)。声明：版权所有，转载请注明出处，谢谢。# 0、前言     从这一部分开始直接切入我们计算机互联网笔试面试中的重头戏算法了，初始的想法是找一条主线，比如数据结构或者解题思路方法，将博主见过做过整理过的算法题逐个分析一遍(博主当年自己学算法就是用这种比较笨的刷题学的，囧)，不过又想了想，算法这东西，博主自己学的过程中一直深感，基础还是非常重要的，很多难题是基础类数据结构和题目的思想综合发散而来。比如说作为最基本的排序算法就种类很多，而事实上笔试面试过程中发现掌握的程度很一般，有很多题目，包括很多算法难题，其母题或者基本思想就是基于这些经典算法的，比如说快排的partition算法，比如说归并排序中的思想，比如说桶排序中桶的思想。        这里对笔试面试最常涉及到的12种排序算法(包括插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序)进行了详解。每一种算法都有基本介绍、算法原理分析、图解/flash演示/视频演示、算法代码、笔试面试重点分析、笔试面试题等板块，希望能帮助大家真正理解这些排序算法，并能使用这些算法的思想解决一些题。不多说了，下面就进入正题了。# 一、插入排序## 1）算法简介        插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。## 2）算法描述和分析    一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：    1、从第一个元素开始，该元素可以认为已经被排序    2、取出下一个元素，在已经排序的元素序列中从后向前扫描    3、如果该元素（已排序）大于新元素，将该元素移到下一位置    4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置    5、将新元素插入到该位置后    6、重复步骤2~5        如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929144225312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)下列排序算法中最坏复杂度不是n(n-1)/2的是 DA.快速排序     B.冒泡排序   C.直接插入排序   D.堆排序# 二、二分插入排序## 1）算法简介       二分（折半）插入（Binary insert sort)排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。## 2）算法描述和分析    一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：    1、从第一个元素开始，该元素可以认为已经被排序    2、取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置    3、将新元素插入到该位置后    4、重复上述两步        1）稳定        2）空间代价：O(1)        3）时间代价：插入每个记录需要O(log i)比较，最多移动i+1次，最少2次。最佳情况O(n log n)，最差和平均情况O(n^2)。        二分插入排序是一种稳定的排序。当n较大时，总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929144225312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)##  5）考察点，重点和频度分析        这个排序算法在笔试面试中出现的频度也不高，但毕竟是直接排序算法的一个小改进算法，同时二分查找又是很好的思想，有可能会在面试的时候提到，算法不难，留心一下就会了。## 6）笔试面试例题### 例题1、下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的是（B）A、二分插入排序         B、堆排序         C、冒泡排序            D、快速排序### 例题2、写出下列算法的时间复杂度。(1)冒泡排序；(2)选择排序；(3)插入排序；(4)二分插入排序；(5)快速排序；(6)堆排序；(7)归并排序；# 三、希尔排序## 1）算法简介希尔排序，也称递减增量排序算法，因DL．Shell于1959年提出而得名，是插入排序的一种高速而稳定的改进版本。## 2）算法描述    1、先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。    2、所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。    3、取第二个增量d2<d1重复上述的分组和排序，    4、直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。          希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n^2)，而Hibbard增量的希尔排序的时间复杂度为O(N^(5/4))，但是现今仍然没有人能找出希尔排序的精确下界。## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929145755250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929145816140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929145822953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929145839109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点，重点和频度分析        事实上希尔排序算法在笔试面试中出现的频度也不比直接插入排序高，但它的时间复杂度并不是一个定值，所以偶尔会被面试官问到选择的步长和时间复杂度的关系，要稍微有点了解吧。算法大题中使用该方法或者其思想的题也不多。## 6）笔试面试例题### 例题1、写出希尔排序算法程序，并说明最坏的情况下需要进行多少次的比较和交换。    程序略，需要O(n^2)次的比较### 例题2、设要将序列（Q, H, C, Y, P, A, M, S, R, D, F, X）中的关键码按字母序的升序重新排列，则：冒泡排序一趟扫描的结果是       H, C, Q, P, A, M, S, R, D, F, X ,Y      ；初始步长为4的希尔（shell）排序一趟的结果是   P, A, C, S, Q, D, F, X , R, H,M, Y     ；二路归并排序一趟扫描的结果是   H, Q, C, Y，A, P, M, S, D, R, F, X   ；快速排序一趟扫描的结果是     F, H, C, D, P, A, M, Q, R, S, Y，X     ；堆排序初始建堆的结果是   A, D, C, R, F, Q, M, S, Y，P, H, X   。# 四、选择排序## 1）算法简介       选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。## 2）算法描述和分析       n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果： 1、初始状态：无序区为R[1..n]，有序区为空。       2、第i趟排序(i=1,2,3...n-1)第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。       3、前n-1趟结束，数组有序化了        选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。比较次数O(n^2),比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+...+1=n*(n-1)/2。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。|最差时间复杂度|О(n2)||----|----||最优时间复杂度|О(n2)||平均时间复杂度|О(n2)||最差空间复杂度|О(n) total, O(1)|## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929150444921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点，重点和频度分析        就博主看过的笔试面试题而言，选择算法也大多出现在选择填空中，要熟悉其时间和空间复杂度，最好最坏的情况分别是什么，以及在那种情况下，每一轮的比较次数等。## 6）笔试面试例题## 例题1、在插入和选择排序中，若初始数据基本正序，则选用 插入排序（到尾部）   ；若初始数据基本反序，则选用   选择排序     。## 例题2、 下述几种排序方法中，平均查找长度（ASL）最小的是Ａ. 插入排序      Ｂ.快速排序        Ｃ. 归并排序       Ｄ. 选择排序# 五、冒泡排序## 1）算法简介        冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。## 2）算法描述      1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。      2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。      3、针对所有的元素重复以上的步骤，除了最后一个。      4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。       冒泡排序是与插入排序拥有相等的执行时间，但是两种法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地执行（O(n^2)），而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次执行时，使用一个旗标来表示有无需要交换的可能，也有可能把最好的复杂度降低到O(n)。在这个情况，在已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序和比较大小反过来，也可以稍微地改进效率。有时候称为往返排序，因为算法会从数列的一端到另一端之间穿梭往返。|最差时间复杂度|O(n^2)||----|----||最优时间复杂度|O(n)||平均时间复杂度|O(n^2)||最差空间复杂度|总共O(n)，需要辅助空间O(1)|## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929151112984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[## 5）考察点，重点和频度分析       一般我们学到的第一个排序算法就是冒泡排序，不得不说，这个还真是一个很常见的考点，平均时间空间复杂度，最好最坏情况下的时间空间复杂度，在不同情况下每一趟的比较次数，以及加标志位减少比较次数等，都是需要注意的地方。## 6）笔试面试例题### 例题1、对于整数序列100，99，98，…3，2，1，如果将它完全倒过来，分别用冒泡排序，它们的比较次数和交换次数各是多少？答：冒泡排序的比较和交换次数将最大，都是1+2+…+n-1=n(n-1)/2＝50×99=4545次。### 例题2、   把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间。      事实上，这道题放到冒泡排序这里不知道是不是特别合适，只是有一种解法是类似冒泡的思想，如下解法一#### 解法一、每次遇到大写字母就往后冒，最后结果即为所求#### 解法二、步骤如下1、两个指针p1和p2，从后往前扫描2、p1遇到一个小写字母时停下， p2遇到大写字母时停下，两者所指向的char交换3、p1， p2同时往前一格# 六、鸡尾酒排序/双向冒泡排序## 1）算法简介        鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。## 2）算法描述和分析    1、依次比较相邻的两个数，将小数放在前面，大数放在后面；     2、第一趟可得到：将最大数放到最后一位。     3、第二趟可得到：将第二大的数放到倒数第二位。     4、如此下去，重复以上过程，直至最终完成排序。    鸡尾酒排序最糟或是平均所花费的次数都是O(n^2)，但如果序列在一开始已经大部分排序过的话，会接近O(n)。|最差时间复杂度|O(n^2)||----|----||最优时间复杂度|O(n)||平均时间复杂度|O(n^2)|## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929151719906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点，重点和频度分析        鸡尾酒排序在博主印象中出现的频度也不高，用到它的算法题大题很少，选择填空出现的话多以双向冒泡排序的名称出现，注意注意时间空间复杂度，理解理解算法应该问题就不大了。## 6）笔试面试例题   考点基本类似冒泡排序，请参考上一节# 七、快速排序       恩，重头戏开始了，快速排序是各种笔试面试最爱考的排序算法之一，且排序思想在很多算法题里面被广泛使用。是需要重点掌握的排序算法。## 1）算法简介       快速排序是由东尼·霍尔所发展的一种排序算法。其基本思想是基本思想是，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。## 2）算法描述和分析快速排序使用分治法来把一个串（list）分为两个子串行（sub-lists）。步骤为：     1、从数列中挑出一个元素，称为 "基准"（pivot），2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。    递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。算法伪代码描述：function quicksort(q)     var list less, pivotList, greater     if length(q) ≤ 1 {         return q     } else {         select a pivot value pivot from q         for each x in q except the pivot element             if x < pivot then add x to less             if x ≥ pivot then add x to greater         add pivot to pivotList         return concatenate(quicksort(less), pivotList, quicksort(greater))     }在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。|最差时间复杂度|O(n^2)||----|----||最优时间复杂度|O(n log n)||平均时间复杂度|O(n log n)||最差空间复杂度|根据实现的方式不同而不同|## 3）算法图解、flash演示、视频演示### 图解：        快速排序会递归地进行很多轮，其中每一轮称之为快排的partition算法，即上述算法描述中的第2步，非常重要，且在各种笔试面试中用到该思想的算法题层出不穷，下图为第一轮的partition算法的一个示例。![](https://img-blog.csdn.net/20130929152345453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 4）算法代码        事实上，这个地方需要提一下的是，快排有很多种版本。例如，我们“基准数”的选择方法不同就有不同的版本，但重要的是快排的思想，我们熟练掌握一种版本，在最后的笔试面试中也够用了，我这里罗列几种最有名的版本C代码。### 1、版本一我们选取数组的第一个元素作为主元，每一轮都是和第一个元素比较大小，通过交换，分成大于和小于它的前后两部分，再递归处理。### 2、版本二 随机选基准数的快排## 5）考察点，重点和频度分析       完全考察快排算法本身的题目，多出现在选择填空，基本是关于时间空间复杂度的讨论，最好最坏的情形交换次数等等。倒是快排的partition算法需要特别注意！频度极高地被使用在各种算法大题中！详见下小节列举的面试小题。## 6）笔试面试例题   这里要重点强调的是快排的partition算法，博主当年面试的时候就遇到过数道用该思路的算法题，举几道如下：### 例题1、最小的k个数，输入n个整数，找出其中最下的k个数，例如输入4、5、1、6、2、7、3、8、1、2，输出最下的4个数，则输出1、1、2、2。        当然，博主也知道这题可以建大小为k的大顶堆，然后用堆的方法解决。        但是这个题目可也以仿照快速排序，运用partition函数进行求解，不过我们完整的快速排序分割后要递归地对前后两段继续进行分割，而这里我们需要做的是判定分割的位置，然后再确定对前段还是后段进行分割，所以只对单侧分割即可。代码如下：### 例题3、有一个由大小写组成的字符串，现在需要对他进行修改，将其中的所有小写字母排在大写字母的前面(不要求保持原顺序)        这题可能大家都能想到的方法是：设置首尾两个指针，首指针向后移动寻找大写字母，尾指针向前移动需找小写字母，找到后都停下，交换。之后继续移动，直至相遇。这种方法在这里我就不做讨论写代码了。        但是这题也可以采用类似快排的partition。这里使用从左往后扫描的方式。字符串在调整的过程中可以分成两个部分：已排好的小写字母部分、待调整的剩余部分。用两个指针i和j，其中i指向待调整的剩余部分的第一个元素，用j指针遍历待调整的部分。当j指向一个小写字母时，交换i和j所指的元素。向前移动i、j，直到字符串末尾。代码如下：# 八、堆排序        不得不说，堆排序太容易出现了，选择填空问答算法大题都会出现。建堆的过程，堆调整的过程，这些过程的时间复杂度，空间复杂度，以及如何应用在海量数据Top K问题中等等，都是需要重点掌握的。## 1）算法简介        堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。## 2）算法描述       我们这里介绍几个问题，一步步推到堆排序的算法。### 1、什么是堆？      我们这里提到的堆一般都指的是二叉堆，它满足二个特性：           1---父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。           2---每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。     如下为一个最小堆(父结点的键值总是小于任何一个子节点的键值)![](https://img-blog.csdn.net/20130929153051656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)### 2、什么是堆调整(Heap Adjust)？        这是为了保持堆的特性而做的一个操作。对某一个节点为根的子树做堆调整，其实就是将该根节点进行“下沉”操作(具体是通过和子节点交换完成的)，一直下沉到合适的位置，使得刚才的子树满足堆的性质。       例如对最大堆的堆调整我们会这么做：              1、在对应的数组元素A[i], 左孩子A[LEFT(i)], 和右孩子A[RIGHT(i)]中找到最大的那一个，将其下标存储在largest中。              2、如果A[i]已经就是最大的元素，则程序直接结束。              3、否则，i的某个子结点为最大的元素，将A[largest]与A[i]交换。              4、再从交换的子节点开始，重复1,2,3步，直至叶子节点，算完成一次堆调整。这里需要提一下的是，一般做一次堆调整的时间复杂度为log(n)。如下为我们对4为根节点的子树做一次堆调整的示意图，可帮我们理解。![](https://img-blog.csdn.net/20130929153137953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)### 3、如何建堆建堆是一个通过不断的堆调整，使得整个二叉树中的数满足堆性质的操作。在数组中的话，我们一般从下标为n/2的数开始做堆调整，一直到下标为0的数(因为下标大于n/2的数都是叶子节点，其子树已经满足堆的性质了)。下图为其一个图示：![](https://img-blog.csdn.net/20130929153234937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929153255656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)        很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。### 4、如何进行堆排序        堆排序是在上述3中对数组建堆的操作之后完成的。数组储存成堆的形式之后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n-2]交换，再对A[0…n-3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。如下图所示：![](https://img-blog.csdn.net/20130929153402562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929153418218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![](https://img-blog.csdn.net/20130929153540140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)|最差时间复杂度|O(n log n)||----|----||最优时间复杂度|O(n log n)||平均时间复杂度|O(n log n)||最差空间复杂度|O(n)|## 5）考察点，重点和频度分析        堆排序相关的考察太多了，选择填空问答算法大题都会出现。建堆的过程，堆调整的过程，这些过程的时间复杂度，空间复杂度，需要比较交换多少次，以及如何应用在海量数据Top K问题中等等。堆又是一种很好做调整的结构，在算法题里面使用频度很高。## 6）笔试面试题### 例题1、编写算法，从10亿个浮点数当中，选出其中最大的10000个。   典型的Top K问题，用堆是最典型的思路。建10000个数的小顶堆，然后将10亿个数依次读取，大于堆顶，则替换堆顶，做一次堆调整。结束之后，小顶堆中存放的数即为所求。代码如下(为了方便，这里直接使用了STL容器)：### 例题2、设计一个数据结构，其中包含两个函数，1.插入一个数字，2.获得中数。并估计时间复杂度。        使用大顶堆和小顶堆存储。　　使用大顶堆存储较小的一半数字，使用小顶堆存储较大的一半数字。　　插入数字时，在O(logn)时间内将该数字插入到对应的堆当中，并适当移动根节点以保持两个堆数字相等（或相差1）。　　获取中数时，在O(1)时间内找到中数。# 九、归并排序## 1）算法简介        归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。       将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。## 2）算法描述    归并排序具体算法描述如下(递归版本)：    1、Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。    2、Conquer: 对这两个子序列分别采用归并排序。    3、Combine: 将两个排序好的子序列合并成一个最终的排序序列。    归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929154325406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点、重点和频度分析       归并排序本身作为一种高效的排序算法，也是常会被问到的。尤其是归并排序体现的递归思路很重要，在递归的过程中可以完成很多事情，很多算法题也是使用的这个思路，可见下面7）部分的笔试面试算法题。## 6）笔试面试题### 例题1、题目输入一个数组，数组元素的大小在0->999.999.999的范围内，元素个数为0-500000范围。题目要求通过相邻的元素的交换，使得输入的数组变为有序，要求输出交换的次数        这题求解的其实就是一个逆序对。我们回想一下归并排序的过程：        归并排序是用分治思想，分治模式在每一层递归上有三个步骤：分解：将n个元素分成个含n/2个元素的子序列。解决：用合并排序法对两个子序列递归的排序。合并：合并两个已排序的子序列已得到排序结果。在归并排序算法中稍作修改，就可以在n log n的时间内求逆序对。将数组A[1...size]，划分为A[1...mid] 和 A[mid+1...size].那么逆序对数的个数为 f(1, size) = f(1, mid) + f(mid+1, size) + s(1, mid, size)，这里s(1, mid, size)代表左值在[1---mid]中，右值在[mid+1, size]中的逆序对数。由于两个子序列本身都已经排序，所以查找起来非常方便。代码如下：### 例题2、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。        1、hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。2、hash统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。3、堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。### 例题3、归并一个左右两边分别排好序的数组，空间复杂度要求O(1)。使用原地归并，能够让归并排序的空间复杂度降为O(1)，但是速度上会有一定程度的下降。代码如下：# 十、桶排序## 1）算法简介        桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。       桶排序是稳定的，且在大多数情况下常见排序里最快的一种,比快排还要快，缺点是非常耗空间,基本上是最耗空间的一种排序算法，而且只能在某些情形下使用。## 2）算法描述和分析       桶排序具体算法描述如下：      1、设置一个定量的数组当作空桶子。      2、寻访串行，并且把项目一个一个放到对应的桶子去。      3、对每个不是空的桶子进行排序。      4、从不是空的桶子里把项目再放回原来的串行中。       桶排序最好情况下使用线性时间O(n)，很显然桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为 其它部分的时间复杂度都为O(n);很显然，桶划分的越小，各个桶之间的数据越少，排 序所用的时间也会越少。但相应的空间消耗就会增大。       可以证明，即使选用插入排序作为桶内排序的方法，桶排序的平均时间复杂度为线性。 具体证明，请参考算法导论。其空间复杂度也为线性。## 3）算法图解、flash演示、视频演示### 图解![](https://img-blog.csdn.net/20130929154849312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点、重点和频度分析        桶排序是一种很巧妙的排序方法，在处理密集型数排序的时候有比较好的效果(主要是这种情况下空间复杂度不高)，其思想也可用在很多算法题上，详见后续笔试面试算法例题。## 6）笔试面试题### 例题1、一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，你把这500 万元素的数组排个序。        对500W数据排序，如果基于比较的先进排序，平均比较次数为O(5000000*log5000000)≈1.112亿。但是我们发现，这些数据都有特殊的条件：  100=<score<=900。那么我们就可以考虑桶排序这样一个“投机取巧”的办法、让其在毫秒级别就完成500万排序。       创建801(900-100)个桶。将每个考生的分数丢进f(score)=score-100的桶中。这个过程从头到尾遍历一遍数据只需要500W次。然后根据桶号大小依次将桶中数值输出，即可以得到一个有序的序列。而且可以很容易的得到100分有***人，501分有***人。      实际上，桶排序对数据的条件有特殊要求，如果上面的分数不是从100-900，而是从0-2亿，那么分配2亿个桶显然是不可能的。所以桶排序有其局限性，适合元素值集合并不大的情况。### 例题2、在一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可（内存限制为 2G的意思就是，可以使用2G的空间来运行程序，而不考虑这台机器上的其他软件的占用内存）。    分析： 既然要找中位数，很简单就是排序的想法。那么基于字节的桶排序是一个可行的方法。    思想：将整型的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的字典序。按以下步骤实施：    1、把10G整数每2G读入一次内存，然后一次遍历这536,870,912即（1024*1024*1024）*2 /4个数据。每个数据用位运算">>"取出最高8位(31-24)。这8bits(0-255)最多表示255个桶，那么可以根据8bit的值来确定丢入第几个桶。最后把每个桶写入一个磁盘文件中，同时在内存中统计每个桶内数据的数量，自然这个数量只需要255个整形空间即可。    2、继续以内存中的整数的次高8bit进行桶排序(23-16)。过程和第一步相同，也是255个桶。    3、一直下去，直到最低字节(7-0bit)的桶排序结束。我相信这个时候完全可以在内存中使用一次快排就可以了。### 例题3、给定n个实数x1,x2,...,xn,求这n个实数在实轴上相邻2个数之间的最大差值M,要求设计线性的时间算法       典型的最大间隙问题。       要求线性时间算法。需要使用桶排序。桶排序的平均时间复发度是O(N).如果桶排序的数据分布不均匀，假设都分配到同一个桶中，最坏情况下的时间复杂度将变为O(N^2).      桶排序: 最关键的建桶，如果桶设计得不好的话桶排序是几乎没有作用的。通常情况下，上下界有两种取法，第一种是取一个10^n或者是2^n的数，方便实现。另一种是取数列的最大值和最小值然后均分作桶。      对于这个题，最关键的一步是：由抽屉原理知：最大差值M>= (Max(V[n])-Min(V[n]))/(n-1)！所以，假如以(Max(V[n])-Min(V[n]))/(n-1)为桶宽的话，答案一定不是属于同一个桶的两元素之差。因此，这样建桶，每次只保留桶里面的最大值和最小值即可。# 十一、计数排序## 1）算法简介    计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。## 2）算法描述和分析算法的步骤如下：        1、找出待排序的数组中最大和最小的元素         2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项         3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）         4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。        由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。## 3）算法图解、flash演示、视频演示### 图解：        我们使用计数排序对一个乱序的整数数组进行排序。        首先创建一个临时数组（长度为输入数据的最大间隔），对于每一个输入数组的整数k，我们在临时数组的第k位置"1"。如下图![](https://img-blog.csdn.net/20130929160149390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)        上图中，第一行表示输入数据，第二行表示创建的临时数据，临时数组的下标代表输入数据的某一个值，临时数组的值表示输入数据中某一个值的数量。         如果输入数据中有重复的数值，那么我们增加临时数组相应的值（比如上图中5有3个，所以小标为5的数组的值是3）。在“初始化”临时数组以后，我们就得到了一个排序好的输入数据。![](https://img-blog.csdn.net/20130929160249078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)        我们顺序遍历这个数组，将下标解释成数据， 将该位置的值表示该数据的重复数量，记得得到一个排序好的数组。## 5）考察点、重点和频度分析计数排序在处理密集整数排序的问题的时候非常有限，尤其是有时候题目对空间并不做太大限制，那使用计数排序能够达到O(n)的时间复杂度，远快于所有基于比较的其他排序方法。## 6）笔试面试题### 例题1、某地区年龄排序问题    够典型的计数排序吧，年龄的区间也就那么大，代码就不上了，请参照上述参照计数排序算法。# 十二、基数排序## 1）算法简介        基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。## 2）算法描述和分析        整个算法过程描述如下： 1、将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。2、从最低位开始，依次进行一次排序。3、这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。      基数排序的时间复杂度是 O(k?n)，其中n是排序元素个数，k是数字位数。      注意这不是说这个时间复杂度一定优于O(n·log(n))，因为k的大小一般会受到n的影响。 以排序n个不同整数来举例，假定这些整数以B为底，这样每位数都有B个不同的数字，k就一定不小于logB(n)。由于有B个不同的数字，所以就需要B个不同的桶，在每一轮比较的时候都需要平均n·log2(B) 次比较来把整数放到合适的桶中去，所以就有：      k 大于或等于 logB(n)      每一轮(平均)需要 n·log2(B) 次比较所以，基数排序的平均时间T就是：      T ≥ logB(n)·n·log2(B) = log2(n)·logB(2)·n·log2(B) = log2(n)·n·logB(2)·log2(B) = n·log2(n)      所以和比较排序相似，基数排序需要的比较次数：T ≥ n·log2(n)。 故其时间复杂度为 Ω(n·log2(n)) = Ω(n·log n) 。## 3）算法图解、flash演示、视频演示### 图解：![](https://img-blog.csdn.net/20130929160608437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)## 5）考察点、重点和频度分析        计数排序在处理密集整数排序的问题的时候非常有限，尤其是有时候题目对空间并不做太大限制，那使用计数排序能够达到O(n)的时间复杂度，远快于所有基于比较的其他排序方法。# 总结总结一下各种排序算法如下：|名称|时间复杂度|额外空间|稳定性|考点||----|----|----|----|----||插入排序|平均O(n^2)最优O(n)最差O(n^2)|O(1)|稳定|选择填空各种时间复杂度移动元素个数||二分插入排序|平均O(n^2)|O(1)|稳定|同上||希尔排序|最差O(nlogn)最优 O(n)|O(n)|不稳定|时间复杂度比较次数||选择排序|O(n^2)|O(1)|不稳定|同插入排序||冒泡排序|O(n^2)最优O(n)最差O(n^2)|O(1)|稳定|时间复杂度比较次数单轮冒泡||鸡尾酒排序|O(n^2)|O(1)|稳定|同上||快速排序|O(n log n)|O(1)|不稳定|时间复杂度快排partition算法||堆排序|O(n log n)|O(n)|不稳定|时间复杂度堆调整，建堆，堆排序，Top K问题||归并排序|平均O(nlogn)最差O(nlogn)最优O(n)|O(n)|稳定|时间复杂度递归思想|即![](https://img-blog.csdn.net/20131020210419843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW95YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)






