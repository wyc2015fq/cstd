# 二级指针使用 - maopig的专栏 - CSDN博客
2011年08月28日 22:24:57[maopig](https://me.csdn.net/maopig)阅读数：1313
指针就是指向内存的地址，那么对应的二级指针就是指向指针的指针，简单点就是取指针的地址，二级指针的值是一个地址，具体可看下面的这个例子：
 char   c   =   'a';   //一个字符型变量   
  char   *p;       //p是一个指向char类型的指针   
  p=&c;             //现在p里存的是c的地址   
  char   **q;     //q是一个二级指针   
  q=&p;             //q里存的是p的地址(p如前所述是个整数,所以p占有内存的一块空   
                        //间,现在q就是指向这个空间的开始)   
  printf("%p",q);       //p的地址   
  printf("%p",*q);     //c的地址   
  printf("%c",**q);   //a   
  int   A[100];   //A是一个int   *型的指针,指向一块内存的开始(当然课本上把这种   
                          //指向预先分配的空间的指针叫做数组)   
  int   B[100][100];     //B就是一个int   **型的指针   
  void   F(int   **p);   
  你可以这样调用F   
  F(B);
1。用二级指针动态申请二维数组。 
void   main() 
{ 
        int   m   ,   n   ,   **p; 
        scanf( "%d%d "   ,   &m   ,   &n); 
        p   =   (int   **)malloc(m   *   sizeof(int   *)) 
        //C＋＋中建议使用：p   =   new   int*   [m]; 
        for(i   =   0   ;   i   <   m   ;   i++) 
                p[i]   =   (int   *)malloc(n   *   sizeof(int));   
                //C＋＋：p[i]   =   new   int[n]; 
} 
这样就实现了二维数组的动态申请，因为一般数组声明时，不允许下标是变量，所以如果想动态决定数组各维的大小，最好这样做。 
2。使用二级指针传递参数，可以在函数内部修改一级指针。 
或许，你已经很熟悉通过传递一级指针，可以在函数内部修改实参指针指向的内容：如： 
void   f(char   *p) 
{ 
        p[2]   =   'a ';//由实参指向的函数外部的数组的内容就被改变了。 
        …… 
} 
但是，如果我们想改变实参本身呢？也就是说，我们连指针值都要改变，如果使用： 
void   f(char   *p) 
{ 
        p   =   (char   *)malloc(10   *   sizeof(char)) 
        //或C＋＋中：p   =   new   char[10]; 
        …… 
} 
就不行了，因为在函数内部不能通过改变形参的值来改变实参（注意这里实形参是指针p，上面的那个函数并没有改变形参，只是改变了形参指向的内容，只是由于形参和实参的值相同，也就是指向同一块内存，所以也就是改变了实参指向的内容，这个时候就要用二级指针了）。 
void   f(char   **p) 
{ 
        *p   =   new   char[10]; 
        *p[2]   =   'a '; 
        …… 
} 
可以这样说，传入一个N级指针，就可以修改N-1级指针，原因就是C的参数传递是值传递的，直接修改形参根本改变不了实参，但可以改变行参指针指向的内容，而N级指针指向的内容就是一个N-1级指针（你可以把非指针变量理解为0级指针），另外，你可能感觉这样使用似乎有问题，因为原先的内存空间没有释放，是的，这只是个为了说明问题的简化了的例子，实际的应用场合要比这合适的多。 
最后，指针是C/C＋＋语言的精华，但理解指针还是应该从指针本身去理解，二级指针只是指针的一种，不应该在这里钻牛角尖，多级指针其实还是指针，只不过它指向的内容内容仍是指针而已。
