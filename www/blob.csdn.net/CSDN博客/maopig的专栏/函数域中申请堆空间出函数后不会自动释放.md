# 函数域中申请堆空间出函数后不会自动释放 - maopig的专栏 - CSDN博客
2011年08月24日 18:43:43[maopig](https://me.csdn.net/maopig)阅读数：1539
#include<iostream>
using std::cout;
using std::endl;
char *scat(char *s1,char *s2)
{
 char *s=new char[strlen(s1)+strlen(s2)+1];
 strcpy(s,s1);
 strcat(s,s2);
 return s;//返回刚申请的堆空间的首址，出了函数后变量s就不复存在了，但申请的空间仍在
 //这很危险，容易造成内存泄露，因为有的人认为在函数中为局部变量申请的堆空间，出了函数后
 //会自动释放，这是不正确的
}
void main()
{
 char str1[]="hello";
 char str2[]="Jim";
 char *str3=scat(str1,str2);
 cout<<str3<<endl;
 str3[0]='x';
 cout<<str3<<endl;
 delete [] str3;//释放堆空间
}
结果：helloJim
            xelloJim
地址返回可以为int类型
#include<iostream>
using std::cout;
using std::endl;
int scat(char *s1,char *s2)
{
 char *s=NULL;
 s=new char[strlen(s1)+strlen(s2)+1];
 strcpy(s,s1);
 strcat(s,s2);
return (int )s;//返回刚申请的堆空间的首址，出了函数后变量s就不复存在了，但申请的空间仍在
 //这很危险，容易造成内存泄露，因为有的人认为在函数中为局部变量申请的堆空间，出了函数后
 //会自动释放，这是不正确的
}
void main()
{
 char str1[]="hello";
 char str2[]="Jim";
 char *str3=(char *)scat(str1,str2);
 cout<<str3<<endl;
 str3[0]='x';
 cout<<str3<<endl;
 delete [] str3;//释放堆空间
}
结果：helloJim
            xelloJim
3、
#include<iostream>
using std::cout;
using std::endl;
int scat(char **s1,char 
**s2)
{
 char *s=NULL;
  s=new char[strlen(*s1)+strlen(*s2)+1];
 strcpy(s,*s1);
 strcat(s,*s2);
 return (int )s;
}
void main()
{
 char *str1="hello";
 char *str2="Jim";
 char *a="x";
 char *str3=(char *)scat(&str1,&str2);
 cout<<str3<<endl;
 str3[0]='x';
 cout<<str3<<endl;
 delete [] str3;//释放堆空间
}

