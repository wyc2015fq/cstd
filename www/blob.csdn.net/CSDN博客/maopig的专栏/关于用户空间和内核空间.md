# 关于用户空间和内核空间 - maopig的专栏 - CSDN博客
2012年03月06日 23:40:59[maopig](https://me.csdn.net/maopig)阅读数：1031标签：[磁盘																[linux																[文档																[任务](https://so.csdn.net/so/search/s.do?q=任务&t=blog)](https://so.csdn.net/so/search/s.do?q=文档&t=blog)](https://so.csdn.net/so/search/s.do?q=linux&t=blog)](https://so.csdn.net/so/search/s.do?q=磁盘&t=blog)
个人分类：[c/C++																[u-boot/驱动开发](https://blog.csdn.net/maopig/article/category/1090389)](https://blog.csdn.net/maopig/article/category/847675)
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（内核态）。在内核态下，CPU可执行任何指令。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。用户态不能访问内核空间，包括代码和数据。
进程处于用户态时能访问的是用户空间，处于内核态时能访问的称为内核空间。
CPU执行程序所访问的地址都是虚拟地址，MMU 必须通过读取控制寄存器CR3中的值作为当前页面目录的指针，进而根据分页内存映射机制（参看相关文档）将该虚拟地址转换为真正的物理地址才能让CPU真正的访问到物理地址。
进程有4G的寻址空间，其中第一部分为“用户空间”，用来映射其整个进程空间（0x0000 0000－0xBFFF FFFF）即3G字节的虚拟地址；第二部分为“系统空间”，用来映射（0xC000 0000－0xFFFF FFFF）1G字节的虚拟地址。可以看出Linux系统中每个进程的页面目录的第二部分是相同的，所以从进程的角度来看，每个进程有4G字节的虚拟空间，较低的3G字节是自己的用户空间，最高的1G字节则为与所有进程以及内核共享的系统空间。
![](http://www.embedu.org/Column/images/Column329-1.JPG)
if(数据在物理内存中)
        {        虚拟地址转换成物理地址
                 读数据 }
        else
        {     if(数据在磁盘中)
              {
                     if(物理内存还有空闲)
                     {          把数据从磁盘中读到物理内存
                                 虚拟地址转换成物理地址
                                 读数据
                     }
                     else
                     {          把物理内存中某页的数据存入磁盘
                                 把要读的数据从磁盘读到该页的物理内存中
                                 虚拟地址转换成物理地址
                                 读数据
                     }
              }
              else
              {     报错        } }
# 请问如何在驱动程序里边通过用户空间的虚拟地址得到它对应的物理地址呢？
一般的驱动程序里边都要实现read函数
read函数里边有一个参数char* buf是用户空间传递过来的指针，是用户空间的虚拟地址，请问我怎么通过这个虚拟地址得到它对应的物理地址呢？
（因为我想实现通过dma把内核空间的数据传送到用户空间去，所以一定要知道buf对应的物理地址）
请问有可能吗？
谢谢
我觉得有三种解决方案.第一种性能差些,但是简单,即先从内核到内核dma,然后再调用现成的copy_to_usr等函数.第二种就是搜索该用户进程的页表,(找到该进程的task结构,task->pgd...),从页表中搜索虚拟地址对应的物理地址.第三种就是在内核中开辟一块内存,用于存放dma后的数据,然后将它映射到用户空间去.这种方法我以前采用过,依稀的一些印象是.mknod一个设备文件,然后对该设备文件进行一些ioctl请求(ioctl的各个操作函数当然是自己写),必需实现的一个函数是该文件的***_mmap.(这样mmap系统调用->do_mmap()->do_mmap_pgoff()然后再找到你的***_mmap()),在这个map函数中,一个关键可用的内核函数是remap_page_range().该函数则可用来生成一个用户空间的vma段,然后将其和给定的物理内存(设备文件片断)联系起来,将返回的虚拟地址传回用户空间(ioctl)后,就可以在用户空间对那块内存操作了
