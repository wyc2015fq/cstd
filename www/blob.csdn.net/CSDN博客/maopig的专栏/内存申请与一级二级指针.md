# 内存申请与一级二级指针 - maopig的专栏 - CSDN博客
2011年08月28日 17:18:09[maopig](https://me.csdn.net/maopig)阅读数：3033标签：[buffer																[null																[float																[date																[编程																[file](https://so.csdn.net/so/search/s.do?q=file&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=date&t=blog)](https://so.csdn.net/so/search/s.do?q=float&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=buffer&t=blog)
个人分类：[c/C++](https://blog.csdn.net/maopig/article/category/847675)
1.如果是函数内进行内存申请，很简单，标准用法就可以了：
test()
{
 int *array;
 array=(int *)malloc(sizeof(int)*10);//申请10*4 bytes，即10个单位的int内存单元
}
注意，malloc使用简单，但是注意参数和返回值，参数是申请内存的字节数，多字节的类型如int，short,float等需要乘上类型字节数，返回值是没有定义类型的指针，使用时需要自己指定。
2.使用一级指针实现内存申请，通过函数返回值带出malloc的地址：
char *my_malloc(int m)
{
 char *p;
 p=malloc(m);
 return p;
}
test()
{
 char * buff=NULL;  //指针如果在函数内没有赋值，注意开始赋值为NULL
 buff=my_malloc(10); 
 printf("buff adress is %x\n",buff); 
 free(buff);  
} 
3.使用二级指针实现内存申请，通过指针值传递： 
void my_malloc1(char **p1)
{
*p1=(char *)malloc(100);
}
test()
{
 char *buffer=NULL;
 my_malloc1(&buffer); 
 printf("buffer adress is %x\n",buffer); 
 free(buffer);
} 
小结：一级指针和二级指针在做形参时的不同：指针用作形参，改变指针地址则值不能传回，改变指针内容而地址不变则值可以传回。（特殊情况：改变指针地址采用返回值也可以传回地址）
对于一级指针，做形参时传入地址，如果函数只改变该指针内容，OK，该指针可以正常返回; 
如果函数改变了指针地址，除非返回该指针，否则该指针不能正常返回，函数内对指针的操作将无效。
对于二级指针，做形参时传入地址（注意此时传入的是二级指针的地址），如果改变该二级指针地址（**p），对该指针的操作也将无效，但是改变二级指针的内容（例如*p），则该二级指针可以正常返回。
总之，指针使用最关键的是弄清地址和内容，指针做形参时只有改变其内容时才能正常返回。 
4.编程实例： 
/*
date:20100823
file name:my_pointer.c
description:指针作为形参的值传递分析
result：
1.指针作为形参时，如果只需要改变指针指向的值，可以使用一级指针，如果需要改变指针本身的地址 
，则需要使用二级指针,相当于改变的是一级指针指向的值。
2.指针作为形参时，指针指向的内容变化是可以带回的，指针地址的变化是不可带回的，即指针作为参 
数，其地址不可改变，否则形参就无法传回实参的值。
*/ 
/*********************************************************************************/
//指针作为形参，指针指向的内容改变，函数返回时这种变化是可以带回的
void change(int *p)
{
 *p+=5; 
} 
test1()  
{
 int a=1;
 change(&a);
 printf("After change a is %d\n",a);  //结果为6
} 
/*********************************************************************************/
//指针作为形参，指针本身的地址改变，函数返回时这种变化将无效
void my_malloc(char *pp,int num)   
{
 pp=(char *)malloc(num); 
} 
test2()       
{
 char *buf=NULL;
 my_malloc(buf,100);
 printf("After my_malloc buf adress is %x\n",buf); //函数返回后,buf的地址依然为NULL 
 strcpy(buf,"hello");         //这里会出错，运行出现段错误，程序直接退出了，下面的输 
出也没有了
 puts(buf);
} 
main()
{
 test1();
 //test2();
} 
