# 宏定义和内联函数的学习 - maopig的专栏 - CSDN博客
2011年09月13日 09:43:56[maopig](https://me.csdn.net/maopig)阅读数：896标签：[编译器																[delete																[null																[存储																[c](https://so.csdn.net/so/search/s.do?q=c&t=blog)](https://so.csdn.net/so/search/s.do?q=存储&t=blog)](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=delete&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)
个人分类：[c/C++](https://blog.csdn.net/maopig/article/category/847675)
宏定义可以提高效率，但是宏不是函数。预编译通过代码复制的方式代替函数调用，省去了诸如函数压栈等系统过程，从而提高了效率。但是由于宏定义仅仅是代码替换，所以引起很多问题。
#define  MAX(a，b)  (a) > (b) ? ( a) : (b)
result=MAX(A,B) +2  编译器对其解释为 (a) > (b) ? (a) : (b)+2 .导致该语句执行与预期不符。
宏定义的另一个缺点就是无法访问类的私有成员。
而内联函数通过把代码直接复制进调用函数体内，避免产生某些系统过程，同样提高了效率，但是内联函数可以进行类型检查，this指针同样能应用，这是宏定义无法比拟的。
内联函数必须是函数的声明和定义一体，且在函数前面加inline。
**内存的三种分配方式**：静态存储区分配，栈上分配，堆上分配。
**内存使用常见错误**： 
（1）内存分配不成功，却使用它。对策：使用前检查内存是否为NULL。
（2）内存分配成功，但没有初始化就使用它。对策：内存分配后初始化。
（3）内存分配成功且已经初始化，但是越界。对策：做越界检查。
（4）忘记释放内存，造成内存泄漏。对策：内存动态分配和释放必须成双配对。
（5）释放了内存却继续使用它。
> 
（a）对象关系过于复杂，理不清楚究竟释放了没有。
（b）return指向栈内存的指针或引用。
（c）free或delete内存后，没有把指针置为NULL。导致野指针。
**指针与数组**。数组名对应着（而不是指向）一块内存，在生存期内，其地址不可改变，只能是数组内容改变。
**sizeof（）：**
sizeof(数组)= 数组元素个数*sizeof（数组的元素数据类型）。
sizeof（指针）= 4；
数组作为参数传递时，数组名自动退化为指针类型，即sizeof（数组）=4；
sizeof（结构体或者类）：这个有点麻烦，和编译器的设置有关系，pragma pack（n）是编译器指定的内存字节对齐方式，sizeof（结构或者类）和pragma pack（n）关系密切，默认的n=8，结构中的成员占用的内存起始地址为成员的数据类型的大小和n相比较的较小值。
**指针参数**：
不要让指针参数在函数体内部申请内存，如果非要指针在函数体内部申请内存，就要用指针的指针。函数的返回值不能使用栈内分配的变量地址。
**野指针：**用malloc和new 分配了内存，就得用free和delete 释放，否则造成内存泄漏，但是只释放内存还是不够安全的，必须在释放内存后，让指针指向NULL，才不至于造成野指针。我理解的野指针就是没有正确指向的指针。

