# 一段H264数据的分析 - maopig的专栏 - CSDN博客
2015年01月27日 22:12:33[maopig](https://me.csdn.net/maopig)阅读数：4870
﻿﻿
目录[(?)](http://blog.csdn.net/Siobhan/article/details/5962646#)[[-]](http://blog.csdn.net/Siobhan/article/details/5962646#)
- [分析00 00 00 01 67 42 00 1E 99 A0 B1 31 00 00 00 01](http://blog.csdn.net/Siobhan/article/details/5962646#t0)
- [分析00 00 00 01 68 CE 38 80 00 00 00 01](http://blog.csdn.net/Siobhan/article/details/5962646#t1)
# **分析**00 00 00 01 67 42 00 1E 99 A0 B1 31 00 00 00 01
H264的数据流分为两种，一种是NAL UNIT stream(RTP),一种是 bits stream,
两者可以互相转换。我们分析的这个是 bit stream,根据Annex B
00 00 00 01 67 42 00 1E 99 A0 B1 31 是 一个NAL，在两个00 00 00 01之间
0110 0111 0100 0010 0000 0000 0001 1110 1001 1001 1010 0000 1011 0001 0011 0001
**forbidden_zero_bit（1） ＝ 0nal_ref_idc（2）＝ 11nal_unit_type（5） ＝ 0 0111：**seq_parameter_set_rbsp( )
所以 processSPS
0110 0111 0100 0010 0000 0000 0001 1110 1001 1001 1010 0000 1011 0001 0011 0001
**profile_idc(8):42：0100 0010**
0110 0111 0100 0010 0000 0000 0001 1110 1001 1001 1010 0000 1011 0001 0011 0001
**constraint_set0_flag(1):0constraint_set1_flag(1):0constraint_set2_flag(1):0constraint_set3_flag(1):0reserved_zero_4bits(4):0**
0110 0111 0100 0010 0000 0000 0001 1110 1001 1001 1010 0000 1011 0001 0011 0001
**level_idc(8):1Eseq_parameter_set_id(UE(V)):**
ue(v): unsigned integer Exp-Golomb-coded syntax element with the left bit first. The parsing process for this descriptor is specified in subclause 9.1
uvlC: 1001：根据Table9.1 ， value= 0,只占1bit.
根据**profile_idc忽略掉一部分。log2_max_frame_num_minus4(ue(v): 001 10,len = 5,value= 5pic_order_cnt_type(ue(v)):01 1,len = 3,value = 2根据pic_order_cnt_type忽略几个参数num_ref_frames（ue）：010,len = 3,value = 1**
0110 0111 0100 0010 0000 0000 0001 1110 1001 1001 1010 0000 1011 0001 0011 0001
**gaps_in_frame_num_value_allowed_flag(1) = 0pic_width_in_mbs_minus1(ue):000 1011 ,len = 7,value = 10;pic_height_in_map_units_minus1(ue):0001 001,len = 7,value = 8frame_mbs_only_flag(1) = 1忽略1direct_8x8_inference_flag（1）:0忽略vui_parameters_present_flag(1):0忽略NALU结束**
# **分析**00 00 00 01 68 CE 38 80 00 00 00 01
**0110 1000**(68)
**forbidden_zero_bit（1） ＝ 0nal_ref_idc（2）＝ 11nal_unit_type（5） ＝01000：**pic_parameter_set_rbsp( ),7.3.2.2
1100 (C)
**pic_parameter_set_id (ue)=0seq_parameter_set_id(ue)=0entropy_coding_mode_flag(1) :0, 重要的flag,0 表示编码Exp-Golomb coded and CAVLC,1表示CABACpic_order_present_flag(1):0**
1110 (E)
**num_slice_groups_minus1(ue):0**
忽略
**num_ref_idx_l0_active_minus1（ue）:0num_ref_idx_l1_active_minus1(ue):0weighted_pred_flag(1);00011 1000 1000 0000**(38 80)
**weighted_bipred_idc(2):00pic_init_qp_minus26 /*** relative to 26 */(se):0
**pic_init_qs_minus26** /* relative to 26 */(se):0
**chroma_qp_index_offset(se):0deblocking_filter_control_present_flag(1);0constrained_intra_pred_flag(1):0redundant_pic_cnt_present_flag(1):0忽略NALU结束**
**65 88 80 21 71 27 1B 88…….3888*16 byte65：0110 0101forbidden_zero_bit（1） ＝ 0nal_ref_idc（2）＝ 11nal_unit_type（5） ＝0 0101：**slice_layer_without_partitioning_rbsp( ),IDR浈
Slice
Slice_Header:
**first_mb_in_slice(ue):0slice_type(ue):000 1000 = 7pic_parameter_set_id(ue) = 080 21：000 0000 0010 0001frame_num(u(v): frame_num** is used as an identifier for pictures and shall be represented by log2_max_frame_num_minus4 + 4 bits,9 bits = 0
忽略
if( nal_unit_type = = 5 ) //IDR frame
**idr_pic_id(u(e)):0忽略N多**
ref_pic_list_reordering( ) 见7。3。3。1忽略，Islice,SI slice,B slice
nal_ref_idc   =11 所以dec_ref_pic_marking( )
nal_unit_type = 5，所以
**no_output_of_prior_pics_flag（1）：0long_term_reference_flag（1）：0忽略**
。。71 27
001 0111 0001 0010 0111
**slice_qp_delta（se（v）：001 01 ，4：-2忽略**
**slice_data( ):7.3.4对I-Slice:忽略N多进入**if( moreDataFlag ) { if( MbaffFrameFlag && ( CurrMbAddr % 2 = = 0 | |                  ( CurrMbAddr % 2 = = 1 && prevMbSkipped ) ) )**mb_field_decoding_flagmacroblock_layer( )**}
mb_field_decoding_flag忽略
macroblock_layer( )
**mb_type（ue（v）：0**
mb_pred( mb_type )
**prev_intra4x4_pred_mode_flag[** luma4x4BlkIdx **] （1bit, 对babac是ae(v)）:11 27:0001 0010 0111prev_intra4x4_pred_mode_flag[** 1 **] : 0001,0,001**
0010 0111
**prev_intra4x4_pred_mode_flag[** 2 **] : 0010,0,010prev_intra4x4_pred_mode_flag[** 3**] : 0111,0,111……16个1b 88 00 3e cf. intra_chroma_pred_mode（ue(v)） : 最后的一个1bit:0**
**接下来是**macroblock_layer的**coded_block_pattern和run level,既系数c0 06 ad a0 181100 0000 0000 0110 1010 0000 0001 1000coded_block_pattern（me(v):0,根据**，= 47，0x2f
**mb_qp_delta(se(v):0 len =1**
residual( )见7.3.5.3
residual_block( LumaLevel[ i8x8 * 4 + i4x4 ], 16 )
**coeff_token(ce(v): 00 0000 0000 0110 1nc = 0(left block and top block 相关的)：**
len: {   // 0702
{ 1, 6, 8, 9,10,11,13,13,13,14,14,15,15,16,16,16,16},
{ 0, 2, 6, 8, 9,10,11,13,13,14,14,15,15,15,16,16,16},
{ 0, 0, 3, 7, 8, 9,10,11,13,13,14,14,15,15,16,16,16},
{ 0, 0, 0, 5, 6, 7, 8, 9,10,11,13,14,14,15,15,16,16},
},
{
{ 2, 6, 6, 7, 8, 8, 9,11,11,12,12,12,13,13,13,14,14},
{ 0, 2, 5, 6, 6, 7, 8, 9,11,11,12,12,13,13,14,14,14},
{ 0, 0, 3, 6, 6, 7, 8, 9,11,11,12,12,13,13,13,14,14},
{ 0, 0, 0, 4, 4, 5, 6, 6, 7, 9,11,11,12,13,13,13,14},
},
{
{ 4, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9,10,10,10,10},
{ 0, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 9,10,10,10},
{ 0, 0, 4, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,10},
{ 0, 0, 0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 8, 9,10,10,10},
},
code:
{ 1, 5, 7, 7, 7, 7,15,11, 8,15,11,15,11,15,11, 7,4},
{ 0, 1, 4, 6, 6, 6, 6,14,10,14,10,14,10, 1,14,10,6},
{ 0, 0, 1, 5, 5, 5, 5, 5,13, 9,13, 9,**13**, 9,13, 9,5},
{ 0, 0, 0, 3, 3, 4, 4, 4, 4, 4,12,12, 8,12, 8,12,8},
},
{
{ 3,11, 7, 7, 7, 4, 7,15,11,15,11, 8,15,11, 7, 9,7},
{ 0, 2, 7,10, 6, 6, 6, 6,14,10,14,10,14,10,11, 8,6},
{ 0, 0, 3, 9, 5, 5, 5, 5,13, 9,13, 9,13, 9, 6,10,5},
{ 0, 0, 0, 5, 4, 6, 8, 4, 4, 4,12, 8,12,12, 8, 1,4},
},
{
{15,15,11, 8,15,11, 9, 8,15,11,15,11, 8,13, 9, 5,1},
{ 0,14,15,12,10, 8,14,10,14,14,10,14,10, 7,12, 8,4},
{ 0, 0,13,14,11, 9,13, 9,13,10,13, 9,13, 9,11, 7,3},
{ 0, 0, 0,12,11,10, 9, 8,13,12,12,12, 8,12,10, 6,2},
},
根据表查的：
code = 13,len = 15，i= 12，j=2
**所以**numcoeff = 12,numtrailingones = 2
**010 0000 0001 1000: totalzeros:根据**numcoeff
int lentab[TOTRUN_NUM][16] =
{
{ 1,3,3,4,4,5,5,6,6,7,7,8,8,9,9,9},
{ 3,3,3,3,3,4,4,4,4,5,5,6,6,6,6},
{ 4,3,3,3,4,4,3,3,4,5,5,6,5,6},
{ 5,3,4,4,3,3,3,4,3,4,5,5,5},
{ 4,4,4,3,3,3,3,3,4,5,4,5},
{ 6,5,3,3,3,3,3,3,4,3,6},
{ 6,5,3,3,3,2,3,4,3,6},
{ 6,4,5,3,2,2,3,3,6},
{ 6,6,4,2,2,3,2,5},
{ 5,5,3,2,2,2,4},
{ 4,4,3,3,1,3},
**{ 4,4,2,1,3}, **numcoeff**开始**
{ 3,3,1,2},
{ 2,2,1},
{ 1,1},
};
int codtab[TOTRUN_NUM][16] =
{
{1,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1},
{7,6,5,4,3,5,4,3,2,3,2,3,2,1,0},
{5,7,6,5,4,3,4,3,2,3,2,1,1,0},
{3,7,5,4,6,5,4,3,3,2,2,1,0},
{5,4,3,7,6,5,4,3,2,1,1,0},
{1,1,7,6,5,4,3,2,1,1,0},
{1,1,5,4,3,3,2,1,1,0},
{1,1,1,3,3,2,2,1,0},
{1,0,1,3,2,1,1,1,},
{1,0,1,3,2,1,1,},
{0,1,1,2,1,3},
**{0,1,1,1,1},** numcoeff**开始**
{0,1,1,1},
{0,1,1},
{0,1},
};
