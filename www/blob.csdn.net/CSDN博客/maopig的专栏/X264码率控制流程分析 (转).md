# X264码率控制流程分析 (转) - maopig的专栏 - CSDN博客
2011年09月08日 11:12:31[maopig](https://me.csdn.net/maopig)阅读数：4932
　　二、编码器机能20钟头前　　码率节制的意见常识： 　　码率节制的目的以及意义： 　　图象通讯中码率节制的目的：路程经过过程调治编码参量，节制单元时间内的编码视频文件流的数值量，以使 ...
　　二、编码器机能20钟头前
　　码率节制的意见常识： 
　　码率节制的目的以及意义： 
　　图象通讯中码率节制的目的：路程经过过程调治编码参量，节制单元时间内的编码视频文件流的数值量，以使孕育发生的比特流切合各类应用的需求视频文件压缩的效率以及视频文件内部实质意义有很大的瓜葛，对变化多样的银幕，视频文件编码的输出的码流变化较大，在信道环境欠好的时辰就容易引被押送码端预示的质量的不不变
　　率掉真意见： 
　　因为传道输送带宽厚温以及储存空间的限定，视频文件应用对压缩比有较高的要求而无损编码较低的压缩比没有办法餍足视频文件在现实应用中的需求但若给视频文件引入一定水平的掉真，凡是可以获患上较高的压缩比
　　率掉真意见对有损压缩减编制码下的掉真以及编码机能之间的瓜葛的描写，为码率节制的研究供给了坚实的意见依据率掉真意见大旨是描写编码掉真度以及编码数值速度的瓜葛该意见成立在图象是持续的根蒂根基上的，在有限数值速度下，因为存在量化偏差，肯定是存在掉真当施用有损编码要领时，重修图象g(x,y)以及原始图象f(x,y)之间存在差异，掉真度D的函数情势在乎见上是可以按照需要自由拔取的，在图象编码中，D经常使用均方差情势暗示的，典型的率掉真曲线R(D)为D的凸减函数
　　对怎么选择哪1个函数的率掉真效验更好，则是比力哪1个函数的率掉真函数更为靠近典型的率掉真函数的曲线 
　　x264码率节制要领：接纳的码率节制算法并无接纳拉格朗日价钱函数来节制编码，而是施用一种更简略的要领，即哄骗半精疏密程度帧的SATD(sum of absolute transformed difference)作为标准样式选择的依据SATD行将残差经哈德曼变换的4×4块的预先推测残差绝对值全体，可以将其看作简略的时频变换，其值在一定水平上可以反应天生码流的巨细SATD是将残差经哈达曼变换4*4块的预先推测残差绝对值全体自顺应宏块层码率节制计谋：X264的宏块没有不论什么码率节制的机制，其在帧层获患上1个QP后，归属该帧的所有宏块都用着同一的QP举行量化
　　码率节制机能揣测： 
　　一、比特率偏差|ABR-TBR|/TBR ，越小越好 
　　三、缓以及冲突区满度与TBL的般配水平 
　　四、跳帧数 
　　五、PSNR颠簸越小越好 
　　x264中码率节制的流程(对重点函数鄙人面有注释)： 
　　1.在举行编码时，Encode--->x264_encoder_open(主如果举行参量的改订配置，举行初始化)---->x264_ratecontrol_new
　　2.encode--->Encode_frame--->x264_encoder_encode--->x2 64_ratecontrol_slice_type
　　3.encode--->Encode_frame--->x264_encoder_encode--->x2 64_ratecontrol_start**************
　　4.encode--->Encode_frame--->x264_encoder_encode--->x2 64_ratecontrol_qp 
　　5.encode--->Encode_frame--->x264_encoder_encode--->x2 64_slices_write--->x264_slice_write
　　--->x264_ratecontrol_mb******************** 
　　6.encode--->Encode_frame--->x264_encoder_encode--->x2 64_ratecontrol_end(在编完一帧事后)
　　7.在编完事后，encode--->x264_encoder_关了---->ratecontrol summary/x264_ratecontrol_delete
　　函数注释： 
　　在编码中所用的编码体式格局： 
　　#define X264_RC_CQP 0 
　　#define X264_RC_CRF 1 
　　#define X264_RC_ABR 2 
　　1. 
　　x264_ratecontrol_new( x264_t *h ) 
　　{ // 获取RC体式格局，FPS，bitrate,rc->buffer_rate,rc->buffer_size 
　　// 在码率节制的时辰会浮现2pass，参量的初始化 
　　rc = h->rc; 
　　rc->b_abr = h->param.rc.i_rc_method != X264_RC_CQP && !h->param.rc.b_stat_read;
　　rc->b_2pass = h->param.rc.i_rc_method == X264_RC_ABR && h->param.rc.b_stat_read;
　　.......... 
　　if( h->param.rc.b_mb_tree )//这搭配置mb_tree 
　　{ 
　　h->param.rc.f_pb_factor = 1; 
　　rc->qcompress = 1; 
　　} 
　　else 
　　rc->qcompress = h->param.rc.f_qcompress; 
　　.............. 
　　rc->ip_offset = 6.0 * log(h->param.rc.f_ip_factor) / log(2.0); 
　　rc->pb_offset = 6.0 * log(h->param.rc.f_pb_factor) / log(2.0); 
　　rc->qp_constant[SLICE_TYPE_P] = h->param.rc.i_qp_constant; 
　　rc->qp_constant[SLICE_TYPE_I] = x264_clip3( h->param.rc.i_qp_constant - rc->ip_offset + 0.5, 0, 51 );
　　rc->qp_constant[SLICE_TYPE_B] = x264_clip3( h->param.rc.i_qp_constant + rc->pb_offset + 0.5, 0, 51 );
　　} 
　　2. 
　　int x264_ratecontrol_slice_type( x264_t *h, int frame_num ) 
　　{ 
　　//按照差别类型来获取差别的qp_constant 
　　h->param.rc.i_qp_constant = (h->stat.i_frame_count[SLICE_TYPE_P] == 0) ? 24 
　　: 1 + h->stat.f_frame_qp[SLICE_TYPE_P] / h->stat.i_frame_count[SLICE_TYPE_P]; 
　　rc->qp_constant[SLICE_TYPE_P] = x264_clip3( h->param.rc.i_qp_constant, 0, 51 );
　　rc->qp_constant[SLICE_TYPE_I] = x264_clip3( (int)( qscale2qp( qp2qscale( h->param.rc.i_qp_constant ) / fabs( h->param.rc.f_ip_factor )) + 0.5 ), 0, 51 );
　　rc->qp_constant[SLICE_TYPE_B] = x264_clip3( (int)( qscale2qp( qp2qscale( h->param.rc.i_qp_constant ) * fabs( h->param.rc.f_pb_factor )) + 0.5 ), 0, 51 );
　　} 
　　3. 
　　x264_ratecontrol_start( h, h->fenc->i_qpplus1, overhead*8 ); 
　　这个函数的目的就是在一帧的编码前就选择QP 
　　/* Init the rate control */ 
　　/* FIXME: Include slice header bit cost. */ 
　　x264_ratecontrol_start( h, h->fenc->i_qpplus1, overhead*8 ); 
　　对x264_ratecontrol_start函数的剖析如次： 
　　x264_zone_t *zone = get_zone( h, h->fenc->i_frame );//找到h->fenc->i_frame地点的zone
　　.................... 
　　//由各类差别的slice类型，vbv等等参量获取的q值 
　　if( i_force_qp ) 
　　{ 
　　q = i_force_qp - 1;// 
　　} 
　　else if( rc->b_abr ) 
　　{ 
　　q = qscale2qp( rate_estimate_qscale( h ) );//底下有注释 
　　} 
　　else if( rc->b_2pass ) 
　　{ 
　　rce->new_qscale = rate_estimate_qscale( h ); 
　　q = qscale2qp( rce->new_qscale ); 
　　} 
　　else /* CQP */ 
　　{ 
　　if( h->sh.i_type == SLICE_TYPE_B && h->fdec->b_kept_as_ref ) 
　　q = ( rc->qp_constant[ SLICE_TYPE_B ] + rc->qp_constant[ SLICE_TYPE_P ] ) / 2; 
　　else 
　　q = rc->qp_constant[ h->sh.i_type ]; 
　　if( zone ) 
　　{ 
　　if( zone->b_force_qp ) 
　　q += zone->i_qp - rc->qp_constant[SLICE_TYPE_P]; 
　　else 
　　q -= 6*log(zone->f_bitrate_factor)/log⑵; 
　　} 
　　////////////////////////////////////////////////// //////////////// 
　　/* Terminology: 
　　* qp = h.264''s quantizer 
　　* qscale = linearized quantizer = Lagrange multiplier 
　　*/ 
　　static inline double qp2qscale(double qp) 
　　{ 
　　return 0.85 * pow(2.0, ( qp - 12.0 ) / 6.0); 
　　} 
　　static inline double qscale2qp(double qscale) 
　　{ 
　　return 12.0 + 6.0 * log(qscale/0.85) / log(2.0); 
　　} 
　　////////////////////////////////////////////////// ////////////////////// 
　　rate_estimate_qscale( h ) 
　　// update qscale for 1 frame based on actual bits used so far(即按照所需BIT来计较qscale)
　　static float rate_estimate_qscale( x264_t *h ) 
　　{ 
　　//这搭是别离针对B，P帧别离举行,因为I帧是已设定 
　　if( pict_type == SLICE_TYPE_B ) 
　　{ 
　　//这搭B帧的q的巨细是由参考帧求的 
　　..................... 
　　..................... 
　　// 由predict_size获患上帧的size 
　　rcc->frame_size_planned = predict_size( rcc->pred_b_from_p, q, h->fref1[h->i_ref1-1]->i_satd );
　　x264_ratecontrol_set_estimated_size(h, rcc->frame_size_planned); 
　　////////////////////////// 
　　void x264_ratecontrol_set_estimated_size( x264_t *h, int bits ) 
　　{ 
　　x264_pthread_mutex_lock( &h->fenc->mutex ); 
　　h->rc->frame_size_estimated = bits;///*********** 
　　x264_pthread_mutex_unlock( &h->fenc->mutex ); 
　　} 
　　//////////////////////////// 
　　} 
　　////P帧的q值获取 
　　else 
　　{ 
　　//这搭的分有1pass以及2pass的选择 
　　................... 
　　选择predicted_bits，求出diff 
　　diff = predicted_bits - (int64_t)rce.expected_bits; 
　　q /= x264_clip3f((double)(abr_buffer - diff) / abr_buffer, .5, 2); 
　　} 
　　} 
　　4. 
　　int x264_ratecontrol_qp( x264_t *h ) 
　　{ 
　　return h->rc->qpm; 
　　} 
　　5. 
　　void x264_ratecontrol_mb( x264_t *h, int bits ) 
　　{ 
　　//这个函数主如果针对一行的bits 
　　if( h->sh.i_type == SLICE_TYPE_B ) 
　　{ 
　　//由参考的图象求对应的行的qp，有已编码的bits获患上此行的bits以及qp 
　　int avg_qp = X264_MIN(h->fref0[0]->i_row_qp[y+1], h->fref1[0]->i_row_qp[y+1]) 
　　+ rc->pb_offset * ((h->fenc->i_type == X264_TYPE_BREF) ? 0.5 : 1); 
　　rc->qpm = X264_MIN(X264_MAX( rc->qp, avg_qp), 51); //avg_qp could go hellogher than 51 due to pb_offset
　　i_estimated = row_bits_so_far(h, y); //FIXME: compute full estimated size 
　　if (i_estimated > h->rc->frame_size_planned) 
　　x264_ratecontrol_set_estimated_size(h, i_estimated); 
　　} 
　　//I, p，这搭还要参考缓以及冲突区的状况 
　　else 
　　{ 
　　//对I,P帧在思量VBV的环境下求的bits以及qp 
　　} 
　　} 
　　6. 
　　/* After encoding one frame, save stats and update ratecontrol state */ 
　　int x264_ratecontrol_end( x264_t *h, int bits ) 
　　{ 
　　///计数ipb类型的Mb的个数，并计较均等QP 
　　h->fdec->f_qp_avg_rc = rc->qpa_rc /= h->mb.i_mb_count; 
　　h->fdec->f_qp_avg_aq = rc->qpa_aq /= h->mb.i_mb_count; 
　　} 
　　7. 
　　void x264_ratecontrol_summary( x264_t *h ) 
　　{ 
　　x264_ratecontrol_t *rc = h->rc; 
　　//ABR 
　　if( rc->b_abr && h->param.rc.i_rc_method == X264_RC_ABR && rc->cbr_decay > .9999 )
　　{ 
　　double base_cplx = h->mb.i_mb_count * (h->param.i_bframe ? 120 : 80); 
　　double mbtree_offset = h->param.rc.b_mb_tree ? (1.0-h->param.rc.f_qcompress)*13.5 : 0;
　　x264_log( h, X264_LOG_INFO, "final ratefactor: %.2f\n", 
　　qscale2qp( pow( base_cplx, 1 - rc->qcompress ) 
　　* rc->cplxr_sum / rc->wanted_bits_window ) - mbtree_offset ); 
　　} 
　　} 
　　///////////////////////////// 
　　void x264_ratecontrol_delete( x264_t *h )///////开释RC斥地的空间 
　　路程经过过程以上的流程总结x264码率节制的历程基本是有以下三步： 
　　1.对码率节制的相干变量举行初始化，如，I,P,B的初始QP值，RC的体式格局，VBV的初始状况等等； 
　　2.获取编码帧的庞气量宽宏，x264用SATD暗示，对接纳的差别参量的码率节制的体式格局，由前边已编码的Bits,庞气量宽宏，方针比特的配置等一些前提来获取编码时下帧的qp值
　　3.在编码历程中，由获患上qp值获患上预先推测的bits; 
　　测试部门： 
　　1.简略参量配置： 
　　参量配置： 
　　--frames 10 --qp 26 -o test.264 F:\.......\akiyo_qcif.yuv 176x144 
　　其它的参量接纳默许配置（在默许配置时接纳的码率节制模子是X264_RC_CQP），所患上的测试成果： 
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:23.00 size: 4189 
　　x264 [info]: frame P:3 Avg QP:26.00 size: 62 
　　x264 [info]: frame B:6 Avg QP:28.00 size: 38 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 3.0% 41.4% 55.6% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 3.0% 1.3% 1.7% 0.0% 0 
　　.0% skip:93.9% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 4.4% 0.2% 0.3% direct: 
　　0.7% skip:94.4% L0:56.0% L1:40.5% BI: 3.4% 
　　x264 [info]: 8x8 transform intra:41.4% inter:25.9% 
　　x264 [info]: coded y,uvDC,uvAC intra: 83.6% 81.8% 68.7% inter: 1.1% 0.1% 0.0% 
　　x264 [info]: i16 v,h,dc,p: 100% 0% 0% 0% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 25% 30% 15% 4% 4% 4% 7% 5% 6% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 35% 18% 8% 5% 5% 10% 5% 8% 6% 
　　x264 [info]: ref P L0: 88.9% 0.0% 11.1% 
　　x264 [info]: kb/s:92.08 
　　encoded 10 frames, 24.33 fps, 92.08 kb/s 
　　2.转变码率节制的模子： 
　　--frames 10 --qp 26 --crf 2 -o test.264 F:\......\akiyo_qcif.yuv 176x144 
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:10.00 size: 10246 
　　x264 [info]: frame P:3 Avg QP:11.48 size: 847 
　　x264 [info]: frame B:6 Avg QP:12.10 size: 172 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 1.0% 44.4% 54.5% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 30.0% 3.0% 4.7% 0.0% 0 
　　.0% skip:62.3% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 6.9% 1.0% 1.2% direct: 
　　4.0% skip:86.9% L0:34.7% L1:55.6% BI: 9.7% 
　　x264 [info]: 8x8 transform intra:44.4% inter:34.8% 
　　x264 [info]: coded y,uvDC,uvAC intra: 100.0% 99.0% 94.9% inter: 11.6% 7.6% 4.9%
　　x264 [info]: i16 v,h,dc,p: 100% 0% 0% 0% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 30% 33% 16% 3% 2% 3% 4% 4% 5% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 28% 12% 11% 5% 7% 11% 6% 12% 8% 
　　x264 [info]: ref P L0: 95.8% 1.6% 2.7% 
　　x264 [info]: ref B L0: 96.3% 3.7% 
　　x264 [info]: kb/s:276.36 
　　encoded 10 frames, 14.27 fps, 276.36 kb/s 
　　针对1，2两个测试，所接纳的RC模子纷歧样，1：X264_RC_CQP，2：X264_RC_CRF，其它参量的配置同样，从IPB的均等QP，编码Bits可以看出以及对现实的应用来讲，CRF的效验不比CQP
　　3. 
　　--frames 10 --qp 26 --pass 1 -o test.264 F:\.....\bin\akiyo_qcif.yuv 176x144 
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile Main, level 1.1 
　　x264 [info]: frame I:1 Avg QP:23.00 size: 4068 
　　x264 [info]: frame P:3 Avg QP:26.00 size: 59 
　　x264 [info]: frame B:6 Avg QP:28.00 size: 31 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 15.2% 0.0% 84.8% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 7.1% 0.0% 0.0% 0.0% 0 
　　.0% skip:92.9% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 1.2% 0.0% 0.0% direct: 
　　1.5% skip:97.3% L0:100.0% L1: 0.0% BI: 0.0% 
　　x264 [info]: coded y,uvDC,uvAC intra: 87.4% 77.8% 68.7% inter: 1.1% 0.1% 0.0% 
　　x264 [info]: i16 v,h,dc,p: 47% 20% 27% 7% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 29% 27% 10% 5% 4% 8% 5% 6% 5% 
　　x264 [info]: kb/s:88.58 
　　encoded 10 frames, 52.63 fps, 88.58 kb/s 
　　4. 
　　--frames 10 --qp 26 --pass 2 -o test.264 F:\.....\bin\akiyo_qcif.yuv 176x144 
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:23.00 size: 4189 
　　x264 [info]: frame P:3 Avg QP:26.00 size: 62 
　　x264 [info]: frame B:6 Avg QP:28.00 size: 38 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 3.0% 41.4% 55.6% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 3.0% 1.3% 1.7% 0.0% 0 
　　.0% skip:93.9% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 4.4% 0.2% 0.3% direct: 
　　0.7% skip:94.4% L0:56.0% L1:40.5% BI: 3.4% 
　　x264 [info]: 8x8 transform intra:41.4% inter:25.9% 
　　x264 [info]: coded y,uvDC,uvAC intra: 83.6% 81.8% 68.7% inter: 1.1% 0.1% 0.0% 
　　x264 [info]: i16 v,h,dc,p: 100% 0% 0% 0% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 25% 30% 15% 4% 4% 4% 7% 5% 6% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 35% 18% 8% 5% 5% 10% 5% 8% 6% 
　　x264 [info]: ref P L0: 88.9% 0.0% 11.1% 
　　x264 [info]: kb/s:92.08 
　　encoded 10 frames, 27.70 fps, 92.08 kb/s 
　　5. 
　　--frames 10 --qp 26 --pass 3 -o test.264 F:\.....\bin\akiyo_qcif.yuv 176x144 
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:23.00 size: 4189 
　　x264 [info]: frame P:3 Avg QP:26.00 size: 62 
　　x264 [info]: frame B:6 Avg QP:28.00 size: 38 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 3.0% 41.4% 55.6% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 3.0% 1.3% 1.7% 0.0% 0 
　　.0% skip:93.9% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 4.4% 0.2% 0.3% direct: 
　　0.7% skip:94.4% L0:56.0% L1:40.5% BI: 3.4% 
　　x264 [info]: 8x8 transform intra:41.4% inter:25.9% 
　　x264 [info]: coded y,uvDC,uvAC intra: 83.6% 81.8% 68.7% inter: 1.1% 0.1% 0.0% 
　　x264 [info]: i16 v,h,dc,p: 100% 0% 0% 0% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 25% 30% 15% 4% 4% 4% 7% 5% 6% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 35% 18% 8% 5% 5% 10% 5% 8% 6% 
　　x264 [info]: ref P L0: 88.9% 0.0% 11.1% 
　　x264 [info]: kb/s:92.08 
　　encoded 10 frames, 25.64 fps, 92.08 kb/s 
　　对3，4，5是涉及Pass的测试比力： 
　　屡次压缩码率节制 
　　1：熬头次压缩，始于计数文件 
　　2：按成立的计数文件压缩并输出，不笼罩计数文件， 
　　3：按成立的计数文件压缩，优化计数文件 
　　在想获患上建好的效验的时辰接纳pass 2就能够了 
　　6. 
　　--frames 10 --qp 26 --bitrate 64 -o test.264 F:\.....\bin\akiyo_qcif.yuv 176x144
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:38.31 size: 1461 
　　x264 [info]: frame P:3 Avg QP:42.00 size: 18 
　　x264 [info]: frame B:6 Avg QP:45.00 size: 14 
　　x264 [info]: consecutive B-frames: 11.1% 0.0% 0.0% 88.9% 
　　x264 [info]: mb I I16..4: 15.2% 68.7% 16.2% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 2.0% 0.0% 0.3% 0.0% 0 
　　.0% skip:97.6% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 0.2% 0.0% 0.0% direct: 
　　0.0% skip:99.8% L0: 0.0% L1:100.0% BI: 0.0% 
　　x264 [info]: final ratefactor: 31.50 
　　x264 [info]: 8x8 transform intra:68.7% 
　　x264 [info]: coded y,uvDC,uvAC intra: 48.0% 61.6% 32.3% inter: 0.0% 0.0% 0.0% 
　　x264 [info]: i16 v,h,dc,p: 33% 47% 7% 13% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 35% 17% 20% 3% 4% 7% 3% 7% 5% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 50% 14% 8% 5% 5% 5% 3% 6% 4% 
　　x264 [info]: kb/s:31.94 
　　encoded 10 frames, 31.25 fps, 31.94 kb/s 
　　7. 
　　--frames 250 --qp 26 --bitrate 64 -o test.264 F:\.....\bin\akiyo_qcif.yuv 176x144
　　x264 [info]: 176x144 @ 25.00 fps 
　　x264 [info]: using cpu capabilities: MMX2 SSE2 Cache64 Slow_mod4_stack 
　　x264 [info]: profile High, level 1.1 
　　x264 [info]: frame I:1 Avg QP:34.62 size: 1779 
　　x264 [info]: frame P:92 Avg QP:19.81 size: 569 
　　x264 [info]: frame B:157 Avg QP:26.76 size: 53 
　　x264 [info]: consecutive B-frames: 15.7% 0.0% 2.4% 81.9% 
　　x264 [info]: mb I I16..4: 14.1% 61.6% 24.2% 
　　x264 [info]: mb P I16..4: 0.0% 0.0% 0.0% P16..4: 25.8% 9.4% 9.9% 0.0% 0 
　　.0% skip:54.8% 
　　x264 [info]: mb B I16..4: 0.0% 0.0% 0.0% B16..8: 13.9% 0.7% 1.4% direct: 
　　1.1% skip:83.0% L0:16.6% L1:72.1% BI:11.3% 
　　x264 [info]: final ratefactor: 18.97 
　　x264 [info]: 8x8 transform intra:61.5% inter:40.4% 
　　x264 [info]: coded y,uvDC,uvAC intra: 61.3% 65.4% 34.6% inter: 8.6% 6.8% 2.8% 
　　x264 [info]: i16 v,h,dc,p: 57% 43% 0% 0% 
　　x264 [info]: i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 32% 22% 18% 4% 2% 7% 3% 7% 4% 
　　x264 [info]: i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 45% 10% 10% 5% 6% 7% 6% 6% 5% 
　　x264 [info]: ref P L0: 87.6% 7.6% 4.8% 
　　x264 [info]: ref B L0: 95.0% 5.0% 
　　x264 [info]: kb/s:49.92 
　　encoded 250 frames, 16.74 fps, 49.92 kb/s 
　　6，7是针对差别的编码帧数来举行比力的，在编码帧数越多，带宽哄骗的效验就越好 
　　6，7是在配置了方针码率64kp/s时，接纳的是ABR的RC模子，在配置了方针码率可以兴许按照方针码率的巨细转变QP巨细，可以兴许节制码率 
