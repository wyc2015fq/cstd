# NAND 坏块管理 - maopig的专栏 - CSDN博客
2013年12月25日 10:55:08[maopig](https://me.csdn.net/maopig)阅读数：1239
**NAND的操作管理方式**
NAND FLASH的管理方式：以三星FLASH为例，一片Nand flash为一个设备(device)，1 (Device) = xxxx (Blocks)，1 (Block) = xxxx (Pages)，1(Page) =528 (Bytes) = 数据块大小(512Bytes) + OOB 块大小(16Bytes，除OOB第六字节外，通常至少把OOB的前3个字节存放Nand Flash硬件ECC码)。
      关于OOB区，是每个Page都有的。Page大小是512字节的NAND每页分配16字节的OOB；如果NAND物理上是2K的Page，则每个Page分配64字节的OOB。如下图：
![](http://hi.csdn.net/attachment/201103/25/0_1301039353CC60.gif)
以HYNIX为例，图中黑体的是实际探测到的NAND，是个2G bit（256M）的NAND。PgSize是2K字节，PgsPBlk表示每个BLOCK包含64页，那么每个BLOCK占用的字节数是 64X2K=128K字节；该NAND包好2048个BLOCK，那么可以算出NAND占用的字节数是2048X128K=256M，与实际相符。需要注意的是SprSize就是OOB大小，也恰好是2K页所用的64字节。
**1.为什么会出现坏块**　   由于NAND Flash的工艺不能保证NAND的Memory Array在其生命周期中保持性能的可靠，因此，在NAND的生产中及使用过程中会产生坏块。坏块的特性是：当编程/擦除这个块时，会造成Page Program和Block Erase操作时的错误，相应地反映到Status Register的相应位。
**2.坏块的分类**　  总体上，坏块可以分为两大类：（1）固有坏块：这是生产过程中产生的坏块，一般芯片原厂都会在出厂时都会将每个坏块第一个page的spare area的第6个byte标记为不等于0xff的 值。（2）使用坏块：这是在NAND Flash使用过程中，如果Block Erase或者Page Program错误，就可以简单地将这个块作为坏块来处理，这个时候需要把坏块标记起来。为了和固有坏块信息保持一致，将新发现的坏块的第一个page的
 spare area的第6个Byte标记为非0xff的值。
**3.坏块管理**　   根据上面的这些叙述，可以了解NAND Flash出厂时在spare area中已经反映出了坏块信息，因此，
如果在擦除一个块之前，一定要先check一下第一页的spare area的第6个byte是否是0xff，如果是就证明这是一个好块，可以擦除；如果是非0xff，那么就不能擦除，以免将坏块标记擦掉。当然，这样处理可能会犯一个错误―――“错杀伪坏块”，因为在芯片操作过程中可能由于 电压不稳定等偶然因素会造成NAND操作的错误。但是，为了数据的可靠性及软件设计的简单化，还是需要遵照这个标准。
      可以用BBT：bad block table，即坏块表来进行管理。各家对nand的坏块管理方法都有差异。比如专门用nand做存储的，会把bbt放到block0，因为第0块一定是好的块。但是如果nand本身被用来boot，那么第0块就要存放程序，不能放bbt了。有的把bbt放到最后一块，当然，这一块坚决不能为坏块。bbt的大小跟nand大小有关，nand越大，需要的bbt也就越大。
**需要注意的是：OOB是每个页都有的数据，里面存的有ECC（当然不仅仅）；而BBT是一个FLASH才有一个；针对每个BLOCK的坏块识别则是该块第一页spare area的第六个字节。4.坏块纠正**
     ECC：NAND Flash出错的时候一般不会造成整个Block或是Page不能读取或是全部出错，而是整个Page（例如512Bytes）中只有一个或几个bit出错。一般使用一种比较专用的校验——ECC。ECC能纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不保证能检测。
      ECC一般每256字节原始数据生成3字节ECC校验数据，这三字节共24比特分成两部分：6比特的列校验和16比特的行校验，多余的两个比特置1。（512生成两组ECC，共6字节） 
      当往NAND Flash的page中写入数据的时候，每256字节我们生成一个ECC校验和，称之为原ECC校验和，保存到PAGE的**OOB** （out- of-band）数据区中。其位置就是eccpos[]。校验的时候，根据上述ECC生成原理不难推断：将从OOB区中读出的原ECC校验和新ECC校验和按位异或，若结果为0，则表示不存在错（或是出现了ECC无法检测的错误）；若3个字节异或结果中存在11个比特位为1，表示存在一个比特错误，且可纠正；若3个字节异或结果中只存在1个比特位为1，表示OOB区出错；其他情况均表示出现了无法纠正的错误。
**5.补充**　 （1）需要对前面由于Page Program错误发现的坏块进行一下特别说明。如果在对一个块的某个page进行编程的时候发生了错误就要把这个块标记为坏块，首先就要把块里其他好的面的内容备份到另外一个空的好块里面，然后，把这个块标记为坏块。当然，这可能会犯“错杀”之误，一个补救的办法，就是在进行完块备份之后，再将这个坏块擦除一遍，如果Block Erase发生错误，那就证明这个块是个真正的坏块，那就毫不犹豫地将它打个“戳”吧！
　 （2）可能有人会问，为什么要使用每个块第一页的spare area的第六个byte作为坏块标记。这是NAND Flash生产商的默认约定，你可以看到Samsung,Toshiba,STMicroelectronics都是使用这个Byte作为坏块标记的。
     （3）为什么好块用0xff来标记？因为Nand Flash的擦除即是将相应块的位全部变为1，写操作时只能把芯片每一位(bit)只能从1变为0，而不能从0变为1。0XFF这个值就是标识擦除成功，是好块。
