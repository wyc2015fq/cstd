# VC下调用x264进行视频编码, - maopig的专栏 - CSDN博客
2011年08月31日 14:12:39[maopig](https://me.csdn.net/maopig)阅读数：2879
                
 4.X264.c中,h = x264_encoder_open( param ) )是用来复制参数并验证参数的有效性,在CCS下应该是不需要验证参数的(参数都是在程序中设置好的),因此此处只作复制参数param和初始化X264_T h的操作.(VC下程序修改记录080106下午)
修改COMMON.C中的void    x264_param_default( x264_param_t *param )(即设置param的默认参数)为:
void    x264_param_default( x264_param_t *param )
{
    /* */
    memset( param, 0, sizeof( x264_param_t ) );
    /* CPU autodetect */
//   param->cpu = x264_cpu_detect();
param->cpu = 0;
    param->i_threads = 1;
    /* Video properties */
    param->i_csp           = X264_CSP_I420;
    param->i_width         = 0;
    param->i_height        = 0;
    param->vui.i_sar_width = 0;
    param->vui.i_sar_height= 0;
//    param->vui.i_overscan = 0; /* undef */
//    param->vui.i_vidformat = 5; /* undef */
//    param->vui.b_fullrange = 0; /* off */
//    param->vui.i_colorprim = 2; /* undef */
//    param->vui.i_transfer = 2; /* undef */
//    param->vui.i_colmatrix = 2; /* undef */
//    param->vui.i_chroma_loc= 0; /* left center */
    param->i_fps_num       = 25;
    param->i_fps_den       = 1;
//   param->i_level_idc     = 51; /* as close to "unrestricted" as we can get */
param->i_level_idc     = 40; /* level 4.0 is sufficient for 720x576 with16 reference frames */
    /* Encoder parameters */
    param->i_frame_reference = 1;
    param->i_keyint_max = 250;
    param->i_keyint_min = 25;
    param->i_bframe = 0;   // 在IP帧之间可插入的B帧数量最大值，范围0~16，默认0
    param->i_scenecut_threshold = 40; ;// 画面动态变化限，当超出此值时插入I帧，默认40
//    param->b_bframe_adaptive = 1; ////好像是自适应的B帧个数
param->b_bframe_adaptive = 0;
    param->i_bframe_bias = 0;
    param->b_bframe_pyramid = 0;
//    param->b_deblocking_filter = 1; //去块效应相关
param->b_deblocking_filter = 0;
    param->i_deblocking_filter_alphac0 = 0;
    param->i_deblocking_filter_beta = 0;
//    param->b_cabac = 1;
param->b_cabac = 0;
//    param->i_cabac_init_idc = 0;
param->i_cabac_init_idc = -1;
    param->rc.i_rc_method = X264_RC_CQP; //使用恒定质量方式
    param->rc.i_bitrate = 0;
    param->rc.f_rate_tolerance = 1.0;
    param->rc.i_vbv_max_bitrate = 0;
    param->rc.i_vbv_buffer_size = 0;
    param->rc.f_vbv_buffer_init = 0.9;
    param->rc.i_qp_constant = 26;
    param->rc.i_rf_constant = 0;
    param->rc.i_qp_min = 10;
    param->rc.i_qp_max = 51;
    param->rc.i_qp_step = 4;
    param->rc.f_ip_factor = 1.4;
    param->rc.f_pb_factor = 1.3;
    param->rc.b_stat_write = 0;
    param->rc.psz_stat_out = "x264_2pass.log";
    param->rc.b_stat_read = 0;
    param->rc.psz_stat_in = "x264_2pass.log";
    param->rc.psz_rc_eq = "blurCplx^(1-qComp)";
    param->rc.f_qcompress = 0.6;
    param->rc.f_qblur = 0.5;
    param->rc.f_complexity_blur = 20;
    param->rc.i_zones = 0;
    /* Log */
    param->pf_log = x264_log_default;
    param->p_log_private = NULL;
    param->i_log_level = X264_LOG_INFO;
    /* */
//   param->analyse.intra = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8;
param->analyse.intra = X264_ANALYSE_I4x4;
//    param->analyse.inter = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8
//                         | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16;
param->analyse.inter = X264_ANALYSE_I4x4 
                           | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16;
    param->analyse.i_direct_mv_pred = X264_DIRECT_PRED_SPATIAL;
//   param->analyse.i_me_method = X264_ME_HEX;
param->analyse.i_me_method = X264_ME_DIA; //使用菱形搜索
    param->analyse.i_me_range = 16;
//    param->analyse.i_subpel_refine = 5;
param->analyse.i_subpel_refine = 3; ////亚像素搜索范围
    param->analyse.b_chroma_me = 1;
//   param->analyse.i_mv_range = -1; // set from level_idc
param->analyse.i_mv_range = 512;//运动向量搜索范围
    param->analyse.i_chroma_qp_offset = 0; //色度和亮度之间的量化差,范围-12~+12，默认0
    param->analyse.b_fast_pskip = 1;
    param->analyse.b_dct_decimate = 1;
//    param->analyse.b_psnr = 1;
param->analyse.b_psnr = 0; //是否使用信噪比
    param->i_cqm_preset = X264_CQM_FLAT;
    memset( param->cqm_4iy, 16, 16 );
    memset( param->cqm_4ic, 16, 16 );
    memset( param->cqm_4py, 16, 16 );
    memset( param->cqm_4pc, 16, 16 );
    memset( param->cqm_8iy, 16, 64 );
    memset( param->cqm_8py, 16, 64 );
    param->b_repeat_headers = 1;
    param->b_aud = 0;
}
修改后对foreman01.yuv编码速率由1.82fps提高到3.03fps
将main函数改为:
int main( int argc, char **argv )
{
    x264_param_t param;
    cli_opt_t opt;
/*                                                        
主要是屏蔽以下四句,因为在CCS下不需要
#ifdef _MSC_VER
    _setmode(_fileno(stdin), _O_BINARY);
    _setmode(_fileno(stdout), _O_BINARY);
#endif
*/
    x264_param_default( ¶m );
    /* Parse command line */
    if( Parse( argc, argv, ¶m, &opt ) < 0 )
        return -1;
    /* Control-C handler */                //用来判断是否按下CTRL+C键,若按下则退出命令行模式
//   signal( SIGINT, SigIntHandler );
    return Encode( ¶m, &opt );
}
程序可运行,fps无影响
将X264程序中的muxers.c,matroskv.c文件删除,其中的i
int open_file_yuv( char *psz_filename, hnd_t *p_handle, x264_param_t *p_param );
int get_frame_total_yuv( hnd_t handle );
int read_frame_yuv( x264_picture_t *p_pic, hnd_t handle, int i_frame );
int close_file_yuv( hnd_t handle );
int open_file_bsf( char *psz_filename, hnd_t *p_handle );
int set_param_bsf( hnd_t handle, x264_param_t *p_param );
int write_nalu_bsf( hnd_t handle, uint8_t *p_nal, int i_size );
int set_eop_bsf( hnd_t handle, x264_picture_t *p_picture );
int close_file_bsf( hnd_t handle );
extern int (*p_open_infile)( char *psz_filename, hnd_t *p_handle, x264_param_t *p_param );
extern int (*p_get_frame_total)( hnd_t handle );
extern int (*p_read_frame)( x264_picture_t *p_pic, hnd_t handle, int i_frame );
extern int (*p_close_infile)( hnd_t handle );
在X264.c中重写.
muxer和matroskv文件的一些函数主要是定义了对mp4,y4m,mkv文件格式的输入输出支持,修改后程序则只能执行YUV格式的输入输出了.运行正常,2.97fps
4.X264.c中,h = x264_encoder_open( param ) )是用来复制参数并验证参数的有效性,在CCS下应该是不需要验证参数的(参数都是在程序中设置好的),因此此处只作复制参数param和初始化X264_T h的操作.
但是也不能将static int x264_validate_parameters( x264_t *h )函数屏蔽了,因为里面还有其它赋值操作,在此函数中删除了判断图像的宽高,CSP420的语句,速度3.36fps
