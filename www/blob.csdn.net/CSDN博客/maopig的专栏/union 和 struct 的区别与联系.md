# union 和 struct 的区别与联系 - maopig的专栏 - CSDN博客
2014年07月01日 14:43:08[maopig](https://me.csdn.net/maopig)阅读数：1242

union （ 共用体）：构造数据类型,也叫联合体 
 用途：使几个不同类型的变量共占一段内存(相互覆盖)
 struct ( 结构体 )：是一种构造类型
 用途： 把不同的数据组合成一个整体——自定义数据类型
主要区别：
1. struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的,一个struct变量的总长度等于所有成员长度之和，遵从字节对其原则; 在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在 , Union变量的长度等于最长的成员的长度。
2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 而对于struct的不同成员赋值是互不影响的。
union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。例子如下：
union StateMachine
{
   char character;
   int number;
   char *str;
   double exp;
};
一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。
在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。
## 一、大小端模式对union 类型数据的影响
下面再看一个例子：
union
{
   int i;
   char a[2];
}*p, u;
p =&u;
p->a[0] = 0x39;
p->a[1] = 0x38;
p.i 的值应该为多少呢？
**这里需要考虑存储模式：大端模式和小端模式。**- 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。 
- 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。 
union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？
## 二、如何用程序确认当前系统的存储模式？
上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian 的，则返回1。
先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。
以大端模式存储，其内存布局如下图：
![](http://see.xidian.edu.cn/cpp/uploads/allimg/120205/1-1202051G1094W.jpg)
以小端模式存储，其内存布局如下图：
![](http://see.xidian.edu.cn/cpp/uploads/allimg/120205/1-1202051G146418.jpg)
变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。如果取出低地址上的值为0，毫无疑问，这是大端模式；如果取出低地址上的值为1，毫无疑问，这是小端模式。既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一致。
到现在，应该知道怎么写了吧？参考答案如下：
int checkSystem( )
{
   union check
   {
      int i;
      char ch;
   } c;
   c.i = 1;
   return (c.ch ==1);
}
现在你可以用这个函数来测试你当前系统的存储模式了。当然你也可以不用函数而直接去查看内存来确定当前系统的存储模式。如下图：
![](http://see.xidian.edu.cn/cpp/uploads/allimg/120205/1-1202051G223J7.jpg)
图中0x01 的值存在低地址上，说明当前系统为小端模式
