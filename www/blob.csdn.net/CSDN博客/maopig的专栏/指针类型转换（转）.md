# 指针类型转换（转） - maopig的专栏 - CSDN博客
2011年09月10日 14:26:06[maopig](https://me.csdn.net/maopig)阅读数：685
   当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指
针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大
多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的
类型和指针表达式所指向的类型是一样的。
例十五：
float f=12.3;
float *fptr=&f;
int *p;
在上面的例子中，假如我们想让指针p 指向实数f，应该怎么办？
是用下面的语句吗？
p=&f;
  不对。因为指针p 的类型是int *，它指向的类型是int。表达式
&f 的结果是一个指针，指针的类型是float *,它指向的类型是float。
两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对
指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其
它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进
行"强制类型转换"：
p=(int*)&f;
   如果有一个指针p，我们需要把它的类型和所指向的类型改为
TYEP *TYPE， 那么语法格式是： (TYPE *)p；
这样强制类型转换的结果是一个新指针，该新指针的类型是
TYPE *，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。
而原来的指针p 的一切属性都没有被修改。（切记）
一个函数如果使用了指针作为形参，那么在函数调用语句的实参和
形参的结合过程中，必须保证类型一致，否则需要强制转换
例十六：
void fun(char*);
int a=125,b;
fun((char*)&a);
void fun(char*s)
{
charc;
c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;
c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;
}
   注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个
字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意
到了吗？在函数调用语句中，实参&a 的结果是一个指针，它的类型是
int *，它指向的类型是int。形参这个指针的类型是char *，它指向
的类型是char。这样，在实参和形参的结合过程中，我们必须进行一
次从int *类型到char *类型的转换。结合这个例子，我们可以这样来
想象编译器进行转换的过程：编译器先构造一个临时指针char *temp，
然后执行temp=(char *)&a，最后再把temp 的值传递给s。所以最后的
结果是：s 的类型是char *,它指向的类型是char，它指向的地址就是
a 的首地址。
   我们已经知道，指针的值就是指针指向的地址，在32 位程序中，
指针的值其实是一个32 位整数。那可不可以把一个整数当作指针的值
直接赋给指针呢？就象下面的语句：
unsigned int a;
TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。
a=20345686;
ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686
ptr=a; //我们的目的是要使指针ptr 指向地址20345686
编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能
达到了吗？不，还有办法：
unsigned int a;
TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。
a=N //N 必须代表一个合法的地址；
ptr=(TYPE*)a； //呵呵，这就可以了。
严格说来这里的(TYPE *)和指针类型转换中的(TYPE *)还不一样。这里
的(TYPE*)的意思是把无符号整数a 的值当作一个地址来看待。上面强
调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，
就会出现非法操作错误。
想想能不能反过来，把指针指向的地址即指针的值当作一个整数取
出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出
来，然后再把这个整数当作一个地址赋给一个指针：
例十七：
int a=123,b;
int *ptr=&a;
char *str;
b=(int)ptr; //把指针ptr 的值当作一个整数取出来。
str=(char*)b; //把这个整数的值当作一个地址赋给指针str。
现在我们已经知道了，可以把指针的值当作一个整数取出来，也可
以把一个整数值当作地址赋给一个指针。
