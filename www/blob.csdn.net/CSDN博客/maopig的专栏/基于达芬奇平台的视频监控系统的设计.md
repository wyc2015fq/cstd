# 基于达芬奇平台的视频监控系统的设计 - maopig的专栏 - CSDN博客
2011年11月03日 13:40:38[maopig](https://me.csdn.net/maopig)阅读数：3475
Design and implement of the video surveillance system based on DaVinci platform
Abstract：This paper implements a video surveillance system based on the new dual core platform Da Vinci. Describe the detail of the develop method and flow.
Keyword:  DaVinci; Embedded system; xDAIS; dual-core;
摘要：本文中设计并实现了一个基于TI最新的DSP多媒体平台——Da Vinci平台的微波传输无线监控系统。介绍了新一代双核DSP平台的特性，阐述了基于双核系统的开发方法和流程。
关键词：达芬奇；嵌入式系统; xDAIS; 双核；
1 简介
   在日常生活中，很多高危险区、无人区需要人们随时监控。在布线困难的情况下，出现了很多无线监控系统。然而无线监控系统面临着很多设计挑战例如：稳定性，功耗，带宽不足带来的效果低下等等。本文中设计和实现了一种新型微波无线视频监控系统。它的优点主要在于：1 基于TI公司的最新DSP处理系统，有着低功耗，高性能，高稳定性的特点，保证了视频图像处理的高效性；2 采用最新的H.264高效视频压缩算法，使得利用有限带宽传输D1级别的清晰成为可能。3
 对RTP进行改进和扩展，设计和实现了一个适合用于两条微波信道的传输系统。
    本系统视频采集用DaVinci平台，连接有摄像头作为采集设备,本地显示设备用于调试，采集后的数据在DaVinci平台上经过视频压缩算法后，以自主改进后的RTP/RTCP协议进行发送，通过Alcatel A9800进行中转。在服务器PC端，主要实现视频的接受、回放、存储以及管理功能。[1]
2采集终端DaVinci系统的简介
达芬奇技术TI公司今年4月提出的一种基于DSP的系统解决方案组件的集合，专门为高效而强大的数字视频而量身定制，如：数码相机、视频安全监控系统、高级医疗影像、便携式视频播放器或其他视频应用。这种系统针对灵活的数字视频实施而进行了精心优化，拥有业界领先的性能并集成了可编程数字信号处理器(DSP)内核以及RISC指令集的通用ARM处理器(GPP:
 General Purpose Processor)。本文中使用的TMS320DM6446具有以下特性：
 集成了1个C64x+体系结构的DSP和1个ARM926EJ-S RISC MCU的双核处理器；
 带有32k L1 Program Cache ，80k L1D Data Cache，64k L2 Cache的低功耗DSP，速度可高达594-MHz；
 用于DSP和MCU子系统的先进电源管理和低功耗模式； 
 Video处理子系统，包括CCD/CMOS接口，BT.601/BT.656 Digital YCbCr 4:2:2接口
 外部存储器接口（EMIF）配有64MB ddr2内存；
 丰富的外围设备接口，例如：flash card, Ethernet, usb, uart, ata/atapi等等
3 xDIAS规范
DaVinci的双核结构使得我们能在ARM核上运行基于MontaVista 公司的专业版的Linux 2.6.10操作系统进行视频采集，显示以及网络协议处理等低复杂度的工作，高复杂度的视频压缩算法则交由DSP通过BIOS进行处理。然而对双核系统的嵌入式开发会存在很多的问题：
 调试一个双核系统中遇到的交叉编译和复杂的系统自举引导问题十分头痛；
 不同的算法实现有着不同的应用编程接口，会导致工作量很大；
 在更换DSP和GPP后可移植性成问题；
 有些算法既可以运行在DSP上也可以用在GPP上，为了平衡双核的负载，应用程序中有可能会测试算法在两个核上的运行情况，这时程序架构改变会很大。
TI公司因此设计了一个Codec Engine来解决上述问题。它规定了一个DSP算法结构框架——xDIAS (eXpressDSP Algorithm Interoperability Standard)，其中xDM为xDIAS for Digital Media,它定义了一组统一的应用编程接口(API)[2]，它们可以在本地（GPP上）或者远程（DSP上）运行，这些API函数可以用于多种媒体，包括视频、音频、语音、图像等。这样保证了的算法的通用和可移植性。只要按照标准利用TI的算法开发软件eXpressDSP进行开发就可以开发出一个CE(Codec
 Engine)。CE有以下的优点：
 容易使用，应用程序开发者只需要调用API就可以使用特定算法；
 容易扩展和配置，增加一个新的算法只需要利用eXpressDSP工具封装出符合标准的算法即可，而不需要改动应用程序；
 可移植性，APIs与应用程序是独立并且一致的，更换换算法只需要修改Codec Server配置，而不需要修改应用程序。
图1是一个典型的基于Codec Engine的应用程序。[3]
![](http://www.cediy.com/UpLoadFiles/Article/2008/12/20/2008122011530929503.jpg)
在双核调用的时候， Codec Server类似一个Web Server,就如Web Server是一台服务器上电后会有一个守护进程来响应Client的请求，Codec Server是DSP上电后通过boot loader装入的配置文件以及任务文件来响应GPP的请求。如图2所示，应用程序处理器（本文中为Arm926EJ-S）中的应用程序（或者中间程序）通过标准的VISA
 APIs(Video Image Speech and Audio类接口)或者自定义接口发出请求，而Stubs部分用来汇集GPP到DSP的各种参数，这包括所有CPU间的参数以及GPP的虚拟内存地址转换到DSP的物理内存地址，然后发送到DSP中的Skeleton部分由Skeleton送出给相应算法；同样反过来Skeleton会汇集DSP处理后的结果交由Stubs送到应用程序处理器处理。
3 开发和实现流程
3.1 配置Codec Server
   Codec Server配置存放于.cfg文件中，通过makefile生成.c文件之后link成链接文件.xdl
 var osalGlobal = xdc.useModule( 'ti.sdo.ce.osal.Global' );
osalGlobal.runtimeEnv = osalGlobal.DSPLINK_LINUX;
var VIDENC_H264 = xdc.useModule('codecs. VIDENC_H264');
var Engine = xdc.useModule('ti.sdo.ce.Engine');
var vcr = Engine.create("video_copy", [{name: "videnc_h264", mod: VIDENC_H264, local: false,groupId: 0},]);
vcr.server = "./video_h264.x64P";
Program.main = Program.system = null;
其中DSPLINK_LINUX表示使用这个engine的环境为linux
var VIDENC_H264 = xdc.useModule('codecs.VIDENC_H264')中表示取得目录。./codecs/中的编码器，并且给其一个名字VIDENC_H264,这里VIDENC_H264必须和该目录下的VIDENC_H264.xdc同名。[4]
var vcr = Engine.create("video_copy", [{name: "videnc_h264", mod: VIDENC_H264, local: false,groupId: 0}中name代表应用程序使用时本地名为videnc_h264,mod代表实际的名字为VIDENC_H264,local为false代表为远程（DSP上）运行，groupId用于把相同优先级的任务放在一个group中。
3.2 配置Codec Engine
首先任何要使用Codec Engine的程序都要调用CERuntime_init()来初始化，然后用Engine_open，Engine_close来打开或者关闭引擎。代码如下：
Static String engineName = “videnc”;
Engine_Handle cd;
Engine_Error errorcode;
if((ce = Engine_open(engineName,NULL,&errorcode))==NULL){
printf(“ERROR: can’t open engine %s: %d\n”,engineName,&errorcode);
    goto init_end;
}
Engine_close(ce);
其中错误的返回值为下列之一:
Engine_EEXIST,Engine_ENOMEM,Engine_EDSPLOAD,Engine_ENOCOMM,Engine_ENOSERVER, Engine_ECOMALLOC,Engine_EOK；分别表示不存在，不能分配内存，不能装入DSP,不能与DSP通讯，DSP上没有Server,不能分配通信缓冲和成功。
每一个会利用到Codec Engine的线程只能利用其自己实例化的句柄，这样就防止了在多线程环境中某个实例化engine被其他线程所访问。
3.3 配置VISA APIs
在配置好Codec Engine后就可以调用VISA的类函数，VISA APIs可以分为8大类：
VIDENC,VIDDEC,IMGENC,IMGDEC,SPHENC,SPHDEC,AUDENC,AUDDEC。
每一组又分为MOD_create, MOD_process,MOD_control,MOD_delete。分别用于建造，处理，控制和销毁VISA类。其中MOD为VISA APIs中大类的一种。
代码如下：
Engine_Handle ce;
VIDENC_Handle enc;
Static String encoderName = “h264enc”;
enc = VIDENC_create(ce,encoderName,IVIDENC_Params);
create中第一个参数ce为engine初始化的返回句柄，第二个为编码器名称，第三个为编码器参数。
下面的代码通过process函数从in缓存读取数据处理后输出到out缓存[5]
XDAS_Int8 *src = inBuf;
XDAS_Int8 *dst = outBuf;
/* prepare "per loop" buffer descriptor settings */
inBufenc.bufs = &src;
outBufenc.bufs = &dst;
encInArgs.size = sizeof(encInArgs);
encInArgs.numBytes = sizeof(inBuf);
/* encode the frame */
status = VIDENC_process(enc, &inBufenc, &outBufenc,&encInArgs, &encOutArgs);
if (status != VIDENC_EOK) {printf("frame %d: encode status = %ld\n", n, status);}
其中VIDENC_process的第一个参数为create函数返回的句柄，之后两个为输入输出缓存的指针，其结构如下：
typedef struct XDM_Bufenc {
XDAS_Int8 **bufs;
XDAS_Int32 numBufs;
XDAS_Int32 *bufSizes;
} XDM_Bufenc;
最后两个参数为指向输入输出参数的指针。
4结论
 本文作者创新点：阐述了新一代达芬奇双核嵌入式平台开发多媒体应用程序的流程和方法，并将该方法实际的应用到我们为深圳市供电局研发的微波视频传输系统中，该系统利用已有的微波线路，在视频压缩算法和高速DSP芯片的支持下，很好地实现了远程视频监控。我们开发了算法通信等API接口，因为达芬奇台的实用性、规范性和开放性，这些API具有较强的重用性、可靠性、适应性，大大节省开发成本，缩短了开发周期，增强了系统的可维护性和灵活性。
5 参考文献
1 韩相军，关永.嵌入式视频采集系统的设计与实现嵌入式视频采集系统的设计与实现［J］．微计算机信息 2006,1-2:26-28、148.
2 xDAIS-DM (Digital Media) User Guide (SPRUEC8)
3 Codec Engine Application (API) Reference Guide
4 TMS320 DSP Algorithm Standard Developer’s Guide
5 TMS320 DSP Algorithm Standard API Reference (SPRU360)
