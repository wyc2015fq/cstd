# 嵌入式系统中看门狗概述。。。 - maopig的专栏 - CSDN博客
2012年01月03日 20:14:04[maopig](https://me.csdn.net/maopig)阅读数：12199
      一直以来对于嵌入式中的watch dog（看门狗）都比较陌生，一直都不知道它到底是做什么的，单从名字上看也不知其所以然，然后就在网上找到了一篇blog，就是再说看门狗的作用和概述，原文如下：
 1、概述： 
      WATCHDOG对于没有底层开发经验的开发人员来说，可能比较陌生，但是它在系统起到非常重要的作用，相当于系统警察，当系统发生严重错误（如程序进入死循环等）不能 恢复的时候，WATCHDOG能够让系统重启。WATCHDOG的应用主要是在嵌入式操作系统中，避免了系统在无人干预时长时间挂起的情况。
 2、WATCHDOG模块 
      在比较高档的嵌入式硬件芯片中，都有一个WATCHDOG模块，如果在MCU/MPU中没有集成WATCHDOG，一般会在此嵌入式系统中加一个专门的WATCHDOG芯片来实现WATCHDOG机制。此模块主要的功能包括：
      1、提供WATCHDOG控制寄存器和配置寄存器，供软件开发人员根据系统需要进行灵活配置。
      2、提供一接口，使应用软件能够定时给WATCHDOG“喂狗”。
      3、提供WATCHDOG机制，当系统进入不可恢复错误时，能产生一个不可屏蔽中断来通知系统自动重启（一般这样，也有改变为其他处理方式的），只有相应的复位信号才能清除它。
 3、WATCHDOG的实现方式： 
      对于WATCHDOG模块的实现，不同的硬件芯片有不同的方式，这里介绍2中工作方式：
      1、利用系统操作系统时钟来实现WATCHDOG
      在Intel XScale系列中，利用了操作系统时钟的比较寄存器3（OSMR3）做为WATCHDOG的运行主体，当系统的WATCHDOG激活后，软件就必须在一定时间内从OSMR3读出当前的计数，然后加上一定的计数值（下一次到期的计数值），再写回到OSMR3中，软件一直周期性的重复这个过程，如果软件没有重新写入新的计数使定时器到期，此OSMR3会利用一个GPIO触发系统复位。
      2、芯片的专门WATCHDOG模块
      对于现在的很多芯片，已经集成了专门的WATCHDOG模块，比如ARM11的芯片，WATCHDOG模块中，提供了比较灵活的配置和控制机制：
      A、宽范围设置过期时间间隔,从0。5秒到128秒可以用户配置
      B、可以灵活配置在低功耗下，使用或者停止WATCHDOG功能
      C、可以灵活配置在DEBUG等状态下，使用或者停止WATCHDOG功能
      根据不同的系统，设置好相应的寄存器，激活WATCHDOG后，需要应用程序周期性的服务WATCHDOG，即我们所说的“喂狗”，对于 WATCHDOG模块，需要定时向Watchdog Service Register按顺序写入0x5555,0xaaaa.一般 在WATCHDOG模块中还会提供Watchdog Reset Status Register，从中可以找到复位的具体原因。
      3、单片机的WATCHDOG实现
      许多单片机片内自带看门狗电路，单片机复位时将片内自带看门狗电路禁止，只有当程序访问该电路时，电路启动。如51系列单片机对SFR中的0A6H 地址顺序写入＃01EH、#0E1H；而96系列单片机则对SFR中的0A6H地址顺序写入＃1EH、#0E1H；工控主机板上看门狗电路本身并不要求复位后重新启动，但BIOS在复位后将板上看门狗禁止，启动和喂狗方法与单片机相同。如研祥的FSC-1713主板，在WatchDog编程状态，只要执行如下两条指令：
      outportb(0x2e,0xf6)；   
      outportb(0x2f,TIME-OUT-VALUE)；
可实现WatchDog的启停，其中TIME-OUT-VALUE ≠0启动；TIME-OUT-VALUE =0停止[2] 。能够用指令禁止看门狗是为了适应用户程序开发阶段的需要，这同时给看门狗启动和运行失败留下了后门，在看门狗启动时或启动前遇干扰而使程序跑飞，则看门狗启动失败，无法行使监控职能。
      4、结论
      WATCHDOG在嵌入式系统中发挥着非常重要的作用，其实现方式也千差万别，根据不同的硬件设计，可以选用不同的WATCHDOG，但它们的作用是一样的：保证系统在出现不可恢复错误时，能够自动让系统重启。
参考资料：
1.Intel XScale Pocessor Developer's Manual     
2.Arm11 芯片用户手册
3.WatchDog失效机理与对策研究 
      以上就是原文，对我理解看门狗有一定的帮助，也希望能够帮助大家。
linux嵌入式系统开发之看门狗---应用篇 
“小涛哥，你的这个什么板子是不是坏了啊，为啥老是重启，好奇怪啊….”小王好奇的指着我心爱的板子说。
“笨死啦，没看到吗， 我昨天化了一上午写的一个看门狗程序…”我生气而又无奈的说。
“等等，啥？看门狗？我听过哈巴狗，牡羊狗，落水狗，流浪狗，还就是没听说过你的说的那个啥子 看门狗 ”小王嘴一噘锁，“哼，你是看我不懂，忽悠我的吧”..
“切，不懂就是不懂，这还就是你没听过的 看门狗 ”我故意提高了音调说。
  算啦，也不卖官腔了，开始今天的课程----linux嵌入式系统开发之看门狗----应用篇。
  话说这个看门狗，还真是形象。什么个意思呢？就是一直“狗”它会盯着系统的定时器，如果定时器的时间值到了，你还没有喂它东西的话，它肯定就不爽了，就把你的系统重启，惩罚一下你，为啥这么久了不喂它东西吃。所以嘛，为了保持系统正常运行，就要在定时器到之前不断的喂它东西吃，贿赂一下它。
   回到这个程序，为了不是看门狗叫（重启咱们的电脑），就不断地要从终端输入字符来喂狗（清空定时器，让计时值总是从0开始计数），这样的话，就可以保持狗不会饥饿，也就不会重启我们的电脑了。不多说了，咱们结合代码来详细介绍。
必要的头文件#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <sys/time.h>
#include <unistd.h>
#include <time.h>
#include <getopt.h>
#include <sys/signal.h>
#include <termios.h>
struct watchdog_info{
    unsigned int options;   //options the card/driver supprots 19         
    unsigned int firmware_version;  //firmcard version of the card
    unsigned char identity[32];     //identity of the board 21
 };
#define WATCHDOG_IOCTL_BASE 'W'
#define WDIOC_GETSUPPORT _IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
#define WDIOC_SETTIMEOUT _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
#define WDIOC_GETTIMEOUT _IOR(WATCHDOG_IOCTL_BASE, 7, int) 27 
#define WDIOS_DISABLECARD 0x0001        /* Turn off the watchdog timer */
#define WDIOS_ENABLECARD 0x0002 /* Turn on the watchdog timer */
#define WDIOC_SETOPTIONS _IOR(WATCHDOG_IOCTL_BASE, 4, int)
#define WDIOC_KEEPALIVE _IOR(WATCHDOG_IOCTL_BASE, 5, int)
int Getch (void)   //无回显的从屏幕输入字符，来达到喂狗的目的
{
     int ch;
     struct termios oldt, newt;   //终端设备结构体
     tcgetattr(STDIN_FILENO, &oldt);   //获得终端属性
     newt = oldt;
     newt.c_lflag &= ~(ECHO|ICANON);   //设置无回显属性
     tcsetattr(STDIN_FILENO, TCSANOW, &newt);  //设置新的终端属性
     ch = getchar();   //从键盘输入一个数据
     tcsetattr(STDIN_FILENO, TCSANOW, &oldt);  //恢复终端设备初始设置
     return ch;
}
 //suspend some seconds
int zsleep(int millisecond)
{
     unsigned long usec;
     usec=1000*millisecond;
     usleep(usec); //睡眠usec秒
}
int Init()
{ 
     int fd;
     //open device file
     fd = open("/dev/watchdog",O_RDWR);   //打开看门狗设备
      if(fd < 0)
     {
         printf("device open fail\n");
         return -1;
     }
     return fd;
}
int main(int argc,char **argv)
{
     int fd,ch;
     int i,j;
     char c;
     struct watchdog_info wi;
     fd=Init();  //打开终端看门狗设备
     //读板卡信息，但不常用
      ioctl(fd,WDIOC_GETSUPPORT,&wi);
     printf("%d,%s\n",wi.options,wi.identity);
     //读看门狗溢出时间，默认是5s
     //重新设置时间为10s
     i=5;
     printf("%d\n",ioctl(fd,WDIOC_SETTIMEOUT,&i));
     //读新的设置时间
      printf("%d\n",ioctl(fd,WDIOC_GETTIMEOUT,&i));
     printf("%d\n",i); 
     //看门狗开始和停止工作，打开和关闭设备具有同样的功能
     //关闭
      i=WDIOS_DISABLECARD;
     printf("%d\n",ioctl(fd,WDIOC_SETOPTIONS,&i));
     //打开
      i=WDIOS_ENABLECARD;
     printf("%d\n",ioctl(fd,WDIOC_SETOPTIONS,&i));
     while(1)
     {
           zsleep(100);
           if((c=Getch())!=27){
                //输入如果不是ESC，就喂狗，否则不喂狗，到时间后系统重启
                ioctl(fd,WDIOC_KEEPALIVE,NULL);
                //write(fd,NULL,1);     //同样是喂狗
           }
     }
    close(fd);   //关闭设备
     return 0;
}
“小王，看清楚了吗？这就是看门狗的应用程序，可不是你说的什么流浪狗，哈巴狗”我拍拍小王的头说。
“看到了，只是感觉没啥用啊，除了你向我炫耀的左右外..”小王调皮地说道。
“啊！啊! 切，我是怕你不懂，所以就没怎么讲它的用途和原理，以及实际的应用..”我吓唬她到，“难的在下一节有关看门狗驱动的编写上，知道不..”
“嗯..嗯，知道，你啊，一点幽默都不懂..不想跟你说了..”小王生气的说…
“好了，不跟你耍嘴皮子啦，我还是给你说说这个程序咋用吧..”我不耐烦的说。
  你，这样，先gcc编译一下，生成可执行的文件，然后下到板子上运行，这个时候你要小心啦，要不断的按键盘(除了ESC),否则系统就会重启啦，就像你开始的那样。哈哈哈…
2010-08-24 09:52
## 嵌入式 看门狗
看门狗其实就是这么回事：
比如说你正在绕着一座小山裸奔。——程序按预定流程执行。
每次经过山脚下的某个地方，你都给一条大狼狗一根肉骨头。——喂狗。
奔着奔着，你奔叉了道，跑到了不该去的山顶。——程序跑飞了。
或者，你在裸奔的途中睡着了。——程序死机。
这时，那条大狼狗，由于一直得不到喂食，饿疯了，挣脱锁链来追你。——看门狗定时器溢出。
你被它一吓，脚底一软，从山上咕噜咕噜滚下来。起来一看，靠，又回到了出发地点。于是只好又从头开
