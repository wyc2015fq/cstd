# 《高效程序员的45个习惯》-之三 - maopig的专栏 - CSDN博客
2011年09月03日 11:47:26[maopig](https://me.csdn.net/maopig)阅读数：506标签：[单元测试																[工作																[测试																[编程																[设计模式																[任务](https://so.csdn.net/so/search/s.do?q=任务&t=blog)](https://so.csdn.net/so/search/s.do?q=设计模式&t=blog)](https://so.csdn.net/so/search/s.do?q=编程&t=blog)](https://so.csdn.net/so/search/s.do?q=测试&t=blog)](https://so.csdn.net/so/search/s.do?q=工作&t=blog)](https://so.csdn.net/so/search/s.do?q=单元测试&t=blog)
个人分类：[项目管理](https://blog.csdn.net/maopig/article/category/877158)
请您在阅读本文之前，先了解《高效程序员的45个习惯》-之二。
每一期都会涉及15个话题，用3期来列出这45个习惯，每次不贪多，贪精，大家如果有空，一定要细细品味这15个习惯。
注意：每一个好的习惯，开头都会相应有一个唱反调的句子哦。 
**16 使用演示获得频繁反馈**
“客户不停的更改需求，导致我们严重地延期。他们一次就应该想清楚所有想要的东西，然后把这些需求给我们。”
需求就像是流动着的油墨。你无法冻结需求，就像你无法冻结市场、竞争、知识、进化或者成长一样。就算你真的冻结了，也很可能是冻结了错的东西。
不一致的术语是导致需求误解的一个主要原因。所以，需要维护一份项目术语表。人们应该可以公开访问它，一般是在wiki或内部网里。
项目启动了一段时间以后，你就应该进入一种舒适的状态，团队和客户建立了一种健康的富有创造性的关系。
**17 使用短迭代，增量发布**
“我们为后面的3年制定了漂亮的项目计划，列出了所有的任务和可交付的时间表。只要我们那时候发布了产品，就可以占领市场”
给我一份详细的长期报告，我就会给你一个注定完蛋的项目。
对于大项目，最理想的办法就是小步前进，这也是敏捷方法的核心。大步跳跃大大地增加了风险，小步前进才可以帮助你很好地把握平衡。
**18 固定的价格就意味着背叛承诺**
“对这个项目，我们必须要有固定的报价。虽然我们还不清楚项目的具体情况，但仍要有一个报价。”
固定价格的合同会是敏捷团队的一大难题。我们一直在谈论如何用持续、迭代和增量的方式工作。但是现在却有些人跑过来，想提早知道它会花费多少时间及多少成本。
软件项目天生就是变化无常的，不可重复。如果要提前给出一个固定的价格，就几乎肯定不能遵守开发上的承诺。
如果你现在别无选择，你不得不提供一个固定价格，那么你需要学到真正好的评估技巧。
**19 守护天使**
“你不必为单元测试花费那么多时间和精力。它只会拖延项目的进度。好歹，你也是一个不错的程序员—单元测试只会浪费时间。”
单元测试能及时提供反馈
单元测试让你的代码更加健壮
单元测试时有用的设计工具
单元测试是你自信的后台
单元测试是可信的文档
单元测试是学习工具
**20 先用它再实现它**
“前进，先完成所有的库代码。后面会有大量时间看用户是如何思考的。现在只要把代码扔过墙就可以了，我保证它没有问题。”
很多成功的公司都是靠着“吃自己的狗食”活着。也就是说，如果要让你的产品尽可能地好，自己先要积极地使用它。
编程之前，先写测试。
先写测试，你就会站在代码用户的角度来思考，而不仅仅是一个单纯的实现者，这样做是有很大区别的，你会发现因为你自己要使用它们，所以能设计一个更有用、更一致的接口。
**21 不同环境，就有不同问题**
“只要代码能在你的机器上运行就可以了，谁会去关心它是否可以在其他平台上工作，你又不用其他平台。”
一位同事的代码失败了，最终找到了罪魁祸首：一个.NET环境下的API在Windows XP和Windows2003上的行为不同。平台不同，造成了结果的不一样。
使用持久集成工具，在每一种支持的平台和环境中运行单元测试，要积极地寻找问题，而不是等问题来找你。
**22 自动验收测试**
“很好，你现在用单元测试来验证代码是否完成了你期望的行为。发给客户吧。我们很快会知道这是否是用户期望的功能。”
关键业务逻辑必须要独立进行严格的测试，并且最后需要通过用户的审批。但是，你又不可能拉着用户，逐一模块确认。所以你需要能自动比较用户期望和实际完成的工作。
FIT（fit.c2.com），即集成测试框架，它很实用，可以更容易的使用HTML表格定义测试用例，并比较测试结果数据。
**23 度量真正的进度**
“用自己的时间表报告工作进度。我们会用它做项目计划。不用管那些实际的工作时间，每周填满40小时就可以了。”
时间表很难真实地反映工作完成状况，因此它不可以用来进行计划、评估或表现评估。
你曾经听到开发人员报告一个任务完成了80%么？然而过了一天又一天，一周又一周，那个任务仍然是完成80%。
随意用一个比率进行度量是没有意义的。所以不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发了35个小时之后，你认为还需要另外30个小时的工作。那就得到了很重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）
关注功能，而不是日程表。
**24 倾听用户的声音**
“用户就是会抱怨。这不是你的过错，是用户太愚蠢了，连使用手册都看不懂。它不是一个bug，只是用户不明白如何使用而已。他们本应该知道更多。”
不管它是否是产品的bug，还是文档的bug，或者是对用户社区理解的bug，它都是团队的问题，而不是用户的问题。
对于一些软件，倒霉的用户必须要配置那些包含了一些魔术数字的模糊系统文件，否则系统根本不会运行。系统既没有错误提示消息，也不会崩溃，只是显示大黑屏和一个斗大的“退出”按钮。
每一个抱怨的背后都隐藏着一个事实。找出真相，修复真正的问题。
没有愚蠢的用户；只有愚蠢自大的开发人员。
“它就是这样的。”这不是一个好答案。
你的用户有可能会阅读所有的文档，记住其中的所有内容。但也可能不会。
**25 代码要清晰地表达意图**
“可以工作而且易于理解的代码当然好，但是让人觉得聪明更加重要。别人给你钱是因为你脑子好使，让我们看看你到底有多聪明。”
Hoare说“设计软件有两种方式。一种是设计得尽量简单，并且明显没有缺陷。另一种方式是设计得尽量复杂，并且没有明显的缺陷。”
（Hoare创造了Algol 60编程语言，并发明了快速排序算法。于1980年获得图灵奖。）
代码阅读的次数要远远超过编写的次数，所以在编写的时候值得花点功夫让它读起来更加简单。
当开发人员们像一群旁观者见到UFO一样围在代码四周，感到恐惧、困惑与无助时，这个代码的质量就可想而知了。
看一个例子：
coffeeShop.PlaceOrder(2);//通过阅读代码，可以大致明白这是要在咖啡店中下一个订单。但是2代表什么意思？
coffeeShop.PlaceOrder(2 /* large cup */); //不妨添加一些注释。但注释有时候是为了帮写得不好的代码补漏。
public enum CoffeeCupSize
{
Small,
Medium,
Large
}
coffeeShop.PlaceOrder(CoffeeCupSize,Large);//如果使用上枚举值，代码就一目了然了。
应该让自己或团队的其他任何人，可以读懂自己一年前写的代码，而且只读一遍就知道它的运行机制。
**26 用代码沟通**
“精确地解释代码做了什么，每行代码都要加注释。不用管为什么要这样编码，只要告诉我们做了什么就好了。”
源代码可以读懂，不是因为其中的注释，而应该是由于它本身优雅而清晰。
要尽量避免使用神秘的变量名。（i常用于循环索引变量，str常用于表示字符串。如果用str表示循环索引变量，可真不是好主意）
在代码可以明确传递意图的地方，不要使用注释。
解释代码做了什么的注释用处不那么大。相反，注释要说明为什么会这样写代码。
**27 动态评估取舍**
“性能、生产力、优雅、成本以及上市时间，在软件开发过程中都是至关重要的因素。每一项都必须达到最理想的状态。”
与其花费时间去提升千分之一的性能表现，也许减少开发投入，降低成本，并尽快让应用程序上市销售更有价值。
如果现在投入额外的资源和精力，是为了将来可能得到的好处，要确认投入一定要得到回报。（大部分情况下，是不会有回报的）
**28 增量式编程**
“真正的程序员写起代码来，一干就是几个小时，根本不停，甚至连头都不抬。不要停下来去编译你的代码，只要一直往下写就好了！”
如果不对自己编写的代码进行测试，保证没有问题，就不要联系几个小时，甚至连续几分钟进行编程。相反，应该采用增量式的编程方式。
采用增量式编程和测试，会倾向于创建更小的方法和更具内聚性的类。你应该经常评估代码质量，并不时的进行许多小调整，而不是一次修改许多东西。
在写了几行代码之后，你会迫切地希望进行一次构建/测试。在没有得到反馈时，你不要走的太远。
**29 保持简单**
“通过编写史上最复杂的程序，你将会得到美誉和认可，更不用提保住你的工作了。”
Andy曾经认识一个家伙，他对设计模式非常着迷，想把它们全都用起来。有一次，要写一个大概几百行的代码程序。在被别人发现之前，他已经成功将17种设计模式，都运用到那可怜的程序中了。—这不应该是编写敏捷代码的方式。
问题在于，许多开发人员倾向于将投入的努力与程序复杂性混同起来。如果你看到别人给出的解决方案，并评价说“非常简单且易于理解”，很有可能你会让设计者不高兴。许多开发人员以自己程序的复杂性为荣，如果能听到“Wow，这很难，一定是花了很多时间和精力才做出来的吧。” 这时，他们就会面带自豪的微笑了。其实应当恰恰相反，开发人员更应该为自己能够创建出一个简单并且可用的设计而骄傲。
简单不是简陋。
**30 编写内聚的代码**
“你要编写一些新的代码，看看IDE中现在打开的是哪个类，就直接加进去吧。如果所有的代码都在一个类或组件里面，要找起来是很方便的。”
内聚性用来评估一个组建（包、模块或配件）中成员的功能相关性。内聚程度高，表明各个成员共同完成了一个功能特性或是一组功能特性。内聚程度低的话，表明各个成员提供的功能是互不相干的。
类也要遵循内聚性。如果一个类的方法和属性共同完成了一个功能，这个类就是内聚的。
不过，不要把一些东西分成很多微小的部分，而使其失去了实用价值。当你需要一只袜子的时候，一盒棉线不能带给你任何帮助。
