# c语言中有关void，sizeof，结构体的一些问题 - maopig的专栏 - CSDN博客
2011年09月07日 15:50:52[maopig](https://me.csdn.net/maopig)阅读数：1844
**void[1]：**
void是C语言中的空类型，void的用途有二。
1、对函数返回的限定；
      如果函数没有返回值，则默认返回整数类型，而不是void类型。c++有很严格的类型，不允许函数不加类型声明，而编译器则不这么认为检查这一点在VC6.0中可以验证。所以在编写代码的时候，每个函数都应该加上返回类型。
2、对函数参数的限定；
      在c++中，函数参数为void意味着不接受参数，但是在c语言中可以给无参数的函数传递任意类型的参数，这点在turbo c中可以验证。
指针的大小和机器的位数有关，在32位机器上任何类型指针的大小都是4字节，在64位机器上为8。**所以指针大小和类型无关**。
void*就是空类型指针，所谓空类型指针就是通用指针类型。它有以下特点。1、按照ASC码标准void指针不能做算术操作，因为不确定其指向数据类型大小；
2、c++允许将任何类型的指针赋给void*，但是不允许void指针赋值给其它类型。必须显示的强制转换。
其它类型指针相互之间是否也可以强制装换？
   强制转换后编译能通过，大部分情况下运行也是没有问题的，但是根据参考文献[4]的说法是容易出问题的，因为某些CPU对某些数据类型有对其限制，这样在做指针强制转换的时候就容易出现问题。
   其实，其它类型指针之间的转换完全可以通过使用void*类型来避免。
**sizeof[2]:**
前面说在同一台机器上指针大小是固定的，通过sizeof测试int*,char*,bool*,double*都出结果都是4(32位机器测试)。
今天在程序中memset一个T*类型的指针，发现没有初始化成功，原来在memset的第三个参数中填的是sizeof(T*类型的指针)。特此总结了一下sizeof的一些问题。
1、char* s="0123456789"；
      sizeof(s)=4，s是一个指针。
      sizeof(*s)=1，*s是第一个元素。
      strlen(s)=10，s是字符串首地址。
2、char s[]="0123456789"；
      sizeof(s)=11，s是字符串数组，包括'\0'。
      sizeof(*s)=1，*s是第一个元素。
      strlen(s)=10，s是字符串首地址。
3、char s[20]="0123456789"；
      sizeof(s)=20，s是在内存中静态分配的大小。
      sizeof(*s)=1，*s是第一个元素。
      strlen(s)=10，s是字符串首地址。
**结构体[3]：**
结构体在字节对齐的时候有三个原则，有了这三个原则就很容易的可以计算出任意一个结构体的sizeof大小了。
1、结构体变量的首地址能够被其最宽基本类型的成员大小所整除；
2、结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；
3、结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)。
