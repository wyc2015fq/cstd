# 动态加载和静态加载及其编译步骤 - maopig的专栏 - CSDN博客
2012年03月30日 21:15:25[maopig](https://me.csdn.net/maopig)阅读数：1586
在类unix操作系统中，驱动加载方式一般分为：动态加载和静态加载，下面分别对其详细论述。
一、动态加载
动态加载是将驱动模块加载到内核中，而不能放入/lib/modules/下。
在2.4内核中，加载驱动命令为：insmod ,删除模块为：rmmod；
在2.6以上内核中，除了insmod与rmmod外，加载命令还有modprobe；
    insmod与modprobe不同之处：
    insmod 绝对路径/××.o，而modprobe ××即可，不用加.ko或.o后缀，也不用加路径；最重要的一点是：modprobe同时会加载当前模块所依赖的其它模块；
    lsmod查看当前加载到内核中的所有驱动模块，同时提供其它一些信息，比如其它模块是否在使用另一个模块。
二、静态加载
（一）概念
在执行make menuconfig命令进行内核配置裁剪时，在窗口中可以选择是否编译入内核，还是放入/lib/modules/下相应内核版本目录中，还是不选。
（二）操作步骤
    linux设备一般分为：字符设备、块设备和网络设备，每种设备在内核源代码目录树drivers/下都有对应的目录，其加载方法类似，以下以字符设备静态加载为例，假设驱动程序源代码名为ledc.c，具体操作步骤如下：
第一步：将ledc.c源程序放入内核源码drivers/char/下；
第二步：修改drivers/char/Config.in文件，具体修改如下：
按照打开文件中的格式添加即可；
在文件的适当位置（这个位置随便都可以，但这个位置决定其在make menuconfig窗口中所在位置）加入以下任一段代码：
         tristate 'LedDriver' CONFIG_LEDC
         if [ "$CONFIG_LEDC" = "y" ];then
         bool '   Support for led on h9200 board' CONFIG_LEDC_CONSOLE
         fi
说明:以上代码使用tristate来定义一个宏,表示此驱动可以直接编译至内核（用*选择）,也可以编制至/lib/modules/下（用M选择）,
或者不编译（不选）。
         bool 'LedDriver' CONFIG_LEDC
         if [ "$CONFIG_LEDC" = "y" ];then
         bool '   Support for led on h9200 board' CONFIG_LEDC_CONSOLE
         fi
说明:以上代码使用tristate来定义一个宏,表示此驱动只能直接编译至内核（用*选择）或者不编译（不选），不能编制至/lib/modules/
下（用M选择）。
第三步：修改drivers/char/Makefile文件
在适当位置加入下面一行代码：
         obj-$(CONFIG_LEDC)   +=   ledc.o
或者在obj-y一行中加入ledc.o,如：
         obj-y += ledc.o mem.o
后面不变；
    OK，经过以上的设置就可以在执行make menuconfig命令后的窗口中的character devices--->
中进行选择配置了。选择后重新编译就ok了。
