# 进程及线程通信总结 - maopig的专栏 - CSDN博客
2012年02月19日 18:08:45[maopig](https://me.csdn.net/maopig)阅读数：1140标签：[编译器																[多线程																[system																[数据结构																[linux																[null](https://so.csdn.net/so/search/s.do?q=null&t=blog)](https://so.csdn.net/so/search/s.do?q=linux&t=blog)](https://so.csdn.net/so/search/s.do?q=数据结构&t=blog)](https://so.csdn.net/so/search/s.do?q=system&t=blog)](https://so.csdn.net/so/search/s.do?q=多线程&t=blog)](https://so.csdn.net/so/search/s.do?q=编译器&t=blog)
                
 上文我们介绍了如何建立一个简单的多线程程序，多线程之间不可避免的需要进行通信。相比于进程间通信来说，线程间通信无疑是相对比较简单的。
    首先我们来看看最简单的方法，那就是使用全局变量（静态变量也可以）来进行通信，由于属于同一个进程的各个线程是处于同一个进程空间中的，并且它们共享这个进程的各种资源，因此它们都可以毫无障碍的访问这个进程中的全局变量。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是易变的，让编译器不要对这个变量进行优化（至于编译器到底有没有按照你的要求来对volatile进行处理这个暂且不理）。
    下面贴出一段简单的示例代码：
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)#include "stdafx.h"
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)#include "windows.h"
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)#include "stdio.h"
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)volatile int ThreadData = 0;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)void ThreadProcess()
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222509.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223669.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223405.gif){
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)for(int i=0; i<6; i++)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223527.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223655.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223405.gif){
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        ThreadData +=1000;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        Sleep(1000);
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        printf("Sub  Thread Tick %5d! %5d\n",(i+1)*1000, ThreadData);
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223102.gif)    }
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    printf("Exit Sub Thread!\n");
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223141.gif)}
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222191.gif)int _tmain(int argc, _TCHAR* argv[])
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100222509.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223669.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223405.gif){
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    HANDLE hThread;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    DWORD ThreadID;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    hThread=CreateThread(NULL,
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)0,
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)                     (LPTHREAD_START_ROUTINE)ThreadProcess,
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)                     NULL,
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)0,
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)&ThreadID);
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)for(int i=0; i<10; i++)
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223527.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223655.gif)![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223405.gif){
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        ThreadData -=600;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        Sleep(600);
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)        printf("Main Thread Tick %5d! %5d\n", (i+1)*600, ThreadData);
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223102.gif)    }
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    printf("Main Thread Loop Finished! \n");
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)    system("pause");
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223970.gif)return0;
![](http://c.chinaitlab.com/UploadFiles_4204/200907/20090724100223141.gif)}
    除了全局变量之外，还有其他的方法，比如利用消息机制等来实现线程间通信。
线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。
一、互斥与同步
1.互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
2.同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源.
3.同步是一种更为复杂的互斥，而互斥是一种特殊的同步.
二、通信与同步
进程间同步本身也是一种进程间通信(因为涉及信息的交换)，当然也是一种原始的进程间通信，但同时又是更高级的进程间通信机制的基石。
对线程亦然.
三、临界区(Critical section)与互斥体(Mutex)的区别
1、临界区只能用于对象在同一进程里线程间的互斥访问；互斥体可以用于对象进程间或线程间的互斥访问。
2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。
3、临界区和互斥体在Windows平台都下可用；Linux下只有互斥体可用。
四、linux IPC
1.经典IPC：
(1)管道、命名管道       //最基本最常用
(2)消息队列、信号量、共享存储
//分为Posix IPC和System V IPC,共享存储是运行在同一台机器上的进程间通信最快的方式
2高级IPC： 流管道、命名流管道
(以上是限于同一台主机的各个进程间的IPC)
3.支持不同主机上各个进程的IPC：套接口、流
五、线程间通信机制:
1.互斥锁
2.条件变量
3.读写锁
4.信号灯
